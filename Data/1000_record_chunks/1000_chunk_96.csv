record_number,buggy_code,fixed_code,code_similarity
95001,"protected void fireChatMessage(ID fromID,ID threadID,Type type,String subject,String body,Map properties){
  fireMessageEvent(new ChatMessageEvent(fromID,new ChatMessage(threadID,createMessageType(type),subject,body,properties)));
}","protected void fireChatMessage(ID fromID,ID threadID,Type type,String subject,String body,Map properties){
  fireMessageEvent(new ChatMessageEvent(fromID,new ChatMessage(fromID,threadID,createMessageType(type),subject,body,properties)));
}",0.9851380042462844
95002,"private boolean intelligentAppend(SimpleLinkTextViewer readText,StyledText st,ChatLine text){
  String line=text.getText();
  int index=line.indexOf(""String_Node_Str"");
  if (index == -1) {
    index=line.indexOf(""String_Node_Str"");
    if (index == -1) {
      index=line.indexOf(""String_Node_Str"");
      if (index == -1) {
        return false;
      }
    }
  }
 else {
    int nextIndex=line.indexOf(""String_Node_Str"");
    if (nextIndex != -1 && nextIndex < index) {
      index=nextIndex;
    }
    nextIndex=line.indexOf(""String_Node_Str"");
    if (nextIndex != -1 && nextIndex < index) {
      index=nextIndex;
    }
  }
  int startRange=st.getText().length();
  StringBuffer sb=new StringBuffer();
  boolean nickContained=text.getText().indexOf(userName) != -1;
  if (text.getOriginator() != null) {
    nickContained=!text.getOriginator().getName().equals(userName) && nickContained;
    sb.append('(').append(getCurrentDate(DEFAULT_TIME_FORMAT)).append(""String_Node_Str"");
    StyleRange dateStyle=new StyleRange();
    dateStyle.start=startRange;
    dateStyle.length=sb.length();
    dateStyle.foreground=dateColor;
    dateStyle.fontStyle=SWT.NORMAL;
    st.append(sb.toString());
    st.setStyleRange(dateStyle);
    sb=new StringBuffer();
    sb.append(text.getOriginator().getName()).append(""String_Node_Str"");
    StyleRange sr=new StyleRange();
    sr.start=startRange + dateStyle.length;
    sr.length=sb.length();
    sr.fontStyle=SWT.BOLD;
    sr.foreground=nickContained ? highlightColor : otherColor;
    st.append(sb.toString());
    st.setStyleRange(sr);
  }
  while (index != -1) {
    String front=line.substring(0,index);
    line=line.substring(index);
    int beforeMessageIndex=st.getText().length();
    st.append(front);
    if (text.getOriginator() == null) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=front.length();
      sr.foreground=systemColor;
      sr.fontStyle=SWT.BOLD;
      st.setStyleRange(sr);
    }
 else     if (nickContained) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=front.length();
      sr.foreground=highlightColor;
      st.setStyleRange(sr);
    }
    int spaceIndex=line.indexOf(' ');
    if (spaceIndex != -1) {
      String url=line.substring(0,spaceIndex);
      if (!url.startsWith(""String_Node_Str"")) {
        readText.appendLink(url,createLinkRunnable(""String_Node_Str"" + url));
      }
 else {
        readText.appendLink(url,createLinkRunnable(url));
      }
      line=line.substring(spaceIndex);
      index=line.indexOf(""String_Node_Str"");
      if (index == -1) {
        index=line.indexOf(""String_Node_Str"");
        if (index == -1) {
          index=line.indexOf(""String_Node_Str"");
          if (index == -1) {
            return false;
          }
        }
      }
 else {
        int nextIndex=line.indexOf(""String_Node_Str"");
        if (nextIndex != -1 && nextIndex < index) {
          index=nextIndex;
        }
        nextIndex=line.indexOf(""String_Node_Str"");
        if (nextIndex != -1 && nextIndex < index) {
          index=nextIndex;
        }
      }
    }
 else {
      if (!line.startsWith(""String_Node_Str"")) {
        readText.appendLink(line,createLinkRunnable(""String_Node_Str"" + line));
      }
 else {
        readText.appendLink(line,createLinkRunnable(line));
      }
      line=null;
      break;
    }
  }
  if (line != null && !line.equals(""String_Node_Str"")) {
    int beforeMessageIndex=st.getText().length();
    st.append(line);
    if (text.getOriginator() == null) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=line.length();
      sr.foreground=systemColor;
      sr.fontStyle=SWT.BOLD;
      st.setStyleRange(sr);
    }
 else     if (nickContained) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=line.length();
      sr.foreground=highlightColor;
      st.setStyleRange(sr);
    }
  }
  if (!text.isNoCRLF()) {
    st.append(""String_Node_Str"");
  }
  return true;
}","private boolean intelligentAppend(SimpleLinkTextViewer readText,StyledText st,ChatLine text){
  String line=text.getText();
  int index=line.indexOf(""String_Node_Str"");
  if (index == -1) {
    index=line.indexOf(""String_Node_Str"");
    if (index == -1) {
      index=line.indexOf(""String_Node_Str"");
      if (index == -1) {
        return false;
      }
    }
  }
 else {
    int nextIndex=line.indexOf(""String_Node_Str"");
    if (nextIndex != -1 && nextIndex < index) {
      index=nextIndex;
    }
    nextIndex=line.indexOf(""String_Node_Str"");
    if (nextIndex != -1 && nextIndex < index) {
      index=nextIndex;
    }
  }
  int startRange=st.getText().length();
  StringBuffer sb=new StringBuffer();
  boolean nickContained=text.getText().indexOf(userName) != -1;
  if (text.getOriginator() != null) {
    nickContained=!text.getOriginator().getName().equals(userName) && nickContained;
    sb.append('(').append(getCurrentDate(DEFAULT_TIME_FORMAT)).append(""String_Node_Str"");
    StyleRange dateStyle=new StyleRange();
    dateStyle.start=startRange;
    dateStyle.length=sb.length();
    dateStyle.foreground=dateColor;
    dateStyle.fontStyle=SWT.NORMAL;
    st.append(sb.toString());
    st.setStyleRange(dateStyle);
    sb=new StringBuffer();
    sb.append(text.getOriginator().getName()).append(""String_Node_Str"");
    StyleRange sr=new StyleRange();
    sr.start=startRange + dateStyle.length;
    sr.length=sb.length();
    sr.fontStyle=SWT.BOLD;
    sr.foreground=nickContained ? highlightColor : otherColor;
    st.append(sb.toString());
    st.setStyleRange(sr);
  }
  while (index != -1) {
    String front=line.substring(0,index);
    line=line.substring(index);
    int beforeMessageIndex=st.getText().length();
    st.append(front);
    if (text.getOriginator() == null) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=front.length();
      sr.foreground=systemColor;
      sr.fontStyle=SWT.BOLD;
      st.setStyleRange(sr);
    }
 else     if (nickContained) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=front.length();
      sr.foreground=highlightColor;
      st.setStyleRange(sr);
    }
    int spaceIndex=line.indexOf(' ');
    if (spaceIndex != -1) {
      String url=line.substring(0,spaceIndex);
      int symbols=0;
      for (int i=url.length() - 1; i != 0; i--) {
        char ch=url.charAt(i);
        if (!Character.isLetterOrDigit(ch)) {
          symbols++;
        }
 else {
          break;
        }
      }
      if (!url.startsWith(""String_Node_Str"")) {
        if (symbols == 0) {
          readText.appendLink(url,createLinkRunnable(""String_Node_Str"" + url));
        }
 else {
          int symbolIndex=url.length() - symbols;
          String link=url.substring(0,symbolIndex);
          readText.appendLink(link,createLinkRunnable(""String_Node_Str"" + link));
          st.append(url.substring(symbolIndex));
        }
      }
 else {
        if (symbols == 0) {
          readText.appendLink(url,createLinkRunnable(url));
        }
 else {
          int symbolIndex=url.length() - symbols;
          String link=url.substring(0,symbolIndex);
          readText.appendLink(link,createLinkRunnable(link));
          st.append(url.substring(symbolIndex));
        }
      }
      line=line.substring(spaceIndex);
      index=line.indexOf(""String_Node_Str"");
      if (index == -1) {
        index=line.indexOf(""String_Node_Str"");
        if (index == -1) {
          index=line.indexOf(""String_Node_Str"");
          if (index == -1) {
            break;
          }
        }
      }
 else {
        int nextIndex=line.indexOf(""String_Node_Str"");
        if (nextIndex != -1 && nextIndex < index) {
          index=nextIndex;
        }
        nextIndex=line.indexOf(""String_Node_Str"");
        if (nextIndex != -1 && nextIndex < index) {
          index=nextIndex;
        }
      }
    }
 else {
      int symbols=0;
      for (int i=line.length() - 1; i != 0; i--) {
        char ch=line.charAt(i);
        if (!Character.isLetterOrDigit(ch)) {
          symbols++;
        }
 else {
          break;
        }
      }
      if (!line.startsWith(""String_Node_Str"")) {
        if (symbols == 0) {
          readText.appendLink(line,createLinkRunnable(""String_Node_Str"" + line));
        }
 else {
          int symbolIndex=line.length() - symbols;
          String link=line.substring(0,symbolIndex);
          readText.appendLink(link,createLinkRunnable(""String_Node_Str"" + link));
          st.append(line.substring(symbolIndex));
        }
      }
 else {
        if (symbols == 0) {
          readText.appendLink(line,createLinkRunnable(line));
        }
 else {
          int symbolIndex=line.length() - symbols;
          String link=line.substring(0,symbolIndex);
          readText.appendLink(link,createLinkRunnable(link));
          st.append(line.substring(symbolIndex));
        }
      }
      line=null;
      break;
    }
  }
  if (line != null && !line.equals(""String_Node_Str"")) {
    int beforeMessageIndex=st.getText().length();
    st.append(line);
    if (text.getOriginator() == null) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=line.length();
      sr.foreground=systemColor;
      sr.fontStyle=SWT.BOLD;
      st.setStyleRange(sr);
    }
 else     if (nickContained) {
      StyleRange sr=new StyleRange();
      sr.start=beforeMessageIndex;
      sr.length=line.length();
      sr.foreground=highlightColor;
      st.setStyleRange(sr);
    }
  }
  if (!text.isNoCRLF()) {
    st.append(""String_Node_Str"");
  }
  return true;
}",0.687081142385813
95003,"protected IStatus run(IProgressMonitor monitor){
  byte[] buf=new byte[buff_length];
  int totalWork=((fileLength == -1) ? 100 : (int)fileLength);
  monitor.beginTask(getRemoteFileURL().toString() + Messages.AbstractRetrieveFileTransfer_Progress_Data,totalWork);
  try {
    while (!isDone()) {
      if (monitor.isCanceled())       throw new UserCancelledException(Messages.AbstractRetrieveFileTransfer_Exception_User_Cancelled);
      int bytes=remoteFileContents.read(buf);
      if (bytes != -1) {
        bytesReceived+=bytes;
        localFileContents.write(buf,0,bytes);
        fireTransferReceiveDataEvent();
        monitor.worked(bytes);
      }
 else       done=true;
    }
  }
 catch (  Exception e) {
    exception=e;
    done=true;
  }
 finally {
    hardClose();
    monitor.done();
    fireTransferReceiveDoneEvent();
  }
  return getFinalStatus(exception);
}","protected IStatus run(IProgressMonitor monitor){
  byte[] buf=new byte[buff_length];
  int totalWork=((fileLength == -1) ? 100 : (int)fileLength);
  monitor.beginTask(getRemoteFileURL().toString() + Messages.AbstractRetrieveFileTransfer_Progress_Data,totalWork);
  try {
    while (!isDone()) {
      if (monitor.isCanceled())       throw new UserCancelledException(Messages.AbstractRetrieveFileTransfer_Exception_User_Cancelled);
      int bytes=remoteFileContents.read(buf);
      if (bytes != -1) {
        bytesReceived+=bytes;
        localFileContents.write(buf,0,bytes);
        fireTransferReceiveDataEvent();
        monitor.worked(bytes);
      }
 else {
        done=true;
        if (closeOutputStream) {
          localFileContents.close();
        }
      }
    }
  }
 catch (  Exception e) {
    exception=e;
    done=true;
  }
 finally {
    hardClose();
    monitor.done();
    fireTransferReceiveDoneEvent();
  }
  return getFinalStatus(exception);
}",0.9501084598698482
95004,"protected void hardClose(){
  try {
    if (remoteFileContents != null) {
      remoteFileContents.close();
    }
  }
 catch (  IOException e) {
  }
  try {
    if (closeOutputStream && localFileContents != null)     localFileContents.close();
  }
 catch (  IOException e) {
  }
  job=null;
  remoteFileContents=null;
  localFileContents=null;
}","protected void hardClose(){
  try {
    if (remoteFileContents != null) {
      remoteFileContents.close();
    }
  }
 catch (  IOException e) {
  }
  try {
    if (localFileContents != null && closeOutputStream) {
      localFileContents.close();
    }
  }
 catch (  IOException e) {
  }
  job=null;
  remoteFileContents=null;
  localFileContents=null;
}",0.8628571428571429
95005,"protected void openStreams(Map options) throws IncomingFileTransferException {
  URL theURL=null;
  try {
    theURL=getRemoteFileURL();
    urlConnection=theURL.openConnection();
    setInputStream(urlConnection.getInputStream());
    setFileLength(urlConnection.getContentLength());
    fileid=new FileTransferID(getRetrieveNamespace(),theURL);
    listener.handleTransferEvent(new IIncomingFileTransferReceiveStartEvent(){
      private static final long serialVersionUID=-59096575294481755L;
      public IFileID getFileID(){
        return remoteFileID;
      }
      public IIncomingFileTransfer receive(      File localFileToSave) throws IOException {
        setOutputStream(new BufferedOutputStream(new FileOutputStream(localFileToSave)));
        job=new FileTransferJob(getRemoteFileURL().toString());
        job.schedule();
        return UrlConnectionRetrieveFileTransfer.this;
      }
      public String toString(){
        StringBuffer sb=new StringBuffer(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(done).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(bytesReceived).append(""String_Node_Str"");
        return sb.toString();
      }
      public void cancel(){
        hardClose();
      }
      public IIncomingFileTransfer receive(      OutputStream streamToStore) throws IOException {
        setOutputStream(new BufferedOutputStream(streamToStore));
        setCloseOutputStream(false);
        job=new FileTransferJob(getRemoteFileURL().toString());
        job.schedule();
        return UrlConnectionRetrieveFileTransfer.this;
      }
    }
);
  }
 catch (  Exception e) {
    throw new IncomingFileTransferException(""String_Node_Str"" + theURL.toString(),e);
  }
}","protected void openStreams(Map options) throws IncomingFileTransferException {
  URL theURL=null;
  try {
    theURL=getRemoteFileURL();
    urlConnection=theURL.openConnection();
    setInputStream(urlConnection.getInputStream());
    setFileLength(urlConnection.getContentLength());
    fileid=new FileTransferID(getRetrieveNamespace(),theURL);
    listener.handleTransferEvent(new IIncomingFileTransferReceiveStartEvent(){
      private static final long serialVersionUID=-59096575294481755L;
      public IFileID getFileID(){
        return remoteFileID;
      }
      public IIncomingFileTransfer receive(      File localFileToSave) throws IOException {
        setOutputStream(new BufferedOutputStream(new FileOutputStream(localFileToSave)));
        job=new FileTransferJob(getRemoteFileURL().toString());
        job.schedule();
        return UrlConnectionRetrieveFileTransfer.this;
      }
      public String toString(){
        StringBuffer sb=new StringBuffer(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(done).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(bytesReceived).append(""String_Node_Str"");
        return sb.toString();
      }
      public void cancel(){
        hardClose();
      }
      public IIncomingFileTransfer receive(      OutputStream streamToStore) throws IOException {
        setOutputStream(streamToStore);
        setCloseOutputStream(false);
        job=new FileTransferJob(getRemoteFileURL().toString());
        job.schedule();
        return UrlConnectionRetrieveFileTransfer.this;
      }
    }
);
  }
 catch (  Exception e) {
    throw new IncomingFileTransferException(""String_Node_Str"" + theURL.toString(),e);
  }
}",0.992437463641652
95006,"public IIncomingFileTransfer receive(OutputStream streamToStore) throws IOException {
  setOutputStream(new BufferedOutputStream(streamToStore));
  setCloseOutputStream(false);
  job=new FileTransferJob(getRemoteFileURL().toString());
  job.schedule();
  return UrlConnectionRetrieveFileTransfer.this;
}","public IIncomingFileTransfer receive(OutputStream streamToStore) throws IOException {
  setOutputStream(streamToStore);
  setCloseOutputStream(false);
  job=new FileTransferJob(getRemoteFileURL().toString());
  job.schedule();
  return UrlConnectionRetrieveFileTransfer.this;
}",0.9103448275862068
95007,"public void handleTransferEvent(IFileTransferEvent event){
  if (event instanceof IIncomingFileTransferReceiveStartEvent) {
    IIncomingFileTransferReceiveStartEvent rse=(IIncomingFileTransferReceiveStartEvent)event;
    targetFile=new File(TESTTARGETPATH,rse.getFileID().getFilename());
    printFileInfo(""String_Node_Str"",event,targetFile);
    try {
      bufferedStream=new BufferedOutputStream(new FileOutputStream(targetFile));
      rse.receive(bufferedStream);
    }
 catch (    IOException e) {
      e.printStackTrace();
      fail(e.getLocalizedMessage());
    }
  }
 else   if (event instanceof IIncomingFileTransferReceiveDataEvent) {
    printFileInfo(""String_Node_Str"",event,targetFile);
  }
 else   if (event instanceof IIncomingFileTransferReceiveDoneEvent) {
    printFileInfo(""String_Node_Str"",event,targetFile);
    assertTrue(srcFile.length() == targetFile.length());
  }
 else {
    printFileInfo(""String_Node_Str"",event,targetFile);
  }
}","public void handleTransferEvent(IFileTransferEvent event){
  if (event instanceof IIncomingFileTransferReceiveStartEvent) {
    IIncomingFileTransferReceiveStartEvent rse=(IIncomingFileTransferReceiveStartEvent)event;
    targetFile=new File(TESTTARGETPATH,rse.getFileID().getFilename());
    printFileInfo(""String_Node_Str"",event,targetFile);
    try {
      bufferedStream=new BufferedOutputStream(new FileOutputStream(targetFile));
      rse.receive(bufferedStream);
    }
 catch (    IOException e) {
      e.printStackTrace();
      fail(e.getLocalizedMessage());
    }
  }
 else   if (event instanceof IIncomingFileTransferReceiveDataEvent) {
    printFileInfo(""String_Node_Str"",event,targetFile);
  }
 else   if (event instanceof IIncomingFileTransferReceiveDoneEvent) {
    try {
      bufferedStream.flush();
      printFileInfo(""String_Node_Str"",event,targetFile);
      assertTrue(srcFile.length() == targetFile.length());
    }
 catch (    IOException e) {
      e.printStackTrace();
      fail(e.getLocalizedMessage());
    }
  }
 else {
    printFileInfo(""String_Node_Str"",event,targetFile);
  }
}",0.9281234925229136
95008,"protected void setUp() throws Exception {
  super.setUp();
  clients=createClients();
  Enumeration files=Activator.getDefault().getBundle().getEntryPaths(TESTSRCPATH);
  for (; files.hasMoreElements(); ) {
    URL url=Activator.getDefault().getBundle().getEntry((String)files.nextElement());
    srcFiles.add(url.toExternalForm());
  }
  File targetDir=new File(TESTTARGETPATH);
  targetDir.mkdirs();
}","protected void setUp() throws Exception {
  super.setUp();
  clients=createClients();
  Enumeration files=Activator.getDefault().getBundle().getEntryPaths(TESTSRCPATH);
  for (; files.hasMoreElements(); ) {
    URL url=Activator.getDefault().getBundle().getEntry((String)files.nextElement());
    String file=url.getFile();
    if (file != null && !file.equals(""String_Node_Str"") && !file.endsWith(""String_Node_Str"")) {
      srcFiles.add(url.toExternalForm());
    }
  }
  File targetDir=new File(TESTTARGETPATH);
  targetDir.mkdirs();
}",0.8501594048884166
95009,"protected void testReceive(String url) throws Exception {
  final File srcFile=new File(url);
  IRetrieveFileTransferContainerAdapter retrieveAdapter=(IRetrieveFileTransferContainerAdapter)getClients()[0].getAdapter(IRetrieveFileTransferContainerAdapter.class);
  assertNotNull(retrieveAdapter);
  IFileTransferListener listener=new IFileTransferListener(){
    File targetFile=null;
    BufferedOutputStream bufferedStream=null;
    public void handleTransferEvent(    IFileTransferEvent event){
      if (event instanceof IIncomingFileTransferReceiveStartEvent) {
        IIncomingFileTransferReceiveStartEvent rse=(IIncomingFileTransferReceiveStartEvent)event;
        targetFile=new File(TESTTARGETPATH,rse.getFileID().getFilename());
        printFileInfo(""String_Node_Str"",event,targetFile);
        try {
          bufferedStream=new BufferedOutputStream(new FileOutputStream(targetFile));
          rse.receive(bufferedStream);
        }
 catch (        IOException e) {
          e.printStackTrace();
          fail(e.getLocalizedMessage());
        }
      }
 else       if (event instanceof IIncomingFileTransferReceiveDataEvent) {
        printFileInfo(""String_Node_Str"",event,targetFile);
      }
 else       if (event instanceof IIncomingFileTransferReceiveDoneEvent) {
        printFileInfo(""String_Node_Str"",event,targetFile);
        assertTrue(srcFile.length() == targetFile.length());
      }
 else {
        printFileInfo(""String_Node_Str"",event,targetFile);
      }
    }
  }
;
  retrieveAdapter.sendRetrieveRequest(FileIDFactory.getDefault().createFileID(retrieveAdapter.getRetrieveNamespace(),url),listener,null);
}","protected void testReceive(String url) throws Exception {
  final File srcFile=new File(url);
  IRetrieveFileTransferContainerAdapter retrieveAdapter=(IRetrieveFileTransferContainerAdapter)getClients()[0].getAdapter(IRetrieveFileTransferContainerAdapter.class);
  assertNotNull(retrieveAdapter);
  IFileTransferListener listener=new IFileTransferListener(){
    File targetFile=null;
    BufferedOutputStream bufferedStream=null;
    public void handleTransferEvent(    IFileTransferEvent event){
      if (event instanceof IIncomingFileTransferReceiveStartEvent) {
        IIncomingFileTransferReceiveStartEvent rse=(IIncomingFileTransferReceiveStartEvent)event;
        targetFile=new File(TESTTARGETPATH,rse.getFileID().getFilename());
        printFileInfo(""String_Node_Str"",event,targetFile);
        try {
          bufferedStream=new BufferedOutputStream(new FileOutputStream(targetFile));
          rse.receive(bufferedStream);
        }
 catch (        IOException e) {
          e.printStackTrace();
          fail(e.getLocalizedMessage());
        }
      }
 else       if (event instanceof IIncomingFileTransferReceiveDataEvent) {
        printFileInfo(""String_Node_Str"",event,targetFile);
      }
 else       if (event instanceof IIncomingFileTransferReceiveDoneEvent) {
        try {
          bufferedStream.flush();
          printFileInfo(""String_Node_Str"",event,targetFile);
          assertTrue(srcFile.length() == targetFile.length());
        }
 catch (        IOException e) {
          e.printStackTrace();
          fail(e.getLocalizedMessage());
        }
      }
 else {
        printFileInfo(""String_Node_Str"",event,targetFile);
      }
    }
  }
;
  retrieveAdapter.sendRetrieveRequest(FileIDFactory.getDefault().createFileID(retrieveAdapter.getRetrieveNamespace(),url),listener,null);
}",0.94874022589053
95010,"protected IRCEventListener getIRCEventListener(){
  return new IRCEventListener(){
    public void onRegistered(){
      trace(""String_Node_Str"");
synchronized (connectLock) {
        connectWaiting=false;
        connectLock.notify();
      }
    }
    public void onDisconnected(){
      trace(""String_Node_Str"");
synchronized (connectLock) {
        if (connectWaiting) {
          if (connectException == null)           connectException=new Exception(Messages.IRCRootContainer_Exception_Unexplained_Disconnect);
          connectWaiting=false;
          connectLock.notify();
        }
      }
      showMessage(null,NLS.bind(Messages.IRCRootContainer_Disconnected,targetID.getName()));
      handleDisconnected();
    }
    public void onError(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
      showMessage(null,NLS.bind(Messages.IRCRootContainer_Error,arg0));
      handleErrorIfConnecting(arg0);
    }
    public void onError(    int arg0,    String arg1){
      String msg=arg0 + ""String_Node_Str"" + arg1;
      trace(""String_Node_Str"" + msg + ""String_Node_Str"");
      showMessage(null,NLS.bind(Messages.IRCRootContainer_Error,msg));
      handleErrorIfConnecting(arg0 + msg);
    }
    public void onInvite(    String arg0,    IRCUser arg1,    String arg2){
      handleInvite(createIDFromString(arg0),createIDFromString(arg1.getNick()));
    }
    public void onJoin(    String arg0,    IRCUser arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      IRCChannelContainer container=getChannel(arg0);
      if (container != null) {
        container.setIRCUser(arg1);
      }
    }
    public void onKick(    String channelName,    IRCUser kicker,    String kicked,    String reason){
      trace(""String_Node_Str"" + channelName + ""String_Node_Str""+ kicker+ ""String_Node_Str""+ kicked+ ""String_Node_Str""+ reason+ ""String_Node_Str"");
      IRCChannelContainer channel=getChannel(channelName);
      if (channel != null) {
        showMessage(channelName,NLS.bind(Messages.IRCRootContainer_UserKicked,new Object[]{kicker.getNick(),kicked,channelName,reason}));
        if (kicked.equals(((IRCID)targetID).getUsername())) {
          channel.fireContainerEvent(new ContainerDisconnectingEvent(channel.getID(),channel.targetID));
          channel.firePresenceListeners(false,new String[]{kicked});
          channel.fireContainerEvent(new ContainerDisconnectedEvent(channel.getID(),channel.targetID));
        }
 else {
          channel.firePresenceListeners(false,new String[]{kicked});
        }
      }
    }
    public void onMode(    String arg0,    IRCUser arg1,    IRCModeParser arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onMode(    IRCUser arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onNick(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
    }
    public void onNotice(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg2);
    }
    public void onPart(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      IRCChannelContainer channel=(IRCChannelContainer)channels.get(arg0);
      if (channel != null) {
        channel.firePresenceListeners(false,new String[]{getIRCUserName(arg1)});
      }
    }
    public void onPing(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
synchronized (IRCRootContainer.this) {
        if (connection != null) {
          connection.doPong(arg0);
        }
      }
    }
    public void onPrivmsg(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg1.toString(),arg2);
    }
    public void onQuit(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      for (Iterator i=channels.values().iterator(); i.hasNext(); ) {
        IRCChannelContainer container=(IRCChannelContainer)i.next();
        container.handleUserQuit(getIRCUserName(arg0));
      }
    }
    public void onReply(    int arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      replyHandler.handleReply(arg0,arg1,arg2);
    }
    public void onTopic(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      handleSetSubject(arg0,arg1,arg2);
    }
    public void unknown(    String arg0,    String arg1,    String arg2,    String arg3){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3+ ""String_Node_Str"");
      showMessage(null,NLS.bind(Messages.IRCRootContainer_Unknown_Message,new Object[]{arg0,arg1,arg2,arg3}));
    }
  }
;
}","protected IRCEventListener getIRCEventListener(){
  return new IRCEventListener(){
    public void onRegistered(){
      trace(""String_Node_Str"");
synchronized (connectLock) {
        connectWaiting=false;
        connectLock.notify();
      }
    }
    public void onDisconnected(){
      trace(""String_Node_Str"");
synchronized (connectLock) {
        if (connectWaiting) {
          if (connectException == null)           connectException=new Exception(Messages.IRCRootContainer_Exception_Unexplained_Disconnect);
          connectWaiting=false;
          connectLock.notify();
        }
      }
      if (targetID != null) {
        showMessage(null,NLS.bind(Messages.IRCRootContainer_Disconnected,targetID.getName()));
        handleDisconnected();
      }
    }
    public void onError(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
      showMessage(null,NLS.bind(Messages.IRCRootContainer_Error,arg0));
      handleErrorIfConnecting(arg0);
    }
    public void onError(    int arg0,    String arg1){
      String msg=arg0 + ""String_Node_Str"" + arg1;
      trace(""String_Node_Str"" + msg + ""String_Node_Str"");
      showMessage(null,NLS.bind(Messages.IRCRootContainer_Error,msg));
      handleErrorIfConnecting(arg0 + msg);
    }
    public void onInvite(    String arg0,    IRCUser arg1,    String arg2){
      handleInvite(createIDFromString(arg0),createIDFromString(arg1.getNick()));
    }
    public void onJoin(    String arg0,    IRCUser arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      IRCChannelContainer container=getChannel(arg0);
      if (container != null) {
        container.setIRCUser(arg1);
      }
    }
    public void onKick(    String channelName,    IRCUser kicker,    String kicked,    String reason){
      trace(""String_Node_Str"" + channelName + ""String_Node_Str""+ kicker+ ""String_Node_Str""+ kicked+ ""String_Node_Str""+ reason+ ""String_Node_Str"");
      IRCChannelContainer channel=getChannel(channelName);
      if (channel != null) {
        showMessage(channelName,NLS.bind(Messages.IRCRootContainer_UserKicked,new Object[]{kicker.getNick(),kicked,channelName,reason}));
        if (kicked.equals(((IRCID)targetID).getUsername())) {
          channel.fireContainerEvent(new ContainerDisconnectingEvent(channel.getID(),channel.targetID));
          channel.firePresenceListeners(false,new String[]{kicked});
          channel.fireContainerEvent(new ContainerDisconnectedEvent(channel.getID(),channel.targetID));
        }
 else {
          channel.firePresenceListeners(false,new String[]{kicked});
        }
      }
    }
    public void onMode(    String arg0,    IRCUser arg1,    IRCModeParser arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onMode(    IRCUser arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onNick(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
    }
    public void onNotice(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg2);
    }
    public void onPart(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      IRCChannelContainer channel=(IRCChannelContainer)channels.get(arg0);
      if (channel != null) {
        channel.firePresenceListeners(false,new String[]{getIRCUserName(arg1)});
      }
    }
    public void onPing(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
synchronized (IRCRootContainer.this) {
        if (connection != null) {
          connection.doPong(arg0);
        }
      }
    }
    public void onPrivmsg(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg1.toString(),arg2);
    }
    public void onQuit(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      for (Iterator i=channels.values().iterator(); i.hasNext(); ) {
        IRCChannelContainer container=(IRCChannelContainer)i.next();
        container.handleUserQuit(getIRCUserName(arg0));
      }
    }
    public void onReply(    int arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      replyHandler.handleReply(arg0,arg1,arg2);
    }
    public void onTopic(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      handleSetSubject(arg0,arg1,arg2);
    }
    public void unknown(    String arg0,    String arg1,    String arg2,    String arg3){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3+ ""String_Node_Str"");
      showMessage(null,NLS.bind(Messages.IRCRootContainer_Unknown_Message,new Object[]{arg0,arg1,arg2,arg3}));
    }
  }
;
}",0.9960973796692064
95011,"public void onDisconnected(){
  trace(""String_Node_Str"");
synchronized (connectLock) {
    if (connectWaiting) {
      if (connectException == null)       connectException=new Exception(Messages.IRCRootContainer_Exception_Unexplained_Disconnect);
      connectWaiting=false;
      connectLock.notify();
    }
  }
  showMessage(null,NLS.bind(Messages.IRCRootContainer_Disconnected,targetID.getName()));
  handleDisconnected();
}","public void onDisconnected(){
  trace(""String_Node_Str"");
synchronized (connectLock) {
    if (connectWaiting) {
      if (connectException == null)       connectException=new Exception(Messages.IRCRootContainer_Exception_Unexplained_Disconnect);
      connectWaiting=false;
      connectLock.notify();
    }
  }
  if (targetID != null) {
    showMessage(null,NLS.bind(Messages.IRCRootContainer_Disconnected,targetID.getName()));
    handleDisconnected();
  }
}",0.9617117117117115
95012,"protected void firePresenceListeners(boolean joined,String[] users){
  for (Iterator i=participantListeners.iterator(); i.hasNext(); ) {
    IChatRoomParticipantListener l=(IChatRoomParticipantListener)i.next();
    for (int j=0; j < users.length; j++) {
      ID fromID=createIDFromString(users[j]);
      boolean localUserIsChannelOperator=isLocalUserChannelOperator(users[j]);
      if (localUserIsChannelOperator)       setChannelOperator(true);
      l.handlePresence(fromID,createPresence(joined));
      if (joined)       l.handleArrivedInChat(fromID);
 else       l.handleDepartedFromChat(fromID);
    }
  }
}","protected void firePresenceListeners(boolean joined,String[] users){
  for (int i=0; i < users.length; i++) {
    if (joined)     addChannelParticipant(createIDFromString(users[i]));
 else     removeChannelParticipant(createIDFromString(users[i]));
  }
  for (Iterator i=participantListeners.iterator(); i.hasNext(); ) {
    IChatRoomParticipantListener l=(IChatRoomParticipantListener)i.next();
    for (int j=0; j < users.length; j++) {
      ID fromID=createIDFromString(users[j]);
      boolean localUserIsChannelOperator=isLocalUserChannelOperator(users[j]);
      if (localUserIsChannelOperator)       setChannelOperator(true);
      if (joined)       l.handleArrivedInChat(fromID);
      l.handlePresence(fromID,createPresence(joined));
      if (!joined)       l.handleDepartedFromChat(fromID);
    }
  }
}",0.5604472396925227
95013,"protected void handleUserQuit(String name){
  firePresenceListeners(false,new String[]{name});
}","protected void handleUserQuit(String name){
  if (containsChannelParticipant(createIDFromString(name)))   firePresenceListeners(false,new String[]{name});
}",0.7619047619047619
95014,"public String getStatus(){
  return ""String_Node_Str"";
}","public String getStatus(){
  return null;
}",0.8080808080808081
95015,"protected void setChannelOperator(boolean channelOperator){
  this.channelOperator=channelOperator;
}","protected void setChannelOperator(String channelOperator){
  this.channelOperator=channelOperator;
}",0.945273631840796
95016,"protected void firePresenceListeners(boolean joined,String[] users){
  for (int i=0; i < users.length; i++) {
    if (joined)     addChannelParticipant(createIDFromString(users[i]));
 else     removeChannelParticipant(createIDFromString(users[i]));
  }
  for (Iterator i=participantListeners.iterator(); i.hasNext(); ) {
    IChatRoomParticipantListener l=(IChatRoomParticipantListener)i.next();
    for (int j=0; j < users.length; j++) {
      ID fromID=createIDFromString(users[j]);
      boolean localUserIsChannelOperator=isLocalUserChannelOperator(users[j]);
      if (localUserIsChannelOperator)       setChannelOperator(true);
      if (joined)       l.handleArrivedInChat(fromID);
      l.handlePresence(fromID,createPresence(joined));
      if (!joined)       l.handleDepartedFromChat(fromID);
    }
  }
}","protected void firePresenceListeners(boolean joined,String[] users){
  for (int j=0; j < users.length; j++) {
    if (joined) {
      if (isChannelOperator(users[j]))       setChannelOperator(users[j]);
      ID participantID=createIDFromString(users[j]);
      if (addChannelParticipant(participantID)) {
        for (Iterator i=participantListeners.iterator(); i.hasNext(); ) {
          IChatRoomParticipantListener l=(IChatRoomParticipantListener)i.next();
          l.handleArrivedInChat(participantID);
          l.handlePresence(participantID,createPresence(true));
        }
      }
    }
 else {
      ID removeID=removeChannelParticipant(createIDFromString(users[j]));
      if (removeID != null) {
        for (Iterator i=participantListeners.iterator(); i.hasNext(); ) {
          IChatRoomParticipantListener l=(IChatRoomParticipantListener)i.next();
          l.handlePresence(removeID,createPresence(false));
          l.handleDepartedFromChat(removeID);
        }
      }
    }
  }
}",0.265857694429123
95017,"protected boolean containsChannelParticipant(ID participantID){
  return channelParticipants.contains(participantID);
}","protected ID containsChannelParticipant(ID participantID){
  if (channelParticipants.contains(participantID))   return participantID;
  ID operatorID=createIDFromString(OPERATOR_PREFIX + participantID.getName());
  if (channelParticipants.contains(operatorID))   return operatorID;
  return null;
}",0.5035971223021583
95018,"protected void handleUserQuit(String name){
  if (containsChannelParticipant(createIDFromString(name)))   firePresenceListeners(false,new String[]{name});
}","protected void handleUserQuit(String name){
  if (containsChannelParticipant(createIDFromString(name)) != null)   firePresenceListeners(false,new String[]{name});
}",0.975
95019,"public Map getProperties(){
  return null;
}","public Map getProperties(){
  return properties;
}",0.851063829787234
95020,"protected boolean isChannelOperator(){
  return channelOperator;
}","protected boolean isChannelOperator(String user){
  if (user != null && user.startsWith(OPERATOR_PREFIX))   return true;
  return false;
}",0.5196078431372549
95021,"protected boolean isLocalUserChannelOperator(String user){
  if (!user.startsWith(OPERATOR_PREFIX))   return false;
  String localUserName=(ircUser == null) ? null : (OPERATOR_PREFIX + ircUser.getNick());
  if (localUserName == null)   return false;
  if (user.equals(localUserName))   return true;
  return false;
}","protected boolean isLocalUserChannelOperator(String channelOperator){
  if (!isChannelOperator(channelOperator))   return false;
  String localUserName=(ircUser == null) ? null : (OPERATOR_PREFIX + ircUser.getNick());
  if (localUserName == null)   return false;
  if (channelOperator.equals(localUserName))   return true;
  return false;
}",0.6402439024390244
95022,"private IPresence createPresence(final boolean available){
  return new IPresence(){
    private static final long serialVersionUID=1L;
    public Mode getMode(){
      return (available ? IPresence.Mode.AVAILABLE : IPresence.Mode.AWAY);
    }
    public Map getProperties(){
      return null;
    }
    public String getStatus(){
      return ""String_Node_Str"";
    }
    public Type getType(){
      return (available ? IPresence.Type.AVAILABLE : IPresence.Type.UNAVAILABLE);
    }
    public Object getAdapter(    Class adapter){
      return null;
    }
    public byte[] getPictureData(){
      return new byte[0];
    }
  }
;
}","private IPresence createPresence(final boolean available){
  return new IPresence(){
    private static final long serialVersionUID=1L;
    Map properties=new HashMap();
    public Mode getMode(){
      return (available ? IPresence.Mode.AVAILABLE : IPresence.Mode.AWAY);
    }
    public Map getProperties(){
      return properties;
    }
    public String getStatus(){
      return null;
    }
    public Type getType(){
      return (available ? IPresence.Type.AVAILABLE : IPresence.Type.UNAVAILABLE);
    }
    public Object getAdapter(    Class adapter){
      return null;
    }
    public byte[] getPictureData(){
      return new byte[0];
    }
  }
;
}",0.9467181467181468
95023,"protected boolean removeChannelParticipant(ID participantID){
  return channelParticipants.remove(participantID);
}","protected ID removeChannelParticipant(ID participantID){
  if (channelParticipants.remove(participantID))   return participantID;
  ID operatorID=createIDFromString(OPERATOR_PREFIX + participantID.getName());
  if (channelParticipants.remove(operatorID))   return operatorID;
  return null;
}",0.4963144963144963
95024,"protected void addChannelParticipant(ID participantID){
  channelParticipants.add(participantID);
}","protected boolean addChannelParticipant(ID participantID){
  if (containsChannelParticipant(participantID) == null) {
    channelParticipants.add(participantID);
    return true;
  }
 else   return false;
}",0.6163934426229508
95025,"public void handleDepartedFromChat(ID participant){
  chatroomview.handleLeave(participant);
}","public void handleDepartedFromChat(ID participant){
}",0.7210884353741497
95026,"protected void doJoin(final String target,final String key){
  ChatRoom room=(ChatRoom)rooms.get(target);
  if (room != null && room.isConnected()) {
    room.setSelected();
    return;
  }
  IChatRoomInfo roomInfo=chatRoomManager.getChatRoomInfo(target);
  if (roomInfo == null)   return;
 else {
    try {
      final IChatRoomContainer chatRoomContainer=roomInfo.createChatRoomContainer();
      final ChatRoom chatroomview=new ChatRoom(chatRoomContainer,new Manager(tabFolder,target));
      chatRoomContainer.addMessageListener(new IIMMessageListener(){
        public void handleMessageEvent(        IIMMessageEvent messageEvent){
          if (messageEvent instanceof IChatRoomMessageEvent) {
            IChatRoomMessage m=((IChatRoomMessageEvent)messageEvent).getChatRoomMessage();
            chatroomview.handleMessage(m.getFromID(),m.getMessage());
          }
        }
      }
);
      chatRoomContainer.addChatRoomParticipantListener(new IChatRoomParticipantListener(){
        public void handlePresence(        ID fromID,        IPresence presence){
          chatroomview.handlePresence(fromID,presence);
        }
        public void handleArrivedInChat(        ID participant){
          chatroomview.handleJoin(participant);
        }
        public void handleDepartedFromChat(        ID participant){
          chatroomview.handleLeave(participant);
        }
      }
);
      chatRoomContainer.addListener(new IContainerListener(){
        public void handleEvent(        IContainerEvent evt){
          if (evt instanceof IContainerDisconnectedEvent) {
            chatroomview.disconnected();
          }
        }
      }
);
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          try {
            chatRoomContainer.connect(IDFactory.getDefault().createID(chatRoomContainer.getConnectNamespace(),target),ConnectContextFactory.createPasswordConnectContext(key));
            rooms.put(target,chatroomview);
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","protected void doJoin(final String target,final String key){
  ChatRoom room=(ChatRoom)rooms.get(target);
  if (room != null && room.isConnected()) {
    room.setSelected();
    return;
  }
  IChatRoomInfo roomInfo=chatRoomManager.getChatRoomInfo(target);
  if (roomInfo == null)   return;
 else {
    try {
      final IChatRoomContainer chatRoomContainer=roomInfo.createChatRoomContainer();
      final ChatRoom chatroomview=new ChatRoom(chatRoomContainer,new Manager(tabFolder,target));
      chatRoomContainer.addMessageListener(new IIMMessageListener(){
        public void handleMessageEvent(        IIMMessageEvent messageEvent){
          if (messageEvent instanceof IChatRoomMessageEvent) {
            IChatRoomMessage m=((IChatRoomMessageEvent)messageEvent).getChatRoomMessage();
            chatroomview.handleMessage(m.getFromID(),m.getMessage());
          }
        }
      }
);
      chatRoomContainer.addChatRoomParticipantListener(new IChatRoomParticipantListener(){
        public void handlePresence(        ID fromID,        IPresence presence){
          chatroomview.handlePresence(fromID,presence);
        }
        public void handleArrivedInChat(        ID participant){
        }
        public void handleDepartedFromChat(        ID participant){
        }
      }
);
      chatRoomContainer.addListener(new IContainerListener(){
        public void handleEvent(        IContainerEvent evt){
          if (evt instanceof IContainerDisconnectedEvent) {
            chatroomview.disconnected();
          }
        }
      }
);
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          try {
            chatRoomContainer.connect(IDFactory.getDefault().createID(chatRoomContainer.getConnectNamespace(),target),ConnectContextFactory.createPasswordConnectContext(key));
            rooms.put(target,chatroomview);
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.9769212467285272
95027,"public void handleArrivedInChat(ID participant){
  chatroomview.handleJoin(participant);
}","public void handleArrivedInChat(ID participant){
}",0.7142857142857143
95028,"public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().asyncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null && !otherUsers.contains(fromID)) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
      }
    }
  }
);
}","public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().asyncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
      }
    }
  }
);
}",0.7918367346938775
95029,"protected void removeParticipant(IUser p){
  if (p != null) {
    ID id=p.getID();
    if (id != null) {
      if (otherUsers.contains(id))       appendText(outputText,new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ trimUserID(id)+ ""String_Node_Str"",null));
      memberViewer.remove(p);
    }
  }
}","protected void removeParticipant(IUser p){
  if (p != null) {
    ID id=p.getID();
    if (id != null) {
      appendText(outputText,new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ trimUserID(id)+ ""String_Node_Str"",null));
      memberViewer.remove(p);
    }
  }
}",0.4344941956882255
95030,"public void handleRosterEntryUpdate(final IRosterEntry entry){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      rosterView.handleRosterEntryAdd(PresenceContainerUI.this.groupID,entry);
    }
  }
);
}","public void handleRosterEntryUpdate(final IRosterEntry entry){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      rosterView.handleRosterEntryUpdate(PresenceContainerUI.this.groupID,entry);
    }
  }
);
}",0.9803063457330417
95031,"protected void setup(final IContainer container,final ID localUser,final String nick){
  this.container=container;
  this.soContainer=(ISharedObjectContainer)this.container.getAdapter(ISharedObjectContainer.class);
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        PresenceContainerUI.this.localUser=new org.eclipse.ecf.core.user.User(localUser,nickname);
      }
 catch (      Exception e) {
        ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,SEND_ERRORCODE,""String_Node_Str"",e));
      }
    }
  }
);
  chatManager.addMessageListener(new IIMMessageListener(){
    public void handleMessageEvent(    final IIMMessageEvent chatMessageEvent){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (chatMessageEvent instanceof IChatMessageEvent) {
            rosterView.handleMessageEvent(chatMessageEvent);
          }
 else           if (chatMessageEvent instanceof ITypingMessageEvent) {
            rosterView.handleTyping(chatMessageEvent.getFromID());
          }
        }
      }
);
    }
  }
);
  container.addListener(new IContainerListener(){
    public void handleEvent(    IContainerEvent event){
      if (event instanceof IContainerConnectedEvent) {
        IContainerConnectedEvent cce=(IContainerConnectedEvent)event;
        final ID joinedContainer=cce.getTargetID();
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            ILocalInputHandler handler=new ILocalInputHandler(){
              public void inputText(              ID userID,              String text){
                try {
                  chatMessageSender.sendChatMessage(userID,text);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void startTyping(              ID userID){
                try {
                  typingMessageSender.sendTypingMessage(userID,true,""String_Node_Str"");
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void disconnect(){
                container.disconnect();
              }
              public void updatePresence(              ID userID,              IPresence presence){
                try {
                  presenceSender.sendPresenceUpdate(userID,presence);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void sendRosterAdd(              String user,              String name,              String[] groups){
                try {
                  rosterSubscriptionSender.sendRosterAdd(user,name,groups);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void sendRosterRemove(              ID userID){
                try {
                  rosterSubscriptionSender.sendRosterRemove(userID);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
            }
;
            PresenceContainerUI.this.groupID=joinedContainer;
            rosterView.addAccount(joinedContainer,PresenceContainerUI.this.localUser,handler,pc,soContainer);
          }
        }
);
      }
 else       if (event instanceof IContainerDisconnectedEvent) {
        final IContainerDisconnectedEvent de=(IContainerDisconnectedEvent)event;
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            rosterView.accountDisconnected(de.getTargetID());
          }
        }
);
      }
    }
  }
);
  pc.getRosterManager().addPresenceListener(new IPresenceListener(){
    public void handleRosterEntryAdd(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntryAdd(PresenceContainerUI.this.groupID,entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(PresenceContainerUI.this.groupID,fromID,presence);
        }
      }
);
    }
    public void handleRosterEntryUpdate(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntryAdd(PresenceContainerUI.this.groupID,entry);
        }
      }
);
    }
    public void handleRosterEntryRemove(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntryRemove(PresenceContainerUI.this.groupID,entry);
        }
      }
);
    }
  }
);
  pc.getRosterManager().addRosterSubscriptionListener(new IRosterSubscriptionListener(){
    public void handleSubscribeRequest(    final ID fromID){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.setBlockOnOpen(true);
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null)                 rosterView.sendRosterAdd(localUser,fromID.getName(),null);
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
            }
 else {
            }
          }
 catch (          Exception e) {
            ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,SEND_ERRORCODE,""String_Node_Str"",e));
          }
        }
      }
);
    }
    public void handleSubscribed(    ID fromID){
    }
    public void handleUnsubscribed(    ID fromID){
    }
  }
);
}","protected void setup(final IContainer container,final ID localUser,final String nick){
  this.container=container;
  this.soContainer=(ISharedObjectContainer)this.container.getAdapter(ISharedObjectContainer.class);
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        PresenceContainerUI.this.localUser=new org.eclipse.ecf.core.user.User(localUser,nickname);
      }
 catch (      Exception e) {
        ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,SEND_ERRORCODE,""String_Node_Str"",e));
      }
    }
  }
);
  chatManager.addMessageListener(new IIMMessageListener(){
    public void handleMessageEvent(    final IIMMessageEvent chatMessageEvent){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (chatMessageEvent instanceof IChatMessageEvent) {
            rosterView.handleMessageEvent(chatMessageEvent);
          }
 else           if (chatMessageEvent instanceof ITypingMessageEvent) {
            rosterView.handleTyping(chatMessageEvent.getFromID());
          }
        }
      }
);
    }
  }
);
  container.addListener(new IContainerListener(){
    public void handleEvent(    IContainerEvent event){
      if (event instanceof IContainerConnectedEvent) {
        IContainerConnectedEvent cce=(IContainerConnectedEvent)event;
        final ID joinedContainer=cce.getTargetID();
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            ILocalInputHandler handler=new ILocalInputHandler(){
              public void inputText(              ID userID,              String text){
                try {
                  chatMessageSender.sendChatMessage(userID,text);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void startTyping(              ID userID){
                try {
                  typingMessageSender.sendTypingMessage(userID,true,""String_Node_Str"");
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void disconnect(){
                container.disconnect();
              }
              public void updatePresence(              ID userID,              IPresence presence){
                try {
                  presenceSender.sendPresenceUpdate(userID,presence);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void sendRosterAdd(              String user,              String name,              String[] groups){
                try {
                  rosterSubscriptionSender.sendRosterAdd(user,name,groups);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
              public void sendRosterRemove(              ID userID){
                try {
                  rosterSubscriptionSender.sendRosterRemove(userID);
                }
 catch (                ECFException e) {
                  ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),SEND_ERRORCODE,""String_Node_Str"",e));
                }
              }
            }
;
            PresenceContainerUI.this.groupID=joinedContainer;
            rosterView.addAccount(joinedContainer,PresenceContainerUI.this.localUser,handler,pc,soContainer);
          }
        }
);
      }
 else       if (event instanceof IContainerDisconnectedEvent) {
        final IContainerDisconnectedEvent de=(IContainerDisconnectedEvent)event;
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            rosterView.accountDisconnected(de.getTargetID());
          }
        }
);
      }
    }
  }
);
  pc.getRosterManager().addPresenceListener(new IPresenceListener(){
    public void handleRosterEntryAdd(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntryAdd(PresenceContainerUI.this.groupID,entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(PresenceContainerUI.this.groupID,fromID,presence);
        }
      }
);
    }
    public void handleRosterEntryUpdate(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntryUpdate(PresenceContainerUI.this.groupID,entry);
        }
      }
);
    }
    public void handleRosterEntryRemove(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntryRemove(PresenceContainerUI.this.groupID,entry);
        }
      }
);
    }
  }
);
  pc.getRosterManager().addRosterSubscriptionListener(new IRosterSubscriptionListener(){
    public void handleSubscribeRequest(    final ID fromID){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.setBlockOnOpen(true);
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null)                 rosterView.sendRosterAdd(localUser,fromID.getName(),null);
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
            }
 else {
            }
          }
 catch (          Exception e) {
            ClientPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,SEND_ERRORCODE,""String_Node_Str"",e));
          }
        }
      }
);
    }
    public void handleSubscribed(    ID fromID){
    }
    public void handleUnsubscribed(    ID fromID){
    }
  }
);
}",0.999417211681668
95032,"Manager(boolean withParticipantsList,CTabFolder parent,String name,KeyListener keyListener){
  tabItem=new CTabItem(parent,SWT.NULL);
  tabItem.setText(name);
  if (withParticipantsList) {
    fullChat=new SashForm(parent,SWT.HORIZONTAL);
    fullChat.setLayout(new FillLayout());
    Composite memberComp=new Composite(fullChat,SWT.NONE);
    memberComp.setLayout(new FillLayout());
    listViewer=new ListViewer(memberComp,SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
    listViewer.setSorter(new ViewerSorter());
    Composite rightComp=new Composite(fullChat,SWT.NONE);
    rightComp.setLayout(new FillLayout());
    rightSash=new SashForm(rightComp,SWT.VERTICAL);
  }
 else   rightSash=new SashForm(parent,SWT.VERTICAL);
  Composite readInlayComp=new Composite(rightSash,SWT.FILL);
  readInlayComp.setLayout(new GridLayout());
  readInlayComp.setLayoutData(new GridData(GridData.FILL_BOTH));
  textOutput=new SimpleLinkTextViewer(readInlayComp,SWT.V_SCROLL | SWT.H_SCROLL | SWT.WRAP);
  textOutput.getTextWidget().setEditable(false);
  textOutput.getTextWidget().setLayoutData(new GridData(GridData.FILL_BOTH));
  Composite writeComp=new Composite(rightSash,SWT.NONE);
  writeComp.setLayout(new FillLayout());
  textInput=new Text(writeComp,SWT.BORDER | SWT.MULTI | SWT.WRAP| SWT.V_SCROLL);
  if (keyListener != null)   textInput.addKeyListener(keyListener);
  rightSash.setWeights(new int[]{RATIO_READ_PANE,RATIO_WRITE_PANE});
  if (withParticipantsList) {
    fullChat.setWeights(new int[]{RATIO_PRESENCE_PANE,RATIO_READ_WRITE_PANE});
    tabItem.setControl(fullChat);
  }
 else   tabItem.setControl(rightSash);
  parent.setSelection(tabItem);
}","Manager(boolean withParticipantsList,CTabFolder parent,String name,KeyListener keyListener){
  tabItem=new CTabItem(parent,SWT.NULL);
  tabItem.setText(name);
  if (withParticipantsList) {
    fullChat=new SashForm(parent,SWT.HORIZONTAL);
    fullChat.setLayout(new FillLayout());
    Composite memberComp=new Composite(fullChat,SWT.NONE);
    memberComp.setLayout(new FillLayout());
    listViewer=new ListViewer(memberComp,SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
    listViewer.setSorter(new ViewerSorter());
    Composite rightComp=new Composite(fullChat,SWT.NONE);
    rightComp.setLayout(new FillLayout());
    rightSash=new SashForm(rightComp,SWT.VERTICAL);
  }
 else   rightSash=new SashForm(parent,SWT.VERTICAL);
  Composite readInlayComp=new Composite(rightSash,SWT.FILL);
  readInlayComp.setLayout(new GridLayout());
  readInlayComp.setLayoutData(new GridData(GridData.FILL_BOTH));
  textOutput=new SimpleLinkTextViewer(readInlayComp,SWT.V_SCROLL | SWT.H_SCROLL | SWT.WRAP);
  textOutput.getTextWidget().setEditable(false);
  textOutput.getTextWidget().setLayoutData(new GridData(GridData.FILL_BOTH));
  textOutput.getTextWidget().addFocusListener(new FocusListener(){
    public void focusGained(    FocusEvent e){
      textInput.setFocus();
    }
    public void focusLost(    FocusEvent e){
    }
  }
);
  Composite writeComp=new Composite(rightSash,SWT.NONE);
  writeComp.setLayout(new FillLayout());
  textInput=new Text(writeComp,SWT.BORDER | SWT.MULTI | SWT.WRAP| SWT.V_SCROLL);
  if (keyListener != null)   textInput.addKeyListener(keyListener);
  rightSash.setWeights(new int[]{RATIO_READ_PANE,RATIO_WRITE_PANE});
  if (withParticipantsList) {
    fullChat.setWeights(new int[]{RATIO_PRESENCE_PANE,RATIO_READ_WRITE_PANE});
    tabItem.setControl(fullChat);
  }
 else   tabItem.setControl(rightSash);
  parent.setSelection(tabItem);
}",0.9412435824301196
95033,"public String getMucString(){
  String host=uri.getHost();
  String group=fixPath(uri.getPath());
  String res=group + ""String_Node_Str"" + host;
  return res;
}","public String getMucString(){
  return this.roomname + ""String_Node_Str"" + this.domain+ ""String_Node_Str""+ this.host;
}",0.5089605734767025
95034,"protected boolean namespaceEquals(BaseID o){
  if (!(o instanceof XMPPRoomID)) {
    return false;
  }
  XMPPRoomID other=(XMPPRoomID)o;
  return uri.equals(other.uri);
}","protected boolean namespaceEquals(BaseID o){
  if (!(o instanceof XMPPRoomID)) {
    return false;
  }
  XMPPRoomID other=(XMPPRoomID)o;
  return fieldEquals(other);
}",0.9673590504451038
95035,"protected String namespaceGetName(){
  String path=uri.getPath();
  return fixPath(path);
}","protected String namespaceGetName(){
  return this.roomname;
}",0.6797385620915033
95036,"protected int namespaceHashCode(){
  return uri.hashCode();
}","protected int namespaceHashCode(){
  return this.domain.hashCode() ^ this.host.hashCode() ^ this.nickname.hashCode()^ this.roomname.hashCode()^ this.username.hashCode();
}",0.5172413793103449
95037,"public String getNickname(){
  String query=uri.getQuery();
  if (query == null) {
    return uri.getUserInfo();
  }
 else {
    return query.substring(query.indexOf('=') + 1);
  }
}","public String getNickname(){
  return nickname;
}",0.3722943722943723
95038,"public String toString(){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(uri).append(""String_Node_Str"");
  return sb.toString();
}","public String toString(){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(getNamespace().getScheme() + ""String_Node_Str"" + getUsername()+ ""String_Node_Str""+ this.domain+ ""String_Node_Str""+ this.host+ ""String_Node_Str""+ this.roomname).append(""String_Node_Str"");
  return sb.toString();
}",0.6461538461538462
95039,"protected void parseMessageAndSend(String message){
  if (isCommand(message)) {
    String[] tokens=parseCommandTokens(message);
synchronized (this) {
      if (connection != null) {
        handleCommandMessage(tokens);
      }
 else {
        trace(""String_Node_Str"" + message + ""String_Node_Str""+ getID());
      }
    }
  }
 else {
    trace(message + ""String_Node_Str"");
  }
}","protected void parseMessageAndSend(String message){
  if (isCommand(message)) {
synchronized (this) {
      if (connection != null) {
        String lowerCase=message.toLowerCase();
        if (lowerCase.startsWith(""String_Node_Str"")) {
          message=message.substring(5);
          int index=message.indexOf(COMMAND_DELIM);
          if (index != -1) {
            connection.doPrivmsg(message.substring(0,index),message.substring(index + 1));
          }
        }
 else         if (lowerCase.startsWith(""String_Node_Str"")) {
          message=message.substring(9);
          int index=message.indexOf(COMMAND_DELIM);
          if (index != -1) {
            connection.doPrivmsg(message.substring(0,index),message.substring(index + 1));
          }
        }
 else {
          String[] tokens=parseCommandTokens(message);
          handleCommandMessage(tokens);
        }
      }
 else {
        trace(""String_Node_Str"" + message + ""String_Node_Str""+ getID());
      }
    }
  }
 else {
    trace(message + ""String_Node_Str"");
  }
}",0.4436619718309859
95040,"private synchronized void handleCommandMessage(String[] tokens){
  String command=tokens[0];
  while (command.startsWith(COMMAND_PREFIX))   command=command.substring(1);
  String[] args=new String[tokens.length - 1];
  System.arraycopy(tokens,1,args,0,tokens.length - 1);
  if (command.equalsIgnoreCase(JOIN_COMMAND)) {
    if (args.length > 1) {
      connection.doJoin(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doJoin(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(LIST_COMMAND)) {
    if (args.length > 0) {
      connection.doList(args[0]);
    }
 else     connection.doList();
  }
 else   if (command.equalsIgnoreCase(PART_COMMAND)) {
    if (args.length > 1) {
      connection.doPart(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doPart(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(NICK_COMMAND)) {
    if (args.length > 0) {
      connection.doNick(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(MSG_COMMAND)) {
    if (args.length > 1) {
      connection.doPrivmsg(args[0],args[1]);
    }
  }
 else   if (command.equalsIgnoreCase(NOTICE_COMMAND)) {
    if (args.length > 1) {
      connection.doNotice(args[0],args[1]);
    }
  }
 else   if (command.equalsIgnoreCase(WHOIS_COMMAND)) {
    if (args.length > 0) {
      connection.doWhois(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(QUIT_COMMAND)) {
    if (args.length > 0) {
      connection.doQuit(args[0]);
    }
 else {
      connection.doQuit();
    }
  }
 else   if (command.equalsIgnoreCase(AWAY_COMMAND)) {
    if (args.length > 0) {
      connection.doAway(args[0]);
    }
 else {
      connection.doAway();
    }
  }
 else   if (command.equalsIgnoreCase(TOPIC_COMMAND)) {
    if (args.length > 1) {
      StringBuffer sb=new StringBuffer();
      for (int i=1; i < args.length; i++) {
        if (i > 1) {
          sb.append(COMMAND_DELIM);
        }
        sb.append(args[i]);
      }
      connection.doTopic(args[0],sb.toString());
    }
 else     if (args.length > 0) {
      connection.doTopic(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(INVITE_COMMAND)) {
    if (args.length > 1) {
      connection.doInvite(args[0],args[1]);
    }
  }
 else {
    trace(""String_Node_Str"" + command + ""String_Node_Str""+ getID());
  }
}","private synchronized void handleCommandMessage(String[] tokens){
  String command=tokens[0];
  while (command.startsWith(COMMAND_PREFIX))   command=command.substring(1);
  String[] args=new String[tokens.length - 1];
  System.arraycopy(tokens,1,args,0,tokens.length - 1);
  if (command.equalsIgnoreCase(JOIN_COMMAND)) {
    if (args.length > 1) {
      connection.doJoin(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doJoin(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(LIST_COMMAND)) {
    if (args.length > 0) {
      connection.doList(args[0]);
    }
 else     connection.doList();
  }
 else   if (command.equalsIgnoreCase(PART_COMMAND)) {
    if (args.length > 1) {
      connection.doPart(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doPart(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(NICK_COMMAND)) {
    if (args.length > 0) {
      connection.doNick(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(NOTICE_COMMAND)) {
    if (args.length > 1) {
      connection.doNotice(args[0],args[1]);
    }
  }
 else   if (command.equalsIgnoreCase(WHOIS_COMMAND)) {
    if (args.length > 0) {
      connection.doWhois(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(QUIT_COMMAND)) {
    if (args.length > 0) {
      connection.doQuit(args[0]);
    }
 else {
      connection.doQuit();
    }
  }
 else   if (command.equalsIgnoreCase(AWAY_COMMAND)) {
    if (args.length > 0) {
      connection.doAway(args[0]);
    }
 else {
      connection.doAway();
    }
  }
 else   if (command.equalsIgnoreCase(TOPIC_COMMAND)) {
    if (args.length > 1) {
      StringBuffer sb=new StringBuffer();
      for (int i=1; i < args.length; i++) {
        if (i > 1) {
          sb.append(COMMAND_DELIM);
        }
        sb.append(args[i]);
      }
      connection.doTopic(args[0],sb.toString());
    }
 else     if (args.length > 0) {
      connection.doTopic(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(INVITE_COMMAND)) {
    if (args.length > 1) {
      connection.doInvite(args[0],args[1]);
    }
  }
 else {
    trace(""String_Node_Str"" + command + ""String_Node_Str""+ getID());
  }
}",0.969939879759519
95041,"public SelectProviderAction(){
  try {
    IExtensionRegistry registry=Platform.getExtensionRegistry();
    IExtension[] configurationWizards=registry.getExtensionPoint(CONFIGURE_EPOINT_ID).getExtensions();
    IExtension[] connectWizards=registry.getExtensionPoint(CONNECT_EPOINT_ID).getExtensions();
    for (int i=0; i < connectWizards.length; i++) {
      final IConfigurationElement[] ices=connectWizards[i].getConfigurationElements();
      for (int j=0; j < ices.length; j++) {
        final String factoryName=ices[j].getAttribute(ATT_CONTAINER_TYPE_NAME);
        final IConfigurationWizard wizard=getWizard(configurationWizards,factoryName);
        final IConfigurationElement ice=ices[j];
        if (wizard == null) {
          map.put(ice.getAttribute(ATT_NAME),new SelectionAdapter(){
            public void widgetSelected(            SelectionEvent e){
              openConnectWizard(ice,factoryName);
            }
          }
);
        }
 else {
          map.put(ice.getAttribute(ATT_NAME),new SelectionAdapter(){
            public void widgetSelected(            SelectionEvent e){
              openConnectWizard(wizard,ice,factoryName);
            }
          }
);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public SelectProviderAction(){
  try {
    IExtensionRegistry registry=Platform.getExtensionRegistry();
    IExtension[] configurationWizards=registry.getExtensionPoint(CONFIGURE_EPOINT_ID).getExtensions();
    IExtension[] connectWizards=registry.getExtensionPoint(CONNECT_EPOINT_ID).getExtensions();
    for (int i=0; i < connectWizards.length; i++) {
      final IConfigurationElement[] ices=connectWizards[i].getConfigurationElements();
      for (int j=0; j < ices.length; j++) {
        if (ices[j].getName().equals(ELEMENT_CATEGORY)) {
          continue;
        }
        final String factoryName=ices[j].getAttribute(ATT_CONTAINER_TYPE_NAME);
        final IConfigurationWizard wizard=getWizard(configurationWizards,factoryName);
        final IConfigurationElement ice=ices[j];
        if (wizard == null) {
          map.put(ice.getAttribute(ATT_NAME),new SelectionAdapter(){
            public void widgetSelected(            SelectionEvent e){
              openConnectWizard(ice,factoryName);
            }
          }
);
        }
 else {
          map.put(ice.getAttribute(ATT_NAME),new SelectionAdapter(){
            public void widgetSelected(            SelectionEvent e){
              openConnectWizard(wizard,ice,factoryName);
            }
          }
);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9666413949962092
95042,"public byte[] getPhotoDataAsBytes(){
  return StringUtils.decodeBase64(photoData);
}","public byte[] getPhotoDataAsBytes(){
  if (photoData == null)   return new byte[0];
  return StringUtils.decodeBase64(photoData);
}",0.7813953488372093
95043,"protected void doJoin(final String target,final String key){
  CTabItem item=getTabItem(target);
  if (item != null) {
    tabFolder.setSelection(item);
    return;
  }
  IChatRoomInfo roomInfo=chatRoomManager.getChatRoomInfo(target);
  if (roomInfo == null)   return;
 else {
    try {
      final IChatRoomContainer chatRoomContainer=roomInfo.createChatRoomContainer();
      final ChatRoom chatroomview=new ChatRoom(chatRoomContainer,new Manager(tabFolder,target));
      chatRoomContainer.addMessageListener(new IIMMessageListener(){
        public void handleMessageEvent(        IIMMessageEvent messageEvent){
          if (messageEvent instanceof IChatRoomMessageEvent) {
            IChatRoomMessage m=((IChatRoomMessageEvent)messageEvent).getChatRoomMessage();
            chatroomview.handleMessage(m.getFromID(),m.getMessage());
          }
        }
      }
);
      chatRoomContainer.addChatRoomParticipantListener(new IChatRoomParticipantListener(){
        public void handlePresence(        ID fromID,        IPresence presence){
          chatroomview.handlePresence(fromID,presence);
        }
        public void handleArrivedInChat(        ID participant){
          chatroomview.handleJoin(participant);
        }
        public void handleDepartedFromChat(        ID participant){
          chatroomview.handleLeave(participant);
        }
      }
);
      chatRoomContainer.addListener(new IContainerListener(){
        public void handleEvent(        IContainerEvent evt){
          if (evt instanceof IContainerDisconnectedEvent) {
            chatroomview.disconnected();
          }
        }
      }
);
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          try {
            chatRoomContainer.connect(IDFactory.getDefault().createID(chatRoomContainer.getConnectNamespace(),target),ConnectContextFactory.createPasswordConnectContext(key));
          }
 catch (          Exception e) {
          }
        }
      }
);
    }
 catch (    Exception e) {
    }
  }
}","protected void doJoin(final String target,final String key){
  ChatRoom room=(ChatRoom)rooms.get(target);
  if (room != null && room.isConnected()) {
    room.setSelected();
    return;
  }
  IChatRoomInfo roomInfo=chatRoomManager.getChatRoomInfo(target);
  if (roomInfo == null)   return;
 else {
    try {
      final IChatRoomContainer chatRoomContainer=roomInfo.createChatRoomContainer();
      final ChatRoom chatroomview=new ChatRoom(chatRoomContainer,new Manager(tabFolder,target));
      chatRoomContainer.addMessageListener(new IIMMessageListener(){
        public void handleMessageEvent(        IIMMessageEvent messageEvent){
          if (messageEvent instanceof IChatRoomMessageEvent) {
            IChatRoomMessage m=((IChatRoomMessageEvent)messageEvent).getChatRoomMessage();
            chatroomview.handleMessage(m.getFromID(),m.getMessage());
          }
        }
      }
);
      chatRoomContainer.addChatRoomParticipantListener(new IChatRoomParticipantListener(){
        public void handlePresence(        ID fromID,        IPresence presence){
          chatroomview.handlePresence(fromID,presence);
        }
        public void handleArrivedInChat(        ID participant){
          chatroomview.handleJoin(participant);
        }
        public void handleDepartedFromChat(        ID participant){
          chatroomview.handleLeave(participant);
        }
      }
);
      chatRoomContainer.addListener(new IContainerListener(){
        public void handleEvent(        IContainerEvent evt){
          if (evt instanceof IContainerDisconnectedEvent) {
            chatroomview.disconnected();
          }
        }
      }
);
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          try {
            chatRoomContainer.connect(IDFactory.getDefault().createID(chatRoomContainer.getConnectNamespace(),target),ConnectContextFactory.createPasswordConnectContext(key));
            rooms.put(target,chatroomview);
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.8023952095808383
95044,"protected void sendMessageLine(String line){
  try {
    channelMessageSender.sendMessage(line);
  }
 catch (  ECFException e) {
    e.printStackTrace();
  }
}","protected void sendMessageLine(String line){
  try {
    channelMessageSender.sendMessage(line);
  }
 catch (  ECFException e) {
    disconnected();
  }
}",0.926517571884984
95045,"public int getActiveCount(){
  RosterObject[] childs=getChildren();
  int totCount=0;
  for (int i=0; i < childs.length; i++) {
    if (childs[i] instanceof RosterBuddy) {
      RosterBuddy tb=(RosterBuddy)childs[i];
      IPresence presence=tb.getPresence();
      if (presence != null && presence.getMode().equals(IPresence.Mode.AVAILABLE))       totCount++;
    }
  }
  return totCount;
}","public int getActiveCount(){
  RosterObject[] childs=getChildren();
  int totCount=0;
  for (int i=0; i < childs.length; i++) {
    if (childs[i] instanceof RosterBuddy) {
      RosterBuddy tb=(RosterBuddy)childs[i];
      IPresence presence=tb.getPresence();
      if (presence != null && presence.getType().equals(IPresence.Type.AVAILABLE))       totCount++;
    }
  }
  return totCount;
}",0.9846547314578004
95046,"protected void removeAccount(ID serviceID){
  accounts.remove(serviceID);
}","protected void removeAccount(ID serviceID){
synchronized (accounts) {
    for (Iterator i=accounts.keySet().iterator(); i.hasNext(); ) {
      ID key=(ID)i.next();
      if (key.equals(serviceID))       i.remove();
    }
  }
}",0.3521594684385382
95047,"private void makeActions(){
  selectedDoubleClickAction=new Action(){
    public void run(){
      RosterObject rosterObject=getSelectedTreeObject();
      final ID targetID=rosterObject.getID();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      if (MessageDialog.openConfirm(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"")) {
        for (Iterator i=accounts.entrySet().iterator(); i.hasNext(); ) {
          Map.Entry entry=(Map.Entry)i.next();
          RosterUserAccount account=(RosterUserAccount)entry.getValue();
          disconnectAccount(account);
        }
        setToolbarEnabled(false);
        this.setEnabled(false);
      }
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"");
  disconnectAction.setEnabled(false);
  disconnectAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_DISCONNECT_ENABLED)));
  disconnectAction.setDisabledImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_DISCONNECT_DISABLED)));
  openChatRoomAction=new Action(){
    public void run(){
      List list=new ArrayList();
      for (Iterator i=accounts.values().iterator(); i.hasNext(); ) {
        RosterUserAccount ua=(RosterUserAccount)i.next();
        IChatRoomManager man=ua.getPresenceContainer().getChatRoomManager();
        if (man != null)         list.add(man);
      }
      showChatRooms((IChatRoomManager[])list.toArray(new IChatRoomManager[]{}));
    }
  }
;
  openChatRoomAction.setText(""String_Node_Str"");
  openChatRoomAction.setToolTipText(""String_Node_Str"");
  openChatRoomAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_ADD_CHAT)));
  openChatRoomAction.setEnabled(false);
}","private void makeActions(){
  selectedDoubleClickAction=new Action(){
    public void run(){
      RosterObject rosterObject=getSelectedTreeObject();
      final ID targetID=rosterObject.getID();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      if (MessageDialog.openConfirm(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"")) {
        Set entrySet=new HashSet();
        entrySet.addAll(accounts.entrySet());
        for (Iterator i=entrySet.iterator(); i.hasNext(); ) {
          Map.Entry entry=(Map.Entry)i.next();
          RosterUserAccount account=(RosterUserAccount)entry.getValue();
          account.getInputHandler().disconnect();
        }
        setToolbarEnabled(false);
        this.setEnabled(false);
      }
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"");
  disconnectAction.setEnabled(false);
  disconnectAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_DISCONNECT_ENABLED)));
  disconnectAction.setDisabledImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_DISCONNECT_DISABLED)));
  openChatRoomAction=new Action(){
    public void run(){
      List list=new ArrayList();
      for (Iterator i=accounts.values().iterator(); i.hasNext(); ) {
        RosterUserAccount ua=(RosterUserAccount)i.next();
        IChatRoomManager man=ua.getPresenceContainer().getChatRoomManager();
        if (man != null)         list.add(man);
      }
      showChatRooms((IChatRoomManager[])list.toArray(new IChatRoomManager[]{}));
    }
  }
;
  openChatRoomAction.setText(""String_Node_Str"");
  openChatRoomAction.setToolTipText(""String_Node_Str"");
  openChatRoomAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_ADD_CHAT)));
  openChatRoomAction.setEnabled(false);
}",0.9617944293813162
95048,"/** 
 * Called when time to fill the context menu. First allows super class to fill menu, then adds on test action that simply sends shared object message to given buddy. Subclasses may override as appropriate to fill in context menu. Note that super.fillContextMenu(manager) should always be called first to allow the superclass to fill in the context menu.
 * @param manager the IMenuManager
 */
protected void fillContextMenu(IMenuManager manager){
  final RosterObject rosterObject=getSelectedTreeObject();
  final ID targetID=rosterObject.getID();
  if (rosterObject != null) {
    if (rosterObject instanceof RosterBuddy) {
      final RosterBuddy tb=(RosterBuddy)rosterObject;
      selectedChatAction=new Action(){
        public void run(){
          openChatWindowForTarget(targetID);
        }
      }
;
      selectedChatAction.setText(""String_Node_Str"" + rosterObject.getID().getName());
      selectedChatAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_MESSAGE)));
      manager.add(selectedChatAction);
      RosterObject parent=rosterObject.getParent();
      RosterGroup tg=null;
      if (parent != null && parent instanceof RosterGroup) {
        tg=(RosterGroup)parent;
      }
      final RosterGroup rosterGroup=tg;
      Action removeUserAction=new Action(){
        public void run(){
          removeUserFromGroup(tb,rosterGroup);
        }
      }
;
      if (rosterGroup != null) {
        removeUserAction.setText(""String_Node_Str"" + rosterObject.getName() + ""String_Node_Str""+ rosterGroup.getName()+ ""String_Node_Str"");
      }
 else {
        removeUserAction.setText(""String_Node_Str"" + rosterObject.getName());
      }
      removeUserAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_TOOL_DELETE));
      manager.add(removeUserAction);
    }
 else     if (rosterObject instanceof RosterAccount) {
      final RosterAccount rosterAccount=(RosterAccount)rosterObject;
      final ID accountID=rosterAccount.getID();
      final RosterUserAccount ua=getAccount(accountID);
      if (ua != null) {
        Action addBuddyToGroupAction=new Action(){
          public void run(){
            sendRosterAdd(accountID,null);
          }
        }
;
        addBuddyToGroupAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_ADD_BUDDY)));
        addBuddyToGroupAction.setText(""String_Node_Str"");
        addBuddyToGroupAction.setEnabled(true);
        manager.add(addBuddyToGroupAction);
        openChatRoomAccountAction=new Action(){
          public void run(){
            showChatRoomsForAccount(ua);
          }
        }
;
        openChatRoomAccountAction.setText(""String_Node_Str"");
        openChatRoomAccountAction.setEnabled(true);
        openChatRoomAccountAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_ADD_CHAT)));
        manager.add(openChatRoomAccountAction);
        Action changePasswordAction=new Action(){
          public void run(){
            changePasswordForAccount(accountID);
          }
        }
;
        changePasswordAction.setText(""String_Node_Str"");
        changePasswordAction.setToolTipText(""String_Node_Str"");
        changePasswordAction.setEnabled(true);
        manager.add(changePasswordAction);
        disconnectAccountAction=new Action(){
          public void run(){
            if (MessageDialog.openConfirm(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"")) {
              disconnectAccount(ua);
            }
          }
        }
;
        disconnectAccountAction.setText(""String_Node_Str"");
        disconnectAccountAction.setEnabled(true);
        disconnectAccountAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_DISCONNECT_ENABLED)));
        manager.add(disconnectAccountAction);
      }
    }
 else     if (rosterObject instanceof RosterGroup) {
      final RosterGroup rosterGroup=(RosterGroup)rosterObject;
      final String groupName=rosterGroup.getName();
      Action removeGroupAction=new Action(){
        public void run(){
          removeGroup(groupName);
        }
      }
;
      String accountName=rosterGroup.getID().getName();
      removeGroupAction.setText(""String_Node_Str"" + rosterObject.getName() + ""String_Node_Str""+ accountName);
      removeGroupAction.setEnabled(rosterGroup.getTotalCount() == 0);
      removeGroupAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_TOOL_DELETE));
      if (removeGroupAction.isEnabled())       manager.add(removeGroupAction);
    }
  }
  manager.add(new Separator());
  manager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
}","/** 
 * Called when time to fill the context menu. First allows super class to fill menu, then adds on test action that simply sends shared object message to given buddy. Subclasses may override as appropriate to fill in context menu. Note that super.fillContextMenu(manager) should always be called first to allow the superclass to fill in the context menu.
 * @param manager the IMenuManager
 */
protected void fillContextMenu(IMenuManager manager){
  final RosterObject rosterObject=getSelectedTreeObject();
  final ID targetID=rosterObject.getID();
  if (rosterObject != null) {
    if (rosterObject instanceof RosterBuddy) {
      final RosterBuddy tb=(RosterBuddy)rosterObject;
      selectedChatAction=new Action(){
        public void run(){
          openChatWindowForTarget(targetID);
        }
      }
;
      selectedChatAction.setText(""String_Node_Str"" + rosterObject.getID().getName());
      selectedChatAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_MESSAGE)));
      manager.add(selectedChatAction);
      RosterObject parent=rosterObject.getParent();
      RosterGroup tg=null;
      if (parent != null && parent instanceof RosterGroup) {
        tg=(RosterGroup)parent;
      }
      final RosterGroup rosterGroup=tg;
      Action removeUserAction=new Action(){
        public void run(){
          removeUserFromGroup(tb,rosterGroup);
        }
      }
;
      if (rosterGroup != null) {
        removeUserAction.setText(""String_Node_Str"" + rosterObject.getName() + ""String_Node_Str""+ rosterGroup.getName()+ ""String_Node_Str"");
      }
 else {
        removeUserAction.setText(""String_Node_Str"" + rosterObject.getName());
      }
      removeUserAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_TOOL_DELETE));
      manager.add(removeUserAction);
    }
 else     if (rosterObject instanceof RosterAccount) {
      final RosterAccount rosterAccount=(RosterAccount)rosterObject;
      final ID accountID=rosterAccount.getID();
      final RosterUserAccount ua=getAccount(accountID);
      if (ua != null) {
        Action addBuddyToGroupAction=new Action(){
          public void run(){
            sendRosterAdd(accountID,null);
          }
        }
;
        addBuddyToGroupAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_ADD_BUDDY)));
        addBuddyToGroupAction.setText(""String_Node_Str"");
        addBuddyToGroupAction.setEnabled(true);
        manager.add(addBuddyToGroupAction);
        openChatRoomAccountAction=new Action(){
          public void run(){
            showChatRoomsForAccount(ua);
          }
        }
;
        openChatRoomAccountAction.setText(""String_Node_Str"");
        openChatRoomAccountAction.setEnabled(true);
        openChatRoomAccountAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_ADD_CHAT)));
        manager.add(openChatRoomAccountAction);
        Action changePasswordAction=new Action(){
          public void run(){
            changePasswordForAccount(accountID);
          }
        }
;
        changePasswordAction.setText(""String_Node_Str"");
        changePasswordAction.setToolTipText(""String_Node_Str"");
        changePasswordAction.setEnabled(true);
        manager.add(changePasswordAction);
        disconnectAccountAction=new Action(){
          public void run(){
            if (MessageDialog.openConfirm(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"")) {
              ua.getInputHandler().disconnect();
            }
          }
        }
;
        disconnectAccountAction.setText(""String_Node_Str"");
        disconnectAccountAction.setEnabled(true);
        disconnectAccountAction.setImageDescriptor(ImageDescriptor.createFromImage(Activator.getDefault().getImageRegistry().get(Constants.DECORATION_DISCONNECT_ENABLED)));
        manager.add(disconnectAccountAction);
      }
    }
 else     if (rosterObject instanceof RosterGroup) {
      final RosterGroup rosterGroup=(RosterGroup)rosterObject;
      final String groupName=rosterGroup.getName();
      Action removeGroupAction=new Action(){
        public void run(){
          removeGroup(groupName);
        }
      }
;
      String accountName=rosterGroup.getID().getName();
      removeGroupAction.setText(""String_Node_Str"" + rosterObject.getName() + ""String_Node_Str""+ accountName);
      removeGroupAction.setEnabled(rosterGroup.getTotalCount() == 0);
      removeGroupAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_TOOL_DELETE));
      if (removeGroupAction.isEnabled())       manager.add(removeGroupAction);
    }
  }
  manager.add(new Separator());
  manager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
}",0.9947315096251268
95049,"protected void handleAccountDisconnected(RosterUserAccount account){
  removeAllRosterEntriesForAccount(account);
  disposeAllChatWindowsForAccount(account,""String_Node_Str"");
  accounts.remove(account.getServiceID());
  if (accounts.size() == 0)   setToolbarEnabled(false);
}","protected void handleAccountDisconnected(RosterUserAccount account){
  removeAllRosterEntriesForAccount(account);
  disposeAllChatWindowsForAccount(account,""String_Node_Str"");
  removeAccount(account.getServiceID());
  if (accounts.size() == 0)   setToolbarEnabled(false);
}",0.9709090909090908
95050,"protected void handleOnError(String arg0){
  trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
  showMessage(null,""String_Node_Str"" + arg0);
  disconnect();
}","protected void handleOnError(String arg0){
  trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
  showMessage(null,""String_Node_Str"" + arg0);
}",0.9477124183006536
95051,"protected IRCEventListener getIRCEventListener(){
  return new IRCEventListener(){
    public void onRegistered(){
      trace(""String_Node_Str"");
      fireContainerEvent(new ContainerConnectedEvent(IRCRootContainer.this.getID(),targetID));
    }
    public void onDisconnected(){
      trace(""String_Node_Str"");
      showMessage(null,""String_Node_Str"");
      handleDisconnected();
    }
    public void onError(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
      showMessage(null,""String_Node_Str"" + arg0);
      handleDisconnected();
    }
    public void onError(    int arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      showMessage(null,""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1);
      handleDisconnected();
    }
    public void onInvite(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onJoin(    String arg0,    IRCUser arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      IRCChannelContainer container=getChannel(arg0);
      if (container != null) {
        container.setIRCUser(arg1);
      }
    }
    public void onKick(    String arg0,    IRCUser arg1,    String arg2,    String arg3){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3+ ""String_Node_Str"");
    }
    public void onMode(    String arg0,    IRCUser arg1,    IRCModeParser arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onMode(    IRCUser arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onNick(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
    }
    public void onNotice(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg2);
    }
    public void onPart(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      IRCChannelContainer channel=(IRCChannelContainer)channels.get(arg0);
      if (channel != null) {
        channel.firePresenceListeners(false,getIRCUserName(arg1));
      }
    }
    public void onPing(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
synchronized (IRCRootContainer.this) {
        if (connection != null) {
          connection.doPong(arg0);
        }
      }
    }
    public void onPrivmsg(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg1.toString(),arg2);
    }
    public void onQuit(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      for (Iterator i=channels.values().iterator(); i.hasNext(); ) {
        IRCChannelContainer container=(IRCChannelContainer)i.next();
        container.handleUserQuit(getIRCUserName(arg0));
      }
    }
    public void onReply(    int arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      replyHandler.handleReply(arg0,arg1,arg2);
    }
    public void onTopic(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg1.getNick() + ""String_Node_Str"" + arg2);
    }
    public void unknown(    String arg0,    String arg1,    String arg2,    String arg3){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3+ ""String_Node_Str"");
      showMessage(null,""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3);
    }
  }
;
}","protected IRCEventListener getIRCEventListener(){
  return new IRCEventListener(){
    public void onRegistered(){
      trace(""String_Node_Str"");
      fireContainerEvent(new ContainerConnectedEvent(IRCRootContainer.this.getID(),targetID));
    }
    public void onDisconnected(){
      trace(""String_Node_Str"");
      showMessage(null,""String_Node_Str"");
      handleDisconnected();
    }
    public void onError(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
      showMessage(null,""String_Node_Str"" + arg0);
    }
    public void onError(    int arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      showMessage(null,""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1);
    }
    public void onInvite(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onJoin(    String arg0,    IRCUser arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      IRCChannelContainer container=getChannel(arg0);
      if (container != null) {
        container.setIRCUser(arg1);
      }
    }
    public void onKick(    String arg0,    IRCUser arg1,    String arg2,    String arg3){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3+ ""String_Node_Str"");
    }
    public void onMode(    String arg0,    IRCUser arg1,    IRCModeParser arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onMode(    IRCUser arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
    }
    public void onNick(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
    }
    public void onNotice(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg2);
    }
    public void onPart(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      IRCChannelContainer channel=(IRCChannelContainer)channels.get(arg0);
      if (channel != null) {
        channel.firePresenceListeners(false,getIRCUserName(arg1));
      }
    }
    public void onPing(    String arg0){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str"");
synchronized (IRCRootContainer.this) {
        if (connection != null) {
          connection.doPong(arg0);
        }
      }
    }
    public void onPrivmsg(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg1.toString(),arg2);
    }
    public void onQuit(    IRCUser arg0,    String arg1){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
      for (Iterator i=channels.values().iterator(); i.hasNext(); ) {
        IRCChannelContainer container=(IRCChannelContainer)i.next();
        container.handleUserQuit(getIRCUserName(arg0));
      }
    }
    public void onReply(    int arg0,    String arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      replyHandler.handleReply(arg0,arg1,arg2);
    }
    public void onTopic(    String arg0,    IRCUser arg1,    String arg2){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str"");
      showMessage(arg0,arg1.getNick() + ""String_Node_Str"" + arg2);
    }
    public void unknown(    String arg0,    String arg1,    String arg2,    String arg3){
      trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3+ ""String_Node_Str"");
      showMessage(null,""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str""+ arg2+ ""String_Node_Str""+ arg3);
    }
  }
;
}",0.9934747145187602
95052,"public void onError(int arg0,String arg1){
  trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
  showMessage(null,""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1);
  handleDisconnected();
}","public void onError(int arg0,String arg1){
  trace(""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1+ ""String_Node_Str"");
  showMessage(null,""String_Node_Str"" + arg0 + ""String_Node_Str""+ arg1);
}",0.9423076923076924
95053,"public void selectionChanged(SelectionChangedEvent event){
  StructuredSelection selection=(StructuredSelection)event.getSelection();
  ContainerTypeDescription desc=(ContainerTypeDescription)selection.getFirstElement();
  containerType=desc.getName();
  createPropertyComposite(paramComp,desc.getProperties());
}","public void selectionChanged(SelectionChangedEvent event){
  StructuredSelection selection=(StructuredSelection)event.getSelection();
  ContainerTypeDescription desc=(ContainerTypeDescription)selection.getFirstElement();
  if (desc != null) {
    containerType=desc.getName();
    createPropertyComposite(paramComp,desc.getProperties());
  }
}",0.9542682926829268
95054,"public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null && !otherUsers.contains(fromID)) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
        if (isLocalUser(fromID))         removeLocalUser();
      }
    }
  }
);
}","public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().asyncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null && !otherUsers.contains(fromID)) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
        if (isLocalUser(fromID))         removeLocalUser();
      }
    }
  }
);
}",0.9991158267020336
95055,"/** 
 * Get the name of this namespace. May not return null.
 * @return String name of Namespace instance
 */
public String getName(){
  return name;
}","/** 
 * Get the name of this namespace. Must not return null.
 * @return String name of Namespace instance
 */
public String getName(){
  return name;
}",0.9834983498349836
95056,"public final boolean initialize(String name,String desc){
  if (name == null)   throw new NullPointerException(""String_Node_Str"");
  if (!isInitialized) {
    this.name=name;
    this.description=desc;
    this.hashCode=name.hashCode();
    this.isInitialized=true;
    return true;
  }
 else   return false;
}","public final boolean initialize(String name,String desc){
  Assert.isNotNull(name,""String_Node_Str"");
  if (!isInitialized) {
    this.name=name;
    this.description=desc;
    this.hashCode=name.hashCode();
    this.isInitialized=true;
    return true;
  }
 else   return false;
}",0.8798646362098139
95057,"/** 
 * Get array of supported adapters for the given container type description. Providers implement this method to allow clients to inspect the adapter types exposed by the container described by the given description. The returned array entries will be the fully qualified names of the adapter classes. Note that the returned types do not guarantee that a subsequent call to  {@link IContainer#getAdapter(Class)} with the same type name as areturned value will return a non-<code>null</code> result. In other words, even if the class name is in the returned array, subsequent calls to  {@link IContainer#getAdapter(Class)} may still return<code>null</code>.
 * @param description the ContainerTypeDescription to report adapters for. Must not be <code>null</code>.
 * @return String[] of supported adapters. The entries in the returned arraywill be the fully qualified class names of adapters supported by the given description. <code>null</code> will be returned by the provider if no adapters are supported for this description.
 */
public String[] getSupportedAdapterTypes(ContainerTypeDescription description);","/** 
 * Get array of supported adapters for the given container type description. Providers implement this method to allow clients to inspect the adapter types exposed by the container described by the given description. The returned array entries will be the fully qualified names of the adapter classes. Note that the returned types do not guarantee that a subsequent call to  {@link IContainer#getAdapter(Class)} with the same type name as areturned value will return a non-<code>null</code> result. In other words, even if the class name is in the returned array, subsequent calls to  {@link IContainer#getAdapter(Class)} may still return<code>null</code>.
 * @param description the ContainerTypeDescription to report adapters for. Must not be <code>null</code>.
 * @return String[] of supported adapters. The entries in the returned arraywill be the fully qualified class names of adapters supported by the given description. <code>null</code> may be returned by the provider if no adapters are supported for this description.
 */
public String[] getSupportedAdapterTypes(ContainerTypeDescription description);",0.9968623935454952
95058,"/** 
 * Get array of supported adapters for the given container type description. Providers can implement this method to allow clients to inspect the adapter types implemented by the container described by the given description. The returned array entries will be the fully qualified names of the adapter classes. Note that the returned types do not guarantee that a subsequent call to  {@link IContainer#getAdapter(Class)} with the same type name as areturned value will return a non-null result. In other words, even if the class name is in the returned array, subsequent calls to {@link IContainer#getAdapter(Class)} may still return <code>null</code>.
 * @return String[] of supported adapters. The entries in the returned arraywill be the fully qualified class names of adapters supported by the given description. An empty string array (String[0]) will be returned if no adapters are supported.
 */
public String[] getSupportedAdapterTypes(){
  String method=""String_Node_Str"";
  Trace.entering(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_ENTERING,this.getClass(),method);
  String[] result=new String[0];
  try {
    result=getInstantiator().getSupportedAdapterTypes(this);
  }
 catch (  Exception e) {
    traceAndLogException(GET_SUPPORTED_ADAPTERS_ERROR_CODE,method,e);
  }
  Trace.exiting(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_EXITING,this.getClass(),method,result);
  return result;
}","/** 
 * Get array of supported adapters for this container type description. The returned array entries will be the fully qualified names of the adapter classes. Note that the returned types do not guarantee that a subsequent call to  {@link IContainer#getAdapter(Class)} with the same type name as areturned value will return a non-<code>null</code result. In other words, even if the class name is in the returned array, subsequent calls to {@link IContainer#getAdapter(Class)} may still return <code>null</code>.
 * @return String[] of supported adapters. The entries in the returned arraywill be the fully qualified class names of adapters supported by the given description. An empty string array (String[0]) will be returned if no adapters are supported.
 */
public String[] getSupportedAdapterTypes(){
  String method=""String_Node_Str"";
  Trace.entering(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_ENTERING,this.getClass(),method);
  String[] result=new String[0];
  try {
    String[] r=getInstantiator().getSupportedAdapterTypes(this);
    if (r != null)     result=r;
  }
 catch (  Exception e) {
    traceAndLogException(GET_SUPPORTED_ADAPTERS_ERROR_CODE,method,e);
  }
  Trace.exiting(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_EXITING,this.getClass(),method,result);
  return result;
}",0.9060081091043126
95059,"/** 
 * Get array of parameter types for this ContainerTypeDescription. Each of the rows of the returned array specifies a Class[] of parameter types. These parameter types correspond to the types of Objects that can be passed into the second parameter of  {@link IContainerInstantiator#createInstance(ContainerTypeDescription,Object[])}. For example, if this method returns a Class [] = {{ String.class, String.class }, { String.class }} this indicates that a call to createInstance(description,new String[] { ""hello"", ""there"" }) and a call to createInstance(description,new String[] { ""hello"" }) will be understood by the underlying provider implementation.
 * @return Class[][] array of Class arrays. Each row corresponds to aClass[] that describes the types of Objects for second parameter to {@link IContainerInstantiator#createInstance(ContainerTypeDescription,Object[])}. If no parameter types are understood as arguments, a Class[0][0] array will be returned
 */
public Class[][] getSupportedParameterTypes(){
  String method=""String_Node_Str"";
  Trace.entering(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_ENTERING,this.getClass(),method);
  Class[][] result=new Class[0][0];
  try {
    result=getInstantiator().getSupportedParameterTypes(this);
  }
 catch (  Exception e) {
    traceAndLogException(GET_PARAMETER_TYPES_ERROR_CODE,method,e);
  }
  Trace.exiting(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_EXITING,this.getClass(),method,result);
  return result;
}","/** 
 * Get array of parameter types for this ContainerTypeDescription. Each of the rows of the returned array specifies a Class[] of parameter types. These parameter types correspond to the types of Objects that can be passed into the second parameter of  {@link IContainerInstantiator#createInstance(ContainerTypeDescription,Object[])}. For example, if this method returns a Class [] = {{ String.class, String.class }, { String.class }} this indicates that a call to createInstance(description,new String[] { ""hello"", ""there"" }) and a call to createInstance(description,new String[] { ""hello"" }) will be understood by the underlying provider implementation.
 * @return Class[][] array of Class arrays. Each row corresponds to aClass[] that describes the types of Objects for second parameter to {@link IContainerInstantiator#createInstance(ContainerTypeDescription,Object[])}. If no parameter types are understood as arguments, a Class[0][0] array will be returned
 */
public Class[][] getSupportedParameterTypes(){
  String method=""String_Node_Str"";
  Trace.entering(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_ENTERING,this.getClass(),method);
  Class[][] result=new Class[0][0];
  try {
    Class[][] r=getInstantiator().getSupportedParameterTypes(this);
    if (r != null)     result=r;
  }
 catch (  Exception e) {
    traceAndLogException(GET_PARAMETER_TYPES_ERROR_CODE,method,e);
  }
  Trace.exiting(ECFPlugin.getDefault(),ECFDebugOptions.METHODS_EXITING,this.getClass(),method,result);
  return result;
}",0.9833110814419226
95060,"/** 
 * Get array of supported adapters for the given container type description. Providers can implement this method to allow clients to inspect the adapter types implemented by the container described by the given description. The returned array entries will be the fully qualified names of the adapter classes. Note that the returned types do not guarantee that a subsequent call to  {@link IContainer#getAdapter(Class)} with the same type name as areturned value will return a non-null result. In other words, even if the class name is in the returned array, subsequent calls to {@link IContainer#getAdapter(Class)} may still return <code>null</code>.This method should not return null, but rather an empty String[] if no adapters are exposed.
 * @param description the ContainerTypeDescription to report adapters for. Must not be null
 * @return String[] of supported adapters. The entries in the returned arraywill be the fully qualified class names of adapters supported by the given description. Null returned if no adapters are supported for given description.
 */
public String[] getSupportedAdapterTypes(ContainerTypeDescription description);","/** 
 * Get array of supported adapters for the given container type description. Providers implement this method to allow clients to inspect the adapter types exposed by the container described by the given description. The returned array entries will be the fully qualified names of the adapter classes. Note that the returned types do not guarantee that a subsequent call to  {@link IContainer#getAdapter(Class)} with the same type name as areturned value will return a non-<code>null</code> result. In other words, even if the class name is in the returned array, subsequent calls to  {@link IContainer#getAdapter(Class)} may still return<code>null</code>.
 * @param description the ContainerTypeDescription to report adapters for. Must not be <code>null</code>.
 * @return String[] of supported adapters. The entries in the returned arraywill be the fully qualified class names of adapters supported by the given description. <code>null</code> will be returned by the provider if no adapters are supported for this description.
 */
public String[] getSupportedAdapterTypes(ContainerTypeDescription description);",0.6416923754958131
95061,"/** 
 * Get array of parameter types for given container type description. Providers implement this method to allow clients to inspect the available set of parameter types understood for calls to  {@link #createInstance(ContainerTypeDescription,Object[])}. <p> </p> Each of the rows of the returned array specifies a Class[] of parameter types. These parameter types correspond to the types of Object[] that can be passed into the second parameter of  {@link #createInstance(ContainerTypeDescription,Object[])}. <p> </p> Consider the following example: <p> </p> <pre> public Class[][] getSupportedParameterTypes() { return new Class[][] { { String.class }, { String.class, String.class } }; } </pre> The above means that there are two acceptable values for the Object [] passed into   {@link #createInstance(ContainerTypeDescription,Object[])}: 1) a single String, and 2) two Strings. These would therefore be acceptable as input to createInstance: <pre> IContainer container = ContainerFactory.getDefault().createContainer( description, new Object[] { &quot;Hello&quot; }); IContainer container2 = ContainerFactory.getDefault().createContainer( description, new Object[] { &quot;Hello&quot; }); </pre> <p> </p>
 * @param description the ContainerTypeDescription to return parameter types for
 * @return Class[][] array of Class[]s. Each row in the table corresponds toa Class[] that describes the types of Objects in Object[] for second parameter to {@link #createInstance(ContainerTypeDescription,Object[])}. Null returned if no parameter types supported for given description.
 */
public Class[][] getSupportedParameterTypes(ContainerTypeDescription description);","/** 
 * Get array of parameter types for given container type description. Providers implement this method to allow clients to inspect the available set of parameter types understood for calls to  {@link #createInstance(ContainerTypeDescription,Object[])}. <p> </p> Each of the rows of the returned array specifies a Class[] of parameter types. These parameter types correspond to the types of Object[] that can be passed into the second parameter of  {@link #createInstance(ContainerTypeDescription,Object[])}. <p> </p> Consider the following example: <p> </p> <pre> public Class[][] getSupportedParameterTypes() { return new Class[][] { { String.class }, { String.class, String.class } }; } </pre> The above means that there are two acceptable values for the Object [] passed into   {@link #createInstance(ContainerTypeDescription,Object[])}: 1) a single String, and 2) two Strings. These would therefore be acceptable as input to createInstance: <pre> IContainer container = ContainerFactory.getDefault().createContainer( description, new Object[] { &quot;Hello&quot; }); IContainer container2 = ContainerFactory.getDefault().createContainer( description, new Object[] { &quot;Hello&quot; }); </pre> <p> </p>
 * @param description the ContainerTypeDescription to return parameter types for
 * @return Class[][] array of Class[]s. Each row in the table corresponds toa Class[] that describes the types of Objects in Object[] for second parameter to {@link #createInstance(ContainerTypeDescription,Object[])}. <code>null</code> returned if no parameter types supported for given description.
 */
public Class[][] getSupportedParameterTypes(ContainerTypeDescription description);",0.9937219730941704
95062,"public void handleInvitationReceived(ID roomID,ID from,ID toID,String subject,String body){
  System.out.println(""String_Node_Str"" + roomID + ""String_Node_Str""+ from+ ""String_Node_Str""+ toID+ ""String_Node_Str""+ subject+ ""String_Node_Str""+ body);
}","public void handleInvitationReceived(ID roomID,ID from,String subject,String body){
  System.out.println(""String_Node_Str"" + roomID + ""String_Node_Str""+ from+ ""String_Node_Str""+ subject+ ""String_Node_Str""+ body);
}",0.928416485900217
95063,"public void handleInvitationReceived(ID roomID,ID from,ID toID,String subject,String body){
  System.out.println(""String_Node_Str"" + roomID + ""String_Node_Str""+ from+ ""String_Node_Str""+ toID+ ""String_Node_Str""+ subject+ ""String_Node_Str""+ body);
}","public void handleInvitationReceived(ID roomID,ID from,String subject,String body){
  System.out.println(""String_Node_Str"" + roomID + ""String_Node_Str""+ from+ ""String_Node_Str""+ subject+ ""String_Node_Str""+ body);
}",0.928416485900217
95064,"/** 
 * Handle notification of a received invitation to join chat room. This method will be called by some thread when an invitiation is received by this user account to join a chat room
 * @param roomID the room id associated with the invitation
 * @param from the id of the sender
 * @param to the id of the intended receiver
 * @param subject a subject for the invitation
 * @param body a message body for the invitation
 */
public void handleInvitationReceived(ID roomID,ID from,ID to,String subject,String body);","/** 
 * Handle notification of a received invitation to join chat room. This method will be called by some thread when an invitiation is received by this user account to join a chat room
 * @param roomID the room id associated with the invitation
 * @param from the id of the sender
 * @param subject a subject for the invitation
 * @param body a message body for the invitation
 */
public void handleInvitationReceived(ID roomID,ID from,String subject,String body);",0.948118006103764
95065,"public IAccountManager getAccountManager(){
  return new IAccountManager(){
    public boolean changePassword(    String newpassword) throws ECFException {
      return delegate.changePassword(newpassword);
    }
    public boolean createAccount(    String username,    String password,    Map attributes) throws ECFException {
      return delegate.createAccount(username,password,attributes);
    }
    public boolean deleteAccount() throws ECFException {
      return delegate.deleteAccount();
    }
    public String getAccountInstructions() throws ECFException {
      return delegate.getAccountInstructions();
    }
    public String[] getAccountAttributeNames() throws ECFException {
      return delegate.getAccountAttributeNames();
    }
    public Object getAccountAttribute(    String name) throws ECFException {
      return delegate.getAccountAttribute(name);
    }
    public boolean isAccountCreationSupported(){
      return delegate.isAccountCreationSupported();
    }
  }
;
}","public IAccountManager getAccountManager(){
  return new IAccountManager(){
    public boolean changePassword(    String newpassword) throws ECFException {
      return delegate.changePassword(newpassword);
    }
    public boolean createAccount(    String username,    String password,    Map attributes) throws ECFException {
      return delegate.createAccount(username,password,attributes);
    }
    public boolean deleteAccount() throws ECFException {
      return delegate.deleteAccount();
    }
    public String getAccountCreationInstructions() throws ECFException {
      return delegate.getAccountCreationInstructions();
    }
    public String[] getAccountAttributeNames() throws ECFException {
      return delegate.getAccountAttributeNames();
    }
    public Object getAccountAttribute(    String name) throws ECFException {
      return delegate.getAccountAttribute(name);
    }
    public boolean isAccountCreationSupported(){
      return delegate.isAccountCreationSupported();
    }
  }
;
}",0.992007992007992
95066,"protected void fireInvitationReceived(ID roomID,ID fromID,ID toID,String subject,String body){
  for (Iterator i=invitationListeners.iterator(); i.hasNext(); ) {
    IInvitationListener l=(IInvitationListener)i.next();
    l.handleInvitationReceived(roomID,fromID,toID,subject,body);
  }
}","protected void fireInvitationReceived(ID roomID,ID fromID,ID toID,String subject,String body){
  for (Iterator i=invitationListeners.iterator(); i.hasNext(); ) {
    IInvitationListener l=(IInvitationListener)i.next();
    l.handleInvitationReceived(roomID,fromID,subject,body);
  }
}",0.9912739965095986
95067,"public PermissionCollection checkConnect(Object addr,ID fromID,ID targetID,String targetGroup,Object joinData) throws SecurityException {
  System.out.println(""String_Node_Str"" + addr + ""String_Node_Str""+ fromID+ ""String_Node_Str""+ targetGroup+ ""String_Node_Str""+ joinData);
  return null;
}","public PermissionCollection checkConnect(Object addr,ID fromID,ID targetID,String targetGroup,Object joinData) throws Exception {
  System.out.println(""String_Node_Str"" + addr + ""String_Node_Str""+ fromID+ ""String_Node_Str""+ targetGroup+ ""String_Node_Str""+ joinData);
  return null;
}",0.9860627177700348
95068,"public static void main(String args[]) throws Exception {
  String serverName=null;
  List connectors=null;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      ServerConfigParser parser=new ServerConfigParser();
      connectors=parser.load(new FileInputStream(args[1]));
    }
 else     if (!args[0].equals(""String_Node_Str""))     serverName=args[0];
  }
  if (connectors != null) {
    serverGroups=new TCPServerSOContainerGroup[connectors.size()];
    int j=0;
    for (Iterator i=connectors.iterator(); i.hasNext(); ) {
      Connector connect=(Connector)i.next();
      serverGroups[j]=createServerGroup(connect.getHostname(),connect.getPort());
      List groups=connect.getGroups();
      for (Iterator g=groups.iterator(); g.hasNext(); ) {
        NamedGroup group=(NamedGroup)g.next();
        TCPServerSOContainer cont=createServerContainer(group.getIDForGroup(),serverGroups[j],group.getName(),connect.getTimeout());
        servers.add(cont);
      }
      System.out.println(""String_Node_Str"" + connect.getHostname() + ""String_Node_Str"");
      serverGroups[j].putOnTheAir();
      j++;
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    if (serverName == null) {
      serverName=TCPServerSOContainer.getDefaultServerURL();
    }
    java.net.URI anURL=new java.net.URI(serverName);
    int port=anURL.getPort();
    if (port == -1) {
      port=TCPServerSOContainer.DEFAULT_PORT;
    }
    String name=anURL.getPath();
    if (name == null) {
      name=TCPServerSOContainer.DEFAULT_NAME;
    }
    serverGroups=new TCPServerSOContainerGroup[1];
    serverGroups[0]=new TCPServerSOContainerGroup(anURL.getPort());
    ID id=IDFactory.getDefault().createStringID(serverName);
    SOContainerConfig config=new SOContainerConfig(id);
    System.out.print(""String_Node_Str"");
    TCPServerSOContainer server=new TCPServerSOContainer(config,serverGroups[0],name,TCPServerSOContainer.DEFAULT_KEEPALIVE);
    ((ISharedObjectContainerGroupManager)server).setConnectPolicy(new JoinListener());
    ISharedObjectManager manager=server.getSharedObjectManager();
    manager.setRemoteAddPolicy(new SharedObjectAddListener());
    serverGroups[0].putOnTheAir();
    servers.add(server);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + id.getName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
}","public static void main(String args[]) throws Exception {
  String serverName=null;
  List connectors=null;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      ServerConfigParser parser=new ServerConfigParser();
      connectors=parser.load(new FileInputStream(args[1]));
    }
 else     if (!args[0].equals(""String_Node_Str""))     serverName=args[0];
  }
  if (connectors != null) {
    serverGroups=new TCPServerSOContainerGroup[connectors.size()];
    int j=0;
    for (Iterator i=connectors.iterator(); i.hasNext(); ) {
      Connector connect=(Connector)i.next();
      serverGroups[j]=createServerGroup(connect.getHostname(),connect.getPort());
      List groups=connect.getGroups();
      for (Iterator g=groups.iterator(); g.hasNext(); ) {
        NamedGroup group=(NamedGroup)g.next();
        TCPServerSOContainer cont=createServerContainer(group.getIDForGroup(),serverGroups[j],group.getName(),connect.getTimeout());
        ((ISharedObjectContainerGroupManager)cont).setConnectPolicy(new JoinListener());
        servers.add(cont);
      }
      System.out.println(""String_Node_Str"" + connect.getHostname() + ""String_Node_Str"");
      serverGroups[j].putOnTheAir();
      j++;
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    if (serverName == null) {
      serverName=TCPServerSOContainer.getDefaultServerURL();
    }
    java.net.URI anURL=new java.net.URI(serverName);
    int port=anURL.getPort();
    if (port == -1) {
      port=TCPServerSOContainer.DEFAULT_PORT;
    }
    String name=anURL.getPath();
    if (name == null) {
      name=TCPServerSOContainer.DEFAULT_NAME;
    }
    serverGroups=new TCPServerSOContainerGroup[1];
    serverGroups[0]=new TCPServerSOContainerGroup(anURL.getPort());
    ID id=IDFactory.getDefault().createStringID(serverName);
    SOContainerConfig config=new SOContainerConfig(id);
    System.out.print(""String_Node_Str"");
    TCPServerSOContainer server=new TCPServerSOContainer(config,serverGroups[0],name,TCPServerSOContainer.DEFAULT_KEEPALIVE);
    ((ISharedObjectContainerGroupManager)server).setConnectPolicy(new JoinListener());
    ISharedObjectManager manager=server.getSharedObjectManager();
    manager.setRemoteAddPolicy(new SharedObjectAddListener());
    serverGroups[0].putOnTheAir();
    servers.add(server);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + id.getName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
}",0.9817809621289664
95069,"protected ID handleConnectResponse(ID orginalTarget,Object serverData) throws Exception {
  ContainerMessage aPacket=(ContainerMessage)serverData;
  ID fromID=aPacket.getFromContainerID();
  if (fromID == null)   throw new InvalidObjectException(""String_Node_Str"");
  ID[] ids=((ContainerMessage.ViewChangeMessage)aPacket.getData()).getChangeIDs();
  if (ids == null)   throw new java.io.InvalidObjectException(""String_Node_Str"");
  for (int i=0; i < ids.length; i++) {
    ID id=ids[i];
    if (id != null && !id.equals(getID())) {
      addNewRemoteMember(id,null);
      fireContainerEvent(new ContainerConnectedEvent(this.getID(),id));
    }
  }
  return fromID;
}","protected ID handleConnectResponse(ID orginalTarget,Object serverData) throws Exception {
  ContainerMessage aPacket=(ContainerMessage)serverData;
  ID fromID=aPacket.getFromContainerID();
  if (fromID == null)   throw new NullPointerException(""String_Node_Str"");
  ContainerMessage.ViewChangeMessage viewChangeMessage=(ContainerMessage.ViewChangeMessage)aPacket.getData();
  if (!viewChangeMessage.isAdd()) {
    Object data=viewChangeMessage.getData();
    if (data != null && data instanceof Exception)     throw (Exception)data;
 else     throw new NullPointerException(""String_Node_Str"");
  }
  ID[] ids=viewChangeMessage.getChangeIDs();
  if (ids == null)   throw new NullPointerException(""String_Node_Str"");
  for (int i=0; i < ids.length; i++) {
    ID id=ids[i];
    if (id != null && !id.equals(getID())) {
      addNewRemoteMember(id,null);
      fireContainerEvent(new ContainerConnectedEvent(this.getID(),id));
    }
  }
  return fromID;
}",0.6753086419753086
95070,"public void connect(ID remote,IConnectContext joinContext) throws ContainerConnectException {
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    debug(""String_Node_Str"" + remote + ""String_Node_Str""+ joinContext+ ""String_Node_Str"");
    Object response=null;
synchronized (getConnectLock()) {
      if (isConnected())       throw new ConnectException(""String_Node_Str"" + getConnectedID());
      if (isConnecting())       throw new ConnectException(""String_Node_Str"");
      fireContainerEvent(new ContainerConnectingEvent(this.getID(),remote,joinContext));
      ISynchAsynchConnection aConnection=createConnection(remote,joinContext);
      setStateConnecting(aConnection);
synchronized (aConnection) {
        Object connectData=getConnectData(remote,joinContext);
        int connectTimeout=getConnectTimeout();
        try {
          response=aConnection.connect(remote,connectData,connectTimeout);
        }
 catch (        IOException e) {
          if (getConnection() != aConnection)           killConnection(aConnection);
 else           setStateDisconnected(aConnection);
          throw e;
        }
        if (getConnection() != aConnection) {
          killConnection(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        ID serverID=null;
        try {
          serverID=handleConnectResponse(remote,response);
        }
 catch (        Exception e) {
          setStateDisconnected(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        aConnection.start();
        setStateConnected(serverID,aConnection);
      }
    }
  }
 catch (  Exception e) {
    traceStack(""String_Node_Str"",e);
    ContainerConnectException except=new ContainerConnectException(""String_Node_Str"" + remote.getName(),e);
    throw except;
  }
}","public void connect(ID remote,IConnectContext joinContext) throws ContainerConnectException {
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    debug(""String_Node_Str"" + remote + ""String_Node_Str""+ joinContext+ ""String_Node_Str"");
    Object response=null;
synchronized (getConnectLock()) {
      if (isConnected())       throw new IllegalStateException(""String_Node_Str"" + getConnectedID());
      if (isConnecting())       throw new IllegalStateException(""String_Node_Str"");
      fireContainerEvent(new ContainerConnectingEvent(this.getID(),remote,joinContext));
      ISynchAsynchConnection aConnection=createConnection(remote,joinContext);
      setStateConnecting(aConnection);
synchronized (aConnection) {
        Object connectData=getConnectData(remote,joinContext);
        int connectTimeout=getConnectTimeout();
        try {
          response=aConnection.connect(remote,connectData,connectTimeout);
        }
 catch (        IOException e) {
          if (getConnection() != aConnection)           killConnection(aConnection);
 else           setStateDisconnected(aConnection);
          throw e;
        }
        if (getConnection() != aConnection) {
          killConnection(aConnection);
          throw new IllegalStateException(""String_Node_Str"");
        }
        ID serverID=null;
        try {
          serverID=handleConnectResponse(remote,response);
        }
 catch (        Exception e) {
          setStateDisconnected(aConnection);
          throw e;
        }
        aConnection.start();
        setStateConnected(serverID,aConnection);
      }
    }
  }
 catch (  Exception e) {
    traceStack(""String_Node_Str"",e);
    ContainerConnectException except=new ContainerConnectException(""String_Node_Str"" + remote.getName(),e);
    throw except;
  }
}",0.9734900245968844
95071,"protected ContainerMessage acceptNewClient(Socket socket,String target,Serializable data,ISynchAsynchConnection conn){
  debug(""String_Node_Str"" + socket + ""String_Node_Str""+ target+ ""String_Node_Str""+ data+ ""String_Node_Str""+ conn+ ""String_Node_Str"");
  try {
    ContainerMessage mess=(ContainerMessage)data;
    if (mess == null)     throw new InvalidObjectException(""String_Node_Str"");
    ID remoteID=mess.getFromContainerID();
    if (remoteID == null)     throw new InvalidObjectException(""String_Node_Str"");
    ContainerMessage.JoinGroupMessage jgm=(ContainerMessage.JoinGroupMessage)mess.getData();
    if (jgm == null)     throw new IOException(""String_Node_Str"");
    ID memberIDs[]=null;
synchronized (getGroupMembershipLock()) {
      if (isClosing) {
        Exception e=new InvalidObjectException(""String_Node_Str"");
        throw e;
      }
      checkJoin(socket.getRemoteSocketAddress(),remoteID,target,jgm.getData());
      ISynchConnection oldConn=getSynchConnectionForID(remoteID);
      if (oldConn != null) {
        memberLeave(remoteID,oldConn);
      }
      if (addNewRemoteMember(remoteID,conn)) {
        try {
          forwardExcluding(getID(),remoteID,ContainerMessage.createViewChangeMessage(getID(),remoteID,getNextSequenceNumber(),new ID[]{remoteID},true,null));
        }
 catch (        IOException e) {
          traceStack(""String_Node_Str"",e);
        }
        memberIDs=groupManager.getMemberIDs();
        conn.start();
      }
 else {
        ConnectException e=new ConnectException(""String_Node_Str"");
        throw e;
      }
    }
    fireContainerEvent(new ContainerConnectedEvent(this.getID(),remoteID));
    return ContainerMessage.createViewChangeMessage(getID(),remoteID,getNextSequenceNumber(),memberIDs,true,null);
  }
 catch (  Exception e) {
    logException(""String_Node_Str"" + socket + ""String_Node_Str""+ target+ ""String_Node_Str""+ data+ ""String_Node_Str""+ conn,e);
    return null;
  }
}","protected ContainerMessage acceptNewClient(Socket socket,String target,Serializable data,ISynchAsynchConnection conn){
  debug(""String_Node_Str"" + socket + ""String_Node_Str""+ target+ ""String_Node_Str""+ data+ ""String_Node_Str""+ conn+ ""String_Node_Str"");
  ContainerMessage connectMessage=null;
  ID remoteID=null;
  try {
    connectMessage=(ContainerMessage)data;
    if (connectMessage == null)     throw new NullPointerException(""String_Node_Str"");
    remoteID=connectMessage.getFromContainerID();
    if (remoteID == null)     throw new NullPointerException(""String_Node_Str"");
    ContainerMessage.JoinGroupMessage jgm=(ContainerMessage.JoinGroupMessage)connectMessage.getData();
    if (jgm == null)     throw new NullPointerException(""String_Node_Str"");
    ID memberIDs[]=null;
synchronized (getGroupMembershipLock()) {
      if (isClosing) {
        Exception e=new IllegalStateException(""String_Node_Str"");
        throw e;
      }
      checkJoin(socket.getRemoteSocketAddress(),remoteID,target,jgm.getData());
      ISynchConnection oldConn=getSynchConnectionForID(remoteID);
      if (oldConn != null) {
        memberLeave(remoteID,oldConn);
      }
      if (addNewRemoteMember(remoteID,conn)) {
        try {
          forwardExcluding(getID(),remoteID,ContainerMessage.createViewChangeMessage(getID(),remoteID,getNextSequenceNumber(),new ID[]{remoteID},true,null));
        }
 catch (        IOException e) {
          traceStack(""String_Node_Str"",e);
        }
        memberIDs=groupManager.getMemberIDs();
        conn.start();
      }
 else {
        ConnectException e=new ConnectException(""String_Node_Str"");
        throw e;
      }
    }
    fireContainerEvent(new ContainerConnectedEvent(this.getID(),remoteID));
    return ContainerMessage.createViewChangeMessage(getID(),remoteID,getNextSequenceNumber(),memberIDs,true,null);
  }
 catch (  Exception e) {
    logException(""String_Node_Str"" + socket + ""String_Node_Str""+ target+ ""String_Node_Str""+ data+ ""String_Node_Str""+ conn,e);
    return ContainerMessage.createViewChangeMessage(getID(),remoteID,getNextSequenceNumber(),null,false,e);
  }
}",0.3622511673629884
95072,"protected final static Namespace removeNamespace0(Namespace n){
  if (n == null)   return null;
  return (Namespace)namespaces.remove(n);
}","protected final static Namespace removeNamespace0(Namespace n){
  if (n == null)   return null;
  return (Namespace)namespaces.remove(n.getName());
}",0.9652777777777778
95073,"public ID createInstance(Object[] args) throws IDCreateException {
  return new StringID(this,(String)args[0]);
}","public ID createInstance(Object[] args) throws IDCreateException {
  if (args == null || args.length == 0) {
    throw new IDCreateException(""String_Node_Str"");
  }
 else   return new StringID(this,(String)args[0]);
}",0.6848484848484848
95074,"public IRemoteServiceReference[] getRemoteServiceReferences(ID[] idFilter,String clazz,String filter){
  IRemoteFilter remoteFilter=createRemoteFilterFromString(filter);
  List references=new ArrayList();
synchronized (remoteRegistrys) {
    if (idFilter == null) {
      ArrayList registrys=new ArrayList(remoteRegistrys.values());
      for (Iterator i=registrys.iterator(); i.hasNext(); ) {
        RemoteServiceRegistryImpl registry=(RemoteServiceRegistryImpl)i.next();
        addReferencesFromRegistry(clazz,remoteFilter,registry,references);
      }
    }
 else {
      for (int i=0; i < idFilter.length; i++) {
        RemoteServiceRegistryImpl registry=(RemoteServiceRegistryImpl)remoteRegistrys.get(idFilter[i]);
        if (registry != null)         addReferencesFromRegistry(clazz,remoteFilter,registry,references);
      }
    }
  }
  return (IRemoteServiceReference[])references.toArray(new IRemoteServiceReference[references.size()]);
}","public IRemoteServiceReference[] getRemoteServiceReferences(ID[] idFilter,String clazz,String filter){
  IRemoteFilter remoteFilter=createRemoteFilterFromString(filter);
  List references=new ArrayList();
synchronized (remoteRegistrys) {
    if (idFilter == null) {
      ArrayList registrys=new ArrayList(remoteRegistrys.values());
      for (Iterator i=registrys.iterator(); i.hasNext(); ) {
        RemoteServiceRegistryImpl registry=(RemoteServiceRegistryImpl)i.next();
        addReferencesFromRegistry(clazz,remoteFilter,registry,references);
      }
    }
 else {
      for (int i=0; i < idFilter.length; i++) {
        RemoteServiceRegistryImpl registry=(RemoteServiceRegistryImpl)remoteRegistrys.get(idFilter[i]);
        if (registry != null)         addReferencesFromRegistry(clazz,remoteFilter,registry,references);
      }
    }
  }
synchronized (localRegistry) {
    addReferencesFromRegistry(clazz,remoteFilter,localRegistry,references);
  }
  return (IRemoteServiceReference[])references.toArray(new IRemoteServiceReference[references.size()]);
}",0.9448584202682564
95075,"public IRemoteServiceRegistration registerRemoteService(String[] clazzes,Object service,Dictionary properties){
  if (service == null)   throw new NullPointerException(""String_Node_Str"");
  int size=clazzes.length;
  if (size == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  String[] copy=new String[clazzes.length];
  for (int i=0; i < clazzes.length; i++) {
    copy[i]=new String(clazzes[i].getBytes());
  }
  clazzes=copy;
  String invalidService=checkServiceClass(clazzes,service);
  if (invalidService != null)   throw new IllegalArgumentException(""String_Node_Str"" + invalidService);
  RemoteServiceRegistrationImpl reg=new RemoteServiceRegistrationImpl();
  reg.publish(this,localRegistry,service,clazzes,properties);
  sendAddRegistration(reg);
  return reg;
}","public IRemoteServiceRegistration registerRemoteService(String[] clazzes,Object service,Dictionary properties){
  if (service == null)   throw new NullPointerException(""String_Node_Str"");
  int size=clazzes.length;
  if (size == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  String[] copy=new String[clazzes.length];
  for (int i=0; i < clazzes.length; i++) {
    copy[i]=new String(clazzes[i].getBytes());
  }
  clazzes=copy;
  String invalidService=checkServiceClass(clazzes,service);
  if (invalidService != null)   throw new IllegalArgumentException(""String_Node_Str"" + invalidService);
  RemoteServiceRegistrationImpl reg=new RemoteServiceRegistrationImpl();
  reg.publish(this,localRegistry,service,clazzes,properties);
  sendAddRegistration(null,reg);
  return reg;
}",0.9968253968253968
95076,"protected void sendAddRegistration(RemoteServiceRegistrationImpl reg){
  trace(""String_Node_Str"" + null + ""String_Node_Str""+ reg+ ""String_Node_Str"");
  try {
    sendSharedObjectMsgTo(null,SharedObjectMsg.createMsg(null,ADD_REGISTRATION,getLocalContainerID(),reg));
  }
 catch (  IOException e) {
    logSendError(ADD_REGISTRATION_ERROR_CODE,ADD_REGISTRATION_ERROR_MESSAGE,e);
  }
}","protected void sendAddRegistration(ID receiver,RemoteServiceRegistrationImpl reg){
  trace(""String_Node_Str"" + null + ""String_Node_Str""+ reg+ ""String_Node_Str"");
  try {
    sendSharedObjectMsgTo(null,SharedObjectMsg.createMsg(null,ADD_REGISTRATION,getLocalContainerID(),reg));
  }
 catch (  IOException e) {
    logSendError(ADD_REGISTRATION_ERROR_CODE,ADD_REGISTRATION_ERROR_MESSAGE,e);
  }
}",0.9845360824742267
95077,"protected void handleContainerConnectedEvent(IContainerConnectedEvent event){
  if (getContext().isGroupManager() || event.getTargetID().equals(getGroupID())) {
    trace(""String_Node_Str"" + getLocalContainerID() + ""String_Node_Str""+ getGroupID());
synchronized (localRegistry) {
      RemoteServiceRegistrationImpl registrations[]=localRegistry.getRegistrations();
      if (registrations != null)       for (int i=0; i < registrations.length; i++) {
        RemoteServiceRegistrationImpl registration=registrations[i];
        sendAddRegistration(registration);
      }
    }
  }
}","protected void handleContainerConnectedEvent(IContainerConnectedEvent event){
  ID targetID=event.getTargetID();
  if (getContext().isGroupManager() || event.getTargetID().equals(getGroupID())) {
    targetID=null;
  }
synchronized (localRegistry) {
    RemoteServiceRegistrationImpl registrations[]=localRegistry.getRegistrations();
    if (registrations != null)     for (int i=0; i < registrations.length; i++) {
      RemoteServiceRegistrationImpl registration=registrations[i];
      sendAddRegistration(targetID,registration);
    }
  }
}",0.8322981366459627
95078,"/** 
 * Cancel this file transfer.  If file transfer has already been completed, then this method has no effect.  If the file transfer has not been completed then calling this method will result in an   {@link IFileTransferEvent} beingdelivered to the  {@link IFileTransferListener} indicating that transferis done ( {@link #isDone()} returns true), and some exception will be madeavailable
 */
public void cancel();","/** 
 * Cancel this file transfer. If file transfer has already been completed, then this method has no effect. If the file transfer has not been completed then calling this method will result in an  {@link IFileTransferEvent} being delivered to the{@link IFileTransferListener} indicating that transfer is done ({@link #isDone()}returns true), and some exception will be made available
 */
public void cancel();",0.9879227053140096
95079,"/** 
 * Get any properties associated with this file transfer. The map keys and values are assumed to be Strings.
 * @return Map of properties associated with this file transfer info.Will not return null.
 */
public Map getProperties();","/** 
 * Get any properties associated with this file transfer. The map keys and values are assumed to be Strings.
 * @return Map of properties associated with this file transfer info. Willnot return null.
 */
public Map getProperties();",0.9957627118644068
95080,"public final boolean initialize(String name,String desc){
  if (name == null)   throw new RuntimeException(new InstantiationException(""String_Node_Str""));
  if (!isInitialized) {
    this.name=name;
    this.description=desc;
    this.hashCode=name.hashCode();
    return true;
  }
 else   return false;
}","public final boolean initialize(String name,String desc){
  if (name == null)   throw new RuntimeException(new InstantiationException(""String_Node_Str""));
  if (!isInitialized) {
    this.name=name;
    this.description=desc;
    this.hashCode=name.hashCode();
    this.isInitialized=true;
    return true;
  }
 else   return false;
}",0.9546165884194052
95081,"protected void openStreams() throws IncomingFileTransferException {
  URL theURL=null;
  try {
    theURL=getRemoteFileReference().toURL();
    urlConnection=theURL.openConnection();
    setInputStream(urlConnection.getInputStream());
    setFileLength(fileLength=urlConnection.getContentLength());
    listener.handleTransferEvent(new IIncomingFileTransferReceiveStartEvent(){
      private static final long serialVersionUID=-59096575294481755L;
      public URI getURI(){
        try {
          return new URI(urlConnection.getURL().toString());
        }
 catch (        Exception e) {
          return getRemoteFileReference();
        }
      }
      public IIncomingFileTransfer receive(      File localFileToSave) throws IOException {
        setOutputStream(new BufferedOutputStream(new FileOutputStream(localFileToSave)));
        job=new FileTransferJob(getRemoteFileReference().toString());
        job.schedule();
        return UrlRetrieveFileTransfer.this;
      }
      public String toString(){
        StringBuffer sb=new StringBuffer(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(done).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(bytesReceived).append(""String_Node_Str"");
        return sb.toString();
      }
    }
);
  }
 catch (  Exception e) {
    throw new IncomingFileTransferException(""String_Node_Str"" + theURL.toString(),e);
  }
}","protected void openStreams() throws IncomingFileTransferException {
  URL theURL=null;
  try {
    theURL=getRemoteFileReference().toURL();
    urlConnection=theURL.openConnection();
    setInputStream(urlConnection.getInputStream());
    setFileLength(fileLength=urlConnection.getContentLength());
    listener.handleTransferEvent(new IIncomingFileTransferReceiveStartEvent(){
      private static final long serialVersionUID=-59096575294481755L;
      public URI getURI(){
        try {
          return new URI(urlConnection.getURL().toString());
        }
 catch (        Exception e) {
          return getRemoteFileReference();
        }
      }
      public IIncomingFileTransfer receive(      File localFileToSave) throws IOException {
        setOutputStream(new BufferedOutputStream(new FileOutputStream(localFileToSave)));
        job=new FileTransferJob(getRemoteFileReference().toString());
        job.schedule();
        return UrlRetrieveFileTransfer.this;
      }
      public String toString(){
        StringBuffer sb=new StringBuffer(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(done).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(bytesReceived).append(""String_Node_Str"");
        return sb.toString();
      }
      public void cancel(){
        hardClose();
      }
    }
);
  }
 catch (  Exception e) {
    throw new IncomingFileTransferException(""String_Node_Str"" + theURL.toString(),e);
  }
}",0.9801047120418848
95082,"public IContainer createInstance(ContainerTypeDescription description,Object[] args) throws ContainerCreateException {
  boolean isClient=true;
  if (description.getName().equals(TCPSERVER_NAME)) {
    debug(""String_Node_Str"");
    isClient=false;
  }
 else {
    debug(""String_Node_Str"");
  }
  ID newID=null;
  try {
    String[] argDefaults=description.getArgDefaults();
    newID=(argDefaults == null || argDefaults.length == 0) ? null : getIDFromArg(description.getArgDefaults()[0]);
    Integer ka=(argDefaults == null || argDefaults.length < 2) ? null : getIntegerFromArg(description.getArgDefaults()[1]);
    if (args != null) {
      if (args.length > 0) {
        newID=getIDFromArg(args[0]);
        if (args.length > 1) {
          ka=getIntegerFromArg(args[1]);
        }
      }
    }
    debug(""String_Node_Str"" + newID + ""String_Node_Str""+ ka);
    if (newID == null)     throw new ContainerCreateException(""String_Node_Str"");
    if (isClient) {
      return new TCPClientSOContainer(new SOContainerConfig(newID),ka.intValue());
    }
 else {
      return new TCPServerSOContainer(new SOContainerConfig(newID),ka.intValue());
    }
  }
 catch (  ClassCastException e) {
    traceStack(""String_Node_Str"",e);
    throw new ContainerCreateException(""String_Node_Str"",e);
  }
catch (  Exception e) {
    traceStack(""String_Node_Str"",e);
    throw new ContainerCreateException(""String_Node_Str"" + newID,e);
  }
}","public IContainer createInstance(ContainerTypeDescription description,Object[] args) throws ContainerCreateException {
  boolean isClient=true;
  if (description.getName().equals(TCPSERVER_NAME)) {
    debug(""String_Node_Str"");
    isClient=false;
  }
 else {
    debug(""String_Node_Str"");
  }
  try {
    GenericContainerArgs gcargs=null;
    String[] argDefaults=description.getArgDefaults();
    if (isClient)     gcargs=getClientArgs(argDefaults,args);
 else     gcargs=getServerArgs(argDefaults,args);
    if (isClient) {
      return new TCPClientSOContainer(new SOContainerConfig(gcargs.getID()),gcargs.getKeepAlive().intValue());
    }
 else {
      return new TCPServerSOContainer(new SOContainerConfig(gcargs.getID()),gcargs.getKeepAlive().intValue());
    }
  }
 catch (  Exception e) {
    traceStack(""String_Node_Str"",e);
    throw new ContainerCreateException(""String_Node_Str"",e);
  }
}",0.304516129032258
95083,"protected ISharedObjectContainer createClient() throws Exception {
  ID newContainerID=IDFactory.getDefault().createGUID();
  ISharedObjectContainer result=SharedObjectContainerFactory.getDefault().createSharedObjectContainer(contd,null,new Object[]{newContainerID,new Integer(DEFAULT_TIMEOUT)});
  return result;
}","protected ISharedObjectContainer createClient() throws Exception {
  ID newContainerID=IDFactory.getDefault().createGUID();
  ISharedObjectContainer result=SharedObjectContainerFactory.getDefault().createSharedObjectContainer(contd,new Object[]{newContainerID,new Integer(DEFAULT_TIMEOUT)});
  return result;
}",0.992
95084,"public void handleEvent(Event event){
  traceEntering(""String_Node_Str"",event);
  Trace.trace(Activator.getDefault(),getID() + ""String_Node_Str"" + ""String_Node_Str""+ event+ ""String_Node_Str"");
synchronized (eventProcessors) {
    fireEventProcessors(event);
  }
  traceExiting(""String_Node_Str"",event);
}","public void handleEvent(Event event){
  traceEntering(""String_Node_Str"",event);
synchronized (eventProcessors) {
    fireEventProcessors(event);
  }
  traceExiting(""String_Node_Str"");
}",0.7566462167689162
95085,"protected void destroySelfLocal(){
  traceEntering(""String_Node_Str"",null);
  try {
    ISharedObjectManager manager=getContext().getSharedObjectManager();
    if (manager != null) {
      manager.removeSharedObject(getID());
    }
  }
 catch (  Exception e) {
    traceCatching(""String_Node_Str"",e);
  }
  traceExiting(""String_Node_Str"",null);
}","protected void destroySelfLocal(){
  traceEntering(""String_Node_Str"");
  try {
    ISharedObjectManager manager=getContext().getSharedObjectManager();
    if (manager != null) {
      manager.removeSharedObject(getID());
    }
  }
 catch (  Exception e) {
    traceCatching(""String_Node_Str"",e);
    logError(DESTROYSELFLOCAL_CODE,""String_Node_Str"",e);
  }
  traceExiting(""String_Node_Str"");
}",0.9093369418132612
95086,"/** 
 * Send SharedObjectMessage to container with given ID. The toID parameter may be null, and if null the message will be delivered to <b>all</b> containers in group. The second parameter may not be null.
 * @param toID the target container ID for the SharedObjectMsg. If null, the given message is sent to all other containers currently in group
 * @param msg the message instance to send
 * @throws IOException thrown if the local container is not connected or unable to send for other reason
 */
protected void sendSharedObjectMsgTo(ID toID,SharedObjectMsg msg) throws IOException {
  if (msg == null)   throw new NullPointerException(""String_Node_Str"");
  String method=""String_Node_Str"";
  traceEntering(method,new Object[]{toID,msg});
  getContext().sendMessage(toID,new SharedObjectMsgEvent(getID(),toID,msg));
  traceExiting(method,null);
}","/** 
 * Send SharedObjectMessage to container with given ID. The toID parameter may be null, and if null the message will be delivered to <b>all</b> containers in group. The second parameter may not be null.
 * @param toID the target container ID for the SharedObjectMsg. If null, the given message is sent to all other containers currently in group
 * @param msg the message instance to send
 * @throws IOException thrown if the local container is not connected or unable to send for other reason
 */
protected void sendSharedObjectMsgTo(ID toID,SharedObjectMsg msg) throws IOException {
  if (msg == null)   throw new NullPointerException(""String_Node_Str"");
  String method=""String_Node_Str"";
  traceEntering(method,new Object[]{toID,msg});
  getContext().sendMessage(toID,new SharedObjectMsgEvent(getID(),toID,msg));
  traceExiting(method);
}",0.9970536240424278
95087,"/** 
 * Handle a ISharedObjectCreateResponseEvent. This handler is called by handleSharedObjectMsgEvent when the ISharedObjectMessageEvent is of type ISharedObjectCreateResponseEvent. This default implementation simply returns false. Subclasses may override as appropriate. Note that if return value is true, it will prevent subsequent event processors from having a chance to process event
 * @param createResponseEvent the ISharedObjectCreateResponseEvent received
 * @return true if the provided event should receive no further processing.If false the provided Event should be passed to subsequent event processors.
 */
protected boolean handleSharedObjectCreateResponseEvent(ISharedObjectCreateResponseEvent createResponseEvent){
  traceEntering(""String_Node_Str"",createResponseEvent);
  return false;
}","/** 
 * Handle a ISharedObjectCreateResponseEvent. This handler is called by handleSharedObjectMsgEvent when the ISharedObjectMessageEvent is of type ISharedObjectCreateResponseEvent. This default implementation simply returns false. Subclasses may override as appropriate. Note that if return value is true, it will prevent subsequent event processors from having a chance to process event
 * @param createResponseEvent the ISharedObjectCreateResponseEvent received
 * @return true if the provided event should receive no further processing.If false the provided Event should be passed to subsequent event processors.
 */
protected boolean handleSharedObjectCreateResponseEvent(ISharedObjectCreateResponseEvent createResponseEvent){
  return false;
}",0.9640564826700898
95088,"public final void init(ISharedObjectConfig initData) throws SharedObjectInitException {
  String methodName=""String_Node_Str"";
  traceEntering(methodName,new Object[]{initData});
  this.config=initData;
  addEventProcessor(new SharedObjectMsgEventProcessor(this));
  initialize();
  traceExiting(methodName,null);
}","public final void init(ISharedObjectConfig initData) throws SharedObjectInitException {
  this.config=initData;
  traceEntering(""String_Node_Str"",initData);
  addEventProcessor(new SharedObjectMsgEventProcessor(this));
  initialize();
  traceExiting(""String_Node_Str"");
}",0.3720136518771331
95089,"/** 
 * Send SharedObjectMsg to local shared object. This places the given message at the end of this shared object's message queue for processing.
 * @param msg the message instance to send.
 */
protected void sendSharedObjectMsgToSelf(SharedObjectMsg msg){
  if (msg == null)   throw new NullPointerException(""String_Node_Str"");
  ISharedObjectContext context=getContext();
  if (context == null)   return;
  IQueueEnqueue queue=context.getQueue();
  try {
    queue.enqueue(new SharedObjectMsgEvent(getID(),getContext().getLocalContainerID(),msg));
  }
 catch (  QueueException e) {
    traceCatching(""String_Node_Str"",e);
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,DESTROYREMOTE_CODE,""String_Node_Str"" + getID(),e));
  }
}","/** 
 * Send SharedObjectMsg to local shared object. This places the given message at the end of this shared object's message queue for processing.
 * @param msg the message instance to send.
 */
protected void sendSharedObjectMsgToSelf(SharedObjectMsg msg){
  if (msg == null)   throw new NullPointerException(""String_Node_Str"");
  ISharedObjectContext context=getContext();
  if (context == null)   return;
  IQueueEnqueue queue=context.getQueue();
  try {
    queue.enqueue(new SharedObjectMsgEvent(getID(),getContext().getLocalContainerID(),msg));
  }
 catch (  QueueException e) {
    traceCatching(""String_Node_Str"",e);
    logError(DESTROYREMOTE_CODE,""String_Node_Str"",e);
  }
}",0.930488644184446
95090,"/** 
 * Get SharedObjectMsg from ISharedObjectMessageEvent. ISharedObjectMessageEvents can come from both local and remote sources. In the remote case, the SharedObjectMsg has to be retrieved from the RemoteSharedObjectEvent rather than the ISharedObjectMessageEvent.getData() directly. This method will provide a non-null SharedObjectMsg if it's provided either via remotely or locally. Returns null if the given event does not provide a valid SharedObjectMsg.
 * @param event
 * @return SharedObjectMsg the SharedObjectMsg delivered by the given event
 */
protected SharedObjectMsg getSharedObjectMsgFromEvent(ISharedObjectMessageEvent event){
  String method=""String_Node_Str"";
  traceEntering(method,event);
  Object eventData=event.getData();
  Object msgData=null;
  if (eventData != null && eventData instanceof RemoteSharedObjectEvent) {
    Object rsoeData=((RemoteSharedObjectEvent)event).getData();
    if (rsoeData != null && rsoeData instanceof SharedObjectMsgEvent)     msgData=((SharedObjectMsgEvent)rsoeData).getData();
  }
 else   msgData=eventData;
  if (msgData != null && msgData instanceof SharedObjectMsg)   return (SharedObjectMsg)msgData;
  return null;
}","/** 
 * Get SharedObjectMsg from ISharedObjectMessageEvent. ISharedObjectMessageEvents can come from both local and remote sources. In the remote case, the SharedObjectMsg has to be retrieved from the RemoteSharedObjectEvent rather than the ISharedObjectMessageEvent.getData() directly. This method will provide a non-null SharedObjectMsg if it's provided either via remotely or locally. Returns null if the given event does not provide a valid SharedObjectMsg.
 * @param event
 * @return SharedObjectMsg the SharedObjectMsg delivered by the given event
 */
protected SharedObjectMsg getSharedObjectMsgFromEvent(ISharedObjectMessageEvent event){
  traceEntering(""String_Node_Str"",event);
  Object eventData=event.getData();
  Object msgData=null;
  if (eventData != null && eventData instanceof RemoteSharedObjectEvent) {
    Object rsoeData=((RemoteSharedObjectEvent)event).getData();
    if (rsoeData != null && rsoeData instanceof SharedObjectMsgEvent)     msgData=((SharedObjectMsgEvent)rsoeData).getData();
  }
 else   msgData=eventData;
  if (msgData != null && msgData instanceof SharedObjectMsg) {
    traceExiting(""String_Node_Str"",msgData);
    return (SharedObjectMsg)msgData;
  }
 else {
    traceExiting(""String_Node_Str"",null);
    return null;
  }
}",0.9283667621776504
95091,"/** 
 * SharedObjectMsg handler method. This method will be called by  {@link #handleSharedObjectMsgEvent(ISharedObjectMessageEvent)} when aSharedObjectMsg is received either from a local source or a remote source. This default implementation simply returns false so that other processing of of the given msg can occur. Subclasses should override this behavior to define custom logic for handling SharedObjectMsgs.
 * @param msg the SharedObjectMsg received
 * @return true if the msg has been completely handled and subsequentprocessing should stop. False if processing should continue
 */
protected boolean handleSharedObjectMsg(SharedObjectMsg msg){
  traceEntering(""String_Node_Str"",msg);
  return false;
}","/** 
 * SharedObjectMsg handler method. This method will be called by  {@link #handleSharedObjectMsgEvent(ISharedObjectMessageEvent)} when aSharedObjectMsg is received either from a local source or a remote source. This default implementation simply returns false so that other processing of of the given msg can occur. Subclasses should override this behavior to define custom logic for handling SharedObjectMsgs.
 * @param msg the SharedObjectMsg received
 * @return true if the msg has been completely handled and subsequentprocessing should stop. False if processing should continue
 */
protected boolean handleSharedObjectMsg(SharedObjectMsg msg){
  return false;
}",0.9710144927536232
95092,"private void traceCatching(String method,Throwable t){
  Trace.catching(Activator.getDefault(),SharedObjectDebugOptions.EXCEPTIONS_CATCHING,BaseSharedObject.class,getID() + ""String_Node_Str"" + method,t);
}","protected void traceCatching(String method,Throwable t){
  Trace.catching(Activator.getDefault(),SharedObjectDebugOptions.EXCEPTIONS_CATCHING,this.getClass(),getSharedObjectAsString(method),t);
}",0.855
95093,"/** 
 * Replicate this shared object to a given set of remote containers. This method will invoke the method getReplicaDescriptions in order to determine the set of ReplicaSharedObjectDescriptions to send to remote containers.
 * @param remoteContainers the set of remote containers to replicate to. If null, <b>all</b> containers in the current group are sent a message to create a replica of this shared object.
 */
protected void replicateToRemoteContainers(ID[] remoteContainers){
  traceEntering(""String_Node_Str"",remoteContainers);
  try {
    ISharedObjectContext context=getContext();
    if (context == null)     return;
    ID[] group=context.getGroupMemberIDs();
    if (group == null || group.length < 1) {
      return;
    }
    ReplicaSharedObjectDescription[] createInfos=getReplicaDescriptions(remoteContainers);
    if (createInfos != null) {
      if (createInfos.length == 1) {
        context.sendCreate((remoteContainers == null) ? null : remoteContainers[0],createInfos[0]);
      }
 else {
        for (int i=0; i < remoteContainers.length; i++) {
          context.sendCreate(remoteContainers[i],createInfos[i]);
        }
      }
    }
  }
 catch (  IOException e) {
    traceCatching(""String_Node_Str"",e);
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,DESTROYREMOTE_CODE,""String_Node_Str"" + getID(),e));
  }
}","/** 
 * Replicate this shared object to a given set of remote containers. This method will invoke the method getReplicaDescriptions in order to determine the set of ReplicaSharedObjectDescriptions to send to remote containers.
 * @param remoteContainers the set of remote containers to replicate to. If null, <b>all</b> containers in the current group are sent a message to create a replica of this shared object.
 */
protected void replicateToRemoteContainers(ID[] remoteContainers){
  traceEntering(""String_Node_Str"",remoteContainers);
  try {
    ReplicaSharedObjectDescription[] createInfos=getReplicaDescriptions(remoteContainers);
    if (createInfos != null) {
      if (createInfos.length == 1) {
        getContext().sendCreate((remoteContainers == null) ? null : remoteContainers[0],createInfos[0]);
      }
 else {
        for (int i=0; i < remoteContainers.length; i++) {
          getContext().sendCreate(remoteContainers[i],createInfos[i]);
        }
      }
    }
  }
 catch (  IOException e) {
    traceCatching(""String_Node_Str"" + DESTROYREMOTE_CODE,e);
    logError(DESTROYREMOTE_CODE,""String_Node_Str"",e);
  }
}",0.7568862275449102
95094,"protected void destroySelf(){
  traceEntering(""String_Node_Str"",null);
  if (isPrimary()) {
    try {
      destroyRemote(null);
    }
 catch (    IOException e) {
      traceCatching(""String_Node_Str"",e);
      Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,DESTROYREMOTE_CODE,""String_Node_Str"" + getID(),e));
    }
  }
  destroySelfLocal();
  traceExiting(""String_Node_Str"",null);
}","protected void destroySelf(){
  traceEntering(""String_Node_Str"");
  if (isPrimary()) {
    try {
      destroyRemote(null);
    }
 catch (    IOException e) {
      traceCatching(""String_Node_Str"",e);
      logError(DESTROYREMOTE_CODE,""String_Node_Str"",e);
    }
  }
  destroySelfLocal();
  traceExiting(""String_Node_Str"");
}",0.8506056527590848
95095,"private void traceEntering(String methodName,Object param){
  Trace.entering(Activator.getDefault(),SharedObjectDebugOptions.METHODS_ENTERING,BaseSharedObject.class,getID() + ""String_Node_Str"" + methodName,param);
}","protected void traceEntering(String methodName,Object param){
  Trace.entering(Activator.getDefault(),SharedObjectDebugOptions.METHODS_ENTERING,this.getClass(),getSharedObjectAsString(methodName));
}",0.8454106280193237
95096,"private void traceExiting(String methodName,Object result){
  Trace.entering(Activator.getDefault(),SharedObjectDebugOptions.METHODS_EXITING,BaseSharedObject.class,getID() + ""String_Node_Str"" + methodName,result);
}","protected void traceExiting(String methodName,Object result){
  Trace.entering(Activator.getDefault(),SharedObjectDebugOptions.METHODS_EXITING,this.getClass(),getSharedObjectAsString(methodName));
}",0.8426150121065376
95097,"/** 
 * Handle a ISharedObjectMessageEvent. This method will be automatically called by the SharedObjectMsgEventProcessor when a ISharedObjectMessageEvent is received. The SharedObjectMsgEventProcessor is associated with this object via the initialize() method
 * @param event the event to handle
 * @return true if the provided event should receive no further processing.If false the provided Event should be passed to subsequent event processors.
 */
protected boolean handleSharedObjectMsgEvent(ISharedObjectMessageEvent event){
  traceEntering(""String_Node_Str"",event);
  if (event instanceof ISharedObjectCreateResponseEvent)   return handleSharedObjectCreateResponseEvent((ISharedObjectCreateResponseEvent)event);
 else {
    SharedObjectMsg msg=getSharedObjectMsgFromEvent(event);
    if (msg != null)     return handleSharedObjectMsg(msg);
 else     return false;
  }
}","/** 
 * Handle a ISharedObjectMessageEvent. This method will be automatically called by the SharedObjectMsgEventProcessor when a ISharedObjectMessageEvent is received. The SharedObjectMsgEventProcessor is associated with this object via the initialize() method
 * @param event the event to handle
 * @return true if the provided event should receive no further processing.If false the provided Event should be passed to subsequent event processors.
 */
protected boolean handleSharedObjectMsgEvent(ISharedObjectMessageEvent event){
  traceEntering(""String_Node_Str"",event);
  boolean result=false;
  if (event instanceof ISharedObjectCreateResponseEvent)   result=handleSharedObjectCreateResponseEvent((ISharedObjectCreateResponseEvent)event);
 else {
    SharedObjectMsg msg=getSharedObjectMsgFromEvent(event);
    if (msg != null)     result=handleSharedObjectMsg(msg);
  }
  traceExiting(""String_Node_Str"",new Boolean(result));
  return result;
}",0.904709748083242
95098,"public void dispose(ID containerID){
  traceEntering(""String_Node_Str"",new Object[]{containerID});
  eventProcessors.clear();
  config=null;
  traceExiting(""String_Node_Str"",null);
}","public void dispose(ID containerID){
  traceEntering(""String_Node_Str"",containerID);
  eventProcessors.clear();
  config=null;
  traceExiting(""String_Node_Str"");
}",0.944927536231884
95099,"/** 
 * Initialize this shared object. Subclasses may override as appropriate to define custom initialization behavior. If initialization should fail, then a SharedObjectInitException should be thrown by implementing code. Also, subclasses overriding this method should call super.initialize() before running their own code.
 * @throws SharedObjectInitException if initialization should throw
 */
protected void initialize() throws SharedObjectInitException {
  traceEntering(""String_Node_Str"",null);
}","/** 
 * Initialize this shared object. Subclasses may override as appropriate to define custom initialization behavior. If initialization should fail, then a SharedObjectInitException should be thrown by implementing code. Also, subclasses overriding this method should call super.initialize() before running their own code.
 * @throws SharedObjectInitException if initialization should throw
 */
protected void initialize() throws SharedObjectInitException {
  traceEntering(""String_Node_Str"");
}",0.994994994994995
95100,"public void handleEvents(Event[] events){
  traceEntering(""String_Node_Str"",events);
  if (events == null)   return;
  for (int i=0; i < events.length; i++) {
    handleEvent(events[i]);
  }
  traceExiting(""String_Node_Str"",null);
}","public void handleEvents(Event[] events){
  traceEntering(""String_Node_Str"",events);
  if (events == null)   return;
  for (int i=0; i < events.length; i++) {
    handleEvent(events[i]);
  }
  traceExiting(""String_Node_Str"");
}",0.989106753812636
95101,"public List getNamespaces(){
  initialize();
  Trace.entering(Activator.getDefault(),IdentityDebugOptions.METHODS_ENTERING,IDFactory.class,""String_Node_Str"");
  return new ArrayList(namespaces.values());
}","public List getNamespaces(){
  Trace.entering(Activator.getDefault(),IdentityDebugOptions.METHODS_ENTERING,IDFactory.class,""String_Node_Str"");
  return new ArrayList(namespaces.values());
}",0.9593908629441624
95102,"public Namespace getNamespaceByName(String name) throws SecurityException {
  initialize();
  Trace.entering(Activator.getDefault(),IdentityDebugOptions.METHODS_ENTERING,IDFactory.class,""String_Node_Str"",name);
  Namespace result=getNamespace0(name);
  Trace.exiting(Activator.getDefault(),IdentityDebugOptions.METHODS_EXITING,IDFactory.class,""String_Node_Str"",result);
  return result;
}","public Namespace getNamespaceByName(String name) throws SecurityException {
  Trace.entering(Activator.getDefault(),IdentityDebugOptions.METHODS_ENTERING,IDFactory.class,""String_Node_Str"",name);
  Namespace result=getNamespace0(name);
  Trace.exiting(Activator.getDefault(),IdentityDebugOptions.METHODS_EXITING,IDFactory.class,""String_Node_Str"",result);
  return result;
}",0.9789473684210528
95103,"public Namespace getNamespace(Namespace namespace) throws SecurityException {
  initialize();
  Trace.entering(Activator.getDefault(),IdentityDebugOptions.METHODS_ENTERING,IDFactory.class,""String_Node_Str"",namespace);
  if (namespace == null)   return null;
  checkPermission(new NamespacePermission(namespace.toString(),NamespacePermission.GET_NAMESPACE));
  Namespace result=getNamespace0(namespace);
  Trace.exiting(Activator.getDefault(),IdentityDebugOptions.METHODS_EXITING,IDFactory.class,""String_Node_Str"",result);
  return result;
}","public Namespace getNamespace(Namespace namespace) throws SecurityException {
  Trace.entering(Activator.getDefault(),IdentityDebugOptions.METHODS_ENTERING,IDFactory.class,""String_Node_Str"",namespace);
  if (namespace == null)   return null;
  checkPermission(new NamespacePermission(namespace.toString(),NamespacePermission.GET_NAMESPACE));
  Namespace result=getNamespace0(namespace);
  Trace.exiting(Activator.getDefault(),IdentityDebugOptions.METHODS_EXITING,IDFactory.class,""String_Node_Str"",result);
  return result;
}",0.9849624060150376
95104,"protected IDFactory(){
}","protected IDFactory(){
  if (!initialized) {
    if (standAlone)     System.out.println(""String_Node_Str"");
 else     Activator.getDefault().setupNamespaceExtensionPoint();
  }
  initialized=true;
}",0.2162162162162162
95105,"/** 
 * An ECF client container implementation that runs as an application. <p> Usage: java org.eclipse.ecf.provider.app.ClientApplication &lt;serverid&gt <p> If &lt;serverid&gt; is omitted or ""-"" is specified, ecftcp://localhost:3282/server"" is used.  
 */
public static void main(String[] args) throws Exception {
  ClientApplication st=new ClientApplication();
  st.init(args);
  ID serverID=IDFactory.getDefault().createStringID(st.serverName);
  st.connect(serverID);
  st.createSharedObjects();
  System.out.println(""String_Node_Str"" + DEFAULT_WAITTIME + ""String_Node_Str"");
  Thread.sleep(DEFAULT_WAITTIME);
  st.removeSharedObjects();
  st.disconnect();
  System.out.println(""String_Node_Str"");
}","/** 
 * An ECF client container implementation that runs as an application. <p> Usage: java org.eclipse.ecf.provider.app.ClientApplication &lt;serverid&gt <p> If &lt;serverid&gt; is omitted or ""-"" is specified, ecftcp://localhost:3282/server"" is used.  
 */
public static void main(String[] args) throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  ClientApplication st=new ClientApplication();
  st.init(args);
  ID serverID=IDFactory.getDefault().createStringID(st.serverName);
  st.connect(serverID);
  st.createSharedObjects();
  System.out.println(""String_Node_Str"" + DEFAULT_WAITTIME + ""String_Node_Str"");
  Thread.sleep(DEFAULT_WAITTIME);
  st.removeSharedObjects();
  st.disconnect();
  System.out.println(""String_Node_Str"");
}",0.9226736566186108
95106,"public static void main(String args[]) throws Exception {
  String serverName=null;
  List connectors=null;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      ServerConfigParser parser=new ServerConfigParser();
      connectors=parser.load(new FileInputStream(args[1]));
    }
 else     if (!args[0].equals(""String_Node_Str""))     serverName=args[0];
  }
  if (connectors != null) {
    serverGroups=new TCPServerSOContainerGroup[connectors.size()];
    int j=0;
    for (Iterator i=connectors.iterator(); i.hasNext(); ) {
      Connector connect=(Connector)i.next();
      serverGroups[j]=createServerGroup(connect.getHostname(),connect.getPort());
      List groups=connect.getGroups();
      for (Iterator g=groups.iterator(); g.hasNext(); ) {
        NamedGroup group=(NamedGroup)g.next();
        TCPServerSOContainer cont=createServerContainer(group.getIDForGroup(),serverGroups[j],group.getName(),connect.getTimeout());
        servers.add(cont);
      }
      System.out.println(""String_Node_Str"" + connect.getHostname() + ""String_Node_Str"");
      serverGroups[j].putOnTheAir();
      j++;
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    if (serverName == null) {
      serverName=TCPServerSOContainer.getDefaultServerURL();
    }
    java.net.URI anURL=new java.net.URI(serverName);
    int port=anURL.getPort();
    if (port == -1) {
      port=TCPServerSOContainer.DEFAULT_PORT;
    }
    String name=anURL.getPath();
    if (name == null) {
      name=TCPServerSOContainer.DEFAULT_NAME;
    }
    serverGroups=new TCPServerSOContainerGroup[1];
    serverGroups[0]=new TCPServerSOContainerGroup(anURL.getPort());
    ID id=IDFactory.getDefault().createStringID(serverName);
    SOContainerConfig config=new SOContainerConfig(id);
    System.out.print(""String_Node_Str"");
    TCPServerSOContainer server=new TCPServerSOContainer(config,serverGroups[0],name,TCPServerSOContainer.DEFAULT_KEEPALIVE);
    ((ISharedObjectContainerGroupManager)server).setConnectPolicy(new JoinListener());
    ISharedObjectManager manager=server.getSharedObjectManager();
    manager.setRemoteAddPolicy(new SharedObjectAddListener());
    serverGroups[0].putOnTheAir();
    servers.add(server);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + id.getName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
}","public static void main(String args[]) throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String serverName=null;
  List connectors=null;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      ServerConfigParser parser=new ServerConfigParser();
      connectors=parser.load(new FileInputStream(args[1]));
    }
 else     if (!args[0].equals(""String_Node_Str""))     serverName=args[0];
  }
  if (connectors != null) {
    serverGroups=new TCPServerSOContainerGroup[connectors.size()];
    int j=0;
    for (Iterator i=connectors.iterator(); i.hasNext(); ) {
      Connector connect=(Connector)i.next();
      serverGroups[j]=createServerGroup(connect.getHostname(),connect.getPort());
      List groups=connect.getGroups();
      for (Iterator g=groups.iterator(); g.hasNext(); ) {
        NamedGroup group=(NamedGroup)g.next();
        TCPServerSOContainer cont=createServerContainer(group.getIDForGroup(),serverGroups[j],group.getName(),connect.getTimeout());
        servers.add(cont);
      }
      System.out.println(""String_Node_Str"" + connect.getHostname() + ""String_Node_Str"");
      serverGroups[j].putOnTheAir();
      j++;
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    if (serverName == null) {
      serverName=TCPServerSOContainer.getDefaultServerURL();
    }
    java.net.URI anURL=new java.net.URI(serverName);
    int port=anURL.getPort();
    if (port == -1) {
      port=TCPServerSOContainer.DEFAULT_PORT;
    }
    String name=anURL.getPath();
    if (name == null) {
      name=TCPServerSOContainer.DEFAULT_NAME;
    }
    serverGroups=new TCPServerSOContainerGroup[1];
    serverGroups[0]=new TCPServerSOContainerGroup(anURL.getPort());
    ID id=IDFactory.getDefault().createStringID(serverName);
    SOContainerConfig config=new SOContainerConfig(id);
    System.out.print(""String_Node_Str"");
    TCPServerSOContainer server=new TCPServerSOContainer(config,serverGroups[0],name,TCPServerSOContainer.DEFAULT_KEEPALIVE);
    ((ISharedObjectContainerGroupManager)server).setConnectPolicy(new JoinListener());
    ISharedObjectManager manager=server.getSharedObjectManager();
    manager.setRemoteAddPolicy(new SharedObjectAddListener());
    serverGroups[0].putOnTheAir();
    servers.add(server);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + id.getName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
}",0.987847579814624
95107,"protected ContainerFactory(){
  try {
    ECFPlugin.getDefault().addDisposable(new IDisposable(){
      public void dispose(){
        doDispose();
      }
    }
);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace(System.err);
  }
}","protected ContainerFactory(){
  if (!standAlone) {
    ECFPlugin.getDefault().addDisposable(new IDisposable(){
      public void dispose(){
        doDispose();
      }
    }
);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}",0.8233009708737864
95108,"/** 
 * An ECF client container implementation that runs as an application. <p> Usage: java org.eclipse.ecf.provider.app.ClientApplication &lt;serverid&gt <p> If &lt;serverid&gt; is omitted or ""-"" is specified, ecftcp://localhost:3282/server"" is used.  
 */
public static void main(String[] args) throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  ClientApplication st=new ClientApplication();
  st.init(args);
  ID serverID=IDFactory.getDefault().createStringID(st.serverName);
  st.connect(serverID);
  st.createSharedObjects();
  System.out.println(""String_Node_Str"" + DEFAULT_WAITTIME + ""String_Node_Str"");
  Thread.sleep(DEFAULT_WAITTIME);
  st.removeSharedObjects();
  st.disconnect();
  System.out.println(""String_Node_Str"");
}","/** 
 * An ECF client container implementation that runs as an application. <p> Usage: java org.eclipse.ecf.provider.app.ClientApplication &lt;serverid&gt <p> If &lt;serverid&gt; is omitted or ""-"" is specified, ecftcp://localhost:3282/server"" is used.  
 */
public static void main(String[] args) throws Exception {
  ClientApplication st=new ClientApplication();
  st.init(args);
  ID serverID=IDFactory.getDefault().createStringID(st.serverName);
  st.connect(serverID);
  st.createSharedObjects();
  System.out.println(""String_Node_Str"" + DEFAULT_WAITTIME + ""String_Node_Str"");
  Thread.sleep(DEFAULT_WAITTIME);
  st.removeSharedObjects();
  st.disconnect();
  System.out.println(""String_Node_Str"");
}",0.959781867757328
95109,"protected ID getIDFromArg(Object arg) throws IDCreateException {
  if (arg instanceof ID)   return (ID)arg;
  if (arg instanceof String) {
    String val=(String)arg;
    if (val == null || val.equals(""String_Node_Str"")) {
      return IDFactory.getDefault().createGUID();
    }
 else     return IDFactory.getDefault().createStringID((String)arg);
  }
 else   if (arg instanceof Integer) {
    return IDFactory.getDefault().createGUID(((Integer)arg).intValue());
  }
 else   return IDFactory.getDefault().createGUID();
}","protected ID getIDFromArg(Object arg) throws IDCreateException {
  if (arg instanceof ID)   return (ID)arg;
  if (arg instanceof String) {
    String val=(String)arg;
    if (val.equals(""String_Node_Str"")) {
      return IDFactory.getDefault().createGUID();
    }
 else     return IDFactory.getDefault().createStringID((String)arg);
  }
 else   if (arg instanceof Integer) {
    return IDFactory.getDefault().createGUID(((Integer)arg).intValue());
  }
 else   return IDFactory.getDefault().createGUID();
}",0.9853658536585366
95110,"public IContainer createInstance(ContainerTypeDescription description,Object[] args) throws ContainerCreateException {
  String[] argDefaults=description.getArgDefaults();
  try {
    ID newID=(argDefaults == null || argDefaults.length == 0) ? null : getIDFromArg(description.getArgDefaults()[0]);
    if (args != null) {
      if (args.length > 0) {
        newID=getIDFromArg(args[0]);
      }
    }
 else {
      newID=IDFactory.getDefault().createGUID();
    }
    return new DatashareContainer(new DatashareContainerConfig(newID));
  }
 catch (  IDCreateException e) {
    throw new ContainerCreateException(""String_Node_Str"" + description,e);
  }
}","public IContainer createInstance(ContainerTypeDescription description,Object[] args) throws ContainerCreateException {
  String[] argDefaults=description.getArgDefaults();
  try {
    ID newID=null;
    if (args != null && args.length != 0) {
      newID=getIDFromArg(args[0]);
    }
 else     if (argDefaults != null && argDefaults.length != 0) {
      newID=getIDFromArg(description.getArgDefaults()[0]);
    }
 else {
      newID=IDFactory.getDefault().createGUID();
    }
    return new DatashareContainer(new DatashareContainerConfig(newID));
  }
 catch (  IDCreateException e) {
    throw new ContainerCreateException(""String_Node_Str"" + description,e);
  }
}",0.8066717210007581
95111,"public ID createInstance(Class[] argTypes,Object[] args) throws IDCreateException {
  if (args == null || args.length <= 0)   return new GUID(this);
 else   return new GUID(this,((Integer)args[0]).intValue());
}","public ID createInstance(Class[] argTypes,Object[] args) throws IDCreateException {
  if (args == null || args.length <= 0)   return new GUID(this);
 else   if (args.length == 1)   return new GUID(((Namespace)args[0]));
 else   if (args.length == 2)   return new GUID(((Namespace)args[0]),((Integer)args[1]).intValue());
 else   return new GUID(this);
}",0.7304964539007093
95112,"private synchronized void handleCommandMessage(String[] tokens){
  String command=tokens[0];
  while (command.startsWith(COMMAND_PREFIX))   command=command.substring(1);
  String[] args=new String[tokens.length - 1];
  System.arraycopy(tokens,1,args,0,tokens.length - 1);
  if (command.equalsIgnoreCase(JOIN_COMMAND)) {
    if (args.length > 1) {
      connection.doJoin(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doJoin(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(LIST_COMMAND)) {
    if (args.length > 0) {
      connection.doList(args[0]);
    }
 else     connection.doList();
  }
 else   if (command.equalsIgnoreCase(PART_COMMAND)) {
    if (args.length > 1) {
      connection.doPart(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doPart(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(NICK_COMMAND)) {
    if (args.length > 0) {
      connection.doNick(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(MSG_COMMAND)) {
    if (args.length > 1) {
      connection.doPrivmsg(args[0],args[1]);
    }
  }
 else   if (command.equalsIgnoreCase(NOTICE_COMMAND)) {
    if (args.length > 1) {
      connection.doNotice(args[0],args[1]);
    }
  }
 else   if (command.equalsIgnoreCase(WHOIS_COMMAND)) {
    if (args.length > 0) {
      connection.doWhois(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(QUIT_COMMAND)) {
    if (args.length > 0) {
      connection.doQuit(args[0]);
    }
 else {
      connection.doQuit();
    }
  }
 else   if (command.equalsIgnoreCase(AWAY_COMMAND)) {
    if (args.length > 0) {
      connection.doAway(args[0]);
    }
 else {
      connection.doAway();
    }
  }
 else   if (command.equalsIgnoreCase(TOPIC_COMMAND)) {
    if (args.length > 1) {
      connection.doTopic(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doTopic(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(INVITE_COMMAND)) {
    if (args.length > 1) {
      connection.doInvite(args[0],args[1]);
    }
  }
 else {
    trace(""String_Node_Str"" + command + ""String_Node_Str""+ getID());
  }
}","private synchronized void handleCommandMessage(String[] tokens){
  String command=tokens[0];
  while (command.startsWith(COMMAND_PREFIX))   command=command.substring(1);
  String[] args=new String[tokens.length - 1];
  System.arraycopy(tokens,1,args,0,tokens.length - 1);
  if (command.equalsIgnoreCase(JOIN_COMMAND)) {
    if (args.length > 1) {
      connection.doJoin(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doJoin(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(LIST_COMMAND)) {
    if (args.length > 0) {
      connection.doList(args[0]);
    }
 else     connection.doList();
  }
 else   if (command.equalsIgnoreCase(PART_COMMAND)) {
    if (args.length > 1) {
      connection.doPart(args[0],args[1]);
    }
 else     if (args.length > 0) {
      connection.doPart(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(NICK_COMMAND)) {
    if (args.length > 0) {
      connection.doNick(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(MSG_COMMAND)) {
    if (args.length > 1) {
      connection.doPrivmsg(args[0],args[1]);
    }
  }
 else   if (command.equalsIgnoreCase(NOTICE_COMMAND)) {
    if (args.length > 1) {
      connection.doNotice(args[0],args[1]);
    }
  }
 else   if (command.equalsIgnoreCase(WHOIS_COMMAND)) {
    if (args.length > 0) {
      connection.doWhois(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(QUIT_COMMAND)) {
    if (args.length > 0) {
      connection.doQuit(args[0]);
    }
 else {
      connection.doQuit();
    }
  }
 else   if (command.equalsIgnoreCase(AWAY_COMMAND)) {
    if (args.length > 0) {
      connection.doAway(args[0]);
    }
 else {
      connection.doAway();
    }
  }
 else   if (command.equalsIgnoreCase(TOPIC_COMMAND)) {
    if (args.length > 1) {
      StringBuffer sb=new StringBuffer();
      for (int i=1; i < args.length; i++) {
        if (i > 1) {
          sb.append(COMMAND_DELIM);
        }
        sb.append(args[i]);
      }
      connection.doTopic(args[0],sb.toString());
    }
 else     if (args.length > 0) {
      connection.doTopic(args[0]);
    }
  }
 else   if (command.equalsIgnoreCase(INVITE_COMMAND)) {
    if (args.length > 1) {
      connection.doInvite(args[0],args[1]);
    }
  }
 else {
    trace(""String_Node_Str"" + command + ""String_Node_Str""+ getID());
  }
}",0.9528323177612276
95113,"protected void handleContainerDisconnectedEvent(IContainerDisconnectedEvent event){
  ID targetID=event.getTargetID();
synchronized (remoteRegistrys) {
    RemoteServiceRegistryImpl registry=getRemoteRegistry(targetID);
    if (registry != null) {
      RemoteServiceRegistrationImpl registrations[]=registry.getRegistrations();
      if (registrations != null) {
        for (int i=0; i < registrations.length; i++) {
          trace(""String_Node_Str"" + registrations[i].getServiceId());
          registry.unpublishService(registrations[i]);
          fireRemoteServiceListeners(createUnregisteredEvent(registrations[i]));
        }
      }
    }
    removeRemoteRegistry(targetID);
  }
}","protected void handleContainerDisconnectedEvent(IContainerDisconnectedEvent event){
  trace(""String_Node_Str"" + event + ""String_Node_Str"");
  ID targetID=event.getTargetID();
synchronized (remoteRegistrys) {
    RemoteServiceRegistryImpl registry=getRemoteRegistry(targetID);
    removeRemoteRegistry(targetID);
    if (registry != null) {
      RemoteServiceRegistrationImpl registrations[]=registry.getRegistrations();
      if (registrations != null) {
        for (int i=0; i < registrations.length; i++) {
          trace(""String_Node_Str"" + registrations[i].getServiceId());
          registry.unpublishService(registrations[i]);
          fireRemoteServiceListeners(createUnregisteredEvent(registrations[i]));
        }
      }
    }
  }
}",0.9108635097493036
95114,"protected void handleContainerDisconnectedEvent(IContainerDisconnectedEvent event){
  trace(""String_Node_Str"" + event + ""String_Node_Str"");
  ID targetID=event.getTargetID();
synchronized (remoteRegistrys) {
    RemoteServiceRegistryImpl registry=getRemoteRegistry(targetID);
    removeRemoteRegistry(targetID);
    if (registry != null) {
      RemoteServiceRegistrationImpl registrations[]=registry.getRegistrations();
      if (registrations != null) {
        for (int i=0; i < registrations.length; i++) {
          trace(""String_Node_Str"" + registrations[i].getServiceId());
          registry.unpublishService(registrations[i]);
          fireRemoteServiceListeners(createUnregisteredEvent(registrations[i]));
        }
      }
    }
  }
}","protected void handleContainerDisconnectedEvent(IContainerDisconnectedEvent event){
  trace(""String_Node_Str"" + event + ""String_Node_Str"");
  ID targetID=event.getTargetID();
synchronized (remoteRegistrys) {
    RemoteServiceRegistryImpl registry=getRemoteRegistry(targetID);
    if (registry != null) {
      removeRemoteRegistry(targetID);
      RemoteServiceRegistrationImpl registrations[]=registry.getRegistrations();
      if (registrations != null) {
        for (int i=0; i < registrations.length; i++) {
          trace(""String_Node_Str"" + registrations[i].getServiceId());
          registry.unpublishService(registrations[i]);
          fireRemoteServiceListeners(createUnregisteredEvent(registrations[i]));
        }
      }
    }
  }
}",0.9504685408299868
95115,"public void createPartControl(Composite parent){
  otherColor=colorFromRGBString(DEFAULT_OTHER_COLOR);
  systemColor=colorFromRGBString(DEFAULT_SYSTEM_COLOR);
  highlightColor=colorFromRGBString(DEFAULT_HIGHLIGHT_COLOR);
  dateColor=colorFromRGBString(DEFAULT_DATE_COLOR);
  mainComp=new Composite(parent,SWT.NONE);
  mainComp.setLayout(new FillLayout());
  tabFolder=new CTabFolder(mainComp,SWT.NORMAL);
  tabFolder.setSimple(false);
  tabFolder.addCTabFolder2Listener(new CTabFolder2Listener(){
    public void close(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void maximize(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void minimize(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void restore(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void showList(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
  }
);
  rootChatRoomTabItem=new Manager(false,tabFolder,hostName,new KeyListener(){
    public void keyPressed(    KeyEvent evt){
      handleKeyPressed(evt);
    }
    public void keyReleased(    KeyEvent evt){
      handleKeyReleased(evt);
    }
  }
);
  writeText=rootChatRoomTabItem.getTextInput();
  readText=rootChatRoomTabItem.getTextOutput();
  setEnabled(false);
  makeActions();
  hookContextMenu();
}","public void createPartControl(Composite parent){
  otherColor=colorFromRGBString(DEFAULT_OTHER_COLOR);
  systemColor=colorFromRGBString(DEFAULT_SYSTEM_COLOR);
  highlightColor=colorFromRGBString(DEFAULT_HIGHLIGHT_COLOR);
  dateColor=colorFromRGBString(DEFAULT_DATE_COLOR);
  mainComp=new Composite(parent,SWT.NONE);
  mainComp.setLayout(new FillLayout());
  boolean useTraditionalTabFolder=PlatformUI.getPreferenceStore().getBoolean(IWorkbenchPreferenceConstants.SHOW_TRADITIONAL_STYLE_TABS);
  tabFolder=new CTabFolder(mainComp,SWT.NORMAL);
  tabFolder.setSimple(useTraditionalTabFolder);
  PlatformUI.getPreferenceStore().addPropertyChangeListener(new IPropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent event){
      if (event.getProperty().equals(IWorkbenchPreferenceConstants.SHOW_TRADITIONAL_STYLE_TABS) && !tabFolder.isDisposed()) {
        tabFolder.setSimple(((Boolean)event.getNewValue()).booleanValue());
        tabFolder.redraw();
      }
    }
  }
);
  tabFolder.addCTabFolder2Listener(new CTabFolder2Listener(){
    public void close(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void maximize(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void minimize(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void restore(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
    public void showList(    CTabFolderEvent event){
      System.out.println(""String_Node_Str"" + event + ""String_Node_Str"");
    }
  }
);
  rootChatRoomTabItem=new Manager(false,tabFolder,hostName,new KeyListener(){
    public void keyPressed(    KeyEvent evt){
      handleKeyPressed(evt);
    }
    public void keyReleased(    KeyEvent evt){
      handleKeyReleased(evt);
    }
  }
);
  writeText=rootChatRoomTabItem.getTextInput();
  readText=rootChatRoomTabItem.getTextOutput();
  setEnabled(false);
  makeActions();
  hookContextMenu();
}",0.846070460704607
95116,"/** 
 * Handle a ISharedObjectCreateResponseEvent.  This handler is called by handleSharedObjectMsgEvent when the ISharedObjectMessageEvent is of type ISharedObjectCreateResponseEvent. This default  implementation simply returns true.  Subclasses may override as appropriate.
 * @param the ISharedObjectCreateResponseEvent
 * @return true if the provided event should receive no further processing.  If false the provided Event should bepassed to further event processors.  
 */
protected boolean handleSharedObjectCreateResponseEvent(ISharedObjectCreateResponseEvent createResponseEvent){
  trace(""String_Node_Str"" + createResponseEvent + ""String_Node_Str"");
  return true;
}","/** 
 * Handle a ISharedObjectCreateResponseEvent.  This handler is called by handleSharedObjectMsgEvent when the ISharedObjectMessageEvent is of type ISharedObjectCreateResponseEvent. This default  implementation simply returns true.  Subclasses may override as appropriate.
 * @param createResponseEvent the ISharedObjectCreateResponseEvent received
 * @return true if the provided event should receive no further processing.  If false the provided Event should bepassed to further event processors.  
 */
protected boolean handleSharedObjectCreateResponseEvent(ISharedObjectCreateResponseEvent createResponseEvent){
  trace(""String_Node_Str"" + createResponseEvent + ""String_Node_Str"");
  return true;
}",0.9790007241129616
95117,"protected Object deserializeSharedObjectMessage(byte[] bytes) throws IOException, ClassNotFoundException {
  ByteArrayInputStream bins=new ByteArrayInputStream(bytes);
  Object obj=null;
  try {
    ObjectInputStream oins=new ObjectInputStream(bins);
    obj=oins.readObject();
  }
 catch (  ClassNotFoundException e) {
    dumpStack(""String_Node_Str"",e);
    IdentifiableObjectInputStream iins=new IdentifiableObjectInputStream(new IClassLoaderMapper(){
      public ClassLoader mapNameToClassLoader(      String name){
        ISharedObjectManager manager=getSharedObjectManager();
        ID[] ids=manager.getSharedObjectIDs();
        ID found=null;
        for (int i=0; i < ids.length; i++) {
          ID id=ids[i];
          if (name.equals(id.getName())) {
            found=id;
            break;
          }
        }
        if (found == null)         return null;
        ISharedObject obj=manager.getSharedObject(found);
        if (obj == null)         return null;
        return obj.getClass().getClassLoader();
      }
    }
,bins);
    obj=iins.readObject();
  }
  return obj;
}","protected Object deserializeSharedObjectMessage(byte[] bytes) throws IOException, ClassNotFoundException {
  ByteArrayInputStream bins=new ByteArrayInputStream(bytes);
  Object obj=null;
  try {
    ObjectInputStream oins=new ObjectInputStream(bins);
    obj=oins.readObject();
  }
 catch (  ClassNotFoundException e) {
    bins.reset();
    IdentifiableObjectInputStream iins=new IdentifiableObjectInputStream(new IClassLoaderMapper(){
      public ClassLoader mapNameToClassLoader(      String name){
        ISharedObjectManager manager=getSharedObjectManager();
        ID[] ids=manager.getSharedObjectIDs();
        ID found=null;
        for (int i=0; i < ids.length; i++) {
          ID id=ids[i];
          if (name.equals(id.getName())) {
            found=id;
            break;
          }
        }
        if (found == null)         return null;
        ISharedObject obj=manager.getSharedObject(found);
        if (obj == null)         return null;
        return obj.getClass().getClassLoader();
      }
    }
,bins);
    obj=iins.readObject();
  }
  return obj;
}",0.9816176470588236
95118,"protected ClassLoader getClassLoaderForContainer(){
  return ISharedObjectContainer.class.getClassLoader();
}","protected ClassLoader getClassLoaderForContainer(){
  return this.getClass().getClassLoader();
}",0.8682926829268293
95119,"public void handleMessage(ID groupID,ID fromID,ID toID,IMessageListener.Type type,String subject,String message){
  ChatWindow window=openChatWindowForTarget(fromID);
  if (window != null) {
    window.handleMessage(fromID,toID,type,subject,message);
    window.setStatus(""String_Node_Str"" + (new SimpleDateFormat(""String_Node_Str"").format(new Date())));
  }
}","public void handleMessage(ID groupID,ID fromID,ID toID,IMessageListener.Type type,String subject,String message){
  ChatWindow window=openChatWindowForTarget(fromID);
  System.out.println(""String_Node_Str"" + groupID + ""String_Node_Str""+ fromID+ ""String_Node_Str""+ toID+ ""String_Node_Str""+ type+ ""String_Node_Str""+ subject+ ""String_Node_Str""+ message+ ""String_Node_Str"");
  if (window != null) {
    window.handleMessage(fromID,toID,type,subject,message);
    window.setStatus(""String_Node_Str"" + (new SimpleDateFormat(""String_Node_Str"").format(new Date())));
  }
}",0.7792207792207793
95120,"protected void handleEnter(){
  String text=textinput.getText().trim();
  if (text.length() > 0)   sendTextLineInput(text);
  clearInput();
  isTyping=false;
}","protected void handleEnter(){
  String text=textinput.getText().trim();
  if (text != null)   sendTextLineInput(text);
  clearInput();
  isTyping=false;
}",0.939297124600639
95121,"public void appendText(ChatLine text){
  StyledText st=textoutput.getTextWidget();
  if (text == null || textoutput == null || st == null)   return;
  int startRange=st.getText().length();
  StringBuffer sb=new StringBuffer();
  if (text.getOriginator() != null) {
    sb.append(createLineWithTimestamp(text.getOriginator().getName() + ""String_Node_Str""));
    StyleRange sr=new StyleRange();
    sr.start=startRange;
    sr.length=sb.length();
    IUser lu=getLocalUser();
    if (lu != null && lu.getID().equals(text.getOriginator().getID())) {
      sr.foreground=meColor;
    }
 else {
      sr.foreground=otherColor;
    }
    st.append(sb.toString());
    st.setStyleRange(sr);
  }
  int beforeMessageIndex=st.getText().length();
  st.append(text.getText());
  if (text.getOriginator() == null) {
    StyleRange sr=new StyleRange();
    sr.start=beforeMessageIndex;
    sr.length=text.getText().length();
    sr.foreground=systemColor;
    st.setStyleRange(sr);
  }
  if (!text.isNoCRLF()) {
    st.append(""String_Node_Str"");
  }
  String t=st.getText();
  if (t == null)   return;
  st.setSelection(t.length());
}","public void appendText(ChatLine text){
  StyledText st=textoutput.getTextWidget();
  if (text == null || textoutput == null || st == null)   return;
  int startRange=st.getText().length();
  StringBuffer sb=new StringBuffer();
  if (text.getOriginator() != null) {
    sb.append(createLineWithTimestamp(text.getOriginator().getName() + ""String_Node_Str""));
    StyleRange sr=new StyleRange();
    sr.start=startRange;
    sr.length=sb.length();
    IUser lu=getLocalUser();
    if (lu != null && lu.getID().equals(text.getOriginator().getID())) {
      sr.foreground=meColor;
    }
 else {
      sr.foreground=otherColor;
    }
    st.append(sb.toString());
    st.setStyleRange(sr);
  }
  int beforeMessageIndex=st.getText().length();
  st.append(text.getText().trim());
  if (text.getOriginator() == null) {
    StyleRange sr=new StyleRange();
    sr.start=beforeMessageIndex;
    sr.length=text.getText().length();
    sr.foreground=systemColor;
    st.setStyleRange(sr);
  }
  if (!text.isNoCRLF()) {
    st.append(""String_Node_Str"");
  }
  String t=st.getText();
  if (t == null)   return;
  st.setSelection(t.length());
}",0.9968847352024922
95122,"private void startConnection(ConnectionDetails details) throws Exception {
  CollabClient client=new CollabClient();
  ClientPlugin.log(""String_Node_Str"" + details.getContainerType() + ""String_Node_Str""+ details.getTargetURI()+ ""String_Node_Str""+ details.getNickname());
  client.createAndConnectClient(details.getContainerType(),details.getTargetURI(),details.getNickname(),details.getPassword(),ResourcesPlugin.getWorkspace().getRoot());
}","private void startConnection(ConnectionDetails details) throws Exception {
  CollabClient client=new CollabClient();
  client.createAndConnectClient(details.getContainerType(),details.getTargetURI(),details.getNickname(),details.getPassword(),ResourcesPlugin.getWorkspace().getRoot());
}",0.7032967032967034
95123,"protected void processDisconnect(DisconnectConnectionEvent e){
  debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
  try {
    IAsynchConnection conn=(IAsynchConnection)e.getConnection();
    if (!conn.isConnected())     return;
    ID fromID=null;
synchronized (getGroupMembershipLock()) {
      fromID=getIDForConnection(conn);
      memberLeave(fromID,conn);
    }
    if (fromID != null)     fireContainerEvent(new ContainerDisconnectedEvent(getID(),fromID,e.getException()));
  }
 catch (  Exception except) {
    logException(""String_Node_Str"",except);
  }
}","protected void processDisconnect(DisconnectConnectionEvent e){
  debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
  try {
    IAsynchConnection conn=(IAsynchConnection)e.getConnection();
    ID fromID=null;
synchronized (getGroupMembershipLock()) {
      fromID=getIDForConnection(conn);
      memberLeave(fromID,conn);
    }
    if (fromID != null)     fireContainerEvent(new ContainerDisconnectedEvent(getID(),fromID,e.getException()));
  }
 catch (  Exception except) {
    logException(""String_Node_Str"",except);
  }
}",0.9643167972149695
95124,"private void setEditorEditable(final boolean editable){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      textControl.setEditable(editable);
    }
  }
);
}","private void setEditorEditable(final boolean editable){
  if (!textControl.isDisposed()) {
    Display.getDefault().syncExec(new Runnable(){
      public void run(){
        textControl.setEditable(editable);
      }
    }
);
  }
}",0.8668280871670703
95125,"synchronized void setListenerActive(boolean active){
  listenerActive=active;
}","synchronized public void setListenerActive(boolean active){
  listenerActive=active;
}",0.9575757575757576
95126,"public void addSession(String channelID,String sessionName){
  sessionNames.add(new SessionInstance(channelID,sessionName,getPreferenceStore().getString(ClientPreferencePage.LOCAL_NAME),Calendar.getInstance().getTime()));
  if (presenceChannel != null) {
    try {
      presenceChannel.sendMessage(PresenceChannelListener.createMessage(new SharedEditorSessionList(sessionNames)));
    }
 catch (    ECFException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","public void addSession(String channelID,String sessionName){
  sessionNames.add(new SessionInstance(channelID,sessionName,getPreferenceStore().getString(ClientPreferencePage.LOCAL_NAME),Calendar.getInstance().getTime()));
  if (presenceChannel != null) {
    try {
      presenceChannel.sendMessage((new SharedEditorSessionList(sessionNames)).toByteArray());
    }
 catch (    ECFException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
}",0.9020771513353116
95127,"public void run(){
  try {
    IEditorPart editorPart=page.openEditor(new FileEditorInput(file),editorDescriptor.getId());
    if (editorPart instanceof AbstractTextEditor) {
      IEditorInput editorInput=editorPart.getEditorInput();
      IDocumentProvider dp=DocumentProviderRegistry.getDefault().getDocumentProvider(editorInput);
      AbstractTextEditor textEditor=(AbstractTextEditor)editorPart;
      IDocument document=dp.getDocument(editorPart.getEditorInput());
      if (document != null) {
        EditorListener listener=new EditorListener(document,textEditor);
        document.addDocumentListener(listener);
      }
 else {
        if (dp instanceof TextFileDocumentProvider) {
          ((TextFileDocumentProvider)dp).connect(editorPart.getEditorInput());
          document=((TextFileDocumentProvider)dp).getDocument(editorPart.getEditorInput());
          if (document != null) {
            EditorListener listener=new EditorListener(document,textEditor);
            document.addDocumentListener(listener);
            return;
          }
 else {
            Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,""String_Node_Str"",null));
          }
        }
        Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,""String_Node_Str"",null));
      }
    }
  }
 catch (  PartInitException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
catch (  CoreException e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    IEditorPart editorPart=page.openEditor(new FileEditorInput(file),editorDescriptor.getId());
    if (editorPart instanceof AbstractTextEditor) {
      IEditorInput editorInput=editorPart.getEditorInput();
      IDocumentProvider dp=DocumentProviderRegistry.getDefault().getDocumentProvider(editorInput);
      AbstractTextEditor textEditor=(AbstractTextEditor)editorPart;
      IDocument document=dp.getDocument(editorPart.getEditorInput());
      if (document != null) {
        EditorListener listener=new EditorListener(document,textEditor,true);
        document.addDocumentListener(listener);
      }
 else {
        if (dp instanceof TextFileDocumentProvider) {
          ((TextFileDocumentProvider)dp).connect(editorPart.getEditorInput());
          document=((TextFileDocumentProvider)dp).getDocument(editorPart.getEditorInput());
          if (document != null) {
            EditorListener listener=new EditorListener(document,textEditor,true);
            document.addDocumentListener(listener);
            return;
          }
 else {
            Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,""String_Node_Str"",null));
          }
        }
        Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,""String_Node_Str"",null));
      }
    }
  }
 catch (  PartInitException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
catch (  CoreException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
}",0.959228135698724
95128,"public void addSession(String sessionName){
  sessionNames.add(sessionName);
  if (presenceChannel != null) {
    try {
      presenceChannel.sendMessage(PresenceChannelListener.createMessage(new SharedEditorSessionList(sessionNames)));
    }
 catch (    ECFException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","public void addSession(String channelID,String sessionName){
  sessionNames.add(new SessionInstance(channelID,sessionName,getPreferenceStore().getString(ClientPreferencePage.LOCAL_NAME),Calendar.getInstance().getTime()));
  if (presenceChannel != null) {
    try {
      presenceChannel.sendMessage(PresenceChannelListener.createMessage(new SharedEditorSessionList(sessionNames)));
    }
 catch (    ECFException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
}",0.8368953880764904
95129,"public IChannel intializePresenceSession(IChannelListener clistener) throws ECFException {
  presenceContainer=ContainerFactory.getDefault().createContainer(Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CONTAINER_TYPE));
  IChannelContainer channelContainer=(IChannelContainer)presenceContainer.getAdapter(IChannelContainer.class);
  final ID channelID=IDFactory.getDefault().createID(channelContainer.getChannelNamespace(),Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CHANNEL_ID + ""String_Node_Str""));
  presenceChannel=channelContainer.createChannel(channelID,clistener,new HashMap());
  this.presenceChannelListener=clistener;
  presenceContainer.connect(IDFactory.getDefault().createID(presenceContainer.getConnectNamespace(),Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.TARGET_SERVER)),null);
  return presenceChannel;
}","public IChannel intializePresenceSession(IChannelListener clistener) throws ECFException {
  presenceContainer=ContainerFactory.getDefault().createContainer(Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CONTAINER_TYPE));
  IChannelContainer channelContainer=(IChannelContainer)presenceContainer.getAdapter(IChannelContainer.class);
  final ID channelID=IDFactory.getDefault().createID(channelContainer.getChannelNamespace(),Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CHANNEL_ID) + ""String_Node_Str"");
  presenceChannel=channelContainer.createChannel(channelID,clistener,new HashMap());
  this.presenceChannelListener=clistener;
  presenceContainer.connect(IDFactory.getDefault().createID(presenceContainer.getConnectNamespace(),Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.TARGET_SERVER)),null);
  return presenceChannel;
}",0.99890590809628
95130,"public void handleChannelEvent(IChannelEvent event){
  if (event instanceof IChannelMessageEvent) {
    setEditorEditable(false);
    Activator.getDefault().setListenerActive(false);
    IChannelMessageEvent msg=(IChannelMessageEvent)event;
    ByteArrayInputStream bins=new ByteArrayInputStream(msg.getData());
    ObjectInputStream ois;
    try {
      ois=new ObjectInputStream(bins);
      EditorChangeMessage message=(EditorChangeMessage)ois.readObject();
      appendLocallyFromRemote(message);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
 finally {
      setEditorEditable(true);
      Activator.getDefault().setListenerActive(true);
    }
  }
}","public void handleChannelEvent(IChannelEvent event){
  if (event instanceof IChannelMessageEvent) {
    setEditorEditable(false);
    Activator.getDefault().setListenerActive(false);
    IChannelMessageEvent msg=(IChannelMessageEvent)event;
    ByteArrayInputStream bins=new ByteArrayInputStream(msg.getData());
    ObjectInputStream ois;
    try {
      ois=new ObjectInputStream(bins);
      EditorChangeMessage message=(EditorChangeMessage)ois.readObject();
      appendLocallyFromRemote(message);
    }
 catch (    IOException e) {
      Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
    }
catch (    ClassNotFoundException e) {
      Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
    }
 finally {
      setEditorEditable(true);
      Activator.getDefault().setListenerActive(true);
    }
  }
}",0.6889153754469607
95131,"public void documentChanged(DocumentEvent event){
  if (!Activator.getDefault().isListenerActive()) {
    return;
  }
  try {
    IDocument newDocument=event.getDocument();
    if (channel == null) {
      document.removeDocumentListener(this);
    }
    channel.sendMessage(createMessageFromEvent(event));
    this.document=newDocument;
  }
 catch (  ECFException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","public void documentChanged(DocumentEvent event){
  if (!Activator.getDefault().isListenerActive()) {
    return;
  }
  try {
    IDocument newDocument=event.getDocument();
    if (channel == null) {
      document.removeDocumentListener(this);
    }
    channel.sendMessage(createMessageFromEvent(event));
    this.document=newDocument;
  }
 catch (  ECFException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
catch (  IOException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
}",0.7783882783882784
95132,"public EditorListener(IDocument document,AbstractTextEditor textEditor){
  this.document=document;
  this.editor=textEditor;
  try {
    intializeEditorSession();
    if (Activator.getDefault().getPresenceChannelListener() == null) {
      Activator.getDefault().intializePresenceSession(new PresenceChannelListener());
    }
  }
 catch (  ECFException e) {
    e.printStackTrace();
  }
}","public EditorListener(IDocument document,AbstractTextEditor textEditor){
  this.document=document;
  this.editor=textEditor;
  try {
    intializeEditorSession();
    if (Activator.getDefault().getPresenceChannelListener() == null) {
      Activator.getDefault().intializePresenceSession(new PresenceChannelListener());
    }
  }
 catch (  ECFException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
}",0.8604382929642446
95133,"public void intializeEditorSession() throws ECFException {
  container=ContainerFactory.getDefault().createContainer(Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CONTAINER_TYPE));
  IChannelContainer channelContainer=(IChannelContainer)container.getAdapter(IChannelContainer.class);
  sessionID=Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CHANNEL_ID) + ""String_Node_Str"" + editor.getTitle();
  Activator.getDefault().addSession(sessionID);
  final ID channelID=IDFactory.getDefault().createID(channelContainer.getChannelNamespace(),sessionID);
  channelListener=new EditChannelListener(document,editor);
  channel=channelContainer.createChannel(channelID,channelListener,new HashMap());
  container.connect(IDFactory.getDefault().createID(container.getConnectNamespace(),Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.TARGET_SERVER)),null);
}","public void intializeEditorSession() throws ECFException {
  container=ContainerFactory.getDefault().createContainer(Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CONTAINER_TYPE));
  IChannelContainer channelContainer=(IChannelContainer)container.getAdapter(IChannelContainer.class);
  sessionID=Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.CHANNEL_ID) + SESSION_NAME_DELIMITER + editor.getTitle();
  Activator.getDefault().addSession(sessionID,editor.getTitle());
  final ID channelID=IDFactory.getDefault().createID(channelContainer.getChannelNamespace(),sessionID);
  channelListener=new EditChannelListener(document,editor);
  channel=channelContainer.createChannel(channelID,channelListener,new HashMap());
  container.connect(IDFactory.getDefault().createID(container.getConnectNamespace(),Activator.getDefault().getPreferenceStore().getString(ClientPreferencePage.TARGET_SERVER)),null);
}",0.972944297082228
95134,"public void handleChannelEvent(IChannelEvent event){
  if (channel == null) {
    channel=Activator.getDefault().getPresenceChannel();
  }
  if (event instanceof IChannelMessageEvent) {
    IChannelMessageEvent msg=(IChannelMessageEvent)event;
    ByteArrayInputStream bins=new ByteArrayInputStream(msg.getData());
    ObjectInputStream ois;
    try {
      ois=new ObjectInputStream(bins);
      Object o=ois.readObject();
      if (o instanceof SharedEditorSessionListRequest) {
        channel.sendMessage(createMessage(new SharedEditorSessionList(Activator.getDefault().getSessionNames())));
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
catch (    ECFException e) {
      e.printStackTrace();
    }
 finally {
      Activator.getDefault().setListenerActive(true);
      System.out.println(""String_Node_Str"");
    }
  }
}","public void handleChannelEvent(IChannelEvent event){
  if (channel == null) {
    channel=Activator.getDefault().getPresenceChannel();
  }
  if (event instanceof IChannelMessageEvent) {
    IChannelMessageEvent msg=(IChannelMessageEvent)event;
    ByteArrayInputStream bins=new ByteArrayInputStream(msg.getData());
    ObjectInputStream ois;
    try {
      ois=new ObjectInputStream(bins);
      Object o=ois.readObject();
      if (o instanceof SharedEditorSessionListRequest) {
        channel.sendMessage(createMessage(new SharedEditorSessionList(Activator.getDefault().getSessionNames())));
      }
    }
 catch (    IOException e) {
      Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
    }
catch (    ClassNotFoundException e) {
      Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
    }
catch (    ECFException e) {
      Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
    }
 finally {
      Activator.getDefault().setListenerActive(true);
      System.out.println(""String_Node_Str"");
    }
  }
}",0.7729196050775741
95135,"public void run(){
  try {
    IEditorPart editorPart=page.openEditor(new FileEditorInput(file),editorDescriptor.getId());
    if (editorPart instanceof AbstractTextEditor) {
      IDocumentProvider dp=DocumentProviderRegistry.getDefault().getDocumentProvider(editorPart.getEditorInput());
      AbstractTextEditor textEditor=(AbstractTextEditor)editorPart;
      IDocument document=dp.getDocument(editorPart.getEditorInput());
      if (document != null) {
        EditorListener listener=new EditorListener(document,textEditor);
        document.addDocumentListener(listener);
      }
    }
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    IEditorPart editorPart=page.openEditor(new FileEditorInput(file),editorDescriptor.getId());
    if (editorPart instanceof AbstractTextEditor) {
      IDocumentProvider dp=DocumentProviderRegistry.getDefault().getDocumentProvider(editorPart.getEditorInput());
      AbstractTextEditor textEditor=(AbstractTextEditor)editorPart;
      IDocument document=dp.getDocument(editorPart.getEditorInput());
      if (document != null) {
        EditorListener listener=new EditorListener(document,textEditor);
        document.addDocumentListener(listener);
      }
    }
  }
 catch (  PartInitException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
}",0.9142452161587526
95136,"protected void performDefaults(){
  super.performDefaults();
  getPreferenceStore().setDefault(CONTAINER_TYPE,""String_Node_Str"");
  getPreferenceStore().setDefault(TARGET_SERVER,""String_Node_Str"");
  getPreferenceStore().setDefault(CHANNEL_ID,""String_Node_Str"");
}","protected void performDefaults(){
  super.performDefaults();
  getPreferenceStore().setDefault(CONTAINER_TYPE,""String_Node_Str"");
  getPreferenceStore().setDefault(TARGET_SERVER,""String_Node_Str"");
  getPreferenceStore().setDefault(CHANNEL_ID,""String_Node_Str"");
  try {
    getPreferenceStore().setDefault(LOCAL_NAME,Inet4Address.getLocalHost().getHostName());
  }
 catch (  UnknownHostException e) {
    Activator.getDefault().getLog().log(new Status(IStatus.ERROR,Activator.PLUGIN_ID,0,e.getLocalizedMessage(),e));
  }
}",0.6709021601016518
95137,"public void createFieldEditors(){
  addField(new StringFieldEditor(CONTAINER_TYPE,""String_Node_Str"",this.getFieldEditorParent()));
  addField(new StringFieldEditor(TARGET_SERVER,""String_Node_Str"",this.getFieldEditorParent()));
  addField(new StringFieldEditor(CHANNEL_ID,""String_Node_Str"",this.getFieldEditorParent()));
}","public void createFieldEditors(){
  addField(new StringFieldEditor(CONTAINER_TYPE,""String_Node_Str"",this.getFieldEditorParent()));
  addField(new StringFieldEditor(TARGET_SERVER,""String_Node_Str"",this.getFieldEditorParent()));
  addField(new StringFieldEditor(CHANNEL_ID,""String_Node_Str"",this.getFieldEditorParent()));
  addField(new StringFieldEditor(LOCAL_NAME,""String_Node_Str"",this.getFieldEditorParent()));
}",0.8734693877551021
95138,"protected ContainerFactory(){
  ECFPlugin.getDefault().addDisposable(new IDisposable(){
    public void dispose(){
      doDispose();
    }
  }
);
}","protected ContainerFactory(){
  try {
    ECFPlugin.getDefault().addDisposable(new IDisposable(){
      public void dispose(){
        doDispose();
      }
    }
);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
  }
}",0.7435897435897436
95139,"/** 
 * Initialize replicas of this channel.  This method is only called if isPrimary() returns false.  It is called from within the initialize method, immediately after super.initialize but before the listener for this  channel is notified of initialization.  If this method throws a SharedObjectInitException, then initialization of the replica is halted and the remote transaction creating the replica will be  aborted. <p> Note that this implementation checks for the existence of the RECEIVER_ID_PROPERTY on the replica's properties, and if the property contains a valid ID will  <ul> <li>lookup the IChannel on the given container via IChannelContainer.getID(ID)</li> <li>call IChannel.getListener() to retrieve the listener for the channel returned</li> <li>set the listener for this object to the value returned from IChannel.getListener()</li> </ul>
 * @throws SharedObjectInitException if the replica initialization should fail
 */
protected void initializeReplicaChannel() throws SharedObjectInitException {
  Map properties=getConfig().getProperties();
  ID rcvr=null;
  try {
    rcvr=(ID)properties.get(RECEIVER_ID_PROPERTY);
  }
 catch (  ClassCastException e) {
    throw new SharedObjectInitException(""String_Node_Str"");
  }
  IChannelListener l=null;
  if (rcvr != null) {
    IChannelContainer container=(IChannelContainer)getContext().getAdapter(IChannelContainer.class);
    if (container == null)     throw new SharedObjectInitException(""String_Node_Str"");
    final IChannel receiver=container.getChannel(rcvr);
    if (receiver == null)     throw new SharedObjectInitException(""String_Node_Str"");
    setChannelListener(receiver.getListener());
  }
  if (l == null) {
    setChannelListener(new IChannelListener(){
      public void handleChannelEvent(      IChannelEvent event){
        receiveUndeliveredChannelEvent(event);
      }
    }
);
  }
 else {
    this.listener=l;
  }
}","/** 
 * Initialize replicas of this channel.  This method is only called if isPrimary() returns false.  It is called from within the initialize method, immediately after super.initialize but before the listener for this  channel is notified of initialization.  If this method throws a SharedObjectInitException, then initialization of the replica is halted and the remote transaction creating the replica will be  aborted. <p> Note that this implementation checks for the existence of the RECEIVER_ID_PROPERTY on the replica's properties, and if the property contains a valid ID will  <ul> <li>lookup the IChannel on the given container via IChannelContainer.getID(ID)</li> <li>call IChannel.getListener() to retrieve the listener for the channel returned</li> <li>set the listener for this object to the value returned from IChannel.getListener()</li> </ul>
 * @throws SharedObjectInitException if the replica initialization should fail
 */
protected void initializeReplicaChannel() throws SharedObjectInitException {
  Map properties=getConfig().getProperties();
  ID rcvr=null;
  try {
    rcvr=(ID)properties.get(RECEIVER_ID_PROPERTY);
  }
 catch (  ClassCastException e) {
    throw new SharedObjectInitException(""String_Node_Str"");
  }
  IChannelListener l=null;
  if (rcvr != null) {
    IChannelContainer container=(IChannelContainer)getContext().getAdapter(IChannelContainer.class);
    if (container == null)     throw new SharedObjectInitException(""String_Node_Str"");
    final IChannel receiver=container.getChannel(rcvr);
    if (receiver == null)     throw new SharedObjectInitException(""String_Node_Str"");
    setChannelListener(receiver.getListener());
  }
  if (listener == null) {
    setChannelListener(new IChannelListener(){
      public void handleChannelEvent(      IChannelEvent event){
        receiveUndeliveredChannelEvent(event);
      }
    }
);
  }
 else {
    this.listener=l;
  }
}",0.998167059439644
95140,"public static void log(String message,Throwable e){
  getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),IStatus.OK,""String_Node_Str"",e));
}","public static void log(String message,Throwable e){
  getDefault().getLog().log(new Status(IStatus.ERROR,ClientPlugin.getDefault().getBundle().getSymbolicName(),IStatus.OK,message,e));
}",0.9476439790575916
95141,"public void disconnect(){
  ID groupID=getConnectedID();
  debug(""String_Node_Str"" + groupID + ""String_Node_Str"");
  fireContainerEvent(new ContainerDisconnectingEvent(this.getID(),groupID));
synchronized (connectLock) {
    if (isConnected()) {
synchronized (connection) {
        try {
          connection.sendSynch(groupID,serializeObject(ContainerMessage.createLeaveGroupMessage(getID(),groupID,getNextSequenceNumber(),getLeaveData(groupID))));
        }
 catch (        Exception e) {
        }
synchronized (getGroupMembershipLock()) {
          memberLeave(groupID,connection);
        }
      }
    }
    connectionState=UNCONNECTED;
    connection=null;
    remoteServerID=null;
  }
  fireContainerEvent(new ContainerDisconnectedEvent(this.getID(),groupID));
}","public void disconnect(){
  ID groupID=getConnectedID();
  debug(""String_Node_Str"" + groupID + ""String_Node_Str"");
  fireContainerEvent(new ContainerDisconnectingEvent(this.getID(),groupID));
synchronized (getConnectLock()) {
    if (isConnected()) {
synchronized (connection) {
        try {
          connection.sendSynch(groupID,serializeObject(ContainerMessage.createLeaveGroupMessage(getID(),groupID,getNextSequenceNumber(),getLeaveData(groupID))));
        }
 catch (        Exception e) {
        }
synchronized (getGroupMembershipLock()) {
          memberLeave(groupID,connection);
        }
      }
    }
    setStateUnconnected(null);
  }
  fireContainerEvent(new ContainerDisconnectedEvent(this.getID(),groupID));
}",0.9432197728790916
95142,"public void connect(ID remote,IConnectContext joinContext) throws ContainerConnectException {
  fireContainerEvent(new ContainerConnectingEvent(this.getID(),remote,joinContext));
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    debug(""String_Node_Str"" + remote + ""String_Node_Str""+ joinContext);
    ISynchAsynchConnection aConnection=createConnection(remote,joinContext);
    Object response=null;
synchronized (connectLock) {
      if (isConnected()) {
        killConnection(aConnection);
        aConnection=null;
        throw new ConnectException(""String_Node_Str"" + getConnectedID());
      }
      if (isConnecting()) {
        killConnection(aConnection);
        aConnection=null;
        throw new ConnectException(""String_Node_Str"");
      }
      connectionState=CONNECTING;
      connection=aConnection;
    }
    Callback[] callbacks=createAuthorizationCallbacks();
    if (joinContext != null) {
      CallbackHandler handler=joinContext.getCallbackHandler();
      if (handler != null) {
        handler.handle(callbacks);
      }
    }
synchronized (aConnection) {
      try {
        Object connectData=createConnectData(remote,callbacks,null);
        response=aConnection.connect(remote,connectData,getConnectTimeout());
      }
 catch (      IOException e) {
synchronized (connectLock) {
          killConnection(aConnection);
          if (connection != aConnection) {
            aConnection=null;
            throw e;
          }
          connectionState=UNCONNECTED;
          connection=null;
          remoteServerID=null;
        }
        throw e;
      }
synchronized (connectLock) {
        if (connection != aConnection) {
          killConnection(aConnection);
          aConnection=null;
          throw new ConnectException(""String_Node_Str"");
        }
        ID serverID=null;
        try {
          serverID=handleConnectResponse(remote,response);
        }
 catch (        Exception e) {
          killConnection(aConnection);
          aConnection=null;
          connection=null;
          remoteServerID=null;
          connectionState=UNCONNECTED;
          throw new ConnectException(""String_Node_Str"");
        }
        aConnection.start();
        remoteServerID=serverID;
        connectionState=CONNECTED;
      }
    }
  }
 catch (  Exception e) {
    dumpStack(""String_Node_Str"",e);
    ContainerConnectException except=new ContainerConnectException(""String_Node_Str"" + remote.getName(),e);
    throw except;
  }
}","public void connect(ID remote,IConnectContext joinContext) throws ContainerConnectException {
  fireContainerEvent(new ContainerConnectingEvent(this.getID(),remote,joinContext));
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    debug(""String_Node_Str"" + remote + ""String_Node_Str""+ joinContext+ ""String_Node_Str"");
    ISynchAsynchConnection aConnection=createConnection(remote,joinContext);
    Object response=null;
synchronized (getConnectLock()) {
      if (isConnected()) {
        killConnection(aConnection);
        throw new ConnectException(""String_Node_Str"" + getConnectedID());
      }
      if (isConnecting()) {
        killConnection(aConnection);
        throw new ConnectException(""String_Node_Str"");
      }
      setStateConnecting(aConnection);
    }
    Callback[] callbacks=createAuthorizationCallbacks();
    if (joinContext != null) {
      CallbackHandler handler=joinContext.getCallbackHandler();
      if (handler != null) {
        handler.handle(callbacks);
      }
    }
synchronized (connectLock) {
synchronized (aConnection) {
        try {
          Object connectData=createConnectData(remote,callbacks,null);
          response=aConnection.connect(remote,connectData,getConnectTimeout());
        }
 catch (        IOException e) {
          if (getConnection() != aConnection)           killConnection(aConnection);
 else           setStateUnconnected(aConnection);
          throw e;
        }
        if (getConnection() != aConnection) {
          killConnection(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        ID serverID=null;
        try {
          serverID=handleConnectResponse(remote,response);
        }
 catch (        Exception e) {
          setStateUnconnected(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        aConnection.start();
        setStateConnected(serverID,aConnection);
      }
    }
  }
 catch (  Exception e) {
    dumpStack(""String_Node_Str"",e);
    ContainerConnectException except=new ContainerConnectException(""String_Node_Str"" + remote.getName(),e);
    throw except;
  }
}",0.6629526462395543
95143,"public void connect(ID remote,IConnectContext joinContext) throws ContainerConnectException {
  fireContainerEvent(new ContainerConnectingEvent(this.getID(),remote,joinContext));
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    debug(""String_Node_Str"" + remote + ""String_Node_Str""+ joinContext+ ""String_Node_Str"");
    ISynchAsynchConnection aConnection=createConnection(remote,joinContext);
    Object response=null;
synchronized (getConnectLock()) {
      if (isConnected()) {
        killConnection(aConnection);
        throw new ConnectException(""String_Node_Str"" + getConnectedID());
      }
      if (isConnecting()) {
        killConnection(aConnection);
        throw new ConnectException(""String_Node_Str"");
      }
      setStateConnecting(aConnection);
    }
    Callback[] callbacks=createAuthorizationCallbacks();
    if (joinContext != null) {
      CallbackHandler handler=joinContext.getCallbackHandler();
      if (handler != null) {
        handler.handle(callbacks);
      }
    }
synchronized (connectLock) {
synchronized (aConnection) {
        try {
          Object connectData=createConnectData(remote,callbacks,null);
          response=aConnection.connect(remote,connectData,getConnectTimeout());
        }
 catch (        IOException e) {
          if (getConnection() != aConnection)           killConnection(aConnection);
 else           setStateUnconnected(aConnection);
          throw e;
        }
        if (getConnection() != aConnection) {
          killConnection(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        ID serverID=null;
        try {
          serverID=handleConnectResponse(remote,response);
        }
 catch (        Exception e) {
          setStateUnconnected(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        aConnection.start();
        setStateConnected(serverID,aConnection);
      }
    }
  }
 catch (  Exception e) {
    dumpStack(""String_Node_Str"",e);
    ContainerConnectException except=new ContainerConnectException(""String_Node_Str"" + remote.getName(),e);
    throw except;
  }
}","public void connect(ID remote,IConnectContext joinContext) throws ContainerConnectException {
  fireContainerEvent(new ContainerConnectingEvent(this.getID(),remote,joinContext));
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    debug(""String_Node_Str"" + remote + ""String_Node_Str""+ joinContext+ ""String_Node_Str"");
    ISynchAsynchConnection aConnection=createConnection(remote,joinContext);
    Object response=null;
synchronized (getConnectLock()) {
      if (isConnected()) {
        killConnection(aConnection);
        throw new ConnectException(""String_Node_Str"" + getConnectedID());
      }
      if (isConnecting()) {
        killConnection(aConnection);
        throw new ConnectException(""String_Node_Str"");
      }
      setStateConnecting(aConnection);
synchronized (aConnection) {
        Callback[] callbacks=createAuthorizationCallbacks();
        if (joinContext != null) {
          CallbackHandler handler=joinContext.getCallbackHandler();
          if (handler != null) {
            handler.handle(callbacks);
          }
        }
        try {
          Object connectData=createConnectData(remote,callbacks,null);
          response=aConnection.connect(remote,connectData,getConnectTimeout());
        }
 catch (        IOException e) {
          if (getConnection() != aConnection)           killConnection(aConnection);
 else           setStateUnconnected(aConnection);
          throw e;
        }
        if (getConnection() != aConnection) {
          killConnection(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        ID serverID=null;
        try {
          serverID=handleConnectResponse(remote,response);
        }
 catch (        Exception e) {
          setStateUnconnected(aConnection);
          throw new ConnectException(""String_Node_Str"");
        }
        aConnection.start();
        setStateConnected(serverID,aConnection);
      }
    }
  }
 catch (  Exception e) {
    dumpStack(""String_Node_Str"",e);
    ContainerConnectException except=new ContainerConnectException(""String_Node_Str"" + remote.getName(),e);
    throw except;
  }
}",0.9719452817064688
95144,"public void createSharedObjects() throws Exception {
  if (sharedObjectClassNames != null) {
    for (int j=0; j < clientCount; j++) {
      ISharedObjectContainer scg=sm[j];
      sharedObjects=new ID[sharedObjectClassNames.length];
      for (int i=0; i < sharedObjectClassNames.length; i++) {
        System.out.println(""String_Node_Str"" + sharedObjectClassNames[i] + ""String_Node_Str""+ scg.getID().getName());
        ISharedObject so=(ISharedObject)Class.forName(sharedObjectClassNames[i]).newInstance();
        scg.getSharedObjectManager().addSharedObject(sharedObjects[i],so,new HashMap());
        System.out.println(""String_Node_Str"" + scg.getID().getName());
      }
    }
  }
}","public void createSharedObjects() throws Exception {
  if (sharedObjectClassNames != null) {
    for (int j=0; j < clientCount; j++) {
      ISharedObjectContainer scg=sm[j];
      sharedObjects=new ID[sharedObjectClassNames.length];
      for (int i=0; i < sharedObjectClassNames.length; i++) {
        System.out.println(""String_Node_Str"" + sharedObjectClassNames[i] + ""String_Node_Str""+ scg.getID().getName());
        ISharedObject so=(ISharedObject)Class.forName(sharedObjectClassNames[i]).newInstance();
        sharedObjects[i]=IDFactory.getDefault().createStringID(sharedObjectClassNames[i] + ""String_Node_Str"" + i);
        scg.getSharedObjectManager().addSharedObject(sharedObjects[i],so,new HashMap());
        System.out.println(""String_Node_Str"" + scg.getID().getName());
      }
    }
  }
}",0.9229738780977896
95145,"/** 
 * Check remote creation of shared objects. This method is called by the remote shared object creation message handler, to verify that the shared object from container 'fromID' to container 'toID' with description 'desc' is to be allowed to be created within the current container. If this method throws, a failure (and exception will be sent back to caller If this method returns null, the create message is ignored. If this method returns a non-null object, the creation is allowed to proceed. The default implementation is to return a non-null object
 * @param fromID the ID of the container sending us this create request
 * @param toID the ID (or null) of the container intended to receive this request
 * @param desc the SharedObjectDescription that describes the shared object to be created
 * @return Object null if the create message is to be ignored, non-null ifthe creation should continue
 * @throws Exception may throw any Exception to communicate back (via sendCreateResponse) to the sender that the creation has failed
 */
protected Object checkRemoteCreate(ID fromID,ID toID,SharedObjectDescription desc) throws Exception {
  debug(""String_Node_Str"" + fromID + ""String_Node_Str""+ toID+ ""String_Node_Str""+ desc+ ""String_Node_Str"");
  if (policy != null) {
    policy.checkAddSharedObject(fromID,toID,getID(),desc);
  }
  return desc;
}","/** 
 * Check remote creation of shared objects. This method is called by the remote shared object creation message handler, to verify that the shared object from container 'fromID' to container 'toID' with description 'desc' is to be allowed to be created within the current container. If this method throws, a failure (and exception will be sent back to caller If this method returns null, the create message is ignored. If this method returns a non-null object, the creation is allowed to proceed. The default implementation is to return a non-null object
 * @param fromID the ID of the container sending us this create request
 * @param toID the ID (or null) of the container intended to receive this request
 * @param desc the SharedObjectDescription that describes the shared object to be created
 * @return Object null if the create message is to be ignored, non-null ifthe creation should continue
 * @throws Exception may throw any Exception to communicate back (via sendCreateResponse) to the sender that the creation has failed
 */
protected Object checkRemoteCreate(ID fromID,ID toID,SharedObjectDescription desc) throws Exception {
  debug(""String_Node_Str"" + fromID + ""String_Node_Str""+ toID+ ""String_Node_Str""+ desc+ ""String_Node_Str"");
  if (policy != null) {
    return policy.checkAddSharedObject(fromID,toID,getID(),desc);
  }
  return desc;
}",0.9974236290025764
95146,"protected void removeUserFromTree(ID id){
  if (id == null)   return;
  TreeParent top=getPresenceRoot();
  if (top != null) {
    for (Iterator e=top.children().iterator(); e.hasNext(); ) {
      TreeUser tn=(TreeUser)e.next();
      User ud=(User)tn.getUser();
      if (id.equals(ud.getUserID())) {
        top.removeChild(tn);
        refreshTreeView();
      }
    }
  }
}","protected void removeUserFromTree(ID id){
  if (id == null)   return;
  TreeParent top=getPresenceRoot();
  if (top != null) {
    for (Iterator e=top.children().iterator(); e.hasNext(); ) {
      TreeUser tn=(TreeUser)e.next();
      User ud=(User)tn.getUser();
      if (id.equals(ud.getUserID())) {
        e.remove();
        refreshTreeView();
      }
    }
  }
}",0.9369127516778524
95147,"protected void replicateTo(ID[] remotes){
  trace(""String_Node_Str"" + Arrays.asList(remotes) + ""String_Node_Str"");
  try {
    ISharedObjectContext context=getSharedObject().getContext();
    if (context == null)     return;
    ID[] group=context.getGroupMemberIDs();
    if (group == null || group.length < 1) {
      return;
    }
    SharedObjectDescription[] createInfos=getSharedObject().getReplicaDescriptions(remotes);
    if (createInfos != null) {
      if (createInfos.length == 1) {
        context.sendCreate((remotes == null) ? null : remotes[0],createInfos[0]);
      }
 else {
        for (int i=0; i < remotes.length; i++) {
          context.sendCreate(remotes[i],createInfos[i]);
        }
      }
    }
  }
 catch (  IOException e) {
    traceStack(""String_Node_Str"" + Arrays.asList(remotes) + ""String_Node_Str"",e);
    return;
  }
}","protected void replicateTo(ID[] remotes){
  if (remotes == null) {
    trace(""String_Node_Str"");
  }
 else {
    trace(""String_Node_Str"" + Arrays.asList(remotes) + ""String_Node_Str"");
  }
  try {
    ISharedObjectContext context=getSharedObject().getContext();
    if (context == null)     return;
    ID[] group=context.getGroupMemberIDs();
    if (group == null || group.length < 1) {
      return;
    }
    SharedObjectDescription[] createInfos=getSharedObject().getReplicaDescriptions(remotes);
    if (createInfos != null) {
      if (createInfos.length == 1) {
        context.sendCreate((remotes == null) ? null : remotes[0],createInfos[0]);
      }
 else {
        for (int i=0; i < remotes.length; i++) {
          context.sendCreate(remotes[i],createInfos[i]);
        }
      }
    }
  }
 catch (  IOException e) {
    traceStack(""String_Node_Str"" + Arrays.asList(remotes) + ""String_Node_Str"",e);
    return;
  }
}",0.925238898257448
95148,"protected void handleCreateResponse(ISharedObjectCreateResponseEvent event){
  trace(""String_Node_Str"" + event + ""String_Node_Str"");
  if (isPrimary()) {
synchronized (lock) {
      trace(""String_Node_Str"" + event + ""String_Node_Str"");
      Throwable except=event.getException();
      ID remoteID=event.getRemoteContainerID();
      long ident=event.getSequence();
      if (getTransactionState() == ISharedObjectContainerTransaction.VOTING) {
        if (except == null) {
          removeParticipant(remoteID);
        }
 else {
          addFailed(remoteID,except);
        }
      }
 else {
        handleVotingCompletedCreateResponse(remoteID,except,ident);
      }
      lock.notifyAll();
    }
  }
 else {
  }
}","protected void handleCreateResponse(ISharedObjectCreateResponseEvent event){
  trace(""String_Node_Str"" + event + ""String_Node_Str"");
  if (isPrimary()) {
synchronized (lock) {
      Throwable except=event.getException();
      ID remoteID=event.getRemoteContainerID();
      long ident=event.getSequence();
      if (getTransactionState() == ISharedObjectContainerTransaction.VOTING) {
        if (except == null) {
          removeParticipant(remoteID);
        }
 else {
          addFailed(remoteID,except);
        }
      }
 else {
        handleVotingCompletedCreateResponse(remoteID,except,ident);
      }
      lock.notifyAll();
    }
  }
 else {
  }
}",0.9565217391304348
95149,"protected void sendCommit() throws SharedObjectAddAbortException {
  trace(""String_Node_Str"");
  try {
    getContext().sendMessage(null,new SharedObjectCommitEvent(getSharedObject().getID()));
  }
 catch (  Exception e2) {
    doTMAbort(new SharedObjectAddAbortException(""String_Node_Str"",e2,getTimeout()));
  }
}","protected void sendCommit() throws SharedObjectAddAbortException {
  try {
    getContext().sendMessage(null,new SharedObjectCommitEvent(getSharedObject().getID()));
  }
 catch (  Exception e2) {
    doTMAbort(new SharedObjectAddAbortException(""String_Node_Str"",e2,getTimeout()));
  }
}",0.9533333333333334
95150,"protected void fillCombo(){
  List rawDescriptions=null;
  if (descriptions != null) {
    rawDescriptions=Arrays.asList(descriptions);
  }
 else {
    rawDescriptions=ContainerFactory.getDefault().getDescriptions();
  }
  int index=0;
  int def=0;
  Map defProps=null;
  for (Iterator i=rawDescriptions.iterator(); i.hasNext(); ) {
    final ContainerDescription desc=(ContainerDescription)i.next();
    String name=desc.getName();
    String description=desc.getDescription();
    Map props=desc.getProperties();
    String isServer=(String)props.get(ISSERVER_PROP_NAME);
    if (isServer == null || !isServer.equalsIgnoreCase(""String_Node_Str"")) {
      if (DEFAULT_CLIENT.equals(name)) {
        def=index;
        defProps=props;
      }
      combo.add(description + ""String_Node_Str"" + name,index);
      combo.setData(""String_Node_Str"" + index,desc);
      containerDescriptions.add(desc);
      index++;
    }
  }
  combo.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      ContainerDescription desc=(ContainerDescription)combo.getData(combo.getSelectionIndex() + ""String_Node_Str"");
      Map props=desc.getProperties();
      modifyUI(props);
    }
    public void widgetDefaultSelected(    SelectionEvent e){
      widgetSelected(e);
    }
  }
);
  if (combo.getItemCount() > 0)   combo.select(def);
  if (defProps != null)   modifyUI(defProps);
}","protected void fillCombo(){
  List rawDescriptions=null;
  if (descriptions != null) {
    rawDescriptions=Arrays.asList(descriptions);
  }
 else {
    rawDescriptions=ContainerFactory.getDefault().getDescriptions();
  }
  int index=0;
  int def=0;
  Map defProps=null;
  for (Iterator i=rawDescriptions.iterator(); i.hasNext(); ) {
    final ContainerDescription desc=(ContainerDescription)i.next();
    String name=desc.getName();
    String description=desc.getDescription();
    Map props=desc.getProperties();
    defProps=props;
    String isServer=(String)props.get(ISSERVER_PROP_NAME);
    if (isServer == null || !isServer.equalsIgnoreCase(""String_Node_Str"")) {
      if (DEFAULT_CLIENT.equals(name)) {
        def=index;
        defProps=props;
      }
      combo.add(description + ""String_Node_Str"" + name,index);
      combo.setData(""String_Node_Str"" + index,desc);
      containerDescriptions.add(desc);
      index++;
    }
  }
  combo.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      ContainerDescription desc=(ContainerDescription)combo.getData(combo.getSelectionIndex() + ""String_Node_Str"");
      Map props=desc.getProperties();
      modifyUI(props);
    }
    public void widgetDefaultSelected(    SelectionEvent e){
      widgetSelected(e);
    }
  }
);
  if (combo.getItemCount() > 0)   combo.select(def);
  if (defProps != null)   modifyUI(defProps);
}",0.9929725931131412
95151,"public void handleJoin(ID user){
  otherUsers.add(user);
}","public void handleJoin(ID user){
  if (disposed)   return;
  otherUsers.add(user);
}",0.8169014084507042
95152,"public void handleLeave(ID user){
  otherUsers.remove(user);
}","public void handleLeave(ID user){
  if (disposed)   return;
  otherUsers.remove(user);
}",0.8266666666666667
95153,"public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null && !otherUsers.contains(fromID)) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
        if (localUser != null && localUser.getID().equals(fromID)) {
          setEnabled(false);
          String title=getPartName();
          setPartName(""String_Node_Str"" + title + ""String_Node_Str"");
          removeAllParticipants();
          dispose();
        }
      }
    }
  }
);
}","public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null && !otherUsers.contains(fromID)) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
        if (localUser != null && localUser.getID().equals(fromID)) {
          setEnabled(false);
          String title=getPartName();
          setPartName(""String_Node_Str"" + title + ""String_Node_Str"");
          removeAllParticipants();
          dispose();
        }
      }
    }
  }
);
}",0.9776315789473684
95154,"public void handleMessage(final ID fromID,final ID toID,final Type type,final String subject,final String messageBody){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      appendText(new ChatLine(messageBody,new Participant(fromID)));
    }
  }
);
}","public void handleMessage(final ID fromID,final ID toID,final Type type,final String subject,final String messageBody){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      appendText(new ChatLine(messageBody,new Participant(fromID)));
    }
  }
);
}",0.9415807560137456
95155,"public void dispose(){
  if (closeListener != null) {
    closeListener.chatRoomViewClosing(viewID);
    closeListener=null;
    viewID=null;
  }
  super.dispose();
}","public void dispose(){
  if (closeListener != null) {
    closeListener.chatRoomViewClosing(viewID);
    closeListener=null;
    viewID=null;
  }
  otherUsers.clear();
  localUser=null;
  disposed=true;
  super.dispose();
}",0.8277634961439588
95156,"protected void addParticipant(IUser p){
  ChatLine cl=new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ p.getID().getName()+ ""String_Node_Str"",null);
  appendText(cl);
  memberViewer.add(p);
}","protected void addParticipant(IUser p){
  if (p != null) {
    ID id=p.getID();
    if (id != null) {
      ChatLine cl=new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ id.getName()+ ""String_Node_Str"",null);
      appendText(cl);
      memberViewer.add(p);
    }
  }
}",0.5150905432595574
95157,"protected void addParticipant(IUser p){
  if (p != null) {
    ID id=p.getID();
    if (id != null) {
      ChatLine cl=new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ id.getName()+ ""String_Node_Str"",null);
      appendText(cl);
      memberViewer.add(p);
    }
  }
}","protected void addParticipant(IUser p){
  if (p != null) {
    ID id=p.getID();
    if (id != null) {
      appendText(new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ trimUserID(id)+ ""String_Node_Str"",null));
      memberViewer.add(p);
    }
  }
}",0.4801444043321299
95158,"public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null && !otherUsers.contains(fromID)) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
        if (localUser != null && localUser.getID().equals(fromID)) {
          setEnabled(false);
          String title=getPartName();
          setPartName(""String_Node_Str"" + title + ""String_Node_Str"");
          removeAllParticipants();
          dispose();
        }
      }
    }
  }
);
}","public void handlePresence(final ID fromID,final IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      if (disposed)       return;
      boolean isAdd=presence.getType().equals(IPresence.Type.AVAILABLE);
      Participant p=new Participant(fromID);
      if (isAdd) {
        if (localUser == null && !otherUsers.contains(fromID)) {
          localUser=p;
        }
        addParticipant(p);
      }
 else {
        removeParticipant(p);
        if (isLocalUser(fromID))         removeLocalUser();
      }
    }
  }
);
}",0.789865871833085
95159,"protected void removeParticipant(IUser p){
  if (p != null) {
    ID id=p.getID();
    if (id != null) {
      ChatLine cl=new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ id.getName()+ ""String_Node_Str"",null);
      appendText(cl);
      memberViewer.remove(p);
    }
  }
}","protected void removeParticipant(IUser p){
  if (p != null) {
    ID id=p.getID();
    if (id != null) {
      appendText(new ChatLine(""String_Node_Str"" + getDateTime() + ""String_Node_Str""+ trimUserID(id)+ ""String_Node_Str"",null));
      memberViewer.remove(p);
      if (isLocalUser(id))       removeLocalUser();
    }
  }
}",0.4368932038834951
95160,"public String toString(){
  String fullName=id.getName();
  int atIndex=fullName.indexOf('@');
  if (atIndex != -1) {
    fullName=fullName.substring(0,atIndex);
  }
  return fullName;
}","public String toString(){
  return trimUserID(id);
}",0.3361344537815126
95161,"public void run(){
  IChatRoomManager managers[]=new IChatRoomManager[accounts.size()];
  int j=0;
  for (Iterator i=accounts.values().iterator(); i.hasNext(); ) {
    UserAccount ua=(UserAccount)i.next();
    managers[j++]=ua.getContainer().getChatRoomManager();
  }
  ChatRoomSelectionDialog dialog=new ChatRoomSelectionDialog(RosterView.this.getViewSite().getShell(),managers);
  dialog.setBlockOnOpen(true);
  dialog.open();
  if (dialog.getReturnCode() != Window.OK) {
    return;
  }
  ChatRoomSelectionDialog.Room room=dialog.getSelectedRoom();
  IChatRoomManager selectedManager=room.getManager();
  IRoomInfo selectedInfo=room.getRoomInfo();
  if (room == null || selectedManager == null || selectedInfo == null) {
    MessageDialog.openInformation(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
    return;
  }
  String secondaryID=getChatRoomSecondaryID(selectedInfo.getRoomID());
  if (secondaryID == null) {
    MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getRoomID());
    return;
  }
  IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  IWorkbenchPage wp=ww.getActivePage();
  RoomWithAView roomView=getRoomView(secondaryID);
  if (roomView != null) {
    ChatRoomView view=roomView.getView();
    wp.activate(view);
    return;
  }
  IChatRoomContainer chatRoom=null;
  try {
    chatRoom=selectedManager.makeChatRoomContainer();
  }
 catch (  ContainerInstantiationException e1) {
    MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
  }
  IChatMessageSender sender=chatRoom.getChatMessageSender();
  IViewPart view=null;
  try {
    IViewReference ref=wp.findViewReference(CHAT_ROOM_VIEW_CLASS,secondaryID);
    if (ref == null) {
      view=wp.showView(CHAT_ROOM_VIEW_CLASS,secondaryID,IWorkbenchPage.VIEW_ACTIVATE);
    }
 else {
      view=ref.getView(true);
    }
    final ChatRoomView chatroomview=(ChatRoomView)view;
    chatroomview.initialize(RosterView.this,secondaryID,chatRoom,selectedInfo,sender);
    chatRoom.addMessageListener(new IMessageListener(){
      public void handleMessage(      ID fromID,      ID toID,      Type type,      String subject,      String messageBody){
        chatroomview.handleMessage(fromID,toID,type,subject,messageBody);
      }
    }
);
    chatRoom.addChatParticipantListener(new IChatParticipantListener(){
      public void handlePresence(      ID fromID,      IPresence presence){
        chatroomview.handlePresence(fromID,presence);
      }
      public void joined(      ID user){
        chatroomview.handleJoin(user);
      }
      public void left(      ID user){
        chatroomview.handleLeave(user);
      }
    }
);
    chatRoom.addInvitationListener(new IInvitationListener(){
      public void handleInvitationReceived(      ID roomID,      ID from,      ID toID,      String subject,      String body){
        chatroomview.handleInvitationReceived(roomID,from,toID,subject,body);
      }
    }
);
  }
 catch (  PartInitException e) {
    UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e);
    MessageDialog.openError(getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str"");
    return;
  }
  try {
    chatRoom.connect(selectedInfo.getRoomID(),null);
  }
 catch (  ContainerConnectException e1) {
    UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e1);
    MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str""+ e1.getMessage());
    return;
  }
  addRoomView(new RoomWithAView(selectedManager,chatRoom,(ChatRoomView)view,secondaryID));
}","public void run(){
  IChatRoomManager managers[]=new IChatRoomManager[accounts.size()];
  int j=0;
  for (Iterator i=accounts.values().iterator(); i.hasNext(); ) {
    UserAccount ua=(UserAccount)i.next();
    managers[j++]=ua.getContainer().getChatRoomManager();
  }
  ChatRoomSelectionDialog dialog=new ChatRoomSelectionDialog(RosterView.this.getViewSite().getShell(),managers);
  dialog.setBlockOnOpen(true);
  dialog.open();
  if (dialog.getReturnCode() != Window.OK) {
    return;
  }
  ChatRoomSelectionDialog.Room room=dialog.getSelectedRoom();
  IChatRoomManager selectedManager=room.getManager();
  IRoomInfo selectedInfo=room.getRoomInfo();
  if (room == null || selectedManager == null || selectedInfo == null) {
    MessageDialog.openInformation(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
    return;
  }
  String secondaryID=getChatRoomSecondaryID(selectedInfo.getRoomID());
  if (secondaryID == null) {
    MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getRoomID());
    return;
  }
  IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  IWorkbenchPage wp=ww.getActivePage();
  RoomWithAView roomView=getRoomView(secondaryID);
  if (roomView != null) {
    ChatRoomView view=roomView.getView();
    wp.activate(view);
    return;
  }
  IChatRoomContainer chatRoom=null;
  try {
    chatRoom=selectedManager.makeChatRoomContainer();
  }
 catch (  ContainerInstantiationException e1) {
    MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
  }
  IChatMessageSender sender=chatRoom.getChatMessageSender();
  IViewPart view=null;
  try {
    IViewReference ref=wp.findViewReference(CHAT_ROOM_VIEW_CLASS,secondaryID);
    if (ref == null) {
      view=wp.showView(CHAT_ROOM_VIEW_CLASS,secondaryID,IWorkbenchPage.VIEW_ACTIVATE);
    }
 else {
      view=ref.getView(true);
    }
    final ChatRoomView chatroomview=(ChatRoomView)view;
    chatroomview.initialize(RosterView.this,secondaryID,chatRoom,selectedInfo,sender);
    chatRoom.addMessageListener(new IMessageListener(){
      public void handleMessage(      ID fromID,      ID toID,      Type type,      String subject,      String messageBody){
        chatroomview.handleMessage(fromID,toID,type,subject,messageBody);
      }
    }
);
    chatRoom.addChatParticipantListener(new IChatParticipantListener(){
      public void handlePresence(      ID fromID,      IPresence presence){
        chatroomview.handlePresence(fromID,presence);
      }
      public void joined(      ID user){
        chatroomview.handleJoin(user);
      }
      public void left(      ID user){
        chatroomview.handleLeave(user);
      }
    }
);
    chatRoom.addInvitationListener(new IInvitationListener(){
      public void handleInvitationReceived(      ID roomID,      ID from,      ID toID,      String subject,      String body){
        chatroomview.handleInvitationReceived(roomID,from,toID,subject,body);
      }
    }
);
  }
 catch (  PartInitException e) {
    UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e);
    MessageDialog.openError(getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str"");
    return;
  }
  try {
    chatRoom.connect(selectedInfo.getRoomID(),getChatJoinContext(""String_Node_Str"" + selectedInfo.getName()));
  }
 catch (  ContainerConnectException e1) {
    UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e1);
    MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str""+ e1.getMessage());
    return;
  }
  addRoomView(new RoomWithAView(selectedManager,chatRoom,(ChatRoomView)view,secondaryID));
}",0.9913135035535668
95162,"private void makeActions(){
  selectedDoubleClickAction=new Action(){
    public void run(){
      TreeObject treeObject=getSelectedTreeObject();
      final ID targetID=treeObject.getUserID();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      for (Iterator i=accounts.entrySet().iterator(); i.hasNext(); ) {
        Map.Entry entry=(Map.Entry)i.next();
        UserAccount account=(UserAccount)entry.getValue();
        account.getInputHandler().disconnect();
      }
      setToolbarEnabled(false);
      this.setEnabled(false);
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"");
  disconnectAction.setEnabled(false);
  disconnectAction.setImageDescriptor(ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(DISCONNECT_ICON_ENABLED))));
  disconnectAction.setDisabledImageDescriptor(ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(DISCONNECT_ICON_DISABLED))));
  openChatRoomAction=new Action(){
    public void run(){
      IChatRoomManager managers[]=new IChatRoomManager[accounts.size()];
      int j=0;
      for (Iterator i=accounts.values().iterator(); i.hasNext(); ) {
        UserAccount ua=(UserAccount)i.next();
        managers[j++]=ua.getContainer().getChatRoomManager();
      }
      ChatRoomSelectionDialog dialog=new ChatRoomSelectionDialog(RosterView.this.getViewSite().getShell(),managers);
      dialog.setBlockOnOpen(true);
      dialog.open();
      if (dialog.getReturnCode() != Window.OK) {
        return;
      }
      ChatRoomSelectionDialog.Room room=dialog.getSelectedRoom();
      IChatRoomManager selectedManager=room.getManager();
      IRoomInfo selectedInfo=room.getRoomInfo();
      if (room == null || selectedManager == null || selectedInfo == null) {
        MessageDialog.openInformation(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
        return;
      }
      String secondaryID=getChatRoomSecondaryID(selectedInfo.getRoomID());
      if (secondaryID == null) {
        MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getRoomID());
        return;
      }
      IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
      IWorkbenchPage wp=ww.getActivePage();
      RoomWithAView roomView=getRoomView(secondaryID);
      if (roomView != null) {
        ChatRoomView view=roomView.getView();
        wp.activate(view);
        return;
      }
      IChatRoomContainer chatRoom=null;
      try {
        chatRoom=selectedManager.makeChatRoomContainer();
      }
 catch (      ContainerInstantiationException e1) {
        MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
      }
      IChatMessageSender sender=chatRoom.getChatMessageSender();
      IViewPart view=null;
      try {
        IViewReference ref=wp.findViewReference(CHAT_ROOM_VIEW_CLASS,secondaryID);
        if (ref == null) {
          view=wp.showView(CHAT_ROOM_VIEW_CLASS,secondaryID,IWorkbenchPage.VIEW_ACTIVATE);
        }
 else {
          view=ref.getView(true);
        }
        final ChatRoomView chatroomview=(ChatRoomView)view;
        chatroomview.initialize(RosterView.this,secondaryID,chatRoom,selectedInfo,sender);
        chatRoom.addMessageListener(new IMessageListener(){
          public void handleMessage(          ID fromID,          ID toID,          Type type,          String subject,          String messageBody){
            chatroomview.handleMessage(fromID,toID,type,subject,messageBody);
          }
        }
);
        chatRoom.addChatParticipantListener(new IChatParticipantListener(){
          public void handlePresence(          ID fromID,          IPresence presence){
            chatroomview.handlePresence(fromID,presence);
          }
          public void joined(          ID user){
            chatroomview.handleJoin(user);
          }
          public void left(          ID user){
            chatroomview.handleLeave(user);
          }
        }
);
        chatRoom.addInvitationListener(new IInvitationListener(){
          public void handleInvitationReceived(          ID roomID,          ID from,          ID toID,          String subject,          String body){
            chatroomview.handleInvitationReceived(roomID,from,toID,subject,body);
          }
        }
);
      }
 catch (      PartInitException e) {
        UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e);
        MessageDialog.openError(getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str"");
        return;
      }
      try {
        chatRoom.connect(selectedInfo.getRoomID(),null);
      }
 catch (      ContainerConnectException e1) {
        UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e1);
        MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str""+ e1.getMessage());
        return;
      }
      addRoomView(new RoomWithAView(selectedManager,chatRoom,(ChatRoomView)view,secondaryID));
    }
  }
;
  openChatRoomAction.setText(""String_Node_Str"");
  openChatRoomAction.setToolTipText(""String_Node_Str"");
  openChatRoomAction.setImageDescriptor(ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(ADDCHAT_ICON))));
  openChatRoomAction.setEnabled(false);
}","private void makeActions(){
  selectedDoubleClickAction=new Action(){
    public void run(){
      TreeObject treeObject=getSelectedTreeObject();
      final ID targetID=treeObject.getUserID();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      for (Iterator i=accounts.entrySet().iterator(); i.hasNext(); ) {
        Map.Entry entry=(Map.Entry)i.next();
        UserAccount account=(UserAccount)entry.getValue();
        account.getInputHandler().disconnect();
      }
      setToolbarEnabled(false);
      this.setEnabled(false);
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"");
  disconnectAction.setEnabled(false);
  disconnectAction.setImageDescriptor(ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(DISCONNECT_ICON_ENABLED))));
  disconnectAction.setDisabledImageDescriptor(ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(DISCONNECT_ICON_DISABLED))));
  openChatRoomAction=new Action(){
    public void run(){
      IChatRoomManager managers[]=new IChatRoomManager[accounts.size()];
      int j=0;
      for (Iterator i=accounts.values().iterator(); i.hasNext(); ) {
        UserAccount ua=(UserAccount)i.next();
        managers[j++]=ua.getContainer().getChatRoomManager();
      }
      ChatRoomSelectionDialog dialog=new ChatRoomSelectionDialog(RosterView.this.getViewSite().getShell(),managers);
      dialog.setBlockOnOpen(true);
      dialog.open();
      if (dialog.getReturnCode() != Window.OK) {
        return;
      }
      ChatRoomSelectionDialog.Room room=dialog.getSelectedRoom();
      IChatRoomManager selectedManager=room.getManager();
      IRoomInfo selectedInfo=room.getRoomInfo();
      if (room == null || selectedManager == null || selectedInfo == null) {
        MessageDialog.openInformation(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
        return;
      }
      String secondaryID=getChatRoomSecondaryID(selectedInfo.getRoomID());
      if (secondaryID == null) {
        MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getRoomID());
        return;
      }
      IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
      IWorkbenchPage wp=ww.getActivePage();
      RoomWithAView roomView=getRoomView(secondaryID);
      if (roomView != null) {
        ChatRoomView view=roomView.getView();
        wp.activate(view);
        return;
      }
      IChatRoomContainer chatRoom=null;
      try {
        chatRoom=selectedManager.makeChatRoomContainer();
      }
 catch (      ContainerInstantiationException e1) {
        MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
      }
      IChatMessageSender sender=chatRoom.getChatMessageSender();
      IViewPart view=null;
      try {
        IViewReference ref=wp.findViewReference(CHAT_ROOM_VIEW_CLASS,secondaryID);
        if (ref == null) {
          view=wp.showView(CHAT_ROOM_VIEW_CLASS,secondaryID,IWorkbenchPage.VIEW_ACTIVATE);
        }
 else {
          view=ref.getView(true);
        }
        final ChatRoomView chatroomview=(ChatRoomView)view;
        chatroomview.initialize(RosterView.this,secondaryID,chatRoom,selectedInfo,sender);
        chatRoom.addMessageListener(new IMessageListener(){
          public void handleMessage(          ID fromID,          ID toID,          Type type,          String subject,          String messageBody){
            chatroomview.handleMessage(fromID,toID,type,subject,messageBody);
          }
        }
);
        chatRoom.addChatParticipantListener(new IChatParticipantListener(){
          public void handlePresence(          ID fromID,          IPresence presence){
            chatroomview.handlePresence(fromID,presence);
          }
          public void joined(          ID user){
            chatroomview.handleJoin(user);
          }
          public void left(          ID user){
            chatroomview.handleLeave(user);
          }
        }
);
        chatRoom.addInvitationListener(new IInvitationListener(){
          public void handleInvitationReceived(          ID roomID,          ID from,          ID toID,          String subject,          String body){
            chatroomview.handleInvitationReceived(roomID,from,toID,subject,body);
          }
        }
);
      }
 catch (      PartInitException e) {
        UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e);
        MessageDialog.openError(getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str"");
        return;
      }
      try {
        chatRoom.connect(selectedInfo.getRoomID(),getChatJoinContext(""String_Node_Str"" + selectedInfo.getName()));
      }
 catch (      ContainerConnectException e1) {
        UiPlugin.log(""String_Node_Str"" + selectedInfo.getRoomID(),e1);
        MessageDialog.openError(RosterView.this.getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"" + selectedInfo.getName() + ""String_Node_Str""+ e1.getMessage());
        return;
      }
      addRoomView(new RoomWithAView(selectedManager,chatRoom,(ChatRoomView)view,secondaryID));
    }
  }
;
  openChatRoomAction.setText(""String_Node_Str"");
  openChatRoomAction.setToolTipText(""String_Node_Str"");
  openChatRoomAction.setImageDescriptor(ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(ADDCHAT_ICON))));
  openChatRoomAction.setEnabled(false);
}",0.9940743400969654
95163,"public Namespace getConnectNamespace(){
  return IDFactory.getDefault().getNamespaceByName(""String_Node_Str"");
}","public Namespace getConnectNamespace(){
  return IDFactory.getDefault().getNamespaceByName(XmppPlugin.NAMESPACE_IDENTIFIER);
}",0.8319327731092437
95164,"public void connect(String groupName) throws ContainerConnectException {
  ID targetID=null;
  try {
    targetID=makeChatRoomID(groupName);
  }
 catch (  IDInstantiationException e) {
    ContainerConnectException newExcept=new ContainerConnectException(""String_Node_Str"",e);
    newExcept.setStackTrace(e.getStackTrace());
    throw newExcept;
  }
  this.connect(targetID,null);
}","public void connect(String groupName) throws ContainerConnectException {
  ID targetID=null;
  try {
    targetID=makeChatRoomID(groupName);
  }
 catch (  IDInstantiationException e) {
    throw new ContainerConnectException(""String_Node_Str"",e);
  }
  this.connect(targetID,null);
}",0.8210526315789474
95165,"protected ID makeUserIDFromName(String name){
  ID result=null;
  try {
    result=IDFactory.getDefault().makeID(usernamespace,new Object[]{name});
    return result;
  }
 catch (  Exception e) {
    dumpStack(""String_Node_Str"",e);
    return null;
  }
}","protected ID makeUserIDFromName(String name){
  ID result=null;
  try {
    result=new XMPPID(usernamespace,name);
    return result;
  }
 catch (  Exception e) {
    dumpStack(""String_Node_Str"",e);
    return null;
  }
}",0.8842105263157894
95166,"protected String canonicalizeRoomFrom(String from){
  if (from == null)   return null;
  int atIndex=from.indexOf('@');
  String hostname=null;
  String username=null;
  int index=from.indexOf(""String_Node_Str"");
  if (atIndex > 0 && index > 0) {
    hostname=from.substring(atIndex + 1,index);
    int dotIndex=hostname.lastIndexOf('.');
    if (dotIndex > 0) {
      hostname=hostname.substring(dotIndex + 1);
    }
    username=from.substring(index + 1);
    return username + ""String_Node_Str"" + hostname;
  }
  return from;
}","protected String canonicalizeRoomFrom(String from){
  if (from == null)   return null;
  int atIndex=from.indexOf('@');
  String hostname=null;
  String username=null;
  int index=from.indexOf(""String_Node_Str"");
  if (atIndex > 0 && index > 0) {
    hostname=from.substring(atIndex + 1,index);
    username=from.substring(index + 1);
    return username + ""String_Node_Str"" + hostname;
  }
  return from;
}",0.8687299893276414
95167,"public String getHostname(){
  return uri.getHost();
}","public String getHostname(){
  return hostname;
}",0.8543689320388349
95168,"protected XMPPID(Namespace namespace,String unamehost) throws URISyntaxException {
  super(namespace);
  unamehost=fixEscape(unamehost);
  if (unamehost == null)   throw new URISyntaxException(unamehost,""String_Node_Str"");
  int atIndex=unamehost.indexOf(USER_HOST_DELIMITER);
  if (atIndex == -1)   throw new URISyntaxException(unamehost,""String_Node_Str"");
  String username=unamehost.substring(0,atIndex);
  String host=unamehost.substring(atIndex + 1);
  uri=new URI(namespace.getScheme(),username,host,-1,null,null,null);
}","public XMPPID(Namespace namespace,String unamehost) throws URISyntaxException {
  super(namespace);
  unamehost=fixEscape(unamehost);
  if (unamehost == null)   throw new URISyntaxException(unamehost,""String_Node_Str"");
  int atIndex=unamehost.lastIndexOf(USER_HOST_DELIMITER);
  if (atIndex == -1)   throw new URISyntaxException(unamehost,""String_Node_Str"");
  username=unamehost.substring(0,atIndex);
  hostname=unamehost.substring(atIndex + 1);
  uri=new URI(namespace.getScheme(),username,hostname,-1,null,null,null);
}",0.9096098953377736
95169,"public String getUsername(){
  return uri.getUserInfo();
}","public String getUsername(){
  return username;
}",0.8598130841121495
95170,"public ID makeInstance(Class[] argTypes,Object[] args) throws IDInstantiationException {
  try {
    if (args.length == 3) {
      return new XMPPID(this,(String)args[0],(String)args[1],(String)args[2]);
    }
 else     if (args.length == 2) {
      return new XMPPID(this,(String)args[0],(String)args[1]);
    }
 else     if (args.length == 1) {
      return new XMPPID(this,(String)args[0]);
    }
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 catch (  Exception e) {
    throw new IDInstantiationException(""String_Node_Str"",e);
  }
}","public ID makeInstance(Class[] argTypes,Object[] args) throws IDInstantiationException {
  try {
    return new XMPPID(this,(String)args[0]);
  }
 catch (  Exception e) {
    throw new IDInstantiationException(""String_Node_Str"",e);
  }
}",0.4601769911504424
95171,"protected void handleTextInput(String text){
  if (messageSender == null) {
    MessageDialog.openError(getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
    return;
  }
 else {
    try {
      messageSender.sendMessage(text);
    }
 catch (    IOException e) {
      UiPlugin.log(""String_Node_Str"",e);
    }
  }
}","protected void handleTextInput(String text){
  if (messageSender == null) {
    MessageDialog.openError(getViewSite().getShell(),""String_Node_Str"",""String_Node_Str"");
    return;
  }
 else {
    try {
      messageSender.sendMessage(text);
    }
 catch (    IOException e) {
      removeLocalUser();
    }
  }
}",0.927899686520376
95172,"protected void setEnabled(boolean enabled){
  writeText.setEnabled(enabled);
}","protected void setEnabled(boolean enabled){
  if (!writeText.isDisposed())   writeText.setEnabled(enabled);
}",0.8342245989304813
95173,"protected void removeLocalUser(){
  setEnabled(false);
  String title=getPartName();
  setPartName(""String_Node_Str"" + title + ""String_Node_Str"");
  removeAllParticipants();
  dispose();
}","protected void removeLocalUser(){
  String title=getPartName();
  setPartName(""String_Node_Str"" + title + ""String_Node_Str"");
  removeAllParticipants();
  cleanUp();
  setEnabled(false);
}",0.8563829787234043
95174,"public void dispose(){
  if (closeListener != null) {
    closeListener.chatRoomViewClosing(viewID);
    closeListener=null;
    viewID=null;
  }
  otherUsers.clear();
  localUser=null;
  disposed=true;
  super.dispose();
}","public void dispose(){
  disposed=true;
  cleanUp();
  super.dispose();
}",0.4054054054054054
95175,"public void initialize(final IChatRoomViewCloseListener parent,final String secondaryID,final IChatRoomContainer container,final IRoomInfo info,final IChatMessageSender sender){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      ChatRoomView.this.viewID=secondaryID;
      ChatRoomView.this.closeListener=parent;
      ChatRoomView.this.chatRoomContainer=container;
      ChatRoomView.this.messageSender=sender;
      ChatRoomView.this.roomInfo=info;
      ID roomID=info.getRoomID();
      ChatRoomView.this.setPartName(VIEW_PREFIX + roomInfo.getName());
      ChatRoomView.this.setTitleToolTip(""String_Node_Str"" + roomID.getName() + ""String_Node_Str""+ roomInfo.getDescription());
      setEnabled(true);
    }
  }
);
}","public void initialize(final IChatRoomViewCloseListener parent,final String secondaryID,final IChatRoomContainer container,final IRoomInfo info,final IChatMessageSender sender){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      removeAllParticipants();
      otherUsers.clear();
      localUser=null;
      ChatRoomView.this.viewID=secondaryID;
      ChatRoomView.this.closeListener=parent;
      ChatRoomView.this.chatRoomContainer=container;
      ChatRoomView.this.messageSender=sender;
      ChatRoomView.this.roomInfo=info;
      ID roomID=info.getRoomID();
      ChatRoomView.this.setPartName(VIEW_PREFIX + roomInfo.getName());
      ChatRoomView.this.setTitleToolTip(""String_Node_Str"" + roomID.getName() + ""String_Node_Str""+ roomInfo.getDescription());
      setEnabled(true);
    }
  }
);
}",0.9497135582431572
95176,"public void disconnect(){
  ID groupID=getConnectedID();
  fireContainerEvent(new SharedObjectContainerDisconnectingEvent(this.getID(),groupID));
synchronized (getConnectLock()) {
    if (isConnected()) {
      ISynchAsynchConnection conn=getConnection();
synchronized (conn) {
synchronized (getGroupMembershipLock()) {
          memberLeave(groupID,null);
        }
        try {
          conn.disconnect();
        }
 catch (        IOException e) {
          dumpStack(""String_Node_Str"",e);
        }
      }
    }
    connectionState=UNCONNECTED;
    this.connection=null;
    remoteServerID=null;
  }
  fireContainerEvent(new SharedObjectContainerDisconnectedEvent(this.getID(),groupID));
}","public void disconnect(){
  ID groupID=getConnectedID();
  fireContainerEvent(new SharedObjectContainerDisconnectingEvent(this.getID(),groupID));
synchronized (getConnectLock()) {
    if (isConnected()) {
      ISynchAsynchConnection conn=getConnection();
synchronized (conn) {
synchronized (getGroupMembershipLock()) {
          memberLeave(groupID,null);
        }
        try {
          conn.disconnect();
        }
 catch (        IOException e) {
          dumpStack(""String_Node_Str"",e);
        }
      }
    }
    connectionState=UNCONNECTED;
    this.connection=null;
    remoteServerID=null;
  }
  fireContainerEvent(new SharedObjectContainerDisconnectedEvent(this.getID(),groupID));
  dispose();
}",0.990747330960854
95177,"public IChatRoomManager getChatRoomManager(){
  return new IChatRoomManager(){
    public ID[] getChatRooms(){
      return XMPPClientSOContainer.this.getChatRooms();
    }
    public IRoomInfo getChatRoomInfo(    ID roomID){
      return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
    }
    public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
      IChatRoomContainer chatContainer=null;
      try {
        chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
      }
 catch (      IDInstantiationException e) {
        ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
        newExcept.setStackTrace(e.getStackTrace());
        throw newExcept;
      }
      return chatContainer;
    }
    public IRoomInfo[] getChatRoomsInfo(){
      ID[] chatRooms=getChatRooms();
      if (chatRooms == null)       return null;
      IRoomInfo[] res=new IRoomInfo[chatRooms.length];
      int count=0;
      for (int i=0; i < chatRooms.length; i++) {
        IRoomInfo infoResult=getChatRoomInfo(chatRooms[i]);
        if (infoResult != null) {
          res[count++]=infoResult;
        }
      }
      IRoomInfo[] results=new IRoomInfo[count];
      for (int i=0; i < count; i++) {
        results[i]=res[i];
      }
      return results;
    }
  }
;
}","public IChatRoomManager getChatRoomManager(){
  return new IChatRoomManager(){
    public ID[] getChatRooms(){
      return XMPPClientSOContainer.this.getChatRooms();
    }
    public IRoomInfo getChatRoomInfo(    ID roomID){
      return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
    }
    public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
      IChatRoomContainer chatContainer=null;
      try {
        chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
      }
 catch (      IDInstantiationException e) {
        ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
        newExcept.setStackTrace(e.getStackTrace());
        throw newExcept;
      }
      chats.add(chatContainer);
      return chatContainer;
    }
    public IRoomInfo[] getChatRoomsInfo(){
      ID[] chatRooms=getChatRooms();
      if (chatRooms == null)       return null;
      IRoomInfo[] res=new IRoomInfo[chatRooms.length];
      int count=0;
      for (int i=0; i < chatRooms.length; i++) {
        IRoomInfo infoResult=getChatRoomInfo(chatRooms[i]);
        if (infoResult != null) {
          res[count++]=infoResult;
        }
      }
      IRoomInfo[] results=new IRoomInfo[count];
      for (int i=0; i < count; i++) {
        results[i]=res[i];
      }
      return results;
    }
  }
;
}",0.9886685552407932
95178,"public Object getAdapter(Class clazz){
  if (clazz.equals(IPresenceContainer.class)) {
    return new IPresenceContainer(){
      public void addPresenceListener(      IPresenceListener listener){
        sharedObject.addPresenceListener(listener);
      }
      public void addMessageListener(      IMessageListener listener){
        sharedObject.addMessageListener(listener);
      }
      public IMessageSender getMessageSender(){
        return new IMessageSender(){
          public void sendMessage(          ID fromID,          ID toID,          Type type,          String subject,          String message){
            try {
              XMPPClientSOContainer.this.sendMessage(toID,message);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ message,e);
            }
          }
        }
;
      }
      public IPresenceSender getPresenceSender(){
        return new IPresenceSender(){
          public void sendPresenceUpdate(          ID fromID,          ID toID,          IPresence presence){
            try {
              Presence newPresence=makePresenceFromIPresence(presence);
              XMPPClientSOContainer.this.sendPresenceUpdate(toID,newPresence);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ presence,e);
            }
          }
          public void sendRosterAdd(          ID fromID,          String user,          String name,          String[] groups){
            try {
              XMPPClientSOContainer.this.sendRosterAdd(user,name,groups);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
          public void sendRosterRemove(          ID fromID,          ID userID){
            try {
              if (userID == null)               return;
              XMPPClientSOContainer.this.sendRosterRemove(userID.getName());
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
        }
;
      }
      public IAccountManager getAccountManager(){
        return new IAccountManager(){
          public void changePassword(          String newpassword) throws ECFException {
            sharedObject.changePassword(newpassword);
          }
          public void createAccount(          String username,          String password,          Map attributes) throws ECFException {
            sharedObject.createAccount(username,password,attributes);
          }
          public void deleteAccount() throws ECFException {
            sharedObject.deleteAccount();
          }
          public String getAccountInstructions(){
            return sharedObject.getAccountInstructions();
          }
          public String[] getAccountAttributeNames(){
            return sharedObject.getAccountAttributeNames();
          }
          public Object getAccountAttribute(          String name){
            return sharedObject.getAccountAttribute(name);
          }
          public boolean supportsCreation(){
            return sharedObject.supportsCreation();
          }
        }
;
      }
      public void addSubscribeListener(      ISubscribeListener listener){
        sharedObject.addSubscribeListener(listener);
      }
      public IChatRoomManager getChatRoomManager(){
        return new IChatRoomManager(){
          public ID[] getChatRooms(){
            return XMPPClientSOContainer.this.getChatRooms();
          }
          public IRoomInfo getChatRoomInfo(          ID roomID){
            return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
          }
          public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
            IChatRoomContainer chatContainer=null;
            try {
              chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
            }
 catch (            IDInstantiationException e) {
              ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
              newExcept.setStackTrace(e.getStackTrace());
              throw newExcept;
            }
            return chatContainer;
          }
          public IRoomInfo[] getChatRoomsInfo(){
            ID[] chatRooms=getChatRooms();
            if (chatRooms == null)             return null;
            IRoomInfo[] res=new IRoomInfo[chatRooms.length];
            int count=0;
            for (int i=0; i < chatRooms.length; i++) {
              IRoomInfo infoResult=getChatRoomInfo(chatRooms[i]);
              if (infoResult != null) {
                res[count++]=infoResult;
              }
            }
            IRoomInfo[] results=new IRoomInfo[count];
            for (int i=0; i < count; i++) {
              results[i]=res[i];
            }
            return results;
          }
        }
;
      }
    }
;
  }
 else {
    return super.getAdapter(clazz);
  }
}","public Object getAdapter(Class clazz){
  if (clazz.equals(IPresenceContainer.class)) {
    return new IPresenceContainer(){
      public void addPresenceListener(      IPresenceListener listener){
        sharedObject.addPresenceListener(listener);
      }
      public void addMessageListener(      IMessageListener listener){
        sharedObject.addMessageListener(listener);
      }
      public IMessageSender getMessageSender(){
        return new IMessageSender(){
          public void sendMessage(          ID fromID,          ID toID,          Type type,          String subject,          String message){
            try {
              XMPPClientSOContainer.this.sendMessage(toID,message);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ message,e);
            }
          }
        }
;
      }
      public IPresenceSender getPresenceSender(){
        return new IPresenceSender(){
          public void sendPresenceUpdate(          ID fromID,          ID toID,          IPresence presence){
            try {
              Presence newPresence=makePresenceFromIPresence(presence);
              XMPPClientSOContainer.this.sendPresenceUpdate(toID,newPresence);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ presence,e);
            }
          }
          public void sendRosterAdd(          ID fromID,          String user,          String name,          String[] groups){
            try {
              XMPPClientSOContainer.this.sendRosterAdd(user,name,groups);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
          public void sendRosterRemove(          ID fromID,          ID userID){
            try {
              if (userID == null)               return;
              XMPPClientSOContainer.this.sendRosterRemove(userID.getName());
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
        }
;
      }
      public IAccountManager getAccountManager(){
        return new IAccountManager(){
          public void changePassword(          String newpassword) throws ECFException {
            sharedObject.changePassword(newpassword);
          }
          public void createAccount(          String username,          String password,          Map attributes) throws ECFException {
            sharedObject.createAccount(username,password,attributes);
          }
          public void deleteAccount() throws ECFException {
            sharedObject.deleteAccount();
          }
          public String getAccountInstructions(){
            return sharedObject.getAccountInstructions();
          }
          public String[] getAccountAttributeNames(){
            return sharedObject.getAccountAttributeNames();
          }
          public Object getAccountAttribute(          String name){
            return sharedObject.getAccountAttribute(name);
          }
          public boolean supportsCreation(){
            return sharedObject.supportsCreation();
          }
        }
;
      }
      public void addSubscribeListener(      ISubscribeListener listener){
        sharedObject.addSubscribeListener(listener);
      }
      public IChatRoomManager getChatRoomManager(){
        return new IChatRoomManager(){
          public ID[] getChatRooms(){
            return XMPPClientSOContainer.this.getChatRooms();
          }
          public IRoomInfo getChatRoomInfo(          ID roomID){
            return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
          }
          public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
            IChatRoomContainer chatContainer=null;
            try {
              chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
            }
 catch (            IDInstantiationException e) {
              ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
              newExcept.setStackTrace(e.getStackTrace());
              throw newExcept;
            }
            chats.add(chatContainer);
            return chatContainer;
          }
          public IRoomInfo[] getChatRoomsInfo(){
            ID[] chatRooms=getChatRooms();
            if (chatRooms == null)             return null;
            IRoomInfo[] res=new IRoomInfo[chatRooms.length];
            int count=0;
            for (int i=0; i < chatRooms.length; i++) {
              IRoomInfo infoResult=getChatRoomInfo(chatRooms[i]);
              if (infoResult != null) {
                res[count++]=infoResult;
              }
            }
            IRoomInfo[] results=new IRoomInfo[count];
            for (int i=0; i < count; i++) {
              results[i]=res[i];
            }
            return results;
          }
        }
;
      }
    }
;
  }
 else {
    return super.getAdapter(clazz);
  }
}",0.9962554197871502
95179,"public void dispose(){
  if (sharedObject != null) {
    getSharedObjectManager().removeSharedObject(sharedObjectID);
  }
  sharedObjectID=null;
  sharedObject=null;
  messageSender=null;
  super.dispose();
}","public void dispose(){
  if (sharedObject != null) {
    getSharedObjectManager().removeSharedObject(sharedObjectID);
  }
  sharedObjectID=null;
  sharedObject=null;
  messageSender=null;
  disposeChats();
  super.dispose();
}",0.9585253456221198
95180,"public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
  IChatRoomContainer chatContainer=null;
  try {
    chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
  }
 catch (  IDInstantiationException e) {
    ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
    newExcept.setStackTrace(e.getStackTrace());
    throw newExcept;
  }
  return chatContainer;
}","public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
  IChatRoomContainer chatContainer=null;
  try {
    chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
  }
 catch (  IDInstantiationException e) {
    ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
    newExcept.setStackTrace(e.getStackTrace());
    throw newExcept;
  }
  chats.add(chatContainer);
  return chatContainer;
}",0.9725490196078432
95181,"protected void removeRoomView(RoomWithAView roomView){
  chatRooms.remove(roomView);
}","protected void removeRoomView(RoomWithAView roomView){
  chatRooms.remove(roomView.getID());
}",0.9555555555555556
95182,"protected static void displayURL(String url,boolean external){
  try {
    IBrowser browser=BrowserManager.getInstance().createBrowser(external);
    browser.displayURL(url);
  }
 catch (  Exception e) {
    try {
      Shell[] shells=Display.getCurrent().getShells();
      if (shells != null && shells.length > 0) {
        MessageDialog.openError(shells[0],""String_Node_Str"",""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
    }
    ClientPlugin.log(""String_Node_Str"" + url,e);
  }
}","protected static void displayURL(String url,boolean external){
  IBrowser browser=null;
  Shell[] shells=Display.getCurrent().getShells();
  try {
    browser=BrowserManager.getInstance().createBrowser(external);
  }
 catch (  SWTError swterror) {
    try {
      if (shells != null && shells.length > 0) {
        MessageDialog.openError(shells[0],""String_Node_Str"",""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
    }
    ClientPlugin.log(""String_Node_Str"" + url,swterror);
    return;
  }
  try {
    browser.displayURL(url);
  }
 catch (  Exception e) {
    try {
      if (shells != null && shells.length > 0) {
        MessageDialog.openError(shells[0],""String_Node_Str"",""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
    }
    ClientPlugin.log(""String_Node_Str"" + url,e);
  }
catch (  SWTError swterror) {
  }
}",0.6439169139465876
95183,"public static void showURL(final String url,final boolean considerInternal){
  Display.getDefault().asyncExec(new Runnable(){
    public void run(){
      try {
        displayURL(url,considerInternal);
      }
 catch (      Exception e) {
        try {
          Runtime.getRuntime().exec(getBrowserExec(null,url));
        }
 catch (        Exception e1) {
          return;
        }
      }
    }
  }
);
}","public static void showURL(final String url,final boolean considerInternal){
  Display.getDefault().asyncExec(new Runnable(){
    public void run(){
      displayURL(url,considerInternal);
    }
  }
);
}",0.6535947712418301
95184,"public void run(){
  try {
    displayURL(url,considerInternal);
  }
 catch (  Exception e) {
    try {
      Runtime.getRuntime().exec(getBrowserExec(null,url));
    }
 catch (    Exception e1) {
      return;
    }
  }
}","public void run(){
  displayURL(url,considerInternal);
}",0.4028776978417266
95185,"protected static void displayURL(String url,boolean external){
  IBrowser browser=BrowserManager.getInstance().createBrowser(external);
  try {
    browser.displayURL(url);
  }
 catch (  Exception e) {
    ClientPlugin.log(""String_Node_Str"" + url,e);
  }
}","protected static void displayURL(String url,boolean external){
  try {
    IBrowser browser=BrowserManager.getInstance().createBrowser(external);
    browser.displayURL(url);
  }
 catch (  Exception e) {
    try {
      Shell[] shells=Display.getCurrent().getShells();
      if (shells != null && shells.length > 0) {
        MessageDialog.openError(shells[0],""String_Node_Str"",""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
    }
    ClientPlugin.log(""String_Node_Str"" + url,e);
  }
}",0.6164021164021164
95186,"/** 
 * Create a new container instance, and connect to a remote server or group.
 * @param containerType the container type used to create the new container instance.  Must not be null.
 * @param uri the uri that is used to create a targetID for connection.  Must not be null.
 * @param nickname an optional String nickname.  May be null.
 * @param connectData optional connection data.  May be null.
 * @param resource the resource that this container instance is associated with.  Must not be null.
 * @throws Exception
 */
public void createAndConnectClient(final String containerType,String uri,String nickname,final Object connectData,final IResource resource) throws Exception {
  final IContainer newClient=ContainerFactory.getDefault().makeContainer(containerType);
  Namespace targetNamespace=newClient.getConnectNamespace();
  ID targetID=IDFactory.getDefault().makeID(targetNamespace,uri);
  String username=setupUsername(targetID,nickname);
  final ClientEntry newClientEntry=new ClientEntry(containerType,newClient);
  IPresenceContainer pc=(IPresenceContainer)newClient.getAdapter(IPresenceContainer.class);
  if (pc != null) {
    presenceContainerUI=new PresenceContainerUI(pc);
    presenceContainerUI.setup(newClient,targetID,username);
  }
 else {
    ISharedObjectContainer sharedObjectContainer=(ISharedObjectContainer)newClient.getAdapter(ISharedObjectContainer.class);
    if (sharedObjectContainer != null) {
      new SharedObjectContainerUI(this,sharedObjectContainer).setup(sharedObjectContainer,newClientEntry,resource,username);
    }
  }
  try {
    newClient.connect(targetID,getJoinContext(username,connectData));
  }
 catch (  ContainerConnectException e) {
    EclipseCollabSharedObject so=newClientEntry.getObject();
    if (so != null)     so.destroySelf();
    throw e;
  }
  if (presenceContainerUI != null) {
    try {
      presenceContainerUI.connectToFirstChatRoom();
    }
 catch (    ECFException e1) {
      System.err.println(""String_Node_Str"");
      e1.printStackTrace(System.err);
    }
  }
  addClientForResource(newClientEntry,resource);
}","/** 
 * Create a new container instance, and connect to a remote server or group.
 * @param containerType the container type used to create the new container instance.  Must not be null.
 * @param uri the uri that is used to create a targetID for connection.  Must not be null.
 * @param nickname an optional String nickname.  May be null.
 * @param connectData optional connection data.  May be null.
 * @param resource the resource that this container instance is associated with.  Must not be null.
 * @throws Exception
 */
public void createAndConnectClient(final String containerType,String uri,String nickname,final Object connectData,final IResource resource) throws Exception {
  final IContainer newClient=ContainerFactory.getDefault().makeContainer(containerType);
  Namespace targetNamespace=newClient.getConnectNamespace();
  ID targetID=IDFactory.getDefault().makeID(targetNamespace,uri);
  String username=setupUsername(targetID,nickname);
  final ClientEntry newClientEntry=new ClientEntry(containerType,newClient);
  IPresenceContainer pc=(IPresenceContainer)newClient.getAdapter(IPresenceContainer.class);
  if (pc != null) {
    presenceContainerUI=new PresenceContainerUI(pc);
    presenceContainerUI.setup(newClient,targetID,username);
  }
 else {
    ISharedObjectContainer sharedObjectContainer=(ISharedObjectContainer)newClient.getAdapter(ISharedObjectContainer.class);
    if (sharedObjectContainer != null) {
      new SharedObjectContainerUI(this,sharedObjectContainer).setup(sharedObjectContainer,newClientEntry,resource,username);
    }
  }
  try {
    newClient.connect(targetID,getJoinContext(username,connectData));
  }
 catch (  ContainerConnectException e) {
    EclipseCollabSharedObject so=newClientEntry.getObject();
    if (so != null)     so.destroySelf();
    throw e;
  }
  addClientForResource(newClientEntry,resource);
}",0.9420693144447256
95187,"protected void handleChatMessage(Message mess) throws IOException {
  SOWrapper wrap=getSharedObjectWrapper(sharedObjectID);
  if (mess.getExtensions().hasNext()) {
    handleChatMessageWithExtension(mess);
  }
 else {
    if (wrap != null) {
      wrap.deliverEvent(new MessageEvent(mess));
    }
  }
}","protected void handleChatMessage(Message mess) throws IOException {
  SOWrapper wrap=getSharedObjectWrapper(sharedObjectID);
  if (wrap != null) {
    wrap.deliverEvent(new MessageEvent(mess));
  }
}",0.7928286852589641
95188,"public void handleRosterEntry(ID groupID,IRosterEntry entry){
  if (entry == null)   return;
  ViewContentProvider vcp=(ViewContentProvider)viewer.getContentProvider();
  if (vcp != null) {
    if (entry.getInterestType() == IRosterEntry.InterestType.REMOVE || entry.getInterestType() == IRosterEntry.InterestType.NONE) {
      vcp.removeRosterEntry(entry.getUserID());
    }
 else     vcp.addEntry(entry);
    refreshView();
  }
}","public void handleRosterEntry(ID groupID,IRosterEntry entry){
  System.out.println(""String_Node_Str"" + groupID + ""String_Node_Str""+ entry+ ""String_Node_Str"");
  if (entry == null)   return;
  ViewContentProvider vcp=(ViewContentProvider)viewer.getContentProvider();
  if (vcp != null) {
    if (entry.getInterestType() == IRosterEntry.InterestType.REMOVE || entry.getInterestType() == IRosterEntry.InterestType.NONE) {
      vcp.removeRosterEntry(entry.getUserID());
    }
 else     vcp.addEntry(entry);
    refreshView();
  }
}",0.8988529718456726
95189,"public void handlePresence(ID groupID,ID userID,IPresence presence){
  IRosterEntry entry=new RosterEntry(groupID,userID,null,presence);
  handleRosterEntry(groupID,entry);
}","public void handlePresence(ID groupID,ID userID,IPresence presence){
  System.out.println(""String_Node_Str"" + groupID + ""String_Node_Str""+ userID+ ""String_Node_Str""+ presence+ ""String_Node_Str"");
  IRosterEntry entry=new RosterEntry(groupID,userID,null,presence);
  handleRosterEntry(groupID,entry);
}",0.7326315789473684
95190,"public IChatRoomManager getChatRoomManager(){
  return new IChatRoomManager(){
    public ID[] getChatRooms(){
      return XMPPClientSOContainer.this.getChatRooms();
    }
    public IRoomInfo getChatRoomInfo(    ID roomID){
      return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
    }
    public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
      IChatRoomContainer chatContainer=null;
      try {
        chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
      }
 catch (      IDInstantiationException e) {
        ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
        newExcept.setStackTrace(e.getStackTrace());
        throw newExcept;
      }
      return chatContainer;
    }
    public IRoomInfo[] getChatRoomsInfo(){
      ID[] chatRooms=getChatRooms();
      if (chatRooms == null)       return null;
      IRoomInfo[] res=new IRoomInfo[chatRooms.length];
      for (int i=0; i < chatRooms.length; i++) {
        res[i]=getChatRoomInfo(chatRooms[i]);
      }
      return res;
    }
  }
;
}","public IChatRoomManager getChatRoomManager(){
  return new IChatRoomManager(){
    public ID[] getChatRooms(){
      return XMPPClientSOContainer.this.getChatRooms();
    }
    public IRoomInfo getChatRoomInfo(    ID roomID){
      return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
    }
    public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
      IChatRoomContainer chatContainer=null;
      try {
        chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
      }
 catch (      IDInstantiationException e) {
        ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
        newExcept.setStackTrace(e.getStackTrace());
        throw newExcept;
      }
      return chatContainer;
    }
    public IRoomInfo[] getChatRoomsInfo(){
      ID[] chatRooms=getChatRooms();
      if (chatRooms == null)       return null;
      IRoomInfo[] res=new IRoomInfo[chatRooms.length];
      int count=0;
      for (int i=0; i < chatRooms.length; i++) {
        IRoomInfo infoResult=getChatRoomInfo(chatRooms[i]);
        if (infoResult != null) {
          res[count++]=infoResult;
        }
      }
      IRoomInfo[] results=new IRoomInfo[count];
      for (int i=0; i < count; i++) {
        results[i]=res[i];
      }
      return results;
    }
  }
;
}",0.8688845401174168
95191,"public Object getAdapter(Class clazz){
  if (clazz.equals(IPresenceContainer.class)) {
    return new IPresenceContainer(){
      public void addPresenceListener(      IPresenceListener listener){
        sharedObject.addPresenceListener(listener);
      }
      public void addMessageListener(      IMessageListener listener){
        sharedObject.addMessageListener(listener);
      }
      public IMessageSender getMessageSender(){
        return new IMessageSender(){
          public void sendMessage(          ID fromID,          ID toID,          Type type,          String subject,          String message){
            try {
              XMPPClientSOContainer.this.sendMessage(toID,message);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ message,e);
            }
          }
        }
;
      }
      public IPresenceSender getPresenceSender(){
        return new IPresenceSender(){
          public void sendPresenceUpdate(          ID fromID,          ID toID,          IPresence presence){
            try {
              Presence newPresence=makePresenceFromIPresence(presence);
              XMPPClientSOContainer.this.sendPresenceUpdate(toID,newPresence);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ presence,e);
            }
          }
          public void sendRosterAdd(          ID fromID,          String user,          String name,          String[] groups){
            try {
              XMPPClientSOContainer.this.sendRosterAdd(user,name,groups);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
          public void sendRosterRemove(          ID fromID,          ID userID){
            try {
              if (userID == null)               return;
              XMPPClientSOContainer.this.sendRosterRemove(userID.getName());
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
        }
;
      }
      public IAccountManager getAccountManager(){
        return new IAccountManager(){
          public void changePassword(          String newpassword) throws ECFException {
            sharedObject.changePassword(newpassword);
          }
          public void createAccount(          String username,          String password,          Map attributes) throws ECFException {
            sharedObject.createAccount(username,password,attributes);
          }
          public void deleteAccount() throws ECFException {
            sharedObject.deleteAccount();
          }
          public String getAccountInstructions(){
            return sharedObject.getAccountInstructions();
          }
          public String[] getAccountAttributeNames(){
            return sharedObject.getAccountAttributeNames();
          }
          public Object getAccountAttribute(          String name){
            return sharedObject.getAccountAttribute(name);
          }
          public boolean supportsCreation(){
            return sharedObject.supportsCreation();
          }
        }
;
      }
      public void addSubscribeListener(      ISubscribeListener listener){
        sharedObject.addSubscribeListener(listener);
      }
      public IChatRoomManager getChatRoomManager(){
        return new IChatRoomManager(){
          public ID[] getChatRooms(){
            return XMPPClientSOContainer.this.getChatRooms();
          }
          public IRoomInfo getChatRoomInfo(          ID roomID){
            return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
          }
          public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
            IChatRoomContainer chatContainer=null;
            try {
              chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
            }
 catch (            IDInstantiationException e) {
              ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
              newExcept.setStackTrace(e.getStackTrace());
              throw newExcept;
            }
            return chatContainer;
          }
          public IRoomInfo[] getChatRoomsInfo(){
            ID[] chatRooms=getChatRooms();
            if (chatRooms == null)             return null;
            IRoomInfo[] res=new IRoomInfo[chatRooms.length];
            for (int i=0; i < chatRooms.length; i++) {
              res[i]=getChatRoomInfo(chatRooms[i]);
            }
            return res;
          }
        }
;
      }
    }
;
  }
 else {
    return super.getAdapter(clazz);
  }
}","public Object getAdapter(Class clazz){
  if (clazz.equals(IPresenceContainer.class)) {
    return new IPresenceContainer(){
      public void addPresenceListener(      IPresenceListener listener){
        sharedObject.addPresenceListener(listener);
      }
      public void addMessageListener(      IMessageListener listener){
        sharedObject.addMessageListener(listener);
      }
      public IMessageSender getMessageSender(){
        return new IMessageSender(){
          public void sendMessage(          ID fromID,          ID toID,          Type type,          String subject,          String message){
            try {
              XMPPClientSOContainer.this.sendMessage(toID,message);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ message,e);
            }
          }
        }
;
      }
      public IPresenceSender getPresenceSender(){
        return new IPresenceSender(){
          public void sendPresenceUpdate(          ID fromID,          ID toID,          IPresence presence){
            try {
              Presence newPresence=makePresenceFromIPresence(presence);
              XMPPClientSOContainer.this.sendPresenceUpdate(toID,newPresence);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"" + toID + ""String_Node_Str""+ presence,e);
            }
          }
          public void sendRosterAdd(          ID fromID,          String user,          String name,          String[] groups){
            try {
              XMPPClientSOContainer.this.sendRosterAdd(user,name,groups);
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
          public void sendRosterRemove(          ID fromID,          ID userID){
            try {
              if (userID == null)               return;
              XMPPClientSOContainer.this.sendRosterRemove(userID.getName());
            }
 catch (            IOException e) {
              dumpStack(""String_Node_Str"",e);
            }
          }
        }
;
      }
      public IAccountManager getAccountManager(){
        return new IAccountManager(){
          public void changePassword(          String newpassword) throws ECFException {
            sharedObject.changePassword(newpassword);
          }
          public void createAccount(          String username,          String password,          Map attributes) throws ECFException {
            sharedObject.createAccount(username,password,attributes);
          }
          public void deleteAccount() throws ECFException {
            sharedObject.deleteAccount();
          }
          public String getAccountInstructions(){
            return sharedObject.getAccountInstructions();
          }
          public String[] getAccountAttributeNames(){
            return sharedObject.getAccountAttributeNames();
          }
          public Object getAccountAttribute(          String name){
            return sharedObject.getAccountAttribute(name);
          }
          public boolean supportsCreation(){
            return sharedObject.supportsCreation();
          }
        }
;
      }
      public void addSubscribeListener(      ISubscribeListener listener){
        sharedObject.addSubscribeListener(listener);
      }
      public IChatRoomManager getChatRoomManager(){
        return new IChatRoomManager(){
          public ID[] getChatRooms(){
            return XMPPClientSOContainer.this.getChatRooms();
          }
          public IRoomInfo getChatRoomInfo(          ID roomID){
            return XMPPClientSOContainer.this.getChatRoomInfo(roomID);
          }
          public IChatRoomContainer makeChatRoomContainer() throws ContainerInstantiationException {
            IChatRoomContainer chatContainer=null;
            try {
              chatContainer=new XMPPGroupChatSOContainer(sharedObject.getConnection(),getConnectNamespace());
            }
 catch (            IDInstantiationException e) {
              ContainerInstantiationException newExcept=new ContainerInstantiationException(""String_Node_Str"" + getID(),e);
              newExcept.setStackTrace(e.getStackTrace());
              throw newExcept;
            }
            return chatContainer;
          }
          public IRoomInfo[] getChatRoomsInfo(){
            ID[] chatRooms=getChatRooms();
            if (chatRooms == null)             return null;
            IRoomInfo[] res=new IRoomInfo[chatRooms.length];
            int count=0;
            for (int i=0; i < chatRooms.length; i++) {
              IRoomInfo infoResult=getChatRoomInfo(chatRooms[i]);
              if (infoResult != null) {
                res[count++]=infoResult;
              }
            }
            IRoomInfo[] results=new IRoomInfo[count];
            for (int i=0; i < count; i++) {
              results[i]=res[i];
            }
            return results;
          }
        }
;
      }
    }
;
  }
 else {
    return super.getAdapter(clazz);
  }
}",0.9654961832061068
95192,"public IRoomInfo[] getChatRoomsInfo(){
  ID[] chatRooms=getChatRooms();
  if (chatRooms == null)   return null;
  IRoomInfo[] res=new IRoomInfo[chatRooms.length];
  for (int i=0; i < chatRooms.length; i++) {
    res[i]=getChatRoomInfo(chatRooms[i]);
  }
  return res;
}","public IRoomInfo[] getChatRoomsInfo(){
  ID[] chatRooms=getChatRooms();
  if (chatRooms == null)   return null;
  IRoomInfo[] res=new IRoomInfo[chatRooms.length];
  int count=0;
  for (int i=0; i < chatRooms.length; i++) {
    IRoomInfo infoResult=getChatRoomInfo(chatRooms[i]);
    if (infoResult != null) {
      res[count++]=infoResult;
    }
  }
  IRoomInfo[] results=new IRoomInfo[count];
  for (int i=0; i < count; i++) {
    results[i]=res[i];
  }
  return results;
}",0.648721399730821
95193,"protected String fixHostname(String host,String domain){
  String subHost=host;
  int dotIndex=host.indexOf('.');
  if (dotIndex > 0)   subHost=host.substring(0,dotIndex);
  if (domain == null)   domain=DOMAIN_DEFAULT;
  return domain + ""String_Node_Str"" + subHost;
}","protected String fixHostname(String host,String domain){
  if (domain == null)   domain=DOMAIN_DEFAULT;
  return domain + ""String_Node_Str"" + host;
}",0.7115384615384616
95194,"public void run(){
  Thread me=Thread.currentThread();
  try {
    Thread.sleep(pingStartWait);
  }
 catch (  InterruptedException e) {
    return;
  }
  while (!queue.isStopped()) {
    try {
      if (me.isInterrupted())       break;
      Thread.sleep(keepAlive / 2);
      if (me.isInterrupted())       break;
synchronized (outputStream) {
        if (System.currentTimeMillis() >= nextPingTime) {
          waitForPing=true;
          sendIt(ping);
          if (waitForPing) {
            try {
              outputStream.wait(keepAlive / 2);
            }
 catch (            InterruptedException e) {
            }
          }
          if (waitForPing) {
            throw new IOException(getAddressPort() + ""String_Node_Str"");
          }
        }
      }
    }
 catch (    Exception e) {
      if (isClosing) {
        dumpStack(""String_Node_Str"",e);
synchronized (Client.this) {
          Client.this.notifyAll();
        }
      }
 else {
        dumpStack(""String_Node_Str"",e);
        if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
          handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
        }
      }
      break;
    }
  }
  trace(""String_Node_Str"");
}","public void run(){
  Thread me=Thread.currentThread();
  try {
    Thread.sleep(pingStartWait);
  }
 catch (  InterruptedException e) {
    return;
  }
  while (!queue.isStopped()) {
    try {
      if (me.isInterrupted())       break;
      Thread.sleep(keepAlive / 2);
      if (me.isInterrupted())       break;
synchronized (pingLock) {
        if (System.currentTimeMillis() >= nextPingTime) {
          waitForPing=true;
          sendIt(ping);
          if (waitForPing) {
            try {
              pingLock.wait(keepAlive / 2);
            }
 catch (            InterruptedException e) {
              dumpStack(""String_Node_Str"",e);
              return;
            }
          }
          if (waitForPing) {
            throw new IOException(getAddressPort() + ""String_Node_Str"");
          }
        }
      }
    }
 catch (    Exception e) {
      if (isClosing) {
        dumpStack(""String_Node_Str"",e);
synchronized (Client.this) {
          Client.this.notifyAll();
        }
      }
 else {
        dumpStack(""String_Node_Str"",e);
        if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
          handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
        }
      }
      break;
    }
  }
  trace(""String_Node_Str"");
}",0.9573122529644268
95195,"private void receiveResp(){
synchronized (outputStream) {
    waitForPing=false;
    nextPingTime=System.currentTimeMillis() + (keepAlive / 2);
    outputStream.notifyAll();
  }
}","private void receiveResp(){
synchronized (pingLock) {
    waitForPing=false;
    nextPingTime=System.currentTimeMillis() + (keepAlive / 2);
  }
}",0.8518518518518519
95196,"private Thread setupPing(){
  trace(""String_Node_Str"");
  final int pingStartWait=(new Random()).nextInt(keepAlive / 2);
  return new Thread(new Runnable(){
    public void run(){
      Thread me=Thread.currentThread();
      try {
        Thread.sleep(pingStartWait);
      }
 catch (      InterruptedException e) {
        return;
      }
      while (!queue.isStopped()) {
        try {
          if (me.isInterrupted())           break;
          Thread.sleep(keepAlive / 2);
          if (me.isInterrupted())           break;
synchronized (outputStream) {
            if (System.currentTimeMillis() >= nextPingTime) {
              waitForPing=true;
              sendIt(ping);
              if (waitForPing) {
                try {
                  outputStream.wait(keepAlive / 2);
                }
 catch (                InterruptedException e) {
                }
              }
              if (waitForPing) {
                throw new IOException(getAddressPort() + ""String_Node_Str"");
              }
            }
          }
        }
 catch (        Exception e) {
          if (isClosing) {
            dumpStack(""String_Node_Str"",e);
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            dumpStack(""String_Node_Str"",e);
            if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      trace(""String_Node_Str"");
    }
  }
,getLocalID() + ""String_Node_Str"" + getAddressPort());
}","private Thread setupPing(){
  trace(""String_Node_Str"");
  final int pingStartWait=(new Random()).nextInt(keepAlive / 2);
  return new Thread(new Runnable(){
    public void run(){
      Thread me=Thread.currentThread();
      try {
        Thread.sleep(pingStartWait);
      }
 catch (      InterruptedException e) {
        return;
      }
      while (!queue.isStopped()) {
        try {
          if (me.isInterrupted())           break;
          Thread.sleep(keepAlive / 2);
          if (me.isInterrupted())           break;
synchronized (pingLock) {
            if (System.currentTimeMillis() >= nextPingTime) {
              waitForPing=true;
              sendIt(ping);
              if (waitForPing) {
                try {
                  pingLock.wait(keepAlive / 2);
                }
 catch (                InterruptedException e) {
                  dumpStack(""String_Node_Str"",e);
                  return;
                }
              }
              if (waitForPing) {
                throw new IOException(getAddressPort() + ""String_Node_Str"");
              }
            }
          }
        }
 catch (        Exception e) {
          if (isClosing) {
            dumpStack(""String_Node_Str"",e);
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            dumpStack(""String_Node_Str"",e);
            if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      trace(""String_Node_Str"");
    }
  }
,getLocalID() + ""String_Node_Str"" + getAddressPort());
}",0.9653731343283584
95197,"private void sendIt(Serializable snd) throws IOException {
  trace(""String_Node_Str"" + snd + ""String_Node_Str"");
synchronized (outputStream) {
    outputStream.writeObject(snd);
    outputStream.flush();
    nextPingTime=System.currentTimeMillis() + (keepAlive / 2);
  }
}","private void sendIt(Serializable snd) throws IOException {
  trace(""String_Node_Str"" + snd + ""String_Node_Str"");
  nextPingTime=System.currentTimeMillis() + (keepAlive / 2);
  outputStream.writeObject(snd);
  outputStream.flush();
}",0.6825396825396826
95198,"private Thread getSendThread(){
  Thread aThread=new Thread(new Runnable(){
    public void run(){
      int msgCount=0;
      Thread me=Thread.currentThread();
      for (; ; ) {
        if (me.isInterrupted())         break;
        Serializable aMsg=(Serializable)queue.peekQueue();
        if (me.isInterrupted() || aMsg == null)         break;
        try {
          trace(""String_Node_Str"" + aMsg);
          sendIt(aMsg);
          queue.removeHead();
          if (msgCount > maxMsg) {
synchronized (outputStream) {
              outputStream.reset();
            }
            msgCount=0;
          }
 else           msgCount++;
        }
 catch (        IOException e) {
          if (isClosing) {
            dumpStack(""String_Node_Str"",e);
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            dumpStack(""String_Node_Str"",e);
            if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      trace(""String_Node_Str"");
    }
  }
,getLocalID() + ""String_Node_Str"" + getAddressPort());
  aThread.setPriority(SNDR_PRIORITY);
  return aThread;
}","private Thread getSendThread(){
  Thread aThread=new Thread(new Runnable(){
    public void run(){
      int msgCount=0;
      Thread me=Thread.currentThread();
      for (; ; ) {
        if (me.isInterrupted())         break;
        Serializable aMsg=(Serializable)queue.peekQueue();
        if (me.isInterrupted() || aMsg == null)         break;
        try {
          sendIt(aMsg);
          queue.removeHead();
          if (msgCount > maxMsg) {
            outputStream.reset();
            msgCount=0;
          }
 else           msgCount++;
        }
 catch (        IOException e) {
          if (isClosing) {
            dumpStack(""String_Node_Str"",e);
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            dumpStack(""String_Node_Str"",e);
            if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      trace(""String_Node_Str"");
    }
  }
,getLocalID() + ""String_Node_Str"" + getAddressPort());
  aThread.setPriority(SNDR_PRIORITY);
  return aThread;
}",0.947579031612645
95199,"public synchronized Object connect(ID remote,Object data,int timeout) throws IOException {
  trace(""String_Node_Str"" + remote + ""String_Node_Str""+ data+ ""String_Node_Str""+ timeout+ ""String_Node_Str"");
  if (socket != null)   throw new ConnectException(""String_Node_Str"" + getAddressPort());
  URI anURI=null;
  try {
    anURI=remote.toURI();
  }
 catch (  URISyntaxException e) {
    throw new IOException(""String_Node_Str"");
  }
  SocketFactory fact=SocketFactory.getSocketFactory();
  if (fact == null) {
    fact=SocketFactory.getDefaultSocketFactory();
  }
  Socket s=fact.createSocket(anURI.getHost(),anURI.getPort(),timeout);
  setSocket(s);
  outputStream=new ExObjectOutputStream(new BufferedOutputStream(s.getOutputStream()),false);
  outputStream.flush();
  inputStream=new ExObjectInputStream(s.getInputStream(),false);
  trace(""String_Node_Str"" + anURI);
  sendIt(new ConnectRequestMessage(anURI,(Serializable)data));
  ConnectResultMessage res=null;
  res=(ConnectResultMessage)readObject();
  trace(""String_Node_Str"" + res);
  setupThreads();
  Object ret=res.getData();
  trace(""String_Node_Str"" + ret);
  return ret;
}","public synchronized Object connect(ID remote,Object data,int timeout) throws IOException {
  trace(""String_Node_Str"" + remote + ""String_Node_Str""+ data+ ""String_Node_Str""+ timeout+ ""String_Node_Str"");
  if (socket != null)   throw new ConnectException(""String_Node_Str"" + getAddressPort());
  URI anURI=null;
  try {
    anURI=remote.toURI();
  }
 catch (  URISyntaxException e) {
    IOException except=new IOException(""String_Node_Str"" + remote);
    except.setStackTrace(e.getStackTrace());
    throw except;
  }
  SocketFactory fact=SocketFactory.getSocketFactory();
  if (fact == null) {
    fact=SocketFactory.getDefaultSocketFactory();
  }
  Socket s=fact.createSocket(anURI.getHost(),anURI.getPort(),timeout);
  setSocket(s);
  outputStream=new ExObjectOutputStream(new BufferedOutputStream(s.getOutputStream()),false);
  outputStream.flush();
  inputStream=new ExObjectInputStream(s.getInputStream(),false);
  trace(""String_Node_Str"" + anURI);
  sendIt(new ConnectRequestMessage(anURI,(Serializable)data));
  ConnectResultMessage res=null;
  res=(ConnectResultMessage)readObject();
  trace(""String_Node_Str"" + res);
  setupThreads();
  Object ret=res.getData();
  trace(""String_Node_Str"" + ret);
  return ret;
}",0.9545647558386412
95200,"public synchronized ID getLocalID(){
  if (containerID != null)   return containerID;
  if (socket == null)   return null;
  ID retID=null;
  try {
    retID=IDFactory.getDefault().makeStringID(PROTOCOL + ""String_Node_Str"" + socket.getLocalAddress().getHostName()+ ""String_Node_Str""+ socket.getLocalPort());
  }
 catch (  Exception e) {
    return null;
  }
  return retID;
}","public synchronized ID getLocalID(){
  if (containerID != null)   return containerID;
  if (socket == null)   return null;
  ID retID=null;
  try {
    retID=IDFactory.getDefault().makeStringID(PROTOCOL + ""String_Node_Str"" + socket.getLocalAddress().getHostName()+ ""String_Node_Str""+ socket.getLocalPort());
  }
 catch (  Exception e) {
    dumpStack(""String_Node_Str"",e);
    return null;
  }
  return retID;
}",0.9541984732824428
95201,"private Serializable readObject() throws IOException {
  Serializable ret=null;
  try {
    ret=(Serializable)inputStream.readObject();
  }
 catch (  ClassNotFoundException e) {
    dumpStack(""String_Node_Str"",e);
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
  return ret;
}","private Serializable readObject() throws IOException {
  Serializable ret=null;
  try {
    ret=(Serializable)inputStream.readObject();
  }
 catch (  ClassNotFoundException e) {
    dumpStack(""String_Node_Str"",e);
    IOException except=new IOException(""String_Node_Str"" + e.getMessage());
    except.setStackTrace(e.getStackTrace());
    throw except;
  }
  return ret;
}",0.8682634730538922
95202,"protected void processAsynch(AsynchConnectionEvent e){
  try {
    Object obj=e.getData();
    if (obj == null) {
      debug(""String_Node_Str"" + e);
      return;
    }
    if (!(obj instanceof byte[])) {
      debug(""String_Node_Str"" + e);
    }
    ContainerMessage mess=validateContainerMessage(deserializeContainerMessage((byte[])obj));
    if (mess == null) {
      return;
    }
    Serializable submess=mess.getData();
    if (submess != null) {
      if (submess instanceof ContainerMessage.CreateMessage) {
        handleCreateMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.CreateResponseMessage) {
        handleCreateResponseMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.SharedObjectDisposeMessage) {
        handleSharedObjectDisposeMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.SharedObjectMessage) {
        handleSharedObjectMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.ViewChangeMessage) {
        handleViewChangeMessage(mess);
      }
 else {
        handleUnidentifiedMessage(mess);
      }
    }
 else {
      handleUnidentifiedMessage(mess);
    }
  }
 catch (  IOException except) {
    handleAsynchIOException(except,e);
  }
}","protected void processAsynch(AsynchConnectionEvent e){
  try {
    Object obj=e.getData();
    if (obj == null) {
      System.out.println(""String_Node_Str"" + e);
      debug(""String_Node_Str"" + e);
      return;
    }
    if (!(obj instanceof byte[])) {
      debug(""String_Node_Str"" + e);
      System.out.println(""String_Node_Str"" + e);
      return;
    }
    ContainerMessage mess=validateContainerMessage(deserializeContainerMessage((byte[])obj));
    if (mess == null) {
      System.out.println(""String_Node_Str"" + e);
      return;
    }
    Serializable submess=mess.getData();
    if (submess != null) {
      if (submess instanceof ContainerMessage.CreateMessage) {
        handleCreateMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.CreateResponseMessage) {
        handleCreateResponseMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.SharedObjectDisposeMessage) {
        handleSharedObjectDisposeMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.SharedObjectMessage) {
        handleSharedObjectMessage(mess);
      }
 else       if (submess instanceof ContainerMessage.ViewChangeMessage) {
        handleViewChangeMessage(mess);
      }
 else {
        handleUnidentifiedMessage(mess);
      }
    }
 else {
      handleUnidentifiedMessage(mess);
    }
  }
 catch (  IOException except) {
    handleAsynchIOException(except,e);
  }
}",0.9365020423319718
95203,"protected void forwardExcluding(ID from,ID excluding,ContainerMessage data) throws IOException {
  if (excluding == null) {
    queueContainerMessage(new ContainerMessage(from,null,getNextSequenceNumber(),data.getData()));
  }
 else {
    Object ms[]=groupManager.getMembers();
    for (int i=0; i < ms.length; i++) {
      Member m=(Member)ms[i];
      ID oldID=m.getID();
      if (!excluding.equals(oldID) && !from.equals(oldID)) {
        IAsynchConnection conn=(IAsynchConnection)m.getData();
        if (conn != null) {
          try {
            conn.sendAsynch(oldID,serializeObject(new ContainerMessage(from,oldID,getNextSequenceNumber(),data.getData())));
          }
 catch (          IOException e) {
            logException(""String_Node_Str"" + from + ""String_Node_Str""+ oldID,e);
          }
        }
      }
    }
  }
}","protected void forwardExcluding(ID from,ID excluding,ContainerMessage data) throws IOException {
  if (excluding == null) {
    queueContainerMessage(new ContainerMessage(from,null,getNextSequenceNumber(),data.getData()));
  }
 else {
    Object ms[]=groupManager.getMembers();
    for (int i=0; i < ms.length; i++) {
      Member m=(Member)ms[i];
      ID oldID=m.getID();
      if (!excluding.equals(oldID) && !from.equals(oldID)) {
        IAsynchConnection conn=(IAsynchConnection)m.getData();
        if (conn != null) {
          try {
            conn.sendAsynch(oldID,serializeObject(new ContainerMessage(from,oldID,getNextSequenceNumber(),data.getData())));
          }
 catch (          IOException e) {
            logException(""String_Node_Str"" + from + ""String_Node_Str""+ oldID,e);
            e.printStackTrace();
          }
        }
      }
    }
  }
}",0.9806451612903224
95204,"protected void handleJoined(ISharedObjectContainerJoinedEvent event){
  if (isPrimary()) {
synchronized (lock) {
      ID newMember=event.getJoinedContainerID();
      getSharedObject().replicate(newMember);
      if (getTransactionState() == ISharedObjectContainerTransaction.VOTING)       addParticipants(new ID[]{newMember});
 else       getSharedObject().replicate(newMember);
    }
  }
 else {
  }
}","protected void handleJoined(ISharedObjectContainerJoinedEvent event){
  if (isPrimary()) {
synchronized (lock) {
      ID newMember=event.getJoinedContainerID();
      getSharedObject().replicate(newMember);
      if (getTransactionState() == ISharedObjectContainerTransaction.VOTING)       addParticipants(new ID[]{newMember});
    }
  }
 else {
  }
}",0.8862433862433863
95205,"protected void handleSharedObjectMessage(ContainerMessage mess) throws IOException {
  debug(""String_Node_Str"" + mess);
  ID fromID=mess.getFromContainerID();
  ID toID=mess.getToContainerID();
  long seq=mess.getSequence();
  ContainerMessage.SharedObjectMessage resp=(ContainerMessage.SharedObjectMessage)mess.getData();
  byte[] databytes=(byte[])resp.getData();
  Serializable obj=null;
  try {
    obj=(Serializable)deserializeSharedObjectMessage(databytes);
  }
 catch (  ClassNotFoundException e) {
    dumpStack(""String_Node_Str"",e);
    e.printStackTrace(System.err);
  }
synchronized (getGroupMembershipLock()) {
    if (toID == null || toID.equals(getID())) {
      SOWrapper sow=getSharedObjectWrapper(resp.getFromSharedObjectID());
      if (sow != null) {
        sow.deliverSharedObjectMessage(fromID,obj);
      }
    }
    forward(fromID,toID,mess);
  }
}","protected void handleSharedObjectMessage(ContainerMessage mess) throws IOException {
  debug(""String_Node_Str"" + mess);
  ID fromID=mess.getFromContainerID();
  ID toID=mess.getToContainerID();
  ContainerMessage.SharedObjectMessage resp=(ContainerMessage.SharedObjectMessage)mess.getData();
synchronized (getGroupMembershipLock()) {
    if (toID == null || toID.equals(getID())) {
      SOWrapper sow=getSharedObjectWrapper(resp.getFromSharedObjectID());
      if (sow != null) {
        try {
          sow.deliverSharedObjectMessage(fromID,(Serializable)deserializeSharedObjectMessage((byte[])resp.getData()));
        }
 catch (        ClassNotFoundException e) {
          dumpStack(""String_Node_Str"",e);
          e.printStackTrace(System.err);
        }
      }
    }
    forward(fromID,toID,mess);
  }
}",0.4385026737967914
95206,"protected void handleSharedObjectMessage(ContainerMessage mess) throws IOException {
  debug(""String_Node_Str"" + mess);
  ID fromID=mess.getFromContainerID();
  ID toID=mess.getToContainerID();
  long seq=mess.getSequence();
  ContainerMessage.SharedObjectMessage resp=(ContainerMessage.SharedObjectMessage)mess.getData();
  byte[] databytes=(byte[])resp.getData();
  Serializable obj=null;
  try {
    obj=(Serializable)deserializeSharedObjectMessage(databytes);
  }
 catch (  ClassNotFoundException e) {
    dumpStack(""String_Node_Str"",e);
    e.printStackTrace(System.err);
  }
synchronized (getGroupMembershipLock()) {
    SOWrapper sow=getSharedObjectWrapper(resp.getFromSharedObjectID());
    if (sow != null) {
      sow.deliverSharedObjectMessage(fromID,obj);
    }
    forward(fromID,toID,mess);
  }
}","protected void handleSharedObjectMessage(ContainerMessage mess) throws IOException {
  debug(""String_Node_Str"" + mess);
  ID fromID=mess.getFromContainerID();
  ID toID=mess.getToContainerID();
  long seq=mess.getSequence();
  ContainerMessage.SharedObjectMessage resp=(ContainerMessage.SharedObjectMessage)mess.getData();
  byte[] databytes=(byte[])resp.getData();
  Serializable obj=null;
  try {
    obj=(Serializable)deserializeSharedObjectMessage(databytes);
  }
 catch (  ClassNotFoundException e) {
    dumpStack(""String_Node_Str"",e);
    e.printStackTrace(System.err);
  }
synchronized (getGroupMembershipLock()) {
    if (toID == null || toID.equals(getID())) {
      SOWrapper sow=getSharedObjectWrapper(resp.getFromSharedObjectID());
      if (sow != null) {
        sow.deliverSharedObjectMessage(fromID,obj);
      }
    }
    forward(fromID,toID,mess);
  }
}",0.9631391200951248
95207,"public void handleSubscribed(ID fromID,IPresence presence){
  System.out.println(""String_Node_Str"" + fromID);
}","public void handleSubscribed(ID fromID,IPresence presence){
}",0.7093023255813954
95208,"public void handleUnsubscribed(ID fromID,IPresence presence){
  System.out.println(""String_Node_Str"" + fromID);
}","public void handleUnsubscribed(ID fromID,IPresence presence){
}",0.7159090909090909
95209,"protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  presenceSender=pc.getPresenceSender();
  accountManager=pc.getAccountManager();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ILocalInputHandler(){
          public void inputText(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void startTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
          public void updatePresence(          ID userID,          IPresence presence){
            presenceSender.sendPresenceUpdate(localUser,userID,presence);
          }
          public void sendRosterAdd(          String user,          String name,          String[] groups){
            presenceSender.sendRosterAdd(localUser,user,name,groups);
          }
          public void sendRosterRemove(          ID userID){
            presenceSender.sendRosterRemove(localUser,userID);
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
    public void handleSetRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleSetRosterEntry(entry);
        }
      }
);
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    final ID fromID,    IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.setBlockOnOpen(true);
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null) {
                  String[] groupNames=rosterView.getGroupNames();
                  List g=Arrays.asList(groupNames);
                  String selectedGroup=rosterView.getSelectedGroupName();
                  int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
                  AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
                  sg.open();
                  if (sg.getResult() == Window.OK) {
                    String group=sg.getGroup();
                    String user=sg.getUser();
                    String nickname=sg.getNickname();
                    sg.close();
                    if (!g.contains(group)) {
                      rosterView.addGroup(group);
                    }
                    presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
                  }
                }
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
 catch (          Exception e) {
            IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
            ClientPlugin.getDefault().getLog().log(status);
          }
        }
      }
);
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
      }
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
  }
);
}","protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  presenceSender=pc.getPresenceSender();
  accountManager=pc.getAccountManager();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ILocalInputHandler(){
          public void inputText(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void startTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
          public void updatePresence(          ID userID,          IPresence presence){
            presenceSender.sendPresenceUpdate(localUser,userID,presence);
          }
          public void sendRosterAdd(          String user,          String name,          String[] groups){
            presenceSender.sendRosterAdd(localUser,user,name,groups);
          }
          public void sendRosterRemove(          ID userID){
            presenceSender.sendRosterRemove(localUser,userID);
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
    public void handleSetRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleSetRosterEntry(entry);
        }
      }
);
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    final ID fromID,    IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.setBlockOnOpen(true);
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null) {
                  String[] groupNames=rosterView.getGroupNames();
                  List g=Arrays.asList(groupNames);
                  String selectedGroup=rosterView.getSelectedGroupName();
                  int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
                  AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
                  sg.open();
                  if (sg.getResult() == Window.OK) {
                    String group=sg.getGroup();
                    String user=sg.getUser();
                    String nickname=sg.getNickname();
                    sg.close();
                    if (!g.contains(group)) {
                      rosterView.addGroup(group);
                    }
                    presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
                  }
                }
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
 catch (          Exception e) {
            IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
            ClientPlugin.getDefault().getLog().log(status);
          }
        }
      }
);
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
      }
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
    }
  }
);
}",0.9788625304136253
95210,"public void handleMessage(ID fromID,ID toID,Type type,String subject,String message);","/** 
 * Handle message from remote user
 * @param fromID the ID of the user sending the message
 * @param toID the ID of the user to receive the message
 * @param type the Type of the message
 * @param subject the subject of the message
 * @param messageBody the message body
 */
public void handleMessage(ID fromID,ID toID,Type type,String subject,String messageBody);",0.3744493392070485
95211,"public void sendMessage(ID fromID,ID toID,Type type,String subject,String message);","/** 
 * Send text message
 * @param fromID the user id of the sender.  Cannot be null
 * @param toID the user id of the target receiver of the message.  Cannot be null
 * @param type the Type of the message
 * @param subject the subject of the message
 * @param messageBody the message body
 */
public void sendMessage(ID fromID,ID toID,Type type,String subject,String messageBody);",0.3569892473118279
95212,public void addPresenceListener(IPresenceListener listener);,"/** 
 * Setup listener for handling presence updates
 * @param listener
 */
public void addPresenceListener(IPresenceListener listener);",0.6122448979591837
95213,public void addMessageListener(IMessageListener listener);,"/** 
 * Setup listener for handling IM messages
 * @param listener
 */
public void addMessageListener(IMessageListener listener);",0.6203208556149733
95214,public IMessageSender getMessageSender();,"/** 
 * Get interface for sending messages
 * @return
 */
public IMessageSender getMessageSender();",0.5857142857142857
95215,public IPresenceSender getPresenceSender();,"/** 
 * Get interface for sending presence updates
 * @return
 */
public IPresenceSender getPresenceSender();",0.5657894736842105
95216,public IAccountManager getAccountManager();,"/** 
 * Get interface for managing account
 * @return
 */
public IAccountManager getAccountManager();",0.5972222222222222
95217,public void addSubscribeListener(ISubscribeListener listener);,"/** 
 * Setup listener for handling subscription requests
 * @param listener
 */
public void addSubscribeListener(ISubscribeListener listener);",0.6048780487804878
95218,public void handleContainerJoined(ID joinedContainer);,"/** 
 * Notification that a new group member (i.e. the server) has successfully joined/connected
 * @param joinedContainer
 */
public void handleContainerJoined(ID joinedContainer);",0.4595744680851064
95219,public void handleRosterEntry(IRosterEntry entry);,"/** 
 * Notification that a roster entry has been received
 * @param entry
 */
public void handleRosterEntry(IRosterEntry entry);",0.5586592178770949
95220,"public void handlePresence(ID fromID,IPresence presence);","/** 
 * Notification that a presence update has been received
 * @param fromID
 * @param presence
 */
public void handlePresence(ID fromID,IPresence presence);",0.5277777777777778
95221,public void handleContainerDeparted(ID departedContainer);,"/** 
 * Notification that a remote container (i.e. the server) has disconnected/left group
 * @param departedContainer
 */
public void handleContainerDeparted(ID departedContainer);",0.4853556485355648
95222,public void handleSetRosterEntry(IRosterEntry entry);,"/** 
 * Notification that a roster entry has been set
 * @param entry
 */
public void handleSetRosterEntry(IRosterEntry entry);",0.5888888888888889
95223,"public void sendPresenceUpdate(ID fromID,ID toID,IPresence presence);","/** 
 * Send a presence update to a remote target user
 * @param fromID the user the update is from
 * @param toID the target user
 * @param presence the presence information
 */
public void sendPresenceUpdate(ID fromID,ID toID,IPresence presence);",0.4353312302839117
95224,"public void sendRosterAdd(ID fromID,String user,String name,String[] groups);","/** 
 * Send a roster add request (subscribe) to a remote
 * @param fromID the user the subscription request is from
 * @param user the account name of the target user
 * @param groups an array of group names that this use will belong toon the roster entry
 */
public void sendRosterAdd(ID fromID,String user,String name,String[] groups);",0.3710843373493976
95225,"public void sendRosterRemove(ID fromID,ID userID);","/** 
 * Send roster remove request (unsubscribe) to a remote
 * @param fromID the user id the request is from
 * @param userID the user id the request it intended for
 */
public void sendRosterRemove(ID fromID,ID userID);",0.3690036900369003
95226,"protected void createButtonsForButtonBar(Composite parent){
  createButton(parent,IDialogConstants.OK_ID,IDialogConstants.OK_LABEL,false);
  createButton(parent,IDialogConstants.CANCEL_ID,IDialogConstants.CANCEL_LABEL,true);
  okButton=getButton(IDialogConstants.OK_ID);
  if (okButton != null) {
    okButton.setEnabled(false);
  }
}","protected void createButtonsForButtonBar(Composite parent){
  createButton(parent,IDialogConstants.OK_ID,IDialogConstants.OK_LABEL,false);
  createButton(parent,IDialogConstants.CANCEL_ID,IDialogConstants.CANCEL_LABEL,true);
  okButton=getButton(IDialogConstants.OK_ID);
  if (okButton != null) {
    if (user != null)     okButton.setEnabled(true);
 else     okButton.setEnabled(false);
  }
}",0.9188445667125172
95227,"protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  final GridLayout gridLayout=new GridLayout();
  gridLayout.horizontalSpacing=0;
  container.setLayout(gridLayout);
  final Composite composite=new Composite(container,SWT.NONE);
  composite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.FILL_VERTICAL));
  final GridLayout gridLayout_2=new GridLayout();
  gridLayout_2.numColumns=2;
  composite.setLayout(gridLayout_2);
  final Label label=new Label(composite,SWT.NONE);
  final Label label_4=new Label(composite,SWT.NONE);
  label_4.setText(""String_Node_Str"");
  final Label label_3=new Label(composite,SWT.NONE);
  label_3.setText(""String_Node_Str"");
  usertext=new Text(composite,SWT.BORDER);
  usertext.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_FILL));
  if (user != null) {
    usertext.setText(user);
    okButton.setEnabled(true);
  }
  usertext.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      if (user != null || (usertext.getText().length() > 3 && usertext.getText().indexOf(""String_Node_Str"") != -1)) {
        okButton.setEnabled(true);
      }
 else {
        okButton.setEnabled(false);
      }
    }
  }
);
  final Label label_1=new Label(composite,SWT.NONE);
  label_1.setText(""String_Node_Str"");
  groups=new Combo(composite,SWT.NONE);
  groups.setToolTipText(""String_Node_Str"");
  final GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.widthHint=141;
  groups.setLayoutData(gridData);
  if (existing != null) {
    for (int i=0; i < existing.length; i++) {
      groups.add(existing[i]);
    }
    if (selectedGroup != -1)     groups.select(selectedGroup);
 else     groups.select(0);
  }
  final Label label_2=new Label(composite,SWT.NONE);
  label_2.setText(""String_Node_Str"");
  nicknametext=new Text(composite,SWT.BORDER);
  final GridData gridData_1=new GridData(GridData.FILL_HORIZONTAL);
  gridData_1.widthHint=192;
  nicknametext.setLayoutData(gridData_1);
  return container;
}","protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  final GridLayout gridLayout=new GridLayout();
  gridLayout.horizontalSpacing=0;
  container.setLayout(gridLayout);
  final Composite composite=new Composite(container,SWT.NONE);
  composite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.FILL_VERTICAL));
  final GridLayout gridLayout_2=new GridLayout();
  gridLayout_2.numColumns=2;
  composite.setLayout(gridLayout_2);
  final Label label=new Label(composite,SWT.NONE);
  final Label label_4=new Label(composite,SWT.NONE);
  label_4.setText(""String_Node_Str"");
  final Label label_3=new Label(composite,SWT.NONE);
  label_3.setText(""String_Node_Str"");
  usertext=new Text(composite,SWT.BORDER);
  usertext.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_FILL));
  if (user != null) {
    usertext.setText(user);
  }
  usertext.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      if (user != null || (usertext.getText().length() > 3 && usertext.getText().indexOf(""String_Node_Str"") != -1)) {
        okButton.setEnabled(true);
      }
 else {
        okButton.setEnabled(false);
      }
    }
  }
);
  final Label label_1=new Label(composite,SWT.NONE);
  label_1.setText(""String_Node_Str"");
  groups=new Combo(composite,SWT.NONE);
  groups.setToolTipText(""String_Node_Str"");
  final GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.widthHint=141;
  groups.setLayoutData(gridData);
  if (existing != null) {
    for (int i=0; i < existing.length; i++) {
      groups.add(existing[i]);
    }
    if (selectedGroup != -1)     groups.select(selectedGroup);
 else     groups.select(0);
  }
  final Label label_2=new Label(composite,SWT.NONE);
  label_2.setText(""String_Node_Str"");
  nicknametext=new Text(composite,SWT.BORDER);
  final GridData gridData_1=new GridData(GridData.FILL_HORIZONTAL);
  gridData_1.widthHint=192;
  nicknametext.setLayoutData(gridData_1);
  if (user != null) {
    nicknametext.setFocus();
  }
  return container;
}",0.9706448508180944
95228,"protected void openDialogAndSendRequest(String name,String groupName){
  String[] groupNames=this.getGroupNames();
  List g=Arrays.asList(groupNames);
  int selected=(groupName == null) ? -1 : g.indexOf(groupName);
  AddBuddyDialog sg=new AddBuddyDialog(viewer.getControl().getShell(),name,groupNames,selected);
  sg.open();
  if (sg.getResult() == Window.OK) {
    String group=sg.getGroup();
    String user=sg.getUser();
    String nickname=sg.getNickname();
    sg.close();
    if (!Arrays.asList(groupNames).contains(group)) {
      this.addGroup(group);
    }
    String[] sendGroups=new String[]{group};
    inputHandler.sendRosterAdd(user,nickname,sendGroups);
    addPendingEntry(user,nickname,group);
  }
}","protected void openDialogAndSendRequest(String name,String groupName){
  String[] groupNames=this.getGroupNames();
  List g=Arrays.asList(groupNames);
  int selected=(groupName == null) ? -1 : g.indexOf(groupName);
  AddBuddyDialog sg=new AddBuddyDialog(viewer.getControl().getShell(),name,groupNames,selected);
  sg.open();
  if (sg.getResult() == Window.OK) {
    String group=sg.getGroup();
    String user=sg.getUser();
    String nickname=sg.getNickname();
    sg.close();
    if (!Arrays.asList(groupNames).contains(group)) {
      this.addGroup(group);
    }
    String[] sendGroups=new String[]{group};
    inputHandler.sendRosterAdd(user,nickname,sendGroups);
  }
}",0.9697841726618706
95229,"protected XMPPID(Namespace namespace,String unamehost) throws URISyntaxException {
  super(namespace);
  uri=new URI(PROTOCOL + ""String_Node_Str"" + unamehost);
}","protected XMPPID(Namespace namespace,String unamehost) throws URISyntaxException {
  super(namespace);
  unamehost=fixEscape(unamehost);
  uri=new URI(PROTOCOL + ""String_Node_Str"" + unamehost);
}",0.904494382022472
95230,"public void modifyText(ModifyEvent e){
  if (usertext.getText().length() > 3 && usertext.getText().indexOf(""String_Node_Str"") != -1) {
    okButton.setEnabled(true);
  }
}","public void modifyText(ModifyEvent e){
  if (user != null || (usertext.getText().length() > 3 && usertext.getText().indexOf(""String_Node_Str"") != -1)) {
    okButton.setEnabled(true);
  }
 else {
    okButton.setEnabled(false);
  }
}",0.8465346534653465
95231,"protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  final GridLayout gridLayout=new GridLayout();
  gridLayout.horizontalSpacing=0;
  container.setLayout(gridLayout);
  final Composite composite=new Composite(container,SWT.NONE);
  composite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.FILL_VERTICAL));
  final GridLayout gridLayout_2=new GridLayout();
  gridLayout_2.numColumns=2;
  composite.setLayout(gridLayout_2);
  final Label label=new Label(composite,SWT.NONE);
  final Label label_4=new Label(composite,SWT.NONE);
  label_4.setText(""String_Node_Str"");
  final Label label_3=new Label(composite,SWT.NONE);
  label_3.setText(""String_Node_Str"");
  usertext=new Text(composite,SWT.BORDER);
  usertext.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_FILL));
  if (user != null) {
    usertext.setText(user);
  }
  usertext.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      if (usertext.getText().length() > 3 && usertext.getText().indexOf(""String_Node_Str"") != -1) {
        okButton.setEnabled(true);
      }
    }
  }
);
  final Label label_1=new Label(composite,SWT.NONE);
  label_1.setText(""String_Node_Str"");
  groups=new Combo(composite,SWT.NONE);
  groups.setToolTipText(""String_Node_Str"");
  final GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.widthHint=141;
  groups.setLayoutData(gridData);
  if (existing != null) {
    for (int i=0; i < existing.length; i++) {
      groups.add(existing[i]);
    }
    if (selectedGroup != -1)     groups.select(selectedGroup);
 else     groups.select(0);
  }
  final Label label_2=new Label(composite,SWT.NONE);
  label_2.setText(""String_Node_Str"");
  nicknametext=new Text(composite,SWT.BORDER);
  final GridData gridData_1=new GridData(GridData.FILL_HORIZONTAL);
  gridData_1.widthHint=192;
  nicknametext.setLayoutData(gridData_1);
  return container;
}","protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  final GridLayout gridLayout=new GridLayout();
  gridLayout.horizontalSpacing=0;
  container.setLayout(gridLayout);
  final Composite composite=new Composite(container,SWT.NONE);
  composite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.FILL_VERTICAL));
  final GridLayout gridLayout_2=new GridLayout();
  gridLayout_2.numColumns=2;
  composite.setLayout(gridLayout_2);
  final Label label=new Label(composite,SWT.NONE);
  final Label label_4=new Label(composite,SWT.NONE);
  label_4.setText(""String_Node_Str"");
  final Label label_3=new Label(composite,SWT.NONE);
  label_3.setText(""String_Node_Str"");
  usertext=new Text(composite,SWT.BORDER);
  usertext.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_FILL));
  if (user != null) {
    usertext.setText(user);
    okButton.setEnabled(true);
  }
  usertext.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      if (user != null || (usertext.getText().length() > 3 && usertext.getText().indexOf(""String_Node_Str"") != -1)) {
        okButton.setEnabled(true);
      }
 else {
        okButton.setEnabled(false);
      }
    }
  }
);
  final Label label_1=new Label(composite,SWT.NONE);
  label_1.setText(""String_Node_Str"");
  groups=new Combo(composite,SWT.NONE);
  groups.setToolTipText(""String_Node_Str"");
  final GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.widthHint=141;
  groups.setLayoutData(gridData);
  if (existing != null) {
    for (int i=0; i < existing.length; i++) {
      groups.add(existing[i]);
    }
    if (selectedGroup != -1)     groups.select(selectedGroup);
 else     groups.select(0);
  }
  final Label label_2=new Label(composite,SWT.NONE);
  label_2.setText(""String_Node_Str"");
  nicknametext=new Text(composite,SWT.BORDER);
  final GridData gridData_1=new GridData(GridData.FILL_HORIZONTAL);
  gridData_1.widthHint=192;
  nicknametext.setLayoutData(gridData_1);
  return container;
}",0.9749441825849664
95232,"protected void handleTextInput(String text){
  ChatLine line=new ChatLine(text);
  if (lch != null) {
    line.setOriginator(userdata);
  }
  appendAndScrollToBottom(line);
  teamChat.clearInput();
  if (lch != null)   lch.inputText(text);
}","protected void handleTextInput(String text){
  if (showTimestamp) {
    text=dateTime() + text;
  }
  ChatLine line=new ChatLine(text);
  if (lch != null) {
    line.setOriginator(userdata);
  }
  appendAndScrollToBottom(line);
  teamChat.clearInput();
  if (lch != null)   lch.inputText(text);
}",0.8975791433891993
95233,"protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ITextInputHandler(){
          public void handleTextLine(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void handleStartTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
      if (messageSender != null) {
        messageSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
      }
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
  }
);
}","protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  presenceSender=pc.getPresenceSender();
  accountManager=pc.getAccountManager();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ITextInputHandler(){
          public void handleTextLine(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void handleStartTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
      }
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
  }
);
}",0.9850166481687016
95234,"public void handleSubscribeRequest(ID fromID,IPresence presence){
  System.out.println(""String_Node_Str"" + fromID);
  if (messageSender != null) {
    messageSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
  }
}","public void handleSubscribeRequest(ID fromID,IPresence presence){
  System.out.println(""String_Node_Str"" + fromID);
  if (presenceSender != null) {
    presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
  }
}",0.9477911646586346
95235,"public void run(){
  try {
    IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
    authRequest.setBlockOnOpen(true);
    authRequest.open();
    int res=authRequest.getButtonPressed();
    if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
        if (rosterView != null) {
          String[] groupNames=rosterView.getGroupNames();
          List g=Arrays.asList(groupNames);
          String selectedGroup=rosterView.getSelectedGroupName();
          int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
          AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
          sg.open();
          if (sg.getReturnCode() == Window.OK) {
            String group=sg.getGroup();
            String user=sg.getUser();
            String nickname=sg.getNickname();
            sg.close();
            if (!g.contains(group)) {
              rosterView.addGroup(group);
            }
            presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
          }
        }
      }
    }
 else     if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
      }
    }
 else     if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
    ClientPlugin.getDefault().getLog().log(status);
  }
}","public void run(){
  try {
    IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
    authRequest.setBlockOnOpen(true);
    authRequest.open();
    int res=authRequest.getButtonPressed();
    if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
        if (rosterView != null) {
          String[] groupNames=rosterView.getGroupNames();
          List g=Arrays.asList(groupNames);
          String selectedGroup=rosterView.getSelectedGroupName();
          int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
          AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
          sg.open();
          if (sg.getResult() == Window.OK) {
            String group=sg.getGroup();
            String user=sg.getUser();
            String nickname=sg.getNickname();
            sg.close();
            if (!g.contains(group)) {
              rosterView.addGroup(group);
            }
            presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
          }
        }
      }
    }
 else     if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
      }
    }
 else     if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
    ClientPlugin.getDefault().getLog().log(status);
  }
}",0.9969072164948454
95236,"protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  presenceSender=pc.getPresenceSender();
  accountManager=pc.getAccountManager();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ILocalInputHandler(){
          public void inputText(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void startTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
          public void updatePresence(          ID userID,          IPresence presence){
            presenceSender.sendPresenceUpdate(localUser,userID,presence);
          }
          public void sendRosterAdd(          String user,          String name,          String[] groups){
            presenceSender.sendRosterAdd(localUser,user,name,groups);
          }
          public void sendRosterRemove(          ID userID){
            presenceSender.sendRosterRemove(localUser,userID);
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    final ID fromID,    IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.setBlockOnOpen(true);
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null) {
                  String[] groupNames=rosterView.getGroupNames();
                  List g=Arrays.asList(groupNames);
                  String selectedGroup=rosterView.getSelectedGroupName();
                  int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
                  AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
                  sg.open();
                  if (sg.getReturnCode() == Window.OK) {
                    String group=sg.getGroup();
                    String user=sg.getUser();
                    String nickname=sg.getNickname();
                    sg.close();
                    if (!g.contains(group)) {
                      rosterView.addGroup(group);
                    }
                    presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
                  }
                }
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
 catch (          Exception e) {
            IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
            ClientPlugin.getDefault().getLog().log(status);
          }
        }
      }
);
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
      }
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
  }
);
}","protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  presenceSender=pc.getPresenceSender();
  accountManager=pc.getAccountManager();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ILocalInputHandler(){
          public void inputText(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void startTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
          public void updatePresence(          ID userID,          IPresence presence){
            presenceSender.sendPresenceUpdate(localUser,userID,presence);
          }
          public void sendRosterAdd(          String user,          String name,          String[] groups){
            presenceSender.sendRosterAdd(localUser,user,name,groups);
          }
          public void sendRosterRemove(          ID userID){
            presenceSender.sendRosterRemove(localUser,userID);
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
    public void handleSetRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleSetRosterEntry(entry);
        }
      }
);
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    final ID fromID,    IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.setBlockOnOpen(true);
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null) {
                  String[] groupNames=rosterView.getGroupNames();
                  List g=Arrays.asList(groupNames);
                  String selectedGroup=rosterView.getSelectedGroupName();
                  int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
                  AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
                  sg.open();
                  if (sg.getResult() == Window.OK) {
                    String group=sg.getGroup();
                    String user=sg.getUser();
                    String nickname=sg.getNickname();
                    sg.close();
                    if (!g.contains(group)) {
                      rosterView.addGroup(group);
                    }
                    presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
                  }
                }
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
 catch (          Exception e) {
            IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
            ClientPlugin.getDefault().getLog().log(status);
          }
        }
      }
);
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
      }
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
  }
);
}",0.9393615396364748
95237,"public void handleUnsubscribeRequest(ID fromID,IPresence presence){
  System.out.println(""String_Node_Str"" + fromID);
  if (presenceSender != null) {
    presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
  }
}","public void handleUnsubscribeRequest(ID fromID,IPresence presence){
  if (presenceSender != null) {
    presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
  }
}",0.8908296943231441
95238,"public void handleSubscribeRequest(final ID fromID,IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
        authRequest.setBlockOnOpen(true);
        authRequest.open();
        int res=authRequest.getButtonPressed();
        if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
            if (rosterView != null) {
              String[] groupNames=rosterView.getGroupNames();
              List g=Arrays.asList(groupNames);
              String selectedGroup=rosterView.getSelectedGroupName();
              int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
              AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
              sg.open();
              if (sg.getReturnCode() == Window.OK) {
                String group=sg.getGroup();
                String user=sg.getUser();
                String nickname=sg.getNickname();
                sg.close();
                if (!g.contains(group)) {
                  rosterView.addGroup(group);
                }
                presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
              }
            }
          }
        }
 else         if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
          }
        }
 else         if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
}","public void handleSubscribeRequest(final ID fromID,IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
        authRequest.setBlockOnOpen(true);
        authRequest.open();
        int res=authRequest.getButtonPressed();
        if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
            if (rosterView != null) {
              String[] groupNames=rosterView.getGroupNames();
              List g=Arrays.asList(groupNames);
              String selectedGroup=rosterView.getSelectedGroupName();
              int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
              AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
              sg.open();
              if (sg.getResult() == Window.OK) {
                String group=sg.getGroup();
                String user=sg.getUser();
                String nickname=sg.getNickname();
                sg.close();
                if (!g.contains(group)) {
                  rosterView.addGroup(group);
                }
                presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
              }
            }
          }
        }
 else         if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
          }
        }
 else         if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
}",0.9973368841544608
95239,"protected void createButtonsForButtonBar(Composite parent){
  createButton(parent,IDialogConstants.OK_ID,IDialogConstants.OK_LABEL,true);
  createButton(parent,IDialogConstants.CANCEL_ID,IDialogConstants.CANCEL_LABEL,false);
}","protected void createButtonsForButtonBar(Composite parent){
  createButton(parent,IDialogConstants.OK_ID,IDialogConstants.OK_LABEL,false);
  createButton(parent,IDialogConstants.CANCEL_ID,IDialogConstants.CANCEL_LABEL,true);
  okButton=getButton(IDialogConstants.OK_ID);
  if (okButton != null) {
    okButton.setEnabled(false);
  }
}",0.7964285714285714
95240,"protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  final GridLayout gridLayout=new GridLayout();
  gridLayout.horizontalSpacing=0;
  container.setLayout(gridLayout);
  final Composite composite=new Composite(container,SWT.NONE);
  composite.setLayoutData(new GridData(GridData.FILL_BOTH));
  final GridLayout gridLayout_2=new GridLayout();
  gridLayout_2.numColumns=2;
  composite.setLayout(gridLayout_2);
  final Label label_3=new Label(composite,SWT.NONE);
  label_3.setText(""String_Node_Str"");
  usertext=new Text(composite,SWT.BORDER);
  usertext.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_FILL));
  if (user != null) {
    usertext.setText(user);
    usertext.setEnabled(false);
  }
  final Label label_1=new Label(composite,SWT.NONE);
  label_1.setText(""String_Node_Str"");
  groups=new Combo(composite,SWT.NONE);
  groups.setToolTipText(""String_Node_Str"");
  final GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.widthHint=141;
  groups.setLayoutData(gridData);
  if (existing != null) {
    for (int i=0; i < existing.length; i++) {
      groups.add(existing[i]);
    }
    if (selectedGroup != -1)     groups.select(selectedGroup);
 else     groups.select(0);
  }
  final Label label_2=new Label(composite,SWT.NONE);
  label_2.setText(""String_Node_Str"");
  nicknametext=new Text(composite,SWT.BORDER);
  final GridData gridData_1=new GridData(GridData.FILL_HORIZONTAL);
  gridData_1.widthHint=192;
  nicknametext.setLayoutData(gridData_1);
  return container;
}","protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  final GridLayout gridLayout=new GridLayout();
  gridLayout.horizontalSpacing=0;
  container.setLayout(gridLayout);
  final Composite composite=new Composite(container,SWT.NONE);
  composite.setLayoutData(new GridData(GridData.FILL_BOTH));
  final GridLayout gridLayout_2=new GridLayout();
  gridLayout_2.numColumns=2;
  composite.setLayout(gridLayout_2);
  final Label label_3=new Label(composite,SWT.NONE);
  label_3.setText(""String_Node_Str"");
  usertext=new Text(composite,SWT.BORDER);
  usertext.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_FILL));
  if (user != null) {
    usertext.setText(user);
    usertext.setEnabled(false);
  }
  usertext.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      if (usertext.getText().length() > 3 && usertext.getText().indexOf(""String_Node_Str"") != -1) {
        okButton.setEnabled(true);
      }
    }
  }
);
  final Label label_1=new Label(composite,SWT.NONE);
  label_1.setText(""String_Node_Str"");
  groups=new Combo(composite,SWT.NONE);
  groups.setToolTipText(""String_Node_Str"");
  final GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.widthHint=141;
  groups.setLayoutData(gridData);
  if (existing != null) {
    for (int i=0; i < existing.length; i++) {
      groups.add(existing[i]);
    }
    if (selectedGroup != -1)     groups.select(selectedGroup);
 else     groups.select(0);
  }
  final Label label_2=new Label(composite,SWT.NONE);
  label_2.setText(""String_Node_Str"");
  nicknametext=new Text(composite,SWT.BORDER);
  final GridData gridData_1=new GridData(GridData.FILL_HORIZONTAL);
  gridData_1.widthHint=192;
  nicknametext.setLayoutData(gridData_1);
  return container;
}",0.9251620506776664
95241,"public void run(){
  try {
    IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    AuthorizeRequest authRequest=new AuthorizeRequest(ww.getShell(),fromID.getName(),localUser.getName());
    authRequest.open();
    int res=authRequest.getButtonPressed();
    if (res == AuthorizeRequest.AUTHORIZE_AND_ADD) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
        if (rosterView != null) {
          String[] groupNames=rosterView.getGroupNames();
        }
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBE));
      }
    }
 else     if (res == AuthorizeRequest.AUTHORIZE_ID) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
      }
    }
 else     if (res == AuthorizeRequest.REFUSE_ID) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
    ClientPlugin.getDefault().getLog().log(status);
  }
}","public void run(){
  try {
    IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
    authRequest.setBlockOnOpen(true);
    authRequest.open();
    int res=authRequest.getButtonPressed();
    if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
        if (rosterView != null) {
          String[] groupNames=rosterView.getGroupNames();
          List g=Arrays.asList(groupNames);
          String selectedGroup=rosterView.getSelectedGroupName();
          int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
          AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
          sg.open();
          if (sg.getReturnCode() == Window.OK) {
            String group=sg.getGroup();
            String user=sg.getUser();
            String nickname=sg.getNickname();
            sg.close();
            if (!g.contains(group)) {
              rosterView.addGroup(group);
            }
            presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
          }
        }
      }
    }
 else     if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
      }
    }
 else     if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
    ClientPlugin.getDefault().getLog().log(status);
  }
}",0.7081761006289308
95242,"protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  presenceSender=pc.getPresenceSender();
  accountManager=pc.getAccountManager();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ILocalInputHandler(){
          public void inputText(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void startTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
          public void updatePresence(          ID userID,          IPresence presence){
            presenceSender.sendPresenceUpdate(localUser,userID,presence);
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    final ID fromID,    IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            AuthorizeRequest authRequest=new AuthorizeRequest(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == AuthorizeRequest.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null) {
                  String[] groupNames=rosterView.getGroupNames();
                }
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBE));
              }
            }
 else             if (res == AuthorizeRequest.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == AuthorizeRequest.REFUSE_ID) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
 catch (          Exception e) {
            IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
            ClientPlugin.getDefault().getLog().log(status);
          }
        }
      }
);
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
  }
);
}","protected void setupPresenceContainer(final ISharedObjectContainer container,IPresenceContainer pc,final ID localUser,final String nick){
  messageSender=pc.getMessageSender();
  presenceSender=pc.getPresenceSender();
  accountManager=pc.getAccountManager();
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        IWorkbenchPage wp=ww.getActivePage();
        IViewPart view=wp.showView(""String_Node_Str"");
        rosterView=(RosterView)view;
        String nickname=null;
        if (nick != null) {
          nickname=nick;
        }
 else {
          String name=localUser.getName();
          nickname=name.substring(0,name.indexOf(""String_Node_Str""));
        }
        rosterView.setLocalUser(new org.eclipse.ecf.core.user.User(localUser,nickname),new ILocalInputHandler(){
          public void inputText(          ID userID,          String text){
            messageSender.sendMessage(localUser,userID,null,null,text);
          }
          public void startTyping(          ID userID){
          }
          public void disconnect(){
            container.leaveGroup();
          }
          public void updatePresence(          ID userID,          IPresence presence){
            presenceSender.sendPresenceUpdate(localUser,userID,presence);
          }
          public void sendRosterAdd(          String user,          String name,          String[] groups){
            presenceSender.sendRosterAdd(localUser,user,name,groups);
          }
          public void sendRosterRemove(          ID userID){
            presenceSender.sendRosterRemove(localUser,userID);
          }
        }
);
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
  pc.addMessageListener(new IMessageListener(){
    public void handleMessage(    final ID fromID,    final ID toID,    final Type type,    final String subject,    final String message){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleMessage(fromID,toID,type,subject,message);
        }
      }
);
    }
  }
);
  pc.addPresenceListener(new IPresenceListener(){
    public void handleContainerJoined(    final ID joinedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.setGroup(joinedContainer);
        }
      }
);
    }
    public void handleRosterEntry(    final IRosterEntry entry){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handleRosterEntry(entry);
        }
      }
);
    }
    public void handlePresence(    final ID fromID,    final IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          rosterView.handlePresence(fromID,presence);
        }
      }
);
    }
    public void handleContainerDeparted(    final ID departedContainer){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          if (rosterView != null) {
            rosterView.memberDeparted(departedContainer);
          }
        }
      }
);
      messageSender=null;
      rosterView=null;
    }
  }
);
  pc.addSubscribeListener(new ISubscribeListener(){
    public void handleSubscribeRequest(    final ID fromID,    IPresence presence){
      Display.getDefault().syncExec(new Runnable(){
        public void run(){
          try {
            IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
            ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
            authRequest.setBlockOnOpen(true);
            authRequest.open();
            int res=authRequest.getButtonPressed();
            if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
                if (rosterView != null) {
                  String[] groupNames=rosterView.getGroupNames();
                  List g=Arrays.asList(groupNames);
                  String selectedGroup=rosterView.getSelectedGroupName();
                  int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
                  AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
                  sg.open();
                  if (sg.getReturnCode() == Window.OK) {
                    String group=sg.getGroup();
                    String user=sg.getUser();
                    String nickname=sg.getNickname();
                    sg.close();
                    if (!g.contains(group)) {
                      rosterView.addGroup(group);
                    }
                    presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
                  }
                }
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
              if (presenceSender != null) {
                presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
              }
            }
 else             if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
 catch (          Exception e) {
            IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
            ClientPlugin.getDefault().getLog().log(status);
          }
        }
      }
);
    }
    public void handleUnsubscribeRequest(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
      if (presenceSender != null) {
        presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
      }
    }
    public void handleSubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
    public void handleUnsubscribed(    ID fromID,    IPresence presence){
      System.out.println(""String_Node_Str"" + fromID);
    }
  }
);
}",0.8594273923136446
95243,"public void handleUnsubscribeRequest(ID fromID,IPresence presence){
  System.out.println(""String_Node_Str"" + fromID);
}","public void handleUnsubscribeRequest(ID fromID,IPresence presence){
  System.out.println(""String_Node_Str"" + fromID);
  if (presenceSender != null) {
    presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.UNSUBSCRIBED));
  }
}",0.6380697050938338
95244,"public void handleSubscribeRequest(final ID fromID,IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        AuthorizeRequest authRequest=new AuthorizeRequest(ww.getShell(),fromID.getName(),localUser.getName());
        authRequest.open();
        int res=authRequest.getButtonPressed();
        if (res == AuthorizeRequest.AUTHORIZE_AND_ADD) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
            if (rosterView != null) {
              String[] groupNames=rosterView.getGroupNames();
            }
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBE));
          }
        }
 else         if (res == AuthorizeRequest.AUTHORIZE_ID) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
          }
        }
 else         if (res == AuthorizeRequest.REFUSE_ID) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
}","public void handleSubscribeRequest(final ID fromID,IPresence presence){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      try {
        IWorkbenchWindow ww=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
        ReceiveAuthorizeRequestDialog authRequest=new ReceiveAuthorizeRequestDialog(ww.getShell(),fromID.getName(),localUser.getName());
        authRequest.setBlockOnOpen(true);
        authRequest.open();
        int res=authRequest.getButtonPressed();
        if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_AND_ADD) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
            if (rosterView != null) {
              String[] groupNames=rosterView.getGroupNames();
              List g=Arrays.asList(groupNames);
              String selectedGroup=rosterView.getSelectedGroupName();
              int selected=(selectedGroup == null) ? -1 : g.indexOf(selectedGroup);
              AddBuddyDialog sg=new AddBuddyDialog(ww.getShell(),fromID.getName(),groupNames,selected);
              sg.open();
              if (sg.getReturnCode() == Window.OK) {
                String group=sg.getGroup();
                String user=sg.getUser();
                String nickname=sg.getNickname();
                sg.close();
                if (!g.contains(group)) {
                  rosterView.addGroup(group);
                }
                presenceSender.sendRosterAdd(localUser,user,nickname,new String[]{group});
              }
            }
          }
        }
 else         if (res == ReceiveAuthorizeRequestDialog.AUTHORIZE_ID) {
          if (presenceSender != null) {
            presenceSender.sendPresenceUpdate(localUser,fromID,new Presence(IPresence.Type.SUBSCRIBED));
          }
        }
 else         if (res == ReceiveAuthorizeRequestDialog.REFUSE_ID) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        IStatus status=new Status(IStatus.ERROR,ClientPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e);
        ClientPlugin.getDefault().getLog().log(status);
      }
    }
  }
);
}",0.7319807794981313
95245,"public void removeUser(ID id){
  String name=getUserData(id);
  if (name != null) {
    final String str=makeChatLine(""String_Node_Str"" + name + ""String_Node_Str""+ LEFT_STRING);
    showText(new ChatLine(str));
  }
  myNames.remove(id);
  removeUserFromTree(id);
}","public void removeUser(ID id){
  String name=getUserData(id);
  if (name != null) {
    final String str=makeChatLine(name + ""String_Node_Str"" + LEFT_STRING);
    showText(new ChatLine(str));
  }
  myNames.remove(id);
  removeUserFromTree(id);
}",0.9351669941060904
95246,"protected void handleShellCloseEvent(){
  if (!getShell().isDisposed()) {
    if (!disposed) {
      chat.dispose();
      chat=null;
      getShell().dispose();
    }
 else {
      getShell().setVisible(false);
    }
  }
}","protected void handleShellCloseEvent(){
  if (!getShell().isDisposed()) {
    if (disposed) {
      chat.dispose();
      chat=null;
      getShell().dispose();
    }
 else {
      getShell().setVisible(false);
    }
  }
}",0.997752808988764
95247,"protected int namespaceCompareTo(BaseID obj){
  String ovalue=((StringID)obj).value;
  return value.compareTo(ovalue);
}","protected int namespaceCompareTo(BaseID obj){
  return getName().compareTo(obj.getName());
}",0.7075471698113207
95248,"protected void handleKeyPressed(KeyEvent evt){
  if (evt.keyCode == SWT.CR) {
    handleEnter();
  }
}","protected void handleKeyPressed(KeyEvent evt){
  if (evt.character == SWT.CR) {
    handleEnter();
  }
}",0.9320388349514565
95249,"public synchronized static ISharedObjectContainer getContainer(IResource proj){
  ClientEntry entry=getClientEntry(proj,GENERIC_CONTAINER_CLIENT_NAME);
  if (entry != null)   return entry.getContainer();
 else   return null;
}","public synchronized static ISharedObjectContainer getContainer(IResource proj){
  ClientEntry entry=getClientEntry(proj,GENERIC_CONTAINER_CLIENT_NAME);
  if (entry == null) {
    entry=getClientEntry(ResourcesPlugin.getWorkspace().getRoot(),GENERIC_CONTAINER_CLIENT_NAME);
  }
  if (entry != null)   return entry.getContainer();
 else   return null;
}",0.7833622183708839
95250,"public void showMessage(final ID fromID,ID toID,Type type,String subject,final String message){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      if (chat != null) {
        chat.appendText(new ChatLine(message,getRemoteUser()));
      }
    }
  }
);
}","public void showMessage(final ID fromID,ID toID,Type type,String subject,final String message){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      if (!disposed && chat != null) {
        chat.appendText(new ChatLine(message,getRemoteUser()));
      }
    }
  }
);
}",0.9772329246935202
95251,"public void run(){
  if (chat != null) {
    chat.appendText(new ChatLine(message,getRemoteUser()));
  }
}","public void run(){
  if (!disposed && chat != null) {
    chat.appendText(new ChatLine(message,getRemoteUser()));
  }
}",0.9422222222222222
95252,"protected void handleShellCloseEvent(){
  if (!getShell().isDisposed())   getShell().setVisible(false);
}","protected void handleShellCloseEvent(){
  if (!getShell().isDisposed()) {
    if (!disposed) {
      chat.dispose();
      chat=null;
      getShell().dispose();
    }
 else {
      getShell().setVisible(false);
    }
  }
}",0.6341463414634146
95253,"protected void configureShell(final Shell newShell){
  super.configureShell(newShell);
  String shellTitlePrefix=MessageLoader.getString(""String_Node_Str"");
  if (shellTitlePrefix != null && !shellTitlePrefix.equals(""String_Node_Str"")) {
    shellTitlePrefix=shellTitlePrefix + ""String_Node_Str"";
  }
  titleBarText=shellTitlePrefix + titleBarText;
  newShell.setText(titleBarText);
  image=ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(ICONS_PERSON_GIF))).createImage();
  newShell.setImage(image);
  RGB[] colors=new RGB[2];
  colors[0]=new RGB(0,0,0);
  colors[1]=new RGB(255,255,255);
  ImageData data=new ImageData(16,16,1,new PaletteData(colors));
  data.transparentPixel=0;
  blank=new Image(newShell.getDisplay(),data);
  flash=new Flash(newShell.getDisplay());
  new Thread(flash).start();
  newShell.addDisposeListener(new DisposeListener(){
    public void widgetDisposed(    DisposeEvent e){
      flash();
      if (image != null)       image.dispose();
      if (blank != null)       blank.dispose();
    }
  }
);
  newShell.addShellListener(new ShellAdapter(){
    public void shellActivated(    ShellEvent e){
      stopFlashing();
      if (!chat.isDisposed())       chat.textinput.setFocus();
    }
  }
);
}","protected void configureShell(final Shell newShell){
  super.configureShell(newShell);
  String shellTitlePrefix=MessageLoader.getString(""String_Node_Str"");
  if (shellTitlePrefix != null && !shellTitlePrefix.equals(""String_Node_Str"")) {
    shellTitlePrefix=shellTitlePrefix + ""String_Node_Str"";
  }
  titleBarText=shellTitlePrefix + titleBarText;
  newShell.setText(titleBarText);
  image=ImageDescriptor.createFromURL(UiPlugin.getDefault().find(new Path(ICONS_PERSON_GIF))).createImage();
  newShell.setImage(image);
  RGB[] colors=new RGB[2];
  colors[0]=new RGB(0,0,0);
  colors[1]=new RGB(255,255,255);
  ImageData data=new ImageData(16,16,1,new PaletteData(colors));
  data.transparentPixel=0;
  blank=new Image(newShell.getDisplay(),data);
  flash=new Flash(newShell.getDisplay());
  flashThread=new Thread(flash);
  flashThread.start();
  newShell.addDisposeListener(new DisposeListener(){
    public void widgetDisposed(    DisposeEvent e){
      flash();
      if (image != null)       image.dispose();
      if (blank != null)       blank.dispose();
    }
  }
);
  newShell.addShellListener(new ShellAdapter(){
    public void shellActivated(    ShellEvent e){
      stopFlashing();
      if (!chat.isDisposed())       chat.textinput.setFocus();
    }
  }
);
}",0.9805323798172428
95254,"public void run(){
  showMessage(""String_Node_Str"");
}","public void run(){
  if (textInputHandler != null) {
    textInputHandler.disconnect();
    chatAction.setEnabled(false);
    this.setEnabled(false);
  }
}",0.277511961722488
95255,"public Object getAdapter(Class clazz){
  if (clazz != null && clazz.equals(ITextInputHandler.class)) {
    return new ITextInputHandler(){
      public void handleTextLine(      ID userID,      String text){
        if (textInputHandler != null) {
          textInputHandler.handleTextLine(userID,text);
        }
 else         System.out.println(""String_Node_Str"" + text + ""String_Node_Str"");
      }
      public void handleStartTyping(      ID userID){
        if (textInputHandler != null) {
          textInputHandler.handleStartTyping(userID);
        }
 else         System.out.println(""String_Node_Str"");
      }
    }
;
  }
 else   if (clazz.equals(ILocalUserSettable.class)) {
    return this;
  }
 else   if (clazz.equals(IRosterViewer.class)) {
    return this;
  }
 else   if (clazz.equals(IMessageViewer.class)) {
    return this;
  }
 else   if (clazz.equals(IPresenceViewer.class)) {
    return this;
  }
 else   return null;
}","public Object getAdapter(Class clazz){
  if (clazz != null && clazz.equals(ITextInputHandler.class)) {
    return new ITextInputHandler(){
      public void handleTextLine(      ID userID,      String text){
        if (textInputHandler != null) {
          textInputHandler.handleTextLine(userID,text);
        }
 else         System.out.println(""String_Node_Str"" + text + ""String_Node_Str"");
      }
      public void handleStartTyping(      ID userID){
        if (textInputHandler != null) {
          textInputHandler.handleStartTyping(userID);
        }
 else         System.out.println(""String_Node_Str"");
      }
      public void disconnect(){
        if (textInputHandler != null) {
          textInputHandler.disconnect();
        }
 else         System.out.println(""String_Node_Str"");
      }
    }
;
  }
 else   if (clazz.equals(ILocalUserSettable.class)) {
    return this;
  }
 else   if (clazz.equals(IRosterViewer.class)) {
    return this;
  }
 else   if (clazz.equals(IMessageViewer.class)) {
    return this;
  }
 else   if (clazz.equals(IPresenceViewer.class)) {
    return this;
  }
 else   return null;
}",0.9091787439613528
95256,"public void setGroup(ID groupManager){
  groupID=groupManager;
}","public void setGroup(ID groupManager){
  if (groupManager != null) {
    groupID=groupManager;
    disconnectAction.setEnabled(true);
    chatAction.setEnabled(true);
  }
}",0.5423728813559322
95257,"private void makeActions(){
  chatAction=new Action(){
    public void run(){
      ID targetID=inputIMTarget();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  chatAction.setText(""String_Node_Str"");
  chatAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_OBJS_INFO_TSK));
  selectedDoubleClickAction=new Action(){
    public void run(){
      TreeObject treeObject=getSelectedTreeObject();
      final ID targetID=treeObject.getUserID();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      showMessage(""String_Node_Str"");
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"");
}","private void makeActions(){
  chatAction=new Action(){
    public void run(){
      ID targetID=inputIMTarget();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  chatAction.setText(""String_Node_Str"");
  chatAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_OBJS_INFO_TSK));
  chatAction.setEnabled(false);
  selectedDoubleClickAction=new Action(){
    public void run(){
      TreeObject treeObject=getSelectedTreeObject();
      final ID targetID=treeObject.getUserID();
      if (targetID != null)       openChatWindowForTarget(targetID);
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      if (textInputHandler != null) {
        textInputHandler.disconnect();
        chatAction.setEnabled(false);
        this.setEnabled(false);
      }
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"" + ((groupID == null) ? ""String_Node_Str"" : groupID.getName()));
  disconnectAction.setEnabled(false);
}",0.7845420857596612
95258,"private void fillLocalToolBar(IToolBarManager manager){
  manager.add(chatAction);
  manager.add(new Separator());
}","private void fillLocalToolBar(IToolBarManager manager){
  manager.add(chatAction);
  manager.add(new Separator());
  manager.add(disconnectAction);
}",0.8754716981132076
95259,"protected void handleGroupManagerDeparted(){
}","protected void handleGroupManagerDeparted(){
  removeAllRosterEntries();
  disposeAllChatWindows(""String_Node_Str"");
  chatAction.setEnabled(false);
  disconnectAction.setEnabled(false);
}",0.3931623931623931
95260,"private void makeActions(){
  chatAction=new Action(){
    public void run(){
      TreeObject treeObject=getSelectedTreeObject();
      if (treeObject != null)       openChatWindowForTarget(treeObject.getUserID());
    }
  }
;
  chatAction.setText(""String_Node_Str"");
  chatAction.setToolTipText(""String_Node_Str"");
  chatAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_OBJS_INFO_TSK));
  selectedDoubleClickAction=new Action(){
    public void run(){
      chatAction.run();
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      showMessage(""String_Node_Str"");
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"");
}","private void makeActions(){
  chatAction=new Action(){
    public void run(){
      TreeObject treeObject=getSelectedTreeObject();
      if (treeObject != null)       openChatWindowForTarget(treeObject.getUserID());
 else {
      }
    }
  }
;
  chatAction.setText(""String_Node_Str"");
  chatAction.setToolTipText(""String_Node_Str"");
  chatAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().getImageDescriptor(ISharedImages.IMG_OBJS_INFO_TSK));
  selectedDoubleClickAction=new Action(){
    public void run(){
      chatAction.run();
    }
  }
;
  disconnectAction=new Action(){
    public void run(){
      showMessage(""String_Node_Str"");
    }
  }
;
  disconnectAction.setText(""String_Node_Str"");
  disconnectAction.setToolTipText(""String_Node_Str"");
}",0.9895287958115184
95261,"public void handleAccept(Socket aSocket) throws Exception {
  ObjectOutputStream oStream=new ExObjectOutputStream(new BufferedOutputStream(aSocket.getOutputStream()));
  oStream.flush();
  ObjectInputStream iStream=new ExObjectInputStream(aSocket.getInputStream());
  ConnectRequestMessage req=(ConnectRequestMessage)iStream.readObject();
  if (Trace.ON && debug != null) {
    debug.msg(""String_Node_Str"" + req);
  }
  if (req == null)   throw new InvalidObjectException(INVALID_CONNECT + ""String_Node_Str"");
  URI uri=req.getTarget();
  if (uri == null)   throw new InvalidObjectException(INVALID_CONNECT + ""String_Node_Str"");
  String path=uri.getPath();
  if (path == null)   throw new InvalidObjectException(INVALID_CONNECT + ""String_Node_Str"");
  TCPServerSOContainer srs=(TCPServerSOContainer)get(path);
  debug(""String_Node_Str"" + srs.getID().getName() + ""String_Node_Str""+ uri);
  if (srs == null)   throw new InvalidObjectException(""String_Node_Str"" + path + ""String_Node_Str"");
  Client newClient=new Client(aSocket,iStream,oStream,srs.getReceiver(),srs.keepAlive);
synchronized (newClient) {
    Serializable resp=(Serializable)((ConnectionRequestHandler)srs).checkConnect(aSocket,path,req.getData(),newClient);
    oStream.writeObject(new ConnectResultMessage(resp));
    oStream.flush();
  }
}","public void handleAccept(Socket aSocket) throws Exception {
  ObjectOutputStream oStream=new ExObjectOutputStream(new BufferedOutputStream(aSocket.getOutputStream()));
  oStream.flush();
  ObjectInputStream iStream=new ExObjectInputStream(aSocket.getInputStream());
  ConnectRequestMessage req=(ConnectRequestMessage)iStream.readObject();
  if (Trace.ON && debug != null) {
    debug.msg(""String_Node_Str"" + req);
  }
  if (req == null)   throw new InvalidObjectException(INVALID_CONNECT + ""String_Node_Str"");
  URI uri=req.getTarget();
  if (uri == null)   throw new InvalidObjectException(INVALID_CONNECT + ""String_Node_Str"");
  String path=uri.getPath();
  if (path == null)   throw new InvalidObjectException(INVALID_CONNECT + ""String_Node_Str"");
  TCPServerSOContainer srs=(TCPServerSOContainer)get(path);
  if (srs == null)   throw new InvalidObjectException(""String_Node_Str"" + path + ""String_Node_Str"");
  debug(""String_Node_Str"" + srs.getID().getName() + ""String_Node_Str""+ uri);
  Client newClient=new Client(aSocket,iStream,oStream,srs.getReceiver(),srs.keepAlive);
synchronized (newClient) {
    Serializable resp=(Serializable)((ConnectionRequestHandler)srs).checkConnect(aSocket,path,req.getData(),newClient);
    oStream.writeObject(new ConnectResultMessage(resp));
    oStream.flush();
  }
}",0.9410864575363428
95262,"public void drop(DropTargetEvent event){
  if (fileTransfer.isSupportedType(event.currentDataType)) {
    String[] files=(String[])event.data;
    for (int i=0; i < files.length; i++) {
      ID target=(selectedUser == null) ? null : selectedUser.getUserID();
      File file=new File(files[i]);
      if (file.exists() && !file.isDirectory() && composite != null) {
        composite.sendFile(file.getPath(),this.view.downloaddir + file.getName(),null,target,false);
      }
    }
  }
}","public void drop(DropTargetEvent event){
  if (fileTransfer.isSupportedType(event.currentDataType)) {
    String[] files=(String[])event.data;
    for (int i=0; i < files.length; i++) {
      ID target=(selectedUser == null) ? null : selectedUser.getUserID();
      File file=new File(files[i]);
      if (file.exists() && !file.isDirectory() && composite != null) {
        composite.sendFile(file.getPath(),this.view.downloaddir + File.separatorChar + file.getName(),null,target,false);
      }
    }
  }
}",0.978894472361809
95263,"public void run(){
  Thread me=Thread.currentThread();
  while (!queue.isStopped()) {
    try {
      if (me.isInterrupted())       break;
      Thread.sleep(keepAlive / 2);
      if (me.isInterrupted())       break;
synchronized (outputStream) {
        if (System.currentTimeMillis() >= nextPingTime) {
          waitForPing=true;
          sendIt(ping);
          if (waitForPing) {
            try {
              outputStream.wait(keepAlive / 2);
            }
 catch (            InterruptedException e) {
            }
          }
          if (waitForPing) {
            throw new IOException(address + ""String_Node_Str"" + port+ ""String_Node_Str"");
          }
        }
      }
    }
 catch (    Exception e) {
      if (isClosing) {
        isClosing=false;
synchronized (Client.this) {
          Client.this.notifyAll();
        }
      }
 else {
        if (handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
          handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
        }
      }
      break;
    }
  }
}","public void run(){
  Thread me=Thread.currentThread();
  while (!queue.isStopped()) {
    try {
      if (me.isInterrupted())       break;
      Thread.sleep(keepAlive / 2);
      if (me.isInterrupted())       break;
synchronized (outputStream) {
        if (System.currentTimeMillis() >= nextPingTime) {
          waitForPing=true;
          sendIt(ping);
          if (waitForPing) {
            try {
              outputStream.wait(keepAlive / 2);
            }
 catch (            InterruptedException e) {
            }
          }
          if (waitForPing) {
            throw new IOException(address + ""String_Node_Str"" + port+ ""String_Node_Str"");
          }
        }
      }
    }
 catch (    Exception e) {
      if (isClosing) {
        isClosing=false;
synchronized (Client.this) {
          Client.this.notifyAll();
        }
      }
 else {
        if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
          handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
        }
      }
      break;
    }
  }
}",0.9995333644423704
95264,"private Thread setupPing(){
  return new Thread(new Runnable(){
    public void run(){
      Thread me=Thread.currentThread();
      while (!queue.isStopped()) {
        try {
          if (me.isInterrupted())           break;
          Thread.sleep(keepAlive / 2);
          if (me.isInterrupted())           break;
synchronized (outputStream) {
            if (System.currentTimeMillis() >= nextPingTime) {
              waitForPing=true;
              sendIt(ping);
              if (waitForPing) {
                try {
                  outputStream.wait(keepAlive / 2);
                }
 catch (                InterruptedException e) {
                }
              }
              if (waitForPing) {
                throw new IOException(address + ""String_Node_Str"" + port+ ""String_Node_Str"");
              }
            }
          }
        }
 catch (        Exception e) {
          if (isClosing) {
            isClosing=false;
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            if (handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
    }
  }
,""String_Node_Str"" + address + ""String_Node_Str""+ port);
}","private Thread setupPing(){
  return new Thread(new Runnable(){
    public void run(){
      Thread me=Thread.currentThread();
      while (!queue.isStopped()) {
        try {
          if (me.isInterrupted())           break;
          Thread.sleep(keepAlive / 2);
          if (me.isInterrupted())           break;
synchronized (outputStream) {
            if (System.currentTimeMillis() >= nextPingTime) {
              waitForPing=true;
              sendIt(ping);
              if (waitForPing) {
                try {
                  outputStream.wait(keepAlive / 2);
                }
 catch (                InterruptedException e) {
                }
              }
              if (waitForPing) {
                throw new IOException(address + ""String_Node_Str"" + port+ ""String_Node_Str"");
              }
            }
          }
        }
 catch (        Exception e) {
          if (isClosing) {
            isClosing=false;
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
    }
  }
,""String_Node_Str"" + address + ""String_Node_Str""+ port);
}",0.9996308600959763
95265,"private Thread getSendThread(){
  Thread aThread=new Thread(new Runnable(){
    public void run(){
      int msgCount=0;
      Thread me=Thread.currentThread();
      for (; ; ) {
        if (me.isInterrupted())         break;
        Serializable aMsg=(Serializable)queue.peekQueue();
        if (me.isInterrupted() || aMsg == null)         break;
        try {
          debug(""String_Node_Str"" + address + ""String_Node_Str""+ port+ ""String_Node_Str""+ aMsg);
          sendIt(aMsg);
          queue.removeHead();
          if (msgCount > maxMsg) {
synchronized (outputStream) {
              outputStream.reset();
            }
            msgCount=0;
          }
 else           msgCount++;
        }
 catch (        IOException e) {
          if (isClosing) {
            isClosing=false;
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            if (handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      debug(""String_Node_Str"" + address + ""String_Node_Str""+ port+ ""String_Node_Str"");
    }
  }
,""String_Node_Str"" + address + ""String_Node_Str""+ port);
  aThread.setPriority(SNDR_PRIORITY);
  return aThread;
}","private Thread getSendThread(){
  Thread aThread=new Thread(new Runnable(){
    public void run(){
      int msgCount=0;
      Thread me=Thread.currentThread();
      for (; ; ) {
        if (me.isInterrupted())         break;
        Serializable aMsg=(Serializable)queue.peekQueue();
        if (me.isInterrupted() || aMsg == null)         break;
        try {
          debug(""String_Node_Str"" + address + ""String_Node_Str""+ port+ ""String_Node_Str""+ aMsg);
          sendIt(aMsg);
          queue.removeHead();
          if (msgCount > maxMsg) {
synchronized (outputStream) {
              outputStream.reset();
            }
            msgCount=0;
          }
 else           msgCount++;
        }
 catch (        IOException e) {
          if (isClosing) {
            isClosing=false;
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      debug(""String_Node_Str"" + address + ""String_Node_Str""+ port+ ""String_Node_Str"");
    }
  }
,""String_Node_Str"" + address + ""String_Node_Str""+ port);
  aThread.setPriority(SNDR_PRIORITY);
  return aThread;
}",0.9996283909327388
95266,"private Thread getRcvThread(){
  Thread aThread=new Thread(new Runnable(){
    public void run(){
      Thread me=Thread.currentThread();
      for (; ; ) {
        if (me.isInterrupted())         break;
        try {
          handleRcv(readObject());
        }
 catch (        IOException e) {
          if (isClosing) {
            isClosing=false;
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            if (handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      debug(""String_Node_Str"" + address + ""String_Node_Str""+ port+ ""String_Node_Str"");
    }
  }
,""String_Node_Str"" + address + ""String_Node_Str""+ port);
  aThread.setPriority(RCVR_PRIORITY);
  return aThread;
}","private Thread getRcvThread(){
  Thread aThread=new Thread(new Runnable(){
    public void run(){
      Thread me=Thread.currentThread();
      for (; ; ) {
        if (me.isInterrupted())         break;
        try {
          handleRcv(readObject());
        }
 catch (        IOException e) {
          if (isClosing) {
            isClosing=false;
synchronized (Client.this) {
              Client.this.notifyAll();
            }
          }
 else {
            if (!handler.handleSuspectEvent(new ConnectionEvent(Client.this,e))) {
              handler.handleDisconnectEvent(new DisconnectConnectionEvent(Client.this,e,queue));
            }
          }
          break;
        }
      }
      debug(""String_Node_Str"" + address + ""String_Node_Str""+ port+ ""String_Node_Str"");
    }
  }
,""String_Node_Str"" + address + ""String_Node_Str""+ port);
  aThread.setPriority(RCVR_PRIORITY);
  return aThread;
}",0.999447818884594
95267,"protected void processDisconnect(DisconnectConnectionEvent e){
  debug(""String_Node_Str"" + e);
  try {
    ContainerMessage mess=getObjectFromBytes((byte[])e.getData());
  }
 catch (  Exception except) {
    logException(""String_Node_Str"",except);
  }
}","protected void processDisconnect(DisconnectConnectionEvent e){
  debug(""String_Node_Str"" + e);
  try {
    IAsynchConnection conn=(IAsynchConnection)e.getConnection();
    if (!conn.isConnected())     return;
    ID fromID=null;
synchronized (getGroupMembershipLock()) {
      fromID=getIDForConnection(conn);
      memberLeave(fromID,conn);
    }
    if (fromID != null)     fireContainerEvent(new SharedObjectContainerDepartedEvent(getID(),fromID));
  }
 catch (  Exception except) {
    logException(""String_Node_Str"",except);
  }
}",0.5177664974619289
95268,"public void dispose(long waittime){
  debug(""String_Node_Str"" + waittime + ""String_Node_Str"");
  isClosing=true;
  fireContainerEvent(new SharedObjectContainerDisposeEvent(getID()));
  if (groupManager != null) {
    groupManager.removeAllMembers();
    groupManager=null;
  }
  if (sharedObjectManager != null) {
    sharedObjectManager.dispose();
    sharedObjectManager=null;
  }
  if (sharedObjectThreadGroup != null) {
    sharedObjectThreadGroup.interrupt();
    sharedObjectThreadGroup=null;
  }
  if (loadingThreadGroup != null) {
    loadingThreadGroup.interrupt();
    loadingThreadGroup=null;
  }
  if (listeners != null) {
    listeners.clear();
    listeners=null;
  }
}","public void dispose(long waittime){
  debug(""String_Node_Str"" + waittime + ""String_Node_Str"");
  isClosing=true;
  fireContainerEvent(new SharedObjectContainerDisposeEvent(getID()));
  if (groupManager != null) {
    groupManager.removeAllMembers();
  }
  if (sharedObjectManager != null) {
    sharedObjectManager.dispose();
    sharedObjectManager=null;
  }
  if (sharedObjectThreadGroup != null) {
    sharedObjectThreadGroup.interrupt();
    sharedObjectThreadGroup=null;
  }
  if (loadingThreadGroup != null) {
    loadingThreadGroup.interrupt();
    loadingThreadGroup=null;
  }
  if (listeners != null) {
    listeners.clear();
    listeners=null;
  }
}",0.6984363365599404
95269,"public void run(){
  debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
  Event evt=null;
  for (; ; ) {
    if (Thread.currentThread().isInterrupted())     break;
    evt=(Event)queue.dequeue();
    if (Thread.currentThread().isInterrupted() || evt == null)     break;
    try {
      if (evt instanceof ProcEvent) {
        SOWrapper.this.svc(((ProcEvent)evt).getEvent());
      }
 else       if (evt instanceof DisposeEvent) {
        SOWrapper.this.doDestroy();
      }
    }
 catch (    Throwable t) {
      handleRuntimeException(t);
    }
  }
  if (Thread.currentThread().isInterrupted()) {
    debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
  }
 else {
    debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
  }
}","public void run(){
  debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
  Event evt=null;
  for (; ; ) {
    if (Thread.currentThread().isInterrupted())     break;
    evt=(Event)queue.dequeue();
    if (Thread.currentThread().isInterrupted() || evt == null)     break;
    try {
      if (evt instanceof ProcEvent) {
        SOWrapper.this.svc(((ProcEvent)evt).getEvent());
      }
 else       if (evt instanceof DisposeEvent) {
        SOWrapper.this.doDestroy();
      }
 else {
        SOWrapper.this.svc(evt);
      }
    }
 catch (    Throwable t) {
      handleRuntimeException(t);
    }
  }
  if (Thread.currentThread().isInterrupted()) {
    debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
  }
 else {
    debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
  }
}",0.9688096753660088
95270,"protected Thread getThread(){
  return container.getNewSharedObjectThread(sharedObjectID,new Runnable(){
    public void run(){
      debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
      Event evt=null;
      for (; ; ) {
        if (Thread.currentThread().isInterrupted())         break;
        evt=(Event)queue.dequeue();
        if (Thread.currentThread().isInterrupted() || evt == null)         break;
        try {
          if (evt instanceof ProcEvent) {
            SOWrapper.this.svc(((ProcEvent)evt).getEvent());
          }
 else           if (evt instanceof DisposeEvent) {
            SOWrapper.this.doDestroy();
          }
        }
 catch (        Throwable t) {
          handleRuntimeException(t);
        }
      }
      if (Thread.currentThread().isInterrupted()) {
        debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
      }
 else {
        debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
      }
    }
  }
);
}","protected Thread getThread(){
  return container.getNewSharedObjectThread(sharedObjectID,new Runnable(){
    public void run(){
      debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
      Event evt=null;
      for (; ; ) {
        if (Thread.currentThread().isInterrupted())         break;
        evt=(Event)queue.dequeue();
        if (Thread.currentThread().isInterrupted() || evt == null)         break;
        try {
          if (evt instanceof ProcEvent) {
            SOWrapper.this.svc(((ProcEvent)evt).getEvent());
          }
 else           if (evt instanceof DisposeEvent) {
            SOWrapper.this.doDestroy();
          }
 else {
            SOWrapper.this.svc(evt);
          }
        }
 catch (        Throwable t) {
          handleRuntimeException(t);
        }
      }
      if (Thread.currentThread().isInterrupted()) {
        debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
      }
 else {
        debug(""String_Node_Str"" + sharedObjectID + ""String_Node_Str"");
      }
    }
  }
);
}",0.971824023727138
95271,"public void dispose(long timeout){
  URI aURI=null;
  try {
    aURI=new URI(getID().getName());
  }
 catch (  Exception e) {
  }
  if (aURI != null)   group.remove(aURI.getPath());
  group=null;
  super.dispose(timeout);
}","public void dispose(long timeout){
  URI aURI=null;
  try {
    aURI=new URI(getID().getName());
  }
 catch (  Exception e) {
  }
  if (aURI != null)   group.remove(aURI.getPath());
  if (isSingle) {
    group.takeOffTheAir();
  }
  group=null;
  super.dispose(timeout);
}",0.901010101010101
95272,"protected void makeInactive(){
  this.standAloneContext.makeInactive();
  this.standAloneContext=null;
  isActive=false;
}","protected void makeInactive(){
  this.context.makeInactive();
  this.context=null;
  isActive=false;
}",0.8928571428571429
95273,"public ISharedObjectContext getContext(){
  if (isActive) {
    return null;
  }
 else   return null;
}","public ISharedObjectContext getContext(){
  if (isActive) {
    return context;
  }
 else   return null;
}",0.9569377990430622
95274,"protected void makeActive(QueueEnqueue queue){
  isActive=true;
  this.standAloneContext=new SOContext(sharedObjectID,homeContainerID,container,properties,queue);
}","protected void makeActive(QueueEnqueue queue){
  isActive=true;
  this.context=container.makeNewSharedObjectContext(this,queue);
}",0.7414965986394558
95275,"protected SOConfig makeNewSharedObjectConfig(SharedObjectDescription sd,SOContainer cont){
  ID homeID=sd.getHomeID();
  if (homeID == null)   homeID=getID();
  return new SOConfig(sd.getID(),homeID,this,sd.getProperties());
}","protected SOConfig makeNewSharedObjectConfig(SharedObjectDescription sd,ISharedObject obj){
  ID homeID=sd.getHomeID();
  if (homeID == null)   homeID=getID();
  return new SOConfig(sd.getID(),homeID,this,sd.getProperties());
}",0.9271523178807948
95276,"public SOContainer(ISharedObjectContainerConfig config){
  if (config == null)   throw new InstantiationError(""String_Node_Str"");
  this.config=config;
  groupManager=new SOContainerGMM(this,new Member(config.getID()));
  sharedObjectManager=new SOManager(this);
  loadingThreadGroup=getLoadingThreadGroup();
  sharedObjectThreadGroup=getSharedObjectThreadGroup();
  listeners=new Vector();
  receiver=new MessageReceiver();
  debug(""String_Node_Str"");
}","public SOContainer(ISharedObjectContainerConfig config){
  if (config == null)   throw new InstantiationError(""String_Node_Str"");
  this.config=config;
  groupManager=new SOContainerGMM(this,new Member(config.getID()));
  sharedObjectManager=new SOManager(this);
  loadingThreadGroup=makeLoadingThreadGroup();
  sharedObjectThreadGroup=getSharedObjectThreadGroup();
  listeners=new Vector();
  receiver=new MessageReceiver();
  debug(""String_Node_Str"");
}",0.9922992299229924
95277,"protected void handleCreateMessage(ContainerMessage mess) throws IOException {
  debug(""String_Node_Str"" + mess);
  SharedObjectDescription desc=(SharedObjectDescription)mess.getData();
  ID fromID=mess.getFromContainerID();
  ID toID=mess.getToContainerID();
  long seq=mess.getSequence();
  Object result=checkCreate(fromID,toID,seq,desc);
  if (result != null && (toID == null || toID.equals(getID()))) {
    LoadingSharedObject lso=new LoadingSharedObject(desc,result);
synchronized (getGroupMembershipLock()) {
      if (!addToLoading(lso)) {
        ID sharedObjectID=desc.getID();
        try {
          sendCreateResponse(fromID,sharedObjectID,new SharedObjectAddException(""String_Node_Str"" + sharedObjectID),desc.getIdentifier());
        }
 catch (        IOException e) {
          logException(""String_Node_Str"",e);
        }
      }
      forward(fromID,toID,mess);
      return;
    }
  }
synchronized (getGroupMembershipLock()) {
    forward(fromID,toID,mess);
  }
}","protected void handleCreateMessage(ContainerMessage mess) throws IOException {
  debug(""String_Node_Str"" + mess);
  ContainerMessage.CreateMessage create=(ContainerMessage.CreateMessage)mess.getData();
  SharedObjectDescription desc=(SharedObjectDescription)create.getData();
  ID fromID=mess.getFromContainerID();
  ID toID=mess.getToContainerID();
  long seq=mess.getSequence();
  Object result=checkCreate(fromID,toID,seq,desc);
  if (result != null) {
    LoadingSharedObject lso=new LoadingSharedObject(desc,result);
synchronized (getGroupMembershipLock()) {
      if (!addToLoading(lso)) {
        ID sharedObjectID=desc.getID();
        try {
          sendCreateResponse(fromID,sharedObjectID,new SharedObjectAddException(""String_Node_Str"" + sharedObjectID),desc.getIdentifier());
        }
 catch (        IOException e) {
          logException(""String_Node_Str"",e);
        }
      }
      forward(fromID,toID,mess);
      return;
    }
  }
synchronized (getGroupMembershipLock()) {
    forward(fromID,toID,mess);
  }
}",0.9304174950298212
95278,"protected Thread getNewSharedObjectThread(ID sharedObjectID,Runnable runnable){
  return new Thread(sharedObjectThreadGroup,runnable,getID().getName() + ""String_Node_Str"" + sharedObjectID.getName());
}","protected Thread getNewSharedObjectThread(ID sharedObjectID,Runnable runnable){
  return new Thread(sharedObjectThreadGroup,runnable,sharedObjectID.getName() + ""String_Node_Str"");
}",0.8952879581151832
95279,"protected SOWrapper makeNewSharedObjectWrapper(SharedObjectDescription sd,ISharedObject s){
  SOConfig newConfig=makeNewSharedObjectConfig(sd,this);
  return new SOWrapper(newConfig,s,this);
}","protected SOWrapper makeNewSharedObjectWrapper(SharedObjectDescription sd,ISharedObject s){
  SOConfig newConfig=makeNewSharedObjectConfig(sd,s);
  return new SOWrapper(newConfig,s,this);
}",0.9921259842519684
95280,"protected void sendMessage(ID toContainerID,ID sharedObjectID,Object message) throws IOException {
  if (message == null)   return;
  if (message instanceof Serializable)   throw new NotSerializableException(message.getClass().getName());
  sendSharedObjectMessage(toContainerID,sharedObjectID,(Serializable)message);
}","protected void sendMessage(ID toContainerID,ID sharedObjectID,Object message) throws IOException {
  if (message == null)   return;
  sendSharedObjectMessage(toContainerID,sharedObjectID,(Serializable)message);
}",0.7984934086629002
95281,"Thread getThread(){
  return new Thread(loadingThreadGroup,new Runnable(){
    public void run(){
      try {
        if (Thread.currentThread().isInterrupted() || isClosing())         throw new InterruptedException(""String_Node_Str"" + getID().getName());
        ISharedObject obj=load(description);
        SOConfig aConfig=makeSharedObjectConfig(description,obj);
        obj.init(aConfig);
        if (Thread.currentThread().isInterrupted() || isClosing())         throw new InterruptedException(""String_Node_Str"" + getID().getName());
        SOContainer.this.moveFromLoadingToActive(new SOWrapper(aConfig,obj,SOContainer.this));
      }
 catch (      Exception e) {
        SOContainer.this.removeFromLoading(getID());
        try {
          sendCreateResponse(getHomeID(),getID(),e,description.getIdentifier());
        }
 catch (        Exception e1) {
        }
      }
    }
  }
,""String_Node_Str"" + getID().getName());
}","Thread getThread(){
  return new Thread(loadingThreadGroup,new Runnable(){
    public void run(){
      try {
        if (Thread.currentThread().isInterrupted() || isClosing())         throw new InterruptedException(""String_Node_Str"" + getID().getName());
        ISharedObject obj=load(description);
        SOConfig aConfig=makeNewSharedObjectConfig(description,obj);
        obj.init(aConfig);
        if (Thread.currentThread().isInterrupted() || isClosing())         throw new InterruptedException(""String_Node_Str"" + getID().getName());
        SOContainer.this.moveFromLoadingToActive(new SOWrapper(aConfig,obj,SOContainer.this));
      }
 catch (      Exception e) {
        dumpStack(""String_Node_Str"",e);
        SOContainer.this.removeFromLoading(getID());
        try {
          sendCreateResponse(getHomeID(),getID(),e,description.getIdentifier());
        }
 catch (        Exception e1) {
          dumpStack(""String_Node_Str"",e1);
        }
      }
    }
  }
,getID().getName() + ""String_Node_Str"");
}",0.917948717948718
95282,"public static final ID makeStringID(String idstring) throws IDInstantiationException {
  Namespace n=new Namespace(StringID.class.getClassLoader(),StringID.STRINGID_NAME,StringID.STRINGID_INSTANTIATOR_CLASS,null);
  return makeID(n,new String[]{String.class.getName()},new Object[]{idstring});
}","public static final ID makeStringID(String idstring) throws IDInstantiationException {
  if (idstring == null)   throw new IDInstantiationException(""String_Node_Str"");
  Namespace n=new Namespace(StringID.class.getClassLoader(),StringID.STRINGID_NAME,StringID.STRINGID_INSTANTIATOR_CLASS,null);
  return makeID(n,new String[]{String.class.getName()},new Object[]{idstring});
}",0.879284649776453
95283,"public static String convertStringAToString(String[] strings){
  if (strings == null)   return ""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
  for (int i=0; i < strings.length; i++) {
    sb.append(strings[i]);
    if (i != (strings.length - 1))     sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","public static String convertStringAToString(String[] strings){
  if (strings == null)   return ""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
  for (int i=0; i < strings.length; i++) {
    if (strings[i] == null)     sb.append(""String_Node_Str"");
 else     sb.append(strings[i]);
    if (i != (strings.length - 1))     sb.append(""String_Node_Str"");
  }
  return sb.toString();
}",0.903954802259887
95284,"public static String convertObjectAToString(Object[] objs){
  if (objs == null)   return ""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
  for (int i=0; i < objs.length; i++) {
    sb.append(objs[i].toString());
    if (i != (objs.length - 1))     sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","public static String convertObjectAToString(Object[] objs){
  if (objs == null)   return ""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
  for (int i=0; i < objs.length; i++) {
    if (objs[i] == null)     sb.append(""String_Node_Str"");
 else     sb.append(objs[i].toString());
    if (i != (objs.length - 1))     sb.append(""String_Node_Str"");
  }
  return sb.toString();
}",0.9067431850789096
95285,"public final static Namespace getNamespaceByName(String name) throws SecurityException {
  debug(""String_Node_Str"" + name + ""String_Node_Str"");
  Namespace ns=new Namespace(null,name,null,null);
  return getNamespace(ns);
}","public final static Namespace getNamespaceByName(String name) throws SecurityException {
  debug(""String_Node_Str"" + name + ""String_Node_Str"");
  Namespace ns=new Namespace(null,name,name,null);
  return getNamespace(ns);
}",0.9865470852017936
95286,"protected boolean namespaceEquals(BaseID o){
  if (!(o instanceof LongID))   return false;
  LongID obj=(LongID)o;
  return value.equals(obj);
}","protected boolean namespaceEquals(BaseID o){
  if (!(o instanceof LongID))   return false;
  LongID obj=(LongID)o;
  return value.equals(obj.value);
}",0.979591836734694
95287,"public void joinGroup(ID remoteSpace,Object data) throws SharedObjectContainerJoinException {
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    ISynchAsynchConnection aConnection=getClientConnection(remoteSpace,data);
    if (aConnection == null) {
      ConnectException c=new ConnectException(""String_Node_Str"" + ""String_Node_Str"" + remoteSpace.getName());
      throw c;
    }
    ContainerMessage response;
synchronized (connectLock) {
      if (isConnected()) {
        killConnection(aConnection);
        aConnection=null;
        ConnectException c=new ConnectException(""String_Node_Str"" + getGroupID());
        throw c;
      }
      if (isConnecting()) {
        killConnection(aConnection);
        aConnection=null;
        ConnectException c=new ConnectException(""String_Node_Str"");
        throw c;
      }
      connectionState=CONNECTING;
      connection=aConnection;
    }
synchronized (aConnection) {
      try {
        Object connectData=getConnectData(remoteSpace,data);
        response=(ContainerMessage)aConnection.connect(remoteSpace,connectData,0);
      }
 catch (      IOException e) {
synchronized (connectLock) {
          killConnection(aConnection);
          if (connection != aConnection) {
            aConnection=null;
            throw e;
          }
          connectionState=UNCONNECTED;
          connection=null;
          remoteServerID=null;
        }
        throw e;
      }
synchronized (connectLock) {
        if (connection != aConnection) {
          killConnection(aConnection);
          aConnection=null;
          ConnectException c=new ConnectException(""String_Node_Str"");
          throw c;
        }
        ID serverID=null;
        try {
          serverID=acceptNewServer(response);
        }
 catch (        Exception e) {
          killConnection(aConnection);
          aConnection=null;
          connection=null;
          remoteServerID=null;
          connectionState=UNCONNECTED;
          ConnectException c=new ConnectException(""String_Node_Str"");
          throw c;
        }
        aConnection.start();
        remoteServerID=serverID;
        connectionState=CONNECTED;
      }
    }
  }
 catch (  Exception e) {
    throw new SharedObjectContainerJoinException(""String_Node_Str"",e);
  }
}","public void joinGroup(ID remote,Object data) throws SharedObjectContainerJoinException {
  try {
    if (isClosing)     throw new IllegalStateException(""String_Node_Str"");
    ISynchAsynchConnection aConnection=getClientConnection(remote,data);
    if (aConnection == null) {
      ConnectException c=new ConnectException(""String_Node_Str"" + ""String_Node_Str"" + remote.getName());
      throw c;
    }
    ContainerMessage response;
synchronized (connectLock) {
      if (isConnected()) {
        killConnection(aConnection);
        aConnection=null;
        ConnectException c=new ConnectException(""String_Node_Str"" + getGroupID());
        throw c;
      }
      if (isConnecting()) {
        killConnection(aConnection);
        aConnection=null;
        ConnectException c=new ConnectException(""String_Node_Str"");
        throw c;
      }
      connectionState=CONNECTING;
      connection=aConnection;
    }
synchronized (aConnection) {
      try {
        Object connectData=getConnectData(remote,data);
        response=(ContainerMessage)aConnection.connect(remote,connectData,0);
      }
 catch (      IOException e) {
synchronized (connectLock) {
          killConnection(aConnection);
          if (connection != aConnection) {
            aConnection=null;
            throw e;
          }
          connectionState=UNCONNECTED;
          connection=null;
          remoteServerID=null;
        }
        throw e;
      }
synchronized (connectLock) {
        if (connection != aConnection) {
          killConnection(aConnection);
          aConnection=null;
          ConnectException c=new ConnectException(""String_Node_Str"");
          throw c;
        }
        ID serverID=null;
        try {
          serverID=acceptNewServer(response);
        }
 catch (        Exception e) {
          killConnection(aConnection);
          aConnection=null;
          connection=null;
          remoteServerID=null;
          connectionState=UNCONNECTED;
          ConnectException c=new ConnectException(""String_Node_Str"");
          throw c;
        }
        aConnection.start();
        remoteServerID=serverID;
        connectionState=CONNECTED;
      }
    }
  }
 catch (  Exception e) {
    throw new SharedObjectContainerJoinException(""String_Node_Str"",e);
  }
}",0.994537906925934
95288,"public static Map<Integer,Set<String>> of(String resource){
  Map<Integer,Set<String>> resourceItemsLengthMap=new HashMap<Integer,Set<String>>();
  Scanner sc=new Scanner(ResourceLoader.class.getResourceAsStream(File.separator + resource),""String_Node_Str"");
  while (sc.hasNext()) {
    String element=sc.next();
    if (!resourceItemsLengthMap.containsKey(element.length())) {
      resourceItemsLengthMap.put(element.length(),new HashSet<String>());
    }
    resourceItemsLengthMap.get(element.length()).add(element);
  }
  return resourceItemsLengthMap;
}","public static Map<Integer,Set<String>> of(String resource){
  Map<Integer,Set<String>> resourceItemsLengthMap=new HashMap<Integer,Set<String>>();
  Scanner sc=new Scanner(ResourceLoader.class.getResourceAsStream(""String_Node_Str"" + resource),""String_Node_Str"");
  while (sc.hasNext()) {
    String element=sc.next();
    if (!resourceItemsLengthMap.containsKey(element.length())) {
      resourceItemsLengthMap.put(element.length(),new HashSet<String>());
    }
    resourceItemsLengthMap.get(element.length()).add(element);
  }
  return resourceItemsLengthMap;
}",0.9723953695458591
95289,"/** 
 * @param units the units
 * @param value the value
 */
private void setValueProgrammatically(String units,double value){
  double absValue;
  Slider slider=getRealComponent();
  if (units.equalsIgnoreCase(ValueSets.Measure.percent.rcValue())) {
    if (value < 0 || 100 < value) {
      throwInvalidValueMessage();
    }
    absValue=slider.getMin() + value * ((slider.getMax() - slider.getMin())) * 0.01;
  }
 else {
    absValue=value;
  }
  double closestPossibleValue=absValue;
  double incr=slider.getMajorTickUnit() / (slider.getMinorTickCount() + 1);
  double val=slider.getMin();
  while (val < absValue) {
    val+=incr;
  }
  final double valueToSet;
  if (!slider.snapToTicksProperty().get()) {
    valueToSet=absValue;
  }
 else {
    valueToSet=(val - absValue) <= (absValue - (val - incr)) ? val : val - incr;
  }
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",(Callable<Void>)() -> {
    slider.setValue(valueToSet);
    LOG.warn(""String_Node_Str"" + getRealComponent());
    return null;
  }
);
}","/** 
 * @param units the units
 * @param value the value
 */
private void setValueProgrammatically(String units,double value){
  double absValue;
  Slider slider=getRealComponent();
  if (units.equalsIgnoreCase(ValueSets.Measure.percent.rcValue())) {
    if (value < 0 || 100 < value) {
      throwInvalidValueMessage();
    }
    absValue=slider.getMin() + value * ((slider.getMax() - slider.getMin())) * 0.01;
  }
 else {
    absValue=value;
  }
  double closestPossibleValue=absValue;
  double incr=slider.getMajorTickUnit() / (slider.getMinorTickCount() + 1);
  double val=slider.getMin();
  while (val < absValue) {
    val+=incr;
  }
  final double valueToSet;
  if (!slider.snapToTicksProperty().get()) {
    valueToSet=absValue;
  }
 else {
    valueToSet=(val - absValue) <= (absValue - (val - incr)) ? val : val - incr;
  }
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",(Callable<Void>)() -> {
    slider.setValue(valueToSet);
    return null;
  }
);
}",0.9731343283582088
95290,"/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part  of the component (e.g. tree node, table cell, etc)   rather than the overall component itself. May be   <code>null</code>.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions The click options 
 * @throws StepExecutionException If the click delay is interrupted or the  event confirmation receives a timeout. 
 */
private void moveImpl(Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible()) {
    ensureComponentVisible((Component)graphicsComponent,constraints);
    m_eventFlusher.flush();
  }
  Component component=(Component)graphicsComponent;
  Rectangle bounds=new Rectangle(getLocation(component,new Point(0,0)));
  bounds.width=component.getWidth();
  bounds.height=component.getHeight();
  if (component instanceof Frame) {
    Frame window=(Frame)component;
    if (bounds.x < 0 && checkExtendedState(window,Frame.MAXIMIZED_HORIZ)) {
      bounds.width+=2 * bounds.x;
      bounds.x=0;
    }
    if (bounds.y < 0 && checkExtendedState(window,Frame.MAXIMIZED_VERT)) {
      bounds.height+=2 * bounds.y;
      bounds.y=0;
    }
  }
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    IRobotEventConfirmer confirmer=null;
    if (clickOptions.isConfirmClick()) {
      InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
      confirmer=m_interceptor.intercept(options);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      Component root=SwingUtilities.getRoot(component);
      Component c=(root != null) ? root : component;
      startpoint=getLocation(c,null);
    }
    Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,clickOptions.getStepMovement(),clickOptions.getFirstHorizontal());
    for (int i=0; i < mouseMove.length; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      m_eventFlusher.flush();
    }
    if (confirmer != null) {
      confirmer.waitToConfirm(component,new MouseMovedAwtEventMatcher());
    }
  }
}","/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part  of the component (e.g. tree node, table cell, etc)   rather than the overall component itself. May be   <code>null</code>.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions The click options 
 * @throws StepExecutionException If the click delay is interrupted or the  event confirmation receives a timeout. 
 */
private void moveImpl(Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible()) {
    ensureComponentVisibility(graphicsComponent,constraints,xPos,xAbsolute,yPos,yAbsolute);
  }
  Component component=(Component)graphicsComponent;
  Rectangle bounds=new Rectangle(getLocation(component,new Point(0,0)));
  bounds.width=component.getWidth();
  bounds.height=component.getHeight();
  if (component instanceof Frame) {
    Frame window=(Frame)component;
    if (bounds.x < 0 && checkExtendedState(window,Frame.MAXIMIZED_HORIZ)) {
      bounds.width+=2 * bounds.x;
      bounds.x=0;
    }
    if (bounds.y < 0 && checkExtendedState(window,Frame.MAXIMIZED_VERT)) {
      bounds.height+=2 * bounds.y;
      bounds.y=0;
    }
  }
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    IRobotEventConfirmer confirmer=null;
    if (clickOptions.isConfirmClick()) {
      InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
      confirmer=m_interceptor.intercept(options);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      Component root=SwingUtilities.getRoot(component);
      Component c=(root != null) ? root : component;
      startpoint=getLocation(c,null);
    }
    Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,clickOptions.getStepMovement(),clickOptions.getFirstHorizontal());
    for (int i=0; i < mouseMove.length; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      m_eventFlusher.flush();
    }
    if (confirmer != null) {
      confirmer.waitToConfirm(component,new MouseMovedAwtEventMatcher());
    }
  }
}",0.9837763203313772
95291,"/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map<String,String> parameters,String autServerClasspath){
  String env=parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
    if (autCommunicator != null) {
      serverPort=String.valueOf(autCommunicator.getLocalPort());
    }
    env+=ENV_SEPARATOR + Constants.AUT_SERVER_PORT + ""String_Node_Str""+ serverPort;
    env+=ENV_SEPARATOR + Constants.AUT_SERVER_CLASSPATH + ""String_Node_Str""+ autServerClasspath;
    env+=ENV_SEPARATOR + Constants.AUT_SERVER_NAME + ""String_Node_Str""+ getServerClassName();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}","/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map<String,String> parameters,String autServerClasspath){
  String env=parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
    if (autCommunicator != null) {
      serverPort=String.valueOf(autCommunicator.getLocalPort());
    }
    env+=ENV_SEPARATOR + Constants.AUT_SERVER_PORT + ""String_Node_Str""+ serverPort;
    env+=ENV_SEPARATOR + Constants.AUT_SERVER_CLASSPATH + ""String_Node_Str""+ autServerClasspath;
    env+=ENV_SEPARATOR + Constants.AUT_SERVER_NAME + ""String_Node_Str""+ getServerClassName();
    env+=ENV_SEPARATOR + Constants.AUT_JUB_INSTALL_DIRECTORY + ""String_Node_Str""+ getInstallDir();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}",0.967741935483871
95292,"/** 
 * @param parameters The AUT Configuration parameters.
 * @param valueSeparator The string to use to separate property names from property values.
 * @return the list of properties.
 */
private List<String> getConnectionProperties(Map<String,String> parameters,String valueSeparator){
  List<String> props=new ArrayList<String>();
  StringBuffer sb=new StringBuffer();
  sb=new StringBuffer();
  sb.append(AutConfigConstants.KEYBOARD_LAYOUT).append(valueSeparator).append(parameters.get(AutConfigConstants.KEYBOARD_LAYOUT));
  props.add(sb.toString());
  sb=new StringBuffer();
  sb.append(AutConfigConstants.AUT_AGENT_HOST).append(valueSeparator).append(parameters.get(AutConfigConstants.AUT_AGENT_HOST));
  props.add(sb.toString());
  sb=new StringBuffer();
  sb.append(AutConfigConstants.AUT_AGENT_PORT).append(valueSeparator).append(parameters.get(AutConfigConstants.AUT_AGENT_PORT));
  props.add(sb.toString());
  sb=new StringBuffer();
  sb.append(AutConfigConstants.AUT_NAME).append(valueSeparator).append(parameters.get(AutConfigConstants.AUT_NAME));
  props.add(sb.toString());
  return props;
}","/** 
 * @param parameters The AUT Configuration parameters.
 * @param valueSeparator The string to use to separate property names from property values.
 * @return the list of properties.
 */
private List<String> getConnectionProperties(Map<String,String> parameters,String valueSeparator){
  List<String> props=new ArrayList<String>();
  StringBuffer sb=new StringBuffer();
  sb=new StringBuffer();
  sb.append(AutConfigConstants.KEYBOARD_LAYOUT).append(valueSeparator).append(parameters.get(AutConfigConstants.KEYBOARD_LAYOUT));
  props.add(sb.toString());
  sb=new StringBuffer();
  sb.append(AutConfigConstants.AUT_AGENT_HOST).append(valueSeparator).append(parameters.get(AutConfigConstants.AUT_AGENT_HOST));
  props.add(sb.toString());
  sb=new StringBuffer();
  sb.append(AutConfigConstants.AUT_AGENT_PORT).append(valueSeparator).append(parameters.get(AutConfigConstants.AUT_AGENT_PORT));
  props.add(sb.toString());
  sb=new StringBuffer();
  sb.append(AutConfigConstants.AUT_NAME).append(valueSeparator).append(parameters.get(AutConfigConstants.AUT_NAME));
  props.add(sb.toString());
  sb=new StringBuffer();
  sb.append(Constants.AUT_JUB_INSTALL_DIRECTORY).append(valueSeparator).append(getInstallDir());
  props.add(sb.toString());
  return props;
}",0.9366554054054054
95293,"/** 
 * {@inheritDoc}
 */
protected String[] createCmdArray(String baseCmd,Map<String,String> parameters){
  List<String> cmds=new Vector<String>();
  cmds.add(baseCmd);
  StringBuffer autServerClasspath=new StringBuffer();
  createServerClasspath(autServerClasspath);
  List<String> autAgentArgs=new ArrayList<String>();
  autAgentArgs.add(String.valueOf(parameters.get(AutConfigConstants.AUT_AGENT_HOST)));
  autAgentArgs.add(String.valueOf(parameters.get(AutConfigConstants.AUT_AGENT_PORT)));
  autAgentArgs.add(String.valueOf(parameters.get(AutConfigConstants.AUT_NAME)));
  if (!isRunningFromExecutable(parameters)) {
    createAutServerLauncherClasspath(cmds,autServerClasspath,parameters);
    createAutServerClasspath(autServerClasspath,cmds,parameters);
    cmds.addAll(autAgentArgs);
    cmds.add(CommandConstants.RC_COMMON_AGENT_INACTIVE);
  }
 else {
    String serverBasePath=createServerBasePath();
    autServerClasspath.append(PATH_SEPARATOR).append(serverBasePath).append(PATH_SEPARATOR).append(getRcBundleClassPath());
    m_autServerClasspath=autServerClasspath.toString();
  }
  cmds.addAll(createAutArguments(parameters));
  return cmds.toArray(new String[cmds.size()]);
}","/** 
 * {@inheritDoc}
 */
protected String[] createCmdArray(String baseCmd,Map<String,String> parameters){
  List<String> cmds=new Vector<String>();
  cmds.add(baseCmd);
  StringBuffer autServerClasspath=new StringBuffer();
  createServerClasspath(autServerClasspath);
  List<String> autAgentArgs=new ArrayList<String>();
  autAgentArgs.add(String.valueOf(parameters.get(AutConfigConstants.AUT_AGENT_HOST)));
  autAgentArgs.add(String.valueOf(parameters.get(AutConfigConstants.AUT_AGENT_PORT)));
  autAgentArgs.add(String.valueOf(parameters.get(AutConfigConstants.AUT_NAME)));
  if (!isRunningFromExecutable(parameters)) {
    createAutServerLauncherClasspath(cmds,autServerClasspath,parameters);
    createAutServerClasspath(autServerClasspath,cmds,parameters);
    cmds.addAll(autAgentArgs);
    cmds.add(CommandConstants.RC_COMMON_AGENT_INACTIVE);
  }
 else {
    String serverBasePath=createServerBasePath();
    autServerClasspath.append(PATH_SEPARATOR).append(serverBasePath).append(PATH_SEPARATOR).append(getRcBundleClassPath());
    m_autServerClasspath=autServerClasspath.toString();
  }
  cmds.add(getInstallDir().getAbsolutePath());
  cmds.addAll(createAutArguments(parameters));
  return cmds.toArray(new String[cmds.size()]);
}",0.980682285244554
95294,"/** 
 * Creates the arguments array for AutServer, <br> saves the current ClassLoader, <br> calls the main-method of the AUTServerLauncher, <br> reactivates the saved ClassLoader.
 * @param agentArguments String agentArguments
 * @param instrumentation a java.lang.instrument.Instrumentation instance
 * @throws ClassNotFoundException 
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 * @throws InvocationTargetException 
 * @throws IllegalAccessException 
 * @throws IllegalArgumentException If reflection calls fail.
 * @throws MalformedURLException If any entry of the AUT Server classpath cannot be  parsed to a URL.
 */
public static void premain(String agentArguments,Instrumentation instrumentation) throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, MalformedURLException {
  String autServerClassPath=System.getenv(Constants.AUT_SERVER_CLASSPATH);
  String[] args=new String[Constants.MIN_ARGS_REQUIRED];
  args[Constants.ARG_SERVERPORT]=System.getenv(Constants.AUT_SERVER_PORT);
  args[Constants.ARG_AUTMAIN]=Constants.AUT_MAIN;
  args[Constants.ARG_AUTSERVER_CLASSPATH]=autServerClassPath;
  args[Constants.ARG_AUTSERVER_NAME]=System.getenv(Constants.AUT_SERVER_NAME);
  args[Constants.ARG_REG_HOST]=System.getenv(AutConfigConstants.AUT_AGENT_HOST);
  args[Constants.ARG_REG_PORT]=System.getenv(AutConfigConstants.AUT_AGENT_PORT);
  args[Constants.ARG_AUT_NAME]=System.getenv(AutConfigConstants.AUT_NAME);
  args[Constants.ARG_AGENT_SET]=CommandConstants.RC_COMMON_AGENT_ACTIVE;
  String[] fileNames=autServerClassPath.split(System.getProperty(""String_Node_Str""));
  URL[] urls=new URL[fileNames.length];
  for (int i=0; i < fileNames.length; i++) {
    urls[i]=new File(fileNames[i]).toURI().toURL();
  }
  final ClassLoader oldContextClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    ClassLoader autServerLauncherLoader=new URLClassLoader(urls);
    Class<?> autServerLauncherClass=autServerLauncherLoader.loadClass(CommandConstants.AUT_SERVER_LAUNCHER);
    Method mainMethod=autServerLauncherClass.getMethod(Constants.MAIN_METHOD_NAME,String[].class);
    mainMethod.invoke(null,new Object[]{args});
  }
  finally {
    Thread.currentThread().setContextClassLoader(oldContextClassLoader);
  }
}","/** 
 * Creates the arguments array for AutServer, <br> saves the current ClassLoader, <br> calls the main-method of the AUTServerLauncher, <br> reactivates the saved ClassLoader.
 * @param agentArguments String agentArguments
 * @param instrumentation a java.lang.instrument.Instrumentation instance
 * @throws ClassNotFoundException 
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 * @throws InvocationTargetException 
 * @throws IllegalAccessException 
 * @throws IllegalArgumentException If reflection calls fail.
 * @throws MalformedURLException If any entry of the AUT Server classpath cannot be  parsed to a URL.
 */
public static void premain(String agentArguments,Instrumentation instrumentation) throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, MalformedURLException {
  String autServerClassPath=System.getenv(Constants.AUT_SERVER_CLASSPATH);
  String[] args=new String[Constants.MIN_ARGS_REQUIRED];
  args[Constants.ARG_SERVERPORT]=System.getenv(Constants.AUT_SERVER_PORT);
  args[Constants.ARG_AUTMAIN]=Constants.AUT_MAIN;
  args[Constants.ARG_AUTSERVER_CLASSPATH]=autServerClassPath;
  args[Constants.ARG_AUTSERVER_NAME]=System.getenv(Constants.AUT_SERVER_NAME);
  args[Constants.ARG_REG_HOST]=System.getenv(AutConfigConstants.AUT_AGENT_HOST);
  args[Constants.ARG_REG_PORT]=System.getenv(AutConfigConstants.AUT_AGENT_PORT);
  args[Constants.ARG_AUT_NAME]=System.getenv(AutConfigConstants.AUT_NAME);
  args[Constants.ARG_AGENT_SET]=CommandConstants.RC_COMMON_AGENT_ACTIVE;
  args[Constants.ARG_INSTALLATION_DIR]=System.getenv(Constants.AUT_JUB_INSTALL_DIRECTORY);
  String[] fileNames=autServerClassPath.split(System.getProperty(""String_Node_Str""));
  URL[] urls=new URL[fileNames.length];
  for (int i=0; i < fileNames.length; i++) {
    urls[i]=new File(fileNames[i]).toURI().toURL();
  }
  final ClassLoader oldContextClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    ClassLoader autServerLauncherLoader=new URLClassLoader(urls);
    Class<?> autServerLauncherClass=autServerLauncherLoader.loadClass(CommandConstants.AUT_SERVER_LAUNCHER);
    Method mainMethod=autServerLauncherClass.getMethod(Constants.MAIN_METHOD_NAME,String[].class);
    mainMethod.invoke(null,new Object[]{args});
  }
  finally {
    Thread.currentThread().setContextClassLoader(oldContextClassLoader);
  }
}",0.9809742839222244
95295,"/** 
 * puts the given arguments to member variables
 * @param args the args given to main() 
 */
protected void setArgs(String args[]){
  m_autMainClassName=args[Constants.ARG_AUTMAIN];
  m_autAgentHost=args[Constants.ARG_REG_HOST];
  m_autAgentPort=args[Constants.ARG_REG_PORT];
  m_autID=args[Constants.ARG_AUT_NAME];
  int numberAutArgs=args.length - Constants.MIN_ARGS_REQUIRED;
  m_autArgs=new String[numberAutArgs];
  for (int i=0; i < numberAutArgs; i++) {
    m_autArgs[i]=args[Constants.MIN_ARGS_REQUIRED + i];
  }
  if (args.length == Constants.MIN_ARGS_REQUIRED && args[Constants.ARG_AGENT_SET].equals(CommandConstants.RC_COMMON_AGENT_ACTIVE)) {
    m_isAgentSet=true;
  }
}","/** 
 * puts the given arguments to member variables
 * @param args the args given to main() 
 */
protected void setArgs(String args[]){
  m_autMainClassName=args[Constants.ARG_AUTMAIN];
  m_autAgentHost=args[Constants.ARG_REG_HOST];
  m_autAgentPort=args[Constants.ARG_REG_PORT];
  m_autID=args[Constants.ARG_AUT_NAME];
  m_installationDir=args[Constants.ARG_INSTALLATION_DIR];
  int numberAutArgs=args.length - Constants.MIN_ARGS_REQUIRED;
  m_autArgs=new String[numberAutArgs];
  for (int i=0; i < numberAutArgs; i++) {
    m_autArgs[i]=args[Constants.MIN_ARGS_REQUIRED + i];
  }
  if (args.length == Constants.MIN_ARGS_REQUIRED && args[Constants.ARG_AGENT_SET].equals(CommandConstants.RC_COMMON_AGENT_ACTIVE)) {
    m_isAgentSet=true;
  }
}",0.9594405594405594
95296,"/** 
 * Initializes the classloader of the user-supplied jars 
 */
private void initExternalLoader(){
  try {
    String start=AUTServer.class.getProtectionDomain().getCodeSource().getLocation().getPath();
    if (System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
      start=start.substring(1,start.length());
    }
    start=start.replaceFirst(""String_Node_Str"",""String_Node_Str"");
    File dir=new File(start);
    File[] res=dir.listFiles(new FilenameFilter(){
      public boolean accept(      File directory,      String name){
        return name.endsWith(""String_Node_Str"");
      }
    }
);
    if (res == null) {
      return;
    }
    ArrayList<URL> urls=new ArrayList<URL>();
    for (int i=0; i < res.length; i++) {
      try {
        urls.add(res[i].toURI().toURL());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (!urls.isEmpty()) {
      m_externalLoader=new URLClassLoader(urls.toArray(new URL[0]));
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Initializes the classloader of the user-supplied jars 
 */
private void initExternalLoader(){
  try {
    String start=null;
    if (StringUtils.isNotEmpty(m_installationDir)) {
      start=m_installationDir + StringConstants.SLASH + Constants.EXTERNAL_JARS_NAME;
    }
    if (StringUtils.isBlank(start)) {
      start=AUTServer.class.getProtectionDomain().getCodeSource().getLocation().getPath();
      if (System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
        start=start.substring(1,start.length());
      }
      start=start.replaceFirst(""String_Node_Str"",Constants.EXTERNAL_JARS_NAME);
    }
    File dir=new File(start);
    File[] res=dir.listFiles(new FilenameFilter(){
      public boolean accept(      File directory,      String name){
        return name.endsWith(""String_Node_Str"");
      }
    }
);
    if (res == null) {
      return;
    }
    ArrayList<URL> urls=new ArrayList<URL>();
    for (int i=0; i < res.length; i++) {
      try {
        urls.add(res[i].toURI().toURL());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (!urls.isEmpty()) {
      m_externalLoader=new URLClassLoader(urls.toArray(new URL[0]));
    }
  }
 catch (  Exception e) {
  }
}",0.88272157564906
95297,"/** 
 * initializes the AUTServer. <br> 1. create communicator <br> 2. connect to client <br> 3. register shutdown hook, not yet <br> 4. register a AWTEventListener, not yet <br> 5. load the AUT <br> 6. send message AUTServerReady <br> In case of an error in step >2. send an AUTServerStateMessage with an error code
 * @param isRcpAccessible true, if this method was called by RcpAccessor Plug-in
 */
public void start(boolean isRcpAccessible){
  m_isRcpAccessible=isRcpAccessible;
  try {
    IRegisterAut autReg=parseAutReg();
    if (autReg == null) {
      String errorMessage=""String_Node_Str"";
      log.error(errorMessage);
      sendExitReason(errorMessage,AUTServerExitConstants.EXIT_MISSING_AGENT_INFO);
    }
    if (!isRcpAccessible && !isAgentSet()) {
      loadAUT();
    }
    if (m_isAgentSet || isRcpAccessible) {
      setAutThread(Thread.currentThread());
    }
    if (m_iteCommunicator != null) {
      m_iteCommunicator.send(new AUTServerStateMessage(AUTServerStateMessage.READY));
    }
 else {
      new Thread(""String_Node_Str""){
        public void run(){
          AUTStartCommand startCommand=new AUTStartCommand();
          startCommand.setMessage(new AUTStartMessage());
          startCommand.execute();
        }
      }
.start();
    }
    while ((getAutThread() == null || !getAutThread().isAlive()) && !isAutRunning()) {
      try {
        Thread.sleep(TimingConstantsServer.POLLING_DELAY_AUT_START);
      }
 catch (      InterruptedException e) {
      }
    }
    if (autReg != null) {
      registerAutinAgent(autReg);
    }
  }
 catch (  IllegalArgumentException iae) {
    log.error(""String_Node_Str"",iae);
    System.exit(AUTServerExitConstants.EXIT_INVALID_ARGS);
  }
catch (  CommunicationException ce) {
    log.error(""String_Node_Str"",ce);
    System.exit(AUTServerExitConstants.EXIT_COMMUNICATION_ERROR);
  }
catch (  SecurityException se) {
    log.error(""String_Node_Str"",se);
    System.exit(AUTServerExitConstants.EXIT_SECURITY_VIOLATION_REFLECTION);
  }
catch (  ClassNotFoundException cnfe) {
    sendExitReason(cnfe,AUTServerStateMessage.AUT_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  NoSuchMethodException nsme) {
    sendExitReason(nsme,AUTServerStateMessage.MAIN_METHOD_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  UnsupportedClassVersionError ucve) {
    sendExitReason(ucve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_AUT_WRONG_CLASS_VERSION);
  }
catch (  JBVersionException ve) {
    sendExitReason(ve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_UNKNOWN_ITE_CLIENT);
  }
}","/** 
 * initializes the AUTServer. <br> 1. create communicator <br> 2. connect to client <br> 3. register shutdown hook, not yet <br> 4. register a AWTEventListener, not yet <br> 5. load the AUT <br> 6. send message AUTServerReady <br> In case of an error in step >2. send an AUTServerStateMessage with an error code
 * @param isRcpAccessible true, if this method was called by RcpAccessor Plug-in
 */
public void start(boolean isRcpAccessible){
  initExternalLoader();
  m_isRcpAccessible=isRcpAccessible;
  try {
    IRegisterAut autReg=parseAutReg();
    if (autReg == null) {
      String errorMessage=""String_Node_Str"";
      log.error(errorMessage);
      sendExitReason(errorMessage,AUTServerExitConstants.EXIT_MISSING_AGENT_INFO);
    }
    if (!isRcpAccessible && !isAgentSet()) {
      loadAUT();
    }
    if (m_isAgentSet || isRcpAccessible) {
      setAutThread(Thread.currentThread());
    }
    if (m_iteCommunicator != null) {
      m_iteCommunicator.send(new AUTServerStateMessage(AUTServerStateMessage.READY));
    }
 else {
      new Thread(""String_Node_Str""){
        public void run(){
          AUTStartCommand startCommand=new AUTStartCommand();
          startCommand.setMessage(new AUTStartMessage());
          startCommand.execute();
        }
      }
.start();
    }
    while ((getAutThread() == null || !getAutThread().isAlive()) && !isAutRunning()) {
      try {
        Thread.sleep(TimingConstantsServer.POLLING_DELAY_AUT_START);
      }
 catch (      InterruptedException e) {
      }
    }
    if (autReg != null) {
      registerAutinAgent(autReg);
    }
  }
 catch (  IllegalArgumentException iae) {
    log.error(""String_Node_Str"",iae);
    System.exit(AUTServerExitConstants.EXIT_INVALID_ARGS);
  }
catch (  CommunicationException ce) {
    log.error(""String_Node_Str"",ce);
    System.exit(AUTServerExitConstants.EXIT_COMMUNICATION_ERROR);
  }
catch (  SecurityException se) {
    log.error(""String_Node_Str"",se);
    System.exit(AUTServerExitConstants.EXIT_SECURITY_VIOLATION_REFLECTION);
  }
catch (  ClassNotFoundException cnfe) {
    sendExitReason(cnfe,AUTServerStateMessage.AUT_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  NoSuchMethodException nsme) {
    sendExitReason(nsme,AUTServerStateMessage.MAIN_METHOD_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  UnsupportedClassVersionError ucve) {
    sendExitReason(ucve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_AUT_WRONG_CLASS_VERSION);
  }
catch (  JBVersionException ve) {
    sendExitReason(ve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_UNKNOWN_ITE_CLIENT);
  }
}",0.9956140350877192
95298,"/** 
 * Initializes the AUT Server for the host application.
 * @param display The Display to use for the AUT Server.
 * @return the AUTServer instance
 */
private AUTServer initAutServer(Display display){
  AUTServer instance=AUTServer.getInstance(CommandConstants.AUT_SWT_SERVER);
  ((SwtAUTServer)instance).setDisplay(display);
  instance.setAutAgentHost(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_HOST));
  instance.setAutAgentPort(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_PORT));
  instance.setAutID(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_NAME));
  instance.start(true);
  return instance;
}","/** 
 * Initializes the AUT Server for the host application.
 * @param display The Display to use for the AUT Server.
 * @return the AUTServer instance
 */
private AUTServer initAutServer(Display display){
  AUTServer instance=AUTServer.getInstance(CommandConstants.AUT_SWT_SERVER);
  ((SwtAUTServer)instance).setDisplay(display);
  instance.setAutAgentHost(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_HOST));
  instance.setAutAgentPort(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_PORT));
  instance.setAutID(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_NAME));
  instance.setInstallationDir(EnvironmentUtils.getProcessOrSystemProperty(Constants.AUT_JUB_INSTALL_DIRECTORY));
  instance.start(true);
  return instance;
}",0.8915824915824916
95299,"/** 
 * Initializes the AUT Server for the host application.
 * @param display The Display to use for the AUT Server.
 * @return the AUTServer instance
 */
private AUTServer initAutServer(Display display){
  AUTServer instance=AUTServer.getInstance(CommandConstants.AUT_SWT_SERVER);
  ((SwtAUTServer)instance).setDisplay(display);
  instance.setAutAgentHost(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_HOST));
  instance.setAutAgentPort(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_PORT));
  instance.setAutID(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_NAME));
  instance.start(true);
  return instance;
}","/** 
 * Initializes the AUT Server for the host application.
 * @param display The Display to use for the AUT Server.
 * @return the AUTServer instance
 */
private AUTServer initAutServer(Display display){
  AUTServer instance=AUTServer.getInstance(CommandConstants.AUT_SWT_SERVER);
  ((SwtAUTServer)instance).setDisplay(display);
  instance.setAutAgentHost(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_HOST));
  instance.setAutAgentPort(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_PORT));
  instance.setAutID(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_NAME));
  instance.setInstallationDir(EnvironmentUtils.getProcessOrSystemProperty(Constants.AUT_JUB_INSTALL_DIRECTORY));
  instance.start(true);
  return instance;
}",0.8915824915824916
95300,"/** 
 * Start the SwtAUTServer by connecting with the AUT agent.
 * @param display The SWT display.
 * @return True, if the AUTServer is already running, otherwise false.
 */
private boolean startRemoteControlService(final Display display){
  String autAgentHost=EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_HOST);
  if (autAgentHost != null) {
    try {
      setAutAgentHost(autAgentHost);
      setAutAgentPort(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_PORT));
      setAutID(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_NAME));
      setDisplay(display);
      start(true);
      m_hasRemoteControlServiceStarted=true;
    }
 catch (    Exception e) {
      LOG.error(e.getLocalizedMessage(),e);
      System.exit(AUTServerExitConstants.AUT_START_ERROR);
    }
  }
  return m_hasRemoteControlServiceStarted;
}","/** 
 * Start the SwtAUTServer by connecting with the AUT agent.
 * @param display The SWT display.
 * @return True, if the AUTServer is already running, otherwise false.
 */
private boolean startRemoteControlService(final Display display){
  String autAgentHost=EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_HOST);
  if (autAgentHost != null) {
    try {
      setAutAgentHost(autAgentHost);
      setAutAgentPort(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_AGENT_PORT));
      setAutID(EnvironmentUtils.getProcessOrSystemProperty(AutConfigConstants.AUT_NAME));
      setInstallationDir(EnvironmentUtils.getProcessOrSystemProperty(Constants.AUT_JUB_INSTALL_DIRECTORY));
      setDisplay(display);
      start(true);
      m_hasRemoteControlServiceStarted=true;
    }
 catch (    Exception e) {
      LOG.error(e.getLocalizedMessage(),e);
      System.exit(AUTServerExitConstants.AUT_START_ERROR);
    }
  }
  return m_hasRemoteControlServiceStarted;
}",0.9430379746835444
95301,"/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=InspectedComponent.getInstance().getCompId();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        PropertyDescriptor propDes=new PropertyDescriptor(new OMTechNameGUIPropertySource.ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}","/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=InspectedComponent.getInstance().getCompId();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        PropertyDescriptor propDes=new JBPropertyDescriptor(new OMTechNameGUIPropertySource.ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}",0.9984251968503935
95302,"/** 
 * Initializes the tracked changes property descriptor
 */
protected void initTrackedChangesPropDescriptor(){
  SortedMap<Long,String> changes=getPoNode().getTrackedChanges();
  int i=0;
  for (  Object o : changes.keySet()) {
    if (o instanceof Long) {
      Long key=(Long)o;
      PropertyDescriptor propDes=new PropertyDescriptor(new TrackedChangesValueController(i),formatDateForTrackedChanges(key));
      propDes.setCategory(P_TRACKED_CHANGES_CAT);
      addPropertyDescriptor(propDes);
      i++;
    }
  }
}","/** 
 * Initializes the tracked changes property descriptor
 */
protected void initTrackedChangesPropDescriptor(){
  SortedMap<Long,String> changes=getPoNode().getTrackedChanges();
  int i=0;
  for (  Object o : changes.keySet()) {
    if (o instanceof Long) {
      Long key=(Long)o;
      JBPropertyDescriptor propDes=new JBPropertyDescriptor(new TrackedChangesValueController(i),formatDateForTrackedChanges(key));
      propDes.setCategory(P_TRACKED_CHANGES_CAT);
      addPropertyDescriptor(propDes);
      i++;
    }
  }
}",0.9961904761904762
95303,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  createNamePropertyDescriptor();
  createSpecNamePropertyDescriptor();
  createCommentPropertyDescriptor();
  createTaskIdPropertyDescriptor();
  if (m_eventTypePropDesc == null) {
    PropertyDescriptor cbpd=new PropertyDescriptor(new EventTypeController(),P_ELEMENT_DISPLAY_EVENTTYPE);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return EVENT_TYPES[((Integer)element).intValue()];
        }
        Assert.notReached(Messages.WrongTypeOfElement + StringConstants.EXCLAMATION_MARK);
        return String.valueOf(element);
      }
    }
);
    m_eventTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_eventTypePropDesc);
  if (m_reentryTypePropDesc == null) {
    PropertyDescriptor cbpd=new ComboBoxPropertyDescriptor(new ReentryTypeController(),P_ELEMENT_DISPLAY_REENTRYTYPE,reentryTypes);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return reentryTypes[((Integer)element).intValue()];
        }
        Assert.notReached(""String_Node_Str"");
        return String.valueOf(element);
      }
    }
);
    m_reentryTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_reentryTypePropDesc);
  if (m_maxRetriesPropDesc == null) {
    m_maxRetriesPropDesc=new IntegerTextPropertyDescriptor(new MaxRetriesController(),P_ELEMENT_DISPLAY_MAXRETRIES,false,IEventExecTestCasePO.MIN_VALUE_MAX_NUM_RETRIES,IEventExecTestCasePO.MAX_VALUE_MAX_NUM_RETRIES);
  }
  if (((IEventExecTestCasePO)getPoNode()).getReentryProp().equals(ReentryProperty.RETRY)) {
    addPropertyDescriptor(m_maxRetriesPropDesc);
  }
  addPropertyDescriptor(super.createParamDescriptors());
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  createNamePropertyDescriptor();
  createSpecNamePropertyDescriptor();
  createCommentPropertyDescriptor();
  createTaskIdPropertyDescriptor();
  if (m_eventTypePropDesc == null) {
    PropertyDescriptor cbpd=new JBPropertyDescriptor(new EventTypeController(),P_ELEMENT_DISPLAY_EVENTTYPE);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return EVENT_TYPES[((Integer)element).intValue()];
        }
        Assert.notReached(Messages.WrongTypeOfElement + StringConstants.EXCLAMATION_MARK);
        return String.valueOf(element);
      }
    }
);
    m_eventTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_eventTypePropDesc);
  if (m_reentryTypePropDesc == null) {
    PropertyDescriptor cbpd=new ComboBoxPropertyDescriptor(new ReentryTypeController(),P_ELEMENT_DISPLAY_REENTRYTYPE,reentryTypes);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return reentryTypes[((Integer)element).intValue()];
        }
        Assert.notReached(""String_Node_Str"");
        return String.valueOf(element);
      }
    }
);
    m_reentryTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_reentryTypePropDesc);
  if (m_maxRetriesPropDesc == null) {
    m_maxRetriesPropDesc=new IntegerTextPropertyDescriptor(new MaxRetriesController(),P_ELEMENT_DISPLAY_MAXRETRIES,false,IEventExecTestCasePO.MIN_VALUE_MAX_NUM_RETRIES,IEventExecTestCasePO.MAX_VALUE_MAX_NUM_RETRIES);
  }
  if (((IEventExecTestCasePO)getPoNode()).getReentryProp().equals(ReentryProperty.RETRY)) {
    addPropertyDescriptor(m_maxRetriesPropDesc);
  }
  addPropertyDescriptor(super.createParamDescriptors());
}",0.9994711792702274
95304,"/** 
 * create property descriptor 
 */
private void createSpecNamePropertyDescriptor(){
  if (m_specNamePropDesc == null) {
    PropertyDescriptor propDes=new PropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
}","/** 
 * create property descriptor 
 */
private void createSpecNamePropertyDescriptor(){
  if (m_specNamePropDesc == null) {
    PropertyDescriptor propDes=new JBPropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
}",0.9973118279569892
95305,"/** 
 * Initializes the EventTypes.
 * @return a String-Array of Event Types.
 */
private static String[] initEventTypes(){
  Set<?> mapKeySet=ComponentBuilder.getInstance().getCompSystem().getEventTypes().keySet();
  String[] eventTypes=new String[mapKeySet.size()];
  int i=0;
  final Map<String,String> stringHelperMap=StringHelper.getInstance().getMap();
  for (  Object object : mapKeySet) {
    eventTypes[i]=stringHelperMap.get(object.toString());
    i++;
  }
  return eventTypes;
}","/** 
 * Initializes the EventTypes.
 * @return a String-Array of Event Types.
 */
private static String[] initEventTypes(){
  Set mapKeySet=ComponentBuilder.getInstance().getCompSystem().getEventTypes().keySet();
  String[] eventTypes=new String[mapKeySet.size()];
  int i=0;
  final Map<String,String> stringHelperMap=StringHelper.getInstance().getMap();
  for (  Object object : mapKeySet) {
    eventTypes[i]=stringHelperMap.get(object.toString());
    i++;
  }
  return eventTypes;
}",0.9969293756397134
95306,"/** 
 * create property descriptor 
 */
private void createTaskIdPropertyDescriptor(){
  if (getTaskIdPropDesc() == null) {
    PropertyDescriptor taskIdPropDesc=new PropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
    taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
    setTaskIdPropDesc(taskIdPropDesc);
  }
  addPropertyDescriptor(getTaskIdPropDesc());
}","/** 
 * create property descriptor 
 */
private void createTaskIdPropertyDescriptor(){
  if (getTaskIdPropDesc() == null) {
    JBPropertyDescriptor taskIdPropDesc=new JBPropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
    taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
    setTaskIdPropDesc(taskIdPropDesc);
  }
  addPropertyDescriptor(getTaskIdPropDesc());
}",0.9956043956043956
95307,"/** 
 * {@inheritDoc}
 */
protected void initPropDescriptor(){
  if (!getPropertyDescriptorList().isEmpty()) {
    clearPropertyDescriptors();
  }
  if (m_namePropDesc == null) {
    m_namePropDesc=new TextPropertyDescriptor(new ExecNameController(),P_REFERNCE_DISPLAY_NAME);
  }
  addPropertyDescriptor(m_namePropDesc);
  if (m_specNamePropDesc == null) {
    PropertyDescriptor propDes=new PropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
  if (m_commentPropDesc == null) {
    m_commentPropDesc=new TextPropertyDescriptor(new CommentController(),P_ELEMENT_DISPLAY_COMMENT);
  }
  addPropertyDescriptor(m_commentPropDesc);
  if (getTaskIdPropDesc() == null) {
    createJPropertyDescriptor();
  }
  addPropertyDescriptor(getTaskIdPropDesc());
  addPropertyDescriptor(getDataSourcePropertyDescr(new ExecTestCaseTestDataSourceController(this)));
  final JUnitTestSuiteController jsC=new JUnitTestSuiteController();
  createJUnitComboBox(jsC);
  if (m_extDataPropDesc == null) {
    m_extDataPropDesc=new TextPropertyDescriptor(new ExternalDataController(this),P_ELEMENT_DISPLAY_DATEFILE);
    m_extDataPropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_extDataPropDesc);
  if (m_referencedCubePropDesc == null) {
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    IContentProposalProvider dataCubeRefProposalProvider=null;
    IValidator dataCubeRefValidator=null;
    if (activeProject != null) {
      dataCubeRefProposalProvider=new TestDataCubeRefContentProposalProvider(activeProject,(IParameterInterfacePO)getPoNode());
      dataCubeRefValidator=new TestDataCubeReferenceValidator(activeProject);
    }
    m_referencedCubePropDesc=new ContentAssistedTextPropertyDescriptor(new ReferenceTestDataController(this),P_ELEMENT_DISPLAY_REFDATA,dataCubeRefProposalProvider,dataCubeRefValidator,ContentProposalAdapter.PROPOSAL_REPLACE);
    m_referencedCubePropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_referencedCubePropDesc);
  addPropertyDescriptor(createParamDescriptors());
}","/** 
 * {@inheritDoc}
 */
protected void initPropDescriptor(){
  if (!getPropertyDescriptorList().isEmpty()) {
    clearPropertyDescriptors();
  }
  if (m_namePropDesc == null) {
    m_namePropDesc=new TextPropertyDescriptor(new ExecNameController(),P_REFERNCE_DISPLAY_NAME);
  }
  addPropertyDescriptor(m_namePropDesc);
  if (m_specNamePropDesc == null) {
    JBPropertyDescriptor propDes=new JBPropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
  if (m_commentPropDesc == null) {
    m_commentPropDesc=new TextPropertyDescriptor(new CommentController(),P_ELEMENT_DISPLAY_COMMENT);
  }
  addPropertyDescriptor(m_commentPropDesc);
  if (getTaskIdPropDesc() == null) {
    createJPropertyDescriptor();
  }
  addPropertyDescriptor(getTaskIdPropDesc());
  addPropertyDescriptor(getDataSourcePropertyDescr(new ExecTestCaseTestDataSourceController(this)));
  final JUnitTestSuiteController jsC=new JUnitTestSuiteController();
  createJUnitComboBox(jsC);
  if (m_extDataPropDesc == null) {
    m_extDataPropDesc=new TextPropertyDescriptor(new ExternalDataController(this),P_ELEMENT_DISPLAY_DATEFILE);
    m_extDataPropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_extDataPropDesc);
  if (m_referencedCubePropDesc == null) {
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    IContentProposalProvider dataCubeRefProposalProvider=null;
    IValidator dataCubeRefValidator=null;
    if (activeProject != null) {
      dataCubeRefProposalProvider=new TestDataCubeRefContentProposalProvider(activeProject,(IParameterInterfacePO)getPoNode());
      dataCubeRefValidator=new TestDataCubeReferenceValidator(activeProject);
    }
    m_referencedCubePropDesc=new ContentAssistedTextPropertyDescriptor(new ReferenceTestDataController(this),P_ELEMENT_DISPLAY_REFDATA,dataCubeRefProposalProvider,dataCubeRefValidator,ContentProposalAdapter.PROPOSAL_REPLACE);
    m_referencedCubePropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_referencedCubePropDesc);
  addPropertyDescriptor(createParamDescriptors());
}",0.99909338168631
95308,"/** 
 * Property Descriptor for the Task ID
 */
private void createJPropertyDescriptor(){
  PropertyDescriptor taskIdPropDesc=new PropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
  taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
  setTaskIdPropDesc(taskIdPropDesc);
}","/** 
 * Property Descriptor for the Task ID
 */
private void createJPropertyDescriptor(){
  JBPropertyDescriptor taskIdPropDesc=new JBPropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
  taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
  setTaskIdPropDesc(taskIdPropDesc);
}",0.9945205479452056
95309,"/** 
 * Inits the PropertyDescriptors
 */
protected void initPropDescriptor(){
  clearPropertyDescriptors();
  PropertyDescriptor propDes=null;
  propDes=new PropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ComponentTypeController(),P_ELEMENT_DISPLAY_COMPTYPE);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ParentProjectController(),P_ELEMENT_DISPLAY_PARENTPROJECT);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
}","/** 
 * Inits the PropertyDescriptors
 */
protected void initPropDescriptor(){
  clearPropertyDescriptors();
  JBPropertyDescriptor propDes=null;
  propDes=new JBPropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ComponentTypeController(),P_ELEMENT_DISPLAY_COMPTYPE);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ParentProjectController(),P_ELEMENT_DISPLAY_PARENTPROJECT);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
}",0.9953106682297772
95310,"/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=getNode().getCompIdentifier();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        PropertyDescriptor propDes=new PropertyDescriptor(new ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}","/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=getNode().getCompIdentifier();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        JBPropertyDescriptor propDes=new JBPropertyDescriptor(new ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}",0.9966273187183812
95311,"/** 
 * Inits the PropertyDescriptors
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  PropertyDescriptor propDes=null;
  propDes=new PropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ComponentClassController(),P_ELEMENT_DISPLAY_COMPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ComponentSuppClassController(),P_ELEMENT_DISPLAY_COMPSUPPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  initHierarchy();
  initContext();
  initComponentProperties();
}","/** 
 * Inits the PropertyDescriptors
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  JBPropertyDescriptor propDes=null;
  propDes=new JBPropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ComponentClassController(),P_ELEMENT_DISPLAY_COMPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ComponentSuppClassController(),P_ELEMENT_DISPLAY_COMPSUPPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  initHierarchy();
  initContext();
  initComponentProperties();
}",0.995959595959596
95312,"/** 
 * Initializes the context
 */
private void initContext(){
  PropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List context=compId.getNeighbours();
    for (int i=0; i < context.size(); i++) {
      if (i == 0) {
        propDes=new PropertyDescriptor(new ComponentContextController(i),P_ELEMENT_DISPLAY_CONTEXT);
      }
 else {
        propDes=new PropertyDescriptor(new ComponentContextController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}","/** 
 * Initializes the context
 */
private void initContext(){
  JBPropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List context=compId.getNeighbours();
    for (int i=0; i < context.size(); i++) {
      if (i == 0) {
        propDes=new JBPropertyDescriptor(new ComponentContextController(i),P_ELEMENT_DISPLAY_CONTEXT);
      }
 else {
        propDes=new JBPropertyDescriptor(new ComponentContextController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}",0.9951690821256038
95313,"/** 
 * Initializes the hierarchy
 */
private void initHierarchy(){
  PropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List<?> hierarchy=compId.getHierarchyNames();
    for (int i=0; i < hierarchy.size(); i++) {
      if (i == 0) {
        propDes=new PropertyDescriptor(new ComponentHierarchyController(i),P_ELEMENT_DISPLAY_HIERARCHY);
      }
 else {
        propDes=new PropertyDescriptor(new ComponentHierarchyController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}","/** 
 * Initializes the hierarchy
 */
private void initHierarchy(){
  JBPropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List hierarchy=compId.getHierarchyNames();
    for (int i=0; i < hierarchy.size(); i++) {
      if (i == 0) {
        propDes=new JBPropertyDescriptor(new ComponentHierarchyController(i),P_ELEMENT_DISPLAY_HIERARCHY);
      }
 else {
        propDes=new JBPropertyDescriptor(new ComponentHierarchyController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}",0.9929742388758782
95314,"/** 
 * creates a job which expands the viewer to its old state 
 * @return the job
 */
private Job createExpanderJob(){
  return new WorkbenchJob(""String_Node_Str""){
    public IStatus runInUIThread(    IProgressMonitor monitor){
      getViewer().setExpandedElements(m_expandedElements);
      return new Status(Status.OK,Plugin.PLUGIN_ID,StringConstants.EMPTY);
    }
  }
;
}","/** 
 * creates a job which expands the viewer to its old state 
 * @return the job
 */
private Job createExpanderJob(){
  return new WorkbenchJob(""String_Node_Str""){
    public IStatus runInUIThread(    IProgressMonitor monitor){
      try {
        if (!getViewer().getTree().isDisposed()) {
          getViewer().setExpandedElements(m_expandedElements);
        }
      }
 catch (      SWTException e) {
      }
      return new Status(Status.OK,Plugin.PLUGIN_ID,StringConstants.EMPTY);
    }
  }
;
}",0.8581157775255391
95315,"public IStatus runInUIThread(IProgressMonitor monitor){
  getViewer().setExpandedElements(m_expandedElements);
  return new Status(Status.OK,Plugin.PLUGIN_ID,StringConstants.EMPTY);
}","public IStatus runInUIThread(IProgressMonitor monitor){
  try {
    if (!getViewer().getTree().isDisposed()) {
      getViewer().setExpandedElements(m_expandedElements);
    }
  }
 catch (  SWTException e) {
  }
  return new Status(Status.OK,Plugin.PLUGIN_ID,StringConstants.EMPTY);
}",0.7837259100642399
95316,"/** 
 * checks and sets the switch button status
 */
private void checkButtons(){
  ITreeSelection selection=m_availableTree.getStructuredSelection();
  enableAvailableToUsedButton(!selection.isEmpty());
  for (Iterator<?> iterator=selection.iterator(); iterator.hasNext(); ) {
    Object type=iterator.next();
    if (!(type instanceof IObjectMappingCategoryPO)) {
      enableAvailableToUsedButton(false);
      break;
    }
  }
  ITreeSelection usedSelection=m_usedTree.getStructuredSelection();
  enableRemoveUsedButton(!usedSelection.isEmpty());
  for (Iterator<?> iterator=usedSelection.iterator(); iterator.hasNext(); ) {
    Object type=iterator.next();
    if (!(type instanceof IObjectMappingCategoryPO)) {
      enableRemoveUsedButton(false);
      break;
    }
  }
  enableRemoveAllUsedButton(m_selectedCat.size() > 0);
  enableAllAvailableToUsedButton(m_availableTree.getVisibleExpandedElements().length != m_availableTree.getTree().getItemCount());
}","/** 
 * checks and sets the switch button status
 */
private void checkButtons(){
  ITreeSelection selection=m_availableTree.getStructuredSelection();
  enableAvailableToUsedButton(!selection.isEmpty());
  for (Iterator<?> iterator=selection.iterator(); iterator.hasNext(); ) {
    Object type=iterator.next();
    if (!(type instanceof IObjectMappingCategoryPO)) {
      enableAvailableToUsedButton(false);
      break;
    }
  }
  ITreeSelection usedSelection=m_usedTree.getStructuredSelection();
  Object firstElement=usedSelection.getFirstElement();
  enableRemoveUsedButton(!usedSelection.isEmpty() && m_selectedCat.contains(firstElement));
  for (Iterator<?> iterator=usedSelection.iterator(); iterator.hasNext(); ) {
    Object type=iterator.next();
    if (!(type instanceof IObjectMappingCategoryPO)) {
      enableRemoveUsedButton(false);
      break;
    }
  }
  enableRemoveAllUsedButton(m_selectedCat.size() > 0);
  enableAllAvailableToUsedButton(m_availableTree.getVisibleExpandedElements().length != m_availableTree.getTree().getItemCount());
}",0.95304003954523
95317,"/** 
 * @param combobox the combobox
 * @return a {@link ListView} which is the list of the {@link ComboBox}
 */
public static ListView<?> getPopUpContent(ComboBox<?> combobox){
  Class<?> clazz=null;
  Object skin=combobox.getSkin();
  try {
    clazz=Class.forName(JAVA8_COMBO_LISTVIEWSKIN);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_COMBO_LISTVIEWSKIN);
    }
 catch (    ClassNotFoundException e2) {
      throw new RuntimeException(e2);
    }
  }
  try {
    Method method=clazz.getMethod(GET_POPUP_CONTENT);
    Object o=method.invoke(skin);
    if (o instanceof ListView<?>) {
      return (ListView<?>)o;
    }
  }
 catch (  NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(e);
  }
  return null;
}","/** 
 * @param combobox the combobox
 * @return a {@link ListView} which is the list of the {@link ComboBox}
 */
public static ListView<?> getPopUpContent(ComboBox<?> combobox){
  Class<?> clazz=null;
  Object skin=combobox.getSkin();
  try {
    clazz=Class.forName(JAVA8_COMBO_LISTVIEWSKIN);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_COMBO_LISTVIEWSKIN);
    }
 catch (    ClassNotFoundException e2) {
      throw new RuntimeException(e2);
    }
  }
  try {
    Method method=clazz.getDeclaredMethod(GET_POPUP_CONTENT);
    if (!method.isAccessible()) {
      method.setAccessible(true);
    }
    Object o=method.invoke(skin);
    if (o instanceof ListView<?>) {
      return (ListView<?>)o;
    }
  }
 catch (  NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(e);
  }
  return null;
}",0.9539325842696628
95318,"/** 
 * @param table the {@link TableView}
 * @param column the column number
 * @param relative should the calculation be relative or absolute
 * @return the {@link Rectangle} or null if it is not found
 */
public static Rectangle getNodeBoundsofHeader(Parent table,TableColumnBase<?,?> column,boolean relative){
  Class<?> clazz=null;
  try {
    clazz=Class.forName(JAVA8_TABLE_HEADER_ROW);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_TABLE_HEADER_ROW);
    }
 catch (    ClassNotFoundException e2) {
      String message=""String_Node_Str"" + JAVA8_TABLE_HEADER_ROW + ""String_Node_Str""+ JAVA9_TABLE_HEADER_ROW+ ""String_Node_Str"";
      log.error(message,e2);
      throw new RuntimeException(message,e2);
    }
  }
  try {
    List<?> headerRow=NodeTraverseHelper.getInstancesOf(table,clazz);
    Object colH=null;
    for (    Object tableHeaderRow : headerRow) {
      Method method=clazz.getMethod(GET_COLUMN_HEADER_FOR,TableColumnBase.class);
      colH=method.invoke(tableHeaderRow,column);
      if (colH != null) {
        if (relative) {
          return NodeBounds.getRelativeBounds((Node)colH,(Node)tableHeaderRow);
        }
        return NodeBounds.getAbsoluteBounds((Node)colH);
      }
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * @param table the {@link TableView}
 * @param column the column number
 * @param relative should the calculation be relative or absolute
 * @return the {@link Rectangle} or null if it is not found
 */
public static Rectangle getNodeBoundsofHeader(Parent table,TableColumnBase<?,?> column,boolean relative){
  Class<?> clazz=null;
  try {
    clazz=Class.forName(JAVA8_TABLE_HEADER_ROW);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_TABLE_HEADER_ROW);
    }
 catch (    ClassNotFoundException e2) {
      String message=""String_Node_Str"" + JAVA8_TABLE_HEADER_ROW + ""String_Node_Str""+ JAVA9_TABLE_HEADER_ROW+ ""String_Node_Str"";
      log.error(message,e2);
      throw new RuntimeException(message,e2);
    }
  }
  try {
    List<?> headerRow=NodeTraverseHelper.getInstancesOf(table,clazz);
    Object colH=null;
    for (    Object tableHeaderRow : headerRow) {
      Method method=clazz.getDeclaredMethod(GET_COLUMN_HEADER_FOR,TableColumnBase.class);
      if (!method.isAccessible()) {
        method.setAccessible(true);
      }
      colH=method.invoke(tableHeaderRow,column);
      if (colH != null) {
        if (relative) {
          return NodeBounds.getRelativeBounds((Node)colH,(Node)tableHeaderRow);
        }
        return NodeBounds.getAbsoluteBounds((Node)colH);
      }
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}",0.970310391363023
95319,"/** 
 * Constructor
 * @param id The associated property controller
 * @param displayName  the name to display for the property
 * @param valuesArray the list of possible values to display in the combo box
 * @param validator for parameter value validation
 */
public ParamComboPropertyDescriptor(IPropertyController id,String displayName,String[] valuesArray,IParamValueValidator validator){
  super(id,displayName);
  m_dataValidator=validator;
  m_proposals=valuesArray;
}","/** 
 * Constructor
 * @param id The associated property controller
 * @param displayName  the name to display for the property
 * @param valuesArray the list of possible values to display in the combo box
 * @param validator for parameter value validation
 */
public ParamComboPropertyDescriptor(IPropertyController id,String displayName,Map<String,String> valuesArray,IParamValueValidator validator){
  super(id,displayName);
  m_dataValidator=validator;
  m_proposals=valuesArray;
}",0.9854166666666668
95320,"/** 
 * @param valueSet alueSet Source for returned values. May be <code>null</code>.
 * @return a {@link Map} with values as key and comments as value
 */
public static Map<String,String> getValuesWithComment(ParamValueSet valueSet){
  Map<String,String> valueToComment=new HashMap<>();
  if (valueSet == null) {
    return valueToComment;
  }
  Iterator<ValueSetElement> valueSetIter=valueSet.iterator();
  while (valueSetIter.hasNext()) {
    ValueSetElement value=valueSetIter.next();
    valueToComment.put(value.getValue(),value.getComment());
  }
  return valueToComment;
}","/** 
 * @param valueSet alueSet Source for returned values. May be <code>null</code>.
 * @return a {@link Map} with values as key and comments as value
 */
public static Map<String,String> getValuesWithComment(ParamValueSet valueSet){
  Map<String,String> valueToComment=new HashMap<>();
  if (valueSet == null) {
    return valueToComment;
  }
  Iterator<ValueSetElement> valueSetIter=valueSet.iterator();
  while (valueSetIter.hasNext()) {
    ValueSetElement value=valueSetIter.next();
    String comment=value.getComment();
    if (StringUtils.isEmpty(comment)) {
      comment=CompSystemI18n.getString(value.getDescriptionKey());
    }
    valueToComment.put(value.getValue(),comment);
  }
  return valueToComment;
}",0.8285933897002306
95321,"/** 
 * Inits the PropertyDescriptors
 */
protected void initPropDescriptor(){
  Map<String,String> map=StringHelper.getInstance().getMap();
  clearPropertyDescriptors();
  addPropertyDescriptor(getStepNamePropDesc());
  super.initPropDescriptor();
  addPropertyDescriptor(getCompTypePropDesc());
  IPropertyDescriptor propdesc=getCompNamePropDesc();
  if (propdesc != null) {
    addPropertyDescriptor(getCompNamePropDesc());
  }
  addPropertyDescriptor(getActionPropDesc());
  if (m_initializedParamDescriptors.isEmpty()) {
    clearControllerLists();
    IParamNameMapper activeParamNameMapper=getActiveParamNameMapper();
    IParamNodePO paramNode=getParamNode();
    for (    IParamDescriptionPO desc : paramNode.getParameterList()) {
      ParameterValueController paramCtrl=new ParameterValueController(this,desc,activeParamNameMapper);
      m_paramValueControllerList.add(paramCtrl);
      Action action=CapBP.getAction((ICapPO)getPoNode());
      final List<String> values=new ArrayList<String>();
      Param param=action.findParam(desc.getUniqueId());
      for (Iterator iter=param.valueSetIterator(); iter.hasNext(); ) {
        values.add(map.get(((ValueSetElement)iter.next()).getValue()));
      }
      final String[] valArray=values.toArray(new String[values.size()]);
      PropertyDescriptor descr=TestDataControlFactory.createValuePropertyDescriptor(paramCtrl,getParameterNameDescr(desc),valArray,param.getValueSet().isCombinable());
      ILabelProvider labelProvider;
      if (param.isOptional()) {
        labelProvider=new ParameterValueLabelProvider(IconConstants.OPTIONAL_DATA_IMAGE);
      }
 else {
        labelProvider=new ParameterValueLabelProvider(INCOMPL_DATA_IMAGE);
      }
      descr.setLabelProvider(labelProvider);
      descr.setCategory(P_PARAMETER_CAT);
      m_initializedParamDescriptors.add(descr);
    }
  }
  addPropertyDescriptor(m_initializedParamDescriptors);
}","/** 
 * Inits the PropertyDescriptors
 */
protected void initPropDescriptor(){
  Map<String,String> map=StringHelper.getInstance().getMap();
  clearPropertyDescriptors();
  addPropertyDescriptor(getStepNamePropDesc());
  super.initPropDescriptor();
  addPropertyDescriptor(getCompTypePropDesc());
  IPropertyDescriptor propdesc=getCompNamePropDesc();
  if (propdesc != null) {
    addPropertyDescriptor(getCompNamePropDesc());
  }
  addPropertyDescriptor(getActionPropDesc());
  if (m_initializedParamDescriptors.isEmpty()) {
    clearControllerLists();
    IParamNameMapper activeParamNameMapper=getActiveParamNameMapper();
    IParamNodePO paramNode=getParamNode();
    for (    IParamDescriptionPO desc : paramNode.getParameterList()) {
      ParameterValueController paramCtrl=new ParameterValueController(this,desc,activeParamNameMapper);
      m_paramValueControllerList.add(paramCtrl);
      Action action=CapBP.getAction((ICapPO)getPoNode());
      final Map<String,String> values=new HashMap<String,String>();
      Param param=action.findParam(desc.getUniqueId());
      for (Iterator<ValueSetElement> iter=param.valueSetIterator(); iter.hasNext(); ) {
        ValueSetElement next=iter.next();
        values.put(map.get(next.getValue()),CompSystemI18n.getString(next.getDescriptionKey()));
      }
      PropertyDescriptor descr=TestDataControlFactory.createValuePropertyDescriptor(paramCtrl,getParameterNameDescr(desc),values,param.getValueSet().isCombinable());
      ILabelProvider labelProvider;
      if (param.isOptional()) {
        labelProvider=new ParameterValueLabelProvider(IconConstants.OPTIONAL_DATA_IMAGE);
      }
 else {
        labelProvider=new ParameterValueLabelProvider(INCOMPL_DATA_IMAGE);
      }
      descr.setLabelProvider(labelProvider);
      descr.setCategory(P_PARAMETER_CAT);
      m_initializedParamDescriptors.add(descr);
    }
  }
  addPropertyDescriptor(m_initializedParamDescriptors);
}",0.9262337662337662
95322,"/** 
 * @return a List of PropertyDescriptors of parameters.
 */
protected List<IPropertyDescriptor> createParamDescriptors(){
  if (m_paramPropDescList.isEmpty()) {
    PropertyDescriptor propDes;
    final IParamNodePO paramNodePO=(IParamNodePO)getPoNode();
    List<IParamDescriptionPO> paramList=paramNodePO.getParameterList();
    IParamNameMapper activeParamNameMapper=getActiveParamNameMapper();
    for (    IParamDescriptionPO paramDescr : paramList) {
      ParamValueSet valueSet=ParamTextPropertyDescriptor.getValuesSet(paramNodePO,paramDescr.getUniqueId());
      propDes=TestDataControlFactory.createValuePropertyDescriptor(new ParameterValueController(this,paramDescr,activeParamNameMapper),getParameterNameDescr(paramDescr),ParamTextPropertyDescriptor.getValues(valueSet),valueSet != null ? valueSet.isCombinable() : false);
      propDes.setCategory(P_PARAMETER_CAT);
      propDes.setLabelProvider(new ParameterValueLabelProvider(INCOMPL_DATA_IMAGE));
      m_paramPropDescList.add(propDes);
    }
  }
  return m_paramPropDescList;
}","/** 
 * @return a List of PropertyDescriptors of parameters.
 */
protected List<IPropertyDescriptor> createParamDescriptors(){
  if (m_paramPropDescList.isEmpty()) {
    PropertyDescriptor propDes;
    final IParamNodePO paramNodePO=(IParamNodePO)getPoNode();
    List<IParamDescriptionPO> paramList=paramNodePO.getParameterList();
    IParamNameMapper activeParamNameMapper=getActiveParamNameMapper();
    for (    IParamDescriptionPO paramDescr : paramList) {
      ParamValueSet valueSet=ParamTextPropertyDescriptor.getValuesSet(paramNodePO,paramDescr.getUniqueId());
      propDes=TestDataControlFactory.createValuePropertyDescriptor(new ParameterValueController(this,paramDescr,activeParamNameMapper),getParameterNameDescr(paramDescr),ParamTextPropertyDescriptor.getValuesWithComment(valueSet),valueSet != null ? valueSet.isCombinable() : false);
      propDes.setCategory(P_PARAMETER_CAT);
      propDes.setLabelProvider(new ParameterValueLabelProvider(INCOMPL_DATA_IMAGE));
      m_paramPropDescList.add(propDes);
    }
  }
  return m_paramPropDescList;
}",0.9947941315664932
95323,"/** 
 * {@inheritDoc} 
 */
protected void initPropDescriptor(){
  clearPropertyDescriptors();
  addPropertyDescriptor(new TextPropertyDescriptor(new ElementNameController(),Messages.IterateGUIPropertySourceName));
  super.initPropDescriptor();
  for (  IParamDescriptionPO desc : getParamNode().getParameterList()) {
    ParameterValueController paramCtrl=new ParameterValueController(this,desc,getActiveParamNameMapper());
    PropertyDescriptor descr=TestDataControlFactory.createValuePropertyDescriptor(paramCtrl,getParameterNameDescr(desc),new String[0],false);
    ILabelProvider labelProvider;
    labelProvider=new ParameterValueLabelProvider(INCOMPL_DATA_IMAGE);
    descr.setLabelProvider(labelProvider);
    descr.setCategory(""String_Node_Str"");
    addPropertyDescriptor(descr);
  }
}","/** 
 * {@inheritDoc} 
 */
protected void initPropDescriptor(){
  clearPropertyDescriptors();
  addPropertyDescriptor(new TextPropertyDescriptor(new ElementNameController(),Messages.IterateGUIPropertySourceName));
  super.initPropDescriptor();
  for (  IParamDescriptionPO desc : getParamNode().getParameterList()) {
    ParameterValueController paramCtrl=new ParameterValueController(this,desc,getActiveParamNameMapper());
    PropertyDescriptor descr=TestDataControlFactory.createValuePropertyDescriptor(paramCtrl,getParameterNameDescr(desc),new HashMap<>(),false);
    ILabelProvider labelProvider;
    labelProvider=new ParameterValueLabelProvider(INCOMPL_DATA_IMAGE);
    descr.setLabelProvider(labelProvider);
    descr.setCategory(""String_Node_Str"");
    addPropertyDescriptor(descr);
  }
}",0.9874371859296482
95324,"/** 
 * Initializes the parameter property descriptors, if needed, and adds them to the given list. The contents of the list are then added to the overall list of property descriptors.
 */
private void initParameterPropDescriptors(){
  List<IPropertyDescriptor> paramPropDescList=new ArrayList<IPropertyDescriptor>();
  List<IParamDescriptionPO> paramList=((IParamNodePO)getPoNode()).getParameterList();
  IParamNameMapper activeParamNameMapper=getActiveParamNameMapper();
  for (  IParamDescriptionPO paramDescr : paramList) {
    PropertyDescriptor propDes=TestDataControlFactory.createValuePropertyDescriptor(new ParameterValueController(this,paramDescr,activeParamNameMapper),getParameterNameDescr(paramDescr),new String[0],false);
    propDes.setCategory(P_PARAMETER_CAT);
    propDes.setLabelProvider(new ParameterValueLabelProvider(WARNING_IMAGE));
    paramPropDescList.add(propDes);
  }
  addPropertyDescriptor(paramPropDescList);
}","/** 
 * Initializes the parameter property descriptors, if needed, and adds them to the given list. The contents of the list are then added to the overall list of property descriptors.
 */
private void initParameterPropDescriptors(){
  List<IPropertyDescriptor> paramPropDescList=new ArrayList<IPropertyDescriptor>();
  List<IParamDescriptionPO> paramList=((IParamNodePO)getPoNode()).getParameterList();
  IParamNameMapper activeParamNameMapper=getActiveParamNameMapper();
  for (  IParamDescriptionPO paramDescr : paramList) {
    PropertyDescriptor propDes=TestDataControlFactory.createValuePropertyDescriptor(new ParameterValueController(this,paramDescr,activeParamNameMapper),getParameterNameDescr(paramDescr),new HashMap<>(),false);
    propDes.setCategory(P_PARAMETER_CAT);
    propDes.setLabelProvider(new ParameterValueLabelProvider(WARNING_IMAGE));
    paramPropDescList.add(propDes);
  }
  addPropertyDescriptor(paramPropDescList);
}",0.989384288747346
95325,"/** 
 * Creates a PropertyDescriptor depending on the given paramValController,  displayName and values array.<br> The values parameter is to get a ComboBoxPropertyDescriptor if array.length > 0.<br> For all other PropertyDescriptors set an empty String-Array into this parameter.
 * @param paramValController an AbstractParamValueController.
 * @param displayName the display name of the PropertyDescriptor
 * @param values The values parameter is to get a ComboBoxPropertyDescriptorif values.length > 0.<br> For all other PropertyDescriptors set an empty  String-Array into this parameter!
 * @param valuesAreCombinable Whether combinations of the supplied values are allowed.
 * @return a PropertyDescriptor
 */
public static PropertyDescriptor createValuePropertyDescriptor(AbstractParamValueController paramValController,String displayName,String[] values,boolean valuesAreCombinable){
  final String paramType=paramValController.getParamDesc().getType();
  if (values.length > 0) {
    return new ParamComboPropertyDescriptor(paramValController,displayName,values,createParamValueValidator(TestDataConstants.STR,valuesAreCombinable,values));
  }
  if (TestDataConstants.BOOLEAN.equals(paramType)) {
    return new ParamTextPropertyDescriptor(paramValController,displayName,createParamValueValidator(TestDataConstants.STR,valuesAreCombinable,BOOLEAN_VALUES));
  }
  return new ParamTextPropertyDescriptor(paramValController,displayName,createParamValueValidator(paramType,valuesAreCombinable));
}","/** 
 * Creates a PropertyDescriptor depending on the given paramValController,  displayName and values array.<br> The values parameter is to get a ComboBoxPropertyDescriptor if array.length > 0.<br> For all other PropertyDescriptors set an empty String-Array into this parameter.
 * @param paramValController an AbstractParamValueController.
 * @param displayName the display name of the PropertyDescriptor
 * @param values The values parameter is to get a ComboBoxPropertyDescriptorif values are not empty<br> For all other PropertyDescriptors set an empty  String,String Map into this parameter!
 * @param valuesAreCombinable Whether combinations of the supplied values are allowed.
 * @return a PropertyDescriptor
 */
public static PropertyDescriptor createValuePropertyDescriptor(AbstractParamValueController paramValController,String displayName,Map<String,String> values,boolean valuesAreCombinable){
  final String paramType=paramValController.getParamDesc().getType();
  if (!values.isEmpty()) {
    return new ParamComboPropertyDescriptor(paramValController,displayName,values,createParamValueValidator(TestDataConstants.STR,valuesAreCombinable,values.keySet().toArray(new String[0])));
  }
  if (TestDataConstants.BOOLEAN.equals(paramType)) {
    return new ParamTextPropertyDescriptor(paramValController,displayName,createParamValueValidator(TestDataConstants.STR,valuesAreCombinable,BOOLEAN_VALUES));
  }
  return new ParamTextPropertyDescriptor(paramValController,displayName,createParamValueValidator(paramType,valuesAreCombinable));
}",0.9308423467715504
95326,"/** 
 * This method must be called on the FX Thread.
 * @param targetTab the Tab for which to get the bounding node.
 * @return the Node representing the bounding box of <code>targetTab</code>,or <code>null</code> if no such Node could be found.
 * @throws StepExecutionException if the Skin or structure of the realcomponent is not supported.
 */
private Node getNodeFor(Tab targetTab) throws StepExecutionException {
  EventThreadQueuerJavaFXImpl.checkEventThread();
  Skin<?> tabPaneSkin=getRealComponent().getSkin();
  if (!(tabPaneSkin instanceof SkinBase)) {
    throw new StepExecutionException(""String_Node_Str"" + tabPaneSkin.getClass(),EventFactory.createActionError(TestErrorEvent.RENDERER_NOT_SUPPORTED));
  }
  ClassLoader skinClassLoader=targetTab.getClass().getClassLoader();
  try {
    Class<?> tabHeaderAreaClass=skinClassLoader.loadClass(TAB_HEADER_AREA_CLASSNAME);
    for (    Node tabPaneSkinChild : ((SkinBase<?>)tabPaneSkin).getChildren()) {
      if (tabHeaderAreaClass.isInstance(tabPaneSkinChild)) {
        Method method=tabHeaderAreaClass.getDeclaredMethod(GET_TAB_HEADER_SKIN_METHOD_NAME,GET_TAB_HEADER_SKIN_PARAMETER_TYPES);
        method.setAccessible(true);
        Object tabHeaderSkin=method.invoke(tabPaneSkinChild,new Object[]{targetTab});
        if (tabHeaderSkin == null || tabHeaderSkin instanceof Node) {
          return (Node)tabHeaderSkin;
        }
        throw new StepExecutionException(""String_Node_Str"" + tabHeaderSkin.getClass(),EventFactory.createActionError(TestErrorEvent.RENDERER_NOT_SUPPORTED));
      }
    }
  }
 catch (  ClassNotFoundException|NoSuchMethodException e) {
  }
catch (  IllegalAccessException|InvocationTargetException e) {
    throw new StepExecutionException(e);
  }
  throw new StepExecutionException(""String_Node_Str"" + tabPaneSkin.getClass(),EventFactory.createActionError(TestErrorEvent.RENDERER_NOT_SUPPORTED));
}","/** 
 * This method must be called on the FX Thread.
 * @param targetTab the Tab for which to get the bounding node.
 * @return the Node representing the bounding box of <code>targetTab</code>,or <code>null</code> if no such Node could be found.
 * @throws StepExecutionException if the Skin or structure of the realcomponent is not supported.
 */
private Node getNodeFor(Tab targetTab) throws StepExecutionException {
  EventThreadQueuerJavaFXImpl.checkEventThread();
  Skin<?> tabPaneSkin=getRealComponent().getSkin();
  if (!(tabPaneSkin instanceof SkinBase)) {
    throw new StepExecutionException(""String_Node_Str"" + tabPaneSkin.getClass(),EventFactory.createActionError(TestErrorEvent.RENDERER_NOT_SUPPORTED));
  }
  ClassLoader skinClassLoader=targetTab.getClass().getClassLoader();
  try {
    Class<?> tabHeaderAreaClass=null;
    if (SystemUtils.JAVA_VERSION_FLOAT > 1.8f) {
      tabHeaderAreaClass=skinClassLoader.loadClass(TAB_HEADER_AREA_CLASSNAME_JAVA9);
    }
 else {
      tabHeaderAreaClass=skinClassLoader.loadClass(TAB_HEADER_AREA_CLASSNAME);
    }
    for (    Node tabPaneSkinChild : ((SkinBase<?>)tabPaneSkin).getChildren()) {
      if (tabHeaderAreaClass.isInstance(tabPaneSkinChild)) {
        Method method=tabHeaderAreaClass.getDeclaredMethod(GET_TAB_HEADER_SKIN_METHOD_NAME,GET_TAB_HEADER_SKIN_PARAMETER_TYPES);
        method.setAccessible(true);
        Object tabHeaderSkin=method.invoke(tabPaneSkinChild,new Object[]{targetTab});
        if (tabHeaderSkin == null || tabHeaderSkin instanceof Node) {
          return (Node)tabHeaderSkin;
        }
        throw new StepExecutionException(""String_Node_Str"" + tabHeaderSkin.getClass(),EventFactory.createActionError(TestErrorEvent.RENDERER_NOT_SUPPORTED));
      }
    }
  }
 catch (  ClassNotFoundException|NoSuchMethodException e) {
  }
catch (  IllegalAccessException|InvocationTargetException e) {
    throw new StepExecutionException(e);
  }
  throw new StepExecutionException(""String_Node_Str"" + tabPaneSkin.getClass(),EventFactory.createActionError(TestErrorEvent.RENDERER_NOT_SUPPORTED));
}",0.948905109489051
95327,"/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  super.createPartControl(parent);
  parent.setLayout(new FillLayout());
  m_scrollComposite=new ScrolledComposite(parent,SWT.V_SCROLL | SWT.H_SCROLL);
  m_child=new Composite(m_scrollComposite,SWT.NONE);
  m_child.setLayout(new FillLayout());
  m_logWidget=new Text(m_child,SWT.MULTI | SWT.BORDER | SWT.H_SCROLL| SWT.V_SCROLL);
  m_logWidget.setEditable(false);
  m_scrollComposite.setExpandHorizontal(true);
  m_scrollComposite.setExpandVertical(true);
  m_scrollComposite.setMinSize(m_child.computeSize(SWT.DEFAULT,SWT.DEFAULT));
  m_scrollComposite.setContent(m_child);
  MenuManager contextManager=new MenuManager();
  contextManager.setRemoveAllWhenShown(true);
  Menu contextMenu=contextManager.createContextMenu(m_logWidget);
  m_logWidget.setMenu(contextMenu);
  getSite().registerContextMenu(contextManager,this);
  handleSelection(getSelectionService().getSelection());
  getSite().setSelectionProvider(this);
}","/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  super.createPartControl(parent);
  parent.setLayout(new FillLayout());
  m_scrollComposite=new ScrolledComposite(parent,SWT.V_SCROLL | SWT.H_SCROLL);
  m_child=new Composite(m_scrollComposite,SWT.NONE);
  m_child.setLayout(new FillLayout());
  m_logWidget=new Text(m_child,SWT.MULTI | SWT.BORDER | SWT.H_SCROLL| SWT.V_SCROLL);
  m_logWidget.setEditable(false);
  m_scrollComposite.setExpandHorizontal(true);
  m_scrollComposite.setExpandVertical(true);
  m_scrollComposite.setMinSize(m_child.computeSize(SWT.DEFAULT,SWT.DEFAULT));
  m_scrollComposite.setContent(m_child);
  MenuManager contextManager=new MenuManager();
  contextManager.setRemoveAllWhenShown(true);
  Menu contextMenu=contextManager.createContextMenu(m_logWidget);
  m_logWidget.setMenu(contextMenu);
  getSite().registerContextMenu(contextManager,this);
  super.createPartControl(parent);
  handleSelection(getSelectionService().getSelection());
  getSite().setSelectionProvider(this);
}",0.9827501232134056
95328,"/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=InspectedComponent.getInstance().getCompId();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        PropertyDescriptor propDes=new JBPropertyDescriptor(new OMTechNameGUIPropertySource.ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}","/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=InspectedComponent.getInstance().getCompId();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        PropertyDescriptor propDes=new PropertyDescriptor(new OMTechNameGUIPropertySource.ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}",0.9984251968503935
95329,"/** 
 * Initializes the tracked changes property descriptor
 */
protected void initTrackedChangesPropDescriptor(){
  SortedMap<Long,String> changes=getPoNode().getTrackedChanges();
  int i=0;
  for (  Object o : changes.keySet()) {
    if (o instanceof Long) {
      Long key=(Long)o;
      JBPropertyDescriptor propDes=new JBPropertyDescriptor(new TrackedChangesValueController(i),formatDateForTrackedChanges(key));
      propDes.setCategory(P_TRACKED_CHANGES_CAT);
      addPropertyDescriptor(propDes);
      i++;
    }
  }
}","/** 
 * Initializes the tracked changes property descriptor
 */
protected void initTrackedChangesPropDescriptor(){
  SortedMap<Long,String> changes=getPoNode().getTrackedChanges();
  int i=0;
  for (  Object o : changes.keySet()) {
    if (o instanceof Long) {
      Long key=(Long)o;
      PropertyDescriptor propDes=new PropertyDescriptor(new TrackedChangesValueController(i),formatDateForTrackedChanges(key));
      propDes.setCategory(P_TRACKED_CHANGES_CAT);
      addPropertyDescriptor(propDes);
      i++;
    }
  }
}",0.9961904761904762
95330,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  createNamePropertyDescriptor();
  createSpecNamePropertyDescriptor();
  createCommentPropertyDescriptor();
  createTaskIdPropertyDescriptor();
  if (m_eventTypePropDesc == null) {
    PropertyDescriptor cbpd=new JBPropertyDescriptor(new EventTypeController(),P_ELEMENT_DISPLAY_EVENTTYPE);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return EVENT_TYPES[((Integer)element).intValue()];
        }
        Assert.notReached(Messages.WrongTypeOfElement + StringConstants.EXCLAMATION_MARK);
        return String.valueOf(element);
      }
    }
);
    m_eventTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_eventTypePropDesc);
  if (m_reentryTypePropDesc == null) {
    PropertyDescriptor cbpd=new ComboBoxPropertyDescriptor(new ReentryTypeController(),P_ELEMENT_DISPLAY_REENTRYTYPE,reentryTypes);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return reentryTypes[((Integer)element).intValue()];
        }
        Assert.notReached(""String_Node_Str"");
        return String.valueOf(element);
      }
    }
);
    m_reentryTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_reentryTypePropDesc);
  if (m_maxRetriesPropDesc == null) {
    m_maxRetriesPropDesc=new IntegerTextPropertyDescriptor(new MaxRetriesController(),P_ELEMENT_DISPLAY_MAXRETRIES,false,IEventExecTestCasePO.MIN_VALUE_MAX_NUM_RETRIES,IEventExecTestCasePO.MAX_VALUE_MAX_NUM_RETRIES);
  }
  if (((IEventExecTestCasePO)getPoNode()).getReentryProp().equals(ReentryProperty.RETRY)) {
    addPropertyDescriptor(m_maxRetriesPropDesc);
  }
  addPropertyDescriptor(super.createParamDescriptors());
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  createNamePropertyDescriptor();
  createSpecNamePropertyDescriptor();
  createCommentPropertyDescriptor();
  createTaskIdPropertyDescriptor();
  if (m_eventTypePropDesc == null) {
    PropertyDescriptor cbpd=new PropertyDescriptor(new EventTypeController(),P_ELEMENT_DISPLAY_EVENTTYPE);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return EVENT_TYPES[((Integer)element).intValue()];
        }
        Assert.notReached(Messages.WrongTypeOfElement + StringConstants.EXCLAMATION_MARK);
        return String.valueOf(element);
      }
    }
);
    m_eventTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_eventTypePropDesc);
  if (m_reentryTypePropDesc == null) {
    PropertyDescriptor cbpd=new ComboBoxPropertyDescriptor(new ReentryTypeController(),P_ELEMENT_DISPLAY_REENTRYTYPE,reentryTypes);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return reentryTypes[((Integer)element).intValue()];
        }
        Assert.notReached(""String_Node_Str"");
        return String.valueOf(element);
      }
    }
);
    m_reentryTypePropDesc=cbpd;
  }
  addPropertyDescriptor(m_reentryTypePropDesc);
  if (m_maxRetriesPropDesc == null) {
    m_maxRetriesPropDesc=new IntegerTextPropertyDescriptor(new MaxRetriesController(),P_ELEMENT_DISPLAY_MAXRETRIES,false,IEventExecTestCasePO.MIN_VALUE_MAX_NUM_RETRIES,IEventExecTestCasePO.MAX_VALUE_MAX_NUM_RETRIES);
  }
  if (((IEventExecTestCasePO)getPoNode()).getReentryProp().equals(ReentryProperty.RETRY)) {
    addPropertyDescriptor(m_maxRetriesPropDesc);
  }
  addPropertyDescriptor(super.createParamDescriptors());
}",0.9994711792702274
95331,"/** 
 * create property descriptor 
 */
private void createSpecNamePropertyDescriptor(){
  if (m_specNamePropDesc == null) {
    PropertyDescriptor propDes=new JBPropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
}","/** 
 * create property descriptor 
 */
private void createSpecNamePropertyDescriptor(){
  if (m_specNamePropDesc == null) {
    PropertyDescriptor propDes=new PropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
}",0.9973118279569892
95332,"/** 
 * Initializes the EventTypes.
 * @return a String-Array of Event Types.
 */
private static String[] initEventTypes(){
  Set mapKeySet=ComponentBuilder.getInstance().getCompSystem().getEventTypes().keySet();
  String[] eventTypes=new String[mapKeySet.size()];
  int i=0;
  final Map<String,String> stringHelperMap=StringHelper.getInstance().getMap();
  for (  Object object : mapKeySet) {
    eventTypes[i]=stringHelperMap.get(object.toString());
    i++;
  }
  return eventTypes;
}","/** 
 * Initializes the EventTypes.
 * @return a String-Array of Event Types.
 */
private static String[] initEventTypes(){
  Set<?> mapKeySet=ComponentBuilder.getInstance().getCompSystem().getEventTypes().keySet();
  String[] eventTypes=new String[mapKeySet.size()];
  int i=0;
  final Map<String,String> stringHelperMap=StringHelper.getInstance().getMap();
  for (  Object object : mapKeySet) {
    eventTypes[i]=stringHelperMap.get(object.toString());
    i++;
  }
  return eventTypes;
}",0.9969293756397134
95333,"/** 
 * create property descriptor 
 */
private void createTaskIdPropertyDescriptor(){
  if (getTaskIdPropDesc() == null) {
    JBPropertyDescriptor taskIdPropDesc=new JBPropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
    taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
    setTaskIdPropDesc(taskIdPropDesc);
  }
  addPropertyDescriptor(getTaskIdPropDesc());
}","/** 
 * create property descriptor 
 */
private void createTaskIdPropertyDescriptor(){
  if (getTaskIdPropDesc() == null) {
    PropertyDescriptor taskIdPropDesc=new PropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
    taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
    setTaskIdPropDesc(taskIdPropDesc);
  }
  addPropertyDescriptor(getTaskIdPropDesc());
}",0.9956043956043956
95334,"/** 
 * {@inheritDoc}
 */
protected void initPropDescriptor(){
  if (!getPropertyDescriptorList().isEmpty()) {
    clearPropertyDescriptors();
  }
  if (m_namePropDesc == null) {
    m_namePropDesc=new TextPropertyDescriptor(new ExecNameController(),P_REFERNCE_DISPLAY_NAME);
  }
  addPropertyDescriptor(m_namePropDesc);
  if (m_specNamePropDesc == null) {
    JBPropertyDescriptor propDes=new JBPropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
  if (m_commentPropDesc == null) {
    m_commentPropDesc=new TextPropertyDescriptor(new CommentController(),P_ELEMENT_DISPLAY_COMMENT);
  }
  addPropertyDescriptor(m_commentPropDesc);
  if (getTaskIdPropDesc() == null) {
    createJPropertyDescriptor();
  }
  addPropertyDescriptor(getTaskIdPropDesc());
  addPropertyDescriptor(getDataSourcePropertyDescr(new ExecTestCaseTestDataSourceController(this)));
  final JUnitTestSuiteController jsC=new JUnitTestSuiteController();
  createJUnitComboBox(jsC);
  if (m_extDataPropDesc == null) {
    m_extDataPropDesc=new TextPropertyDescriptor(new ExternalDataController(this),P_ELEMENT_DISPLAY_DATEFILE);
    m_extDataPropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_extDataPropDesc);
  if (m_referencedCubePropDesc == null) {
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    IContentProposalProvider dataCubeRefProposalProvider=null;
    IValidator dataCubeRefValidator=null;
    if (activeProject != null) {
      dataCubeRefProposalProvider=new TestDataCubeRefContentProposalProvider(activeProject,(IParameterInterfacePO)getPoNode());
      dataCubeRefValidator=new TestDataCubeReferenceValidator(activeProject);
    }
    m_referencedCubePropDesc=new ContentAssistedTextPropertyDescriptor(new ReferenceTestDataController(this),P_ELEMENT_DISPLAY_REFDATA,dataCubeRefProposalProvider,dataCubeRefValidator,ContentProposalAdapter.PROPOSAL_REPLACE);
    m_referencedCubePropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_referencedCubePropDesc);
  addPropertyDescriptor(createParamDescriptors());
}","/** 
 * {@inheritDoc}
 */
protected void initPropDescriptor(){
  if (!getPropertyDescriptorList().isEmpty()) {
    clearPropertyDescriptors();
  }
  if (m_namePropDesc == null) {
    m_namePropDesc=new TextPropertyDescriptor(new ExecNameController(),P_REFERNCE_DISPLAY_NAME);
  }
  addPropertyDescriptor(m_namePropDesc);
  if (m_specNamePropDesc == null) {
    PropertyDescriptor propDes=new PropertyDescriptor(new SpecNameController(),P_SPECNAME_DISPLAY_NAME);
    propDes.setLabelProvider(new DisabledLabelProvider());
    m_specNamePropDesc=propDes;
  }
  addPropertyDescriptor(m_specNamePropDesc);
  if (m_commentPropDesc == null) {
    m_commentPropDesc=new TextPropertyDescriptor(new CommentController(),P_ELEMENT_DISPLAY_COMMENT);
  }
  addPropertyDescriptor(m_commentPropDesc);
  if (getTaskIdPropDesc() == null) {
    createJPropertyDescriptor();
  }
  addPropertyDescriptor(getTaskIdPropDesc());
  addPropertyDescriptor(getDataSourcePropertyDescr(new ExecTestCaseTestDataSourceController(this)));
  final JUnitTestSuiteController jsC=new JUnitTestSuiteController();
  createJUnitComboBox(jsC);
  if (m_extDataPropDesc == null) {
    m_extDataPropDesc=new TextPropertyDescriptor(new ExternalDataController(this),P_ELEMENT_DISPLAY_DATEFILE);
    m_extDataPropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_extDataPropDesc);
  if (m_referencedCubePropDesc == null) {
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    IContentProposalProvider dataCubeRefProposalProvider=null;
    IValidator dataCubeRefValidator=null;
    if (activeProject != null) {
      dataCubeRefProposalProvider=new TestDataCubeRefContentProposalProvider(activeProject,(IParameterInterfacePO)getPoNode());
      dataCubeRefValidator=new TestDataCubeReferenceValidator(activeProject);
    }
    m_referencedCubePropDesc=new ContentAssistedTextPropertyDescriptor(new ReferenceTestDataController(this),P_ELEMENT_DISPLAY_REFDATA,dataCubeRefProposalProvider,dataCubeRefValidator,ContentProposalAdapter.PROPOSAL_REPLACE);
    m_referencedCubePropDesc.setCategory(P_TESTDATA_CAT);
  }
  addPropertyDescriptor(m_referencedCubePropDesc);
  addPropertyDescriptor(createParamDescriptors());
}",0.99909338168631
95335,"/** 
 * Property Descriptor for the Task ID
 */
private void createJPropertyDescriptor(){
  JBPropertyDescriptor taskIdPropDesc=new JBPropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
  taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
  setTaskIdPropDesc(taskIdPropDesc);
}","/** 
 * Property Descriptor for the Task ID
 */
private void createJPropertyDescriptor(){
  PropertyDescriptor taskIdPropDesc=new PropertyDescriptor(new ReadOnlyTaskIdController(),org.eclipse.jubula.client.ui.i18n.Messages.AbstractGuiNodePropertySourceTaskId);
  taskIdPropDesc.setLabelProvider(new DisabledLabelProvider());
  setTaskIdPropDesc(taskIdPropDesc);
}",0.9945205479452056
95336,"/** 
 * Inits the PropertyDescriptors
 */
protected void initPropDescriptor(){
  clearPropertyDescriptors();
  JBPropertyDescriptor propDes=null;
  propDes=new JBPropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ComponentTypeController(),P_ELEMENT_DISPLAY_COMPTYPE);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ParentProjectController(),P_ELEMENT_DISPLAY_PARENTPROJECT);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
}","/** 
 * Inits the PropertyDescriptors
 */
protected void initPropDescriptor(){
  clearPropertyDescriptors();
  PropertyDescriptor propDes=null;
  propDes=new PropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ComponentTypeController(),P_ELEMENT_DISPLAY_COMPTYPE);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ParentProjectController(),P_ELEMENT_DISPLAY_PARENTPROJECT);
  propDes.setCategory(P_COMPONENT_CAT);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
}",0.9953106682297772
95337,"/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=getNode().getCompIdentifier();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        JBPropertyDescriptor propDes=new JBPropertyDescriptor(new ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}","/** 
 * initializes the ComponentProperties
 */
private void initComponentProperties(){
  IComponentIdentifier compId=getNode().getCompIdentifier();
  if (compId != null) {
    Map<String,String> componentProperties=compId.getComponentPropertiesMap();
    if (componentProperties != null) {
      for (      String key : componentProperties.keySet()) {
        PropertyDescriptor propDes=new PropertyDescriptor(new ComponentPropertiesController(key,compId),key);
        propDes.setCategory(P_ELEMENT_DISPLAY_PROPERTY_INFORMATION);
        addPropertyDescriptor(propDes);
      }
    }
  }
}",0.9966273187183812
95338,"/** 
 * Inits the PropertyDescriptors
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  JBPropertyDescriptor propDes=null;
  propDes=new JBPropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ComponentClassController(),P_ELEMENT_DISPLAY_COMPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new JBPropertyDescriptor(new ComponentSuppClassController(),P_ELEMENT_DISPLAY_COMPSUPPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  initHierarchy();
  initContext();
  initComponentProperties();
}","/** 
 * Inits the PropertyDescriptors
 */
@SuppressWarnings(""String_Node_Str"") protected void initPropDescriptor(){
  clearPropertyDescriptors();
  PropertyDescriptor propDes=null;
  propDes=new PropertyDescriptor(new ComponentNameController(),P_ELEMENT_DISPLAY_COMPNAME);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ComponentClassController(),P_ELEMENT_DISPLAY_COMPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMP);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  propDes=new PropertyDescriptor(new ComponentSuppClassController(),P_ELEMENT_DISPLAY_COMPSUPPCLASS);
  propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
  propDes.setLabelProvider(new PropertyControllerLabelProvider());
  addPropertyDescriptor(propDes);
  initHierarchy();
  initContext();
  initComponentProperties();
}",0.995959595959596
95339,"/** 
 * Initializes the context
 */
private void initContext(){
  JBPropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List context=compId.getNeighbours();
    for (int i=0; i < context.size(); i++) {
      if (i == 0) {
        propDes=new JBPropertyDescriptor(new ComponentContextController(i),P_ELEMENT_DISPLAY_CONTEXT);
      }
 else {
        propDes=new JBPropertyDescriptor(new ComponentContextController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}","/** 
 * Initializes the context
 */
private void initContext(){
  PropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List context=compId.getNeighbours();
    for (int i=0; i < context.size(); i++) {
      if (i == 0) {
        propDes=new PropertyDescriptor(new ComponentContextController(i),P_ELEMENT_DISPLAY_CONTEXT);
      }
 else {
        propDes=new PropertyDescriptor(new ComponentContextController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}",0.9951690821256038
95340,"/** 
 * Initializes the hierarchy
 */
private void initHierarchy(){
  JBPropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List hierarchy=compId.getHierarchyNames();
    for (int i=0; i < hierarchy.size(); i++) {
      if (i == 0) {
        propDes=new JBPropertyDescriptor(new ComponentHierarchyController(i),P_ELEMENT_DISPLAY_HIERARCHY);
      }
 else {
        propDes=new JBPropertyDescriptor(new ComponentHierarchyController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}","/** 
 * Initializes the hierarchy
 */
private void initHierarchy(){
  PropertyDescriptor propDes=null;
  IComponentIdentifier compId=getNode().getTechnicalName();
  if (compId != null) {
    List<?> hierarchy=compId.getHierarchyNames();
    for (int i=0; i < hierarchy.size(); i++) {
      if (i == 0) {
        propDes=new PropertyDescriptor(new ComponentHierarchyController(i),P_ELEMENT_DISPLAY_HIERARCHY);
      }
 else {
        propDes=new PropertyDescriptor(new ComponentHierarchyController(i),StringConstants.EMPTY);
      }
      propDes.setCategory(P_ELEMENT_DISPLAY_COMPADDINFO);
      addPropertyDescriptor(propDes);
    }
  }
}",0.9929742388758782
95341,"/** 
 * Refreshes the currently open Project.
 * @return the result of the operation.
 */
public IStatus refreshProject(){
  Plugin.startLongRunning(Messages.RefreshTSBrowserActionProgressMessage);
  try {
    PlatformUI.getWorkbench().getProgressService().run(true,false,new RefreshProjectOperation());
  }
 catch (  InvocationTargetException e) {
    return new Status(IStatus.ERROR,Plugin.PLUGIN_ID,e.getLocalizedMessage());
  }
catch (  InterruptedException e) {
    return Status.CANCEL_STATUS;
  }
 finally {
    Plugin.stopLongRunning();
    DataEventDispatcher.getInstance().fireProjectStateChanged(ProjectState.opened);
  }
  return Status.OK_STATUS;
}","/** 
 * Refreshes the currently open Project.
 * @return the result of the operation.
 */
public IStatus refreshProject(){
  Plugin.startLongRunning(Messages.RefreshTSBrowserActionProgressMessage);
  ProblemPropagator.INSTANCE.cancelPropagationJobs();
  try {
    PlatformUI.getWorkbench().getProgressService().run(true,false,new RefreshProjectOperation());
  }
 catch (  InvocationTargetException e) {
    return new Status(IStatus.ERROR,Plugin.PLUGIN_ID,e.getLocalizedMessage());
  }
catch (  InterruptedException e) {
    return Status.CANCEL_STATUS;
  }
 finally {
    Plugin.stopLongRunning();
    DataEventDispatcher.getInstance().fireProjectStateChanged(ProjectState.opened);
  }
  return Status.OK_STATUS;
}",0.9607558139534884
95342,"@Override protected String getMainClassFromManifest(Map parameters){
  String jarFile=createAbsoluteJarPath(parameters);
  String attr=getAttributeFromManifest(""String_Node_Str"",jarFile);
  return attr.replace(""String_Node_Str"",""String_Node_Str"");
}","@Override protected String getMainClassFromManifest(Map parameters){
  String jarFile=createAbsoluteJarPath(parameters);
  String attr=getAttributeFromManifest(""String_Node_Str"",jarFile);
  if (attr != null) {
    return attr.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return null;
}",0.9205175600739371
95343,"/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState){
  if (po instanceof INodePO) {
    TreeViewer tv=getTreeViewer();
switch (dataState) {
case Added:
      INodePO addedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
  if (editorNode.indexOf(addedNode) > -1) {
    getTreeViewer().refresh();
    getTreeViewer().expandAll();
    UINodeBP.setFocusAndSelection(new StructuredSelection(addedNode),tv);
  }
break;
case Deleted:
if (!(po instanceof IProjectPO)) {
getTreeViewer().refresh();
setFocus();
}
break;
case Renamed:
createPartName();
break;
case StructureModified:
if (!handleStructureModified(po)) {
return;
}
break;
case ReuseChanged:
break;
default :
Assert.notReached();
}
getEditorHelper().handleDataChanged(po,dataState);
}
}","/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState){
  if (po instanceof INodePO) {
    TreeViewer tv=getTreeViewer();
switch (dataState) {
case Added:
      INodePO addedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
  if (editorNode.indexOf(addedNode) > -1) {
    getTreeViewer().refresh();
    getTreeViewer().expandAll();
    UINodeBP.setFocusAndSelection(new StructuredSelection(addedNode),tv);
  }
break;
case Deleted:
if (!(po instanceof IProjectPO)) {
getTreeViewer().refresh();
setFocus();
}
break;
case Renamed:
createPartName();
break;
case StructureModified:
if (!handleStructureModified(po)) {
return;
}
break;
case ReuseChanged:
break;
case Saved:
break;
default :
Assert.notReached();
}
getEditorHelper().handleDataChanged(po,dataState);
}
}",0.9793753682969948
95344,"/** 
 * @param root node, where starts the validation
 * @param ts changed test suite
 * @return if editor contains an reusing testcase for given specTestCase
 */
@SuppressWarnings(""String_Node_Str"") private static boolean containsWorkVersionReuses(INodePO root,ITestSuitePO ts){
  final Iterator it=root.getNodeListIterator();
  final List<INodePO> childList=IteratorUtils.toList(it);
  for (  INodePO child : childList) {
    if (child instanceof IRefTestSuitePO) {
      final IRefTestSuitePO refTs=(IRefTestSuitePO)child;
      if (ts.getGuid().equals(refTs.getTestSuiteGuid())) {
        return true;
      }
      if (containsWorkVersionReuses(refTs,ts)) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * @param root node, where starts the validation
 * @param ts changed test suite
 * @return if editor contains an reusing testcase for given specTestCase
 */
@SuppressWarnings(""String_Node_Str"") private static boolean containsWorkVersionReuses(INodePO root,ITestSuitePO ts){
  final Iterator<INodePO> it=root.getNodeListIterator();
  final List<INodePO> childList=IteratorUtils.toList(it);
  for (  INodePO child : childList) {
    if (child instanceof IRefTestSuitePO) {
      final IRefTestSuitePO refTs=(IRefTestSuitePO)child;
      if (ts.getGuid().equals(refTs.getTestSuiteGuid())) {
        return true;
      }
      if (containsWorkVersionReuses(refTs,ts)) {
        return true;
      }
    }
  }
  return false;
}",0.7933655839668279
95345,"/** 
 * {@inheritDoc}
 */
public void run(IProgressMonitor monitor){
  monitor.beginTask(Messages.RefreshProjectOperationRefreshing,IProgressMonitor.UNKNOWN);
  ProgressMonitorTracker instance=ProgressMonitorTracker.SINGLETON;
  instance.setProgressMonitor(monitor);
  try {
    IProjectPO referencedProject=ProjectPM.loadReusedProjectInMasterSession(m_selectedProject);
    GeneralStorage.getInstance().getMasterSession().refresh(referencedProject.getSpecObjCont());
    DataEventDispatcher.getInstance().fireDataChangedListener(new DataChangedEvent(referencedProject,DataState.StructureModified,UpdateState.all));
  }
 catch (  ProjectDeletedException e) {
    PMExceptionHandler.handleProjectDeletedException();
  }
catch (  JBException e) {
    ErrorHandlingUtil.createMessageDialog(e,null,null);
  }
 finally {
    instance.setProgressMonitor(null);
    monitor.done();
  }
}","public void run(){
  DataEventDispatcher.getInstance().fireDataChangedListener(new DataChangedEvent(referencedProject,DataState.StructureModified,UpdateState.all));
}",0.3173996175908222
95346,"/** 
 * @param paramDesc the {@link IParamDescriptionPO} should be of type {@link ITcParamDescriptionPO}
 * @return the values from the {@link IParamValueSetPO}
 */
private static String[] getValuesFromValueSet(IParamDescriptionPO paramDesc){
  String[] values=new String[0];
  if (paramDesc instanceof ITcParamDescriptionPO) {
    ITcParamDescriptionPO desc=(ITcParamDescriptionPO)paramDesc;
    List<String> collect=desc.getValueSet().getValues().stream().map(IValueCommentPO::getValue).collect(Collectors.toList());
    values=collect.toArray(new String[collect.size()]);
  }
  return values;
}","/** 
 * @param paramDesc the {@link IParamDescriptionPO} should be of type {@link ITcParamDescriptionPO}
 * @return the values from the {@link IParamValueSetPO}
 */
private static Map<String,String> getValuesFromValueSet(IParamDescriptionPO paramDesc){
  if (paramDesc instanceof ITcParamDescriptionPO) {
    ITcParamDescriptionPO desc=(ITcParamDescriptionPO)paramDesc;
    IParamValueSetPO valueSet=desc.getValueSet();
    List<IValueCommentPO> values=valueSet.getValues();
    if (valueSet != null && values != null && values.size() > 0) {
      return values.stream().collect(Collectors.toMap(IValueCommentPO::getValue,IValueCommentPO::getComment));
    }
  }
  return new HashMap<>();
}",0.4273504273504273
95347,"/** 
 * Creates Controls depending on the given IParamNodePO and the given parameter name in dataset view.<br> E.g. it returns a Text Control which only accepts Integers.
 * @param paramName the current parameter name
 * @param paramObj the current param object
 * @param parent the parent composite
 * @param style the style of the new Control
 * @return the control to edit test data
 */
public static Control createControl(IParameterInterfacePO paramObj,String paramName,Composite parent,int style){
  Map<String,String> map=StringHelper.getInstance().getMap();
  String nameOfParam=paramName;
  IParamDescriptionPO paramDesc=paramObj.getParameterForName(nameOfParam);
  if (paramDesc == null) {
    nameOfParam=map.get(paramName);
    paramDesc=paramObj.getParameterForName(nameOfParam);
  }
  if (paramObj instanceof ICapPO) {
    ICapPO cap=(ICapPO)paramObj;
    Action action=CapBP.getAction(cap);
    List<String> values=new ArrayList<String>();
    Param param=action.findParam(paramDesc.getUniqueId());
    for (Iterator<ValueSetElement> iter=param.valueSetIterator(); iter.hasNext(); ) {
      values.add(map.get((iter.next()).getValue()));
    }
    if (!values.isEmpty()) {
      return new CheckedParamText(parent,style,cap,paramDesc,createParamValueValidator(TestDataConstants.STR,param.getValueSet().isCombinable(),values.toArray(new String[values.size()])));
    }
  }
  if (paramObj instanceof IParamNodePO) {
    IParamNodePO paramNode=(IParamNodePO)paramObj;
    ParamValueSet valueSet=ParamTextPropertyDescriptor.getValuesSet(paramNode,paramDesc.getUniqueId());
    String[] values=ParamTextPropertyDescriptor.getValues(valueSet);
    Map<String,String> valuesWithComment=ParamTextPropertyDescriptor.getValuesWithComment(valueSet);
    if (TestDataConstants.BOOLEAN.equals(paramDesc.getType())) {
      values=BOOLEAN_VALUES;
      valuesWithComment.clear();
      valuesWithComment.put(BOOLEAN_VALUES[0],StringConstants.EMPTY);
      valuesWithComment.put(BOOLEAN_VALUES[1],StringConstants.EMPTY);
    }
    return new CheckedParamTextContentAssisted(parent,style,paramNode,paramDesc,createParamValueValidator(paramDesc.getType(),valueSet != null ? valueSet.isCombinable() : false,values),new ParamProposalProvider(valuesWithComment,paramNode,paramDesc));
  }
  if (paramObj instanceof ITestDataCubePO) {
    ITestDataCubePO tdc=(ITestDataCubePO)paramObj;
    String[] values=getValuesFromValueSet(paramDesc);
    if (TestDataConstants.BOOLEAN.equals(paramDesc.getType())) {
      return new CheckedParamTextContentAssisted(parent,style,tdc,paramDesc,createParamValueValidator(paramDesc.getType(),false,BOOLEAN_VALUES),new ParamProposalProvider(BOOLEAN_VALUES,null,paramDesc));
    }
    return new CheckedParamTextContentAssisted(parent,style,tdc,paramDesc,createParamValueValidator(paramDesc.getType(),false,values),new ParamProposalProvider(values,null,paramDesc));
  }
  Assert.notReached(Messages.ImplementFor + StringConstants.SPACE + paramObj.getClass().getName());
  return null;
}","/** 
 * Creates Controls depending on the given IParamNodePO and the given parameter name in dataset view.<br> E.g. it returns a Text Control which only accepts Integers.
 * @param paramName the current parameter name
 * @param paramObj the current param object
 * @param parent the parent composite
 * @param style the style of the new Control
 * @return the control to edit test data
 */
public static Control createControl(IParameterInterfacePO paramObj,String paramName,Composite parent,int style){
  Map<String,String> map=StringHelper.getInstance().getMap();
  String nameOfParam=paramName;
  IParamDescriptionPO paramDesc=paramObj.getParameterForName(nameOfParam);
  if (paramDesc == null) {
    nameOfParam=map.get(paramName);
    paramDesc=paramObj.getParameterForName(nameOfParam);
  }
  if (paramObj instanceof ICapPO) {
    ICapPO cap=(ICapPO)paramObj;
    Action action=CapBP.getAction(cap);
    List<String> values=new ArrayList<String>();
    Param param=action.findParam(paramDesc.getUniqueId());
    for (Iterator<ValueSetElement> iter=param.valueSetIterator(); iter.hasNext(); ) {
      values.add(map.get((iter.next()).getValue()));
    }
    if (!values.isEmpty()) {
      return new CheckedParamText(parent,style,cap,paramDesc,createParamValueValidator(TestDataConstants.STR,param.getValueSet().isCombinable(),values.toArray(new String[values.size()])));
    }
  }
  if (paramObj instanceof IParamNodePO) {
    IParamNodePO paramNode=(IParamNodePO)paramObj;
    ParamValueSet valueSet=ParamTextPropertyDescriptor.getValuesSet(paramNode,paramDesc.getUniqueId());
    String[] values=ParamTextPropertyDescriptor.getValues(valueSet);
    Map<String,String> valuesWithComment=ParamTextPropertyDescriptor.getValuesWithComment(valueSet);
    if (TestDataConstants.BOOLEAN.equals(paramDesc.getType())) {
      values=BOOLEAN_VALUES;
      valuesWithComment.clear();
      valuesWithComment.put(BOOLEAN_VALUES[0],StringConstants.EMPTY);
      valuesWithComment.put(BOOLEAN_VALUES[1],StringConstants.EMPTY);
    }
    return new CheckedParamTextContentAssisted(parent,style,paramNode,paramDesc,createParamValueValidator(paramDesc.getType(),valueSet != null ? valueSet.isCombinable() : false,values),new ParamProposalProvider(valuesWithComment,paramNode,paramDesc));
  }
  if (paramObj instanceof ITestDataCubePO) {
    ITestDataCubePO tdc=(ITestDataCubePO)paramObj;
    Map<String,String> values=getValuesFromValueSet(paramDesc);
    if (TestDataConstants.BOOLEAN.equals(paramDesc.getType())) {
      return new CheckedParamTextContentAssisted(parent,style,tdc,paramDesc,createParamValueValidator(paramDesc.getType(),false,BOOLEAN_VALUES),new ParamProposalProvider(BOOLEAN_VALUES,null,paramDesc));
    }
    return new CheckedParamTextContentAssisted(parent,style,tdc,paramDesc,createParamValueValidator(paramDesc.getType(),false,values.keySet().toArray(new String[values.size()])),new ParamProposalProvider(values,null,paramDesc));
  }
  Assert.notReached(Messages.ImplementFor + StringConstants.SPACE + paramObj.getClass().getName());
  return null;
}",0.988479262672811
95348,"/** 
 * @param paramBP the paramBP to set
 */
private void setParamBP(AbstractParamInterfaceBP paramBP){
  m_paramBP=paramBP;
}","/** 
 * @param paramBP the paramBP to set
 */
private void setParamBP(AbstractParamInterfaceBP<?> paramBP){
  m_paramBP=paramBP;
}",0.9883268482490272
95349,"/** 
 * @param selection the current selection
 * @return the valid param interface po or <code>null</code> if currentselection does not contain a IParameterInterfacePO
 */
private IParameterInterfacePO getSelectedParamInterfaceObj(IStructuredSelection selection){
  IParameterInterfacePO paramInterfacePO=null;
  Object firstSel=selection.getFirstElement();
  if (firstSel instanceof SearchResultElement) {
    firstSel=((SearchResultElement)firstSel).getObject();
  }
  if (firstSel instanceof IParameterInterfacePO) {
    paramInterfacePO=(IParameterInterfacePO)firstSel;
  }
  return paramInterfacePO;
}","/** 
 * @param selection the current selection
 * @return the valid param interface po or <code>null</code> if currentselection does not contain a IParameterInterfacePO
 */
private IParameterInterfacePO getSelectedParamInterfaceObj(IStructuredSelection selection){
  IParameterInterfacePO paramInterfacePO=null;
  Object firstSel=selection.getFirstElement();
  if (firstSel instanceof SearchResultElement) {
    firstSel=((SearchResultElement<?>)firstSel).getObject();
  }
  if (firstSel instanceof IParameterInterfacePO) {
    paramInterfacePO=(IParameterInterfacePO)firstSel;
  }
  return paramInterfacePO;
}",0.9975349219391948
95350,"/** 
 * The constructor
 * @param bp the business process to use for this page
 */
public AbstractDataSetPage(AbstractParamInterfaceBP bp){
  setParamBP(bp);
}","/** 
 * The constructor
 * @param bp the business process to use for this page
 */
public AbstractDataSetPage(AbstractParamInterfaceBP<?> bp){
  setParamBP(bp);
}",0.9906542056074766
95351,"/** 
 * @return the paramBP
 */
private AbstractParamInterfaceBP getParamBP(){
  return m_paramBP;
}","/** 
 * @return the paramBP
 */
private AbstractParamInterfaceBP<?> getParamBP(){
  return m_paramBP;
}",0.9852216748768472
95352,"/** 
 * @param oldParamsMap the old parameters for comparison
 * @param params the maybe changed parmaters
 * @param paramsToRename the map which parameter should be renamed
 * @param paramsToChangeUsage the map which parameter should the usage be updated
 * @param paramsToUpdate the map which parameter should the value set be updated
 */
private static void fillMapsWithChanges(Map<String,IParamDescriptionPO> oldParamsMap,List<Parameter> params,Map<IParamDescriptionPO,String> paramsToRename,Map<IParamDescriptionPO,String> paramsToChangeUsage,Map<IParamDescriptionPO,Parameter> paramsToUpdate){
  for (  Parameter param : params) {
    IParamDescriptionPO paramDescr=oldParamsMap.get(param.getGuid());
    if (paramDescr != null) {
      if (!(paramDescr.getName().equals(param.getName()))) {
        Parameter paramNotRenamed=getNotRenamedParamWithSameName(oldParamsMap,params,param);
        if (paramNotRenamed == null) {
          paramsToRename.put(paramDescr,param.getName());
        }
 else {
          paramsToChangeUsage.put(paramDescr,paramNotRenamed.getGuid());
        }
      }
      if (paramDescr instanceof ITcParamDescriptionPO) {
        ITcParamDescriptionPO tcdesc=(ITcParamDescriptionPO)paramDescr;
        IParamValueSetPO valueSet=tcdesc.getValueSet();
        List<IValueCommentPO> values=valueSet.getValues();
        List<ValueComment> paramValues=param.getValueSet();
        String paramDefault=param.getDefaultValue();
        String valueSetDefault=valueSet.getDefaultValue();
        if (!StringUtils.equals(valueSetDefault,paramDefault)) {
          paramsToUpdate.put(tcdesc,param);
        }
 else         if (values.size() != paramValues.size()) {
          paramsToUpdate.put(tcdesc,param);
        }
 else {
          for (          ValueComment vcParam : paramValues) {
            boolean found=false;
            for (            IValueCommentPO vc : values) {
              if (StringUtils.equals(vcParam.getValue(),(vc.getValue()))) {
                found=true;
                if (StringUtils.equals(vcParam.getComment(),vc.getComment())) {
                  paramsToUpdate.put(tcdesc,param);
                }
              }
            }
            if (!found) {
              paramsToUpdate.put(tcdesc,param);
            }
          }
        }
      }
    }
 else {
      Assert.notReached(Messages.UnexpectedError + StringConstants.COLON + StringConstants.SPACE+ Messages.ModificationOfNonExistingParameter+ StringConstants.DOT);
    }
  }
}","/** 
 * @param oldParamsMap the old parameters for comparison
 * @param params the maybe changed parmaters
 * @param paramsToRename the map which parameter should be renamed
 * @param paramsToChangeUsage the map which parameter should the usage be updated
 * @param paramsToUpdate the map which parameter should the value set be updated
 */
private static void fillMapsWithChanges(Map<String,IParamDescriptionPO> oldParamsMap,List<Parameter> params,Map<IParamDescriptionPO,String> paramsToRename,Map<IParamDescriptionPO,String> paramsToChangeUsage,Map<IParamDescriptionPO,Parameter> paramsToUpdate){
  for (  Parameter param : params) {
    IParamDescriptionPO paramDescr=oldParamsMap.get(param.getGuid());
    if (paramDescr != null) {
      if (!(paramDescr.getName().equals(param.getName()))) {
        Parameter paramNotRenamed=getNotRenamedParamWithSameName(oldParamsMap,params,param);
        if (paramNotRenamed == null) {
          paramsToRename.put(paramDescr,param.getName());
        }
 else {
          paramsToChangeUsage.put(paramDescr,paramNotRenamed.getGuid());
        }
      }
      if (paramDescr instanceof ITcParamDescriptionPO) {
        ITcParamDescriptionPO tcdesc=(ITcParamDescriptionPO)paramDescr;
        IParamValueSetPO valueSet=tcdesc.getValueSet();
        List<IValueCommentPO> values=valueSet.getValues();
        List<ValueComment> paramValues=param.getValueSet();
        String paramDefault=param.getDefaultValue();
        String valueSetDefault=valueSet.getDefaultValue();
        if (!StringUtils.equals(valueSetDefault,paramDefault)) {
          paramsToUpdate.put(tcdesc,param);
        }
 else         if (values.size() != paramValues.size()) {
          paramsToUpdate.put(tcdesc,param);
        }
 else {
          for (          ValueComment vcParam : paramValues) {
            boolean found=false;
            for (            IValueCommentPO vc : values) {
              if (StringUtils.equals(vcParam.getValue(),(vc.getValue()))) {
                found=true;
                if (!StringUtils.equals(vcParam.getComment(),vc.getComment())) {
                  paramsToUpdate.put(tcdesc,param);
                }
              }
            }
            if (!found) {
              paramsToUpdate.put(tcdesc,param);
            }
          }
        }
      }
    }
 else {
      Assert.notReached(Messages.UnexpectedError + StringConstants.COLON + StringConstants.SPACE+ Messages.ModificationOfNonExistingParameter+ StringConstants.DOT);
    }
  }
}",0.9997999599919984
95353,"@SuppressWarnings(""String_Node_Str"") public void proposalPopupClosed(ContentProposalAdapter adapter){
  setFocus();
  m_popupOpen=false;
}","@SuppressWarnings(""String_Node_Str"") public void proposalPopupClosed(ContentProposalAdapter adapter){
  m_popupOpen=false;
}",0.9465648854961832
95354,"/** 
 * Activates content assist (if it is supported).
 * @param contentProposalProvider The proposal provider to use for content assist.
 * @param proposalAcceptanceStyle The integer style that indicates how an accepted proposal  affects the control's content. See  {@link ContentProposalAdapter#setProposalAcceptanceStyle(int)}.
 */
private void enableContentProposal(IContentProposalProvider contentProposalProvider,int proposalAcceptanceStyle){
  if (contentProposalProvider != null) {
    ContentProposalAdapter contentProposalAdapter=new ContentProposalAdapter(text,new TextContentAdapter(),contentProposalProvider,ContentAssistUtil.getTriggerKeyStroke(),ContentAssistUtil.getTriggerChars());
    contentProposalAdapter.setFilterStyle(ContentProposalAdapter.FILTER_NONE);
    contentProposalAdapter.setProposalAcceptanceStyle(proposalAcceptanceStyle);
    contentProposalAdapter.addContentProposalListener(new IContentProposalListener2(){
      @SuppressWarnings(""String_Node_Str"") public void proposalPopupClosed(      ContentProposalAdapter adapter){
        setFocus();
        m_popupOpen=false;
      }
      @SuppressWarnings(""String_Node_Str"") public void proposalPopupOpened(      ContentProposalAdapter adapter){
        m_popupOpen=true;
      }
    }
);
  }
}","/** 
 * Activates content assist (if it is supported).
 * @param contentProposalProvider The proposal provider to use for content assist.
 * @param proposalAcceptanceStyle The integer style that indicates how an accepted proposal  affects the control's content. See  {@link ContentProposalAdapter#setProposalAcceptanceStyle(int)}.
 */
private void enableContentProposal(IContentProposalProvider contentProposalProvider,int proposalAcceptanceStyle){
  if (contentProposalProvider != null) {
    ContentProposalAdapter contentProposalAdapter=new ContentProposalAdapter(text,new TextContentAdapter(),contentProposalProvider,ContentAssistUtil.getTriggerKeyStroke(),ContentAssistUtil.getTriggerChars());
    contentProposalAdapter.setFilterStyle(ContentProposalAdapter.FILTER_NONE);
    contentProposalAdapter.setProposalAcceptanceStyle(proposalAcceptanceStyle);
    contentProposalAdapter.addContentProposalListener(new IContentProposalListener2(){
      @SuppressWarnings(""String_Node_Str"") public void proposalPopupClosed(      ContentProposalAdapter adapter){
        m_popupOpen=false;
      }
      @SuppressWarnings(""String_Node_Str"") public void proposalPopupOpened(      ContentProposalAdapter adapter){
        m_popupOpen=true;
      }
    }
);
  }
}",0.9921011058451816
95355,"/** 
 * Handles the CR keys
 */
private void handleCR(){
  if (m_editor.getEditor() instanceof CheckedParamTextContentAssisted) {
    CheckedParamTextContentAssisted ed=(CheckedParamTextContentAssisted)m_editor.getEditor();
    if (ed.isAccepted()) {
      ed.setAccepted(false);
      return;
    }
  }
  final Control editorControl=m_editor.getEditor();
  if (!editorControl.isDisposed()) {
    writeData();
  }
  if (!editorControl.isDisposed()) {
    TableItem rowItem=getRow();
    final int col=getColumn();
    rowItem.setText(col,TextControlBP.getText(editorControl));
    editorControl.dispose();
    final int row=getTable().indexOf(getRow());
    if (getTable().getColumnCount() > (col + 1)) {
      setSelection(row,col + 1);
      getTable().setSelection(row);
      setFocus();
    }
 else     if (getTable().getItemCount() > (row + 1)) {
      setSelection(row + 1,1);
      getTable().setSelection(row + 1);
    }
 else {
      getAddButton().setFocus();
    }
  }
}","/** 
 * Handles the CR keys
 */
private void handleCR(){
  if (m_editor.getEditor() instanceof CheckedParamTextContentAssisted) {
    CheckedParamTextContentAssisted ed=(CheckedParamTextContentAssisted)m_editor.getEditor();
  }
  final Control editorControl=m_editor.getEditor();
  if (!editorControl.isDisposed()) {
    writeData();
  }
  if (!editorControl.isDisposed()) {
    TableItem rowItem=getRow();
    final int col=getColumn();
    rowItem.setText(col,TextControlBP.getText(editorControl));
    editorControl.dispose();
    final int row=getTable().indexOf(getRow());
    if (getTable().getColumnCount() > (col + 1)) {
      setSelection(row,col + 1);
      getTable().setSelection(row);
      setFocus();
    }
 else     if (getTable().getItemCount() > (row + 1)) {
      setSelection(row + 1,1);
      getTable().setSelection(row + 1);
    }
 else {
      getAddButton().setFocus();
    }
  }
}",0.9597457627118644
95356,"/** 
 * @param parent parent
 * @param style style
 * @param node current node, associated with parameter for this value
 * @param desc parameter description associated with current edited value
 * @param dataValidator validator for data validation
 * @param proposalProvider The content proposal provider for this textfield, or <code>null</code> if no content assist is available.
 */
@SuppressWarnings(""String_Node_Str"") public CheckedParamTextContentAssisted(Composite parent,int style,IParameterInterfacePO node,IParamDescriptionPO desc,IParamValueValidator dataValidator,IContentProposalProvider proposalProvider){
  super(parent,style,node,desc,dataValidator);
  m_popupListener=new IContentProposalListener2Implementation();
  ContentProposalAdapter cpa=new ContentProposalAdapter(this,new TextContentAdapter(),proposalProvider,ContentAssistUtil.getTriggerKeyStroke(),ContentAssistUtil.getTriggerChars());
  cpa.setFilterStyle(ContentProposalAdapter.FILTER_NONE);
  cpa.setProposalAcceptanceStyle(ContentProposalAdapter.PROPOSAL_INSERT);
  cpa.addContentProposalListener(m_popupListener);
  cpa.addContentProposalListener(new IContentProposalListener(){
    @Override public void proposalAccepted(    IContentProposal proposal){
      m_accepted=true;
    }
  }
);
}","/** 
 * @param parent parent
 * @param style style
 * @param node current node, associated with parameter for this value
 * @param desc parameter description associated with current edited value
 * @param dataValidator validator for data validation
 * @param proposalProvider The content proposal provider for this textfield, or <code>null</code> if no content assist is available.
 */
@SuppressWarnings(""String_Node_Str"") public CheckedParamTextContentAssisted(Composite parent,int style,IParameterInterfacePO node,IParamDescriptionPO desc,IParamValueValidator dataValidator,IContentProposalProvider proposalProvider){
  super(parent,style,node,desc,dataValidator);
  m_popupListener=new IContentProposalListener2Implementation();
  ContentProposalAdapter cpa=new ContentProposalAdapter(this,new TextContentAdapter(),proposalProvider,ContentAssistUtil.getTriggerKeyStroke(),ContentAssistUtil.getTriggerChars());
  cpa.setFilterStyle(ContentProposalAdapter.FILTER_NONE);
  cpa.setProposalAcceptanceStyle(ContentProposalAdapter.PROPOSAL_INSERT);
  cpa.addContentProposalListener(m_popupListener);
}",0.9257383966244724
95357,"@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView table=getRealComponent();
      TableColumn<?,?> col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
 else {
        col=getRealComponent().getVisibleLeafColumn(column);
      }
      table.scrollToColumn(col);
      return TableUtils.getNodeBoundsofHeader(table,column,true);
    }
  }
);
  return result;
}","@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView table=getRealComponent();
      TableColumn<?,?> col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
 else {
        col=getRealComponent().getVisibleLeafColumn(column);
      }
      table.scrollToColumn(col);
      return TableUtils.getNodeBoundsofHeader(table,col,true);
    }
  }
);
  return result;
}",0.9974025974025974
95358,"@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeTableView<?> treeTable=getTree();
      TreeTableColumn col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
 else {
        col=treeTable.getVisibleLeafColumn(column);
      }
      treeTable.scrollToColumn(col);
      treeTable.layout();
      Rectangle b=TableUtils.getNodeBoundsofHeader(treeTable,column,false);
      Rectangle tableB=NodeBounds.getAbsoluteBounds(treeTable);
      return new Rectangle(Math.abs(tableB.x - b.x),Math.abs(tableB.y - b.y),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
    }
  }
);
  return result;
}","@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeTableView<?> treeTable=getTree();
      TreeTableColumn col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
 else {
        col=treeTable.getVisibleLeafColumn(column);
      }
      treeTable.scrollToColumn(col);
      treeTable.layout();
      Rectangle b=TableUtils.getNodeBoundsofHeader(treeTable,col,false);
      Rectangle tableB=NodeBounds.getAbsoluteBounds(treeTable);
      return new Rectangle(Math.abs(tableB.x - b.x),Math.abs(tableB.y - b.y),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
    }
  }
);
  return result;
}",0.99815157116451
95359,"/** 
 * @param combobox the combobox
 * @return a {@link ListView} which is the list of the {@link ComboBox}
 */
public static ListView<?> getPopUpContent(ComboBox<?> combobox){
  Class<?> clazz=null;
  try {
    clazz=Class.forName(JAVA8_COMBO_LISTVIEWSKIN);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_COMBO_LISTVIEWSKIN);
    }
 catch (    ClassNotFoundException e2) {
      throw new RuntimeException(e2);
    }
  }
  try {
    Method method=clazz.getMethod(GET_POPUP_CONTENT);
    Object o=method.invoke(combobox);
    if (o instanceof ListView<?>) {
      return (ListView<?>)o;
    }
  }
 catch (  NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(e);
  }
  return null;
}","/** 
 * @param combobox the combobox
 * @return a {@link ListView} which is the list of the {@link ComboBox}
 */
public static ListView<?> getPopUpContent(ComboBox<?> combobox){
  Class<?> clazz=null;
  Object skin=combobox.getSkin();
  try {
    clazz=Class.forName(JAVA8_COMBO_LISTVIEWSKIN);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_COMBO_LISTVIEWSKIN);
    }
 catch (    ClassNotFoundException e2) {
      throw new RuntimeException(e2);
    }
  }
  try {
    Method method=clazz.getMethod(GET_POPUP_CONTENT);
    Object o=method.invoke(skin);
    if (o instanceof ListView<?>) {
      return (ListView<?>)o;
    }
  }
 catch (  NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(e);
  }
  return null;
}",0.97242206235012
95360,"/** 
 * @param table the {@link TableView}
 * @param column the column number
 * @param relative should the calculation be relative or absolute
 * @return the {@link Rectangle} or null if it is not found
 */
public static Rectangle getNodeBoundsofHeader(Parent table,int column,boolean relative){
  Class<?> clazz=null;
  try {
    clazz=Class.forName(JAVA8_TABLE_HEADER_ROW);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_TABLE_HEADER_ROW);
    }
 catch (    ClassNotFoundException e2) {
      String message=""String_Node_Str"" + JAVA8_TABLE_HEADER_ROW + ""String_Node_Str""+ JAVA9_TABLE_HEADER_ROW+ ""String_Node_Str"";
      log.error(message,e2);
      throw new RuntimeException(message,e2);
    }
  }
  try {
    List<?> headerRow=NodeTraverseHelper.getInstancesOf(table,clazz);
    Object colH=null;
    for (    Object tableHeaderRow : headerRow) {
      Method method=clazz.getMethod(GET_COLUMN_HEADER_FOR,Integer.class);
      colH=method.invoke(tableHeaderRow,column);
      if (colH != null) {
        if (relative) {
          return NodeBounds.getRelativeBounds((Node)colH,(Node)tableHeaderRow);
        }
        return NodeBounds.getAbsoluteBounds((Node)colH);
      }
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * @param table the {@link TableView}
 * @param column the column number
 * @param relative should the calculation be relative or absolute
 * @return the {@link Rectangle} or null if it is not found
 */
public static Rectangle getNodeBoundsofHeader(Parent table,TableColumnBase<?,?> column,boolean relative){
  Class<?> clazz=null;
  try {
    clazz=Class.forName(JAVA8_TABLE_HEADER_ROW);
  }
 catch (  ClassNotFoundException e) {
    try {
      clazz=Class.forName(JAVA9_TABLE_HEADER_ROW);
    }
 catch (    ClassNotFoundException e2) {
      String message=""String_Node_Str"" + JAVA8_TABLE_HEADER_ROW + ""String_Node_Str""+ JAVA9_TABLE_HEADER_ROW+ ""String_Node_Str"";
      log.error(message,e2);
      throw new RuntimeException(message,e2);
    }
  }
  try {
    List<?> headerRow=NodeTraverseHelper.getInstancesOf(table,clazz);
    Object colH=null;
    for (    Object tableHeaderRow : headerRow) {
      Method method=clazz.getMethod(GET_COLUMN_HEADER_FOR,TableColumnBase.class);
      colH=method.invoke(tableHeaderRow,column);
      if (colH != null) {
        if (relative) {
          return NodeBounds.getRelativeBounds((Node)colH,(Node)tableHeaderRow);
        }
        return NodeBounds.getAbsoluteBounds((Node)colH);
      }
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}",0.9842160645387584
95361,"/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState,UpdateState updState){
  if (po instanceof INodePO) {
    INodePO changedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
    boolean isVisibleInEditor=editorNode.indexOf(changedNode) > -1;
    isVisibleInEditor|=contains(editorNode,changedNode);
    if (editorNode instanceof ISpecTestCasePO) {
      isVisibleInEditor|=((ISpecTestCasePO)editorNode).getAllEventEventExecTC().contains(po);
    }
switch (dataState) {
case Added:
      if (isVisibleInEditor) {
        handleNodeAdded(changedNode);
      }
    break;
case Deleted:
  if (!(po instanceof IProjectPO)) {
    isVisibleInEditor=true;
    refresh();
  }
break;
case Renamed:
createPartName();
break;
case StructureModified:
if (isVisibleInEditor) {
getEditorHelper().setDirty(true);
}
if (!handleStructureModified(po)) {
return;
}
break;
default :
}
if (isVisibleInEditor) {
runLocalChecks();
}
getEditorHelper().handleDataChanged(po,dataState);
}
 else if (po instanceof IComponentNamePO && updState != UpdateState.onlyInEditor) {
handleCompNameChanged((IComponentNamePO)po,dataState);
}
}","/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState,UpdateState updState){
  if (po instanceof INodePO) {
    INodePO changedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
    boolean isVisibleInEditor=editorNode.indexOf(changedNode) > -1;
    isVisibleInEditor|=contains(editorNode,changedNode);
    if (editorNode instanceof ISpecTestCasePO) {
      isVisibleInEditor|=((ISpecTestCasePO)editorNode).getAllEventEventExecTC().contains(po);
    }
switch (dataState) {
case Added:
      if (isVisibleInEditor) {
        handleNodeAdded(changedNode);
      }
    break;
case Deleted:
  if (!(po instanceof IProjectPO)) {
    isVisibleInEditor=true;
    refresh();
  }
break;
case Renamed:
createPartName();
break;
case StructureModified:
if (isVisibleInEditor) {
getEditorHelper().setDirty(true);
}
if (!handleStructureModified(po)) {
return;
}
break;
default :
}
if (isVisibleInEditor) {
runLocalChecks();
}
getEditorHelper().handleDataChanged(po,dataState);
}
 else if (po instanceof IComponentNamePO && updState != UpdateState.onlyInEditor) {
handleCompNameChanged((IComponentNamePO)po,dataState);
}
 else if (po instanceof IObjectMappingPO && updState != UpdateState.onlyInEditor) {
IPersistentObject workversion=getEditorHelper().getEditSupport().getWorkVersion();
if (workversion instanceof ITestSuitePO) {
EntityManager session=getEditorHelper().getEditSupport().getSession();
session.refresh(session.find(po.getClass(),po.getId()));
}
runLocalChecks();
}
}",0.869753979739508
95362,"/** 
 * run local completeness checks such as test data completeness
 */
public void runLocalChecks(){
  INodePO node=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
  CompletenessGuard.checkAll(node,new NullProgressMonitor());
}","/** 
 * run local completeness checks such as test data completeness
 */
public void runLocalChecks(){
  INodePO node=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
  node.clearProblems();
  for (Iterator<INodePO> childIterator=node.getAllNodeIter(); childIterator.hasNext(); ) {
    INodePO next=childIterator.next();
    next.clearProblems();
  }
  CompletenessGuard.checkAll(node,new NullProgressMonitor());
  m_decoraterUpdateJob.setPriority(Job.DECORATE);
  m_decoraterUpdateJob.schedule(300);
}",0.6411609498680739
95363,"/** 
 * assumes the typed data
 */
private void writeData(){
  if (m_currentPart instanceof AbstractJBEditor) {
    m_tcEditor=(AbstractJBEditor)m_currentPart;
  }
  if (m_tcEditor == null) {
    return;
  }
  int column=getColumn();
  final Control editor=m_editor.getEditor();
  if (!TextControlBP.isTextValid(editor)) {
    TextControlBP.setText(m_oldValue,editor);
  }
  final String property=getTableViewer().getColumnProperties()[column].toString();
  String value=TextControlBP.getText(editor);
  if (m_oldValue != null && m_oldValue.equals(value)) {
    return;
  }
  if (value != null && value.equals(StringConstants.EMPTY)) {
    value=null;
  }
  if (LOG.isDebugEnabled()) {
    logDataChange(property,value,m_oldValue,getParamInterfaceObj().getSpecificationUser());
  }
  if (value.length() > IPersistentObject.MAX_STR_LGT_CHAR) {
    value=value.substring(0,IPersistentObject.MAX_STR_LGT_CHAR);
    if (value.getBytes(StandardCharsets.UTF_8).length > IPersistentObject.MAX_STRING_LENGTH) {
      value=m_oldValue;
    }
    TextControlBP.setText(value,editor);
    ErrorHandlingUtil.createMessageDialog(MessageIDs.W_MAX_CHAR,new Object[]{IPersistentObject.MAX_STR_LGT_CHAR},null);
    return;
  }
  writeDataSetData(property,value,m_tcEditor);
}","/** 
 * assumes the typed data
 */
private void writeData(){
  if (m_currentPart instanceof AbstractJBEditor) {
    m_tcEditor=(AbstractJBEditor)m_currentPart;
  }
  if (m_tcEditor == null) {
    return;
  }
  int column=getColumn();
  final Control editor=m_editor.getEditor();
  if (!TextControlBP.isTextValid(editor)) {
    TextControlBP.setText(m_oldValue,editor);
  }
  final String property=getTableViewer().getColumnProperties()[column].toString();
  String value=TextControlBP.getText(editor);
  if (m_oldValue != null && m_oldValue.equals(value)) {
    return;
  }
  if (value != null && value.equals(StringConstants.EMPTY)) {
    value=null;
  }
  if (LOG.isDebugEnabled()) {
    logDataChange(property,value,m_oldValue,getParamInterfaceObj().getSpecificationUser());
  }
  if (value != null && value.length() > IPersistentObject.MAX_STR_LGT_CHAR) {
    value=value.substring(0,IPersistentObject.MAX_STR_LGT_CHAR);
    if (value.getBytes(StandardCharsets.UTF_8).length > IPersistentObject.MAX_STRING_LENGTH) {
      value=m_oldValue;
    }
    TextControlBP.setText(value,editor);
    ErrorHandlingUtil.createMessageDialog(MessageIDs.W_MAX_CHAR,new Object[]{IPersistentObject.MAX_STR_LGT_CHAR},null);
    return;
  }
  writeDataSetData(property,value,m_tcEditor);
}",0.9932885906040269
95364,"/** 
 * {@inheritDoc} 
 */
public Object getParent(Object element){
  if (element instanceof INodePO) {
    INodePO node=((INodePO)element);
    INodePO parent=node.getParentNode();
    Long nodeProjId=node.getParentProjectId();
    if (node.isExecObjCont() || node.isSpecObjCont()) {
      return GeneralStorage.getInstance().getProject();
    }
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    if (activeProject != null && nodeProjId != null) {
      if (!nodeProjId.equals(activeProject.getId()) && parent.isSpecObjCont()) {
        try {
          String nodeProjGUID=ProjectPM.getGuidOfProjectId(nodeProjId);
          for (          IReusedProjectPO reusedProject : activeProject.getUsedProjects()) {
            if (nodeProjGUID.equals(reusedProject.getProjectGuid())) {
              return reusedProject;
            }
          }
        }
 catch (        JBException e) {
          LOG.warn(""String_Node_Str"",e);
        }
      }
    }
    return parent;
  }
  if (element instanceof IReusedProjectPO) {
    return GeneralStorage.getInstance().getProject();
  }
  if (element instanceof ITestDataCategoryPO) {
    return ((ITestDataCategoryPO)element).getParent();
  }
  if (element instanceof ITestDataCubePO) {
    return ((ITestDataCubePO)element).getParent();
  }
  if (element instanceof SearchResultElement) {
    return null;
  }
  Assert.notReached(Messages.WrongTypeOfElement + StringConstants.EXCLAMATION_MARK);
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object getParent(Object element){
  if (element instanceof INodePO) {
    INodePO node=((INodePO)element);
    INodePO parent=node.getParentNode();
    Long nodeProjId=node.getParentProjectId();
    if (node.isExecObjCont() || node.isSpecObjCont()) {
      return GeneralStorage.getInstance().getProject();
    }
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    if (activeProject != null && nodeProjId != null && parent != null) {
      if (!nodeProjId.equals(activeProject.getId()) && parent.isSpecObjCont()) {
        try {
          String nodeProjGUID=ProjectPM.getGuidOfProjectId(nodeProjId);
          for (          IReusedProjectPO reusedProject : activeProject.getUsedProjects()) {
            if (nodeProjGUID.equals(reusedProject.getProjectGuid())) {
              return reusedProject;
            }
          }
        }
 catch (        JBException e) {
          LOG.warn(""String_Node_Str"",e);
        }
      }
    }
    return parent;
  }
  if (element instanceof IReusedProjectPO) {
    return GeneralStorage.getInstance().getProject();
  }
  if (element instanceof ITestDataCategoryPO) {
    return ((ITestDataCategoryPO)element).getParent();
  }
  if (element instanceof ITestDataCubePO) {
    return ((ITestDataCubePO)element).getParent();
  }
  if (element instanceof SearchResultElement) {
    return null;
  }
  Assert.notReached(Messages.WrongTypeOfElement + StringConstants.EXCLAMATION_MARK);
  return null;
}",0.993943472409152
95365,"@Override public Integer call() throws Exception {
  return getRealComponent().getItems().size();
}","@Override public IMenuItemComponent[] call() throws Exception {
  List<MenuItem> items=getRealComponent().getItems();
  if (items.size() > 0) {
    List<IMenuItemComponent> adapters=new ArrayList<>();
    for (int i=0; i < items.size(); i++) {
      MenuItem item=items.get(i);
      if (item.isVisible()) {
        adapters.add(new MenuItemAdapter<MenuItem>(item));
      }
    }
    return adapters.toArray(new IMenuItemComponent[adapters.size()]);
  }
  return null;
}",0.2947368421052631
95366,"@Override public IMenuItemComponent[] getItems(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<IMenuItemComponent[]>(){
    @Override public IMenuItemComponent[] call() throws Exception {
      List<MenuItem> items=getRealComponent().getItems();
      if (items.size() > 0) {
        IMenuItemComponent[] itemAdapters=new IMenuItemComponent[items.size()];
        for (int i=0; i < items.size(); i++) {
          itemAdapters[i]=new MenuItemAdapter<MenuItem>(items.get(i));
        }
        return itemAdapters;
      }
      return null;
    }
  }
);
}","@Override public IMenuItemComponent[] getItems(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<IMenuItemComponent[]>(){
    @Override public IMenuItemComponent[] call() throws Exception {
      List<MenuItem> items=getRealComponent().getItems();
      if (items.size() > 0) {
        List<IMenuItemComponent> adapters=new ArrayList<>();
        for (int i=0; i < items.size(); i++) {
          MenuItem item=items.get(i);
          if (item.isVisible()) {
            adapters.add(new MenuItemAdapter<MenuItem>(item));
          }
        }
        return adapters.toArray(new IMenuItemComponent[adapters.size()]);
      }
      return null;
    }
  }
);
}",0.6791277258566978
95367,"@Override public int getItemCount(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    @Override public Integer call() throws Exception {
      return getRealComponent().getItems().size();
    }
  }
);
}","@Override public int getItemCount(){
  return getItems().length;
}",0.3848580441640378
95368,"@Override public Integer call() throws Exception {
  return getRealComponent().getMenus().size();
}","@Override public IMenuItemComponent[] call() throws Exception {
  List<Menu> menus=getRealComponent().getMenus();
  if (menus.size() > 0) {
    List<IMenuItemComponent> adapters=new ArrayList<>();
    for (int i=0; i < menus.size(); i++) {
      Menu item=menus.get(i);
      if (item.isVisible()) {
        adapters.add(new MenuBarItemAdapter(item));
      }
    }
    return adapters.toArray(new IMenuItemComponent[adapters.size()]);
  }
  return null;
}",0.3027027027027027
95369,"/** 
 * Returns the adapted Menus of this MenuBar
 * @return the Menus
 */
@Override public IMenuItemComponent[] getItems(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<IMenuItemComponent[]>(){
    @Override public IMenuItemComponent[] call() throws Exception {
      List<Menu> menus=getRealComponent().getMenus();
      if (menus.size() > 0) {
        IMenuItemComponent[] itemAdapters=new IMenuItemComponent[menus.size()];
        for (int i=0; i < menus.size(); i++) {
          itemAdapters[i]=new MenuBarItemAdapter(menus.get(i));
        }
        return itemAdapters;
      }
      return null;
    }
  }
);
}","/** 
 * Returns the adapted Menus of this MenuBar
 * @return the Menus
 */
@Override public IMenuItemComponent[] getItems(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<IMenuItemComponent[]>(){
    @Override public IMenuItemComponent[] call() throws Exception {
      List<Menu> menus=getRealComponent().getMenus();
      if (menus.size() > 0) {
        List<IMenuItemComponent> adapters=new ArrayList<>();
        for (int i=0; i < menus.size(); i++) {
          Menu item=menus.get(i);
          if (item.isVisible()) {
            adapters.add(new MenuBarItemAdapter(item));
          }
        }
        return adapters.toArray(new IMenuItemComponent[adapters.size()]);
      }
      return null;
    }
  }
);
}",0.7201704545454546
95370,"@Override public int getItemCount(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    @Override public Integer call() throws Exception {
      return getRealComponent().getMenus().size();
    }
  }
);
}","@Override public int getItemCount(){
  return getItems().length;
}",0.3722397476340694
95371,"@Override public Node call() throws Exception {
  List<? extends MenuBar> bars=ComponentHandler.getAssignableFrom(MenuBar.class);
  MenuBar menuBar=bars.get(0);
  SkinBase<?> menuBarSkin=(SkinBase<?>)menuBar.getSkin();
  Parent buttonBox=(Parent)menuBarSkin.getChildren().get(0);
  return buttonBox.getChildrenUnmodifiable().get(menuBar.getMenus().indexOf(getRealComponent()));
}","@Override public Node call() throws Exception {
  List<? extends MenuBar> bars=ComponentHandler.getAssignableFrom(MenuBar.class);
  MenuBar menuBar=bars.get(0);
  SkinBase<?> menuBarSkin=(SkinBase<?>)menuBar.getSkin();
  Parent buttonBox=(Parent)menuBarSkin.getChildren().get(0);
  IMenuItemComponent[] items=new MenuBarAdapter(menuBar).getItems();
  int index=-1;
  for (int i=0; i < items.length; i++) {
    if (getRealComponent().equals(items[i].getRealComponent())) {
      index=i;
      break;
    }
  }
  return buttonBox.getChildrenUnmodifiable().get(index);
}",0.7032734952481521
95372,"@Override protected void clickMenuItem(){
  Node menuButton=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Node>(){
    @Override public Node call() throws Exception {
      List<? extends MenuBar> bars=ComponentHandler.getAssignableFrom(MenuBar.class);
      MenuBar menuBar=bars.get(0);
      SkinBase<?> menuBarSkin=(SkinBase<?>)menuBar.getSkin();
      Parent buttonBox=(Parent)menuBarSkin.getChildren().get(0);
      return buttonBox.getChildrenUnmodifiable().get(menuBar.getMenus().indexOf(getRealComponent()));
    }
  }
);
  getRobot().click(menuButton,null);
}","@Override protected void clickMenuItem(){
  Node menuButton=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Node>(){
    @Override public Node call() throws Exception {
      List<? extends MenuBar> bars=ComponentHandler.getAssignableFrom(MenuBar.class);
      MenuBar menuBar=bars.get(0);
      SkinBase<?> menuBarSkin=(SkinBase<?>)menuBar.getSkin();
      Parent buttonBox=(Parent)menuBarSkin.getChildren().get(0);
      IMenuItemComponent[] items=new MenuBarAdapter(menuBar).getItems();
      int index=-1;
      for (int i=0; i < items.length; i++) {
        if (getRealComponent().equals(items[i].getRealComponent())) {
          index=i;
          break;
        }
      }
      return buttonBox.getChildrenUnmodifiable().get(index);
    }
  }
);
  getRobot().click(menuButton,null);
}",0.7852586817859674
95373,"/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState,UpdateState updState){
  if (po instanceof INodePO) {
    INodePO changedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
    boolean isVisibleInEditor=editorNode.indexOf(changedNode) > -1;
    isVisibleInEditor|=contains(editorNode,changedNode);
    if (editorNode instanceof ISpecTestCasePO) {
      isVisibleInEditor|=((ISpecTestCasePO)editorNode).getAllEventEventExecTC().contains(po);
    }
switch (dataState) {
case Added:
      if (isVisibleInEditor) {
        handleNodeAdded(changedNode);
      }
    break;
case Deleted:
  if (!(po instanceof IProjectPO)) {
    isVisibleInEditor=true;
    refresh();
  }
break;
case Renamed:
createPartName();
break;
case StructureModified:
if (isVisibleInEditor) {
getEditorHelper().setDirty(true);
}
if (!handleStructureModified(po)) {
return;
}
break;
default :
}
if (isVisibleInEditor) {
runLocalChecks();
}
getEditorHelper().handleDataChanged(po,dataState);
}
 else if (po instanceof IComponentNamePO && updState != UpdateState.onlyInEditor) {
handleCompNameChanged((IComponentNamePO)po,dataState);
}
}","/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState,UpdateState updState){
  if (po instanceof INodePO) {
    INodePO changedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
    boolean isVisibleInEditor=editorNode.indexOf(changedNode) > -1;
    isVisibleInEditor|=contains(editorNode,changedNode);
    if (editorNode instanceof ISpecTestCasePO) {
      isVisibleInEditor|=((ISpecTestCasePO)editorNode).getAllEventEventExecTC().contains(po);
    }
switch (dataState) {
case Added:
      if (isVisibleInEditor) {
        handleNodeAdded(changedNode);
      }
    break;
case Deleted:
  if (!(po instanceof IProjectPO)) {
    isVisibleInEditor=true;
    refresh();
  }
break;
case Renamed:
createPartName();
break;
case StructureModified:
if (isVisibleInEditor) {
getEditorHelper().setDirty(true);
}
if (!handleStructureModified(po)) {
return;
}
break;
default :
}
if (isVisibleInEditor) {
runLocalChecks();
}
getEditorHelper().handleDataChanged(po,dataState);
}
 else if (po instanceof IComponentNamePO && updState != UpdateState.onlyInEditor) {
handleCompNameChanged((IComponentNamePO)po,dataState);
}
 else if (po instanceof IObjectMappingPO && updState != UpdateState.onlyInEditor) {
IPersistentObject workversion=getEditorHelper().getEditSupport().getWorkVersion();
if (workversion instanceof ITestSuitePO) {
EntityManager session=getEditorHelper().getEditSupport().getSession();
session.refresh(session.find(po.getClass(),po.getId()));
}
runLocalChecks();
}
}",0.869753979739508
95374,"/** 
 * run local completeness checks such as test data completeness
 */
public void runLocalChecks(){
  INodePO node=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
  CompletenessGuard.checkAll(node,new NullProgressMonitor());
}","/** 
 * run local completeness checks such as test data completeness
 */
public void runLocalChecks(){
  INodePO node=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
  node.clearProblems();
  for (Iterator<INodePO> childIterator=node.getAllNodeIter(); childIterator.hasNext(); ) {
    INodePO next=childIterator.next();
    next.clearProblems();
  }
  CompletenessGuard.checkAll(node,new NullProgressMonitor());
  m_decoraterUpdateJob.setPriority(Job.DECORATE);
  m_decoraterUpdateJob.schedule(300);
}",0.6411609498680739
95375,"/** 
 * assumes the typed data
 */
private void writeData(){
  if (m_currentPart instanceof AbstractJBEditor) {
    m_tcEditor=(AbstractJBEditor)m_currentPart;
  }
  if (m_tcEditor == null) {
    return;
  }
  int column=getColumn();
  final Control editor=m_editor.getEditor();
  if (!TextControlBP.isTextValid(editor)) {
    TextControlBP.setText(m_oldValue,editor);
  }
  final String property=getTableViewer().getColumnProperties()[column].toString();
  String value=TextControlBP.getText(editor);
  if (m_oldValue != null && m_oldValue.equals(value)) {
    return;
  }
  if (value != null && value.equals(StringConstants.EMPTY)) {
    value=null;
  }
  if (LOG.isDebugEnabled()) {
    logDataChange(property,value,m_oldValue,getParamInterfaceObj().getSpecificationUser());
  }
  if (value.length() > IPersistentObject.MAX_STR_LGT_CHAR) {
    value=value.substring(0,IPersistentObject.MAX_STR_LGT_CHAR);
    if (value.getBytes(StandardCharsets.UTF_8).length > IPersistentObject.MAX_STRING_LENGTH) {
      value=m_oldValue;
    }
    TextControlBP.setText(value,editor);
    ErrorHandlingUtil.createMessageDialog(MessageIDs.W_MAX_CHAR,new Object[]{IPersistentObject.MAX_STR_LGT_CHAR},null);
    return;
  }
  writeDataSetData(property,value,m_tcEditor);
}","/** 
 * assumes the typed data
 */
private void writeData(){
  if (m_currentPart instanceof AbstractJBEditor) {
    m_tcEditor=(AbstractJBEditor)m_currentPart;
  }
  if (m_tcEditor == null) {
    return;
  }
  int column=getColumn();
  final Control editor=m_editor.getEditor();
  if (!TextControlBP.isTextValid(editor)) {
    TextControlBP.setText(m_oldValue,editor);
  }
  final String property=getTableViewer().getColumnProperties()[column].toString();
  String value=TextControlBP.getText(editor);
  if (m_oldValue != null && m_oldValue.equals(value)) {
    return;
  }
  if (value != null && value.equals(StringConstants.EMPTY)) {
    value=null;
  }
  if (LOG.isDebugEnabled()) {
    logDataChange(property,value,m_oldValue,getParamInterfaceObj().getSpecificationUser());
  }
  if (value != null && value.length() > IPersistentObject.MAX_STR_LGT_CHAR) {
    value=value.substring(0,IPersistentObject.MAX_STR_LGT_CHAR);
    if (value.getBytes(StandardCharsets.UTF_8).length > IPersistentObject.MAX_STRING_LENGTH) {
      value=m_oldValue;
    }
    TextControlBP.setText(value,editor);
    ErrorHandlingUtil.createMessageDialog(MessageIDs.W_MAX_CHAR,new Object[]{IPersistentObject.MAX_STR_LGT_CHAR},null);
    return;
  }
  writeDataSetData(property,value,m_tcEditor);
}",0.9932885906040269
95376,"/** 
 * @param projectList The list of projects to export
 * @param exportDirName The export directory of the projects
 * @param exportSession The session to be used for Persistence (JPA / EclipseLink)
 * @param monitor The progress monitor
 * @param writeToSystemTempDir Indicates whether the projects have to be written to the system temp directory
 * @param listOfProjectFiles The written project files are added to this list, if the temp dir was used and the list   is not null.
 * @param console The console to use to display progress and  error messages.
 */
public static void exportProjectList(List<IProjectPO> projectList,String exportDirName,EntityManager exportSession,IProgressMonitor monitor,boolean writeToSystemTempDir,List<File> listOfProjectFiles,IProgressConsole console) throws JBException, InterruptedException {
  SubMonitor subMonitor=SubMonitor.convert(monitor,Messages.ExportAllBPExporting,JsonStorage.getWorkToSave(projectList));
  for (  IProjectPO proj : projectList) {
    if (subMonitor.isCanceled()) {
      throw new InterruptedException();
    }
    IProjectPO projectToExport=ProjectPM.loadProjectByIdAndPreLoad(proj.getId(),exportSession);
    String projectFileName=projectToExport.getDisplayName() + JUB;
    final String exportFileName;
    if (writeToSystemTempDir) {
      exportFileName=projectFileName;
    }
 else {
      if (projectToExport.equals(GeneralStorage.getInstance().getProject())) {
        projectToExport=GeneralStorage.getInstance().getProject();
      }
      exportFileName=exportDirName + projectFileName;
    }
    if (subMonitor.isCanceled()) {
      throw new InterruptedException();
    }
    console.writeStatus(new Status(IStatus.INFO,Activator.PLUGIN_ID,NLS.bind(Messages.ExportAllBPInfoStartingExportProject,projectFileName)));
    try {
      if (subMonitor.isCanceled()) {
        throw new InterruptedException();
      }
      JsonStorage.save(projectToExport,exportFileName,true,subMonitor.newChild(1),console);
      if (subMonitor.isCanceled()) {
        throw new InterruptedException();
      }
      console.writeStatus(new Status(IStatus.INFO,Activator.PLUGIN_ID,NLS.bind(Messages.ExportAllBPInfoFinishedExportProject,projectFileName)));
    }
 catch (    final PMSaveException e) {
      LOG.error(Messages.CouldNotExportProject,e);
      console.writeStatus(new Status(IStatus.INFO,Activator.PLUGIN_ID,NLS.bind(Messages.ExportAllBPErrorExportFailedProject,new Object[]{projectFileName,e.getMessage()})));
    }
    exportSession.detach(projectToExport);
  }
}","/** 
 * @param projectList The list of projects to export
 * @param exportDirName The export directory of the projects
 * @param exportSession The session to be used for Persistence (JPA / EclipseLink)
 * @param monitor The progress monitor
 * @param writeToSystemTempDir Indicates whether the projects have to be written to the system temp directory
 * @param listOfProjectFiles The written project files are added to this list, if the temp dir was used and the list   is not null.
 * @param console The console to use to display progress and  error messages.
 */
public static void exportProjectList(List<IProjectPO> projectList,String exportDirName,EntityManager exportSession,IProgressMonitor monitor,boolean writeToSystemTempDir,List<File> listOfProjectFiles,IProgressConsole console) throws JBException, InterruptedException {
  SubMonitor subMonitor=SubMonitor.convert(monitor,Messages.ExportAllBPExporting,JsonStorage.getWorkToSave(projectList));
  for (  IProjectPO proj : projectList) {
    if (subMonitor.isCanceled()) {
      throw new InterruptedException();
    }
    IProjectPO projectToExport=ProjectPM.loadProjectByIdAndPreLoad(proj.getId(),exportSession);
    String projectFileName=projectToExport.getDisplayName() + JUB;
    final String exportFileName;
    if (writeToSystemTempDir) {
      exportFileName=projectFileName;
    }
 else {
      if (projectToExport.equals(GeneralStorage.getInstance().getProject())) {
        projectToExport=GeneralStorage.getInstance().getProject();
      }
      exportFileName=exportDirName + projectFileName;
    }
    if (subMonitor.isCanceled()) {
      throw new InterruptedException();
    }
    console.writeStatus(new Status(IStatus.INFO,Activator.PLUGIN_ID,NLS.bind(Messages.ExportAllBPInfoStartingExportProject,projectFileName)));
    try {
      if (subMonitor.isCanceled()) {
        throw new InterruptedException();
      }
      JsonStorage.save(projectToExport,exportFileName,true,subMonitor.newChild(1),console);
      if (subMonitor.isCanceled()) {
        throw new InterruptedException();
      }
      console.writeStatus(new Status(IStatus.INFO,Activator.PLUGIN_ID,NLS.bind(Messages.ExportAllBPInfoFinishedExportProject,projectFileName)));
    }
 catch (    final PMSaveException e) {
      LOG.error(Messages.CouldNotExportProject,e);
      console.writeStatus(new Status(IStatus.INFO,Activator.PLUGIN_ID,NLS.bind(Messages.ExportAllBPErrorExportFailedProject,new Object[]{projectFileName,e.getMessage()})));
    }
    exportSession.detach(projectToExport);
    exportSession.clear();
  }
}",0.9947131388290582
95377,"/** 
 * @param node the node to check
 */
public static void checkLocalTestData(INodePO node){
  INodePO possibleDataSourceNode=node;
  if (node instanceof IExecTestCasePO) {
    IExecTestCasePO execTc=(IExecTestCasePO)node;
    if (execTc.getHasReferencedTD()) {
      possibleDataSourceNode=execTc.getSpecTestCase();
    }
  }
  if (possibleDataSourceNode instanceof IParamNodePO) {
    IParamNodePO dataSourceNode=(IParamNodePO)possibleDataSourceNode;
    INodePO nodeToModify=null;
    if (!(node instanceof ISpecTestCasePO)) {
      nodeToModify=node;
    }
    if (nodeToModify != null) {
      setCompletenessTestData(nodeToModify,dataSourceNode.isTestDataComplete());
    }
  }
}","/** 
 * @param node the node to check
 */
public static void checkLocalTestData(INodePO node){
  INodePO possibleDataSourceNode=node;
  if (node instanceof IExecTestCasePO) {
    IExecTestCasePO execTc=(IExecTestCasePO)node;
    if (StringUtils.isNotBlank(execTc.getDataFile())) {
      return;
    }
    if (execTc.getHasReferencedTD()) {
      possibleDataSourceNode=execTc.getSpecTestCase();
    }
  }
  if (possibleDataSourceNode instanceof IParamNodePO) {
    IParamNodePO dataSourceNode=(IParamNodePO)possibleDataSourceNode;
    INodePO nodeToModify=null;
    if (!(node instanceof ISpecTestCasePO)) {
      nodeToModify=node;
    }
    if (nodeToModify != null) {
      setCompletenessTestData(nodeToModify,dataSourceNode.isTestDataComplete());
    }
  }
}",0.8937931034482759
95378,"/** 
 * Removes a problem from the problems view.
 * @param problem the problem with the marker that should be deleted
 */
public void remove(Problem problem){
  try {
    IMarker marker=m_res.findMarker(m_problems.get(problem).getId());
    marker.delete();
    m_problems.remove(problem);
    m_markers.remove(marker);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}","/** 
 * Removes a problem from the problems view.
 * @param problem the problem with the marker that should be deleted
 */
public void remove(Problem problem){
  try {
    IMarker problemMarker=m_problems.get(problem);
    if (problemMarker != null) {
      IMarker marker=m_res.findMarker(problemMarker.getId());
      marker.delete();
      m_markers.remove(marker);
    }
    m_problems.remove(problem);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}",0.6697892271662763
95379,"/** 
 * {@inheritDoc}This should always be called by the assisted editor during its  <code>handleDataChanged</code> method.
 */
public void handleDataChanged(final IPersistentObject po,final DataState dataState){
  IPersistentObject workVersion=getEditSupport().getWorkVersion();
switch (dataState) {
case Added:
    break;
case Deleted:
  if (po.equals(workVersion)) {
    m_editor.getSite().getPage().closeEditor(m_editor,false);
  }
break;
case Renamed:
if (!isDirty() && editorContainsPo(po)) {
handleProjectLoaded();
}
break;
case StructureModified:
if (po.equals(workVersion) && !po.getVersion().equals(workVersion.getVersion())) {
try {
m_editor.reOpenEditor(po);
}
 catch (PMException e) {
ErrorHandlingUtil.createMessageDialog(MessageIDs.E_REFRESH_FAILED,null,new String[]{Messages.ErrorMessageEDITOR_CLOSE});
m_editor.getSite().getPage().closeEditor(m_editor,false);
}
}
break;
default :
}
}","/** 
 * {@inheritDoc}This should always be called by the assisted editor during its  <code>handleDataChanged</code> method.
 */
public void handleDataChanged(final IPersistentObject po,final DataState dataState){
  EditSupport editSupport=getEditSupport();
  if (editSupport == null) {
    return;
  }
  IPersistentObject workVersion=editSupport.getWorkVersion();
switch (dataState) {
case Added:
    break;
case Deleted:
  if (po.equals(workVersion)) {
    m_editor.getSite().getPage().closeEditor(m_editor,false);
  }
break;
case Renamed:
if (!isDirty() && editorContainsPo(po)) {
handleProjectLoaded();
}
break;
case StructureModified:
if (po.equals(workVersion) && !po.getVersion().equals(workVersion.getVersion())) {
try {
m_editor.reOpenEditor(po);
}
 catch (PMException e) {
ErrorHandlingUtil.createMessageDialog(MessageIDs.E_REFRESH_FAILED,null,new String[]{Messages.ErrorMessageEDITOR_CLOSE});
m_editor.getSite().getPage().closeEditor(m_editor,false);
}
}
break;
default :
}
}",0.9384941675503712
95380,"/** 
 * {@inheritDoc} 
 */
public void clickOnIndex(final Integer index,ClickOptions co){
  final int actualItemCount=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    public Integer call() throws Exception {
      final ObservableList<?> items=getRealComponent().getItems();
      int itemCount=items != null ? items.size() : -1;
      return new Integer(itemCount);
    }
  }
).intValue();
  if (index >= actualItemCount || (index < 0)) {
    throw new StepExecutionException(""String_Node_Str"" + index + ""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.INVALID_INDEX));
  }
  Rectangle r=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    public Rectangle call() throws Exception {
      final T listView=getRealComponent();
      listView.scrollTo(index.intValue());
      listView.layout();
      List<ListCell> lCells=NodeTraverseHelper.getInstancesOf(listView,ListCell.class);
      for (      ListCell<?> cell : lCells) {
        if (cell.getIndex() == index.intValue() && cell.getListView() == listView) {
          Rectangle b=NodeBounds.getAbsoluteBounds(cell);
          Rectangle tableB=NodeBounds.getAbsoluteBounds(listView);
          double widthOfClickableRectangle=b.getWidth();
          double prefWidth=cell.prefWidth(cell.getHeight());
          if (widthOfClickableRectangle > listView.getWidth()) {
            widthOfClickableRectangle=listView.getWidth();
          }
          if (StringUtils.isBlank(cell.getText())) {
            widthOfClickableRectangle=b.getWidth();
          }
          return new Rectangle(Math.abs(tableB.x - b.x),Math.abs(tableB.y - b.y),Rounding.round(widthOfClickableRectangle),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  getRobot().click(getRealComponent(),r,co.setClickType(ClickOptions.ClickType.RELEASED));
}","/** 
 * {@inheritDoc} 
 */
public void clickOnIndex(final Integer index,ClickOptions co){
  final int actualItemCount=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    public Integer call() throws Exception {
      final ObservableList<?> items=getRealComponent().getItems();
      int itemCount=items != null ? items.size() : -1;
      return new Integer(itemCount);
    }
  }
).intValue();
  if (index >= actualItemCount || (index < 0)) {
    throw new StepExecutionException(""String_Node_Str"" + index + ""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.INVALID_INDEX));
  }
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    public Rectangle call() throws Exception {
      final T listView=getRealComponent();
      listView.layout();
      listView.scrollTo(index.intValue());
      return null;
    }
  }
);
  TimeUtil.delay(100);
  Rectangle r=scrollToAndGetRectangle(index);
  getRobot().click(getRealComponent(),r,co.setClickType(ClickOptions.ClickType.RELEASED));
}",0.6475934028946483
95381,"/** 
 * @param dto the DTO to 
 * @param assignNewUuid if there should be a new Uuid
 * @return a {@link ICommentPO}
 */
private ICommentPO createComment(CommentDTO dto,boolean assignNewUuid){
  if (dto.getUuid() != null && !assignNewUuid) {
    return NodeMaker.createCommentPO(dto.getName(),dto.getUuid());
  }
  return NodeMaker.createCommentPO(dto.getName());
}","/** 
 * @param dto the DTO to 
 * @param assignNewUuid if there should be a new Uuid
 * @return a {@link ICommentPO}
 */
private ICommentPO createComment(CommentDTO dto,boolean assignNewUuid){
  ICommentPO comment;
  if (dto.getUuid() != null && !assignNewUuid) {
    comment=NodeMaker.createCommentPO(dto.getName(),dto.getUuid());
  }
 else {
    comment=NodeMaker.createCommentPO(dto.getName());
  }
  comment.setActive(dto.isActive());
  return comment;
}",0.850546780072904
95382,"/** 
 * Remove a change Listener
 */
public void removeChangeListener(){
  Object children=ChildrenGetter.getAsRealType(getComponent());
  EventTarget component=getComponent();
  if (component instanceof Node) {
    ((Node)component).visibleProperty().removeListener(VisibleChangeHandler.INSTACE);
  }
  if (children instanceof ObjectProperty) {
    ChildrenListenerHelper.removeListener((ObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.removeListener((ObservableList<? extends EventTarget>)children);
  }
}","/** 
 * Remove a change Listener
 */
@SuppressWarnings(""String_Node_Str"") public void removeChangeListener(){
  Object children=ChildrenGetter.getAsRealType(getComponent());
  EventTarget component=getComponent();
  if (component instanceof Node) {
    Node node=(Node)component;
    node.visibleProperty().removeListener(VisibleChangeHandler.INSTACE);
    node.idProperty().removeListener(m_iDChangeListener);
  }
  if (children instanceof ObjectProperty) {
    ChildrenListenerHelper.removeListener((ObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.removeListener((ObservableList<? extends EventTarget>)children);
  }
}",0.8923315259488769
95383,"/** 
 * Add a change Listener
 * @param component the component
 */
public void addChangeListener(EventTarget component){
  if (component instanceof Node) {
    ((Node)component).visibleProperty().addListener(new WeakChangeListener<Boolean>(VisibleChangeHandler.INSTACE));
  }
  Object children=ChildrenGetter.getAsRealType(component);
  if (children instanceof ReadOnlyObjectProperty) {
    ChildrenListenerHelper.addListener((ReadOnlyObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.addListener((ObservableList<? extends EventTarget>)children);
  }
}","/** 
 * Add a change Listener
 * @param component the component
 */
@SuppressWarnings(""String_Node_Str"") public void addChangeListener(EventTarget component){
  if (component instanceof Node) {
    ((Node)component).visibleProperty().addListener(VisibleChangeHandler.INSTACE);
    ((Node)component).idProperty().addListener(m_iDChangeListener);
  }
  Object children=ChildrenGetter.getAsRealType(component);
  if (children instanceof ReadOnlyObjectProperty) {
    ChildrenListenerHelper.addListener((ReadOnlyObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.addListener((ObservableList<? extends EventTarget>)children);
  }
}",0.898355754857997
95384,"/** 
 * {@inheritDoc}
 */
protected Cell getCellAtMousePosition() throws StepExecutionException {
  final Point awtMousePos=getRobot().getCurrentMousePosition();
  Cell returnvalue=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Cell>(){
    public Cell run() throws StepExecutionException {
      ITableComponent adapter=(ITableComponent)getComponent();
      Control comp=(Control)adapter.getRealComponent();
      Cell cell=null;
      final int itemCount=adapter.getRowCount();
      for (int rowCount=adapter.getTopIndex(); rowCount < itemCount; rowCount++) {
        if (cell != null) {
          break;
        }
        final int columnCount=adapter.getColumnCount() == 0 ? 1 : adapter.getColumnCount();
        for (int col=0; col < columnCount; col++) {
          checkRowColBounds(rowCount,col);
          final Rectangle itemBounds=adapter.getCellBounds(rowCount,col,false);
          final org.eclipse.swt.graphics.Point absItemBounds=comp.toDisplay(itemBounds.x,itemBounds.y);
          final Rectangle absRect=new Rectangle(absItemBounds.x,absItemBounds.y,itemBounds.width,itemBounds.height);
          if (absRect.contains(awtMousePos)) {
            if (comp instanceof Table) {
              cell=new SWTCell(rowCount,col,((Table)comp).getItem(rowCount));
            }
 else             if (comp instanceof Tree) {
              cell=new SWTCell(rowCount,col,((TreeAdapter)getComponent()).getRow(rowCount));
            }
            break;
          }
        }
      }
      if (cell == null) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
      }
      return cell;
    }
  }
);
  return returnvalue;
}","/** 
 * {@inheritDoc}
 */
protected Cell getCellAtMousePosition() throws StepExecutionException {
  final Point awtMousePos=getRobot().getCurrentMousePosition();
  Cell returnvalue=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Cell>(){
    public Cell run() throws StepExecutionException {
      ITableComponent adapter=(ITableComponent)getComponent();
      Control comp=(Control)adapter.getRealComponent();
      Cell cell=null;
      final int itemCount=adapter.getRowCount();
      for (int rowCount=adapter.getTopIndex(); rowCount < itemCount; rowCount++) {
        if (cell != null) {
          break;
        }
        final int columnCount=adapter.getColumnCount() == 0 ? 1 : adapter.getColumnCount();
        for (int col=0; col < columnCount; col++) {
          checkRowColBounds(rowCount,col);
          final Rectangle itemBounds=adapter.getCellBounds(rowCount,col,false);
          if (col == 0 && (comp.getStyle() & SWT.CHECK) == SWT.CHECK) {
            itemBounds.x=0;
          }
          final org.eclipse.swt.graphics.Point absItemBounds=comp.toDisplay(itemBounds.x,itemBounds.y);
          final Rectangle absRect=new Rectangle(absItemBounds.x,absItemBounds.y,itemBounds.width,itemBounds.height);
          if (absRect.contains(awtMousePos)) {
            if (comp instanceof Table) {
              cell=new SWTCell(rowCount,col,((Table)comp).getItem(rowCount));
            }
 else             if (comp instanceof Tree) {
              cell=new SWTCell(rowCount,col,((TreeAdapter)getComponent()).getRow(rowCount));
            }
            break;
          }
        }
      }
      if (cell == null) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
      }
      return cell;
    }
  }
);
  return returnvalue;
}",0.9684329199549042
95385,"/** 
 * {@inheritDoc} 
 */
public void disconnect(){
  if (isConnected()) {
    m_instance.close();
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Thread.interrupted();
}","/** 
 * {@inheritDoc} 
 */
public void disconnect(){
  if (isConnected()) {
    m_instance.getCommunicator().setIsServerSocketClosable(true);
    m_instance.close();
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Thread.interrupted();
}",0.8565217391304348
95386,"/** 
 * Remove a change Listener
 */
@SuppressWarnings(""String_Node_Str"") public void removeChangeListener(){
  Object children=ChildrenGetter.getAsRealType(getComponent());
  EventTarget component=getComponent();
  if (component instanceof Node) {
    Node node=(Node)component;
    node.visibleProperty().removeListener(VisibleChangeHandler.INSTACE);
    node.idProperty().removeListener(m_iDChangeListener);
  }
  if (children instanceof ObjectProperty) {
    ChildrenListenerHelper.removeListener((ObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.removeListener((ObservableList<? extends EventTarget>)children);
  }
}","/** 
 * Remove a change Listener
 */
@SuppressWarnings(""String_Node_Str"") public void removeChangeListener(){
  Object children=ChildrenGetter.getAsRealType(getComponent());
  EventTarget component=getComponent();
  if (children instanceof ObjectProperty) {
    ChildrenListenerHelper.removeListener((ObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.removeListener((ObservableList<? extends EventTarget>)children);
  }
}",0.8329177057356608
95387,"/** 
 * Add a change Listener
 * @param component the component
 */
@SuppressWarnings(""String_Node_Str"") public void addChangeListener(EventTarget component){
  if (component instanceof Node) {
    ((Node)component).visibleProperty().addListener(VisibleChangeHandler.INSTACE);
    ((Node)component).idProperty().addListener(m_iDChangeListener);
  }
  Object children=ChildrenGetter.getAsRealType(component);
  if (children instanceof ReadOnlyObjectProperty) {
    ChildrenListenerHelper.addListener((ReadOnlyObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.addListener((ObservableList<? extends EventTarget>)children);
  }
}","/** 
 * Add a change Listener
 * @param component the component
 */
@SuppressWarnings(""String_Node_Str"") public void addChangeListener(EventTarget component){
  if (component instanceof Node) {
    Node node=(Node)component;
    node.visibleProperty().addListener(VisibleChangeHandler.INSTACE);
    node.idProperty().addListener(idChangeListener);
  }
  Object children=ChildrenGetter.getAsRealType(component);
  if (children instanceof ReadOnlyObjectProperty) {
    ChildrenListenerHelper.addListener((ReadOnlyObjectProperty<? extends EventTarget>)children);
  }
 else   if (children instanceof ObservableList) {
    ChildrenListenerHelper.addListener((ObservableList<? extends EventTarget>)children);
  }
}",0.9639065817409768
95388,"@Override public void changed(ObservableValue<? extends T> observable,T oldValue,T newValue){
  if (observable instanceof ReadOnlyProperty) {
    @SuppressWarnings(""String_Node_Str"") Object bean=((ReadOnlyProperty)observable).getBean();
    if (bean instanceof EventTarget && !newValue.equals(oldValue)) {
      EventTarget eventTarget=(EventTarget)bean;
      AUTJavaFXHierarchy hierarchy=ComponentHandler.getAutHierarchy();
      hierarchy.removeComponentFromHierarchy(eventTarget);
      hierarchy.createHierarchyFrom(eventTarget);
    }
  }
}","@Override public void changed(ObservableValue<? extends T> observable,T oldValue,T newValue){
  if (observable instanceof ReadOnlyProperty) {
    @SuppressWarnings(""String_Node_Str"") Object bean=((ReadOnlyProperty)observable).getBean();
    if (bean instanceof EventTarget && !newValue.equals(oldValue)) {
      EventTarget eventTarget=(EventTarget)bean;
      AUTJavaFXHierarchy hierarchy=ComponentHandler.getAutHierarchy();
      try {
        if (hierarchy.getComponentIdentifier(eventTarget) != null) {
          hierarchy.removeComponentFromHierarchy(eventTarget);
          hierarchy.createHierarchyFrom(eventTarget);
        }
      }
 catch (      ComponentNotManagedException e) {
      }
    }
  }
}",0.8701195219123506
95389,"@Override public String getText(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      ObservableList<Node> children=getRealComponent().getChildrenUnmodifiable();
      for (      Node node : children) {
        if (node instanceof ListCell) {
          IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,node);
          if (adapter != null && adapter instanceof ITextComponent) {
            return ((ITextComponent)adapter).getText();
          }
        }
      }
      return null;
    }
  }
);
}","@Override public String getText(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      T comboBox=getRealComponent();
      if (comboBox.isEditable()) {
        TextField editor=comboBox.getEditor();
        if (editor != null) {
          return editor.getText();
        }
      }
      ObservableList<Node> children=comboBox.getChildrenUnmodifiable();
      for (      Node node : children) {
        if (node instanceof ListCell) {
          IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,node);
          if (adapter != null && adapter instanceof ITextComponent) {
            return ((ITextComponent)adapter).getText();
          }
        }
      }
      return null;
    }
  }
);
}",0.8465679676985195
95390,"/** 
 * Recursively searches for projects that cannot be used by the given  project. The current rules are as follows: 1. No circular dependencies. This means that a project 'A' can not use  itself nor any project that uses 'A' (this rule is, of course,  transitive).
 * @param projectToCheck The project for which reused/reusable projects arebeing checked.
 * @param checkedProjects Projects that have already been examined by thismethod.
 * @param illegalProjects Projects marked as not reusable by this method.
 * @param projectsToImport Projects that are currently being imported.Reused projects will be searched for by first looking through this collection, and, if the  project is not found there, looking in the # database. May be <code>null</code>.
 */
public static void findIllegalProjects(IProjectPO projectToCheck,Set<IProjectPO> checkedProjects,Set<IProjectPO> illegalProjects,Set<IProjectPO> projectsToImport){
  if (!checkedProjects.contains(projectToCheck)) {
    checkedProjects.add(projectToCheck);
    for (    IReusedProjectPO reused : projectToCheck.getUsedProjects()) {
      try {
        String reusedGuid=reused.getProjectGuid();
        IProjectPO reusedProject=null;
        if (projectsToImport != null) {
          for (          IProjectPO importedProject : projectsToImport) {
            if (reusedGuid.equals(importedProject.getGuid()) && reused.getProjectVersion().equals(importedProject.getProjectVersion())) {
              reusedProject=importedProject;
              break;
            }
          }
        }
        if (reusedProject == null) {
          reusedProject=loadProjectByGuidAndVersion(reused.getProjectGuid(),reused.getMajorNumber(),reused.getMinorNumber(),reused.getMicroNumber(),reused.getVersionQualifier());
        }
        if (reusedProject != null) {
          findIllegalProjects(reusedProject,checkedProjects,illegalProjects,projectsToImport);
        }
      }
 catch (      JBException e) {
        illegalProjects.add(projectToCheck);
      }
      for (      IProjectPO project : illegalProjects) {
        if (project.getGuid().equals(reused.getProjectGuid()) && project.getMajorProjectVersion().equals(reused.getMajorNumber()) && project.getMinorProjectVersion().equals(reused.getMinorNumber())) {
          illegalProjects.add(projectToCheck);
          break;
        }
      }
    }
  }
}","/** 
 * Recursively searches for projects that cannot be used by the given  project. The current rules are as follows: 1. No circular dependencies. This means that a project 'A' can not use  itself nor any project that uses 'A' (this rule is, of course,  transitive).
 * @param projectToCheck The project for which reused/reusable projects arebeing checked.
 * @param checkedProjects Projects that have already been examined by thismethod.
 * @param illegalProjects Projects marked as not reusable by this method.
 * @param projectsToImport Projects that are currently being imported.Reused projects will be searched for by first looking through this collection, and, if the  project is not found there, looking in the # database. May be <code>null</code>.
 */
public static void findIllegalProjects(IProjectPO projectToCheck,Set<IProjectPO> checkedProjects,Set<IProjectPO> illegalProjects,Set<IProjectPO> projectsToImport){
  if (!checkedProjects.contains(projectToCheck)) {
    checkedProjects.add(projectToCheck);
    for (    IReusedProjectPO reused : projectToCheck.getUsedProjects()) {
      try {
        String reusedGuid=reused.getProjectGuid();
        IProjectPO reusedProject=null;
        if (projectsToImport != null) {
          for (          IProjectPO importedProject : projectsToImport) {
            if (reusedGuid.equals(importedProject.getGuid()) && reused.getProjectVersion().equals(importedProject.getProjectVersion())) {
              reusedProject=importedProject;
              break;
            }
          }
        }
        if (reusedProject == null) {
          reusedProject=loadProjectByGuidAndVersion(reused.getProjectGuid(),reused.getMajorNumber(),reused.getMinorNumber(),reused.getMicroNumber(),reused.getVersionQualifier());
        }
        if (reusedProject != null) {
          findIllegalProjects(reusedProject,checkedProjects,illegalProjects,projectsToImport);
        }
      }
 catch (      JBException e) {
        illegalProjects.add(projectToCheck);
      }
      for (      IProjectPO project : illegalProjects) {
        if (project.getGuid().equals(reused.getProjectGuid()) && project.getProjectVersion().equals(reused.getProjectVersion())) {
          illegalProjects.add(projectToCheck);
          break;
        }
      }
    }
  }
}",0.9849397590361446
95391,"@Override public void rcDropValue(String value,String operator,String searchType,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    ListCell<?> targetCell=((ListViewAdapter<ListView<?>>)getComponent()).getCell(value);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    rcSelectValue(value,operator,searchType,BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    Node listView=((Node)getRealComponent());
    listView.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    dndHelper.setDragMode(false);
  }
}","@Override public void rcDropValue(String value,String operator,String searchType,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    ListCell<?> targetCell=((ListViewAdapter<ListView<?>>)getComponent()).getCell(value);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    rcSelectValue(value,operator,searchType,BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    getRobot().shakeMouse();
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    Node listView=((Node)getRealComponent());
    listView.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    dndHelper.setDragMode(false);
  }
}",0.9833810888252148
95392,"@Override public void rcDropIndex(int index,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    ListCell<?> targetCell=((ListViewAdapter<ListView<?>>)getComponent()).getCell(index);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    rcSelectIndex(String.valueOf(index),BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    Node listView=((Node)getRealComponent());
    listView.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    dndHelper.setDragMode(false);
  }
}","@Override public void rcDropIndex(int index,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    ListCell<?> targetCell=((ListViewAdapter<ListView<?>>)getComponent()).getCell(index);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    rcSelectIndex(String.valueOf(index),BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    getRobot().shakeMouse();
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    Node listView=((Node)getRealComponent());
    listView.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    dndHelper.setDragMode(false);
  }
}",0.9825616355983164
95393,"@Override public void rcDropRowByValue(String col,String colOperator,String value,String regexOp,String searchType,int delayBeforeDrop){
  try {
    TableAdapter adapter=(TableAdapter)getComponent();
    int implCol=adapter.getColumnFromString(col,colOperator);
    int implRow=super.findRow(value,regexOp,searchType,adapter,implCol);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropRowByValue(col,colOperator,value,regexOp,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    dndHelper.setDragMode(false);
  }
}","@Override public void rcDropRowByValue(String col,String colOperator,String value,String regexOp,String searchType,int delayBeforeDrop){
  try {
    TableAdapter adapter=(TableAdapter)getComponent();
    int implCol=adapter.getColumnFromString(col,colOperator);
    int implRow=super.findRow(value,regexOp,searchType,adapter,implCol);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropRowByValue(col,colOperator,value,regexOp,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    try {
      pressOrReleaseModifiers(dndHelper.getModifier(),false);
    }
 catch (    RobotException e) {
      if (!EnvironmentUtils.isLinuxOS()) {
        throw e;
      }
    }
    dndHelper.setDragMode(false);
  }
}",0.9411206077872744
95394,"@Override public void rcDropCellByColValue(String row,String rowOperator,String value,String regex,String searchType,int delayBeforeDrop){
  try {
    TableAdapter adapter=(TableAdapter)getComponent();
    int implRow=adapter.getRowFromString(row,rowOperator);
    int implCol=super.findColumn(value,regex,searchType,adapter,implRow);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropCellByColValue(row,rowOperator,value,regex,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    dndHelper.setDragMode(false);
  }
}","@Override public void rcDropCellByColValue(String row,String rowOperator,String value,String regex,String searchType,int delayBeforeDrop){
  try {
    TableAdapter adapter=(TableAdapter)getComponent();
    int implRow=adapter.getRowFromString(row,rowOperator);
    int implCol=super.findColumn(value,regex,searchType,adapter,implRow);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropCellByColValue(row,rowOperator,value,regex,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    try {
      pressOrReleaseModifiers(dndHelper.getModifier(),false);
    }
 catch (    RobotException e) {
      if (!EnvironmentUtils.isLinuxOS()) {
        throw e;
      }
    }
    dndHelper.setDragMode(false);
  }
}",0.9412322274881516
95395,"@Override public void rcDropCell(String row,String rowOperator,String col,String colOperator,int xPos,String xUnits,int yPos,String yUnits,int delayBeforeDrop) throws StepExecutionException {
  try {
    TableAdapter adapter=(TableAdapter)getComponent();
    int implRow=adapter.getRowFromString(row,rowOperator);
    int implCol=adapter.getColumnFromString(col,colOperator);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropCell(row,rowOperator,col,colOperator,xPos,xUnits,yPos,yUnits,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    dndHelper.setDragMode(false);
  }
}","@Override public void rcDropCell(String row,String rowOperator,String col,String colOperator,int xPos,String xUnits,int yPos,String yUnits,int delayBeforeDrop) throws StepExecutionException {
  try {
    TableAdapter adapter=(TableAdapter)getComponent();
    int implRow=adapter.getRowFromString(row,rowOperator);
    int implCol=adapter.getColumnFromString(col,colOperator);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropCell(row,rowOperator,col,colOperator,xPos,xUnits,yPos,yUnits,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    try {
      pressOrReleaseModifiers(dndHelper.getModifier(),false);
    }
 catch (    RobotException e) {
      if (!EnvironmentUtils.isLinuxOS()) {
        throw e;
      }
    }
    dndHelper.setDragMode(false);
  }
}",0.943789664551224
95396,"/** 
 * inputs/replaces the given text
 * @param text the text to input
 * @param replace whether to replace or not
 * @param cell {@link Cell} the location of a Cell
 * @throws StepExecutionException If there is no selected cell,or if the cell is not editable, or if the table cell editor permits the text to be written.
 */
private void inputText(final String text,boolean replace,Cell cell) throws StepExecutionException {
  ITableComponent adapter=getTableAdapter();
  Rectangle rectangle=adapter.scrollCellToVisible(cell.getRow(),cell.getCol());
  Object editor=activateEditor(cell,rectangle);
  editor=setEditorToReplaceMode(editor,replace);
  getRobot().type(editor,text);
}","/** 
 * inputs/replaces the given text
 * @param text the text to input
 * @param replace whether to replace or not
 * @param cell {@link Cell} the location of a Cell
 * @throws StepExecutionException If there is no selected cell,or if the cell is not editable, or if the table cell editor permits the text to be written.
 */
private void inputText(final String text,boolean replace,Cell cell) throws StepExecutionException {
  ITableComponent adapter=getTableAdapter();
  Rectangle rectangle=adapter.scrollCellToVisible(cell.getRow(),cell.getCol());
  Object editor=activateEditor(cell,rectangle);
  editor=setEditorToReplaceMode(editor,replace);
  getRobot().type(editor,text);
  if (replace) {
    getRobot().keyType(null,SWT.CR);
  }
}",0.9591549295774648
95397,"/** 
 * {@inheritDoc}
 */
public Rectangle scrollCellToVisible(final int row,final int col) throws StepExecutionException {
  final Table table=m_table;
  getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Void>(){
    public Void run(){
      if (table.getColumnCount() > 0 || col > 0) {
        table.showColumn(table.getColumn(col));
      }
      table.showItem(table.getItem(row));
      return null;
    }
  }
);
  ((SwtRobot)getRobot()).waitForIdle();
  checkRowColBounds(row,col);
  final org.eclipse.swt.graphics.Rectangle cBoundsRelToParent=SwtPointUtil.toSwtRectangle(getCellBounds(row,col,true));
  getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Void>(){
    public Void run(){
      org.eclipse.swt.graphics.Point cOriginRelToParent=table.getDisplay().map(table,table.getParent(),new org.eclipse.swt.graphics.Point(cBoundsRelToParent.x,cBoundsRelToParent.y));
      cBoundsRelToParent.x=cOriginRelToParent.x;
      cBoundsRelToParent.y=cOriginRelToParent.y;
      return null;
    }
  }
);
  Control parent=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Control>(){
    public Control run(){
      return table.getParent();
    }
  }
);
  getRobot().scrollToVisible(parent,cBoundsRelToParent);
  ((SwtRobot)getRobot()).waitForIdle();
  return getVisibleBounds(getCellBounds(row,col,true));
}","/** 
 * {@inheritDoc}
 */
public Rectangle scrollCellToVisible(final int row,final int col) throws StepExecutionException {
  final Table table=m_table;
  getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Void>(){
    public Void run(){
      if (table.getColumnCount() > 0 || col > 0) {
        table.showColumn(table.getColumn(col));
      }
      table.showItem(table.getItem(row));
      return null;
    }
  }
);
  checkRowColBounds(row,col);
  final org.eclipse.swt.graphics.Rectangle cBoundsRelToParent=SwtPointUtil.toSwtRectangle(getCellBounds(row,col,true));
  getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Void>(){
    public Void run(){
      org.eclipse.swt.graphics.Point cOriginRelToParent=table.getDisplay().map(table,table.getParent(),new org.eclipse.swt.graphics.Point(cBoundsRelToParent.x,cBoundsRelToParent.y));
      cBoundsRelToParent.x=cOriginRelToParent.x;
      cBoundsRelToParent.y=cOriginRelToParent.y;
      return null;
    }
  }
);
  Control parent=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Control>(){
    public Control run(){
      return table.getParent();
    }
  }
);
  getRobot().scrollToVisible(parent,cBoundsRelToParent);
  return getVisibleBounds(getCellBounds(row,col,true));
}",0.9698340874811464
95398,"/** 
 * {@inheritDoc}createButtonsForButtonBar(org.eclipse.swt.widgets.Composite) 
 */
protected void createButtonsForButtonBar(Composite parent){
  m_addButton=createButton(parent,ADD,m_addButtonText,true);
  m_addButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      notifyListener();
      setReturnCode(ADD);
      close();
    }
  }
);
  TreeViewer tv=m_testcaseTreeComposite.getTreeViewer();
  tv.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent e){
      if (e.getSelection() != null) {
        m_addButton.setEnabled(true);
      }
    }
  }
);
  tv.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      m_addButton.setEnabled(checkDataValidityAndSetErrorMessage());
    }
  }
);
  tv.addDoubleClickListener(new IDoubleClickListener(){
    public void doubleClick(    DoubleClickEvent event){
      if (!m_addButton.getEnabled()) {
        return;
      }
      notifyListener();
      setReturnCode(ADD);
      close();
    }
  }
);
  if (m_preSelect != null) {
    tv.getControl().setFocus();
    tv.setSelection(new StructuredSelection(m_preSelect));
  }
  Button cancelButton=createButton(parent,CANCEL,Messages.TestCaseTableDialogCancel,false);
  cancelButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      setReturnCode(CANCEL);
      close();
    }
  }
);
  m_addButton.setEnabled(checkDataValidityAndSetErrorMessage());
}","/** 
 * {@inheritDoc}createButtonsForButtonBar(org.eclipse.swt.widgets.Composite) 
 */
protected void createButtonsForButtonBar(Composite parent){
  String buttonText=m_addButtonText;
  if (m_onlyCategories) {
    buttonText=IDialogConstants.OK_LABEL;
  }
  m_addButton=createButton(parent,IDialogConstants.OK_ID,buttonText,true);
  m_addButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      setReturnCode(IDialogConstants.OK_ID);
      close();
    }
  }
);
  TreeViewer tv=m_testcaseTreeComposite.getTreeViewer();
  tv.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent e){
      if (e.getSelection() != null && !e.getSelection().isEmpty()) {
        m_lastSel=e.getSelection();
        m_addButton.setEnabled(true);
      }
    }
  }
);
  tv.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      m_addButton.setEnabled(checkDataValidityAndSetErrorMessage());
    }
  }
);
  tv.addDoubleClickListener(new IDoubleClickListener(){
    public void doubleClick(    DoubleClickEvent event){
      if (!m_addButton.getEnabled()) {
        return;
      }
      notifyListener();
      setReturnCode(IDialogConstants.OK_ID);
      close();
    }
  }
);
  if (m_preSelect != null) {
    tv.getControl().setFocus();
    tv.setSelection(new StructuredSelection(m_preSelect));
  }
  Button cancelButton=createButton(parent,CANCEL,Messages.TestCaseTableDialogCancel,false);
  cancelButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      setReturnCode(CANCEL);
      close();
    }
  }
);
  m_addButton.setEnabled(checkDataValidityAndSetErrorMessage());
}",0.9062133645955452
95399,"public void doubleClick(DoubleClickEvent event){
  if (!m_addButton.getEnabled()) {
    return;
  }
  notifyListener();
  setReturnCode(ADD);
  close();
}","public void doubleClick(DoubleClickEvent event){
  if (!m_addButton.getEnabled()) {
    return;
  }
  notifyListener();
  setReturnCode(IDialogConstants.OK_ID);
  close();
}",0.9357798165137616
95400,"/** 
 * Asks from the user the new TC name and the category where to save it. Includes business logic to handle 'Back' button when choosing Category.
 * @param editor the Test Case Editor
 * @return whether the operation can commence
 */
protected boolean askNewNameAndCategory(AbstractTestCaseEditor editor){
  TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),Messages.SelectCategoryDialogTitle,Messages.SelectCategoryDialogMessage,null,Messages.SelectCategoryDialogTitle,SWT.SINGLE,IconConstants.OPEN_TC_DIALOG_IMAGE);
  dialog.setReuseds(false);
  dialog.setOnlyCategories(true);
  dialog.setEnterTextLabel(Messages.RefactorTCOptTextLabel,getSuggestedName(editor));
  dialog.setPreSelect(GeneralStorage.getInstance().getProject().getSpecObjCont());
  dialog.open();
  if (dialog.getReturnCode() != TestCaseTreeDialog.ADD || dialog.getSelection().isEmpty()) {
    return false;
  }
  m_newTCName=dialog.getEnteredText();
  m_selectedCategory=dialog.getSelection().get(0);
  return m_newTCName != null && m_selectedCategory != null;
}","/** 
 * Asks from the user the new TC name and the category where to save it. Includes business logic to handle 'Back' button when choosing Category.
 * @param editor the Test Case Editor
 * @return whether the operation can commence
 */
protected boolean askNewNameAndCategory(AbstractTestCaseEditor editor){
  TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),Messages.SelectCategoryDialogTitle,Messages.SelectCategoryDialogMessage,null,Messages.SelectCategoryDialogTitle,SWT.SINGLE,IconConstants.OPEN_TC_DIALOG_IMAGE);
  dialog.setReuseds(false);
  dialog.setOnlyCategories(true);
  dialog.setEnterTextLabel(Messages.RefactorTCOptTextLabel,getSuggestedName(editor));
  dialog.setPreSelect(GeneralStorage.getInstance().getProject().getSpecObjCont());
  dialog.open();
  if (dialog.getReturnCode() != IDialogConstants.OK_ID || dialog.getSelection().isEmpty()) {
    return false;
  }
  m_newTCName=dialog.getEnteredText();
  m_selectedCategory=dialog.getSelection().get(0);
  return m_newTCName != null && m_selectedCategory != null;
}",0.9857414448669202
95401,"/** 
 * Opens the PopUp with the TestCaseTree.
 * @param editor The test case editor.
 */
private void openTestCasePopUp(final TestCaseEditor editor){
  final ISpecTestCasePO parentNode=(ISpecTestCasePO)editor.getTreeViewer().getTree().getItem(0).getData();
  if (hasTestCaseAllEventHandler(parentNode)) {
    return;
  }
  String title=Messages.AddEventHandlerActionAddEventHandler;
  TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),title,StringConstants.EMPTY,parentNode,title,SWT.SINGLE,IconConstants.ADD_EH_IMAGE);
  final SelectionTransfer selTransferObj=new SelectionTransfer();
  ISelectionListener selListener=new ISelectionListener(){
    public void selectionChanged(    IWorkbenchPart part,    ISelection selection){
      selTransferObj.setSelection(selection);
    }
  }
;
  dialog.addSelectionListener(selListener);
  dialog.setHelpAvailable(true);
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.EVENT_HANDLER_ADD);
  int returnCode=dialog.open();
  if (returnCode == TestCaseTreeDialog.ADD) {
    addEventHandler(selTransferObj.getSelection(),parentNode,editor);
  }
  dialog.removeSelectionListener(selListener);
}","/** 
 * Opens the PopUp with the TestCaseTree.
 * @param editor The test case editor.
 */
private void openTestCasePopUp(final TestCaseEditor editor){
  final ISpecTestCasePO parentNode=(ISpecTestCasePO)editor.getTreeViewer().getTree().getItem(0).getData();
  if (hasTestCaseAllEventHandler(parentNode)) {
    return;
  }
  String title=Messages.AddEventHandlerActionAddEventHandler;
  TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),title,StringConstants.EMPTY,parentNode,title,SWT.SINGLE,IconConstants.ADD_EH_IMAGE);
  final SelectionTransfer selTransferObj=new SelectionTransfer();
  ISelectionListener selListener=new ISelectionListener(){
    public void selectionChanged(    IWorkbenchPart part,    ISelection selection){
      selTransferObj.setSelection(selection);
    }
  }
;
  dialog.addSelectionListener(selListener);
  dialog.setHelpAvailable(true);
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.EVENT_HANDLER_ADD);
  int returnCode=dialog.open();
  if (returnCode == IDialogConstants.OK_ID) {
    addEventHandler(selTransferObj.getSelection(),parentNode,editor);
  }
  dialog.removeSelectionListener(selListener);
}",0.9878738884397736
95402,"/** 
 * {@inheritDoc}
 */
public Collection<String> getNodeTextList(final TreeItem node){
  final Collection<String> res=new ArrayList<String>();
  getQueuer().invokeAndWait(""String_Node_Str"" + node,new IRunnable<Void>(){
    public Void run(){
      int colCount=getTree().getColumnCount();
      for (int i=0; i < colCount; i++) {
        String textAtColumn=CAPUtil.getWidgetText(node,SwtToolkitConstants.WIDGET_TEXT_KEY_PREFIX + i,node.getText(i));
        if (textAtColumn != null) {
          res.add(textAtColumn);
        }
      }
      String text=CAPUtil.getWidgetText(node,node.getText());
      if (text != null) {
        res.add(text);
      }
      return null;
    }
  }
);
  return res;
}","/** 
 * {@inheritDoc}
 */
public Collection<String> getNodeTextList(final TreeItem node){
  final Collection<String> res=new ArrayList<String>();
  getQueuer().invokeAndWait(""String_Node_Str"" + node,new IRunnable<Void>(){
    public Void run(){
      String textAtColumn=getRenderedText(node);
      if (textAtColumn != null) {
        res.add(textAtColumn);
      }
      String text=node.getText(getColumn());
      if (text != null) {
        res.add(text);
      }
      return null;
    }
  }
);
  return res;
}",0.5728314238952537
95403,"public void run(IPersistentObject workingPo){
  final INodePO editorNode=(INodePO)workingPo;
  final INodePO node=(INodePO)getSelection().getFirstElement();
  if (node == null) {
    return;
  }
  ISelectionListener listener=getSelectionListener(tce,editorNode,node);
  ISpecTestCasePO specTC=null;
  if (editorNode instanceof ISpecTestCasePO) {
    specTC=(ISpecTestCasePO)editorNode;
  }
  TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),specTC,SWT.MULTI);
  dialog.addSelectionListener(listener);
  dialog.setHelpAvailable(true);
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.TESTCASE_ADD_EXISTING);
  dialog.open();
  dialog.removeSelectionListener(listener);
}","public void run(IPersistentObject workingPo){
  final INodePO editorNode=(INodePO)workingPo;
  final INodePO node=(INodePO)getSelection().getFirstElement();
  if (node == null) {
    return;
  }
  ISpecTestCasePO specTC=null;
  if (editorNode instanceof ISpecTestCasePO) {
    specTC=(ISpecTestCasePO)editorNode;
  }
  TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),specTC,SWT.MULTI);
  dialog.setHelpAvailable(true);
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.TESTCASE_ADD_EXISTING);
  if (dialog.open() == IDialogConstants.OK_ID) {
    addNewNodes(tce,node,dialog.getSelection());
  }
}",0.814663951120163
95404,"/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  final AbstractTestCaseEditor tce=(AbstractTestCaseEditor)HandlerUtil.getActiveEditor(event);
  tce.getEditorHelper().doEditorOperation(new IEditorOperation(){
    public void run(    IPersistentObject workingPo){
      final INodePO editorNode=(INodePO)workingPo;
      final INodePO node=(INodePO)getSelection().getFirstElement();
      if (node == null) {
        return;
      }
      ISelectionListener listener=getSelectionListener(tce,editorNode,node);
      ISpecTestCasePO specTC=null;
      if (editorNode instanceof ISpecTestCasePO) {
        specTC=(ISpecTestCasePO)editorNode;
      }
      TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),specTC,SWT.MULTI);
      dialog.addSelectionListener(listener);
      dialog.setHelpAvailable(true);
      dialog.create();
      DialogUtils.setWidgetNameForModalDialog(dialog);
      Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.TESTCASE_ADD_EXISTING);
      dialog.open();
      dialog.removeSelectionListener(listener);
    }
  }
);
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  final AbstractTestCaseEditor tce=(AbstractTestCaseEditor)HandlerUtil.getActiveEditor(event);
  tce.getEditorHelper().doEditorOperation(new IEditorOperation(){
    public void run(    IPersistentObject workingPo){
      final INodePO editorNode=(INodePO)workingPo;
      final INodePO node=(INodePO)getSelection().getFirstElement();
      if (node == null) {
        return;
      }
      ISpecTestCasePO specTC=null;
      if (editorNode instanceof ISpecTestCasePO) {
        specTC=(ISpecTestCasePO)editorNode;
      }
      TestCaseTreeDialog dialog=new TestCaseTreeDialog(getActiveShell(),specTC,SWT.MULTI);
      dialog.setHelpAvailable(true);
      dialog.create();
      DialogUtils.setWidgetNameForModalDialog(dialog);
      Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.TESTCASE_ADD_EXISTING);
      if (dialog.open() == IDialogConstants.OK_ID) {
        addNewNodes(tce,node,dialog.getSelection());
      }
    }
  }
);
  return null;
}",0.8474733426054706
95405,"/** 
 * Updates the binding between the given scale and its corresponding model value. This is done by removing the old bindings and creating new ones.
 * @param boundProperty the property for the binding
 * @param bindingContext the binding context
 * @param factorScale the scale
 * @param masterObservable the observable
 */
private void updateBindFactor(String boundProperty,final DataBindingContext bindingContext,final Scale factorScale,IObservableValue masterObservable){
  IObservableValue uiElement=WidgetProperties.selection().observe(factorScale);
  IObservableValue modelElement=BeanProperties.value(boundProperty,double.class).observeDetail(masterObservable);
  removeBinding(uiElement,modelElement);
  bindingContext.bindValue(uiElement,modelElement,new JBEditorUpdateValueStrategy(UpdateValueStrategy.POLICY_ON_REQUEST).setConverter(m_sliderToModelConverter),new UpdateValueStrategy().setConverter(m_modelToSliderConverter));
  Label factorText=m_factorLabels.get(factorScale);
  uiElement=WidgetProperties.text().observe(factorText);
  removeBinding(uiElement,modelElement);
  bindingContext.bindValue(uiElement,modelElement,new UpdateValueStrategy().setConverter(m_labelToModelConverter),new UpdateValueStrategy().setConverter(m_modelToLabelConverter));
  uiElement=WidgetProperties.selection().observe(factorScale);
  removeBinding(uiElement,masterObservable);
  bindingContext.bindValue(uiElement,masterObservable,new UpdateValueStrategy(UpdateValueStrategy.POLICY_NEVER),new UpdateValueStrategy().setConverter(m_modelToEnablementConverter));
}","/** 
 * Updates the binding between the given scale and its corresponding model value. This is done by removing the old bindings and creating new ones.
 * @param boundProperty the property for the binding
 * @param bindingContext the binding context
 * @param factorScale the scale
 * @param masterObservable the observable
 */
private void updateBindFactor(String boundProperty,final DataBindingContext bindingContext,final Scale factorScale,IObservableValue masterObservable){
  IObservableValue uiElement=WidgetProperties.selection().observe(factorScale);
  IObservableValue modelElement=BeanProperties.value(boundProperty,double.class).observeDetail(masterObservable);
  removeBinding(uiElement,modelElement);
  bindingContext.bindValue(uiElement,modelElement,new JBEditorUpdateValueStrategy(UpdateValueStrategy.POLICY_ON_REQUEST).setConverter(m_sliderToModelConverter),new UpdateValueStrategy().setConverter(m_modelToSliderConverter));
  Label factorText=m_factorLabels.get(factorScale);
  uiElement=WidgetProperties.text().observe(factorText);
  removeBinding(uiElement,modelElement);
  bindingContext.bindValue(uiElement,modelElement,new UpdateValueStrategy().setConverter(m_labelToModelConverter),new UpdateValueStrategy().setConverter(m_modelToLabelConverter));
  uiElement=WidgetProperties.enabled().observe(factorScale);
  removeBinding(uiElement,masterObservable);
  bindingContext.bindValue(uiElement,masterObservable,new UpdateValueStrategy(UpdateValueStrategy.POLICY_NEVER),new UpdateValueStrategy().setConverter(m_modelToEnablementConverter));
}",0.9948783610755442
95406,"/** 
 * Updates the binding for the threshold
 * @param bindingContext the binding context
 * @param masterObservable the model observable
 */
private void updateThresholdBind(final DataBindingContext bindingContext,IObservableValue masterObservable){
  IObservableValue uiElement;
  IObservableValue modelElement;
  String boundProperty=IObjectMappingProfilePO.PROP_THRESHOLD;
  uiElement=WidgetProperties.selection().observe(m_threshold);
  modelElement=BeanProperties.value(boundProperty,double.class).observe(masterObservable);
  removeBinding(uiElement,masterObservable);
  bindingContext.bindValue(uiElement,modelElement,new UpdateValueStrategy().setConverter(m_sliderToModelConverter),new UpdateValueStrategy().setConverter(m_modelToSliderConverter));
  uiElement=WidgetProperties.text().observe(m_thresholdText);
  removeBinding(uiElement,masterObservable);
  bindingContext.bindValue(uiElement,modelElement,new UpdateValueStrategy(UpdateValueStrategy.POLICY_NEVER),new UpdateValueStrategy().setConverter(m_modelToLabelConverter));
}","/** 
 * Updates the binding for the threshold
 * @param bindingContext the binding context
 * @param masterObservable the model observable
 */
private void updateThresholdBind(final DataBindingContext bindingContext,IObservableValue masterObservable){
  IObservableValue uiElement;
  IObservableValue modelElement;
  String boundProperty=IObjectMappingProfilePO.PROP_THRESHOLD;
  uiElement=WidgetProperties.selection().observe(m_threshold);
  modelElement=BeanProperties.value(boundProperty,double.class).observeDetail(masterObservable);
  removeBinding(uiElement,masterObservable);
  bindingContext.bindValue(uiElement,modelElement,new UpdateValueStrategy().setConverter(m_sliderToModelConverter),new UpdateValueStrategy().setConverter(m_modelToSliderConverter));
  uiElement=WidgetProperties.text().observe(m_thresholdText);
  removeBinding(uiElement,masterObservable);
  bindingContext.bindValue(uiElement,modelElement,new UpdateValueStrategy(UpdateValueStrategy.POLICY_NEVER),new UpdateValueStrategy().setConverter(m_modelToLabelConverter));
}",0.9971264367816092
95407,"public Rectangle run() throws StepExecutionException {
  TableItem ti=m_table.getItem(row);
  int column=(m_table.getColumnCount() > 0 || col > 0) ? col : 0;
  org.eclipse.swt.graphics.Rectangle r=ti.getBounds(column);
  if (!restr) {
    return SwtPointUtil.toAwtRectangle(r);
  }
  String text=CAPUtil.getWidgetText(ti,SwtToolkitConstants.WIDGET_TEXT_KEY_PREFIX + column,ti.getText(column));
  Image image=ti.getImage(column);
  if (text != null && text.length() != 0) {
    GC gc=new GC(m_table);
    int charWidth=0;
    try {
      FontMetrics fm=gc.getFontMetrics();
      charWidth=fm.getAverageCharWidth();
    }
  finally {
      gc.dispose();
    }
    r.width=text.length() * charWidth;
    if (image != null) {
      r.width+=image.getBounds().width;
    }
  }
 else   if (image != null) {
    r.width=image.getBounds().width;
  }
  if (column > 0) {
    TableColumn tc=m_table.getColumn(column);
    int alignment=tc.getAlignment();
    if (alignment == SWT.CENTER) {
      r.x+=((double)tc.getWidth() / 2) - ((double)r.width / 2);
    }
    if (alignment == SWT.RIGHT) {
      r.x+=tc.getWidth() - r.width;
    }
  }
  return new Rectangle(r.x,r.y,r.width,r.height);
}","public Rectangle run() throws StepExecutionException {
  TableItem ti=m_table.getItem(row);
  int column=(m_table.getColumnCount() > 0 || col > 0) ? col : 0;
  org.eclipse.swt.graphics.Rectangle cellbound=ti.getBounds(column);
  if (!restr) {
    return SwtPointUtil.toAwtRectangle(cellbound);
  }
  org.eclipse.swt.graphics.Rectangle calculatedBounds=new org.eclipse.swt.graphics.Rectangle(cellbound.x,cellbound.y,cellbound.width,cellbound.height);
  String text=CAPUtil.getWidgetText(ti,SwtToolkitConstants.WIDGET_TEXT_KEY_PREFIX + column,ti.getText(column));
  Image image=ti.getImage(column);
  if (text != null && text.length() != 0) {
    GC gc=new GC(m_table);
    int charWidth=0;
    try {
      FontMetrics fm=gc.getFontMetrics();
      charWidth=fm.getAverageCharWidth();
    }
  finally {
      gc.dispose();
    }
    calculatedBounds.width=text.length() * charWidth;
    if (image != null) {
      calculatedBounds.width+=image.getBounds().width;
    }
  }
 else   if (image != null) {
    calculatedBounds.width=image.getBounds().width;
  }
  if (column > 0) {
    TableColumn tc=m_table.getColumn(column);
    int alignment=tc.getAlignment();
    if (alignment == SWT.CENTER) {
      calculatedBounds.x+=((double)tc.getWidth() / 2) - ((double)calculatedBounds.width / 2);
    }
    if (alignment == SWT.RIGHT) {
      calculatedBounds.x+=tc.getWidth() - calculatedBounds.width;
    }
  }
  return SwtPointUtil.toAwtRectangle(cellbound.intersection(calculatedBounds));
}",0.8586426696662918
95408,"/** 
 * {@inheritDoc} 
 */
public Rectangle getCellBounds(final int row,final int col,final boolean restr){
  return getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Rectangle>(){
    public Rectangle run() throws StepExecutionException {
      TableItem ti=m_table.getItem(row);
      int column=(m_table.getColumnCount() > 0 || col > 0) ? col : 0;
      org.eclipse.swt.graphics.Rectangle r=ti.getBounds(column);
      if (!restr) {
        return SwtPointUtil.toAwtRectangle(r);
      }
      String text=CAPUtil.getWidgetText(ti,SwtToolkitConstants.WIDGET_TEXT_KEY_PREFIX + column,ti.getText(column));
      Image image=ti.getImage(column);
      if (text != null && text.length() != 0) {
        GC gc=new GC(m_table);
        int charWidth=0;
        try {
          FontMetrics fm=gc.getFontMetrics();
          charWidth=fm.getAverageCharWidth();
        }
  finally {
          gc.dispose();
        }
        r.width=text.length() * charWidth;
        if (image != null) {
          r.width+=image.getBounds().width;
        }
      }
 else       if (image != null) {
        r.width=image.getBounds().width;
      }
      if (column > 0) {
        TableColumn tc=m_table.getColumn(column);
        int alignment=tc.getAlignment();
        if (alignment == SWT.CENTER) {
          r.x+=((double)tc.getWidth() / 2) - ((double)r.width / 2);
        }
        if (alignment == SWT.RIGHT) {
          r.x+=tc.getWidth() - r.width;
        }
      }
      return new Rectangle(r.x,r.y,r.width,r.height);
    }
  }
);
}","/** 
 * {@inheritDoc} 
 */
public Rectangle getCellBounds(final int row,final int col,final boolean restr){
  return getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Rectangle>(){
    public Rectangle run() throws StepExecutionException {
      TableItem ti=m_table.getItem(row);
      int column=(m_table.getColumnCount() > 0 || col > 0) ? col : 0;
      org.eclipse.swt.graphics.Rectangle cellbound=ti.getBounds(column);
      if (!restr) {
        return SwtPointUtil.toAwtRectangle(cellbound);
      }
      org.eclipse.swt.graphics.Rectangle calculatedBounds=new org.eclipse.swt.graphics.Rectangle(cellbound.x,cellbound.y,cellbound.width,cellbound.height);
      String text=CAPUtil.getWidgetText(ti,SwtToolkitConstants.WIDGET_TEXT_KEY_PREFIX + column,ti.getText(column));
      Image image=ti.getImage(column);
      if (text != null && text.length() != 0) {
        GC gc=new GC(m_table);
        int charWidth=0;
        try {
          FontMetrics fm=gc.getFontMetrics();
          charWidth=fm.getAverageCharWidth();
        }
  finally {
          gc.dispose();
        }
        calculatedBounds.width=text.length() * charWidth;
        if (image != null) {
          calculatedBounds.width+=image.getBounds().width;
        }
      }
 else       if (image != null) {
        calculatedBounds.width=image.getBounds().width;
      }
      if (column > 0) {
        TableColumn tc=m_table.getColumn(column);
        int alignment=tc.getAlignment();
        if (alignment == SWT.CENTER) {
          calculatedBounds.x+=((double)tc.getWidth() / 2) - ((double)calculatedBounds.width / 2);
        }
        if (alignment == SWT.RIGHT) {
          calculatedBounds.x+=tc.getWidth() - calculatedBounds.width;
        }
      }
      return SwtPointUtil.toAwtRectangle(cellbound.intersection(calculatedBounds));
    }
  }
);
}",0.887709991158267
95409,"/** 
 * Replaces the given text in the given cell coordinates
 * @param text the text to replace
 * @param row The row of the cell.
 * @param rowOperator The row operator
 * @param col The column of the cell.
 * @param colOperator The column operator
 */
public void rcReplaceText(String text,String row,String rowOperator,String col,String colOperator){
  if (getTableAdapter().getRowFromString(row,rowOperator) == -1) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.UNSUPPORTED_HEADER_ACTION));
  }
  selectCell(row,rowOperator,col,colOperator,ClickOptions.create().setClickCount(1),ValueSets.BinaryChoice.no.rcValue());
  inputText(text,true);
}","/** 
 * Replaces the given text in the given cell coordinates
 * @param text the text to replace
 * @param row The row of the cell.
 * @param rowOperator The row operator
 * @param col The column of the cell.
 * @param colOperator The column operator
 */
public void rcReplaceText(String text,String row,String rowOperator,String col,String colOperator){
  if (getTableAdapter().getRowFromString(row,rowOperator) == -1) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.UNSUPPORTED_HEADER_ACTION));
  }
  selectCell(row,rowOperator,col,colOperator,ClickOptions.create().setClickCount(1),ValueSets.BinaryChoice.no.rcValue());
  inputText(text,true,getCellAtMousePosition());
}",0.9825296995108316
95410,"/** 
 * inputs/replaces the given text
 * @param text the text to input
 * @param replace whether to replace or not
 * @throws StepExecutionException If there is no selected cell,or if the cell is not editable, or if the table cell editor permits the text to be written.
 */
private void inputText(final String text,boolean replace) throws StepExecutionException {
  ITableComponent adapter=getTableAdapter();
  final Cell cell=adapter.getSelectedCell();
  Rectangle rectangle=adapter.scrollCellToVisible(cell.getRow(),cell.getCol());
  Object editor=activateEditor(cell,rectangle);
  editor=setEditorToReplaceMode(editor,replace);
  getRobot().type(editor,text);
}","/** 
 * inputs/replaces the given text
 * @param text the text to input
 * @param replace whether to replace or not
 * @param cell {@link Cell} the location of a Cell
 * @throws StepExecutionException If there is no selected cell,or if the cell is not editable, or if the table cell editor permits the text to be written.
 */
private void inputText(final String text,boolean replace,Cell cell) throws StepExecutionException {
  ITableComponent adapter=getTableAdapter();
  Rectangle rectangle=adapter.scrollCellToVisible(cell.getRow(),cell.getCol());
  Object editor=activateEditor(cell,rectangle);
  editor=setEditorToReplaceMode(editor,replace);
  getRobot().type(editor,text);
}",0.6285289747399703
95411,"/** 
 * {@inheritDoc}
 */
public String[] getSelectedValues(){
  ListElement element=(ListElement)m_list.getElementAt(m_list.getSelectionIndex());
  return new String[]{element.getTabItem().getText()};
}","/** 
 * {@inheritDoc}
 */
public String[] getSelectedValues(){
  return new String[]{getTextOfElementAtIndex(m_list.getSelectionIndex())};
}",0.6472303206997084
95412,"/** 
 * {@inheritDoc}
 */
public String[] getValues(){
  String[] values=new String[m_list.getNumberOfElements()];
  for (int j=0; j < m_list.getNumberOfElements(); j++) {
    ListElement element=(ListElement)m_list.getElementAt(j);
    String string=element.getTabItem().getText();
    values[j]=string;
  }
  return values;
}","/** 
 * {@inheritDoc}
 */
public String[] getValues(){
  List<String> values=new ArrayList<String>();
  try {
    for (int i=0; i < m_list.getNumberOfElements(); i++) {
      values.add(getTextOfElementAtIndex(i));
    }
  }
 catch (  NoSuchMethodError e) {
    int i=0;
    while (m_list.getElementAt(i) != null) {
      values.add(getTextOfElementAtIndex(i));
      i++;
    }
  }
  return values.toArray(new String[values.size()]);
}",0.3538663171690694
95413,"/** 
 * {@inheritDoc}
 */
public void clickOnIndex(Integer i,ClickOptions co){
  Canvas a=(Canvas)m_list.getElementAt(i.intValue());
  TabItem c=null;
  getRobot().click(a,null,co);
}","/** 
 * {@inheritDoc}
 */
public void clickOnIndex(final Integer index,final ClickOptions co){
  Object element=scrollToElement(index);
  getRobot().click(element,null,co);
}",0.7226890756302521
95414,"/** 
 * Invokes the next step
 * @param cap cap, which to create the corresponding message for
 */
private void processCap(ICapPO cap){
  ICapPO currCap=cap;
  MessageCap messageCap=null;
  if (currCap == null) {
    endTestExecution();
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug(Messages.TestStep + StringConstants.COLON + StringConstants.SPACE+ currCap.getName());
      LOG.debug(Messages.Component + StringConstants.COLON + StringConstants.SPACE+ currCap.getComponentName());
    }
    messageCap=buildMessageCap(currCap,false);
    if (!m_stopped) {
      CAPTestMessage capTestMessage=new CAPTestMessage(messageCap);
      TimeUtil.delay(m_stepSpeed);
      while (isPaused()) {
        testConnection();
        TimeUtil.delay(100);
      }
      if (!m_stopped) {
        CAPTestResponseMessage clientResponse=clientExecutionHandling(currCap,capTestMessage);
        if (!m_stopped) {
          if (clientResponse != null) {
            CAPTestResponseCommand responseCommand=new CAPTestResponseCommand();
            responseCommand.setMessage(clientResponse);
            responseCommand.setMessageCap(messageCap);
            responseCommand.execute();
          }
 else {
            final int timeOut=calculateRequestTimeout(messageCap);
            AUTConnection.getInstance().request(capTestMessage,new CAPTestResponseCommand(),timeOut);
          }
        }
      }
 else {
        endTestExecution();
      }
    }
  }
 catch (  NotConnectedException bnce) {
    LOG.error(Messages.AUTConnectionFails,bnce);
  }
catch (  CommunicationException bce) {
    LOG.error(Messages.CommunicationWithAUTFails,bce);
    fireError(bce);
  }
catch (  LogicComponentNotManagedException blcnme) {
    LOG.error(blcnme.getMessage(),blcnme);
    fireComponentError();
  }
catch (  InvalidDataException ide) {
  }
}","/** 
 * Invokes the next step
 * @param cap cap, which to create the corresponding message for
 */
private void processCap(ICapPO cap){
  ICapPO currCap=cap;
  MessageCap messageCap=null;
  if (currCap == null) {
    endTestExecution();
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug(Messages.TestStep + StringConstants.COLON + StringConstants.SPACE+ currCap.getName());
      LOG.debug(Messages.Component + StringConstants.COLON + StringConstants.SPACE+ currCap.getComponentName());
    }
    messageCap=buildMessageCap(currCap,false);
    if (!m_stopped) {
      CAPTestMessage capTestMessage=new CAPTestMessage(messageCap);
      TimeUtil.delay(m_stepSpeed);
      while (isPaused()) {
        testConnection();
        TimeUtil.delay(100);
      }
      if (!m_stopped) {
        CAPTestResponseMessage clientResponse=clientExecutionHandling(currCap,capTestMessage);
        if (!m_stopped) {
          if (clientResponse != null) {
            CAPTestResponseCommand responseCommand=new CAPTestResponseCommand();
            responseCommand.setMessage(clientResponse);
            responseCommand.setMessageCap(messageCap);
            responseCommand.execute();
          }
 else {
            final int timeOut=calculateRequestTimeout(messageCap);
            AUTConnection.getInstance().request(capTestMessage,new CAPTestResponseCommand(),timeOut);
          }
        }
      }
 else {
        endTestExecution();
      }
    }
  }
 catch (  NotConnectedException bnce) {
    LOG.error(Messages.AUTConnectionFails,bnce);
    fireError(bnce);
  }
catch (  CommunicationException bce) {
    LOG.error(Messages.CommunicationWithAUTFails,bce);
    fireError(bce);
  }
catch (  LogicComponentNotManagedException blcnme) {
    LOG.error(blcnme.getMessage(),blcnme);
    fireComponentError();
  }
catch (  InvalidDataException ide) {
  }
}",0.994341147938561
95415,"/** 
 * {@inheritDoc}
 */
public Message execute(){
  TakeScreenshotResponseMessage response=new TakeScreenshotResponseMessage();
  IRobot robot=AUTServer.getInstance().getRobot();
  final BufferedImage createScreenCapture=robot.createFullScreenCapture();
  Point currentPointingDevicePosition=robot.getCurrentMousePosition();
  if (currentPointingDevicePosition != null) {
    final int pdX=currentPointingDevicePosition.x;
    final int pdY=currentPointingDevicePosition.y;
    final int xStart=pdX - LINE_LENGTH_PER_DIRECTION;
    final int yStart=pdY - LINE_LENGTH_PER_DIRECTION;
    for (int i=0; i < TOTAL_LINE_LENGTH; i++) {
      for (int j=0; j < TOTAL_LINE_LENGTH; j++) {
        invertPixelAtPoint(createScreenCapture,xStart + i,yStart + j);
      }
    }
  }
  if (RobotConfiguration.getInstance().isErrorHighlighting()) {
    WeakReference<IComponent> errorComponent=AUTServer.getInstance().getErrorComponent();
    if (errorComponent != null) {
      try {
        highlightErrorComponent(errorComponent,robot,createScreenCapture);
      }
 catch (      RuntimeException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
  final SerializedImage computedSerializeImage=SerializedImage.computeSerializeImage(createScreenCapture);
  response.setScreenshot(computedSerializeImage);
  return response;
}","/** 
 * {@inheritDoc}
 */
public Message execute(){
  TakeScreenshotResponseMessage response=new TakeScreenshotResponseMessage();
  IRobot robot=AUTServer.getInstance().getRobot();
  final BufferedImage createScreenCapture=robot.createFullScreenCapture();
  try {
    Point currentPointingDevicePosition=robot.getCurrentMousePosition();
    if (currentPointingDevicePosition != null) {
      final int pdX=currentPointingDevicePosition.x;
      final int pdY=currentPointingDevicePosition.y;
      final int xStart=pdX - LINE_LENGTH_PER_DIRECTION;
      final int yStart=pdY - LINE_LENGTH_PER_DIRECTION;
      for (int i=0; i < TOTAL_LINE_LENGTH; i++) {
        for (int j=0; j < TOTAL_LINE_LENGTH; j++) {
          invertPixelAtPoint(createScreenCapture,xStart + i,yStart + j);
        }
      }
    }
  }
 catch (  Exception e) {
  }
  if (RobotConfiguration.getInstance().isErrorHighlighting()) {
    WeakReference<IComponent> errorComponent=AUTServer.getInstance().getErrorComponent();
    if (errorComponent != null) {
      try {
        highlightErrorComponent(errorComponent,robot,createScreenCapture);
      }
 catch (      RuntimeException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
  final SerializedImage computedSerializeImage=SerializedImage.computeSerializeImage(createScreenCapture);
  response.setScreenshot(computedSerializeImage);
  return response;
}",0.9760589318600368
95416,"/** 
 * Invokes the next step
 * @param cap cap, which to create the corresponding message for
 */
private void processCap(ICapPO cap){
  ICapPO currCap=cap;
  MessageCap messageCap=null;
  if (currCap == null) {
    endTestExecution();
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug(Messages.TestStep + StringConstants.COLON + StringConstants.SPACE+ currCap.getName());
      LOG.debug(Messages.Component + StringConstants.COLON + StringConstants.SPACE+ currCap.getComponentName());
    }
    messageCap=buildMessageCap(currCap,false);
    if (!m_stopped) {
      CAPTestMessage capTestMessage=new CAPTestMessage(messageCap);
      TimeUtil.delay(m_stepSpeed);
      while (isPaused()) {
        testConnection();
        TimeUtil.delay(100);
      }
      if (!m_stopped) {
        CAPTestResponseMessage clientResponse=clientExecutionHandling(currCap,capTestMessage);
        if (!m_stopped) {
          if (clientResponse != null) {
            CAPTestResponseCommand responseCommand=new CAPTestResponseCommand();
            responseCommand.setMessage(clientResponse);
            responseCommand.setMessageCap(messageCap);
            responseCommand.execute();
          }
 else {
            final int timeOut=calculateRequestTimeout(messageCap);
            AUTConnection.getInstance().request(capTestMessage,new CAPTestResponseCommand(),timeOut);
          }
        }
      }
 else {
        endTestExecution();
      }
    }
  }
 catch (  NotConnectedException bnce) {
    LOG.error(Messages.AUTConnectionFails,bnce);
  }
catch (  CommunicationException bce) {
    LOG.error(Messages.CommunicationWithAUTFails,bce);
    fireError(bce);
  }
catch (  LogicComponentNotManagedException blcnme) {
    LOG.error(blcnme.getMessage(),blcnme);
    fireComponentError();
  }
catch (  InvalidDataException ide) {
  }
}","/** 
 * Invokes the next step
 * @param cap cap, which to create the corresponding message for
 */
private void processCap(ICapPO cap){
  ICapPO currCap=cap;
  MessageCap messageCap=null;
  if (currCap == null) {
    endTestExecution();
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug(Messages.TestStep + StringConstants.COLON + StringConstants.SPACE+ currCap.getName());
      LOG.debug(Messages.Component + StringConstants.COLON + StringConstants.SPACE+ currCap.getComponentName());
    }
    messageCap=buildMessageCap(currCap,false);
    if (!m_stopped) {
      CAPTestMessage capTestMessage=new CAPTestMessage(messageCap);
      TimeUtil.delay(m_stepSpeed);
      while (isPaused()) {
        testConnection();
        TimeUtil.delay(100);
      }
      if (!m_stopped) {
        CAPTestResponseMessage clientResponse=clientExecutionHandling(currCap,capTestMessage);
        if (!m_stopped) {
          if (clientResponse != null) {
            CAPTestResponseCommand responseCommand=new CAPTestResponseCommand();
            responseCommand.setMessage(clientResponse);
            responseCommand.setMessageCap(messageCap);
            responseCommand.execute();
          }
 else {
            final int timeOut=calculateRequestTimeout(messageCap);
            AUTConnection.getInstance().request(capTestMessage,new CAPTestResponseCommand(),timeOut);
          }
        }
      }
 else {
        endTestExecution();
      }
    }
  }
 catch (  NotConnectedException bnce) {
    LOG.error(Messages.AUTConnectionFails,bnce);
    fireError(bnce);
  }
catch (  CommunicationException bce) {
    LOG.error(Messages.CommunicationWithAUTFails,bce);
    fireError(bce);
  }
catch (  LogicComponentNotManagedException blcnme) {
    LOG.error(blcnme.getMessage(),blcnme);
    fireComponentError();
  }
catch (  InvalidDataException ide) {
  }
}",0.994341147938561
95417,"/** 
 * @param addTo the node to add to
 * @param nodeToCopy the param node to clone and add
 * @param pMapper the param name mapper
 * @param oldToNewGuids the old to new guid map
 * @param specTC the top-level specTC for the params
 * @throws PMException in case of an persitence exception
 */
private void addCloneToNode(INodePO addTo,INodePO nodeToCopy,ParamNameBPDecorator pMapper,Map<String,String> oldToNewGuids,ISpecTestCasePO specTC) throws PMException {
  INodePO newNode=null;
  if (nodeToCopy instanceof IExecTestCasePO) {
    IExecTestCasePO origExec=(IExecTestCasePO)nodeToCopy;
    IExecTestCasePO newExec=NodeMaker.createExecTestCasePO(origExec.getSpecTestCase());
    fillExec(origExec,newExec);
    newNode=newExec;
  }
 else   if (nodeToCopy instanceof ICapPO) {
    ICapPO origCap=(ICapPO)nodeToCopy;
    ICapPO newCap=NodeMaker.createCapPO(origCap.getName(),origCap.getComponentName(),origCap.getComponentType(),origCap.getActionName());
    fillCap(origCap,newCap);
    newNode=newCap;
  }
 else   if (nodeToCopy instanceof ICommentPO) {
    ICommentPO origComment=(ICommentPO)nodeToCopy;
    ICommentPO newComment=NodeMaker.createCommentPO(origComment.getName());
    newNode=newComment;
  }
 else   if (nodeToCopy instanceof IControllerPO) {
    newNode=NodeMaker.createControllerPO((IControllerPO)nodeToCopy);
    int i=0;
    for (    INodePO node : nodeToCopy.getUnmodifiableNodeList()) {
      for (      INodePO node2 : node.getUnmodifiableNodeList()) {
        addCloneToNode(newNode.getUnmodifiableNodeList().get(i),node2,pMapper,oldToNewGuids,specTC);
      }
    }
  }
  if (newNode != null) {
    if (newNode instanceof IParamNodePO) {
      addParamsToSpec(specTC,(IParamNodePO)newNode,pMapper,oldToNewGuids);
    }
    addTo.addNode(newNode);
  }
}","/** 
 * @param addTo the node to add to
 * @param nodeToCopy the param node to clone and add
 * @param pMapper the param name mapper
 * @param oldToNewGuids the old to new guid map
 * @param specTC the top-level specTC for the params
 * @throws PMException in case of an persitence exception
 */
private void addCloneToNode(INodePO addTo,INodePO nodeToCopy,ParamNameBPDecorator pMapper,Map<String,String> oldToNewGuids,ISpecTestCasePO specTC) throws PMException {
  INodePO newNode=null;
  if (nodeToCopy instanceof IExecTestCasePO) {
    IExecTestCasePO origExec=(IExecTestCasePO)nodeToCopy;
    IExecTestCasePO newExec=NodeMaker.createExecTestCasePO(origExec.getSpecTestCase());
    fillExec(origExec,newExec);
    newNode=newExec;
  }
 else   if (nodeToCopy instanceof ICapPO) {
    ICapPO origCap=(ICapPO)nodeToCopy;
    ICapPO newCap=NodeMaker.createCapPO(origCap.getName(),origCap.getComponentName(),origCap.getComponentType(),origCap.getActionName());
    fillCap(origCap,newCap);
    newNode=newCap;
  }
 else   if (nodeToCopy instanceof ICommentPO) {
    ICommentPO origComment=(ICommentPO)nodeToCopy;
    ICommentPO newComment=NodeMaker.createCommentPO(origComment.getName());
    newNode=newComment;
  }
 else   if (nodeToCopy instanceof IControllerPO) {
    newNode=NodeMaker.createControllerPO((IControllerPO)nodeToCopy);
    int i=0;
    for (    INodePO node : nodeToCopy.getUnmodifiableNodeList()) {
      for (      INodePO node2 : node.getUnmodifiableNodeList()) {
        addCloneToNode(newNode.getUnmodifiableNodeList().get(i),node2,pMapper,oldToNewGuids,specTC);
      }
      i++;
    }
  }
  if (newNode != null) {
    if (newNode instanceof IParamNodePO) {
      addParamsToSpec(specTC,(IParamNodePO)newNode,pMapper,oldToNewGuids);
    }
    addTo.addNode(newNode);
  }
}",0.9969265157865326
95418,"/** 
 * calls the method of the implementation class per reflection  {@inheritDoc}
 */
public Message execute(){
  AUTServer autServer=AUTServer.getInstance();
  autServer.setErrorComponent(null);
  final int oldMode=autServer.getMode();
  TestErrorEvent event=null;
  CAPTestResponseMessage response=new CAPTestResponseMessage();
  autServer.setMode(ChangeAUTModeMessage.TESTING);
  try {
    MessageCap messageCap=m_capTestMessage.getMessageCap();
    response.setMessageCap(messageCap);
    Object implClass=getImplClass(response);
    if (implClass == null) {
      return response;
    }
    MethodInvoker invoker=new MethodInvoker(messageCap);
    Object returnValue=invoker.invoke(implClass);
    response.setReturnValue((String)returnValue);
    if (""String_Node_Str"".equals(System.getenv(""String_Node_Str"")) && messageCap != null && messageCap.getCi() != null && messageCap.getCi().getComponentClassName() != null && messageCap.getAction() != null && messageCap.getAction().getName() != null) {
      CAPLOG.debug(messageCap.getCi().getComponentClassName() + ""String_Node_Str"" + CompSystemI18n.getString(messageCap.getAction().getName()));
    }
  }
 catch (  NoSuchMethodException nsme) {
    LOG.error(""String_Node_Str"",nsme);
    event=EventFactory.createUnsupportedActionError();
  }
catch (  IllegalAccessException iae) {
    LOG.error(""String_Node_Str"",iae);
    event=EventFactory.createConfigErrorEvent();
  }
catch (  InvocationTargetException ite) {
    if (ite.getTargetException() instanceof EventSupportException) {
      EventSupportException e=(EventSupportException)ite.getTargetException();
      event=e.getEvent();
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else     if (ite.getTargetException() instanceof ExecutionEvent) {
      ExecutionEvent e=(ExecutionEvent)ite.getTargetException();
      response.setState(e.getEvent());
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else {
      event=EventFactory.createConfigErrorEvent();
      if (LOG.isErrorEnabled()) {
        LOG.error(""String_Node_Str"",ite);
        LOG.error(""String_Node_Str"",ite.getTargetException());
      }
    }
  }
catch (  IllegalArgumentException e) {
    LOG.error(e.getLocalizedMessage(),e);
  }
catch (  MethodParamException ex) {
    LOG.error(ex.getLocalizedMessage(),ex);
  }
 finally {
    autServer.setMode(oldMode);
  }
  if (event != null) {
    response.setTestErrorEvent(event);
  }
  return response;
}","/** 
 * calls the method of the implementation class per reflection  {@inheritDoc}
 */
public Message execute(){
  AUTServer autServer=AUTServer.getInstance();
  autServer.setErrorComponent(null);
  final int oldMode=autServer.getMode();
  TestErrorEvent event=null;
  CAPTestResponseMessage response=new CAPTestResponseMessage();
  autServer.setMode(ChangeAUTModeMessage.TESTING);
  try {
    MessageCap messageCap=m_capTestMessage.getMessageCap();
    response.setMessageCap(messageCap);
    Object implClass=getImplClass(response);
    if (implClass == null) {
      return response;
    }
    MethodInvoker invoker=new MethodInvoker(messageCap);
    Object returnValue=invoker.invoke(implClass);
    if (returnValue != null) {
      response.setReturnValue(String.valueOf(returnValue));
    }
    if (""String_Node_Str"".equals(System.getenv(""String_Node_Str"")) && messageCap != null && messageCap.getCi() != null && messageCap.getCi().getComponentClassName() != null && messageCap.getAction() != null && messageCap.getAction().getName() != null) {
      CAPLOG.debug(messageCap.getCi().getComponentClassName() + ""String_Node_Str"" + CompSystemI18n.getString(messageCap.getAction().getName()));
    }
  }
 catch (  NoSuchMethodException nsme) {
    LOG.error(""String_Node_Str"",nsme);
    event=EventFactory.createUnsupportedActionError();
  }
catch (  IllegalAccessException iae) {
    LOG.error(""String_Node_Str"",iae);
    event=EventFactory.createConfigErrorEvent();
  }
catch (  InvocationTargetException ite) {
    if (ite.getTargetException() instanceof EventSupportException) {
      EventSupportException e=(EventSupportException)ite.getTargetException();
      event=e.getEvent();
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else     if (ite.getTargetException() instanceof ExecutionEvent) {
      ExecutionEvent e=(ExecutionEvent)ite.getTargetException();
      response.setState(e.getEvent());
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else {
      event=EventFactory.createConfigErrorEvent();
      if (LOG.isErrorEnabled()) {
        LOG.error(""String_Node_Str"",ite);
        LOG.error(""String_Node_Str"",ite.getTargetException());
      }
    }
  }
catch (  IllegalArgumentException e) {
    LOG.error(e.getLocalizedMessage(),e);
  }
catch (  MethodParamException ex) {
    LOG.error(ex.getLocalizedMessage(),ex);
  }
 finally {
    autServer.setMode(oldMode);
  }
  if (event != null) {
    response.setTestErrorEvent(event);
  }
  return response;
}",0.9872273531145608
95419,"@Override public void handle(ActionEvent event){
  Iterator<Window> it=Window.impl_getWindows();
  List<Window> tempWin=new ArrayList<>();
  while (it.hasNext()) {
    Window w=it.next();
    tempWin.add(w);
    if (!windows.contains(w)) {
      windows.add(w);
    }
  }
  it=windows.listIterator();
  while (it.hasNext()) {
    Window w=it.next();
    if (!tempWin.contains(w)) {
      it.remove();
    }
  }
}","@Override public void handle(ActionEvent event){
  Iterator<Window> it=WindowsUtil.getWindowIterator();
  List<Window> tempWin=new ArrayList<>();
  while (it.hasNext()) {
    Window w=it.next();
    tempWin.add(w);
    if (!windows.contains(w)) {
      windows.add(w);
    }
  }
  it=windows.listIterator();
  while (it.hasNext()) {
    Window w=it.next();
    if (!tempWin.contains(w)) {
      it.remove();
    }
  }
}",0.4669073405535499
95420,"/** 
 * @param clickModifier the click modifier to use for this click
 * @return an array of modifiers to press before click and release afterclick
 */
private int[] getModifierMask(ClickModifier clickModifier){
  int[] modifier=new int[0];
  if (clickModifier.hasModifiers(ClickModifier.M1)) {
    modifier=ArrayUtils.add(modifier,KeyCode.CONTROL.impl_getCode());
  }
  if (clickModifier.hasModifiers(ClickModifier.M2)) {
    modifier=ArrayUtils.add(modifier,KeyCode.SHIFT.impl_getCode());
  }
  if (clickModifier.hasModifiers(ClickModifier.M3)) {
    modifier=ArrayUtils.add(modifier,KeyCode.ALT.impl_getCode());
  }
  if (clickModifier.hasModifiers(ClickModifier.M4)) {
    modifier=ArrayUtils.add(modifier,KeyCode.META.impl_getCode());
  }
  return modifier;
}","/** 
 * @param clickModifier the click modifier to use for this click
 * @return an array of modifiers to press before click and release afterclick
 */
private int[] getModifierMask(ClickModifier clickModifier){
  int[] modifier=new int[0];
  if (clickModifier.hasModifiers(ClickModifier.M1)) {
    modifier=ArrayUtils.add(modifier,KeyCodeUtil.getKeyCode(KeyCode.CONTROL));
  }
  if (clickModifier.hasModifiers(ClickModifier.M2)) {
    modifier=ArrayUtils.add(modifier,KeyCodeUtil.getKeyCode(KeyCode.SHIFT));
  }
  if (clickModifier.hasModifiers(ClickModifier.M3)) {
    modifier=ArrayUtils.add(modifier,KeyCodeUtil.getKeyCode(KeyCode.ALT));
  }
  if (clickModifier.hasModifiers(ClickModifier.M4)) {
    modifier=ArrayUtils.add(modifier,KeyCodeUtil.getKeyCode(KeyCode.META));
  }
  return modifier;
}",0.90537084398977
95421,"public String call(){
  Iterator<Window> iter=Window.impl_getWindows();
  while (iter.hasNext()) {
    Window window=iter.next();
    if (window instanceof Tooltip) {
      return ((Tooltip)window).getText();
    }
  }
  return null;
}","public String call(){
  Iterator<Window> iter=WindowsUtil.getWindowIterator();
  while (iter.hasNext()) {
    Window window=iter.next();
    if (window instanceof Tooltip) {
      return ((Tooltip)window).getText();
    }
  }
  return null;
}",0.9559748427672956
95422,"@Override public String getTooltipText(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    public String call(){
      Iterator<Window> iter=Window.impl_getWindows();
      while (iter.hasNext()) {
        Window window=iter.next();
        if (window instanceof Tooltip) {
          return ((Tooltip)window).getText();
        }
      }
      return null;
    }
  }
);
}","@Override public String getTooltipText(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    public String call(){
      Iterator<Window> iter=WindowsUtil.getWindowIterator();
      while (iter.hasNext()) {
        Window window=iter.next();
        if (window instanceof Tooltip) {
          return ((Tooltip)window).getText();
        }
      }
      return null;
    }
  }
);
}",0.9775147928994082
95423,"/** 
 * Opens the list of choices for the ChoiceBox.
 * @return A MenuTester object to select Items. This is Possible because theChoiceBox uses a ContextMenu.
 */
private MenuTester openMenu(){
  getRobot().click(getRealComponent(),null);
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<MenuTester>(){
    @Override public MenuTester call() throws Exception {
      MenuTester menuTester=null;
      Iterator<Window> iter=Window.impl_getWindows();
      long timeout=TimeoutConstants.SERVER_TIMEOUT_WAIT_FOR_POPUP;
      long done=System.currentTimeMillis() + timeout;
      long now;
      do {
        if (!iter.hasNext()) {
          iter=Window.impl_getWindows();
        }
        Window w=iter.next();
        if (w instanceof ContextMenu && ((ContextMenu)w).getOwnerNode().equals(getRealComponent())) {
          menuTester=new MenuTester();
          menuTester.setComponent(w);
          break;
        }
        now=System.currentTimeMillis();
        timeout=done - now;
      }
 while (timeout > 0);
      return menuTester;
    }
  }
);
}","/** 
 * Opens the list of choices for the ChoiceBox.
 * @return A MenuTester object to select Items. This is Possible because theChoiceBox uses a ContextMenu.
 */
private MenuTester openMenu(){
  getRobot().click(getRealComponent(),null);
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<MenuTester>(){
    @Override public MenuTester call() throws Exception {
      MenuTester menuTester=null;
      Iterator<Window> iter=WindowsUtil.getWindowIterator();
      long timeout=TimeoutConstants.SERVER_TIMEOUT_WAIT_FOR_POPUP;
      long done=System.currentTimeMillis() + timeout;
      long now;
      do {
        if (!iter.hasNext()) {
          iter=WindowsUtil.getWindowIterator();
        }
        Window w=iter.next();
        if (w instanceof ContextMenu && ((ContextMenu)w).getOwnerNode().equals(getRealComponent())) {
          menuTester=new MenuTester();
          menuTester.setComponent(w);
          break;
        }
        now=System.currentTimeMillis();
        timeout=done - now;
      }
 while (timeout > 0);
      return menuTester;
    }
  }
);
}",0.9807692307692308
95424,"/** 
 * Opens the context menu of the given node and finds it with Window.impl_getWindows(). Use this method for components which are not a subclass of Control and therefore don't have the context menu property
 * @param xPos what x position
 * @param xUnits should x position be pixel or percent values
 * @param yPos what y position
 * @param yUnits should y position be pixel or percent values
 * @param button MouseButton
 * @param n the Node
 * @return a MenuTester instance which references the context menu
 */
protected AbstractMenuTester openContextMenu(int xPos,String xUnits,int yPos,String yUnits,int button,Node n){
  boolean isAbsoluteUnitsX=ValueSets.Unit.pixel.rcValue().equalsIgnoreCase(xUnits);
  boolean isAbsoluteUnitsY=ValueSets.Unit.pixel.rcValue().equalsIgnoreCase(yUnits);
  getRobot().click(n,null,ClickOptions.create().setClickCount(1).setMouseButton(button),xPos,isAbsoluteUnitsX,yPos,isAbsoluteUnitsY);
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<MenuTester>(){
    @Override public MenuTester call() throws Exception {
      MenuTester menuTester=null;
      Iterator<Window> iter=Window.impl_getWindows();
      ArrayList<ContextMenu> result=new ArrayList<>();
      long timeout=TimeoutConstants.SERVER_TIMEOUT_WAIT_FOR_POPUP;
      long done=System.currentTimeMillis() + timeout;
      long now;
      do {
        if (!iter.hasNext()) {
          iter=Window.impl_getWindows();
        }
        Window w=iter.next();
        if (w instanceof ContextMenu && !result.contains(w)) {
          result.add((ContextMenu)w);
        }
        now=System.currentTimeMillis();
        timeout=done - now;
      }
 while (timeout > 0 && !(!iter.hasNext() && result.size() > 0));
      if (result.size() == 1) {
        ContextMenu cm=result.get(0);
        menuTester=new MenuTester();
        menuTester.setComponent(cm);
      }
 else       if (result.size() == 0) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.POPUP_NOT_FOUND));
      }
 else       if (result.size() > 1) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.UNSUPPORTED_OPERATION_IN_TOOLKIT_ERROR));
      }
      return menuTester;
    }
  }
);
}","/** 
 * Opens the context menu of the given node and finds it with Window.impl_getWindows(). Use this method for components which are not a subclass of Control and therefore don't have the context menu property
 * @param xPos what x position
 * @param xUnits should x position be pixel or percent values
 * @param yPos what y position
 * @param yUnits should y position be pixel or percent values
 * @param button MouseButton
 * @param n the Node
 * @return a MenuTester instance which references the context menu
 */
protected AbstractMenuTester openContextMenu(int xPos,String xUnits,int yPos,String yUnits,int button,Node n){
  boolean isAbsoluteUnitsX=ValueSets.Unit.pixel.rcValue().equalsIgnoreCase(xUnits);
  boolean isAbsoluteUnitsY=ValueSets.Unit.pixel.rcValue().equalsIgnoreCase(yUnits);
  getRobot().click(n,null,ClickOptions.create().setClickCount(1).setMouseButton(button),xPos,isAbsoluteUnitsX,yPos,isAbsoluteUnitsY);
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<MenuTester>(){
    @Override public MenuTester call() throws Exception {
      MenuTester menuTester=null;
      Iterator<Window> iter=WindowsUtil.getWindowIterator();
      ArrayList<ContextMenu> result=new ArrayList<>();
      long timeout=TimeoutConstants.SERVER_TIMEOUT_WAIT_FOR_POPUP;
      long done=System.currentTimeMillis() + timeout;
      long now;
      do {
        if (!iter.hasNext()) {
          iter=WindowsUtil.getWindowIterator();
        }
        Window w=iter.next();
        if (w instanceof ContextMenu && !result.contains(w)) {
          result.add((ContextMenu)w);
        }
        now=System.currentTimeMillis();
        timeout=done - now;
      }
 while (timeout > 0 && !(!iter.hasNext() && result.size() > 0));
      if (result.size() == 1) {
        ContextMenu cm=result.get(0);
        menuTester=new MenuTester();
        menuTester.setComponent(cm);
      }
 else       if (result.size() == 0) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.POPUP_NOT_FOUND));
      }
 else       if (result.size() > 1) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.UNSUPPORTED_OPERATION_IN_TOOLKIT_ERROR));
      }
      return menuTester;
    }
  }
);
}",0.9908735332464146
95425,"@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.isAssignableFrom(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IContainerAdapter.class)) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}","@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.equals(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.equals(IContainerAdapter.class)) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.equals(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}",0.9430051813471504
95426,"/** 
 * @param objectToAdapt the object to adapt
 * @return the component adapter
 */
private IComponent getComponentAdapter(Object objectToAdapt){
  if (objectToAdapt instanceof MenuButton) {
    return new MenuButtonAdapter((MenuButton)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ButtonBase) {
    return new ButtonBaseAdapter((ButtonBase)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Label) {
    return new LabeledAdapter<Label>((Label)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Text) {
    return new TextAdapter((Text)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TextInputControl) {
    return new TextComponentAdapter((TextInputControl)objectToAdapt);
  }
 else   if (objectToAdapt instanceof DatePicker) {
    return new DatePickerAdapter((DatePicker)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TreeView) {
    return new TreeViewAdapter((TreeView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TableView) {
    return new TableAdapter((TableView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ContextMenu) {
    return new ContextMenuAdapter((ContextMenu)objectToAdapt);
  }
 else   if (objectToAdapt instanceof MenuBar) {
    return new MenuBarAdapter((MenuBar)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ImageView) {
    return new JavaFXComponentAdapter<ImageView>((ImageView)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TitledPane) {
    return new LabeledAdapter<TitledPane>((TitledPane)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ListView) {
    return new ListViewAdapter<ListView<?>>((ListView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ComboBox) {
    return new ComboBoxAdapter<ComboBox<?>>((ComboBox<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ChoiceBox) {
    return new ChoiceBoxAdapter((ChoiceBox<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Accordion) {
    return new AccordionAdapter((Accordion)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TreeTableView) {
    return new TreeTableViewAdapter((TreeTableView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Cell) {
    return new CellAdapter((Cell<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Slider) {
    return new SliderAdapter((Slider)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Shape) {
    return new JavaFXComponentAdapter<Shape>((Shape)objectToAdapt);
  }
  return null;
}","/** 
 * @param objectToAdapt the object to adapt
 * @return the component adapter
 */
private IComponent getComponentAdapter(Object objectToAdapt){
  if (objectToAdapt instanceof MenuButton) {
    return new MenuButtonAdapter((MenuButton)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ButtonBase) {
    return new ButtonBaseAdapter((ButtonBase)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Label) {
    return new LabeledAdapter<Label>((Label)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Text) {
    return new TextAdapter((Text)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TextInputControl) {
    return new TextComponentAdapter((TextInputControl)objectToAdapt);
  }
 else   if (objectToAdapt instanceof DatePicker) {
    return new DatePickerAdapter((DatePicker)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TreeView) {
    return new TreeViewAdapter((TreeView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TableView) {
    return new TableAdapter((TableView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ContextMenu) {
    return new ContextMenuAdapter((ContextMenu)objectToAdapt);
  }
 else   if (objectToAdapt instanceof MenuBar) {
    return new MenuBarAdapter((MenuBar)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ImageView) {
    return new JavaFXComponentAdapter<ImageView>((ImageView)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TabPane) {
    return new TabPaneAdapter((TabPane)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TitledPane) {
    return new LabeledAdapter<TitledPane>((TitledPane)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ListView) {
    return new ListViewAdapter<ListView<?>>((ListView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ComboBox) {
    return new ComboBoxAdapter<ComboBox<?>>((ComboBox<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ChoiceBox) {
    return new ChoiceBoxAdapter((ChoiceBox<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Accordion) {
    return new AccordionAdapter((Accordion)objectToAdapt);
  }
 else   if (objectToAdapt instanceof TreeTableView) {
    return new TreeTableViewAdapter((TreeTableView<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Cell) {
    return new CellAdapter((Cell<?>)objectToAdapt);
  }
 else   if (objectToAdapt instanceof SplitPane) {
    return new SplitPaneAdapter((SplitPane)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Slider) {
    return new SliderAdapter((Slider)objectToAdapt);
  }
 else   if (objectToAdapt instanceof ToolBar) {
    return new ToolBarAdapter((ToolBar)objectToAdapt);
  }
 else   if (objectToAdapt instanceof Shape) {
    return new JavaFXComponentAdapter<Shape>((Shape)objectToAdapt);
  }
  return null;
}",0.9329302852824484
95427,"/** 
 * {@inheritDoc} 
 */
public ListView<?> call() throws Exception {
  T comboBox=getRealComponent();
  List<ListView> listViewList=NodeTraverseHelper.getInstancesOf(comboBox,ListView.class);
  if (listViewList.size() == 1) {
    return listViewList.get(0);
  }
  ComboBoxListViewSkin<?> comboBoxListViewSkin=(ComboBoxListViewSkin<?>)comboBox.getSkin();
  return (ListView<?>)comboBoxListViewSkin.getPopupContent();
}","/** 
 * {@inheritDoc} 
 */
public ListView<?> call() throws Exception {
  T comboBox=getRealComponent();
  @SuppressWarnings(""String_Node_Str"") List<ListView> listViewList=NodeTraverseHelper.getInstancesOf(comboBox,ListView.class);
  if (listViewList.size() == 1) {
    return listViewList.get(0);
  }
  ComboBoxListViewSkin<?> comboBoxListViewSkin=(ComboBoxListViewSkin<?>)comboBox.getSkin();
  return (ListView<?>)comboBoxListViewSkin.getPopupContent();
}",0.9578107183580388
95428,"/** 
 * Returns the list with the items of the combo box.
 * @return the list
 */
private ListView<?> getComboBoxList(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<ListView<?>>(){
    /** 
 * {@inheritDoc} 
 */
    public ListView<?> call() throws Exception {
      T comboBox=getRealComponent();
      List<ListView> listViewList=NodeTraverseHelper.getInstancesOf(comboBox,ListView.class);
      if (listViewList.size() == 1) {
        return listViewList.get(0);
      }
      ComboBoxListViewSkin<?> comboBoxListViewSkin=(ComboBoxListViewSkin<?>)comboBox.getSkin();
      return (ListView<?>)comboBoxListViewSkin.getPopupContent();
    }
  }
);
}","/** 
 * Returns the list with the items of the combo box.
 * @return the list
 */
private ListView<?> getComboBoxList(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<ListView<?>>(){
    /** 
 * {@inheritDoc} 
 */
    public ListView<?> call() throws Exception {
      T comboBox=getRealComponent();
      @SuppressWarnings(""String_Node_Str"") List<ListView> listViewList=NodeTraverseHelper.getInstancesOf(comboBox,ListView.class);
      if (listViewList.size() == 1) {
        return listViewList.get(0);
      }
      ComboBoxListViewSkin<?> comboBoxListViewSkin=(ComboBoxListViewSkin<?>)comboBox.getSkin();
      return (ListView<?>)comboBoxListViewSkin.getPopupContent();
    }
  }
);
}",0.9738145789101204
95429,"/** 
 * {@inheritDoc}
 */
public String getPropertyValueOfCell(String name,ListCell<?> cell){
  Object prop=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      try {
        IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
        if (adapter != null) {
          return ((ITextComponent)adapter).getPropteryValue(name);
        }
        return null;
      }
 catch (      RobotException e) {
        throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
      }
    }
  }
);
  return String.valueOf(prop);
}","/** 
 * {@inheritDoc}
 */
public String getPropertyValueOfCell(String name,ListCell<?> cell){
  Object prop=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      try {
        IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
        if (adapter != null && adapter instanceof ITextComponent) {
          return ((ITextComponent)adapter).getPropteryValue(name);
        }
        return null;
      }
 catch (      RobotException e) {
        throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
      }
    }
  }
);
  return String.valueOf(prop);
}",0.975016880486158
95430,"@Override public String call() throws Exception {
  try {
    IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
    if (adapter != null) {
      return ((ITextComponent)adapter).getPropteryValue(name);
    }
    return null;
  }
 catch (  RobotException e) {
    throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
  }
}","@Override public String call() throws Exception {
  try {
    IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
    if (adapter != null && adapter instanceof ITextComponent) {
      return ((ITextComponent)adapter).getPropteryValue(name);
    }
    return null;
  }
 catch (  RobotException e) {
    throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
  }
}",0.9598262757871878
95431,"/** 
 * {@inheritDoc}
 */
public String getPropertyValueOfCell(String name,TableCell<?,?> cell){
  Object prop=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      try {
        IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
        if (adapter != null) {
          return ((ITextComponent)adapter).getPropteryValue(name);
        }
        return null;
      }
 catch (      RobotException e) {
        throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
      }
    }
  }
);
  return String.valueOf(prop);
}","/** 
 * {@inheritDoc}
 */
public String getPropertyValueOfCell(String name,TableCell<?,?> cell){
  Object prop=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      try {
        IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
        if (adapter != null && adapter instanceof ITextComponent) {
          return ((ITextComponent)adapter).getPropteryValue(name);
        }
        return null;
      }
 catch (      RobotException e) {
        throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
      }
    }
  }
);
  return String.valueOf(prop);
}",0.9751176866173504
95432,"/** 
 * {@inheritDoc}
 */
@Override public String getPropertyValueOfCell(String name,TreeTableCell<?,?> cell){
  Object prop=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      try {
        IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
        if (adapter != null) {
          return ((ITextComponent)adapter).getPropteryValue(name);
        }
        return null;
      }
 catch (      RobotException e) {
        throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
      }
    }
  }
);
  return String.valueOf(prop);
}","/** 
 * {@inheritDoc}
 */
@Override public String getPropertyValueOfCell(String name,TreeTableCell<?,?> cell){
  Object prop=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      try {
        IComponent adapter=(IComponent)AdapterFactoryRegistry.getInstance().getAdapter(IComponent.class,cell);
        if (adapter != null && adapter instanceof ITextComponent) {
          return ((ITextComponent)adapter).getPropteryValue(name);
        }
        return null;
      }
 catch (      RobotException e) {
        throw new StepExecutionException(e.getMessage(),EventFactory.createActionError(TestErrorEvent.PROPERTY_NOT_ACCESSABLE));
      }
    }
  }
);
  return String.valueOf(prop);
}",0.9755775577557756
95433,"/** 
 * calls the method of the implementation class per reflection  {@inheritDoc}
 */
public Message execute(){
  AUTServer autServer=AUTServer.getInstance();
  autServer.setErrorComponent(null);
  final int oldMode=autServer.getMode();
  TestErrorEvent event=null;
  CAPTestResponseMessage response=new CAPTestResponseMessage();
  autServer.setMode(ChangeAUTModeMessage.TESTING);
  try {
    MessageCap messageCap=m_capTestMessage.getMessageCap();
    response.setMessageCap(messageCap);
    Object implClass=getImplClass(response);
    if (implClass == null) {
      return response;
    }
    MethodInvoker invoker=new MethodInvoker(messageCap);
    Object returnValue=invoker.invoke(implClass);
    response.setReturnValue((String)returnValue);
    if (""String_Node_Str"".equals(System.getenv(""String_Node_Str"")) && messageCap != null && messageCap.getCi() != null && messageCap.getCi().getComponentClassName() != null && messageCap.getAction() != null && messageCap.getAction().getName() != null) {
      CAPLOG.debug(messageCap.getCi().getComponentClassName() + ""String_Node_Str"" + CompSystemI18n.getString(messageCap.getAction().getName()));
    }
  }
 catch (  NoSuchMethodException nsme) {
    LOG.error(""String_Node_Str"",nsme);
    event=EventFactory.createUnsupportedActionError();
  }
catch (  IllegalAccessException iae) {
    LOG.error(""String_Node_Str"",iae);
    event=EventFactory.createConfigErrorEvent();
  }
catch (  InvocationTargetException ite) {
    if (ite.getTargetException() instanceof EventSupportException) {
      EventSupportException e=(EventSupportException)ite.getTargetException();
      event=e.getEvent();
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else     if (ite.getTargetException() instanceof ExecutionEvent) {
      ExecutionEvent e=(ExecutionEvent)ite.getTargetException();
      response.setState(e.getEvent());
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else {
      event=EventFactory.createConfigErrorEvent();
      if (LOG.isErrorEnabled()) {
        LOG.error(""String_Node_Str"",ite);
        LOG.error(""String_Node_Str"",ite.getTargetException());
      }
    }
  }
catch (  IllegalArgumentException e) {
    LOG.error(e.getLocalizedMessage(),e);
  }
catch (  MethodParamException ex) {
    LOG.error(ex.getLocalizedMessage(),ex);
  }
 finally {
    autServer.setMode(oldMode);
  }
  if (event != null) {
    response.setTestErrorEvent(event);
  }
  return response;
}","/** 
 * calls the method of the implementation class per reflection  {@inheritDoc}
 */
public Message execute(){
  AUTServer autServer=AUTServer.getInstance();
  autServer.setErrorComponent(null);
  final int oldMode=autServer.getMode();
  TestErrorEvent event=null;
  CAPTestResponseMessage response=new CAPTestResponseMessage();
  autServer.setMode(ChangeAUTModeMessage.TESTING);
  try {
    MessageCap messageCap=m_capTestMessage.getMessageCap();
    response.setMessageCap(messageCap);
    Object implClass=getImplClass(response);
    if (implClass == null) {
      return response;
    }
    MethodInvoker invoker=new MethodInvoker(messageCap);
    Object returnValue=invoker.invoke(implClass);
    if (returnValue != null) {
      response.setReturnValue(String.valueOf(returnValue));
    }
    if (""String_Node_Str"".equals(System.getenv(""String_Node_Str"")) && messageCap != null && messageCap.getCi() != null && messageCap.getCi().getComponentClassName() != null && messageCap.getAction() != null && messageCap.getAction().getName() != null) {
      CAPLOG.debug(messageCap.getCi().getComponentClassName() + ""String_Node_Str"" + CompSystemI18n.getString(messageCap.getAction().getName()));
    }
  }
 catch (  NoSuchMethodException nsme) {
    LOG.error(""String_Node_Str"",nsme);
    event=EventFactory.createUnsupportedActionError();
  }
catch (  IllegalAccessException iae) {
    LOG.error(""String_Node_Str"",iae);
    event=EventFactory.createConfigErrorEvent();
  }
catch (  InvocationTargetException ite) {
    if (ite.getTargetException() instanceof EventSupportException) {
      EventSupportException e=(EventSupportException)ite.getTargetException();
      event=e.getEvent();
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else     if (ite.getTargetException() instanceof ExecutionEvent) {
      ExecutionEvent e=(ExecutionEvent)ite.getTargetException();
      response.setState(e.getEvent());
      if (LOG.isDebugEnabled()) {
        LOG.debug(e.getLocalizedMessage(),e);
      }
    }
 else {
      event=EventFactory.createConfigErrorEvent();
      if (LOG.isErrorEnabled()) {
        LOG.error(""String_Node_Str"",ite);
        LOG.error(""String_Node_Str"",ite.getTargetException());
      }
    }
  }
catch (  IllegalArgumentException e) {
    LOG.error(e.getLocalizedMessage(),e);
  }
catch (  MethodParamException ex) {
    LOG.error(ex.getLocalizedMessage(),ex);
  }
 finally {
    autServer.setMode(oldMode);
  }
  if (event != null) {
    response.setTestErrorEvent(event);
  }
  return response;
}",0.9872273531145608
95434,"/** 
 * @param area The composite.creates the text field to edit the comment text
 */
private void createCommentTextField(Composite area){
  m_commentTextField=new Text(area,SWT.MULTI | SWT.BORDER | SWT.WRAP| SWT.V_SCROLL);
  if (m_comment != null) {
    m_commentTextField.setText(m_comment.getName());
  }
  GridData gridData=newGridData();
  gridData.grabExcessVerticalSpace=true;
  gridData.verticalAlignment=SWT.FILL;
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_commentTextField);
  m_commentTextField.setLayoutData(gridData);
  LayoutUtil.setMaxChar(m_commentTextField,org.eclipse.jubula.client.core.model.IPersistentObject.MAX_STRING_LENGTH);
}","/** 
 * @param area The composite.creates the text field to edit the comment text
 */
private void createCommentTextField(Composite area){
  m_commentTextField=new Text(area,SWT.MULTI | SWT.BORDER | SWT.WRAP| SWT.V_SCROLL);
  if (m_comment != null) {
    m_commentTextField.setText(StringUtils.defaultIfBlank(m_comment.getName(),StringUtils.EMPTY));
  }
  GridData gridData=newGridData();
  gridData.grabExcessVerticalSpace=true;
  gridData.verticalAlignment=SWT.FILL;
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_commentTextField);
  m_commentTextField.setLayoutData(gridData);
  LayoutUtil.setMaxChar(m_commentTextField,org.eclipse.jubula.client.core.model.IPersistentObject.MAX_STRING_LENGTH);
}",0.9659763313609468
95435,"/** 
 * Finds the first column which contains the value <code>value</code> in the given row and selects the cell.
 * @param row the row
 * @param rowOperator the row header operator
 * @param value the value
 * @param regex search using regex
 * @param extendSelection Should this selection be part of a multiple selection
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @param co the click options to use
 */
protected void selectCellByColValue(String row,String rowOperator,final String value,final String regex,final String extendSelection,final String searchType,ClickOptions co){
  ITableComponent adapter=getTableAdapter();
  final int implRow=adapter.getRowFromString(row,rowOperator);
  int colCount=adapter.getColumnCount();
  Integer implCol=null;
  if (implRow == -1) {
    for (int i=getStartingColIndex(searchType); i < colCount; ++i) {
      if (MatchUtil.getInstance().match(adapter.getColumnHeaderText(i),value,regex)) {
        implCol=new Integer(i);
        break;
      }
    }
  }
 else {
    for (int i=getStartingColIndex(searchType); i < colCount; ++i) {
      if (MatchUtil.getInstance().match(getCellText(implRow,i),value,regex)) {
        implCol=new Integer(i);
        break;
      }
    }
  }
  if (implCol == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
  }
  String usrIdxRowStr=new Integer(IndexConverter.toUserIndex(implRow)).toString();
  String usrIdxColStr=new Integer(IndexConverter.toUserIndex(implCol.intValue())).toString();
  selectCell(usrIdxRowStr,rowOperator,usrIdxColStr,MatchUtil.EQUALS,co,extendSelection);
}","/** 
 * Finds the first column which contains the value <code>value</code> in the given row and selects the cell.
 * @param row the row
 * @param rowOperator the row header operator
 * @param value the value
 * @param regex search using regex
 * @param extendSelection Should this selection be part of a multiple selection
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @param co the click options to use
 */
protected void selectCellByColValue(String row,String rowOperator,final String value,final String regex,final String extendSelection,final String searchType,ClickOptions co){
  ITableComponent adapter=getTableAdapter();
  final int implRow=adapter.getRowFromString(row,rowOperator);
  Integer implCol=findColumn(value,regex,searchType,adapter,implRow);
  String usrIdxRowStr=new Integer(IndexConverter.toUserIndex(implRow)).toString();
  String usrIdxColStr=new Integer(IndexConverter.toUserIndex(implCol.intValue())).toString();
  selectCell(usrIdxRowStr,rowOperator,usrIdxColStr,MatchUtil.EQUALS,co,extendSelection);
}",0.7411464037970062
95436,"/** 
 * Finds the first row which contains the value <code>value</code> in column <code>col</code> and selects this row.
 * @param col the column
 * @param colOperator the column header operator
 * @param value the value
 * @param regexOp the regex operator
 * @param extendSelection Should this selection be part of a multiple selection
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @param co the clickOptions to use
 */
protected void selectRowByValue(String col,String colOperator,final String value,final String regexOp,final String extendSelection,final String searchType,ClickOptions co){
  ITableComponent adapter=getTableAdapter();
  final int implCol=adapter.getColumnFromString(col,colOperator);
  Integer implRow=null;
  final int rowCount=adapter.getRowCount();
  for (int i=getStartingRowIndex(searchType); i < rowCount; ++i) {
    if (MatchUtil.getInstance().match(getCellText(i,implCol),value,regexOp)) {
      implRow=new Integer(i);
      break;
    }
  }
  if (implRow == null) {
    String header=adapter.getColumnHeaderText(implCol);
    if (MatchUtil.getInstance().match(header,value,regexOp)) {
      implRow=new Integer(-1);
    }
  }
  if (implRow == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
  }
  String userIdxRow=new Integer(IndexConverter.toUserIndex(implRow.intValue())).toString();
  String userIdxCol=new Integer(IndexConverter.toUserIndex(implCol)).toString();
  selectCell(userIdxRow,MatchUtil.EQUALS,userIdxCol,colOperator,co,extendSelection);
}","/** 
 * Finds the first row which contains the value <code>value</code> in column <code>col</code> and selects this row.
 * @param col the column
 * @param colOperator the column header operator
 * @param value the value
 * @param regexOp the regex operator
 * @param extendSelection Should this selection be part of a multiple selection
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @param co the clickOptions to use
 */
protected void selectRowByValue(String col,String colOperator,final String value,final String regexOp,final String extendSelection,final String searchType,ClickOptions co){
  ITableComponent adapter=getTableAdapter();
  final int implCol=adapter.getColumnFromString(col,colOperator);
  Integer implRow=findRow(value,regexOp,searchType,adapter,implCol);
  String userIdxRow=new Integer(IndexConverter.toUserIndex(implRow.intValue())).toString();
  String userIdxCol=new Integer(IndexConverter.toUserIndex(implCol)).toString();
  selectCell(userIdxRow,MatchUtil.EQUALS,userIdxCol,colOperator,co,extendSelection);
}",0.7793567688855647
95437,"@Override public void rcDropRowByValue(String col,String colOperator,String value,String regexOp,String searchType,int delayBeforeDrop){
  try {
    ITableComponent adapter=(ITableComponent)getComponent();
    int implRow=adapter.getRowFromString(value,regexOp);
    int implCol=adapter.getColumnFromString(col,colOperator);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropRowByValue(col,colOperator,value,regexOp,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    dndHelper.setDragMode(false);
  }
}","@Override public void rcDropRowByValue(String col,String colOperator,String value,String regexOp,String searchType,int delayBeforeDrop){
  try {
    ITableComponent adapter=(ITableComponent)getComponent();
    int implCol=adapter.getColumnFromString(col,colOperator);
    int implRow=super.findRow(value,regexOp,searchType,adapter,implCol);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropRowByValue(col,colOperator,value,regexOp,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    dndHelper.setDragMode(false);
  }
}",0.9079878665318504
95438,"@Override public void rcDropCellByColValue(String row,String rowOperator,String value,String regex,String searchType,int delayBeforeDrop){
  try {
    ITableComponent adapter=(ITableComponent)getComponent();
    int implRow=adapter.getRowFromString(row,rowOperator);
    int implCol=adapter.getColumnFromString(value,regex);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropCellByColValue(row,rowOperator,value,regex,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    dndHelper.setDragMode(false);
  }
}","@Override public void rcDropCellByColValue(String row,String rowOperator,String value,String regex,String searchType,int delayBeforeDrop){
  try {
    ITableComponent adapter=(ITableComponent)getComponent();
    int implRow=adapter.getRowFromString(row,rowOperator);
    int implCol=super.findColumn(value,regex,searchType,adapter,implRow);
    TableCell targetCell=getCellAt(implRow + 1,implCol + 1);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    super.rcDropCellByColValue(row,rowOperator,value,regex,searchType,delayBeforeDrop);
  }
  finally {
    Node table=((Node)getRealComponent());
    table.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    dndHelper.setDragMode(false);
  }
}",0.9646821392532796
95439,"/** 
 * @param string the method name
 * @return the keycode
 * @throws NoSuchMethodException {@link Class#getMethod(String,Class)}
 * @throws IllegalAccessException {@link Method#invoke(Object,Object)}
 * @throws InvocationTargetException {@link Method#invoke(Object,Object)}
 */
private static int getKeyCodeViaReflection(String string) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  Class<KeyCode> clazz=KeyCode.class;
  Method method=clazz.getMethod(string);
  Object o=method.invoke(null);
  if (o instanceof Integer) {
    return ((Integer)o);
  }
  Assert.notReached();
  return -1;
}","/** 
 * @param string the method name
 * @param keyCode the  {@link KeyCode} where we need the integer code from
 * @return the integer code
 * @throws NoSuchMethodException {@link Class#getMethod(String,Class)}
 * @throws IllegalAccessException {@link Method#invoke(Object,Object)}
 * @throws InvocationTargetException {@link Method#invoke(Object,Object)}
 */
private static int getKeyCodeViaReflection(String string,KeyCode keyCode) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  Class<KeyCode> clazz=KeyCode.class;
  Method method=clazz.getMethod(string);
  Object o=method.invoke(keyCode);
  if (o instanceof Integer) {
    return ((Integer)o);
  }
  Assert.notReached();
  return -1;
}",0.9166051660516604
95440,"/** 
 * @param keyCode the keyCode
 * @return the underlying platform code see {@link KeyCode#impl_getCode()}or   {@link KeyCode#getCode()}
 */
public static int getKeyCode(KeyCode keyCode){
  try {
    return getKeyCodeViaReflection(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  try {
    return getKeyCodeViaReflection(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  throw new NoSuchMethodError(""String_Node_Str"");
}","/** 
 * @param keyCode the keyCode
 * @return the underlying platform code see {@link KeyCode#impl_getCode()}or   {@link KeyCode#getCode()}
 */
public static int getKeyCode(KeyCode keyCode){
  try {
    return getKeyCodeViaReflection(""String_Node_Str"",keyCode);
  }
 catch (  Exception e) {
  }
  try {
    return getKeyCodeViaReflection(""String_Node_Str"",keyCode);
  }
 catch (  Exception e) {
  }
  throw new NoSuchMethodError(""String_Node_Str"");
}",0.9819004524886876
95441,"/** 
 * {@inheritDoc}
 */
public void rcDropByIndexPath(String pathType,int preAscend,String treeIndexPath,int delayBeforeDrop){
  try {
    rcSelectByIndices(pathType,preAscend,treeIndexPath,0,1,ValueSets.BinaryChoice.no.rcValue());
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
  }
}","/** 
 * {@inheritDoc}
 */
public void rcDropByIndexPath(String pathType,int preAscend,String treeIndexPath,int delayBeforeDrop){
  try {
    getRobot().shakeMouse();
    rcSelectByIndices(pathType,preAscend,treeIndexPath,0,1,ValueSets.BinaryChoice.no.rcValue());
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
  }
}",0.971258671952428
95442,"/** 
 * {@inheritDoc}
 */
public void rcDropByTextPath(String pathType,int preAscend,String treeTextPath,String operator,int delayBeforeDrop){
  try {
    rcSelect(pathType,preAscend,treeTextPath,operator,0,1,ValueSets.BinaryChoice.no.rcValue());
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
  }
}","/** 
 * {@inheritDoc}
 */
public void rcDropByTextPath(String pathType,int preAscend,String treeTextPath,String operator,int delayBeforeDrop){
  try {
    getRobot().shakeMouse();
    rcSelect(pathType,preAscend,treeTextPath,operator,0,1,ValueSets.BinaryChoice.no.rcValue());
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
  }
}",0.9719806763285024
95443,"@Override public void onChanged(Change<? extends EventTarget> c){
  c.next();
  List<? extends EventTarget> changedObjects=c.getRemoved();
  for (  EventTarget o : changedObjects) {
    m_hierarchy.removeComponentFromHierarchy(o);
  }
  changedObjects=c.getAddedSubList();
  for (  EventTarget o : changedObjects) {
    m_hierarchy.createHierarchyFrom(o);
  }
}","@Override public void onChanged(Change<? extends EventTarget> c){
  c.next();
  List<? extends EventTarget> changedObjects=c.getRemoved();
  for (  EventTarget o : changedObjects) {
    m_hierarchy.removeComponentFromHierarchy(o);
  }
  List<? extends EventTarget> list=c.getList();
  int size=list.size();
  if (c.wasAdded() && c.getTo() > size) {
    changedObjects=list.subList(c.getFrom(),size);
  }
 else {
    changedObjects=c.getAddedSubList();
  }
  for (  EventTarget o : changedObjects) {
    m_hierarchy.createHierarchyFrom(o);
  }
}",0.7977900552486188
95444,"/** 
 * Method to get the single instance of this class.
 * @throws ConnectionException if an error occurs during initialization.
 * @return the instance of this Singleton
 */
public static synchronized AUTConnection getInstance() throws ConnectionException {
  if (instance == null) {
    instance=new AUTConnection();
  }
  return instance;
}","/** 
 * Method to get the single instance of this class.
 * @throws ConnectionException if an error occurs during initialization.
 * @return the instance of this Singleton
 */
public static synchronized AUTConnection getInstance() throws ConnectionException {
  if (instance == null) {
    instance=new AUTConnection(0);
  }
  return instance;
}",0.9985486211901308
95445,"/** 
 * private constructor. creates a communicator
 * @throws ConnectionException containing a detailed message why the connection could not initialized
 */
private AUTConnection() throws ConnectionException {
  super();
}","/** 
 * private constructor. creates a communicator
 * @param port the port or 0 if automatically a port should be assigned
 * @throws ConnectionException containing a detailed message why the connection could not initialized
 */
private AUTConnection(int port) throws ConnectionException {
  super(port);
}",0.8415094339622642
95446,"/** 
 * @param fWriter where the test result will be wrote 
 * @throws IOException
 * @throws PMException
 * @throws OperationCanceledException 
 */
public void writeTestResultSummariesToFile(FileWriterWithEncoding fWriter) throws IOException, PMException, OperationCanceledException {
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_EMPTY);
  fWriter.append(StringConstants.LEFT_BRACKET);
  float size=TestResultSummaryPM.countOfTestResultSummaries(m_project,null);
  long lastPage=(long)Math.ceil(size / ImportExportUtil.PAGE_SIZE);
  int pos=0;
  for (int countOfPage=1; countOfPage <= lastPage; countOfPage++) {
    ImportExportUtil.checkCancel(m_monitor);
    List<ITestResultSummaryPO> summaries=TestResultSummaryPM.getTestResultSummaries(m_project,null,countOfPage,ImportExportUtil.PAGE_SIZE);
    List<TestresultSummaryDTO> summaryDTOs=getTestResultSummaryDTOs(summaries);
    for (int countOfItemInPage=0; countOfItemInPage < summaryDTOs.size(); countOfItemInPage++) {
      pos++;
      TestresultSummaryDTO dto=summaryDTOs.get(countOfItemInPage);
      StringBuffer buffer=new StringBuffer();
      buffer.append(mapper.writeValueAsString(dto));
      if (!(countOfPage == lastPage && countOfItemInPage == summaryDTOs.size() - 1)) {
        buffer.append(StringConstants.COMMA);
      }
      fWriter.append(buffer);
      m_monitor.worked(1);
    }
    m_monitor.subTask(Messages.ImportJsonImportResult + pos + StringConstants.SLASH+ (int)size);
  }
  fWriter.append(StringConstants.RIGHT_BRACKET);
  fWriter.close();
}","/** 
 * @param fWriter where the test result will be wrote 
 * @throws IOException
 * @throws PMException
 * @throws OperationCanceledException 
 */
public void writeTestResultSummariesToFile(FileWriterWithEncoding fWriter) throws IOException, PMException, OperationCanceledException {
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_NULL);
  fWriter.append(StringConstants.LEFT_BRACKET);
  float size=TestResultSummaryPM.countOfTestResultSummaries(m_project,null);
  long lastPage=(long)Math.ceil(size / ImportExportUtil.PAGE_SIZE);
  int pos=0;
  for (int countOfPage=1; countOfPage <= lastPage; countOfPage++) {
    ImportExportUtil.checkCancel(m_monitor);
    List<ITestResultSummaryPO> summaries=TestResultSummaryPM.getTestResultSummaries(m_project,null,countOfPage,ImportExportUtil.PAGE_SIZE);
    List<TestresultSummaryDTO> summaryDTOs=getTestResultSummaryDTOs(summaries);
    for (int countOfItemInPage=0; countOfItemInPage < summaryDTOs.size(); countOfItemInPage++) {
      pos++;
      TestresultSummaryDTO dto=summaryDTOs.get(countOfItemInPage);
      StringBuffer buffer=new StringBuffer();
      buffer.append(mapper.writeValueAsString(dto));
      if (!(countOfPage == lastPage && countOfItemInPage == summaryDTOs.size() - 1)) {
        buffer.append(StringConstants.COMMA);
      }
      fWriter.append(buffer);
      m_monitor.worked(1);
    }
    m_monitor.subTask(Messages.ImportJsonImportResult + pos + StringConstants.SLASH+ (int)size);
  }
  fWriter.append(StringConstants.RIGHT_BRACKET);
  fWriter.close();
}",0.9971364937957364
95447,"/** 
 * Save a project as JUB witch contains an info file about exportation, a project file and a result file
 * @param proj original project object
 * @param monitor loader monitor
 * @param fileName Jubula file name
 * @param includeTestResultSummaries true if project contain test result summaries
 * @throws ProjectDeletedException
 * @throws PMException
 * @throws IOException
 * @throws InterruptedException 
 */
private static void writeToFile(IProjectPO proj,IProgressMonitor monitor,String fileName,boolean includeTestResultSummaries) throws ProjectDeletedException, PMException, IOException {
  String dir=Files.createTempDirectory(TMP_EXCHANGE_FOLDER_NAME).toString() + File.separatorChar;
  String infoFileName=dir + NFO;
  String projectFileName=dir + PJT;
  String testResultFileName=dir + RST;
  ArrayList<String> fileList=new ArrayList<String>();
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_EMPTY);
  ExportInfoDTO exportDTO=new ExportInfoDTO();
  exportDTO.setQualifier(ImportExportUtil.DATE_FORMATTER.format(new Date()));
  exportDTO.setEncoding(StandardCharsets.UTF_8.name());
  exportDTO.setVersion(JsonVersion.CURRENTLY_JSON_VERSION);
  try (FileWriterWithEncoding infoWriter=new FileWriterWithEncoding(infoFileName,StandardCharsets.UTF_8);FileWriterWithEncoding projectWriter=new FileWriterWithEncoding(projectFileName,StandardCharsets.UTF_8);FileWriterWithEncoding resultWriter=new FileWriterWithEncoding(testResultFileName,StandardCharsets.UTF_8)){
    mapper.writeValue(infoWriter,exportDTO);
    fileList.add(infoFileName);
    JsonExporter exporter=new JsonExporter(proj,monitor);
    ProjectDTO projectDTO=exporter.getProjectDTO();
    mapper.writeValue(projectWriter,projectDTO);
    fileList.add(projectFileName);
    if (includeTestResultSummaries) {
      exporter.writeTestResultSummariesToFile(resultWriter);
      fileList.add(testResultFileName);
    }
    monitor.subTask(Messages.ImportJsonStorageCompress);
    zipIt(fileName,fileList);
  }
 catch (  Exception e) {
    fileList.add(fileName);
    throw e;
  }
 finally {
    fileList.add(dir);
    deleteFiles(fileList);
  }
}","/** 
 * Save a project as JUB witch contains an info file about exportation, a project file and a result file
 * @param proj original project object
 * @param monitor loader monitor
 * @param fileName Jubula file name
 * @param includeTestResultSummaries true if project contain test result summaries
 * @throws ProjectDeletedException
 * @throws PMException
 * @throws IOException
 * @throws InterruptedException 
 */
private static void writeToFile(IProjectPO proj,IProgressMonitor monitor,String fileName,boolean includeTestResultSummaries) throws ProjectDeletedException, PMException, IOException {
  String dir=Files.createTempDirectory(TMP_EXCHANGE_FOLDER_NAME).toString() + File.separatorChar;
  String infoFileName=dir + NFO;
  String projectFileName=dir + PJT;
  String testResultFileName=dir + RST;
  ArrayList<String> fileList=new ArrayList<String>();
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_NULL);
  ExportInfoDTO exportDTO=new ExportInfoDTO();
  exportDTO.setQualifier(ImportExportUtil.DATE_FORMATTER.format(new Date()));
  exportDTO.setEncoding(StandardCharsets.UTF_8.name());
  exportDTO.setVersion(JsonVersion.CURRENTLY_JSON_VERSION);
  try (FileWriterWithEncoding infoWriter=new FileWriterWithEncoding(infoFileName,StandardCharsets.UTF_8);FileWriterWithEncoding projectWriter=new FileWriterWithEncoding(projectFileName,StandardCharsets.UTF_8);FileWriterWithEncoding resultWriter=new FileWriterWithEncoding(testResultFileName,StandardCharsets.UTF_8)){
    mapper.writeValue(infoWriter,exportDTO);
    fileList.add(infoFileName);
    JsonExporter exporter=new JsonExporter(proj,monitor);
    ProjectDTO projectDTO=exporter.getProjectDTO();
    mapper.writeValue(projectWriter,projectDTO);
    fileList.add(projectFileName);
    if (includeTestResultSummaries) {
      exporter.writeTestResultSummariesToFile(resultWriter);
      fileList.add(testResultFileName);
    }
    monitor.subTask(Messages.ImportJsonStorageCompress);
    zipIt(fileName,fileList);
  }
 catch (  Exception e) {
    fileList.add(fileName);
    throw e;
  }
 finally {
    fileList.add(dir);
    deleteFiles(fileList);
  }
}",0.9979171488081464
95448,"/** 
 * {@inheritDoc}
 */
@Override public void rcDragByIndexPath(int mouseButton,String modifier,String pathType,int preAscend,String treeIndexPath){
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
  super.rcDragByIndexPath(mouseButton,modifier,pathType,preAscend,treeIndexPath);
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
}","/** 
 * {@inheritDoc}
 */
@Override public void rcDragByIndexPath(int mouseButton,String modifier,String pathType,int preAscend,String treeIndexPath){
  postMouseMovementEvent();
  super.rcDragByIndexPath(mouseButton,modifier,pathType,preAscend,treeIndexPath);
  postMouseMovementEvent();
}",0.5124223602484472
95449,"/** 
 * {@inheritDoc}
 */
@Override public void rcDragByTextPath(int mouseButton,String modifier,String pathType,int preAscend,String treeTextPath,String operator){
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
  super.rcDragByTextPath(mouseButton,modifier,pathType,preAscend,treeTextPath,operator);
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
}","/** 
 * {@inheritDoc}
 */
@Override public void rcDragByTextPath(int mouseButton,String modifier,String pathType,int preAscend,String treeTextPath,String operator){
  postMouseMovementEvent();
  super.rcDragByTextPath(mouseButton,modifier,pathType,preAscend,treeTextPath,operator);
  postMouseMovementEvent();
}",0.5160349854227405
95450,"/** 
 * {@inheritDoc}
 */
@Override public void rcDropByIndexPath(final String pathType,final int preAscend,final String indexPath,int delayBeforeDrop){
  Event wakeEvent=new Event();
  wakeEvent.type=SWT.MouseMove;
  getTreeTable().getDisplay().post(wakeEvent);
  waitForDisplayUpdate();
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
  super.rcDropByIndexPath(pathType,preAscend,indexPath,delayBeforeDrop);
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
}","/** 
 * {@inheritDoc}
 */
@Override public void rcDropByIndexPath(final String pathType,final int preAscend,final String indexPath,int delayBeforeDrop){
  postMouseMovementEvent();
  super.rcDropByIndexPath(pathType,preAscend,indexPath,delayBeforeDrop);
  postMouseMovementEvent();
}",0.443864229765013
95451,"/** 
 * {@inheritDoc}
 */
@Override public void rcDropByTextPath(final String pathType,final int preAscend,final String treePath,final String operator,int delayBeforeDrop){
  Event wakeEvent=new Event();
  wakeEvent.type=SWT.MouseMove;
  getTreeTable().getDisplay().post(wakeEvent);
  waitForDisplayUpdate();
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
  super.rcDropByTextPath(pathType,preAscend,treePath,operator,delayBeforeDrop);
  SwtUtils.waitForDisplayIdle(getTreeTable().getDisplay());
}","/** 
 * {@inheritDoc}
 */
@Override public void rcDropByTextPath(final String pathType,final int preAscend,final String treePath,final String operator,int delayBeforeDrop){
  postMouseMovementEvent();
  super.rcDropByTextPath(pathType,preAscend,treePath,operator,delayBeforeDrop);
  postMouseMovementEvent();
}",0.4853658536585366
95452,"/** 
 * @param widget a Widget
 * @return the Shell of the given Widget or null if no Shell was found
 * @see Control#getShell();
 */
public static Shell getShell(Widget widget){
  Widget wdgt=widget;
  while (!(wdgt instanceof Control) && wdgt != null) {
    wdgt=getWidgetParent(wdgt);
  }
  if (wdgt != null) {
    return ((Control)wdgt).getShell();
  }
  return null;
}","/** 
 * @param widget a Widget
 * @return the Shell of the given Widget or null if no Shell was found
 * @see Control#getShell();
 */
public static Shell getShell(Widget widget){
  Widget wdgt=widget;
  while (!(wdgt instanceof Control) && wdgt != null) {
    wdgt=getWidgetParent(wdgt);
  }
  if (wdgt != null && !wdgt.isDisposed()) {
    return ((Control)wdgt).getShell();
  }
  return null;
}",0.9713541666666666
95453,"public Rectangle run() throws StepExecutionException {
  return SwtUtils.getWidgetBounds(component);
}","public Void run() throws StepExecutionException {
  final int mouseShakeOffset=10;
  java.awt.Point origin=AUTServer.getInstance().getRobot().getCurrentMousePosition();
  SwtRobot lowLevelRobot=new SwtRobot(Display.getDefault());
  lowLevelRobot.mouseMove(origin.x + mouseShakeOffset,origin.y + mouseShakeOffset);
  lowLevelRobot.mouseMove(origin.x - mouseShakeOffset,origin.y - mouseShakeOffset);
  lowLevelRobot.mouseMove(origin.x,origin.y);
  if (!EnvironmentUtils.isWindowsOS() && !EnvironmentUtils.isMacOS()) {
    boolean moreEvents=true;
    while (moreEvents) {
      moreEvents=Display.getDefault().readAndDispatch();
    }
  }
  return null;
}",0.1456953642384106
95454,"/** 
 * {@inheritDoc}
 */
public void shakeMouse(){
  final int mouseShakeOffset=10;
  java.awt.Point origin=AUTServer.getInstance().getRobot().getCurrentMousePosition();
  SwtRobot lowLevelRobot=new SwtRobot(Display.getDefault());
  lowLevelRobot.mouseMove(origin.x + mouseShakeOffset,origin.y + mouseShakeOffset);
  lowLevelRobot.mouseMove(origin.x - mouseShakeOffset,origin.y - mouseShakeOffset);
  lowLevelRobot.mouseMove(origin.x,origin.y);
  if (!EnvironmentUtils.isWindowsOS() && !EnvironmentUtils.isMacOS()) {
    boolean moreEvents=true;
    while (moreEvents) {
      moreEvents=Display.getDefault().readAndDispatch();
    }
  }
}","/** 
 * {@inheritDoc}
 */
public void shakeMouse(){
  m_queuer.invokeAndWait(""String_Node_Str"",new IRunnable<Void>(){
    public Void run() throws StepExecutionException {
      final int mouseShakeOffset=10;
      java.awt.Point origin=AUTServer.getInstance().getRobot().getCurrentMousePosition();
      SwtRobot lowLevelRobot=new SwtRobot(Display.getDefault());
      lowLevelRobot.mouseMove(origin.x + mouseShakeOffset,origin.y + mouseShakeOffset);
      lowLevelRobot.mouseMove(origin.x - mouseShakeOffset,origin.y - mouseShakeOffset);
      lowLevelRobot.mouseMove(origin.x,origin.y);
      if (!EnvironmentUtils.isWindowsOS() && !EnvironmentUtils.isMacOS()) {
        boolean moreEvents=true;
        while (moreEvents) {
          moreEvents=Display.getDefault().readAndDispatch();
        }
      }
      return null;
    }
  }
);
}",0.8648648648648649
95455,"/** 
 * @param node the currently selected node: we insert below this or at the end of the branch
 * @param exp whether node is expanded
 * @return the position to add
 */
public static NodeTarget getPositionToInsert(INodePO node,boolean exp){
  if (Plugin.getDefault().getPreferenceStore().getBoolean(Constants.NODE_INSERT_KEY)) {
    return NodeTargetCalculator.calcNodeTarget(null,node,ViewerDropAdapter.LOCATION_AFTER,exp);
  }
  if (node instanceof IAbstractContainerPO || node instanceof ISpecTestCasePO) {
    return new NodeTarget(node.getNodeListSize(),node);
  }
  if (node.getParentNode() != null) {
    return new NodeTarget(node.getParentNode().getNodeListSize(),node.getParentNode());
  }
  return null;
}","/** 
 * @param node the currently selected node: we insert below this or at the end of the branch
 * @param exp whether node is expanded
 * @return the position to add
 */
public static NodeTarget getPositionToInsert(INodePO node,boolean exp){
  if (Plugin.getDefault().getPreferenceStore().getBoolean(Constants.NODE_INSERT_KEY)) {
    return NodeTargetCalculator.calcNodeTarget(null,node,ViewerDropAdapter.LOCATION_AFTER,exp);
  }
  if (node instanceof IAbstractContainerPO || node instanceof ISpecTestCasePO || node instanceof ITestSuitePO) {
    return new NodeTarget(node.getNodeListSize(),node);
  }
  if (node.getParentNode() != null) {
    return new NodeTarget(node.getParentNode().getNodeListSize(),node.getParentNode());
  }
  return null;
}",0.9782312925170068
95456,"/** 
 * {@inheritDoc}
 */
public void startAut(IAUTMainPO aut,IAUTConfigPO conf) throws ToolkitPluginException {
  final String autToolkit=aut.getToolkit();
  if (!ComponentBuilder.getInstance().getLevelToolkitIds().contains(autToolkit) && ToolkitConstants.LEVEL_TOOLKIT.equals(ToolkitSupportBP.getToolkitLevel(autToolkit))) {
    throw new ToolkitPluginException(Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE);
  }
  try {
    Map<String,String> autConfigMap=createAutConfigMap(conf);
    autConfigMap.put(AutConfigConstants.NAME_TECHNICAL_COMPONENTS,String.valueOf(aut.isGenerateNames()));
    StartAUTServerMessage startAUTServerMessage=new StartAUTServerMessage(autConfigMap,autToolkit);
    AutAgentConnection.getInstance().send(startAUTServerMessage);
    if (log.isDebugEnabled()) {
      log.debug(Messages.StartAUTServerMessageSend);
    }
  }
 catch (  NotConnectedException nce) {
    log.info(nce.getLocalizedMessage(),nce);
  }
catch (  ConnectionException ce) {
    log.info(ce.getLocalizedMessage(),ce);
  }
catch (  CommunicationException cce) {
    log.error(cce.getLocalizedMessage(),cce);
    try {
      closeConnections();
    }
 catch (    ConnectionException ce) {
      log.error(Messages.ClosingTheConnectionsFailed,ce);
    }
  }
}","/** 
 * {@inheritDoc}
 */
public void startAut(IAUTMainPO aut,IAUTConfigPO conf) throws ToolkitPluginException {
  final String autToolkit=aut.getToolkit();
  if (!ComponentBuilder.getInstance().getLevelToolkitIds().contains(autToolkit) && ToolkitConstants.LEVEL_TOOLKIT.equals(ToolkitSupportBP.getToolkitLevel(autToolkit))) {
    throw new ToolkitPluginException(Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE);
  }
  try {
    Map<String,String> autConfigMap=createAutConfigMap(conf);
    autConfigMap.put(AutConfigConstants.NAME_TECHNICAL_COMPONENTS,String.valueOf(aut.isGenerateNames()));
    if (!aut.getPropertyMap().isEmpty()) {
      String currentEnv=StringUtils.defaultIfEmpty(autConfigMap.get(AutConfigConstants.ENVIRONMENT),StringConstants.EMPTY);
      for (      String autProp : aut.getPropertyMap().keySet()) {
        String property=EnvironmentUtils.toPropertyString(autProp,aut.getPropertyMap().get(autProp));
        currentEnv=currentEnv.concat(System.lineSeparator() + property);
      }
      autConfigMap.put(AutConfigConstants.ENVIRONMENT,currentEnv);
    }
    StartAUTServerMessage startAUTServerMessage=new StartAUTServerMessage(autConfigMap,autToolkit);
    AutAgentConnection.getInstance().send(startAUTServerMessage);
    if (log.isDebugEnabled()) {
      log.debug(Messages.StartAUTServerMessageSend);
    }
  }
 catch (  NotConnectedException nce) {
    log.info(nce.getLocalizedMessage(),nce);
  }
catch (  ConnectionException ce) {
    log.info(ce.getLocalizedMessage(),ce);
  }
catch (  CommunicationException cce) {
    log.error(cce.getLocalizedMessage(),cce);
    try {
      closeConnections();
    }
 catch (    ConnectionException ce) {
      log.error(Messages.ClosingTheConnectionsFailed,ce);
    }
  }
}",0.8369926813040586
95457,"/** 
 * Verifies the text of the cell under the mouse
 * @param txt the text
 * @param operator the operator
 */
public void rcVerifyCellTextAtMousePosition(String txt,String operator){
  String result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      TreeTableCell<?,?> cell=(TreeTableCell<?,?>)getNodeAtMousePosition();
      return getContext().getRenderedText(cell);
    }
  }
);
  Verifier.match(result,txt,operator);
}","/** 
 * Verifies the text of the cell under the mouse
 * @param txt the text
 * @param operator the operator
 * @param timeout the timeout for the check
 */
public void rcVerifyCellTextAtMousePosition(String txt,String operator,int timeout){
  invokeAndWait(""String_Node_Str"",timeout,new Runnable(){
    @Override public void run(){
      TreeTableCell<?,?> cell=(TreeTableCell<?,?>)getNodeAtMousePosition();
      String result=getContext().getRenderedText(cell);
      Verifier.match(result,txt,operator);
    }
  }
);
}",0.7442307692307693
95458,"/** 
 * @param object the object to introspect
 * @param propertyName the properties name to retrieve
 * @return the property or <code>null</code> if not found
 * @throws RobotException in case of problems
 */
@SuppressWarnings(""String_Node_Str"") public static String getPropertyValue(Object object,String propertyName) throws RobotException {
  String propertyValue=StringConstants.EMPTY;
  Validate.notNull(object,""String_Node_Str"");
  try {
    ArrayList<String> path=new ArrayList<String>(Arrays.asList(propertyName.split(StringConstants.SLASH)));
    final Object prop;
    if (path.size() > 0) {
      prop=getPropertyByPathOrMethod(object,path,0);
    }
 else {
      prop=null;
    }
    if (prop != null) {
      IPropertyValue propertyValueAdapter=((IPropertyValue)AdapterFactoryRegistry.getInstance().getAdapter(IPropertyValue.class,prop));
      if (propertyValueAdapter != null) {
        propertyValue=propertyValueAdapter.getStringRepresentation(prop);
      }
 else {
        propertyValue=String.valueOf(prop);
      }
    }
  }
 catch (  IllegalAccessException e) {
    throw new RobotException(e);
  }
catch (  InvocationTargetException e) {
    throw new RobotException(e);
  }
catch (  NoSuchMethodException e) {
    throw new RobotException(e);
  }
  if (StringUtils.containsAny(propertyValue,INVALID_XML_CHARS)) {
    for (    Character c : INVALID_XML_CHARS) {
      propertyValue=StringUtils.remove(propertyValue,c);
    }
  }
  return propertyValue;
}","/** 
 * @param object the object to introspect
 * @param propertyName the properties name to retrieve
 * @return the property or <code>null</code> if not found
 * @throws RobotException in case of problems
 */
@SuppressWarnings(""String_Node_Str"") public static String getPropertyValue(Object object,String propertyName) throws RobotException {
  String propertyValue=StringConstants.EMPTY;
  Validate.notNull(object,""String_Node_Str"");
  try {
    ArrayList<String> path=new ArrayList<String>(Arrays.asList(propertyName.split(StringConstants.SLASH)));
    final Object prop;
    if (path.size() > 0) {
      prop=getPropertyByPathOrMethod(object,path,0);
    }
 else {
      prop=null;
    }
    if (prop != null) {
      IPropertyValue propertyValueAdapter=((IPropertyValue)AdapterFactoryRegistry.getInstance().getAdapter(IPropertyValue.class,prop));
      if (propertyValueAdapter != null) {
        propertyValue=propertyValueAdapter.getStringRepresentation(prop);
      }
 else {
        propertyValue=String.valueOf(prop);
      }
    }
 else {
      propertyValue=String.valueOf(prop);
    }
  }
 catch (  IllegalAccessException e) {
    throw new RobotException(e);
  }
catch (  InvocationTargetException e) {
    throw new RobotException(e);
  }
catch (  NoSuchMethodException e) {
    throw new RobotException(e);
  }
  if (StringUtils.containsAny(propertyValue,INVALID_XML_CHARS)) {
    for (    Character c : INVALID_XML_CHARS) {
      propertyValue=StringUtils.remove(propertyValue,c);
    }
  }
  return propertyValue;
}",0.9813953488372092
95459,"/** 
 * Verifies the text of the cell under the mouse
 * @param txt the text
 * @param operator the operator
 */
public void rcVerifyCellTextAtMousePosition(String txt,String operator){
  String result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      TreeTableCell<?,?> cell=(TreeTableCell<?,?>)getNodeAtMousePosition();
      return getContext().getRenderedText(cell);
    }
  }
);
  Verifier.match(result,txt,operator);
}","/** 
 * Verifies the text of the cell under the mouse
 * @param txt the text
 * @param operator the operator
 * @param timeout the timeout for the check
 */
public void rcVerifyCellTextAtMousePosition(String txt,String operator,int timeout){
  invokeAndWait(""String_Node_Str"",timeout,new Runnable(){
    @Override public void run(){
      TreeTableCell<?,?> cell=(TreeTableCell<?,?>)getNodeAtMousePosition();
      String result=getContext().getRenderedText(cell);
      Verifier.match(result,txt,operator);
    }
  }
);
}",0.7442307692307693
95460,"/** 
 * {@inheritDoc}
 */
public String getText(){
  String comboBoxText;
  if (isEditable()) {
    comboBoxText=TesterUtil.getRenderedText(getComboBoxEditorComponent(m_comboBox),true);
  }
 else {
    final int selIndex=getSelectedIndex();
    if (selIndex == -1) {
      comboBoxText=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<String>(){
        public String run(){
          return String.valueOf(m_comboBox.getSelectedItem());
        }
      }
);
    }
 else {
      final JList jlist=new JList(m_comboBox.getModel());
      String o=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<String>(){
        public String run(){
          Component disp=m_comboBox.getRenderer().getListCellRendererComponent(jlist,jlist.getModel().getElementAt(selIndex),selIndex,true,m_comboBox.hasFocus());
          return TesterUtil.getRenderedText(disp,false);
        }
      }
);
      comboBoxText=String.valueOf(o);
    }
  }
  return comboBoxText;
}","/** 
 * {@inheritDoc}
 */
public String getText(){
  String comboBoxText;
  if (isEditable()) {
    comboBoxText=TesterUtil.getRenderedText(getComboBoxEditorComponent(m_comboBox),true);
  }
 else {
    final int selIndex=getSelectedIndex();
    if (selIndex == -1) {
      try {
        comboBoxText=getTextForSelectedItem();
      }
 catch (      Exception e) {
        comboBoxText=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<String>(){
          public String run(){
            return String.valueOf(m_comboBox.getSelectedItem());
          }
        }
);
      }
    }
 else {
      final JList jlist=new JList(m_comboBox.getModel());
      String o=getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<String>(){
        public String run(){
          Component disp=m_comboBox.getRenderer().getListCellRendererComponent(jlist,jlist.getModel().getElementAt(selIndex),selIndex,true,m_comboBox.hasFocus());
          return TesterUtil.getRenderedText(disp,false);
        }
      }
);
      comboBoxText=String.valueOf(o);
    }
  }
  return comboBoxText;
}",0.9454545454545454
95461,"/** 
 */
private void initErrorEventPropDescriptor(){
  PropertyDescriptor propDes=new PropertyDescriptor(new PropertyController(){
    public Object getProperty(){
      return I18n.getString(m_node.getEvent().getId());
    }
  }
,P_ELEMENT_DISPLAY_ERRORTYPE);
  propDes.setCategory(P_TESTERROR_CAT);
  addPropertyDescriptor(propDes);
  final TestErrorEvent event=m_node.getEvent();
  if (event.getId().equals(TestErrorEvent.ID.VERIFY_FAILED)) {
    Set keys=event.getProps().keySet();
    for (    final Object key : keys) {
      propDes=new PropertyDescriptor(new PropertyController(){
        public Object getProperty(){
          return event.getProps().get(key);
        }
      }
,I18n.getString((String)key));
      propDes.setCategory(P_TESTERROR_CAT);
      addPropertyDescriptor(propDes);
    }
  }
 else   if (event.getProps().keySet().contains(TestErrorEvent.Property.DESCRIPTION_KEY)) {
    propDes=new PropertyDescriptor(new PropertyController(){
      public Object getProperty(){
        String key=(String)event.getProps().get(TestErrorEvent.Property.DESCRIPTION_KEY);
        Object[] args=(Object[])event.getProps().get(TestErrorEvent.Property.PARAMETER_KEY);
        if (args != null) {
          return I18n.getString(key,args);
        }
        return I18n.getString(key,true);
      }
    }
,I18n.getString(TestErrorEvent.Property.DESCRIPTION_KEY));
    propDes.setCategory(P_TESTERROR_CAT);
    addPropertyDescriptor(propDes);
  }
}","/** 
 */
private void initErrorEventPropDescriptor(){
  PropertyDescriptor propDes=new PropertyDescriptor(new PropertyController(){
    public Object getProperty(){
      return I18n.getString(m_node.getEvent().getId());
    }
  }
,P_ELEMENT_DISPLAY_ERRORTYPE);
  propDes.setCategory(P_TESTERROR_CAT);
  addPropertyDescriptor(propDes);
  final TestErrorEvent event=m_node.getEvent();
  if (event.getId().equals(TestErrorEvent.ID.VERIFY_FAILED)) {
    Set keys=event.getProps().keySet();
    for (    final Object key : keys) {
      propDes=new PropertyDescriptor(new PropertyController(){
        public Object getProperty(){
          return event.getProps().get(key);
        }
      }
,I18n.getString((String)key));
      propDes.setCategory(P_TESTERROR_CAT);
      addPropertyDescriptor(propDes);
    }
  }
 else   if (event.getProps().keySet().contains(TestErrorEvent.Property.DESCRIPTION_KEY)) {
    propDes=new PropertyDescriptor(new PropertyController(){
      public Object getProperty(){
        String key=(String)event.getProps().get(TestErrorEvent.Property.DESCRIPTION_KEY);
        Object[] args=(Object[])event.getProps().get(TestErrorEvent.Property.PARAMETER_KEY);
        if (args != null) {
          return I18n.getStringWithoutErrorReport(key,args);
        }
        return I18n.getStringWithoutErrorReport(key,true);
      }
    }
,I18n.getString(TestErrorEvent.Property.DESCRIPTION_KEY));
    propDes.setCategory(P_TESTERROR_CAT);
    addPropertyDescriptor(propDes);
  }
}",0.9878213802435724
95462,"/** 
 * @param sourceViewer The viewer containing the dragged/cut item.
 * @param targetViewer The viewer to which the item is to be dropped/pasted.
 * @param toDrop The items that were dragged/cut.
 * @param dropTarget The drop/paste target.
 * @param allowFromBrowser Whether items from the Test Case Browser are allowed to be dropped/pasted.
 * @return <code>true</code> if the given information indicates that thedrop/paste is valid. Otherwise <code>false</code>.
 */
public static boolean validateDrop(Viewer sourceViewer,Viewer targetViewer,IStructuredSelection toDrop,INodePO dropTarget,boolean allowFromBrowser){
  if (toDrop == null || toDrop.isEmpty() || dropTarget == null) {
    return false;
  }
  if (sourceViewer != null && !sourceViewer.equals(targetViewer)) {
    boolean foundOne=false;
    for (    TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
      if (sourceViewer.equals(tcb.getTreeViewer())) {
        foundOne=true;
      }
    }
    if (!(allowFromBrowser && foundOne)) {
      return false;
    }
  }
  Iterator iter=toDrop.iterator();
  INodePO par=null;
  while (iter.hasNext()) {
    Object obj=iter.next();
    if (!(obj instanceof INodePO) || obj instanceof IAbstractContainerPO) {
      return false;
    }
    if (obj instanceof IControllerPO && !(dropTarget instanceof ISpecTestCasePO) && !(dropTarget.getParentNode() instanceof ISpecTestCasePO)) {
      return false;
    }
    INodePO transferGUI=(INodePO)obj;
    INodePO parentNode=transferGUI.getParentNode();
    if (par != null && par != parentNode) {
      return false;
    }
    par=parentNode;
    if (!(transferGUI instanceof ISpecTestCasePO) && transferGUI.getSpecAncestor() != dropTarget.getSpecAncestor()) {
      return false;
    }
    if (!(transferGUI instanceof ISpecTestCasePO)) {
      continue;
    }
    ISpecTestCasePO specTcGUI=(ISpecTestCasePO)dropTarget.getSpecAncestor();
    if (transferGUI.hasCircularDependences(specTcGUI)) {
      return false;
    }
  }
  return true;
}","/** 
 * @param sourceViewer The viewer containing the dragged/cut item.
 * @param targetViewer The viewer to which the item is to be dropped/pasted.
 * @param toDrop The items that were dragged/cut.
 * @param dropTarget The drop/paste target.
 * @param allowFromBrowser Whether items from the Test Case Browser are allowed to be dropped/pasted.
 * @return <code>true</code> if the given information indicates that thedrop/paste is valid. Otherwise <code>false</code>.
 */
public static boolean validateDrop(Viewer sourceViewer,Viewer targetViewer,IStructuredSelection toDrop,INodePO dropTarget,boolean allowFromBrowser){
  if (toDrop == null || toDrop.isEmpty() || dropTarget == null) {
    return false;
  }
  if (sourceViewer != null && !sourceViewer.equals(targetViewer)) {
    boolean foundOne=false;
    for (    TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
      if (sourceViewer.equals(tcb.getTreeViewer())) {
        foundOne=true;
      }
    }
    if (!(allowFromBrowser && foundOne)) {
      return false;
    }
  }
  Iterator iter=toDrop.iterator();
  while (iter.hasNext()) {
    Object obj=iter.next();
    if (!(obj instanceof INodePO) || obj instanceof IAbstractContainerPO) {
      return false;
    }
    if (obj instanceof IControllerPO && !(dropTarget instanceof ISpecTestCasePO) && !(dropTarget.getParentNode() instanceof ISpecTestCasePO)) {
      return false;
    }
    INodePO transferGUI=(INodePO)obj;
    if (!(transferGUI instanceof ISpecTestCasePO) && transferGUI.getSpecAncestor() != dropTarget.getSpecAncestor()) {
      return false;
    }
    if (!(transferGUI instanceof ISpecTestCasePO)) {
      continue;
    }
    ISpecTestCasePO specTcGUI=(ISpecTestCasePO)dropTarget.getSpecAncestor();
    if (transferGUI.hasCircularDependences(specTcGUI)) {
      return false;
    }
  }
  return true;
}",0.8345398138572906
95463,"/** 
 * Checks whether the nodes in the given selection can legally be moved to the given target location.
 * @param sourceViewer The viewer containing the dragged/cut item.
 * @param targetViewer The viewer to which the item is to be dropped/pasted.
 * @param selection The selection to check.
 * @param target The target location to check.
 * @param allowFromBrowser Whether items from the Test Case Browser are allowed to be dropped/pasted.
 * @return <code>true</code> if the move is legal. Otherwise, <code>false</code>.
 */
public static boolean validateDrop(Viewer sourceViewer,Viewer targetViewer,IStructuredSelection selection,Object target,boolean allowFromBrowser){
  if (selection == null || target == null) {
    return false;
  }
  if (sourceViewer != null && !sourceViewer.equals(targetViewer)) {
    boolean foundOne=false;
    for (    TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
      if (sourceViewer.equals(tcb.getTreeViewer())) {
        foundOne=true;
      }
    }
    if (!(allowFromBrowser && foundOne)) {
      return false;
    }
  }
  Iterator iter=selection.iterator();
  while (iter.hasNext()) {
    Object transferObj=iter.next();
    if (!(transferObj instanceof INodePO)) {
      return false;
    }
    INodePO transferGUI=(INodePO)transferObj;
    if (!((transferGUI instanceof IExecTestCasePO && sourceViewer == targetViewer) || (transferGUI instanceof ICommentPO && sourceViewer == targetViewer) || (transferGUI instanceof ISpecTestCasePO))) {
      return false;
    }
  }
  return true;
}","/** 
 * Checks whether the nodes in the given selection can legally be moved to the given target location.
 * @param sourceViewer The viewer containing the dragged/cut item.
 * @param targetViewer The viewer to which the item is to be dropped/pasted.
 * @param selection The selection to check.
 * @param target The target location to check.
 * @param allowFromBrowser Whether items from the Test Case Browser are allowed to be dropped/pasted.
 * @return <code>true</code> if the move is legal. Otherwise, <code>false</code>.
 */
public static boolean validateDrop(Viewer sourceViewer,Viewer targetViewer,IStructuredSelection selection,Object target,boolean allowFromBrowser){
  if (selection == null || !(target instanceof INodePO)) {
    return false;
  }
  INodePO targNode=(INodePO)target;
  if (sourceViewer != null && !sourceViewer.equals(targetViewer)) {
    boolean foundOne=false;
    for (    TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
      if (sourceViewer.equals(tcb.getTreeViewer())) {
        foundOne=true;
      }
    }
    if (!(allowFromBrowser && foundOne)) {
      return false;
    }
  }
  Iterator iter=selection.iterator();
  while (iter.hasNext()) {
    Object next=iter.next();
    if (!(next instanceof INodePO) || next instanceof IAbstractContainerPO) {
      return false;
    }
    if (next instanceof IControllerPO && !(targNode instanceof ITestSuitePO) && !(targNode.getParentNode() instanceof ITestSuitePO)) {
      return false;
    }
    INodePO node=(INodePO)next;
    if (!((node instanceof IExecTestCasePO && sourceViewer == targetViewer) || (node instanceof ICommentPO && sourceViewer == targetViewer) || (node instanceof ISpecTestCasePO)|| (node instanceof IControllerPO))) {
      return false;
    }
  }
  return true;
}",0.8613269575612672
95464,"/** 
 * @param element the element to get the text for 
 * @return a descriptive text for the given element
 */
public static String getTextImpl(Object element){
  if (element instanceof INodePO) {
    String prefix=StringConstants.EMPTY;
    String name=null;
    INodePO node=(INodePO)element;
    if (!checkActivation((INodePO)element)) {
      prefix=INACTIVE_PREFIX;
    }
    if (node instanceof IRefTestSuitePO) {
      name=NodeNameUtil.getText((IRefTestSuitePO)node);
    }
 else     if (node.getName() == null) {
      name=UNNAMED_NODE;
    }
 else     if (node instanceof ICapPO) {
      name=getText((ICapPO)node);
    }
 else     if (node instanceof IExecTestCasePO) {
      name=NodeNameUtil.getText((IExecTestCasePO)node,true);
    }
 else     if (node instanceof ISpecTestCasePO) {
      name=NodeNameUtil.getText((ISpecTestCasePO)node,true);
    }
 else {
      name=node.getName();
    }
    return new StringBuilder(prefix).append(name).toString();
  }
  if (element instanceof IReusedProjectPO) {
    IReusedProjectPO reusedProject=(IReusedProjectPO)element;
    String projectName=reusedProject.getProjectName();
    if (projectName == null) {
      projectName=reusedProject.getProjectGuid();
    }
    return projectName + StringConstants.UNDERSCORE + StringConstants.LEFT_BRACKET+ reusedProject.getVersionString()+ StringConstants.RIGHT_BRACKET;
  }
  if (element instanceof ISpecObjContPO) {
    return Messages.TreeBuilderTestCases;
  }
 else   if (element instanceof IExecObjContPO) {
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    if (activeProject != null) {
      return activeProject.getName();
    }
    LOG.error(Messages.GeneralLabelProvier_NoActiveProject);
  }
  return element == null ? StringConstants.EMPTY : element.toString();
}","/** 
 * @param element the element to get the text for 
 * @return a descriptive text for the given element
 */
public static String getTextImpl(Object element){
  if (element instanceof INodePO) {
    String prefix=StringConstants.EMPTY;
    String name=null;
    INodePO node=(INodePO)element;
    if (!checkActivation((INodePO)element)) {
      prefix=INACTIVE_PREFIX;
    }
    if (node instanceof IRefTestSuitePO) {
      name=NodeNameUtil.getText((IRefTestSuitePO)node);
    }
 else     if (node.getName() == null) {
      name=UNNAMED_NODE;
    }
 else     if (node instanceof ICapPO) {
      name=getText((ICapPO)node);
    }
 else     if (node instanceof IExecTestCasePO) {
      name=NodeNameUtil.getText((IExecTestCasePO)node,true);
    }
 else     if (node instanceof ISpecTestCasePO) {
      name=NodeNameUtil.getText((ISpecTestCasePO)node,true);
    }
 else {
      name=node.getName();
    }
    String postfix=StringConstants.EMPTY;
    if (node instanceof ICondStructPO && ((ICondStructPO)node).isNegate()) {
      postfix=NEGATED_POSTFIX;
    }
    return new StringBuilder(prefix).append(name).append(postfix).toString();
  }
  if (element instanceof IReusedProjectPO) {
    IReusedProjectPO reusedProject=(IReusedProjectPO)element;
    String projectName=reusedProject.getProjectName();
    if (projectName == null) {
      projectName=reusedProject.getProjectGuid();
    }
    return projectName + StringConstants.UNDERSCORE + StringConstants.LEFT_BRACKET+ reusedProject.getVersionString()+ StringConstants.RIGHT_BRACKET;
  }
  if (element instanceof ISpecObjContPO) {
    return Messages.TreeBuilderTestCases;
  }
 else   if (element instanceof IExecObjContPO) {
    IProjectPO activeProject=GeneralStorage.getInstance().getProject();
    if (activeProject != null) {
      return activeProject.getName();
    }
    LOG.error(Messages.GeneralLabelProvier_NoActiveProject);
  }
  return element == null ? StringConstants.EMPTY : element.toString();
}",0.9543766578249336
95465,"/** 
 * get column for the given path
 * @param colPath the path
 * @param op the operation
 * @param table the table
 * @param path the path as list
 * @return the column or null if no column was found
 */
private TableColumn<?,?> determineColumn(final String colPath,final String op,TableView table,List<String> path){
  ObservableList<TableColumn> columns;
  if (colPath.contains(""String_Node_Str"" + TestDataConstants.PATH_CHAR_DEFAULT)) {
    columns=table.getColumns();
  }
 else {
    columns=table.getVisibleLeafColumns();
  }
  Iterator<String> pathIterator=path.iterator();
  String currCol=null;
  TableColumn<?,?> column=null;
  while (pathIterator.hasNext()) {
    try {
      currCol=pathIterator.next();
      int usrIdxCol=Integer.parseInt(currCol);
      if (usrIdxCol == 0) {
        usrIdxCol=usrIdxCol + 1;
      }
      int i=IndexConverter.toImplementationIndex(usrIdxCol);
      if (MatchUtil.NOT_EQUALS == op) {
        for (int j=0; j < columns.size(); j++) {
          if (j != i) {
            if (pathIterator.hasNext()) {
              columns=columns.get(j).getColumns();
            }
 else {
              column=columns.get(j);
            }
          }
        }
      }
 else {
        try {
          if (pathIterator.hasNext()) {
            columns=columns.get(i).getColumns();
          }
 else {
            column=columns.get(i);
          }
        }
 catch (        IndexOutOfBoundsException e) {
          throw new StepExecutionException(""String_Node_Str"" + IndexConverter.toUserIndex(i),EventFactory.createActionError(TestErrorEvent.INVALID_INDEX));
        }
      }
    }
 catch (    NumberFormatException nfe) {
      try {
        if (path.size() <= 1) {
          columns=table.getColumns();
        }
        if (columns.size() <= 0) {
          throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_HEADER));
        }
        for (        TableColumn c : columns) {
          String h=c.getText();
          if (MatchUtil.getInstance().match(h,currCol,op)) {
            column=c;
            if (pathIterator.hasNext()) {
              columns=c.getColumns();
            }
            break;
          }
        }
      }
 catch (      IllegalArgumentException iae) {
      }
    }
  }
  return column;
}","/** 
 * get column for the given path
 * @param colPath the path
 * @param op the operation
 * @param table the table
 * @param path the path as list
 * @return the column or null if no column was found
 */
private TableColumn<?,?> determineColumn(final String colPath,final String op,TableView table,List<String> path){
  ObservableList<TableColumn> columns;
  if (colPath.contains(""String_Node_Str"" + TestDataConstants.PATH_CHAR_DEFAULT)) {
    columns=table.getColumns();
  }
 else {
    columns=table.getVisibleLeafColumns();
  }
  Iterator<String> pathIterator=path.iterator();
  String currCol=null;
  TableColumn<?,?> column=null;
  pathIteration:   while (pathIterator.hasNext()) {
    try {
      currCol=pathIterator.next();
      int usrIdxCol=Integer.parseInt(currCol);
      if (usrIdxCol == 0) {
        usrIdxCol=usrIdxCol + 1;
      }
      int i=IndexConverter.toImplementationIndex(usrIdxCol);
      if (MatchUtil.NOT_EQUALS == op) {
        for (int j=0; j < columns.size(); j++) {
          if (j != i) {
            if (pathIterator.hasNext()) {
              columns=columns.get(j).getColumns();
            }
 else {
              column=columns.get(j);
            }
          }
        }
      }
 else {
        try {
          if (pathIterator.hasNext()) {
            columns=columns.get(i).getColumns();
          }
 else {
            column=columns.get(i);
          }
        }
 catch (        IndexOutOfBoundsException e) {
          return null;
        }
      }
    }
 catch (    NumberFormatException nfe) {
      try {
        if (path.size() <= 1) {
          columns=table.getColumns();
        }
        if (columns.size() <= 0) {
          throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_HEADER));
        }
        for (        TableColumn c : columns) {
          String h=c.getText();
          if (MatchUtil.getInstance().match(h,currCol,op)) {
            column=c;
            if (pathIterator.hasNext()) {
              columns=c.getColumns();
            }
            continue pathIteration;
          }
        }
        return null;
      }
 catch (      IllegalArgumentException iae) {
      }
    }
  }
  return column;
}",0.941306266548985
95466,"/** 
 * Dealing with a single node
 * @param nodeOld the node
 */
public void traverse(INodePO nodeOld){
  String guid;
  ICompNamesPairPO pair;
  Map<String,String> mapLocal;
  HashMap<String,String> localType=new HashMap<String,String>();
  INodePO node=nodeOld;
  if (m_guidToSwap != null && m_guidToSwap.equals(node.getGuid())) {
    node=m_localNode;
  }
  for (Iterator<INodePO> it=node.getAllNodeIter(); it.hasNext(); ) {
    INodePO child=it.next();
    if (child instanceof ICategoryPO || child instanceof ISpecTestCasePO) {
      traverse(child);
    }
 else     if (child instanceof ICapPO) {
      guid=((ICapPO)child).getComponentName();
      if (guid == null) {
        continue;
      }
      guid=CompNameManager.getInstance().resolveGuid(guid);
      String type=((ICapPO)child).getComponentType();
      updateType(guid,type,localType);
    }
 else     if (child instanceof IExecTestCasePO) {
      ISpecTestCasePO spec=((IExecTestCasePO)child).getSpecTestCase();
      if (spec == null) {
        continue;
      }
      if (!m_localType.containsKey(spec.getId())) {
        traverse(spec);
      }
      mapLocal=m_localType.get(spec.getId());
      for (      String gui : mapLocal.keySet()) {
        pair=((IExecTestCasePO)child).getCompNamesPair(gui);
        if (pair == null) {
          guid=gui;
        }
 else {
          guid=pair.getSecondName();
          guid=CompNameManager.getInstance().resolveGuid(guid);
        }
        updateType(guid,mapLocal.get(gui),localType);
      }
      setCompNamePairTypes((IExecTestCasePO)child,mapLocal);
    }
  }
  m_localType.put(node.getId(),localType);
}","/** 
 * Dealing with a single node
 * @param nodeOld the node
 */
public void traverse(INodePO nodeOld){
  String guid;
  ICompNamesPairPO pair;
  Map<String,String> mapLocal;
  HashMap<String,String> localType=new HashMap<String,String>();
  INodePO node=nodeOld;
  if (m_guidToSwap != null && m_guidToSwap.equals(node.getGuid())) {
    node=m_localNode;
  }
  for (Iterator<INodePO> it=node.getAllNodeIter(); it.hasNext(); ) {
    INodePO child=it.next();
    if (child instanceof ICategoryPO || child instanceof ISpecTestCasePO) {
      traverse(child);
    }
 else     if (child instanceof ICapPO) {
      guid=((ICapPO)child).getComponentName();
      if (guid == null) {
        continue;
      }
      guid=CompNameManager.getInstance().resolveGuid(guid);
      String type=((ICapPO)child).getComponentType();
      updateType(guid,type,localType,node);
    }
 else     if (child instanceof IExecTestCasePO) {
      ISpecTestCasePO spec=((IExecTestCasePO)child).getSpecTestCase();
      if (spec == null) {
        continue;
      }
      if (!m_localType.containsKey(spec.getId())) {
        traverse(spec);
      }
      mapLocal=m_localType.get(spec.getId());
      for (      String gui : mapLocal.keySet()) {
        pair=((IExecTestCasePO)child).getCompNamesPair(gui);
        if (pair == null) {
          guid=gui;
        }
 else {
          guid=pair.getSecondName();
          guid=CompNameManager.getInstance().resolveGuid(guid);
        }
        updateType(guid,mapLocal.get(gui),localType,node);
      }
      setCompNamePairTypes((IExecTestCasePO)child,mapLocal);
    }
  }
  m_localType.put(node.getId(),localType);
}",0.9969437652811736
95467,"/** 
 * Handling the associations All mapped types should realize the most concrete usage type The most concrete of usages and the last map will be the new type
 */
private void handleAssociations(){
  Map<String,String> maps=new HashMap<>();
  CompSystem compSystem=ComponentBuilder.getInstance().getCompSystem();
  String resGuid;
  for (  IAUTMainPO aut : GeneralStorage.getInstance().getProject().getAutMainList()) {
    for (    IObjectMappingAssoziationPO assoc : aut.getObjMap().getMappings()) {
      IComponentIdentifier technicalName=assoc.getTechnicalName();
      if (technicalName == null) {
        continue;
      }
      List<Component> availableComponents=compSystem.getComponents(aut.getToolkit(),true);
      String type=CompSystem.getComponentType(technicalName.getSupportedClassName(),availableComponents);
      for (      String guid : assoc.getLogicalNames()) {
        resGuid=CompNameManager.getInstance().resolveGuid(guid);
        if (!maps.containsKey(resGuid) || CompNameTypeManager.doesFirstTypeRealizeSecond(type,maps.get(resGuid))) {
          maps.put(resGuid,type);
        }
        String globType=m_usageType.get(resGuid);
        if (globType == null) {
          m_usageType.put(resGuid,m_mostAbstract);
          globType=m_mostAbstract;
        }
        if (globType != null && !globType.equals(ComponentNamesBP.UNKNOWN_COMPONENT_TYPE) && !CompNameTypeManager.doesFirstTypeRealizeSecond(type,globType)) {
          m_allProblems.put(resGuid,ProblemType.REASON_INCOMPATIBLE_MAP_TYPE);
          List<String> info=new ArrayList<>(2);
          info.add(CompSystemI18n.getString(type));
          info.add(CompSystemI18n.getString(globType));
          m_problemInfo.put(resGuid,info);
        }
      }
    }
  }
  for (  String guid : m_usageType.keySet()) {
    if (!maps.containsKey(guid) || ProblemType.REASON_INCOMPATIBLE_USAGE_TYPE.equals(m_allProblems.get(guid)) || ProblemType.REASON_INCOMPATIBLE_MAP_TYPE.equals(m_allProblems.get(guid))) {
      m_globalType.put(guid,m_usageType.get(guid));
    }
 else {
      m_globalType.put(guid,CompNameTypeManager.getMostConcreteVisibleAncestorType(maps.get(guid)));
    }
  }
}","/** 
 * Handling the associations All mapped types should realize the most concrete usage type The most concrete of usages and the last map will be the new type
 */
private void handleAssociations(){
  Map<String,String> maps=new HashMap<>();
  CompSystem compSystem=ComponentBuilder.getInstance().getCompSystem();
  String resGuid;
  for (  IAUTMainPO aut : GeneralStorage.getInstance().getProject().getAutMainList()) {
    for (    IObjectMappingAssoziationPO assoc : aut.getObjMap().getMappings()) {
      IComponentIdentifier technicalName=assoc.getTechnicalName();
      if (technicalName == null) {
        continue;
      }
      List<Component> availableComponents=compSystem.getComponents(aut.getToolkit(),true);
      String type=CompSystem.getComponentType(technicalName.getSupportedClassName(),availableComponents);
      for (      String guid : assoc.getLogicalNames()) {
        resGuid=CompNameManager.getInstance().resolveGuid(guid);
        if (!maps.containsKey(resGuid) || CompNameTypeManager.doesFirstTypeRealizeSecond(type,maps.get(resGuid))) {
          maps.put(resGuid,type);
        }
        String globType=m_usageType.get(resGuid);
        if (globType == null) {
          m_usageType.put(resGuid,m_mostAbstract);
          globType=m_mostAbstract;
        }
        if (globType != null && !globType.equals(ComponentNamesBP.UNKNOWN_COMPONENT_TYPE) && !CompNameTypeManager.doesFirstTypeRealizeSecond(type,globType)) {
          m_allProblems.put(resGuid,ProblemType.REASON_INCOMPATIBLE_MAP_TYPE);
          List<String> info=new ArrayList<>(2);
          info.add(CompSystemI18n.getString(type));
          info.add(CompSystemI18n.getString(globType));
          info.add(m_lastTypeChange.get(guid));
          info.add(aut.getGuid());
          m_problemInfo.put(resGuid,info);
        }
      }
    }
  }
  for (  String guid : m_usageType.keySet()) {
    if (!maps.containsKey(guid) || ProblemType.REASON_INCOMPATIBLE_USAGE_TYPE.equals(m_allProblems.get(guid)) || ProblemType.REASON_INCOMPATIBLE_MAP_TYPE.equals(m_allProblems.get(guid))) {
      m_globalType.put(guid,m_usageType.get(guid));
    }
 else {
      m_globalType.put(guid,CompNameTypeManager.getMostConcreteVisibleAncestorType(maps.get(guid)));
    }
  }
}",0.9812174700158408
95468,"/** 
 * Puts the type into the local and global type maps
 * @param guid the guid
 * @param type the type
 * @param localType the local type map
 */
private void updateType(String guid,String type,Map<String,String> localType){
  if (localType.containsKey(guid)) {
    localType.put(guid,CompNameTypeManager.calcUsageType(localType.get(guid),type));
  }
 else {
    localType.put(guid,type);
  }
  String currentType=m_usageType.get(guid);
  if (currentType == null) {
    m_usageType.put(guid,m_mostAbstract);
    currentType=m_mostAbstract;
  }
  if (currentType.equals(ComponentNamesBP.UNKNOWN_COMPONENT_TYPE)) {
    return;
  }
  String newType=CompNameTypeManager.calcUsageType(currentType,type);
  if (newType.equals(ComponentNamesBP.UNKNOWN_COMPONENT_TYPE)) {
    List<String> info=new ArrayList<String>(2);
    info.add(CompSystemI18n.getString(type));
    info.add(CompSystemI18n.getString(currentType));
    m_problemInfo.put(guid,info);
  }
  m_usageType.put(guid,newType);
}","/** 
 * Puts the type into the local and global type maps
 * @param guid the guid
 * @param type the type
 * @param localType the local type map
 * @param node the node
 */
private void updateType(String guid,String type,Map<String,String> localType,INodePO node){
  if (localType.containsKey(guid)) {
    localType.put(guid,CompNameTypeManager.calcUsageType(localType.get(guid),type));
  }
 else {
    localType.put(guid,type);
  }
  String currentType=m_usageType.get(guid);
  String currentTypeDisp=CompSystemI18n.getString(currentType);
  String typeDisp=CompSystemI18n.getString(type);
  if (currentType == null) {
    m_usageType.put(guid,m_mostAbstract);
    currentType=m_mostAbstract;
  }
  if (currentType.equals(ComponentNamesBP.UNKNOWN_COMPONENT_TYPE)) {
    return;
  }
  String newType=CompNameTypeManager.calcUsageType(currentType,type);
  if (newType.equals(ComponentNamesBP.UNKNOWN_COMPONENT_TYPE)) {
    List<String> info=new ArrayList<String>(2);
    info.add(typeDisp);
    info.add(currentTypeDisp);
    info.add(m_lastTypeChange.get(guid));
    info.add(node.getGuid());
    m_problemInfo.put(guid,info);
  }
 else   if (!StringUtils.equals(currentTypeDisp,CompSystemI18n.getString(newType))) {
    m_lastTypeChange.put(guid,node.getGuid());
  }
  m_usageType.put(guid,newType);
}",0.7596153846153846
95469,"/** 
 * Recalculates all CN types
 */
public void recalculateTypes(){
  long start=System.currentTimeMillis();
  String mostAbstract=CompNameTypeManager.getMostAbstractType();
  for (  IComponentNamePO cN : CompNameManager.getInstance().getAllCompNamePOs()) {
    if (GeneralStorage.getInstance().getProject().getId().equals(cN.getParentProjectId())) {
      cN.setComponentType(mostAbstract);
    }
  }
  CalcTypes calc=new CalcTypes(CompNameManager.getInstance(),null);
  calc.setWriteTypes(true);
  calc.calculateTypes();
  CompNameManager.getInstance().setTypeProblems(calc);
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
}","/** 
 * Recalculates all CN types
 */
public void recalculateTypes(){
  String mostAbstract=CompNameTypeManager.getMostAbstractType();
  for (  IComponentNamePO cN : CompNameManager.getInstance().getAllCompNamePOs()) {
    if (GeneralStorage.getInstance().getProject().getId().equals(cN.getParentProjectId())) {
      cN.setComponentType(mostAbstract);
      cN.setTypeProblem(null);
    }
  }
  CalcTypes calc=new CalcTypes(CompNameManager.getInstance(),null);
  calc.setWriteTypes(true);
  calc.calculateTypes();
  CompNameManager.getInstance().setTypeProblems(calc);
}",0.8626198083067093
95470,"/** 
 * Adds all propagated component name pairs of the test execution node to the map <code>pairs</code>.
 * @param pairs The map
 * @param execNode The test execution node
 */
private void addPropagatedPairs(Map<String,ICompNamesPairPO> pairs,IExecTestCasePO execNode){
  for (  ICompNamesPairPO pair : execNode.getCompNamesPairs()) {
    if (pair.isPropagated()) {
      String name=pair.getSecondName();
      if (!pairs.containsKey(name)) {
        String type=(pair.getType() == null || pair.getType().equals(StringConstants.EMPTY)) ? StringConstants.EMPTY : pair.getType();
        if (pair.getType() == null) {
          for (          Object o : execNode.getSpecTestCase().getUnmodifiableNodeList()) {
            INodePO node=(INodePO)o;
            if (node instanceof ICapPO) {
              ICapPO cap=(ICapPO)node;
              if (cap.getComponentName().equals(pair.getName())) {
                type=cap.getComponentType();
                pair.setType(type);
                break;
              }
            }
          }
        }
        pairs.put(name,PoMaker.createCompNamesPairPO(name,type));
      }
    }
  }
}","/** 
 * Adds all propagated component name pairs of the test execution node to the map <code>pairs</code>.
 * @param pairs The map
 * @param execNode The test execution node
 */
private void addPropagatedPairs(Map<String,ICompNamesPairPO> pairs,IExecTestCasePO execNode){
  for (  ICompNamesPairPO pair : execNode.getCompNamesPairs()) {
    if (pair.isPropagated()) {
      String name=pair.getSecondName();
      if (!pairs.containsKey(name)) {
        pairs.put(name,PoMaker.createCompNamesPairPO(name,StringConstants.EMPTY));
      }
    }
  }
}",0.5922848664688427
95471,"/** 
 * Creates an incompatible type Problem
 * @param cN the Component Name
 * @param type the Problem Type
 * @return the Problem
 */
public static IProblem createIncompatibleTypeProblem(IComponentNamePO cN,ProblemType type){
  if (type.equals(ProblemType.REASON_INCOMPATIBLE_MAP_TYPE)) {
    return new Problem(NLS.bind(Messages.ProblemIncompatibleMapTypeMarkerText,cN.getName()),new Status(IStatus.ERROR,Activator.PLUGIN_ID,NLS.bind(Messages.ProblemIncompatibleMapTypeMarkerText,cN.getName())),cN.getName(),type);
  }
  return new Problem(NLS.bind(Messages.ProblemIncompatibleUsageTypeMarkerText,cN.getName()),new Status(IStatus.ERROR,Activator.PLUGIN_ID,NLS.bind(Messages.ProblemIncompatibleUsageTypeMarkerText,cN.getName())),cN.getName(),type);
}","/** 
 * Creates an incompatible type Problem
 * @param cN the Component Name
 * @param type the Problem Type
 * @return the Problem
 */
public static IProblem createIncompatibleTypeProblem(IComponentNamePO cN,ProblemType type){
  if (type.equals(ProblemType.REASON_INCOMPATIBLE_MAP_TYPE)) {
    return new Problem(NLS.bind(Messages.ProblemIncompatibleMapTypeMarkerText,cN.getName()),new Status(IStatus.ERROR,Activator.PLUGIN_ID,NLS.bind(Messages.ProblemIncompatibleMapTypeMarkerText,cN.getName())),cN,type);
  }
  return new Problem(NLS.bind(Messages.ProblemIncompatibleUsageTypeMarkerText,cN.getName()),new Status(IStatus.ERROR,Activator.PLUGIN_ID,NLS.bind(Messages.ProblemIncompatibleUsageTypeMarkerText,cN.getName())),cN,type);
}",0.9865229110512128
95472,"/** 
 * Shows a message in the problems view.
 * @param message The message in the problems view.
 * @param messageType IMarker.SEVERITY_ERROR, IMarker.SEVERITY_INFO or IMarker.SEVERITY_WARNING
 * @param location The location of the problem, task, ....
 * @param object The object reference.
 * @param type The type of this problem
 */
private void createMarker(String message,int messageType,String location,Object object,ProblemType type){
  boolean existProblem=false;
  for (  IMarker marker : m_markerList) {
    try {
      if (marker.getAttribute(IMarker.LOCATION).equals(location) && marker.getAttribute(IMarker.SEVERITY).equals(messageType) && marker.getAttribute(IMarker.MESSAGE).equals(message)&& ((object != null && new Integer(object.hashCode()).equals(marker.getAttribute(Constants.JB_OBJECT_HASHCODE))) || (object == null && marker.getAttribute(Constants.JB_OBJECT_HASHCODE) == null))) {
        existProblem=true;
        m_markerToShowList.add(marker);
      }
    }
 catch (    CoreException e) {
    }
  }
  if (existProblem) {
    return;
  }
  try {
    IMarker marker=MARKER_ROOT.createMarker(Constants.JB_PROBLEM_MARKER);
    marker.setAttribute(IMarker.LOCATION,location);
    marker.setAttribute(IMarker.SEVERITY,messageType);
    marker.setAttribute(IMarker.MESSAGE,message);
    if (object != null) {
      marker.setAttribute(Constants.JB_OBJECT_HASHCODE,object.hashCode());
    }
 else {
      marker.setAttribute(Constants.JB_OBJECT_HASHCODE,null);
    }
    marker.setAttribute(Constants.JB_REASON,type.ordinal());
    if (object instanceof INodePO) {
      INodePO node=(INodePO)object;
      marker.setAttribute(Constants.JB_OBJECT_NAME,node.getName());
      marker.setAttribute(Constants.JB_NODE_GUID,node.getGuid());
    }
 else {
      if (object instanceof String) {
        marker.setAttribute(Constants.JB_OBJECT_NAME,object);
      }
 else {
        marker.setAttribute(Constants.JB_OBJECT_NAME,StringConstants.EMPTY);
      }
      marker.setAttribute(Constants.JB_NODE_GUID,StringConstants.EMPTY);
    }
    m_markerList.add(marker);
    m_markerToShowList.add(marker);
  }
 catch (  CoreException e) {
    log.error(e.getLocalizedMessage(),e);
  }
}","/** 
 * Shows a message in the problems view.
 * @param message The message in the problems view.
 * @param messageType IMarker.SEVERITY_ERROR, IMarker.SEVERITY_INFO or IMarker.SEVERITY_WARNING
 * @param location The location of the problem, task, ....
 * @param object The object reference.
 * @param type The type of this problem
 */
private void createMarker(String message,int messageType,String location,Object object,ProblemType type){
  boolean existProblem=false;
  for (  IMarker marker : m_markerList) {
    try {
      if (marker.getAttribute(IMarker.LOCATION).equals(location) && marker.getAttribute(IMarker.SEVERITY).equals(messageType) && marker.getAttribute(IMarker.MESSAGE).equals(message)&& ((object != null && new Integer(object.hashCode()).equals(marker.getAttribute(Constants.JB_OBJECT_HASHCODE))) || (object == null && marker.getAttribute(Constants.JB_OBJECT_HASHCODE) == null))) {
        existProblem=true;
        m_markerToShowList.add(marker);
      }
    }
 catch (    CoreException e) {
    }
  }
  if (existProblem) {
    return;
  }
  try {
    IMarker marker=MARKER_ROOT.createMarker(Constants.JB_PROBLEM_MARKER);
    marker.setAttribute(IMarker.LOCATION,location);
    marker.setAttribute(IMarker.SEVERITY,messageType);
    marker.setAttribute(IMarker.MESSAGE,message);
    if (object != null) {
      marker.setAttribute(Constants.JB_OBJECT_HASHCODE,object.hashCode());
    }
 else {
      marker.setAttribute(Constants.JB_OBJECT_HASHCODE,null);
    }
    marker.setAttribute(Constants.JB_REASON,type.ordinal());
    if (object instanceof IComponentNamePO) {
      marker.setAttribute(Constants.JB_NODE_GUID,((IComponentNamePO)object).getGuid());
    }
 else     if (object instanceof INodePO) {
      INodePO node=(INodePO)object;
      marker.setAttribute(Constants.JB_OBJECT_NAME,node.getName());
      marker.setAttribute(Constants.JB_NODE_GUID,node.getGuid());
    }
 else {
      if (object instanceof String) {
        marker.setAttribute(Constants.JB_OBJECT_NAME,object);
      }
 else {
        marker.setAttribute(Constants.JB_OBJECT_NAME,StringConstants.EMPTY);
      }
      marker.setAttribute(Constants.JB_NODE_GUID,StringConstants.EMPTY);
    }
    m_markerList.add(marker);
    m_markerToShowList.add(marker);
  }
 catch (  CoreException e) {
    log.error(e.getLocalizedMessage(),e);
  }
}",0.967784642541924
95473,"/** 
 * Deletes all tracked changes of a project
 * @param monitor the monitor
 * @param project the project
 * @return the map from changed nodes to whether they were locked (for which tracked changes could not be deleted)
 * @throws ProjectDeletedException 
 * @throws PMException
 */
public static Map<INodePO,Boolean> cleanupTrackedChanges(IProgressMonitor monitor,final IProjectPO project) throws PMException, ProjectDeletedException {
  CollectNodesWithTrackedChangesOperation treeNodeOp=new CollectNodesWithTrackedChangesOperation(project);
  TreeTraverser treeTraverser=new TreeTraverser(project,treeNodeOp,true,true);
  treeTraverser.traverse();
  List<INodePO> listOfNodesWithTrackedChanges=treeNodeOp.getListOfNodesWithTrackedChanges();
  Map<INodePO,Boolean> nodeToWasLockedMap=new HashMap<>(listOfNodesWithTrackedChanges.size());
  monitor.beginTask(Messages.DeleteTrackedChangesActionDialog,listOfNodesWithTrackedChanges.size());
  final Persistor persistor=Persistor.instance();
  final EntityManager session=persistor.openSession();
  EntityTransaction tx=null;
  tx=persistor.getTransaction(session);
  for (  INodePO node : listOfNodesWithTrackedChanges) {
    try {
      persistor.lockPO(session,node);
      node.deleteTrackedChanges();
      session.merge(node);
      nodeToWasLockedMap.put(node,new Boolean(false));
    }
 catch (    PMException|PersistenceException e) {
      nodeToWasLockedMap.put(node,new Boolean(true));
    }
    monitor.worked(1);
  }
  persistor.commitTransaction(session,tx);
  persistor.dropSession(session);
  monitor.done();
  return nodeToWasLockedMap;
}","/** 
 * Deletes all tracked changes of a project
 * @param monitor the monitor
 * @param project the project
 * @return the map from changed nodes to whether they were locked (for which tracked changes could not be deleted)
 * @throws ProjectDeletedException 
 * @throws PMException
 */
public static Map<INodePO,Boolean> cleanupTrackedChanges(IProgressMonitor monitor,final IProjectPO project) throws PMException, ProjectDeletedException {
  CollectNodesWithTrackedChangesOperation treeNodeOp=new CollectNodesWithTrackedChangesOperation(project);
  TreeTraverser treeTraverser=new TreeTraverser(project,treeNodeOp,true,true);
  treeTraverser.traverse();
  List<INodePO> listOfNodesWithTrackedChanges=treeNodeOp.getListOfNodesWithTrackedChanges();
  Map<INodePO,Boolean> nodeToWasLockedMap=new HashMap<>(listOfNodesWithTrackedChanges.size());
  monitor.beginTask(Messages.DeleteTrackedChangesActionDialog,listOfNodesWithTrackedChanges.size());
  final Persistor persistor=Persistor.instance();
  final EntityManager session=persistor.openSession();
  EntityTransaction tx=null;
  tx=persistor.getTransaction(session);
  for (  INodePO node : listOfNodesWithTrackedChanges) {
    try {
      persistor.lockPO(session,node);
      node.deleteTrackedChanges();
      session.merge(node);
      nodeToWasLockedMap.put(node,new Boolean(false));
    }
 catch (    PMException|PersistenceException e) {
      nodeToWasLockedMap.put(node,new Boolean(true));
    }
    monitor.worked(1);
  }
  persistor.commitTransaction(session,tx);
  persistor.dropSession(session);
  EntityManager master=GeneralStorage.getInstance().getMasterSession();
  for (  INodePO key : nodeToWasLockedMap.keySet()) {
    if (!nodeToWasLockedMap.get(key)) {
      INodePO refr=master.find(key.getClass(),key.getId());
      if (refr != null) {
        master.refresh(refr);
      }
    }
  }
  monitor.done();
  return nodeToWasLockedMap;
}",0.9032992036405004
95474,"/** 
 * Refreshes objects of the master session
 * @param op the objects - these don't need to be managed
 */
private static void refreshMasterSession(ITransaction op) throws PMRefreshFailedException {
  if (op.getToRefresh() == null || op.getToRefresh().isEmpty()) {
    return;
  }
  try {
    EntityManager master=GeneralStorage.getInstance().getMasterSession();
    for (    IPersistentObject po : op.getToRefresh()) {
      po=master.find(po.getClass(),po.getId());
      if (po != null) {
        master.refresh(po);
      }
      if (po instanceof INodePO) {
        ((INodePO)po).getUnmodifiableNodeList();
      }
    }
  }
 catch (  Exception e) {
    throw new PMRefreshFailedException(e);
  }
}","/** 
 * Refreshes objects of the master session
 * @param op the objects - these don't need to be managed
 */
private static void refreshMasterSession(ITransaction op) throws PMRefreshFailedException {
  Collection<? extends IPersistentObject> toRefresh=op.getToRefresh();
  if (toRefresh == null || toRefresh.isEmpty()) {
    return;
  }
  try {
    EntityManager master=GeneralStorage.getInstance().getMasterSession();
    for (    IPersistentObject po : toRefresh) {
      po=master.find(po.getClass(),po.getId());
      if (po != null) {
        master.refresh(po);
      }
      if (po instanceof INodePO) {
        ((INodePO)po).getUnmodifiableNodeList();
      }
    }
  }
 catch (  Exception e) {
    throw new PMRefreshFailedException(e);
  }
}",0.7169294037011652
95475,"/** 
 * @param newTcName the name of the new SpecTestCase
 * @param ownerNode the edited  {@link INodePO} from which to extract
 * @param modNodes nodes to move from the old tc to the new tc
 * @return result of extraction
 */
private IExecTestCasePO persistExtraction(final INodePO ownerNode,final String newTcName,final List<INodePO> modNodes){
  final ParamNameBPDecorator mapper=new ParamNameBPDecorator(ParamNameBP.getInstance());
  final IExecTestCasePO[] lol=new IExecTestCasePO[1];
  final List<IPersistentObject> toLock=new ArrayList<>(2);
  final IPersistentObject cont=GeneralStorage.getInstance().getProject().getSpecObjCont();
  toLock.add(cont);
  toLock.add(ownerNode);
  boolean succ=TransactionWrapper.executeOperation(new ITransaction(){
    /** 
 * {@inheritDoc} 
 */
    public Collection<? extends IPersistentObject> getToLock(){
      return toLock;
    }
    /** 
 * {@inheritDoc} 
 */
    public Collection<? extends IPersistentObject> getToRefresh(){
      return toLock;
    }
    /** 
 * {@inheritDoc} 
 */
    public void run(    EntityManager sess) throws PMException {
      List<INodePO> nodesToRef=new ArrayList<INodePO>();
      getModNodesFromCurrentSession(sess,nodesToRef);
      lol[0]=TreeOpsBP.extractTestCase(newTcName,ownerNode,nodesToRef,sess,mapper);
      final ISpecTestCasePO newSpecTc=lol[0].getSpecTestCase();
      registerParamNamesToSave(newSpecTc,mapper);
      mapper.persist(sess,GeneralStorage.getInstance().getProject().getId());
      NativeSQLUtils.addNodeAFFECTS(sess,lol[0].getSpecTestCase(),cont);
    }
    /** 
 * Loads the moved nodes to the session
 * @param s session used for refactoring
 * @param nodesToRef nodes to refactor from current session
 */
    private void getModNodesFromCurrentSession(    EntityManager s,    List<INodePO> nodesToRef){
      if (modNodes.isEmpty()) {
        return;
      }
      INodePO par=modNodes.get(0).getParentNode();
      par=s.find(par.getClass(),par.getId());
      par.getUnmodifiableNodeList();
      for (      INodePO node : modNodes) {
        INodePO object=s.find(node.getClass(),node.getId());
        if (object != null) {
          nodesToRef.add(object);
        }
      }
    }
  }
);
  if (!succ) {
    return null;
  }
  mapper.updateStandardMapperAndCleanup(ownerNode.getParentProjectId());
  return lol[0];
}","/** 
 * @param newTcName the name of the new SpecTestCase
 * @param ownerNode the edited  {@link INodePO} from which to extract
 * @param modNodes nodes to move from the old tc to the new tc
 * @return result of extraction
 */
private IExecTestCasePO persistExtraction(final INodePO ownerNode,final String newTcName,final List<INodePO> modNodes){
  final ParamNameBPDecorator mapper=new ParamNameBPDecorator(ParamNameBP.getInstance());
  final IExecTestCasePO[] lol=new IExecTestCasePO[1];
  final List<IPersistentObject> toLock=new ArrayList<>(2);
  final IPersistentObject cont=GeneralStorage.getInstance().getProject().getSpecObjCont();
  toLock.add(cont);
  toLock.add(ownerNode);
  boolean succ=TransactionWrapper.executeOperation(new ITransaction(){
    /** 
 * {@inheritDoc} 
 */
    public Collection<? extends IPersistentObject> getToLock(){
      return toLock;
    }
    /** 
 * {@inheritDoc} 
 */
    public Collection<? extends IPersistentObject> getToRefresh(){
      List<IPersistentObject> toRefr=new ArrayList<>(toLock);
      toRefr.addAll(lol[0].getSpecTestCase().getUnmodifiableNodeList());
      return toRefr;
    }
    /** 
 * {@inheritDoc} 
 */
    public void run(    EntityManager sess) throws PMException {
      List<INodePO> nodesToRef=new ArrayList<INodePO>();
      getModNodesFromCurrentSession(sess,nodesToRef);
      lol[0]=TreeOpsBP.extractTestCase(newTcName,ownerNode,nodesToRef,sess,mapper);
      final ISpecTestCasePO newSpecTc=lol[0].getSpecTestCase();
      registerParamNamesToSave(newSpecTc,mapper);
      mapper.persist(sess,GeneralStorage.getInstance().getProject().getId());
      NativeSQLUtils.addNodeAFFECTS(sess,lol[0].getSpecTestCase(),cont);
    }
    /** 
 * Loads the moved nodes to the session
 * @param s session used for refactoring
 * @param nodesToRef nodes to refactor from current session
 */
    private void getModNodesFromCurrentSession(    EntityManager s,    List<INodePO> nodesToRef){
      if (modNodes.isEmpty()) {
        return;
      }
      INodePO par=modNodes.get(0).getParentNode();
      par=s.find(par.getClass(),par.getId());
      par.getUnmodifiableNodeList();
      for (      INodePO node : modNodes) {
        INodePO object=s.find(node.getClass(),node.getId());
        if (object != null) {
          nodesToRef.add(object);
        }
      }
    }
  }
);
  if (!succ) {
    return null;
  }
  mapper.updateStandardMapperAndCleanup(ownerNode.getParentProjectId());
  return lol[0];
}",0.9702269414948992
95476,"/** 
 * {@inheritDoc} 
 */
public Collection<? extends IPersistentObject> getToRefresh(){
  return toLock;
}","/** 
 * {@inheritDoc} 
 */
public Collection<? extends IPersistentObject> getToRefresh(){
  List<IPersistentObject> toRefr=new ArrayList<>(toLock);
  toRefr.addAll(lol[0].getSpecTestCase().getUnmodifiableNodeList());
  return toRefr;
}",0.6064139941690962
95477,"/** 
 * @param node the currently selected node: we insert below this or at the end of the SpecTC
 * @param exp whether node is expanded
 * @return the position to add
 */
public static NodeTarget getPositionToInsert(INodePO node,boolean exp){
  if (Plugin.getDefault().getPreferenceStore().getBoolean(Constants.NODE_INSERT_KEY)) {
    INodePO top=node;
    while (top != null && !(top instanceof ISpecTestCasePO)) {
      top=top.getParentNode();
    }
    return new NodeTarget(top.getNodeListSize(),top);
  }
  return NodeTargetCalculator.calcNodeTarget(null,node,ViewerDropAdapter.LOCATION_AFTER,exp);
}","/** 
 * @param node the currently selected node: we insert below this or at the end of the SpecTC
 * @param exp whether node is expanded
 * @return the position to add
 */
public static NodeTarget getPositionToInsert(INodePO node,boolean exp){
  if (Plugin.getDefault().getPreferenceStore().getBoolean(Constants.NODE_INSERT_KEY)) {
    INodePO top=node.getSpecAncestor();
    if (top == null) {
      return null;
    }
    return new NodeTarget(top.getNodeListSize(),top);
  }
  return NodeTargetCalculator.calcNodeTarget(null,node,ViewerDropAdapter.LOCATION_AFTER,exp);
}",0.8983050847457628
95478,"/** 
 * @param node TestResultNode
 * @param parameterInterface Source for Parameter information.
 * @param keyword ITestResultPO
 * @return result with parameter
 */
private ITestResultPO addParameterListToResult(ITestResultPO keyword,TestResultNode node,IParameterInterfacePO parameterInterface){
  for (  TestResultParameter param : node.getParameters()) {
    IParameterDetailsPO parameter=PoMaker.createParameterDetailsPO();
    parameter.setParameterName(param.getName());
    parameter.setParameterType(param.getType());
    parameter.setParameterValue(param.getValue());
    keyword.addParameter(parameter);
  }
  return keyword;
}","/** 
 * @param node TestResultNode
 * @param parameterInterface Source for Parameter information.
 * @param keyword ITestResultPO
 * @return result with parameter
 */
private ITestResultPO addParameterListToResult(ITestResultPO keyword,TestResultNode node,IParameterInterfacePO parameterInterface){
  for (  TestResultParameter param : node.getParameters()) {
    IParameterDetailsPO parameter=PoMaker.createParameterDetailsPO();
    parameter.setParameterName(param.getName());
    parameter.setParameterType(param.getType());
    String value=param.getValue();
    if (value.length() >= 3500) {
      log.warn(""String_Node_Str"" + value);
      value=StringUtils.substring(value,0,3500);
    }
    parameter.setParameterValue(value);
    keyword.addParameter(parameter);
  }
  return keyword;
}",0.8465829846582985
95479,"/** 
 * @param s session
 * @param tx transaction
 * @throws PMReadException {@inheritDoc}
 * @throws PMAlreadyLockedException {@inheritDoc}
 * @throws PMDirtyVersionException {@inheritDoc}
 * @throws PMException {@inheritDoc}
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
public void commitTransaction(EntityManager s,EntityTransaction tx) throws PMReadException, PMAlreadyLockedException, PMDirtyVersionException, PMException, ProjectDeletedException {
  Validate.notNull(s);
  Validate.notNull(tx);
  Validate.isTrue(tx.equals(s.getTransaction()),Messages.SessionAndTransactionDontMatch);
  try {
    tx.commit();
  }
 catch (  PersistenceException e) {
    if (s != null && s.equals(GeneralStorage.getInstance().getMasterSession())) {
      PersistenceManager.handleDBExceptionForMasterSession(null,e);
    }
 else {
      PersistenceManager.handleDBExceptionForAnySession(null,e,s);
    }
  }
 finally {
    removeLocks(s);
  }
}","/** 
 * @param s session
 * @param tx transaction
 * @throws PMReadException {@inheritDoc}
 * @throws PMAlreadyLockedException {@inheritDoc}
 * @throws PMDirtyVersionException {@inheritDoc}
 * @throws PMException {@inheritDoc}
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
public void commitTransaction(EntityManager s,EntityTransaction tx) throws PMReadException, PMAlreadyLockedException, PMDirtyVersionException, PMException, ProjectDeletedException {
  Validate.notNull(s);
  Validate.notNull(tx);
  Validate.isTrue(tx.equals(s.getTransaction()),Messages.SessionAndTransactionDontMatch);
  try {
    tx.commit();
  }
 catch (  PersistenceException e) {
    log.error(""String_Node_Str"",e);
    if (s != null && s.equals(GeneralStorage.getInstance().getMasterSession())) {
      PersistenceManager.handleDBExceptionForMasterSession(null,e);
    }
 else {
      PersistenceManager.handleDBExceptionForAnySession(null,e,s);
    }
  }
 finally {
    removeLocks(s);
  }
}",0.9818548387096774
95480,"/** 
 * Creates the instance of the persistent object which is defined by the XML element used as parameter. The method generates all dependent objects as well.
 * @param dtoProj the XML-Project
 * @param proj the IProjectPO
 * @param compNameCache The cache for storing and retrieving Component Names in memory.
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise <code>false</code>.
 */
private void createComponentNames(ProjectDTO dtoProj,IProjectPO proj,IWritableComponentNameCache compNameCache,boolean assignNewGuid){
  final List<ComponentNameDTO> componentNamesList=dtoProj.getComponentNames();
  final Map<String,String> oldToNewGUID=new HashMap<String,String>(componentNamesList.size());
  Set<IComponentNamePO> createdCompNames=new HashSet<IComponentNamePO>();
  for (  ComponentNameDTO compName : componentNamesList) {
    String guid=compName.getUuid();
    if (assignNewGuid) {
      final String newGuid=PersistenceUtil.generateUUID();
      oldToNewGUID.put(guid,newGuid);
      guid=newGuid;
    }
    final String name=compName.getCompName();
    final String type=compName.getCompType();
    if (!componentHasDefaultMapping(type)) {
      final String creationContext=compName.getCreationContext();
      final CompNameCreationContext ctx=CompNameCreationContext.forName(creationContext);
      final IComponentNamePO componentNamePO=PoMaker.createComponentNamePO(guid,name,type,ctx,proj.getId());
      componentNamePO.setReferencedGuid(compName.getRefUuid());
      createdCompNames.add(componentNamePO);
      compNameCache.addCompNamePO(componentNamePO);
    }
  }
  if (assignNewGuid) {
    for (    IComponentNamePO createdName : createdCompNames) {
      String newGuid=oldToNewGUID.get(createdName.getReferencedGuid());
      if (newGuid != null) {
        createdName.setReferencedGuid(newGuid);
      }
    }
    ImportExportUtil.switchCompNamesGuids(proj,oldToNewGUID);
  }
}","/** 
 * Creates the instance of the persistent object which is defined by the XML element used as parameter. The method generates all dependent objects as well.
 * @param dtoProj the XML-Project
 * @param proj the IProjectPO
 * @param compNameCache The cache for storing and retrieving Component Names in memory.
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise <code>false</code>.
 */
private void createComponentNames(ProjectDTO dtoProj,IProjectPO proj,IWritableComponentNameCache compNameCache,boolean assignNewGuid){
  final List<ComponentNameDTO> componentNamesList=dtoProj.getComponentNames();
  final Map<String,String> oldToNewGUID=new HashMap<String,String>(componentNamesList.size());
  Set<IComponentNamePO> createdCompNames=new HashSet<IComponentNamePO>();
  for (  ComponentNameDTO compName : componentNamesList) {
    String guid=compName.getUuid();
    if (assignNewGuid) {
      final String newGuid=PersistenceUtil.generateUUID();
      oldToNewGUID.put(guid,newGuid);
      guid=newGuid;
    }
    final String name=compName.getCompName();
    final String type=compName.getCompType();
    final String creationContext=compName.getCreationContext();
    final CompNameCreationContext ctx=CompNameCreationContext.forName(creationContext);
    final IComponentNamePO componentNamePO=PoMaker.createComponentNamePO(guid,name,type,ctx,proj.getId());
    componentNamePO.setReferencedGuid(compName.getRefUuid());
    createdCompNames.add(componentNamePO);
    compNameCache.addCompNamePO(componentNamePO);
  }
  if (assignNewGuid) {
    for (    IComponentNamePO createdName : createdCompNames) {
      String newGuid=oldToNewGUID.get(createdName.getReferencedGuid());
      if (newGuid != null) {
        createdName.setReferencedGuid(newGuid);
      }
    }
    ImportExportUtil.switchCompNamesGuids(proj,oldToNewGUID);
  }
}",0.983716722667356
95481,"@Override public void rcDragIndex(int mouseButton,String modifier,int index){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  dndHelper.setModifier(modifier);
  dndHelper.setMouseButton(mouseButton);
  rcSelectIndex(String.valueOf(index),BinaryChoice.no.rcValue(),mouseButton,0);
  pressOrReleaseModifiers(modifier,true);
  getRobot().mousePress(null,null,mouseButton);
}","@Override public void rcDragIndex(int mouseButton,String modifier,int index){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  dndHelper.setModifier(modifier);
  dndHelper.setMouseButton(mouseButton);
  rcSelectIndex(String.valueOf(index),BinaryChoice.no.rcValue(),mouseButton,0);
  pressOrReleaseModifiers(modifier,true);
  getRobot().mousePress(null,null,mouseButton);
  Node listView=((Node)getRealComponent());
  listView.addEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
  dndHelper.setDragMode(true);
}",0.8509719222462203
95482,"@Override public void rcDragValue(int mouseButton,String modifier,String value,String operator,String searchType){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  dndHelper.setModifier(modifier);
  dndHelper.setMouseButton(mouseButton);
  rcSelectValue(value,operator,searchType,BinaryChoice.no.rcValue(),mouseButton,0);
  pressOrReleaseModifiers(modifier,true);
  getRobot().mousePress(null,null,mouseButton);
}","@Override public void rcDragValue(int mouseButton,String modifier,String value,String operator,String searchType){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  dndHelper.setModifier(modifier);
  dndHelper.setMouseButton(mouseButton);
  rcSelectValue(value,operator,searchType,BinaryChoice.no.rcValue(),mouseButton,0);
  pressOrReleaseModifiers(modifier,true);
  getRobot().mousePress(null,null,mouseButton);
  Node listView=((Node)getRealComponent());
  listView.addEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
  dndHelper.setDragMode(true);
}",0.8630952380952381
95483,"@Override public void rcDropValue(String value,String operator,String searchType,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    rcSelectValue(value,operator,searchType,BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    waitBeforeDrop(delayBeforeDrop);
    ((RobotJavaFXImpl)getRobot()).shakeMouse();
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
  }
}","@Override public void rcDropValue(String value,String operator,String searchType,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    ListCell<?> targetCell=((ListViewAdapter<ListView<?>>)getComponent()).getCell(value);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    rcSelectValue(value,operator,searchType,BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    Node listView=((Node)getRealComponent());
    listView.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    dndHelper.setDragMode(false);
  }
}",0.4912536443148688
95484,"@Override public void rcDropIndex(int index,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    rcSelectIndex(String.valueOf(index),BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    waitBeforeDrop(delayBeforeDrop);
    ((RobotJavaFXImpl)getRobot()).shakeMouse();
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
  }
}","@Override public void rcDropIndex(int index,int delayBeforeDrop){
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  try {
    ListCell<?> targetCell=((ListViewAdapter<ListView<?>>)getComponent()).getCell(index);
    if (targetCell == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
    }
    rcSelectIndex(String.valueOf(index),BinaryChoice.no.rcValue(),dndHelper.getMouseButton(),0);
    waitBeforeDrop(delayBeforeDrop);
  }
  finally {
    getRobot().mouseRelease(null,null,dndHelper.getMouseButton());
    pressOrReleaseModifiers(dndHelper.getModifier(),false);
    Node listView=((Node)getRealComponent());
    listView.removeEventFilter(ScrollToEvent.ANY,m_scrollConsumer);
    dndHelper.setDragMode(false);
  }
}",0.4604651162790698
95485,"/** 
 * run a test job
 */
private void doTestJob(){
  String tjName=m_job.getTestJob().getName();
  sysOut(NLS.bind(Messages.ExecutionControllerTestJobBegin,tjName));
  sysOut(NLS.bind(Messages.ExecutionControllerTestJobExpectedTestSuites,new Object[]{tjName,m_job.getTestJob().getNodeListSize()}));
  List<INodePO> executedTestSuites=ClientTest.instance().startTestJob(m_job.getTestJob(),m_job.isAutoScreenshot(),m_job.getNoRunOptMode());
  sysOut(NLS.bind(Messages.ExecutionControllerTestJobExecutedTestSuites,new Object[]{tjName,executedTestSuites.size()}));
  Iterator<INodePO> tsIterator=m_job.getTestJob().getNodeListIterator();
  waitForReportingToFinish(TimeoutConstants.CLIENT_REPORTING_AFTER_FAILURE_TIMEOUT);
  while (tsIterator.hasNext()) {
    INodePO testsuite=tsIterator.next();
    if (!executedTestSuites.contains(testsuite)) {
      sysErr(NLS.bind(Messages.ExecutionControllerTestJobUnsuccessfulTestSuites,new Object[]{tjName,testsuite.getName()}));
    }
  }
}","/** 
 * run a test job
 */
private void doTestJob(){
  String tjName=m_job.getTestJob().getName();
  sysOut(NLS.bind(Messages.ExecutionControllerTestJobBegin,tjName));
  sysOut(NLS.bind(Messages.ExecutionControllerTestJobExpectedTestSuites,new Object[]{tjName,m_job.getTestJob().getNodeListSize()}));
  List<INodePO> executedTestSuites=ClientTest.instance().startTestJob(m_job.getTestJob(),m_job.isAutoScreenshot(),m_job.getIterMax(),m_job.getNoRunOptMode());
  sysOut(NLS.bind(Messages.ExecutionControllerTestJobExecutedTestSuites,new Object[]{tjName,executedTestSuites.size()}));
  Iterator<INodePO> tsIterator=m_job.getTestJob().getNodeListIterator();
  waitForReportingToFinish(TimeoutConstants.CLIENT_REPORTING_AFTER_FAILURE_TIMEOUT);
  while (tsIterator.hasNext()) {
    INodePO testsuite=tsIterator.next();
    if (!executedTestSuites.contains(testsuite)) {
      sysErr(NLS.bind(Messages.ExecutionControllerTestJobUnsuccessfulTestSuites,new Object[]{tjName,testsuite.getName()}));
    }
  }
}",0.9904088844018172
95486,"/** 
 * execute a test suite
 */
private void doTestSuite(){
  while (m_job.getActualTestSuite() != null && !m_stopProcessing) {
    while (m_idle && !m_stopProcessing) {
      TimeUtil.delay(50);
    }
    if (m_job.getActualTestSuite() != null && !m_stopProcessing && !m_idle && !m_isFirstAutStart) {
      ITestSuitePO ts=m_job.getActualTestSuite();
      m_idle=true;
      sysOut(StringConstants.TAB + NLS.bind(Messages.ExecutionControllerTestSuiteBegin,ts.getName()));
      ClientTest.instance().startTestSuite(ts,m_startedAutId != null ? m_startedAutId : m_job.getAutId(),m_job.isAutoScreenshot(),null,m_job.getNoRunOptMode(),null);
    }
  }
  waitForReportingToFinish(TimeoutConstants.CLIENT_REPORTING_AFTER_FAILURE_TIMEOUT);
}","/** 
 * execute a test suite
 */
private void doTestSuite(){
  while (m_job.getActualTestSuite() != null && !m_stopProcessing) {
    while (m_idle && !m_stopProcessing) {
      TimeUtil.delay(50);
    }
    if (m_job.getActualTestSuite() != null && !m_stopProcessing && !m_idle && !m_isFirstAutStart) {
      ITestSuitePO ts=m_job.getActualTestSuite();
      m_idle=true;
      sysOut(StringConstants.TAB + NLS.bind(Messages.ExecutionControllerTestSuiteBegin,ts.getName()));
      ClientTest.instance().startTestSuite(ts,m_startedAutId != null ? m_startedAutId : m_job.getAutId(),m_job.isAutoScreenshot(),m_job.getIterMax(),null,m_job.getNoRunOptMode(),null);
    }
  }
  waitForReportingToFinish(TimeoutConstants.CLIENT_REPORTING_AFTER_FAILURE_TIMEOUT);
}",0.987273945077026
95487,"/** 
 * {@inheritDoc}
 */
public void stackIncremented(INodePO node){
  String nodeType=StringConstants.EMPTY;
  String name=String.valueOf(node.getName());
  if (node instanceof IEventExecTestCasePO) {
    IEventExecTestCasePO evPo=(IEventExecTestCasePO)node;
    if (evPo.getReentryProp() != ReentryProperty.RETRY) {
      setNoErrorWhileExecution(false);
    }
    nodeType=Messages.EventHandler;
  }
 else   if (node instanceof IRefTestSuitePO) {
    nodeType=Messages.TestSuite;
    name=NodeNameUtil.getText((IRefTestSuitePO)node);
  }
 else   if (node instanceof IExecTestCasePO) {
    nodeType=Messages.TestCase;
    name=NodeNameUtil.getText((IExecTestCasePO)node,false);
  }
  StringBuilder sb=new StringBuilder(nodeType);
  sb.append(StringConstants.COLON);
  sb.append(StringConstants.SPACE);
  sb.append(name);
  sysOut(sb.toString());
}","/** 
 * {@inheritDoc}
 */
public void stackIncremented(INodePO node){
  String nodeType=StringConstants.EMPTY;
  String name=String.valueOf(node.getName());
  if (node instanceof IEventExecTestCasePO) {
    IEventExecTestCasePO evPo=(IEventExecTestCasePO)node;
    if (evPo.getReentryProp() != ReentryProperty.RETRY) {
      setNoErrorWhileExecution(false);
    }
    nodeType=Messages.EventHandler;
  }
 else   if (node instanceof IRefTestSuitePO) {
    nodeType=Messages.TestSuite;
    name=NodeNameUtil.getText((IRefTestSuitePO)node);
  }
 else   if (node instanceof IExecTestCasePO) {
    nodeType=Messages.TestCase;
    name=NodeNameUtil.getText((IExecTestCasePO)node,false);
  }
 else   if (node instanceof IConditionalStatementPO) {
    nodeType=Messages.Conditional;
  }
 else   if (node instanceof IAbstractContainerPO) {
    nodeType=Messages.Container;
  }
 else   if (node instanceof IDoWhilePO) {
    nodeType=Messages.DoWhile;
  }
 else   if (node instanceof IWhileDoPO) {
    nodeType=Messages.WhileDo;
  }
 else   if (node instanceof IIteratePO) {
    nodeType=Messages.Iterate;
  }
  StringBuilder sb=new StringBuilder(nodeType);
  sb.append(StringConstants.COLON);
  sb.append(StringConstants.SPACE);
  sb.append(name);
  sysOut(sb.toString());
}",0.804162724692526
95488,"/** 
 * {@inheritDoc}
 */
protected void extendValidate(JobConfiguration job,StringBuilder errorMsgs,StringBuilder errorInvalidArgsMsg){
  if (job.getProjectName() == null) {
    appendError(errorMsgs,ClientTestStrings.PROJECT,ClientTestStrings.PROJECT_NAME);
  }
  if (job.getProjectVersion() == null) {
    appendError(errorMsgs,ClientTestStrings.PROJECT_VERSION,ClientTestStrings.PROJECT_VERSION_EX);
  }
  if (job.getProjectVersion() != null && job.getProjectVersion().getMajorNumber() == null && job.getProjectVersion().getVersionQualifier() == null) {
    appendValidationError(errorInvalidArgsMsg,ClientTestStrings.PROJECT_VERSION,ClientTestStrings.PROJECT_VERSION_EX);
  }
  if (job.getPort() == Constants.INVALID_VALUE) {
    appendError(errorMsgs,ClientTestStrings.PORT,ClientTestStrings.PORT_NUMBER);
  }
  if ((job.getServer() != null) && (job.getPort() == 0)) {
    appendError(errorMsgs,ClientTestStrings.PORT,ClientTestStrings.PORT_NUMBER);
  }
  if (job.getAutConfigName() == null && job.getAutId() == null && job.getTestJobName() == null) {
    appendError(errorMsgs,ClientTestStrings.AUT_CONFIG,ClientTestStrings.AUT_CONFIG);
    appendError(errorMsgs,ClientTestStrings.AUT_ID,ClientTestStrings.AUT_ID);
  }
  if (job.getTestSuiteNames().isEmpty() && job.getTestJobName() == null) {
    appendError(errorMsgs,ClientTestStrings.TESTSUITE,ClientTestStrings.TESTSUITE);
    appendError(errorMsgs,ClientTestStrings.TESTJOB,ClientTestStrings.TESTJOB);
  }
  if (job.getTimeout() < 0) {
    appendError(errorMsgs,ClientTestStrings.TIMEOUT,ClientTestStrings.TIMEOUT);
  }
  if ((!StringUtils.isEmpty(job.getNoRunOptMode())) && (job.getNoRunOptMode().equals(TestExecutionConstants.EXIT_INVALID_ARGUMENT))) {
    appendValidationError(errorInvalidArgsMsg,ClientStrings.NORUN,ClientStrings.NORUN_MODE);
  }
  if ((!StringUtils.isEmpty(job.getFileName())) && (job.getFileName().equals(TestExecutionConstants.EXIT_INVALID_ARGUMENT))) {
    appendValidationError(errorInvalidArgsMsg,ClientStrings.RESULT_NAME,ClientStrings.RESULT_NAME);
  }
}","/** 
 * {@inheritDoc}
 */
protected void extendValidate(JobConfiguration job,StringBuilder errorMsgs,StringBuilder errorInvalidArgsMsg){
  if (job.getProjectName() == null) {
    appendError(errorMsgs,ClientTestStrings.PROJECT,ClientTestStrings.PROJECT_NAME);
  }
  if (job.getProjectVersion() == null) {
    appendError(errorMsgs,ClientTestStrings.PROJECT_VERSION,ClientTestStrings.PROJECT_VERSION_EX);
  }
  if (job.getProjectVersion() != null && job.getProjectVersion().getMajorNumber() == null && job.getProjectVersion().getVersionQualifier() == null) {
    appendValidationError(errorInvalidArgsMsg,ClientTestStrings.PROJECT_VERSION,ClientTestStrings.PROJECT_VERSION_EX);
  }
  if (job.getPort() == Constants.INVALID_VALUE) {
    appendError(errorMsgs,ClientTestStrings.PORT,ClientTestStrings.PORT_NUMBER);
  }
  if (job.getIterMax() == Constants.INVALID_VALUE) {
    appendError(errorMsgs,ClientTestStrings.ITER_MAX,ClientTestStrings.ITER_MAX);
  }
  if ((job.getServer() != null) && (job.getPort() == 0)) {
    appendError(errorMsgs,ClientTestStrings.PORT,ClientTestStrings.PORT_NUMBER);
  }
  if (job.getAutConfigName() == null && job.getAutId() == null && job.getTestJobName() == null) {
    appendError(errorMsgs,ClientTestStrings.AUT_CONFIG,ClientTestStrings.AUT_CONFIG);
    appendError(errorMsgs,ClientTestStrings.AUT_ID,ClientTestStrings.AUT_ID);
  }
  if (job.getTestSuiteNames().isEmpty() && job.getTestJobName() == null) {
    appendError(errorMsgs,ClientTestStrings.TESTSUITE,ClientTestStrings.TESTSUITE);
    appendError(errorMsgs,ClientTestStrings.TESTJOB,ClientTestStrings.TESTJOB);
  }
  if (job.getTimeout() < 0) {
    appendError(errorMsgs,ClientTestStrings.TIMEOUT,ClientTestStrings.TIMEOUT);
  }
  if ((!StringUtils.isEmpty(job.getNoRunOptMode())) && (job.getNoRunOptMode().equals(TestExecutionConstants.EXIT_INVALID_ARGUMENT))) {
    appendValidationError(errorInvalidArgsMsg,ClientStrings.NORUN,ClientStrings.NORUN_MODE);
  }
  if ((!StringUtils.isEmpty(job.getFileName())) && (job.getFileName().equals(TestExecutionConstants.EXIT_INVALID_ARGUMENT))) {
    appendValidationError(errorInvalidArgsMsg,ClientStrings.RESULT_NAME,ClientStrings.RESULT_NAME);
  }
}",0.9671627687219466
95489,"/** 
 * {@inheritDoc}
 */
protected void extendOptions(Options options,boolean req){
  options.addOption(createOption(ClientTestStrings.SERVER,true,ClientTestStrings.HOSTNAME,Messages.ClientServerOpt,false));
  options.addOption(createOption(ClientTestStrings.PORT,true,ClientTestStrings.PORT_NUMBER,Messages.ClientPortOpt,false));
  options.addOption(createOption(ClientTestStrings.PROJECT,true,ClientTestStrings.PROJECT_NAME,Messages.ClientProjectOpt,req));
  options.addOption(createOption(ClientTestStrings.PROJECT_VERSION,true,ClientTestStrings.PROJECT_VERSION_EX,Messages.ClientProjectVersionOpt,req));
  options.addOption(createOption(ClientTestStrings.RESULTDIR,true,ClientTestStrings.RESULTDIR,Messages.ClientResultdirOpt,false));
  options.addOption(createOption(ClientStrings.RESULT_NAME,true,ClientStrings.RESULT_NAME,Messages.ClientResultnameOpt,false));
  OptionGroup autOptionGroup=new OptionGroup();
  autOptionGroup.setRequired(false);
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_CONFIG,true,ClientTestStrings.AUT_CONFIG,Messages.ClientAutconfigOpt,req));
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_ID,true,ClientTestStrings.AUT_ID,Messages.ClientAutIdOpt,req));
  options.addOptionGroup(autOptionGroup);
  OptionGroup testExecutionGroup=new OptionGroup();
  testExecutionGroup.setRequired(req);
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTJOB,true,ClientTestStrings.TESTJOB,Messages.ClientTestJobOpt,req));
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTSUITE,true,ClientTestStrings.TESTSUITE,Messages.ClientTestSuiteOpt,req));
  options.addOptionGroup(testExecutionGroup);
  options.addOption(createOption(ClientTestStrings.DATA_DIR,true,ClientTestStrings.DATA_DIR_EX,Messages.ClientDataFile,false));
  Option noRunOption=createOption(ClientStrings.NORUN,true,ClientStrings.NORUN_MODE,Messages.ClientNoRunOpt,false);
  noRunOption.setOptionalArg(true);
  options.addOption(noRunOption);
  options.addOption(createOption(ClientTestStrings.AUTO_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientAutoScreenshot,false));
  options.addOption(createOption(ClientTestStrings.NO_XML_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientNoXmlScreenshot,false));
  options.addOption(createOption(ClientTestStrings.TIMEOUT,true,ClientTestStrings.TIMEOUT,Messages.ClientTimeout,false));
  options.addOption(createOption(ClientTestStrings.GENERATE_MONITORING_REPORT,false,StringConstants.EMPTY,Messages.ClientGenerateMonitoringReport,false));
}","/** 
 * {@inheritDoc}
 */
protected void extendOptions(Options options,boolean req){
  options.addOption(createOption(ClientTestStrings.SERVER,true,ClientTestStrings.HOSTNAME,Messages.ClientServerOpt,false));
  options.addOption(createOption(ClientTestStrings.PORT,true,ClientTestStrings.PORT_NUMBER,Messages.ClientPortOpt,false));
  options.addOption(createOption(ClientTestStrings.PROJECT,true,ClientTestStrings.PROJECT_NAME,Messages.ClientProjectOpt,req));
  options.addOption(createOption(ClientTestStrings.PROJECT_VERSION,true,ClientTestStrings.PROJECT_VERSION_EX,Messages.ClientProjectVersionOpt,req));
  options.addOption(createOption(ClientTestStrings.RESULTDIR,true,ClientTestStrings.RESULTDIR,Messages.ClientResultdirOpt,false));
  options.addOption(createOption(ClientStrings.RESULT_NAME,true,ClientStrings.RESULT_NAME,Messages.ClientResultnameOpt,false));
  OptionGroup autOptionGroup=new OptionGroup();
  autOptionGroup.setRequired(false);
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_CONFIG,true,ClientTestStrings.AUT_CONFIG,Messages.ClientAutconfigOpt,req));
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_ID,true,ClientTestStrings.AUT_ID,Messages.ClientAutIdOpt,req));
  options.addOptionGroup(autOptionGroup);
  OptionGroup testExecutionGroup=new OptionGroup();
  testExecutionGroup.setRequired(req);
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTJOB,true,ClientTestStrings.TESTJOB,Messages.ClientTestJobOpt,req));
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTSUITE,true,ClientTestStrings.TESTSUITE,Messages.ClientTestSuiteOpt,req));
  options.addOptionGroup(testExecutionGroup);
  options.addOption(createOption(ClientTestStrings.DATA_DIR,true,ClientTestStrings.DATA_DIR_EX,Messages.ClientDataFile,false));
  Option noRunOption=createOption(ClientStrings.NORUN,true,ClientStrings.NORUN_MODE,Messages.ClientNoRunOpt,false);
  noRunOption.setOptionalArg(true);
  options.addOption(noRunOption);
  options.addOption(createOption(ClientTestStrings.AUTO_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientAutoScreenshot,false));
  options.addOption(createOption(ClientTestStrings.ITER_MAX,true,ClientTestStrings.ITER_MAX,Messages.IterMax,false));
  options.addOption(createOption(ClientTestStrings.NO_XML_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientNoXmlScreenshot,false));
  options.addOption(createOption(ClientTestStrings.TIMEOUT,true,ClientTestStrings.TIMEOUT,Messages.ClientTimeout,false));
  options.addOption(createOption(ClientTestStrings.GENERATE_MONITORING_REPORT,false,StringConstants.EMPTY,Messages.ClientGenerateMonitoringReport,false));
}",0.9772376543209876
95490,"/** 
 * Verifies whether the checkbox in the row of the selected cell  is checked
 * @param checked true if checkbox in cell should be selected, false otherwise
 * @throws StepExecutionException If no cell is selected or the verification fails.
 */
public void rcVerifyCheckboxInSelectedRow(boolean checked) throws StepExecutionException {
  int row=((ITableComponent)getComponent()).getSelectedCell().getRow();
  verifyCheckboxInRow(checked,row);
}","/** 
 * Verifies whether the checkbox in the row of the selected cell  is checked
 * @param checked true if checkbox in cell should be selected, false otherwise
 * @param timeout the maximum amount of time to wait to verify whether thecheckbox in the row is checked
 * @throws StepExecutionException If no cell is selected or the verification fails.
 */
public void rcVerifyCheckboxInSelectedRow(final boolean checked,int timeout) throws StepExecutionException {
  invokeAndWait(""String_Node_Str"",timeout,new Runnable(){
    public void run(){
      int row=((ITableComponent)getComponent()).getSelectedCell().getRow();
      verifyCheckboxInRow(checked,row);
    }
  }
);
}",0.7729296527159395
95491,"/** 
 * performs the extraction
 * @param newTcName the name of the new SpecTestCase
 * @param node the edited  {@link INodePO} from which to extract
 * @param selection the nodes to be extracted
 * @return an error message or null.
 */
private IExecTestCasePO performExtraction(final String newTcName,final INodePO node,final IStructuredSelection selection){
  final List<INodePO> modNodes=new ArrayList<INodePO>(selection.size());
  Iterator it=selection.iterator();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof INodePO) {
      modNodes.add((INodePO)next);
    }
  }
  if (modNodes.isEmpty()) {
    return null;
  }
  IExecTestCasePO exec=persistExtraction(node,newTcName,modNodes);
  DataEventDispatcher.getInstance().fireDataChangedListener(node,DataState.StructureModified,UpdateState.all);
  DataEventDispatcher.getInstance().fireDataChangedListener(exec,DataState.Added,UpdateState.all);
  final ISpecTestCasePO newSpecTc=exec.getSpecTestCase();
  DataEventDispatcher.getInstance().fireDataChangedListener(newSpecTc,DataState.Added,UpdateState.all);
  TestCaseBrowser tcb=MultipleTCBTracker.getInstance().getMainTCB();
  if (tcb != null) {
    tcb.getTreeViewer().setSelection(new StructuredSelection(exec),true);
  }
  return exec;
}","/** 
 * performs the extraction
 * @param newTcName the name of the new SpecTestCase
 * @param node the edited  {@link INodePO} from which to extract
 * @param selection the nodes to be extracted
 * @return an error message or null.
 */
private IExecTestCasePO performExtraction(final String newTcName,final INodePO node,final IStructuredSelection selection){
  final List<INodePO> modNodes=new ArrayList<INodePO>(selection.size());
  Iterator it=selection.iterator();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof INodePO) {
      modNodes.add((INodePO)next);
    }
  }
  if (modNodes.isEmpty()) {
    return null;
  }
  IExecTestCasePO exec=persistExtraction(node,newTcName,modNodes);
  DataEventDispatcher.getInstance().fireDataChangedListener(node,DataState.StructureModified,UpdateState.all);
  DataEventDispatcher.getInstance().fireDataChangedListener(exec,DataState.Added,UpdateState.all);
  ISpecTestCasePO newSpecTC=exec.getSpecTestCase();
  newSpecTC=GeneralStorage.getInstance().getMasterSession().find(newSpecTC.getClass(),newSpecTC.getId());
  DataEventDispatcher.getInstance().fireDataChangedListener(newSpecTC,DataState.Added,UpdateState.all);
  TestCaseBrowser tcb=MultipleTCBTracker.getInstance().getMainTCB();
  if (tcb != null) {
    tcb.getTreeViewer().setSelection(new StructuredSelection(newSpecTC),true);
  }
  return exec;
}",0.951339117314221
95492,"/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  String newTestCaseName=getNewTestCaseName(event);
  if (newTestCaseName != null) {
    ISpecTestCasePO newSpecTC=null;
    IStructuredSelection ss=getSelection();
    final List<INodePO> nodesToClone=new ArrayList<INodePO>(ss.size());
    Iterator it=ss.iterator();
    while (it.hasNext()) {
      nodesToClone.add((INodePO)it.next());
    }
    newSpecTC=createAndPerformNodeDuplication(newTestCaseName,nodesToClone);
    DataEventDispatcher.getInstance().fireDataChangedListener(newSpecTC,DataState.Added,UpdateState.all);
    TestCaseBrowser tcb=MultipleTCBTracker.getInstance().getMainTCB();
    if (tcb != null) {
      tcb.getTreeViewer().setSelection(new StructuredSelection(newSpecTC),true);
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  String newTestCaseName=getNewTestCaseName(event);
  if (newTestCaseName != null) {
    ISpecTestCasePO newSpecTC=null;
    IStructuredSelection ss=getSelection();
    final List<INodePO> nodesToClone=new ArrayList<INodePO>(ss.size());
    Iterator it=ss.iterator();
    while (it.hasNext()) {
      nodesToClone.add((INodePO)it.next());
    }
    newSpecTC=createAndPerformNodeDuplication(newTestCaseName,nodesToClone);
    newSpecTC=GeneralStorage.getInstance().getMasterSession().find(newSpecTC.getClass(),newSpecTC.getId());
    DataEventDispatcher.getInstance().fireDataChangedListener(newSpecTC,DataState.Added,UpdateState.all);
    TestCaseBrowser tcb=MultipleTCBTracker.getInstance().getMainTCB();
    if (tcb != null) {
      tcb.getTreeViewer().setSelection(new StructuredSelection(newSpecTC),true);
    }
  }
  return null;
}",0.9371362048894064
95493,"/** 
 * get the gui representation for parameter value of given param description for first dataset
 * @param node current node
 * @param desc param description belonging to searched param value
 * @param rowCount datasetNumber - 1
 * @return gui representation of parameter value for given parameter description
 */
public static String getGuiStringForParamValue(final IParameterInterfacePO node,final IParamDescriptionPO desc,int rowCount){
  String result=StringConstants.EMPTY;
  IParameterInterfacePO srcNode=node;
  IParamDescriptionPO srcDesc=desc;
  while (srcNode.getReferencedDataCube() != null) {
    srcNode=srcNode.getReferencedDataCube();
    srcDesc=srcNode.getParameterForName(srcDesc.getName());
    if (srcDesc == null || !desc.getType().equals(srcDesc.getType())) {
      return result;
    }
  }
  if (srcDesc == null) {
    return result;
  }
  int col=srcNode.getDataManager().findColumnForParam(srcDesc.getUniqueId());
  if (col > -1 && srcNode.getDataManager().getDataSetCount() > rowCount) {
    IDataSetPO row=srcNode.getDataManager().getDataSet(rowCount);
    try {
      String td=row.getValueAt(col);
      ParamValueConverter conv=new ModelParamValueConverter(td,srcNode,srcDesc);
      result=conv.getGuiString();
    }
 catch (    IndexOutOfBoundsException e) {
    }
  }
  if (col >= -1 && StringUtils.isBlank(result)) {
    if (srcNode instanceof IExecTestCasePO) {
      INodePO specNode=srcNode.getSpecificationUser();
      specNode=((IExecTestCasePO)srcNode).getSpecTestCase();
      if (specNode instanceof ISpecTestCasePO) {
        result=getValueForSpecNodeWithParamDesc(srcDesc,(ISpecTestCasePO)specNode,col);
      }
    }
  }
  return result;
}","/** 
 * get the gui representation for parameter value of given param description for first dataset
 * @param node current node
 * @param desc param description belonging to searched param value
 * @param rowCount datasetNumber - 1
 * @return gui representation of parameter value for given parameter description
 */
public static String getGuiStringForParamValue(final IParameterInterfacePO node,final IParamDescriptionPO desc,int rowCount){
  String result=StringConstants.EMPTY;
  IParameterInterfacePO srcNode=node;
  IParamDescriptionPO srcDesc=desc;
  while (srcNode.getReferencedDataCube() != null) {
    srcNode=srcNode.getReferencedDataCube();
    srcDesc=srcNode.getParameterForName(srcDesc.getName());
    if (srcDesc == null || !desc.getType().equals(srcDesc.getType())) {
      return result;
    }
  }
  if (srcDesc == null) {
    return result;
  }
  int col=srcNode.getDataManager().findColumnForParam(srcDesc.getUniqueId());
  boolean colNotExistend=false;
  boolean foundCol=false;
  int dataSetCount=srcNode.getDataManager().getDataSetCount();
  if (col > -1 && dataSetCount > rowCount) {
    IDataSetPO row=srcNode.getDataManager().getDataSet(rowCount);
    try {
      String td=row.getValueAt(col);
      ParamValueConverter conv=new ModelParamValueConverter(td,srcNode,srcDesc);
      result=conv.getGuiString();
      foundCol=true;
    }
 catch (    IndexOutOfBoundsException e) {
      colNotExistend=true;
    }
  }
  if (col == -1 || colNotExistend || (dataSetCount <= srcNode.getParameterListSize() && StringUtils.isBlank(result) && !foundCol)) {
    if (srcNode instanceof IExecTestCasePO) {
      INodePO specNode=srcNode.getSpecificationUser();
      specNode=((IExecTestCasePO)srcNode).getSpecTestCase();
      if (specNode instanceof ISpecTestCasePO) {
        result=getValueForSpecNodeWithParamDesc(srcDesc,(ISpecTestCasePO)specNode);
      }
    }
  }
  return result;
}",0.9193548387096774
95494,"/** 
 * Updates the test data manager of the passed node by writing the value contained in converter into the appropriate cell.
 * @param conv converter contains parameter value to write
 * @param dataSetRow The row of the test data manager
 */
protected void writeTestDataEntry(GuiParamValueConverter conv,int dataSetRow){
  String oldTd=null;
  final IParamDescriptionPO desc=conv.getDesc();
  try {
    oldTd=conv.getCurrentNode().getDataManager().getCell(dataSetRow,desc);
  }
 catch (  IndexOutOfBoundsException e) {
  }
  String td=createOrUpdateTestData(oldTd,conv);
  conv.getCurrentNode().getDataManager().updateCell(td,dataSetRow,desc.getUniqueId());
}","/** 
 * Updates the test data manager of the passed node by writing the value contained in converter into the appropriate cell.
 * @param conv converter contains parameter value to write
 * @param dataSetRow The row of the test data manager
 */
protected void writeTestDataEntry(GuiParamValueConverter conv,int dataSetRow){
  String oldTd=null;
  final IParamDescriptionPO desc=conv.getDesc();
  IParameterInterfacePO currentNode=conv.getCurrentNode();
  ITDManager dataManager=currentNode.getDataManager();
  try {
    oldTd=dataManager.getCell(dataSetRow,desc);
  }
 catch (  IndexOutOfBoundsException e) {
  }
  String td=createOrUpdateTestData(oldTd,conv);
  if (dataManager.getDataSetCount() <= dataSetRow) {
    addDataSet(currentNode,dataSetRow);
  }
  dataManager.updateCell(td,dataSetRow,desc.getUniqueId());
}",0.7859554355165429
95495,"/** 
 * Adds a new data set into the given row of the given IParameterInterface
 * @param obj the IParameterInterface object
 * @param row the row to insert
 */
public void addDataSet(IParameterInterfacePO obj,int row){
  obj.getDataManager().insertDataSet(row);
}","/** 
 * Adds a new data set into the given row of the given IParameterInterface
 * @param obj the IParameterInterface object
 * @param row the row to insert
 */
public void addDataSet(IParameterInterfacePO obj,int row){
  IExecTestCasePO exec=(IExecTestCasePO)obj;
  ISpecTestCasePO spec=exec.getSpecTestCase();
  ITDManager dataManager=exec.getDataManager();
  int i=0;
  List<String> list=new ArrayList<String>();
  while (i < dataManager.getUniqueIds().size()) {
    String uuid=dataManager.getUniqueIds().get(i);
    IParamDescriptionPO uniqueID=exec.getParameterForUniqueId(uuid);
    String value=getValueForSpecNodeWithParamDesc(uniqueID,spec);
    list.add(value);
    i++;
  }
  IDataSetPO dataSet=PoMaker.createListWrapperPO(list);
  obj.getDataManager().insertDataSet(dataSet,row);
}",0.44234404536862
95496,"/** 
 * Gets the value (including default value if there is a cap in the spec)
 * @param srcDesc the {@link IParamDescriptionPO} of the parameter to get the value for
 * @param specNode the spec node to check
 * @param column the column number
 * @return the value for a combination of {@link ISpecTestCasePO} column and {@link IParamDescriptionPO}
 */
public static String getValueForSpecNodeWithParamDesc(IParamDescriptionPO srcDesc,ISpecTestCasePO specNode,int column){
  List<INodePO> list=specNode.getUnmodifiableNodeList();
  if (list.size() == 1) {
    INodePO possibleCap=list.get(0);
    if (possibleCap instanceof ICapPO) {
      ICapPO cap=(ICapPO)possibleCap;
      List<IDataSetPO> datasets=cap.getDataManager().getDataSets();
      if (datasets.size() == 1) {
        IDataSetPO set=datasets.get(0);
        int i=0;
        for (        String string : set.getColumnStringValues()) {
          if (string.contains(srcDesc.getUniqueId())) {
            return getDefaultValue(cap,i);
          }
          i++;
        }
      }
    }
  }
  return null;
}","/** 
 * Gets the value (including default value if there is a cap in the spec)
 * @param srcDesc the {@link IParamDescriptionPO} of the parameter to get the value for
 * @param specNode the spec node to check
 * @return the value for a combination of {@link ISpecTestCasePO} column and {@link IParamDescriptionPO}
 */
public static String getValueForSpecNodeWithParamDesc(IParamDescriptionPO srcDesc,ISpecTestCasePO specNode){
  List<INodePO> list=specNode.getUnmodifiableNodeList();
  if (list.size() == 1) {
    INodePO possibleCap=list.get(0);
    if (possibleCap instanceof ICapPO) {
      ICapPO cap=(ICapPO)possibleCap;
      List<IDataSetPO> datasets=cap.getDataManager().getDataSets();
      if (datasets.size() == 1) {
        IDataSetPO set=datasets.get(0);
        int i=0;
        for (        String string : set.getColumnStringValues()) {
          if (string.contains(srcDesc.getUniqueId())) {
            return getDefaultValue(cap,i);
          }
          i++;
        }
      }
    }
  }
  return null;
}",0.959847036328872
95497,"/** 
 * {@inheritDoc} 
 */
public boolean isTestDataComplete(){
  if (StringUtils.isEmpty(getDataFile())) {
    final int paramListSize=getParameterListSize();
    ITDManager testDataManager=getDataManager();
    List<IParamDescriptionPO> requiredParameters=new ArrayList<IParamDescriptionPO>(getParameterList());
    IParameterInterfacePO refDataCube=getReferencedDataCube();
    for (int i=0; i < testDataManager.getDataSetCount(); i++) {
      for (      IParamDescriptionPO paramDesc : requiredParameters) {
        int column=testDataManager.findColumnForParam(paramDesc.getUniqueId());
        if (refDataCube != null) {
          IParamDescriptionPO dataCubeParam=refDataCube.getParameterForName(paramDesc.getName());
          if (dataCubeParam != null) {
            column=testDataManager.findColumnForParam(dataCubeParam.getUniqueId());
          }
        }
        if (column >= -1) {
          List<INodePO> nodes=null;
          if (this instanceof IExecTestCasePO) {
            IExecTestCasePO exec=(IExecTestCasePO)this;
            nodes=exec.getSpecTestCase().getUnmodifiableNodeList();
            String result=AbstractParamInterfaceBP.getValueForSpecNodeWithParamDesc(paramDesc,exec.getSpecTestCase(),column);
            if (StringUtils.isNotBlank(result)) {
              return true;
            }
          }
        }
        String value=TestDataBP.INSTANCE.getTestData(this,testDataManager,paramDesc,i);
        if (StringUtils.isNotEmpty(value)) {
          ModelParamValueConverter mpvc=new ModelParamValueConverter(value,this,paramDesc);
          List<RefToken> referenceTokens=mpvc.getRefTokens();
          String uiValue=mpvc.getGuiString();
          for (          RefToken token : referenceTokens) {
            if (uiValue.contains(token.getModelString())) {
              return false;
            }
          }
        }
 else {
          if (this instanceof ICapPO) {
            ICapPO cap=(ICapPO)this;
            if (!ParamNameBP.isOptionalParameter(cap,paramDesc.getUniqueId())) {
              return false;
            }
          }
 else {
            return false;
          }
        }
      }
    }
    if ((testDataManager.getDataSetCount() == 0) && (paramListSize > 0)) {
      return false;
    }
    if (getParameterListSize() > testDataManager.getColumnCount()) {
      return false;
    }
  }
  return true;
}","/** 
 * {@inheritDoc} 
 */
public boolean isTestDataComplete(){
  if (StringUtils.isEmpty(getDataFile())) {
    final int paramListSize=getParameterListSize();
    ITDManager testDataManager=getDataManager();
    List<IParamDescriptionPO> requiredParameters=new ArrayList<IParamDescriptionPO>(getParameterList());
    IParameterInterfacePO refDataCube=getReferencedDataCube();
    for (int i=0; i < testDataManager.getDataSetCount(); i++) {
      for (      IParamDescriptionPO paramDesc : requiredParameters) {
        int column=testDataManager.findColumnForParam(paramDesc.getUniqueId());
        if (refDataCube != null) {
          IParamDescriptionPO dataCubeParam=refDataCube.getParameterForName(paramDesc.getName());
          if (dataCubeParam != null) {
            column=testDataManager.findColumnForParam(dataCubeParam.getUniqueId());
          }
        }
        String value=TestDataBP.INSTANCE.getTestData(this,testDataManager,paramDesc,i);
        if (StringUtils.isBlank(value) && column >= -1) {
          if (this instanceof IExecTestCasePO) {
            IExecTestCasePO exec=(IExecTestCasePO)this;
            String result=AbstractParamInterfaceBP.getValueForSpecNodeWithParamDesc(paramDesc,exec.getSpecTestCase());
            if (value == null && StringUtils.isNotBlank(result)) {
              value=result;
            }
            if (StringUtils.isBlank(result)) {
              return false;
            }
          }
        }
        if (StringUtils.isNotEmpty(value)) {
          ModelParamValueConverter mpvc=new ModelParamValueConverter(value,this,paramDesc);
          List<RefToken> referenceTokens=mpvc.getRefTokens();
          String uiValue=mpvc.getGuiString();
          for (          RefToken token : referenceTokens) {
            if (uiValue.contains(token.getModelString())) {
              return false;
            }
          }
        }
 else {
          if (this instanceof ICapPO) {
            ICapPO cap=(ICapPO)this;
            if (!ParamNameBP.isOptionalParameter(cap,paramDesc.getUniqueId())) {
              return false;
            }
          }
 else {
            return false;
          }
        }
      }
    }
    if ((testDataManager.getDataSetCount() == 0) && (paramListSize > 0)) {
      return checkSpecForIncompleteData();
    }
  }
  return true;
}",0.7584149978696207
95498,"/** 
 * This method is also searching for default values if in the Exec there is only one CAP
 * @param node if this is a {@link IExecTestCasePO} we are also searching ifthere are default values
 * @param desc the {@link IParamDescriptionPO} to get the correct value forthe parameter
 * @param tdManager the data manger
 * @param dataSetIndex the index for the data set
 * @return the value (also default value) for the node
 */
private String getDataForExec(INodePO node,IParamDescriptionPO desc,ITDManager tdManager,int dataSetIndex){
  String data=StringConstants.EMPTY;
  try {
    data=tdManager.getCell(dataSetIndex,desc);
  }
 catch (  IndexOutOfBoundsException e) {
  }
  if (StringUtils.isBlank(data) && node instanceof IExecTestCasePO) {
    INodePO specNode=((IExecTestCasePO)node).getSpecTestCase();
    if (specNode instanceof ISpecTestCasePO) {
      data=AbstractParamInterfaceBP.getValueForSpecNodeWithParamDesc(desc,(ISpecTestCasePO)specNode,dataSetIndex);
    }
  }
  return data;
}","/** 
 * This method is also searching for default values if in the Exec there is only one CAP
 * @param node if this is a {@link IExecTestCasePO} we are also searching ifthere are default values
 * @param desc the {@link IParamDescriptionPO} to get the correct value forthe parameter
 * @param tdManager the data manger
 * @param dataSetIndex the index for the data set
 * @return the value (also default value) for the node
 */
private String getDataForExec(INodePO node,IParamDescriptionPO desc,ITDManager tdManager,int dataSetIndex){
  String data=StringConstants.EMPTY;
  boolean cellNotFound=false;
  try {
    data=tdManager.getCell(dataSetIndex,desc);
  }
 catch (  IndexOutOfBoundsException e) {
    cellNotFound=true;
  }
  if (cellNotFound && StringUtils.isBlank(data) && node instanceof IExecTestCasePO) {
    INodePO specNode=((IExecTestCasePO)node).getSpecTestCase();
    if (specNode instanceof ISpecTestCasePO) {
      data=AbstractParamInterfaceBP.getValueForSpecNodeWithParamDesc(desc,(ISpecTestCasePO)specNode);
    }
  }
  return data;
}",0.9601167315175098
95499,"/** 
 * fill test jobs
 * @param tjDTO will be contained the test jobs info
 * @param tj test job object
 */
private void fillTestJob(TestJobDTO tjDTO,ITestJobPO tj){
  for (  Object child : tj.getUnmodifiableNodeList()) {
    if (child instanceof IRefTestSuitePO) {
      IRefTestSuitePO rts=(IRefTestSuitePO)child;
      RefTestSuiteDTO rtsDTO=new RefTestSuiteDTO(rts);
      rtsDTO.setName(rts.getRealName());
      rtsDTO.setUuid(rts.getGuid());
      rtsDTO.setTsUuid(rts.getTestSuiteGuid());
      rtsDTO.setAutId(rts.getTestSuiteAutID());
      tjDTO.addRefTestSuite(rtsDTO);
    }
  }
}","/** 
 * fill test jobs
 * @param tjDTO will be contained the test jobs info
 * @param tj test job object
 */
private void fillTestJob(TestJobDTO tjDTO,ITestJobPO tj){
  for (  INodePO child : tj.getUnmodifiableNodeList()) {
    if (child instanceof IRefTestSuitePO) {
      IRefTestSuitePO rts=(IRefTestSuitePO)child;
      RefTestSuiteDTO rtsDTO=new RefTestSuiteDTO(rts);
      rtsDTO.setName(rts.getRealName());
      rtsDTO.setUuid(rts.getGuid());
      rtsDTO.setTsUuid(rts.getTestSuiteGuid());
      rtsDTO.setAutId(rts.getTestSuiteAutID());
      tjDTO.addRefTestSuite(rtsDTO);
    }
 else     if (child instanceof ICommentPO) {
      tjDTO.addComment(new CommentDTO((ICommentPO)child));
    }
  }
}",0.9053117782909932
95500,"/** 
 * fill test suites
 * @param tsDTO will be contained the test suites info
 * @param po test suite object
 */
private void fillTestsuite(TestSuiteDTO tsDTO,ITestSuitePO po){
  if (po.getAut() != null) {
    tsDTO.setSelectedAut(ImportExportUtil.i2str(po.getAut().getId()));
  }
 else {
    tsDTO.setSelectedAut(null);
  }
  tsDTO.setStepDelay(po.getStepDelay());
  tsDTO.setRelevant(po.getRelevant());
  for (  INodePO o : po.getUnmodifiableNodeList()) {
    if (o instanceof IExecTestCasePO) {
      IExecTestCasePO tc=(IExecTestCasePO)o;
      RefTestCaseDTO rtcDTO=new RefTestCaseDTO(tc);
      fillRefTestCase(rtcDTO,tc);
      tsDTO.addUsedTestcase(rtcDTO);
    }
  }
  for (  Object o : po.getDefaultEventHandler().keySet()) {
    String eventType=(String)o;
    Integer evProp=po.getDefaultEventHandler().get(eventType);
    ReentryProperty.Enum reentryProperty=ReentryProperty.Enum.forInt(evProp);
    DefaultEventHandlerDTO ehDTO=new DefaultEventHandlerDTO();
    ehDTO.setEvent(eventType);
    ehDTO.setReentryProperty(reentryProperty.toString());
    if (reentryProperty == ReentryProperty.RETRY) {
      ehDTO.setMaxRetries(1);
    }
    tsDTO.addEventHandler(ehDTO);
  }
}","/** 
 * fill test suites
 * @param tsDTO will be contained the test suites info
 * @param po test suite object
 */
private void fillTestsuite(TestSuiteDTO tsDTO,ITestSuitePO po){
  if (po.getAut() != null) {
    tsDTO.setSelectedAut(ImportExportUtil.i2str(po.getAut().getId()));
  }
 else {
    tsDTO.setSelectedAut(null);
  }
  tsDTO.setStepDelay(po.getStepDelay());
  tsDTO.setRelevant(po.getRelevant());
  for (  INodePO o : po.getUnmodifiableNodeList()) {
    if (o instanceof IExecTestCasePO) {
      IExecTestCasePO tc=(IExecTestCasePO)o;
      RefTestCaseDTO rtcDTO=new RefTestCaseDTO(tc);
      fillRefTestCase(rtcDTO,tc);
      tsDTO.addUsedTestCase(rtcDTO);
    }
 else     if (o instanceof ICommentPO) {
      ICommentPO commentPO=(ICommentPO)o;
      CommentDTO commentDTO=new CommentDTO(commentPO);
      tsDTO.addUsedTestCase(commentDTO);
    }
  }
  for (  Object o : po.getDefaultEventHandler().keySet()) {
    String eventType=(String)o;
    Integer evProp=po.getDefaultEventHandler().get(eventType);
    ReentryProperty.Enum reentryProperty=ReentryProperty.Enum.forInt(evProp);
    DefaultEventHandlerDTO ehDTO=new DefaultEventHandlerDTO();
    ehDTO.setEvent(eventType);
    ehDTO.setReentryProperty(reentryProperty.toString());
    if (reentryProperty == ReentryProperty.RETRY) {
      ehDTO.setMaxRetries(1);
    }
    tsDTO.addEventHandler(ehDTO);
  }
}",0.9216374269005848
95501,"/** 
 * fill test cases
 * @param tcDTO will be contained the test case info
 * @param po spec test case object
 */
private void fillTestCase(TestCaseDTO tcDTO,ISpecTestCasePO po){
  for (  Object o : po.getUnmodifiableNodeList()) {
    if (o instanceof ICapPO) {
      ICapPO capPO=(ICapPO)o;
      CapDTO capDTO=new CapDTO(capPO);
      fillCap(capDTO,capPO);
      tcDTO.addTestStep(capDTO);
    }
 else     if (o instanceof IExecTestCasePO) {
      IExecTestCasePO tcPO=(IExecTestCasePO)o;
      RefTestCaseDTO refTestCaseDTO=new RefTestCaseDTO(tcPO);
      fillRefTestCase(refTestCaseDTO,tcPO);
      tcDTO.addTestStep(refTestCaseDTO);
    }
  }
  for (  IParamDescriptionPO paramPO : po.getParameterList()) {
    ParamDescriptionDTO pdDTO=new ParamDescriptionDTO();
    fillParamDescription(pdDTO,paramPO);
    tcDTO.addParameterDescription(pdDTO);
  }
  tcDTO.setInterfaceLocked(po.isInterfaceLocked());
  tcDTO.setDatafile(po.getDataFile());
  if (po.getReferencedDataCube() != null) {
    tcDTO.setReferencedTestData(po.getReferencedDataCube().getName());
  }
  final ITDManager dataManager=po.getDataManager();
  if (dataManager != null) {
    if (po.getReferencedDataCube() == null) {
      TDManagerDTO tdmDTO=new TDManagerDTO();
      fillTDManager(tdmDTO,dataManager);
      tcDTO.setTDManager(tdmDTO);
    }
  }
  for (  Object o : po.getEventExecTcMap().keySet()) {
    IEventExecTestCasePO evTc=po.getEventExecTC((String)o);
    EventTestCaseDTO etcDTO=new EventTestCaseDTO(evTc);
    fillEventTestCase(etcDTO,evTc);
    tcDTO.addEventTestcase(etcDTO);
  }
}","/** 
 * fill test cases
 * @param tcDTO will be contained the test case info
 * @param po spec test case object
 */
private void fillTestCase(TestCaseDTO tcDTO,ISpecTestCasePO po){
  for (  Object o : po.getUnmodifiableNodeList()) {
    if (o instanceof ICapPO) {
      ICapPO capPO=(ICapPO)o;
      CapDTO capDTO=new CapDTO(capPO);
      fillCap(capDTO,capPO);
      tcDTO.addTestStep(capDTO);
    }
 else     if (o instanceof IExecTestCasePO) {
      IExecTestCasePO tcPO=(IExecTestCasePO)o;
      RefTestCaseDTO refTestCaseDTO=new RefTestCaseDTO(tcPO);
      fillRefTestCase(refTestCaseDTO,tcPO);
      tcDTO.addTestStep(refTestCaseDTO);
    }
 else     if (o instanceof ICommentPO) {
      ICommentPO commentPO=(ICommentPO)o;
      CommentDTO commentDTO=new CommentDTO(commentPO);
      tcDTO.addTestStep(commentDTO);
    }
  }
  for (  IParamDescriptionPO paramPO : po.getParameterList()) {
    ParamDescriptionDTO pdDTO=new ParamDescriptionDTO();
    fillParamDescription(pdDTO,paramPO);
    tcDTO.addParameterDescription(pdDTO);
  }
  tcDTO.setInterfaceLocked(po.isInterfaceLocked());
  tcDTO.setDatafile(po.getDataFile());
  if (po.getReferencedDataCube() != null) {
    tcDTO.setReferencedTestData(po.getReferencedDataCube().getName());
  }
  final ITDManager dataManager=po.getDataManager();
  if (dataManager != null) {
    if (po.getReferencedDataCube() == null) {
      TDManagerDTO tdmDTO=new TDManagerDTO();
      fillTDManager(tdmDTO,dataManager);
      tcDTO.setTDManager(tdmDTO);
    }
  }
  for (  Object o : po.getEventExecTcMap().keySet()) {
    IEventExecTestCasePO evTc=po.getEventExecTC((String)o);
    EventTestCaseDTO etcDTO=new EventTestCaseDTO(evTc);
    fillEventTestCase(etcDTO,evTc);
    tcDTO.addEventTestcase(etcDTO);
  }
}",0.945661963374362
95502,"/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param dto Abstraction of the TestSuiteDTO element
 * @param assignNewGuid <code>true</code> if the test suiteshould be assigned a new GUID. Otherwise <code>false</code>.
 * @return a persistent object generated from the information in the DTOelement
 */
private IExecPersistable createTestSuite(IProjectPO proj,TestSuiteDTO dto,boolean assignNewGuid){
  ITestSuitePO ts;
  if (dto.getUuid() != null && !assignNewGuid) {
    ts=NodeMaker.createTestSuitePO(dto.getName(),dto.getUuid());
  }
 else {
    ts=NodeMaker.createTestSuitePO(dto.getName());
  }
  if (assignNewGuid) {
    m_oldToNewGuids.put(dto.getUuid(),ts.getGuid());
  }
  ts.setComment(dto.getComment());
  ts.setDescription(dto.getDescription());
  ts.setTaskId(dto.getTaskId());
  ts.setTrackedChangesMap(dto.getTrackedModifications());
  if (dto.getSelectedAut() != null) {
    ts.setAut(m_autRef.get(dto.getSelectedAut()));
  }
  for (  RefTestCaseDTO ref : dto.getUsedTestcases()) {
    ts.addNode(createExecTestCase(proj,ref,assignNewGuid));
  }
  Map<String,Integer> defaultEventHandler=new HashMap<String,Integer>();
  for (  DefaultEventHandlerDTO evh : dto.getEventHandlers()) {
    defaultEventHandler.put(evh.getEvent(),org.eclipse.jubula.client.archive.schema.ReentryProperty.Enum.forString(evh.getReentryProperty()).intValue());
  }
  ts.setDefaultEventHandler(defaultEventHandler);
  ts.setStepDelay(dto.getStepDelay());
  ts.setRelevant(dto.isRelevant());
  return ts;
}","/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param dto Abstraction of the TestSuiteDTO element
 * @param assignNewGuid <code>true</code> if the test suiteshould be assigned a new GUID. Otherwise <code>false</code>.
 * @return a persistent object generated from the information in the DTOelement
 */
private IExecPersistable createTestSuite(IProjectPO proj,TestSuiteDTO dto,boolean assignNewGuid){
  ITestSuitePO ts;
  if (dto.getUuid() != null && !assignNewGuid) {
    ts=NodeMaker.createTestSuitePO(dto.getName(),dto.getUuid());
  }
 else {
    ts=NodeMaker.createTestSuitePO(dto.getName());
  }
  if (assignNewGuid) {
    m_oldToNewGuids.put(dto.getUuid(),ts.getGuid());
  }
  ts.setComment(dto.getComment());
  ts.setDescription(dto.getDescription());
  ts.setTaskId(dto.getTaskId());
  ts.setTrackedChangesMap(dto.getTrackedModifications());
  if (dto.getSelectedAut() != null) {
    ts.setAut(m_autRef.get(dto.getSelectedAut()));
  }
  for (  NodeDTO ref : dto.getUsedTestCases()) {
    if (ref instanceof RefTestCaseDTO) {
      ts.addNode(createExecTestCase(proj,(RefTestCaseDTO)ref,assignNewGuid));
    }
    if (ref instanceof CommentDTO) {
      ts.addNode(createComment((CommentDTO)ref,assignNewGuid));
    }
  }
  Map<String,Integer> defaultEventHandler=new HashMap<String,Integer>();
  for (  DefaultEventHandlerDTO evh : dto.getEventHandlers()) {
    defaultEventHandler.put(evh.getEvent(),org.eclipse.jubula.client.archive.schema.ReentryProperty.Enum.forString(evh.getReentryProperty()).intValue());
  }
  ts.setDefaultEventHandler(defaultEventHandler);
  ts.setStepDelay(dto.getStepDelay());
  ts.setRelevant(dto.isRelevant());
  return ts;
}",0.9405491868834978
95503,"/** 
 * @param dto test case dto
 * @param proj currently projectPO
 * @param stcPo if assignNewGuid is false then it is need the spec test case
 * @param assignNewGuid need we a new Guid or not
 * @throws InvalidDataException
 */
private void generateRefTestCase(TestCaseDTO dto,IProjectPO proj,ISpecTestCasePO stcPo,boolean assignNewGuid) throws InvalidDataException {
  try {
    ISpecTestCasePO tc=!assignNewGuid && stcPo != null ? stcPo : m_tcRef.get(m_oldToNewGuids.get(dto.getUuid()));
    for (    NodeDTO stepDto : dto.getTestSteps()) {
      if (stepDto instanceof CapDTO) {
        tc.addNode(createCap(proj,(CapDTO)stepDto,assignNewGuid));
      }
 else       if (stepDto instanceof RefTestCaseDTO) {
        tc.addNode(createExecTestCase(proj,(RefTestCaseDTO)stepDto,assignNewGuid));
      }
    }
    for (    EventTestCaseDTO evTcDto : dto.getEventTestcases()) {
      tc.addEventTestCase(createEventExecTestCase(proj,tc,evTcDto,assignNewGuid));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}","/** 
 * @param dto test case dto
 * @param proj currently projectPO
 * @param stcPo if assignNewGuid is false then it is need the spec test case
 * @param assignNewGuid need we a new Guid or not
 * @throws InvalidDataException
 */
private void generateRefTestCase(TestCaseDTO dto,IProjectPO proj,ISpecTestCasePO stcPo,boolean assignNewGuid) throws InvalidDataException {
  try {
    ISpecTestCasePO tc=!assignNewGuid && stcPo != null ? stcPo : m_tcRef.get(m_oldToNewGuids.get(dto.getUuid()));
    for (    NodeDTO stepDto : dto.getTestSteps()) {
      if (stepDto instanceof CapDTO) {
        tc.addNode(createCap(proj,(CapDTO)stepDto,assignNewGuid));
      }
 else       if (stepDto instanceof RefTestCaseDTO) {
        tc.addNode(createExecTestCase(proj,(RefTestCaseDTO)stepDto,assignNewGuid));
      }
 else       if (stepDto instanceof CommentDTO) {
        tc.addNode(createComment((CommentDTO)stepDto,assignNewGuid));
      }
    }
    for (    EventTestCaseDTO evTcDto : dto.getEventTestcases()) {
      tc.addEventTestCase(createEventExecTestCase(proj,tc,evTcDto,assignNewGuid));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}",0.9424036281179138
95504,"/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param dto Abstraction of the DTO element
 * @param assignNewGuid <code>true</code> if the test suitehould be assigned a new GUID. Otherwise <code>false</code>.
 * @return a persistent object generated from the information in the DTOelement
 * @throws InvalidDataException if some data is invalid when constructingan object. This should not happen for exported project, but may happen when someone generates DTO project description outside of GUIdancer.
 */
private IExecPersistable createTestJob(TestJobDTO dto,boolean assignNewGuid) throws InvalidDataException {
  ITestJobPO tj;
  if (dto.getUuid() != null && !assignNewGuid) {
    tj=NodeMaker.createTestJobPO(dto.getName(),dto.getUuid());
  }
 else {
    tj=NodeMaker.createTestJobPO(dto.getName());
  }
  tj.setComment(dto.getComment());
  tj.setDescription(dto.getDescription());
  tj.setTaskId(dto.getTaskId());
  fillTrackedChangesInformation(tj,dto);
  for (  RefTestSuiteDTO dtoRts : dto.getRefTestSuites()) {
    IRefTestSuitePO rts;
    if (assignNewGuid) {
      String testSuiteGuid=m_oldToNewGuids.get(dtoRts.getTsUuid());
      if (testSuiteGuid == null) {
        throw new InvalidDataException(""String_Node_Str"" + dtoRts.getTsUuid(),MessageIDs.E_IMPORT_PROJECT_XML_FAILED);
      }
      rts=NodeMaker.createRefTestSuitePO(dtoRts.getName(),testSuiteGuid,dtoRts.getAutId());
    }
 else {
      rts=NodeMaker.createRefTestSuitePO(dtoRts.getName(),dtoRts.getUuid(),dtoRts.getTsUuid(),dtoRts.getAutId());
    }
    rts.setComment(dtoRts.getComment());
    rts.setDescription(dtoRts.getDescription());
    tj.addNode(rts);
  }
  return tj;
}","/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param dto Abstraction of the DTO element
 * @param assignNewGuid <code>true</code> if the test suitehould be assigned a new GUID. Otherwise <code>false</code>.
 * @return a persistent object generated from the information in the DTOelement
 * @throws InvalidDataException if some data is invalid when constructingan object. This should not happen for exported project, but may happen when someone generates DTO project description outside of GUIdancer.
 */
private IExecPersistable createTestJob(TestJobDTO dto,boolean assignNewGuid) throws InvalidDataException {
  ITestJobPO tj;
  if (dto.getUuid() != null && !assignNewGuid) {
    tj=NodeMaker.createTestJobPO(dto.getName(),dto.getUuid());
  }
 else {
    tj=NodeMaker.createTestJobPO(dto.getName());
  }
  tj.setComment(dto.getComment());
  tj.setDescription(dto.getDescription());
  tj.setTaskId(dto.getTaskId());
  fillTrackedChangesInformation(tj,dto);
  for (  NodeDTO dtoRefs : dto.getRefTestSuites()) {
    if (dtoRefs instanceof RefTestSuiteDTO) {
      RefTestSuiteDTO dtoRts=(RefTestSuiteDTO)dtoRefs;
      IRefTestSuitePO rts;
      if (assignNewGuid) {
        String testSuiteGuid=m_oldToNewGuids.get(dtoRts.getTsUuid());
        if (testSuiteGuid == null) {
          throw new InvalidDataException(""String_Node_Str"" + dtoRts.getTsUuid(),MessageIDs.E_IMPORT_PROJECT_XML_FAILED);
        }
        rts=NodeMaker.createRefTestSuitePO(dtoRts.getName(),testSuiteGuid,dtoRts.getAutId());
      }
 else {
        rts=NodeMaker.createRefTestSuitePO(dtoRts.getName(),dtoRts.getUuid(),dtoRts.getTsUuid(),dtoRts.getAutId());
      }
      rts.setComment(dtoRts.getComment());
      rts.setDescription(dtoRts.getDescription());
      tj.addNode(rts);
    }
 else     if (dtoRefs instanceof CommentDTO) {
      tj.addNode(createComment((CommentDTO)dtoRefs,assignNewGuid));
    }
  }
  return tj;
}",0.922101927647214
95505,"/** 
 * @param url of import file
 * @param paramNameMapper 
 * @param compNameCache 
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise  <code>false</code>.
 * @param assignNewVersion if <code>true</code> the project will havea new project version number, otherwise it will have the stored project version from the dto.
 * @param monitor 
 * @param io console
 * @return IProjectPO new project object 
 * @throws JBVersionException 
 * @throws PMReadException 
 * @throws InterruptedException 
 * @throws ToolkitPluginException 
 * @throws PMSaveException 
 */
public IProjectPO readProject(URL url,ParamNameBPDecorator paramNameMapper,final IWritableComponentNameCache compNameCache,boolean assignNewGuid,boolean assignNewVersion,IProgressMonitor monitor,IProgressConsole io) throws JBVersionException, PMReadException, InterruptedException, ToolkitPluginException {
  SubMonitor subMonitor=SubMonitor.convert(monitor,Messages.ImportFileBPReading,2);
  IProjectPO projectPO=null;
  monitor.subTask(Messages.ImportJsonStoragePreparing);
  try (InputStream urlInputStream=url.openStream();ZipInputStream zipInputStream=new ZipInputStream(urlInputStream,StandardCharsets.UTF_8)){
    ObjectMapper mapper=new ObjectMapper();
    mapper.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);
    Map<String,Class> fileTypeMapping=new HashMap<>();
    fileTypeMapping.put(NFO,ExportInfoDTO.class);
    fileTypeMapping.put(PJT,ProjectDTO.class);
    TypeReference tr=new TypeReference<ArrayList<TestresultSummaryDTO>>(){
    }
;
    Map<String,Object> allDTOs=new HashMap<>();
    for (int i=0; i < 3; i++) {
      ZipEntry entry=zipInputStream.getNextEntry();
      String entryName=entry.getName();
      Class entryTypeMapping=fileTypeMapping.get(entryName);
      allDTOs.put(entryName,entryTypeMapping != null ? mapper.readValue(zipInputStream,entryTypeMapping) : mapper.readValue(zipInputStream,tr));
    }
    ExportInfoDTO exportDTO=(ExportInfoDTO)allDTOs.get(NFO);
    checkMinimumRequiredJSONVersion(exportDTO);
    ProjectDTO projectDTO=(ProjectDTO)allDTOs.get(PJT);
    if (!assignNewGuid && projectExists(projectDTO)) {
      existProjectHandling(io,projectDTO);
      return null;
    }
    projectPO=load(projectDTO,subMonitor.newChild(1),io,assignNewGuid,assignNewVersion,paramNameMapper,compNameCache,false);
    JsonImporter importer=new JsonImporter(monitor,io,false);
    List<TestresultSummaryDTO> summaryDTOs=(List<TestresultSummaryDTO>)allDTOs.get(RST);
    importer.initTestResultSummaries(subMonitor.newChild(1),summaryDTOs,projectPO);
  }
 catch (  IOException e) {
    if (!monitor.isCanceled()) {
      log.info(Messages.GeneralIoExeption);
      throw new PMReadException(Messages.InvalidImportFile,MessageIDs.E_IO_EXCEPTION);
    }
  }
  return projectPO;
}","/** 
 * @param url of import file
 * @param paramNameMapper 
 * @param compNameCache 
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise  <code>false</code>.
 * @param assignNewVersion if <code>true</code> the project will havea new project version number, otherwise it will have the stored project version from the dto.
 * @param monitor 
 * @param io console
 * @return IProjectPO new project object 
 * @throws JBVersionException 
 * @throws PMReadException 
 * @throws InterruptedException 
 * @throws ToolkitPluginException 
 * @throws PMSaveException 
 */
public IProjectPO readProject(URL url,ParamNameBPDecorator paramNameMapper,final IWritableComponentNameCache compNameCache,boolean assignNewGuid,boolean assignNewVersion,IProgressMonitor monitor,IProgressConsole io) throws JBVersionException, PMReadException, InterruptedException, ToolkitPluginException {
  SubMonitor subMonitor=SubMonitor.convert(monitor,Messages.ImportFileBPReading,2);
  IProjectPO projectPO=null;
  monitor.subTask(Messages.ImportJsonStoragePreparing);
  try (InputStream urlInputStream=url.openStream();ZipInputStream zipInputStream=new ZipInputStream(urlInputStream,StandardCharsets.UTF_8)){
    ObjectMapper mapper=new ObjectMapper();
    mapper.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);
    Map<String,Class> fileTypeMapping=new HashMap<>();
    fileTypeMapping.put(NFO,ExportInfoDTO.class);
    fileTypeMapping.put(PJT,ProjectDTO.class);
    TypeReference tr=new TypeReference<ArrayList<TestresultSummaryDTO>>(){
    }
;
    Map<String,Object> allDTOs=new HashMap<>();
    for (int i=0; i < 3; i++) {
      ZipEntry entry=zipInputStream.getNextEntry();
      String entryName=entry.getName();
      Class entryTypeMapping=fileTypeMapping.get(entryName);
      allDTOs.put(entryName,entryTypeMapping != null ? mapper.readValue(zipInputStream,entryTypeMapping) : mapper.readValue(zipInputStream,tr));
    }
    ExportInfoDTO exportDTO=(ExportInfoDTO)allDTOs.get(NFO);
    checkMinimumRequiredJSONVersion(exportDTO);
    ProjectDTO projectDTO=(ProjectDTO)allDTOs.get(PJT);
    if (!assignNewGuid && projectExists(projectDTO)) {
      existProjectHandling(io,projectDTO);
      return null;
    }
    projectPO=load(projectDTO,subMonitor.newChild(1),io,assignNewGuid,assignNewVersion,paramNameMapper,compNameCache,false);
    JsonImporter importer=new JsonImporter(monitor,io,false);
    List<TestresultSummaryDTO> summaryDTOs=(List<TestresultSummaryDTO>)allDTOs.get(RST);
    importer.initTestResultSummaries(subMonitor.newChild(1),summaryDTOs,projectPO);
  }
 catch (  IOException e) {
    log.warn(""String_Node_Str"",e);
    if (!monitor.isCanceled()) {
      log.info(Messages.GeneralIoExeption);
      throw new PMReadException(Messages.InvalidImportFile,MessageIDs.E_IO_EXCEPTION);
    }
  }
  return projectPO;
}",0.9938671806553356
95506,"/** 
 * @param testStep 
 */
public void addTestStep(NodeDTO testStep){
  if (!(testStep instanceof RefTestCaseDTO || testStep instanceof CapDTO)) {
    throw new IllegalArgumentException();
  }
  this.m_testSteps.add(testStep);
}","/** 
 * @param testStep 
 */
public void addTestStep(NodeDTO testStep){
  if (!(testStep instanceof RefTestCaseDTO || testStep instanceof CapDTO || testStep instanceof CommentDTO)) {
    throw new IllegalArgumentException();
  }
  this.m_testSteps.add(testStep);
}",0.931174089068826
95507,"/** 
 * @return refTestSuites
 */
@JsonProperty(""String_Node_Str"") public List<RefTestSuiteDTO> getRefTestSuites(){
  return m_refTestSuites;
}","/** 
 * @return refTestSuites
 */
@JsonProperty(""String_Node_Str"") public List<NodeDTO> getRefTestSuites(){
  return m_refTestSuites;
}",0.9496402877697842
95508,"/** 
 * activate the editor
 */
private void activateEditor(){
  if (canModify()) {
    m_editor.setEditor(createEditor());
    Control editorCtrl=m_editor.getEditor();
    if ((editorCtrl != null) && !editorCtrl.isDisposed()) {
      editorCtrl.addFocusListener(m_focusListener);
    }
    TextControlBP.selectAll(m_editor.getEditor());
  }
}","/** 
 * activate the editor
 */
private void activateEditor(){
  if (canModify()) {
    m_editor.setEditor(createEditor());
    Control editorCtrl=m_editor.getEditor();
    if ((editorCtrl != null) && !editorCtrl.isDisposed()) {
      editorCtrl.addFocusListener(m_focusListener);
    }
    TextControlBP.selectAll(m_editor.getEditor());
    m_currentEditorIndex=getSelectedDataSet();
  }
}",0.9358799454297408
95509,"/** 
 * Writes the data to the selected data set
 * @param property the column property
 * @param value the value to write
 * @param edit the editor
 */
private void writeDataSetData(String property,Object value,AbstractJBEditor edit){
  final int langIndex=getColumnIndexOfProperty(property);
  final int dsNumber=getSelectedDataSet();
  final int paramIndex=getTable().getSelectionIndex();
  setValueToModel(value,edit,paramIndex,dsNumber);
  getTable().getItem(paramIndex).setText(langIndex,value == null ? StringConstants.EMPTY : (String)value);
}","/** 
 * Writes the data to the selected data set
 * @param property the column property
 * @param value the value to write
 * @param edit the editor
 */
private void writeDataSetData(String property,Object value,AbstractJBEditor edit){
  final int langIndex=getColumnIndexOfProperty(property);
  setValueToModel(value,edit,m_currentEditorIndex,m_currentEditorIndex);
  getTable().getItem(m_currentEditorIndex).setText(langIndex,value == null ? StringConstants.EMPTY : (String)value);
}",0.747104247104247
95510,"/** 
 * Waits <code>timeMillSec</code> if the application opens a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is shown
 */
public void rcWaitForWindow(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.COMP_NOT_FOUND));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final EventHandler<WindowEvent> showHandler=new EventHandler<WindowEvent>(){
    @Override public void handle(    WindowEvent event){
      signal.countDown();
    }
  }
;
  boolean isShowing=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isShowing()) {
        stage.addEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
        return false;
      }
      return true;
    }
  }
);
  if (!isShowing) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.removeEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isShowing();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * Waits <code>timeMillSec</code> if the application opens a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is shown
 */
public void rcWaitForWindow(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.COMP_NOT_FOUND));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final EventHandler<WindowEvent> showHandler=new EventHandler<WindowEvent>(){
    @Override public void handle(    WindowEvent event){
      signal.countDown();
    }
  }
;
  boolean isShowing=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isShowing()) {
        stage.addEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
        return false;
      }
      return true;
    }
  }
);
  if (!isShowing) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.removeEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
    }
  }
  boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      return stage.isShowing();
    }
  }
);
  if (!result) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
  }
  TimeUtil.delay(delay);
}",0.9851150202976996
95511,"/** 
 * Waits <code>timeMillSec</code> if the application closes (or hides) a window with the given title. If no window with the given title can be found, then it is assumed that the window has already closed.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is closed
 */
public void rcWaitForWindowToClose(final String title,final String operator,int pTimeout,int delay){
  final Stage s=getStageByTitle(title,operator);
  if (s == null) {
    return;
  }
  final CountDownLatch signal=new CountDownLatch(1);
  final EventHandler<WindowEvent> closeHandler=new EventHandler<WindowEvent>(){
    @Override public void handle(    WindowEvent event){
      signal.countDown();
    }
  }
;
  boolean isClosing=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      s.addEventFilter(WindowEvent.WINDOW_CLOSE_REQUEST,closeHandler);
      return false;
    }
  }
);
  if (isClosing) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      s.removeEventFilter(WindowEvent.WINDOW_CLOSE_REQUEST,closeHandler);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        final Stage tmpS=getStageByTitle(title,operator);
        return tmpS == null;
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * Waits <code>timeMillSec</code> if the application closes (or hides) a window with the given title. If no window with the given title can be found, then it is assumed that the window has already closed.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is closed
 */
public void rcWaitForWindowToClose(final String title,final String operator,int pTimeout,int delay){
  final Stage s=getStageByTitle(title,operator);
  if (s == null) {
    return;
  }
  final CountDownLatch signal=new CountDownLatch(1);
  final EventHandler<WindowEvent> closeHandler=new EventHandler<WindowEvent>(){
    @Override public void handle(    WindowEvent event){
      signal.countDown();
    }
  }
;
  boolean isClosing=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (s.isShowing()) {
        s.addEventFilter(WindowEvent.WINDOW_CLOSE_REQUEST,closeHandler);
        return false;
      }
 else {
        return true;
      }
    }
  }
);
  if (!isClosing) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      s.removeEventFilter(WindowEvent.WINDOW_CLOSE_REQUEST,closeHandler);
    }
  }
  boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      final Stage tmpS=getStageByTitle(title,operator);
      return tmpS == null || !tmpS.isShowing();
    }
  }
);
  if (!result) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
  }
  TimeUtil.delay(delay);
}",0.9555674518201284
95512,"@Override public Boolean call() throws Exception {
  final Stage tmpS=getStageByTitle(title,operator);
  return tmpS == null;
}","@Override public Boolean call() throws Exception {
  final Stage tmpS=getStageByTitle(title,operator);
  return tmpS == null || !tmpS.isShowing();
}",0.9236363636363636
95513,"/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isFocused()) {
        stage.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.focusedProperty().removeListener(focusListener);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isFocused();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isFocused()) {
        stage.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (!isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.focusedProperty().removeListener(focusListener);
    }
  }
  boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      return stage.isFocused();
    }
  }
);
  if (!result) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
  }
  TimeUtil.delay(delay);
}",0.9855634561516916
95514,"/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param operator the RegEx operator
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPath(String pathType,int preAscend,String treePath,String operator,boolean exists){
  try {
    rcExpand(pathType,preAscend,treePath,operator);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      throw new StepVerifyFailedException(""String_Node_Str"" + treePath,EventFactory.createVerifyFailed(treePath,StringConstants.EMPTY));
    }
    return;
  }
  if (!exists) {
    throw new StepVerifyFailedException(""String_Node_Str"",EventFactory.createVerifyFailed(StringConstants.EMPTY,treePath));
  }
}","/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param operator the RegEx operator
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPath(String pathType,int preAscend,String treePath,String operator,boolean exists){
  try {
    rcExpand(pathType,preAscend,treePath,operator);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      Verifier.equals(exists,false);
    }
    return;
  }
  if (!exists) {
    Verifier.equals(exists,true);
  }
}",0.8459821428571429
95515,"/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPathByIndices(String pathType,int preAscend,String treePath,boolean exists){
  try {
    rcExpandByIndices(pathType,preAscend,treePath);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      throw new StepVerifyFailedException(""String_Node_Str"" + treePath,EventFactory.createVerifyFailed(treePath,StringConstants.EMPTY));
    }
    return;
  }
  if (!exists) {
    throw new StepVerifyFailedException(""String_Node_Str"",EventFactory.createVerifyFailed(StringConstants.EMPTY,treePath));
  }
}","/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPathByIndices(String pathType,int preAscend,String treePath,boolean exists){
  try {
    rcExpandByIndices(pathType,preAscend,treePath);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      Verifier.equals(exists,false);
    }
    return;
  }
  if (!exists) {
    Verifier.equals(exists,true);
  }
}",0.8378378378378378
95516,"/** 
 * creates the TableColumns with Parameter
 */
private void initTableViewerParameterColumns(){
  if (getParamInterfaceObj() == null) {
    return;
  }
  final Table table=getTable();
  if (m_paramId == getParamInterfaceObj().getId()) {
    TableColumn[] tableColumns=table.getColumns();
    if (tableColumns != null && tableColumns.length != 0) {
      m_columnWidths=new int[tableColumns.length];
      int i=0;
      for (      TableColumn column : tableColumns) {
        m_columnWidths[i++]=column.getWidth();
      }
    }
  }
 else {
    m_paramId=getParamInterfaceObj().getId();
    m_columnWidths=null;
  }
  String[] columnProperties=new String[getParamInterfaceObj().getParameterList().size() + 1];
  columnProperties[0]=initDataSetColumn();
  int i=1;
  for (  IParamDescriptionPO descr : getParamInterfaceObj().getParameterList()) {
    TableColumn column=new TableColumn(table,SWT.NONE);
    String columnName=descr.getName();
    column.setText(columnName);
    columnProperties[i]=columnName;
    if (m_columnWidths == null || m_columnWidths.length <= i) {
      if (column.getWidth() < COLUMN_WIDTH) {
        column.setWidth(COLUMN_WIDTH);
      }
    }
 else {
      column.setWidth(m_columnWidths[i]);
    }
    i++;
  }
  getTableViewer().setColumnProperties(columnProperties);
}","/** 
 * creates the TableColumns with Parameter
 */
private void initTableViewerParameterColumns(){
  if (getParamInterfaceObj() == null) {
    return;
  }
  final Table table=getTable();
  if (m_paramId == getParamInterfaceObj().getId()) {
    TableColumn[] tableColumns=table.getColumns();
    if (tableColumns != null && tableColumns.length != 0) {
      m_columnWidths=new int[tableColumns.length];
      int i=0;
      for (      TableColumn column : tableColumns) {
        m_columnWidths[i++]=column.getWidth();
      }
      m_columnCount=tableColumns.length;
    }
  }
 else {
    m_paramId=getParamInterfaceObj().getId();
    m_columnWidths=null;
  }
  String[] columnProperties=new String[getParamInterfaceObj().getParameterList().size() + 1];
  columnProperties[0]=initDataSetColumn();
  int i=1;
  int parameterListSize=getParamInterfaceObj().getParameterListSize();
  for (  IParamDescriptionPO descr : getParamInterfaceObj().getParameterList()) {
    TableColumn column=new TableColumn(table,SWT.NONE);
    String columnName=descr.getName();
    column.setText(columnName);
    columnProperties[i]=columnName;
    if (m_columnWidths == null || m_columnWidths.length <= i || m_columnCount != (parameterListSize + 1)) {
      column.setWidth(COLUMN_WIDTH);
    }
 else {
      column.setWidth(m_columnWidths[i]);
    }
    i++;
  }
  getTableViewer().setColumnProperties(columnProperties);
}",0.91506646971935
95517,"/** 
 * Packs the table.
 */
private void packTable(){
  final Table table=getTable();
  final TableColumn[] columns=table.getColumns();
  final int columnCount=columns.length;
  columns[0].setWidth((m_columnWidths != null && m_columnWidths.length > 0) ? m_columnWidths[0] : DATASET_NUMBER_COLUMNWIDTH);
  for (int i=1; i < columnCount; i++) {
    final TableColumn column=columns[i];
    column.pack();
    column.setWidth((m_columnWidths != null && m_columnWidths.length > i) ? m_columnWidths[i] : COLUMN_WIDTH);
  }
}","/** 
 * Packs the table.
 */
private void packTable(){
  final Table table=getTable();
  final TableColumn[] columns=table.getColumns();
  final int columnCount=columns.length;
  if ((m_columnWidths != null && m_columnWidths.length > 0) && m_columnCount == columns.length) {
    columns[0].setWidth(m_columnWidths[0]);
  }
 else {
    columns[0].setWidth(DATASET_NUMBER_COLUMNWIDTH);
  }
  for (int i=1; i < columnCount; i++) {
    final TableColumn column=columns[i];
    column.pack();
    if ((m_columnWidths != null && m_columnWidths.length > i) && m_columnCount == columns.length) {
      column.setWidth(m_columnWidths[i]);
    }
 else {
      column.setWidth(COLUMN_WIDTH);
    }
  }
}",0.7277227722772277
95518,"/** 
 * Inits and creates the column for the data set numbers
 * @return the name of the column
 */
private String initDataSetColumn(){
  clearTableViewer();
  final Table table=getTable();
  TableColumn dataSetNumberCol=new TableColumn(table,SWT.NONE);
  dataSetNumberCol.setText(Messages.DataSetViewControllerDataSetNumber);
  dataSetNumberCol.setWidth((m_columnWidths != null && m_columnWidths.length > 0) ? m_columnWidths[0] : DATASET_NUMBER_COLUMNWIDTH);
  return dataSetNumberCol.getText();
}","/** 
 * Inits and creates the column for the data set numbers
 * @return the name of the column
 */
private String initDataSetColumn(){
  clearTableViewer();
  final Table table=getTable();
  TableColumn dataSetNumberCol=new TableColumn(table,SWT.NONE);
  dataSetNumberCol.setText(Messages.DataSetViewControllerDataSetNumber);
  if ((m_columnWidths != null && m_columnWidths.length > 0) && m_columnCount == table.getColumnCount()) {
    dataSetNumberCol.setWidth(m_columnWidths[0]);
  }
 else {
    dataSetNumberCol.setWidth(DATASET_NUMBER_COLUMNWIDTH);
  }
  return dataSetNumberCol.getText();
}",0.8555758683729433
95519,"@Override public boolean select(Viewer viewer,Object parentElement,Object element){
  if (m_searchString == null || m_searchString.length() == 0 || !(element instanceof IDataSetPO)) {
    return true;
  }
  for (  String value : ((IDataSetPO)element).getColumnStringValues()) {
    if (value.matches(m_searchString)) {
      return true;
    }
  }
  return false;
}","@Override public boolean select(Viewer viewer,Object parentElement,Object element){
  if (m_searchString == null || m_searchString.length() == 0 || !(element instanceof IDataSetPO)) {
    return true;
  }
  for (  String value : ((IDataSetPO)element).getColumnStringValues()) {
    if (value != null && value.matches(m_searchString)) {
      return true;
    }
  }
  return false;
}",0.9772423025435074
95520,"/** 
 * @param desc desc of removed parameter of specTc
 * @param childrenIt the Iterator of the children which References are to remove.
 */
private void removeReferences(IParamDescriptionPO desc,Iterator childrenIt){
  while (childrenIt.hasNext()) {
    final IParamNodePO child=(IParamNodePO)childrenIt.next();
    final ITDManager mgr=child.getDataManager();
    final Iterator<TDCell> refIt=child.getParamReferencesIterator();
    while (refIt.hasNext()) {
      final TDCell cell=refIt.next();
      final String guid=mgr.getUniqueIds().get(cell.getCol());
      final IParamDescriptionPO childDesc=child.getParameterForUniqueId(guid);
      final ModelParamValueConverter conv=new ModelParamValueConverter(cell.getTestData(),child,childDesc);
      if (conv.containsReferences()) {
        final boolean isModified=conv.removeReference(desc.getUniqueId());
        if (isModified) {
          cell.setTestData(conv.getModelString());
        }
      }
    }
  }
}","/** 
 * @param desc desc of removed parameter of specTc
 * @param childrenIt the Iterator of the children which References are to remove.
 */
private void removeReferences(IParamDescriptionPO desc,Iterator<? extends INodePO> childrenIt){
  while (childrenIt.hasNext()) {
    INodePO node=childrenIt.next();
    if (node instanceof IParamNodePO) {
      final IParamNodePO child=(IParamNodePO)node;
      final ITDManager mgr=child.getDataManager();
      final Iterator<TDCell> refIt=child.getParamReferencesIterator();
      while (refIt.hasNext()) {
        final TDCell cell=refIt.next();
        final String guid=mgr.getUniqueIds().get(cell.getCol());
        final IParamDescriptionPO childDesc=child.getParameterForUniqueId(guid);
        final ModelParamValueConverter conv=new ModelParamValueConverter(cell.getTestData(),child,childDesc);
        if (conv.containsReferences()) {
          final boolean isModified=conv.removeReference(desc.getUniqueId());
          if (isModified) {
            cell.setTestData(conv.getModelString());
          }
        }
      }
    }
  }
}",0.9086491739552964
95521,"/** 
 * Initializes the Component System.<br> Reads in all ComponentConfiguration Files of all installed  Toolkit-Plugins.
 */
private void initCompSystem() throws ToolkitPluginException {
  IExtension[] plugins=Activator.getDefault().findToolkitPlugins();
  for (  IExtension extension : plugins) {
    IConfigurationElement[] elements=extension.getConfigurationElements();
    for (    IConfigurationElement element : elements) {
      IToolkitProvider provider;
      try {
        provider=(IToolkitProvider)element.createExecutableExtension(ToolkitConstants.ATTR_ITOOLKITPROVIDER);
        URL componentConfigurationURL=provider.getComponentConfigurationFileURL();
        InputStream inputStream=getInputStream(componentConfigurationURL);
        CompSystem compSystem=createCompSystem(inputStream);
        ToolkitDescriptor descr=createToolkitDescriptor(element,compSystem);
        final ResourceBundle resourceBundle=provider.getResourceBundle();
        if (resourceBundle == null) {
          log.error(Messages.NoI18n + StringConstants.MINUS + Messages.ResourceBundleAvailable+ StringConstants.COLON+ StringConstants.SPACE+ String.valueOf(descr.getName()));
        }
        CompSystemI18n.addResourceBundle(resourceBundle);
        setToolkitDescriptorToComponents(compSystem,descr);
        addToolkitToCompSystem(compSystem);
        ToolkitSupportBP.addToolkitProvider(descr,provider);
      }
 catch (      IOException fileNotFoundEx) {
        final String msg=Messages.ComponenConfigurationNotFound + StringConstants.EXCLAMATION_MARK;
        log.error(msg,fileNotFoundEx);
        m_initExceptions.put(extension.getContributor().getName(),fileNotFoundEx);
      }
catch (      CoreException coreEx) {
        final String msg=Messages.CouldNotCreateToolkitProvider + StringConstants.EXCLAMATION_MARK;
        log.error(msg,coreEx);
        m_initExceptions.put(extension.getContributor().getName(),coreEx);
      }
catch (      RuntimeException ce) {
        final String msg=Messages.CouldNotCreateToolkitProvider + StringConstants.EXCLAMATION_MARK;
        log.error(msg,ce);
        m_initExceptions.put(extension.getContributor().getName(),ce);
      }
    }
  }
  postProcess();
}","/** 
 * Initializes the Component System.<br> Reads in all ComponentConfiguration Files of all installed  Toolkit-Plugins.
 */
private void initCompSystem() throws ToolkitPluginException {
  IExtension[] plugins=Activator.getDefault().findToolkitPlugins();
  for (  IExtension extension : plugins) {
    IConfigurationElement[] elements=extension.getConfigurationElements();
    for (    IConfigurationElement element : elements) {
      IToolkitProvider provider;
      try {
        provider=(IToolkitProvider)element.createExecutableExtension(ToolkitConstants.ATTR_ITOOLKITPROVIDER);
        URL componentConfigurationURL=provider.getComponentConfigurationFileURL();
        InputStream inputStream=getInputStream(componentConfigurationURL);
        CompSystem compSystem=createCompSystem(inputStream);
        ToolkitDescriptor descr=createToolkitDescriptor(element,compSystem);
        final ResourceBundle resourceBundle=provider.getResourceBundle();
        if (resourceBundle == null) {
          log.error(Messages.NoI18n + StringConstants.MINUS + Messages.ResourceBundleAvailable+ StringConstants.COLON+ StringConstants.SPACE+ String.valueOf(descr.getName()));
        }
        CompSystemI18n.addResourceBundle(resourceBundle);
        setToolkitDescriptorToComponents(compSystem,descr);
        addToolkitToCompSystem(compSystem);
        ToolkitSupportBP.addToolkitProvider(descr,provider);
      }
 catch (      IOException fileNotFoundEx) {
        final String msg=Messages.ComponenConfigurationNotFound + StringConstants.EXCLAMATION_MARK;
        log.error(msg,fileNotFoundEx);
        m_initExceptions.put(extension.getContributor().getName(),fileNotFoundEx);
      }
catch (      CoreException coreEx) {
        final String msg=Messages.CouldNotCreateToolkitProvider + StringConstants.EXCLAMATION_MARK;
        log.error(msg,coreEx);
        m_initExceptions.put(extension.getContributor().getName(),coreEx);
      }
catch (      RuntimeException ce) {
        final String msg=Messages.CouldNotCreateToolkitProvider + StringConstants.EXCLAMATION_MARK;
        log.error(msg,ce);
        m_initExceptions.put(extension.getContributor().getName(),ce);
      }
    }
  }
  try {
    postProcess();
  }
 catch (  ConfigXmlException cxe) {
    m_initExceptions.put(cxe.getToolkitDescriptor(),cxe);
  }
}",0.9752540874944764
95522,"/** 
 * public constructor
 * @param message the detailed message
 * @param id An ErrorMessage.ID.  {@inheritDoc}
 */
public ConfigXmlException(String message,Integer id){
  super(message,id);
}","/** 
 * public constructor
 * @param toolkitDescriptor the name of the {@link org.eclipse.jubula.tools.internal.xml.businessmodell.ToolkitDescriptor}
 * @param message the detailed message
 * @param id An ErrorMessage.ID. {@inheritDoc}
 */
public ConfigXmlException(String toolkitDescriptor,String message,Integer id){
  super(message,id);
  m_toolkitDescriptor=toolkitDescriptor;
}",0.6458333333333334
95523,"/** 
 * Validates the Components.
 */
private void validateComponents(){
  for (  AbstractComponent ac : m_abstractComponents) {
    if (ac.getRealizers().isEmpty()) {
      String message=""String_Node_Str"" + ac.getType() + ""String_Node_Str"";
      if (ac.isVisible()) {
        log.error(""String_Node_Str"" + message);
        throw new ConfigXmlException(""String_Node_Str"" + message,MessageIDs.E_NO_ABSTRACT_COMPONENT);
      }
      log.warn(message);
    }
  }
  for (  ConcreteComponent cc : m_concreteComponents) {
    if (cc.isExtender() && !StringUtils.isBlank(cc.getComponentClass().getName())) {
      final String msg=""String_Node_Str"" + cc.getType() + ""String_Node_Str"";
      log.error(msg);
      throw new ConfigXmlException(msg,MessageIDs.E_GENERAL_COMPONENT_ERROR);
    }
  }
}","/** 
 * Validates the Components.
 */
private void validateComponents(){
  for (  AbstractComponent ac : m_abstractComponents) {
    if (ac.getRealizers().isEmpty()) {
      String message=""String_Node_Str"" + ac.getType() + ""String_Node_Str"";
      if (ac.isVisible()) {
        log.error(""String_Node_Str"" + message);
        throw new ConfigXmlException(ac.getToolkitDesriptor().getToolkitID(),""String_Node_Str"" + message,MessageIDs.E_NO_ABSTRACT_COMPONENT);
      }
      log.warn(message);
    }
  }
  for (  ConcreteComponent cc : m_concreteComponents) {
    if (cc.isExtender() && !StringUtils.isBlank(cc.getComponentClass().getName())) {
      final String msg=""String_Node_Str"" + cc.getType() + ""String_Node_Str"";
      log.error(msg);
      throw new ConfigXmlException(cc.getToolkitDesriptor().getToolkitID(),msg,MessageIDs.E_GENERAL_COMPONENT_ERROR);
    }
  }
}",0.9519807923169268
95524,"/** 
 * Checks if there are multiple components with the same type.
 * @param component A <code>org.eclipse.jubula.tools.internal.xml.businessmodell.Component</code> object
 */
private void check(Component component){
  for (  Component current : getComponents()) {
    if (current.getType().equals(component.getType())) {
      final String msg=""String_Node_Str"" + component.getType();
      log.error(msg);
      throw new ConfigXmlException(msg,MessageIDs.E_MULTIPLE_COMPONENT);
    }
  }
}","/** 
 * Checks if there are multiple components with the same type.
 * @param component A <code>org.eclipse.jubula.tools.internal.xml.businessmodell.Component</code> object
 */
private void check(Component component){
  for (  Component current : getComponents()) {
    if (current.getType().equals(component.getType())) {
      final String msg=""String_Node_Str"" + component.getType();
      log.error(msg);
      String descriptor=current.getToolkitDesriptor().getToolkitID() + StringConstants.COMMA + StringConstants.SPACE+ component.getToolkitDesriptor().getToolkitID();
      throw new ConfigXmlException(descriptor,msg,MessageIDs.E_MULTIPLE_COMPONENT);
    }
  }
}",0.8478073946689596
95525,"/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param operator the RegEx operator
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPath(String pathType,int preAscend,String treePath,String operator,boolean exists){
  try {
    rcExpand(pathType,preAscend,treePath,operator);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      throw new StepVerifyFailedException(""String_Node_Str"" + treePath,EventFactory.createVerifyFailed(treePath,StringConstants.EMPTY));
    }
    return;
  }
  if (!exists) {
    throw new StepVerifyFailedException(""String_Node_Str"",EventFactory.createVerifyFailed(StringConstants.EMPTY,treePath));
  }
}","/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param operator the RegEx operator
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPath(String pathType,int preAscend,String treePath,String operator,boolean exists){
  try {
    rcExpand(pathType,preAscend,treePath,operator);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      Verifier.equals(exists,false);
    }
    return;
  }
  if (!exists) {
    Verifier.equals(exists,true);
  }
}",0.8459821428571429
95526,"/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPathByIndices(String pathType,int preAscend,String treePath,boolean exists){
  try {
    rcExpandByIndices(pathType,preAscend,treePath);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      throw new StepVerifyFailedException(""String_Node_Str"" + treePath,EventFactory.createVerifyFailed(treePath,StringConstants.EMPTY));
    }
    return;
  }
  if (!exists) {
    throw new StepVerifyFailedException(""String_Node_Str"",EventFactory.createVerifyFailed(StringConstants.EMPTY,treePath));
  }
}","/** 
 * Tests whether the given treePath exists or not
 * @param pathType whether the path is relative or absolute
 * @param preAscend Relative traversals will start this many parent nodes above the current node. Absolute traversals ignore this parameter.
 * @param treePath the path to check
 * @param exists if true, the verify succeeds if the path DOES exist.If false, the verify succeeds if the path DOES NOT exist.
 */
public void rcVerifyPathByIndices(String pathType,int preAscend,String treePath,boolean exists){
  try {
    rcExpandByIndices(pathType,preAscend,treePath);
  }
 catch (  StepExecutionException e) {
    if (exists) {
      Verifier.equals(exists,false);
    }
    return;
  }
  if (!exists) {
    Verifier.equals(exists,true);
  }
}",0.8378378378378378
95527,"/** 
 * Creates and configures the ""Clear Filter"" button
 * @param parent the parent composite
 */
private void createClearFilterButton(Composite parent){
  setClearButton(new Label(parent,SWT.NONE));
  getClearButton().setData(SwtToolkitConstants.WIDGET_NAME,""String_Node_Str"");
  getClearButton().setLayoutData(new GridData(SWT.BEGINNING,SWT.CENTER,false,false));
  getClearButton().setImage(inactiveImage);
  getClearButton().setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_LIST_BACKGROUND));
  getClearButton().setToolTipText(Messages.DataSetClearFilterButton);
  getClearButton().addMouseListener(new MouseAdapter(){
    private MouseMoveListener m_moveListener;
    @Override public void mouseDown(    MouseEvent e){
      getClearButton().setImage(pressedImage);
      m_moveListener=new MouseMoveListener(){
        private boolean m_isMouseInButton=true;
        @Override public void mouseMove(        MouseEvent e){
          boolean isMouseInButton=isMouseInButton(e);
          if (isMouseInButton != m_isMouseInButton) {
            m_isMouseInButton=isMouseInButton;
            getClearButton().setImage(isMouseInButton ? pressedImage : inactiveImage);
          }
        }
      }
;
      getClearButton().addMouseMoveListener(m_moveListener);
    }
    @Override public void mouseUp(    MouseEvent e){
      if (m_moveListener != null) {
        getClearButton().removeMouseMoveListener(m_moveListener);
        m_moveListener=null;
        boolean isMouseInButton=isMouseInButton(e);
        getClearButton().setImage(isMouseInButton ? activeImage : inactiveImage);
        if (isMouseInButton) {
          m_searchText.setText(""String_Node_Str"");
          m_searchText.setFocus();
        }
      }
    }
    private boolean isMouseInButton(    MouseEvent e){
      Point buttonSize=getClearButton().getSize();
      return 0 <= e.x && e.x < buttonSize.x && 0 <= e.y && e.y < buttonSize.y;
    }
  }
);
  getClearButton().addMouseTrackListener(new MouseTrackAdapter(){
    @Override public void mouseEnter(    MouseEvent e){
      getClearButton().setImage(activeImage);
    }
    @Override public void mouseExit(    MouseEvent e){
      getClearButton().setImage(inactiveImage);
    }
  }
);
  getClearButton().addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      inactiveImage.dispose();
      activeImage.dispose();
      pressedImage.dispose();
    }
  }
);
}","/** 
 * Creates and configures the ""Clear Filter"" button
 * @param parent the parent composite
 */
private void createClearFilterButton(Composite parent){
  setClearButton(new Label(parent,SWT.NONE));
  getClearButton().setData(SwtToolkitConstants.WIDGET_NAME,""String_Node_Str"");
  getClearButton().setLayoutData(new GridData(SWT.BEGINNING,SWT.CENTER,false,false));
  getClearButton().setImage(inactiveImage);
  getClearButton().setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_LIST_BACKGROUND));
  getClearButton().setToolTipText(Messages.DataSetClearFilterButton);
  getClearButton().addMouseListener(new MouseAdapter(){
    private MouseMoveListener m_moveListener;
    @Override public void mouseDown(    MouseEvent e){
      getClearButton().setImage(pressedImage);
      m_moveListener=new MouseMoveListener(){
        private boolean m_isMouseInButton=true;
        @Override public void mouseMove(        MouseEvent e2){
          boolean isMouseInButton=isMouseInButton(e2);
          if (isMouseInButton != m_isMouseInButton) {
            m_isMouseInButton=isMouseInButton;
            getClearButton().setImage(isMouseInButton ? pressedImage : inactiveImage);
          }
        }
      }
;
      getClearButton().addMouseMoveListener(m_moveListener);
    }
    @Override public void mouseUp(    MouseEvent e){
      if (m_moveListener != null) {
        getClearButton().removeMouseMoveListener(m_moveListener);
        m_moveListener=null;
        boolean isMouseInButton=isMouseInButton(e);
        getClearButton().setImage(isMouseInButton ? activeImage : inactiveImage);
        if (isMouseInButton) {
          m_searchText.setText(StringConstants.EMPTY);
          m_searchText.setFocus();
        }
      }
    }
    private boolean isMouseInButton(    MouseEvent e){
      Point buttonSize=getClearButton().getSize();
      return 0 <= e.x && e.x < buttonSize.x && 0 <= e.y && e.y < buttonSize.y;
    }
  }
);
  getClearButton().addMouseTrackListener(new MouseTrackAdapter(){
    @Override public void mouseEnter(    MouseEvent e){
      getClearButton().setImage(activeImage);
    }
    @Override public void mouseExit(    MouseEvent e){
      getClearButton().setImage(inactiveImage);
    }
  }
);
}",0.9457959880495092
95528,"@Override public void mouseDown(MouseEvent e){
  getClearButton().setImage(pressedImage);
  m_moveListener=new MouseMoveListener(){
    private boolean m_isMouseInButton=true;
    @Override public void mouseMove(    MouseEvent e){
      boolean isMouseInButton=isMouseInButton(e);
      if (isMouseInButton != m_isMouseInButton) {
        m_isMouseInButton=isMouseInButton;
        getClearButton().setImage(isMouseInButton ? pressedImage : inactiveImage);
      }
    }
  }
;
  getClearButton().addMouseMoveListener(m_moveListener);
}","@Override public void mouseDown(MouseEvent e){
  getClearButton().setImage(pressedImage);
  m_moveListener=new MouseMoveListener(){
    private boolean m_isMouseInButton=true;
    @Override public void mouseMove(    MouseEvent e2){
      boolean isMouseInButton=isMouseInButton(e2);
      if (isMouseInButton != m_isMouseInButton) {
        m_isMouseInButton=isMouseInButton;
        getClearButton().setImage(isMouseInButton ? pressedImage : inactiveImage);
      }
    }
  }
;
  getClearButton().addMouseMoveListener(m_moveListener);
}",0.9981343283582088
95529,"/** 
 * {@inheritDoc}
 */
public Object getAdapter(Class adapter){
  return null;
}","/** 
 * {@inheritDoc}
 */
public <T>T getAdapter(Class<T> adapter){
  return null;
}",0.9221556886227544
95530,"@Override public void mouseMove(MouseEvent e){
  boolean isMouseInButton=isMouseInButton(e);
  if (isMouseInButton != m_isMouseInButton) {
    m_isMouseInButton=isMouseInButton;
    getClearButton().setImage(isMouseInButton ? pressedImage : inactiveImage);
  }
}","@Override public void mouseMove(MouseEvent e2){
  boolean isMouseInButton=isMouseInButton(e2);
  if (isMouseInButton != m_isMouseInButton) {
    m_isMouseInButton=isMouseInButton;
    getClearButton().setImage(isMouseInButton ? pressedImage : inactiveImage);
  }
}",0.9961977186311788
95531,"/** 
 * attachs the detached workVersion to a new session to use for postprocessing of Persistence (JPA / EclipseLink) exceptions without refresh of objects 
 * @throws PMException in case of any db error
 */
public void reinitializeEditSupport() throws PMException {
  try {
    IPersistentObject workVersion=m_workVersion;
    close();
    init();
    m_workVersion=workVersion;
    m_compMapper.setCompNameCache(new ComponentNamesDecorator(getSession()));
    m_compMapper.setContext(m_workVersion);
    m_workVersion=m_session.merge(m_workVersion);
  }
 catch (  PersistenceException e) {
    final String msg=Messages.ReinitOfSessionFailed;
    log.error(msg);
    throw new PMException(msg,MessageIDs.E_DATABASE_GENERAL);
  }
}","/** 
 * attachs the detached workVersion to a new session to use for postprocessing of Persistence (JPA / EclipseLink) exceptions without refresh of objects 
 * @throws PMException in case of any db error
 */
public void reinitializeEditSupport() throws PMException {
  try {
    IPersistentObject workVersion=m_workVersion;
    close();
    init();
    m_workVersion=workVersion;
    m_compMapper.setCompNameCache(new ComponentNamesDecorator(getSession()));
    m_workVersion=m_session.merge(m_workVersion);
    m_compMapper.setContext(m_workVersion);
  }
 catch (  PersistenceException e) {
    final String msg=Messages.ReinitOfSessionFailed;
    log.error(msg);
    throw new PMException(msg,MessageIDs.E_DATABASE_GENERAL);
  }
}",0.931787175989086
95532,"/** 
 * executes the right update
 * @param event int
 * @param obj Object
 */
private void switchEvent(int event,Object obj){
switch (event) {
case IObjectMappingObserver.EVENT_STEP_RECORDED:
    IAUTMainPO aut=(IAUTMainPO)obj;
  if (getAut().equals(aut)) {
    cleanupNames();
  }
break;
case IObjectMappingObserver.EVENT_COMPONENT_MAPPED:
IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
if (getAut().equals(connectedAut)) {
IComponentIdentifier[] comp=(IComponentIdentifier[])obj;
createNewTechnicalNames(comp);
}
break;
default :
}
}","/** 
 * executes the right update
 * @param event int
 * @param obj Object
 */
private void switchEvent(int event,Object obj){
switch (event) {
case IObjectMappingObserver.EVENT_STEP_RECORDED:
    IAUTMainPO aut=(IAUTMainPO)obj;
  if (getAut().equals(aut)) {
    cleanupNames();
    synchronizeViewers();
  }
break;
case IObjectMappingObserver.EVENT_COMPONENT_MAPPED:
IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
if (getAut().equals(connectedAut)) {
IComponentIdentifier[] comp=(IComponentIdentifier[])obj;
createNewTechnicalNames(comp);
}
break;
default :
}
}",0.9773123909249564
95533,"/** 
 * Prompts the user if they really want to delete the given item.  If the user consents, the item is deleted. Otherwise, no action is taken.
 * @param toDelete The item to delete.
 * @param editor The editor in which the delete is taking place.
 * @return the parent of the element before its deletion, or <code>null</code> if no element is deleted.
 */
private Object deleteSingleElement(Object toDelete,ObjectMappingMultiPageEditor editor){
  boolean delete=false;
  Object lastParent=null;
  if (toDelete instanceof IObjectMappingAssoziationPO) {
    delete=MessageDialog.openConfirm(getActiveShell(),Messages.DeleteTreeItemActionOMEditorOMTitle,Messages.DeleteTreeItemActionOMEditorOMText1);
    if (delete) {
      lastParent=editor.getOmEditorBP().deleteAssociation((IObjectMappingAssoziationPO)toDelete);
      editor.getEditorHelper().setDirty(true);
      editor.cleanupNames();
    }
  }
 else   if (toDelete instanceof IComponentNamePO) {
    delete=MessageDialog.openConfirm(getActiveShell(),Messages.DeleteTreeItemActionOMEditorOMTitle,Messages.DeleteTreeItemActionOMEditorOMText2);
    if (delete) {
      lastParent=editor.getOmEditorBP().deleteCompName((IComponentNamePO)toDelete);
      editor.getEditorHelper().setDirty(true);
      editor.cleanupNames();
    }
  }
 else   if (toDelete instanceof IObjectMappingCategoryPO) {
    delete=MessageDialog.openConfirm(getActiveShell(),Messages.DeleteTreeItemActionOMEditorOMTitle,Messages.DeleteTreeItemActionOMEditorOMText4);
    if (delete) {
      lastParent=editor.getOmEditorBP().deleteCategory((IObjectMappingCategoryPO)toDelete);
      editor.getEditorHelper().setDirty(true);
      editor.cleanupNames();
    }
  }
  return lastParent;
}","/** 
 * Prompts the user if they really want to delete the given item.  If the user consents, the item is deleted. Otherwise, no action is taken.
 * @param toDelete The item to delete.
 * @param editor The editor in which the delete is taking place.
 * @return the parent of the element before its deletion, or <code>null</code> if no element is deleted.
 */
private Object deleteSingleElement(Object toDelete,ObjectMappingMultiPageEditor editor){
  boolean delete=false;
  Object lastParent=null;
  if (toDelete instanceof IObjectMappingAssoziationPO) {
    delete=MessageDialog.openConfirm(getActiveShell(),Messages.DeleteTreeItemActionOMEditorOMTitle,Messages.DeleteTreeItemActionOMEditorOMText1);
    if (delete) {
      lastParent=editor.getOmEditorBP().deleteAssociation((IObjectMappingAssoziationPO)toDelete);
      editor.getEditorHelper().setDirty(true);
      editor.cleanupNames();
      editor.synchronizeViewers();
    }
  }
 else   if (toDelete instanceof IComponentNamePO) {
    delete=MessageDialog.openConfirm(getActiveShell(),Messages.DeleteTreeItemActionOMEditorOMTitle,Messages.DeleteTreeItemActionOMEditorOMText2);
    if (delete) {
      lastParent=editor.getOmEditorBP().deleteCompName((IComponentNamePO)toDelete);
      editor.getEditorHelper().setDirty(true);
      editor.cleanupNames();
      editor.synchronizeViewers();
    }
  }
 else   if (toDelete instanceof IObjectMappingCategoryPO) {
    delete=MessageDialog.openConfirm(getActiveShell(),Messages.DeleteTreeItemActionOMEditorOMTitle,Messages.DeleteTreeItemActionOMEditorOMText4);
    if (delete) {
      lastParent=editor.getOmEditorBP().deleteCategory((IObjectMappingCategoryPO)toDelete);
      editor.getEditorHelper().setDirty(true);
      editor.cleanupNames();
      editor.synchronizeViewers();
    }
  }
  return lastParent;
}",0.9702633814783348
95534,"/** 
 * @param toDelete The items to delete.
 * @param editor The editor in which the delete is taking place.
 * @return the parent of one of the given elements before its deletion, or <code>null</code> if no elements are deleted.
 */
public static Object deleteMultipleElements(Object[] toDelete,ObjectMappingMultiPageEditor editor){
  IObjectMappingCategoryPO lastParent=null;
  for (  Object node : toDelete) {
    if (node instanceof IComponentNamePO) {
      lastParent=editor.getOmEditorBP().deleteCompName((IComponentNamePO)node);
    }
 else     if (node instanceof IObjectMappingAssoziationPO) {
      lastParent=editor.getOmEditorBP().deleteAssociation((IObjectMappingAssoziationPO)node);
    }
 else     if (node instanceof IObjectMappingCategoryPO) {
      lastParent=editor.getOmEditorBP().deleteCategory((IObjectMappingCategoryPO)node);
    }
  }
  if (toDelete.length > 0) {
    editor.getEditorHelper().setDirty(true);
    editor.cleanupNames();
  }
  return lastParent;
}","/** 
 * @param toDelete The items to delete.
 * @param editor The editor in which the delete is taking place.
 * @return the parent of one of the given elements before its deletion, or <code>null</code> if no elements are deleted.
 */
public static Object deleteMultipleElements(Object[] toDelete,ObjectMappingMultiPageEditor editor){
  IObjectMappingCategoryPO lastParent=null;
  for (  Object node : toDelete) {
    if (node instanceof IComponentNamePO) {
      lastParent=editor.getOmEditorBP().deleteCompName((IComponentNamePO)node);
    }
 else     if (node instanceof IObjectMappingAssoziationPO) {
      lastParent=editor.getOmEditorBP().deleteAssociation((IObjectMappingAssoziationPO)node);
    }
 else     if (node instanceof IObjectMappingCategoryPO) {
      lastParent=editor.getOmEditorBP().deleteCategory((IObjectMappingCategoryPO)node);
    }
  }
  if (toDelete.length > 0) {
    editor.getEditorHelper().setDirty(true);
    editor.cleanupNames();
    editor.synchronizeViewers();
  }
  return lastParent;
}",0.9835739173718268
95535,"/** 
 * {@inheritDoc}
 */
@Transient public Set<IAUTMainPO> getAutMainList(){
  return Collections.unmodifiableSet(getHbmAutCont().getAutMainList());
}","/** 
 * {@inheritDoc}
 */
@Transient public Set<IAUTMainPO> getAutMainList(){
  AUTContPO autCont=getHbmAutCont();
  if (autCont != null) {
    Set<IAUTMainPO> autMainList=autCont.getAutMainList();
    if (autMainList != null) {
      return Collections.unmodifiableSet(autMainList);
    }
    log.error(""String_Node_Str"");
  }
 else {
    log.error(""String_Node_Str"");
  }
  return null;
}",0.4140480591497227
95536,"/** 
 * @return AUTs, which support working language
 */
private Set<IAUTMainPO> getAUTs(){
  Set<IAUTMainPO> autsForLang=new HashSet<IAUTMainPO>();
  Set<IAUTMainPO> autsOfProject=GeneralStorage.getInstance().getProject().getAutMainList();
  for (  IAUTMainPO aut : autsOfProject) {
    autsForLang.add(aut);
  }
  return autsForLang;
}","/** 
 * @return AUTs, which support working language
 */
private Set<IAUTMainPO> getAUTs(){
  return GeneralStorage.getInstance().getProject().getAutMainList();
}",0.6372745490981964
95537,"/** 
 * @param userName The user name.
 * @param pwd The password.
 * @param url connection string / URL
 * @param monitor the progress monitor to use           
 * @return the only instance of the Persistor, building the connection tothe database
 * @throws JBFatalException .
 * @throws JBException .
 */
private static Persistor instance(String userName,String pwd,String url,IProgressMonitor monitor) throws JBFatalException, JBException {
  if (instance == null) {
    try {
      instance=new Persistor(userName,pwd,url,monitor);
      DatabaseStateDispatcher.notifyListener(new DatabaseStateEvent(DatabaseState.DB_LOGIN_SUCCEEDED));
    }
 catch (    DatabaseVersionConflictException e) {
      final Integer dbMajorVersion=e.getDatabaseMajorVersion();
      final Integer dbMinorVersion=e.getDatabaseMinorVersion();
      final Integer cDBMajorVersion=MODEL_VERSION.getMajor();
      final Integer cDBMinorVersion=MODEL_VERSION.getMinor();
      final String errorMessage=NLS.bind(Messages.DBVersionProblem,new Object[]{dbMajorVersion,dbMinorVersion,cDBMajorVersion,cDBMinorVersion});
      if (cDBMajorVersion > dbMajorVersion || (cDBMajorVersion.equals(dbMajorVersion) && cDBMinorVersion > dbMinorVersion)) {
        if (!handleDatabaseVersionConflict(e)) {
          throw new PMDatabaseConfException(errorMessage,MessageIDs.E_INVALID_DB_VERSION);
        }
      }
 else {
        throw new PMDatabaseConfException(errorMessage,MessageIDs.E_INVALID_DB_VERSION);
      }
    }
    LockManager.instance().startKeepAlive();
  }
  return instance;
}","/** 
 * @param userName The user name.
 * @param pwd The password.
 * @param url connection string / URL
 * @param monitor the progress monitor to use           
 * @return the only instance of the Persistor, building the connection tothe database
 * @throws JBFatalException .
 * @throws JBException .
 */
private static Persistor instance(String userName,String pwd,String url,IProgressMonitor monitor) throws JBFatalException, JBException {
  if (instance == null) {
    try {
      instance=new Persistor(userName,pwd,url,monitor);
      DatabaseStateDispatcher.notifyListener(new DatabaseStateEvent(DatabaseState.DB_LOGIN_SUCCEEDED));
    }
 catch (    DatabaseVersionConflictException e) {
      final Integer dbMajorVersion=e.getDatabaseMajorVersion();
      final Integer dbMinorVersion=e.getDatabaseMinorVersion();
      final Integer cDBMajorVersion=MODEL_VERSION.getMajor();
      final Integer cDBMinorVersion=MODEL_VERSION.getMinor();
      final String errorMessage=NLS.bind(Messages.DBVersionProblem,new Object[]{dbMajorVersion,dbMinorVersion,cDBMajorVersion,cDBMinorVersion});
      if (!handleDatabaseVersionConflict(e)) {
        throw new PMDatabaseConfException(errorMessage,MessageIDs.E_INVALID_DB_VERSION);
      }
    }
    LockManager.instance().startKeepAlive();
  }
  return instance;
}",0.874869292436389
95538,"/** 
 * Checks if there are unused Test Data in this TDManagerPO  (Data column without a parameter).
 * @return true if there are unused Test Data in this TDManagerPO., false otherwise.
 */
public boolean checkHasUnusedTestData(){
  for (  String colId : getDataManager().getUniqueIds()) {
    boolean hasColIdParam=false;
    for (ListIterator<IParamDescriptionPO> paramListIter=getParameterListIter(); paramListIter.hasNext(); ) {
      IParamDescriptionPO paramDescr=paramListIter.next();
      if (colId.equals(paramDescr.getUniqueId())) {
        hasColIdParam=true;
        break;
      }
    }
    if (!hasColIdParam) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if there are unused Test Data in this TDManagerPO  (Data column without a parameter).
 * @return true if there are unused Test Data in this TDManagerPO., false otherwise.
 */
public boolean checkHasUnusedTestData(){
  if (getReferencedDataCube() == null) {
    for (    String colId : getDataManager().getUniqueIds()) {
      boolean hasColIdParam=false;
      for (ListIterator<IParamDescriptionPO> paramListIter=getParameterListIter(); paramListIter.hasNext(); ) {
        IParamDescriptionPO paramDescr=paramListIter.next();
        if (colId.equals(paramDescr.getUniqueId())) {
          hasColIdParam=true;
          break;
        }
      }
      if (!hasColIdParam) {
        return true;
      }
    }
  }
  return false;
}",0.941508104298802
95539,"/** 
 * @param tdc the test data cube to search for reusage
 * @param session The session into which the test cases will be loaded.
 * @return list of ITestDataCubePO
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static List<ITestDataCubePO> computeReuser(IParameterInterfacePO tdc,EntityManager session){
  CriteriaBuilder builder=session.getCriteriaBuilder();
  CriteriaQuery query=builder.createQuery();
  Root from=query.from(PoMaker.getTestDataCubeClass());
  query.select(from).where(builder.isNotNull(from.get(""String_Node_Str"")));
  List<ITestDataCubePO> queryResult=session.createQuery(query).getResultList();
  List<ITestDataCubePO> result=new ArrayList<ITestDataCubePO>();
  for (  ITestDataCubePO pio : queryResult) {
    if (areEqual(pio.getReferencedDataCube(),tdc)) {
      result.add(pio);
    }
  }
  return result;
}","/** 
 * @param tdc the test data cube to search for reusage
 * @param session The session into which the test cases will be loaded.
 * @return list of ITestDataCubePO
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static List<ITestDataCubePO> computeReuser(IParameterInterfacePO tdc,EntityManager session){
  CriteriaBuilder builder=session.getCriteriaBuilder();
  CriteriaQuery query=builder.createQuery();
  Root from=query.from(PoMaker.getTestDataCubeClass());
  query.select(from).where(builder.and(builder.isNotNull(from.get(""String_Node_Str"")),builder.equal(from.get(""String_Node_Str""),tdc.getParentProjectId())));
  List<ITestDataCubePO> queryResult=session.createQuery(query).getResultList();
  List<ITestDataCubePO> result=new ArrayList<ITestDataCubePO>();
  for (  ITestDataCubePO pio : queryResult) {
    if (areEqual(pio.getReferencedDataCube(),tdc)) {
      result.add(pio);
    }
  }
  return result;
}",0.954824316787507
95540,"/** 
 * @return the action property descriptor.
 */
private IPropertyDescriptor getActionPropDesc(){
  if (m_actionPropDesc == null) {
    ComboBoxPropertyDescriptor cbpd=new ComboBoxPropertyDescriptor(m_actionTypeController,P_ELEMENT_DISPLAY_ACTIONTYPE,m_actionTypes);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          return m_actionTypes[((Integer)element).intValue()];
        }
        Assert.notReached(Messages.WrongElementType + StringConstants.DOT);
        return String.valueOf(element);
      }
    }
);
    cbpd.setCategory(P_ACTION_CAT);
    m_actionPropDesc=cbpd;
  }
  return m_actionPropDesc;
}","/** 
 * @return the action property descriptor.
 */
private IPropertyDescriptor getActionPropDesc(){
  if (m_actionPropDesc == null) {
    ComboBoxPropertyDescriptor cbpd=new ComboBoxPropertyDescriptor(m_actionTypeController,P_ELEMENT_DISPLAY_ACTIONTYPE,m_actionTypes);
    cbpd.setLabelProvider(new LabelProvider(){
      public String getText(      Object element){
        if (element instanceof Integer) {
          int temp=((Integer)element).intValue();
          if (temp < m_actionTypes.length) {
            return m_actionTypes[temp];
          }
        }
        Assert.notReached(Messages.WrongElementType + StringConstants.DOT);
        return String.valueOf(element);
      }
    }
);
    cbpd.setCategory(P_ACTION_CAT);
    m_actionPropDesc=cbpd;
  }
  return m_actionPropDesc;
}",0.901726427622842
95541,"/** 
 * @param componentNames the names of the components to support
 * @param toolkitDescriptor the descriptor of the belonging toolkit
 */
public void addSimpleExtensions(List<String> componentNames,ToolkitDescriptor toolkitDescriptor){
  Component graphicsComponent=null;
  for (  Component comp : getComponents()) {
    if (comp.getType().equalsIgnoreCase(""String_Node_Str"")) {
      graphicsComponent=comp;
    }
  }
  cleanPreviousSimpleExtension(graphicsComponent);
  for (  String componentName : componentNames) {
    String cleanName=componentName.trim();
    ConcreteComponent myComponent=new ConcreteComponent();
    myComponent.setType(cleanName);
    myComponent.setTesterClass(""String_Node_Str"");
    myComponent.setComponentClass(new ComponentClass(cleanName));
    myComponent.addRealizedType(""String_Node_Str"");
    myComponent.setToolkitDesriptor(toolkitDescriptor);
    myComponent.addAllRealizer(myComponent);
    myComponent.getRealizers().add(myComponent);
    graphicsComponent.addAllRealizer(myComponent);
    myComponent.addRealized(graphicsComponent);
    m_componentsByType.put(myComponent.getType(),myComponent);
    m_simpleExtensionComponents.add(myComponent);
  }
  getConcreteComponents().addAll(m_simpleExtensionComponents);
  getComponents().addAll(m_simpleExtensionComponents);
}","/** 
 * @param componentNames the names of the components to support
 * @param toolkitDescriptor the descriptor of the belonging toolkit
 */
public void addSimpleExtensions(List<String> componentNames,ToolkitDescriptor toolkitDescriptor){
  Component graphicsComponent=null;
  for (  Component comp : getComponents()) {
    if (comp.getType().equalsIgnoreCase(""String_Node_Str"")) {
      graphicsComponent=comp;
    }
  }
  cleanPreviousSimpleExtension(graphicsComponent);
  for (  String componentName : componentNames) {
    String cleanName=componentName.trim();
    if (m_componentsByType.containsKey(cleanName)) {
      continue;
    }
    ConcreteComponent myComponent=new ConcreteComponent();
    myComponent.setType(cleanName);
    myComponent.setTesterClass(""String_Node_Str"");
    myComponent.setComponentClass(new ComponentClass(cleanName));
    myComponent.addRealizedType(""String_Node_Str"");
    myComponent.setToolkitDesriptor(toolkitDescriptor);
    myComponent.addAllRealizer(myComponent);
    myComponent.getRealizers().add(myComponent);
    graphicsComponent.addAllRealizer(myComponent);
    myComponent.addRealized(graphicsComponent);
    m_componentsByType.put(myComponent.getType(),myComponent);
    m_simpleExtensionComponents.add(myComponent);
  }
  getConcreteComponents().addAll(m_simpleExtensionComponents);
  getComponents().addAll(m_simpleExtensionComponents);
}",0.9722735674676524
95542,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  for (  String elem : m_valueSet) {
    sb.append(elem.trim() + ""String_Node_Str"");
  }
  if (sb.length() > 0) {
    sb.replace(sb.lastIndexOf(""String_Node_Str""),sb.lastIndexOf(""String_Node_Str""),""String_Node_Str"");
  }
  return sb.toString().trim();
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  for (  String elem : m_valueSet) {
    sb.append(elem.trim() + StringConstants.COMMA + StringConstants.SPACE);
  }
  if (sb.length() > 0) {
    sb.replace(sb.lastIndexOf(""String_Node_Str""),sb.lastIndexOf(""String_Node_Str""),""String_Node_Str"");
  }
  return sb.toString().trim();
}",0.9159891598915988
95543,"/** 
 * Constructor 
 */
public ValueSet(){
  m_valueSet=new HashSet<>();
}","/** 
 * Constructor 
 */
public ValueSet(){
  m_valueSet=new LinkedHashSet<>();
}",0.9615384615384616
95544,"/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IContainerAdapter.class)) {
    if (objectToAdapt instanceof ListCell) {
      return new CustomContainerAdapter((ListCell<?>)objectToAdapt);
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass == IContainerAdapter.class) {
    if (objectToAdapt instanceof ListCell) {
      return new CustomContainerAdapter((ListCell<?>)objectToAdapt);
    }
  }
  return null;
}",0.8854700854700854
95545,"/** 
 * @param targetAdapterClass Type of the adapter
 * @param objectToAdapt object that should be adapted
 * @return Returns an adapter for the objectToAdapt of typetargetAdapterClass. The collection of all supported adapter factories is iterated. The first value that is not null will be returned. <code>Null</code> will only be returned if no adapter can be found for the targetAdapterClass, none of the given factories can handle the objectToAdapt or the objectToAdapt itself is <code>null</code>.
 */
public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  if (objectToAdapt == null) {
    return null;
  }
  Collection<IAdapterFactory> registeredFactories=null;
  Class superClass=objectToAdapt.getClass();
  while (registeredFactories == null && superClass != Object.class) {
    registeredFactories=m_registrationMap.get(superClass);
    superClass=superClass.getSuperclass();
  }
  if (registeredFactories == null) {
    return null;
  }
  for (Iterator<IAdapterFactory> iterator=registeredFactories.iterator(); iterator.hasNext(); ) {
    IAdapterFactory adapterFactory=iterator.next();
    Object object=adapterFactory.getAdapter(targetAdapterClass,objectToAdapt);
    if (object != null) {
      return object;
    }
  }
  return null;
}","/** 
 * @param targetAdapterClass Type of the adapter
 * @param objectToAdapt object that should be adapted
 * @return Returns an adapter for the objectToAdapt of typetargetAdapterClass. The collection of all supported adapter factories is iterated. The first value that is not null will be returned. <code>Null</code> will only be returned if no adapter can be found for the targetAdapterClass, none of the given factories can handle the objectToAdapt or the objectToAdapt itself is <code>null</code>.
 */
public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  if (objectToAdapt == null) {
    return null;
  }
  Collection<IAdapterFactory> registeredFactories=null;
  Class superClass=objectToAdapt.getClass();
  registeredFactories=findAdapterFactories(objectToAdapt,superClass);
  while (registeredFactories != null && superClass != Object.class) {
    for (Iterator<IAdapterFactory> iterator=registeredFactories.iterator(); iterator.hasNext(); ) {
      IAdapterFactory adapterFactory=iterator.next();
      Object object=adapterFactory.getAdapter(targetAdapterClass,objectToAdapt);
      if (object != null) {
        return object;
      }
    }
    superClass=superClass.getSuperclass();
    registeredFactories=findAdapterFactories(objectToAdapt,superClass);
  }
  return null;
}",0.6814124951493985
95546,"/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IContainerAdapter.class)) {
    if (objectToAdapt instanceof ButtonBar) {
      return new ButtonBarContainerAdapter<ButtonBar>((ButtonBar)objectToAdapt);
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass == IContainerAdapter.class) {
    if (objectToAdapt instanceof ButtonBar) {
      return new ButtonBarContainerAdapter<ButtonBar>((ButtonBar)objectToAdapt);
    }
  }
  return null;
}",0.8903436988543372
95547,"@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.isAssignableFrom(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IContainerAdapter.class)) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}","@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.isAssignableFrom(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass == IContainerAdapter.class) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}",0.9428815004262576
95548,"/** 
 * Get instances of the given arguments
 * @param args the values for the arguments
 * @param argsSplit the argument separator
 * @param parameterClasses the classes for the arguments
 * @return Object array containing the created objects with the specified value
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws InstantiationException
 */
public static Object[] getParameterValues(String args,@Nullable String argsSplit,Class<?>[] parameterClasses) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
  String[] argValues;
  if (!StringUtils.isEmpty(argsSplit)) {
    argValues=args.split(argsSplit);
  }
 else {
    argValues=new String[]{args};
  }
  if (argValues.length != parameterClasses.length) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.INVALID_INPUT));
  }
  Object[] argObjects=new Object[argValues.length];
  for (int i=0; i < argValues.length; i++) {
    argObjects[i]=ConstructorUtils.invokeExactConstructor(parameterClasses[i],argValues[i]);
  }
  return argObjects;
}","/** 
 * Get instances of the given arguments
 * @param args the values for the arguments
 * @param argsSplit the argument separator
 * @param parameterClasses the classes for the arguments
 * @return Object array containing the created objects with the specified value
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws InstantiationException
 */
public static Object[] getParameterValues(String args,@Nullable String argsSplit,Class<?>[] parameterClasses) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
  String[] argValues;
  if (!StringUtils.isEmpty(argsSplit)) {
    argValues=StringUtils.splitPreserveAllTokens(args,argsSplit);
  }
 else {
    argValues=new String[]{args};
  }
  if (argValues.length != parameterClasses.length) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.INVALID_INPUT));
  }
  Object[] argObjects=new Object[argValues.length];
  for (int i=0; i < argValues.length; i++) {
    argObjects[i]=ConstructorUtils.invokeExactConstructor(parameterClasses[i],argValues[i]);
  }
  return argObjects;
}",0.985200845665962
95549,"/** 
 * Get instances of the given arguments
 * @param args the values for the arguments
 * @param argsSplit the argument separator
 * @param parameterClasses the classes for the arguments
 * @return Object array containing the created objects with the specified value
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws InstantiationException
 */
public static Object[] getParameterValues(String args,@Nullable String argsSplit,Class<?>[] parameterClasses) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
  String[] argValues;
  if (!StringUtils.isEmpty(argsSplit)) {
    argValues=args.split(argsSplit);
  }
 else {
    argValues=new String[]{args};
  }
  if (argValues.length != parameterClasses.length) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.INVALID_INPUT));
  }
  Object[] argObjects=new Object[argValues.length];
  for (int i=0; i < argValues.length; i++) {
    argObjects[i]=ConstructorUtils.invokeExactConstructor(parameterClasses[i],argValues[i]);
  }
  return argObjects;
}","/** 
 * Get instances of the given arguments
 * @param args the values for the arguments
 * @param argsSplit the argument separator
 * @param parameterClasses the classes for the arguments
 * @return Object array containing the created objects with the specified value
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws InstantiationException
 */
public static Object[] getParameterValues(String args,@Nullable String argsSplit,Class<?>[] parameterClasses) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
  String[] argValues;
  if (!StringUtils.isEmpty(argsSplit)) {
    argValues=StringUtils.splitPreserveAllTokens(args,argsSplit);
  }
 else {
    argValues=new String[]{args};
  }
  if (argValues.length != parameterClasses.length) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.INVALID_INPUT));
  }
  Object[] argObjects=new Object[argValues.length];
  for (int i=0; i < argValues.length; i++) {
    argObjects[i]=ConstructorUtils.invokeExactConstructor(parameterClasses[i],argValues[i]);
  }
  return argObjects;
}",0.985200845665962
95550,"/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      originalCategory.removeAssociation(parent);
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}","/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      if (originalCategory != null) {
        originalCategory.removeAssociation(parent);
      }
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}",0.9884892086330936
95551,"/** 
 * Clicks on a menu item
 * @param robot the robot
 * @param item  the menu item
 */
private void clickMenuItem(IRobot robot,JMenuItem item){
  if (EnvironmentUtils.isMacOS()) {
    TimeUtil.delay(300);
  }
  if (!item.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  if (item.getParent() instanceof JPopupMenu && ((JPopupMenu)item.getParent()).getInvoker().getParent() instanceof JMenuBar) {
    if (!EnvironmentUtils.isMacOS()) {
      robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED).setFirstHorizontal(false));
    }
 else {
      item.doClick(100);
    }
  }
 else {
    if (!EnvironmentUtils.isMacOS()) {
      robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED));
    }
 else {
      item.doClick(100);
    }
  }
}","/** 
 * Clicks on a menu item
 * @param robot the robot
 * @param item  the menu item
 */
private void clickMenuItem(IRobot robot,JMenuItem item){
  if (EnvironmentUtils.isMacOS()) {
    TimeUtil.delay(300);
  }
  if (!item.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  MenuSelectionManager selectionmanager=MenuSelectionManager.defaultManager();
  MenuElement[] menus=new MenuElement[0];
  if (selectionmanager != null) {
    menus=MenuSelectionManager.defaultManager().getSelectedPath();
  }
  if (item.getParent() instanceof JPopupMenu && ((JPopupMenu)item.getParent()).getInvoker().getParent() instanceof JMenuBar) {
    if (!EnvironmentUtils.isMacOS() || (menus.length > 0 && menus[0] instanceof JPopupMenu)) {
      robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED).setFirstHorizontal(false));
    }
 else {
      item.doClick();
    }
  }
 else {
    if (!EnvironmentUtils.isMacOS() || (menus.length > 0 && menus[0] instanceof JPopupMenu)) {
      robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED));
    }
 else {
      item.doClick();
    }
  }
}",0.8391019644527596
95552,"/** 
 * Refreshes the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(masterSession.merge(getWorkVersion()));
      Persistor.instance().getTransaction(masterSession).commit();
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}","/** 
 * Refreshes the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(masterSession.merge(getWorkVersion()));
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}",0.9572431397574984
95553,"/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      if (originalCategory != null) {
        originalCategory.removeAssociation(parent);
      }
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    EntityManager sess=getEditor().getEditorHelper().getEditSupport().getSession();
    sess.detach(sess.find(toDelete.getClass(),toDelete.getId()));
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}","/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      if (originalCategory != null) {
        originalCategory.removeAssociation(parent);
      }
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    EntityManager sess=getEditor().getEditorHelper().getEditSupport().getSession();
    if (toDelete.getId() != null) {
      IComponentNamePO toRem=sess.find(toDelete.getClass(),toDelete.getId());
      if (toRem != null) {
        sess.detach(toRem);
      }
    }
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}",0.95361380798274
95554,"/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  IStructuredSelection structuredSelection=getSelection();
  Set<IComponentNamePO> toDelete=new HashSet<IComponentNamePO>();
  for (  Object obj : structuredSelection.toArray()) {
    if (obj instanceof IComponentNamePO) {
      toDelete.add((IComponentNamePO)obj);
    }
  }
  List<String> itemNames=new ArrayList<String>();
  for (  IComponentNamePO compName : toDelete) {
    itemNames.add(compName.getName());
  }
  if (confirmDelete(itemNames)) {
    EntityManager s=GeneralStorage.getInstance().getMasterSession();
    try {
      EntityTransaction tx=Persistor.instance().getTransaction(s);
      Persistor.instance().lockPOSet(s,toDelete);
      for (      IComponentNamePO compName : toDelete) {
        s.remove(s.merge(compName));
      }
      Persistor.instance().commitTransaction(s,tx);
      for (      IComponentNamePO compName : toDelete) {
        DataEventDispatcher.getInstance().fireDataChangedListener(compName,DataState.Deleted,UpdateState.all);
        ComponentNamesBP.getInstance().removeComponentNamePO(compName.getGuid());
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  IStructuredSelection structuredSelection=getSelection();
  Set<IComponentNamePO> toDelete=new HashSet<IComponentNamePO>();
  for (  Object obj : structuredSelection.toArray()) {
    if (obj instanceof IComponentNamePO) {
      toDelete.add((IComponentNamePO)obj);
    }
  }
  List<String> itemNames=new ArrayList<String>();
  for (  IComponentNamePO compName : toDelete) {
    itemNames.add(compName.getName());
  }
  if (confirmDelete(itemNames)) {
    EntityManager s=Persistor.instance().openSession();
    try {
      EntityTransaction tx=Persistor.instance().getTransaction(s);
      Persistor.instance().lockPOSet(s,toDelete);
      for (      IComponentNamePO compName : toDelete) {
        s.remove(s.merge(compName));
      }
      Persistor.instance().commitTransaction(s,tx);
      EntityManager masterRO=GeneralStorage.getInstance().getMasterSession();
      IComponentNamePO temp;
      for (      IComponentNamePO compName : toDelete) {
        temp=masterRO.find(compName.getClass(),compName.getId());
        if (temp != null) {
          masterRO.detach(temp);
        }
        ComponentNamesBP.getInstance().removeComponentNamePO(compName.getGuid());
        DataEventDispatcher.getInstance().fireDataChangedListener(compName,DataState.Deleted,UpdateState.all);
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
 finally {
      Persistor.instance().dropSession(s);
    }
  }
  return null;
}",0.8208015899304405
95555,"/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  IComponentNamePO compName=getSelectedComponentName();
  if (compName != null) {
    EntityManager renameSession=GeneralStorage.getInstance().getMasterSession();
    try {
      ProjectComponentNameMapper compNameMapper=new ProjectComponentNameMapper(new ComponentNamesDecorator(renameSession),GeneralStorage.getInstance().getProject());
      String newName=getNewName(event,compNameMapper,compName);
      if (newName != null) {
        EntityTransaction tx=Persistor.instance().getTransaction(renameSession);
        rename(compNameMapper,compName.getGuid(),newName);
        Persistor.instance().commitTransaction(renameSession,tx);
        compNameMapper.getCompNameCache().updateStandardMapperAndCleanup(GeneralStorage.getInstance().getProject().getId());
        IComponentNamePO eventCompName=ComponentNamesBP.getInstance().getCompNamePo(compName.getGuid());
        DataEventDispatcher.getInstance().fireDataChangedListener(eventCompName,DataState.Renamed,UpdateState.all);
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  IComponentNamePO compName=getSelectedComponentName();
  if (compName != null) {
    EntityManager renameSession=Persistor.instance().openSession();
    try {
      ProjectComponentNameMapper compNameMapper=new ProjectComponentNameMapper(new ComponentNamesDecorator(renameSession),GeneralStorage.getInstance().getProject());
      String newName=getNewName(event,compNameMapper,compName);
      if (newName != null) {
        EntityTransaction tx=Persistor.instance().getTransaction(renameSession);
        rename(compNameMapper,compName.getGuid(),newName);
        Persistor.instance().commitTransaction(renameSession,tx);
        compNameMapper.getCompNameCache().updateStandardMapperAndCleanup(GeneralStorage.getInstance().getProject().getId());
        IComponentNamePO eventCompName=ComponentNamesBP.getInstance().getCompNamePo(compName.getGuid());
        DataEventDispatcher.getInstance().fireDataChangedListener(eventCompName,DataState.Renamed,UpdateState.all);
        EntityManager masterRO=GeneralStorage.getInstance().getMasterSession();
        IComponentNamePO refreshCN;
        refreshCN=masterRO.find(compName.getClass(),compName.getId());
        if (refreshCN != null) {
          masterRO.refresh(refreshCN);
        }
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
 finally {
      Persistor.instance().dropSession(renameSession);
    }
  }
  return null;
}",0.8615490061686086
95556,"/** 
 * register handler for project load and data change to clear caches
 */
public ComponentNameBrowserContentProvider(){
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addProjectLoadedListener(this,true);
  ded.addDataChangedListener(this,true);
}","/** 
 * register handler for project load and data change to clear caches
 */
public ComponentNameBrowserContentProvider(){
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addProjectLoadedListener(this,true);
  ded.addDataChangedListener(this,false);
}",0.9870609981515712
95557,"/** 
 * {@inheritDoc}
 */
public void inputChanged(final Viewer viewer,Object oldInput,final Object newInput){
  Validate.isTrue(viewer instanceof TreeViewer);
  m_childToParentMap.clear();
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  if (m_modelListener != null) {
    ded.removeDataChangedListener(m_modelListener);
    m_modelListener=null;
  }
  if (newInput != null) {
    m_modelListener=new IDataChangedListener(){
      /** 
 * {@inheritDoc} 
 */
      public void handleDataChanged(      DataChangedEvent... events){
        for (        DataChangedEvent e : events) {
          handleDataChanged(e.getPo(),e.getDataState(),e.getUpdateState());
        }
      }
      public void handleDataChanged(      IPersistentObject po,      DataState dataState,      UpdateState updateState){
        if (updateState != UpdateState.notInEditor) {
          StructuredViewer structuredViewer=(StructuredViewer)viewer;
          if (dataState == DataState.StructureModified) {
            boolean objectsAreEqual=structuredViewer.getComparer() != null ? structuredViewer.getComparer().equals(newInput,po) : newInput.equals(po);
            if (objectsAreEqual || po instanceof IAUTMainPO || po instanceof IObjectMappingPO) {
              structuredViewer.refresh();
            }
 else {
              structuredViewer.refresh(po);
            }
          }
 else           if (dataState == DataState.Renamed) {
            structuredViewer.update(po,null);
          }
        }
      }
    }
;
    ded.addDataChangedListener(m_modelListener,true);
  }
}","/** 
 * {@inheritDoc}
 */
public void inputChanged(final Viewer viewer,Object oldInput,final Object newInput){
  Validate.isTrue(viewer instanceof TreeViewer);
  m_childToParentMap.clear();
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  if (m_modelListener != null) {
    ded.removeDataChangedListener(m_modelListener);
    m_modelListener=null;
  }
  if (newInput != null) {
    m_modelListener=new IDataChangedListener(){
      /** 
 * {@inheritDoc} 
 */
      public void handleDataChanged(      DataChangedEvent... events){
        for (        DataChangedEvent e : events) {
          handleDataChanged(e.getPo(),e.getDataState(),e.getUpdateState());
        }
      }
      public void handleDataChanged(      IPersistentObject po,      DataState dataState,      UpdateState updateState){
        if (updateState != UpdateState.notInEditor) {
          StructuredViewer structuredViewer=(StructuredViewer)viewer;
          if (dataState == DataState.StructureModified) {
            boolean objectsAreEqual=structuredViewer.getComparer() != null ? structuredViewer.getComparer().equals(newInput,po) : newInput.equals(po);
            if (objectsAreEqual || po instanceof IAUTMainPO || po instanceof IObjectMappingPO) {
              structuredViewer.refresh();
            }
 else {
              structuredViewer.refresh(po);
            }
          }
 else           if (dataState == DataState.Renamed) {
            structuredViewer.update(po,null);
          }
        }
      }
    }
;
    ded.addDataChangedListener(m_modelListener,false);
  }
}",0.9977742448330684
95558,"/** 
 * Tries to select a menu item in a menu defined by an Index-Path
 * @param indexPath the menu item to select
 */
public void selectMenuItemByIndexpath(String indexPath){
  int[] indexItems=MenuUtilBase.splitIndexPath(indexPath);
  checkPathLength(indexItems.length);
  try {
    final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),indexItems);
    checkIsNull(item);
    item.selectMenuItem();
    if (EnvironmentUtils.isMacOS() && item.isShowing()) {
      MenuSelectionManager.defaultManager().clearSelectedPath();
    }
  }
 catch (  StepExecutionException e) {
    try {
      closeMenu(getAndCheckMenu(),indexItems);
    }
 catch (    StepExecutionException e1) {
      if (getLog().isInfoEnabled()) {
        getLog().info(""String_Node_Str"");
      }
    }
    throwMenuItemNotFound();
  }
}","/** 
 * Tries to select a menu item in a menu defined by an Index-Path
 * @param indexPath the menu item to select
 */
public void selectMenuItemByIndexpath(String indexPath){
  int[] indexItems=MenuUtilBase.splitIndexPath(indexPath);
  checkPathLength(indexItems.length);
  try {
    final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),indexItems);
    checkIsNull(item);
    item.selectMenuItem();
    if (EnvironmentUtils.isMacOS() && item.isShowing()) {
      closeMenu(getAndCheckMenu(),indexItems);
    }
  }
 catch (  StepExecutionException e) {
    try {
      closeMenu(getAndCheckMenu(),indexItems);
    }
 catch (    StepExecutionException e1) {
      if (getLog().isInfoEnabled()) {
        getLog().info(""String_Node_Str"");
      }
    }
    throwMenuItemNotFound();
  }
}",0.9419035846724352
95559,"/** 
 * Tries to select a menu item in a menu defined by a Text-Path
 * @param namePath the menu item to select
 * @param operator operator used for matching
 */
public void selectMenuItem(String namePath,final String operator){
  String[] menuItems=MenuUtilBase.splitPath(namePath);
  if (menuItems.length == 0) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError());
  }
  IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItems,operator);
  if (item == null || item.getRealComponent() == null) {
    try {
      closeMenu(getAndCheckMenu(),menuItems,operator);
    }
 catch (    StepExecutionException see) {
      getLog().info(""String_Node_Str"");
    }
    throwMenuItemNotFound();
  }
  item.selectMenuItem();
  if (EnvironmentUtils.isMacOS() && item.isShowing()) {
    MenuSelectionManager.defaultManager().clearSelectedPath();
  }
}","/** 
 * Tries to select a menu item in a menu defined by a Text-Path
 * @param namePath the menu item to select
 * @param operator operator used for matching
 */
public void selectMenuItem(String namePath,final String operator){
  String[] menuItems=MenuUtilBase.splitPath(namePath);
  if (menuItems.length == 0) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError());
  }
  IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItems,operator);
  if (item == null || item.getRealComponent() == null) {
    try {
      closeMenu(getAndCheckMenu(),menuItems,operator);
    }
 catch (    StepExecutionException see) {
      getLog().info(""String_Node_Str"");
    }
    throwMenuItemNotFound();
  }
  item.selectMenuItem();
  if (EnvironmentUtils.isMacOS() && item.isShowing()) {
    closeMenu(getAndCheckMenu(),menuItems,operator);
  }
}",0.9424379232505644
95560,"/** 
 * {@inheritDoc}
 */
protected void closeMenu(IMenuComponent menuBar,int[] path){
  if (menuBar.getRealComponent() instanceof JPopupMenu) {
    for (int i=0; i < path.length; i++) {
      if (((JPopupMenu)menuBar.getRealComponent()).isVisible()) {
        getRobot().keyType(menuBar.getRealComponent(),KeyEvent.VK_ESCAPE);
      }
    }
    return;
  }
  super.closeMenu(menuBar,path);
}","/** 
 * {@inheritDoc}
 */
protected void closeMenu(IMenuComponent menuBar,int[] path){
  if (closMacMenus()) {
    return;
  }
  if (menuBar.getRealComponent() instanceof JPopupMenu) {
    for (int i=0; i < path.length; i++) {
      if (((JPopupMenu)menuBar.getRealComponent()).isVisible()) {
        getRobot().keyType(menuBar.getRealComponent(),KeyEvent.VK_ESCAPE);
      }
    }
    return;
  }
  super.closeMenu(menuBar,path);
}",0.9514563106796116
95561,"/** 
 * Checks if there are unused Test Data in this TDManagerPO  (Data column without a parameter).
 * @return true if there are unused Test Data in this TDManagerPO., false otherwise.
 */
public boolean checkHasUnusedTestData(){
  for (  String colId : getDataManager().getUniqueIds()) {
    boolean hasColIdParam=false;
    for (ListIterator<IParamDescriptionPO> paramListIter=getParameterListIter(); paramListIter.hasNext(); ) {
      IParamDescriptionPO paramDescr=paramListIter.next();
      if (colId.equals(paramDescr.getUniqueId())) {
        hasColIdParam=true;
        break;
      }
    }
    if (!hasColIdParam) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if there are unused Test Data in this TDManagerPO  (Data column without a parameter).
 * @return true if there are unused Test Data in this TDManagerPO., false otherwise.
 */
public boolean checkHasUnusedTestData(){
  if (getReferencedDataCube() == null) {
    for (    String colId : getDataManager().getUniqueIds()) {
      boolean hasColIdParam=false;
      for (ListIterator<IParamDescriptionPO> paramListIter=getParameterListIter(); paramListIter.hasNext(); ) {
        IParamDescriptionPO paramDescr=paramListIter.next();
        if (colId.equals(paramDescr.getUniqueId())) {
          hasColIdParam=true;
          break;
        }
      }
      if (!hasColIdParam) {
        return true;
      }
    }
  }
  return false;
}",0.941508104298802
95562,"/** 
 * @param tdc the test data cube to search for reusage
 * @param session The session into which the test cases will be loaded.
 * @return list of ITestDataCubePO
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static List<ITestDataCubePO> computeReuser(IParameterInterfacePO tdc,EntityManager session){
  CriteriaBuilder builder=session.getCriteriaBuilder();
  CriteriaQuery query=builder.createQuery();
  Root from=query.from(PoMaker.getTestDataCubeClass());
  query.select(from).where(builder.isNotNull(from.get(""String_Node_Str"")));
  List<ITestDataCubePO> queryResult=session.createQuery(query).getResultList();
  List<ITestDataCubePO> result=new ArrayList<ITestDataCubePO>();
  for (  ITestDataCubePO pio : queryResult) {
    if (areEqual(pio.getReferencedDataCube(),tdc)) {
      result.add(pio);
    }
  }
  return result;
}","/** 
 * @param tdc the test data cube to search for reusage
 * @param session The session into which the test cases will be loaded.
 * @return list of ITestDataCubePO
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static List<ITestDataCubePO> computeReuser(IParameterInterfacePO tdc,EntityManager session){
  CriteriaBuilder builder=session.getCriteriaBuilder();
  CriteriaQuery query=builder.createQuery();
  Root from=query.from(PoMaker.getTestDataCubeClass());
  query.select(from).where(builder.and(builder.isNotNull(from.get(""String_Node_Str"")),builder.equal(from.get(""String_Node_Str""),tdc.getParentProjectId())));
  List<ITestDataCubePO> queryResult=session.createQuery(query).getResultList();
  List<ITestDataCubePO> result=new ArrayList<ITestDataCubePO>();
  for (  ITestDataCubePO pio : queryResult) {
    if (areEqual(pio.getReferencedDataCube(),tdc)) {
      result.add(pio);
    }
  }
  return result;
}",0.954824316787507
95563,"/** 
 * Refreshes the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(masterSession.merge(getWorkVersion()));
      Persistor.instance().getTransaction(masterSession).commit();
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}","/** 
 * Refreshes the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(masterSession.merge(getWorkVersion()));
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}",0.9572431397574984
95564,"/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      if (originalCategory != null) {
        originalCategory.removeAssociation(parent);
      }
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    EntityManager sess=getEditor().getEditorHelper().getEditSupport().getSession();
    sess.detach(sess.find(toDelete.getClass(),toDelete.getId()));
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}","/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      if (originalCategory != null) {
        originalCategory.removeAssociation(parent);
      }
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    EntityManager sess=getEditor().getEditorHelper().getEditSupport().getSession();
    if (toDelete.getId() != null) {
      IComponentNamePO toRem=sess.find(toDelete.getClass(),toDelete.getId());
      if (toRem != null) {
        sess.detach(toRem);
      }
    }
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}",0.95361380798274
95565,"/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  IStructuredSelection structuredSelection=getSelection();
  Set<IComponentNamePO> toDelete=new HashSet<IComponentNamePO>();
  for (  Object obj : structuredSelection.toArray()) {
    if (obj instanceof IComponentNamePO) {
      toDelete.add((IComponentNamePO)obj);
    }
  }
  List<String> itemNames=new ArrayList<String>();
  for (  IComponentNamePO compName : toDelete) {
    itemNames.add(compName.getName());
  }
  if (confirmDelete(itemNames)) {
    EntityManager s=GeneralStorage.getInstance().getMasterSession();
    try {
      EntityTransaction tx=Persistor.instance().getTransaction(s);
      Persistor.instance().lockPOSet(s,toDelete);
      for (      IComponentNamePO compName : toDelete) {
        s.remove(s.merge(compName));
      }
      Persistor.instance().commitTransaction(s,tx);
      for (      IComponentNamePO compName : toDelete) {
        DataEventDispatcher.getInstance().fireDataChangedListener(compName,DataState.Deleted,UpdateState.all);
        ComponentNamesBP.getInstance().removeComponentNamePO(compName.getGuid());
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  IStructuredSelection structuredSelection=getSelection();
  Set<IComponentNamePO> toDelete=new HashSet<IComponentNamePO>();
  for (  Object obj : structuredSelection.toArray()) {
    if (obj instanceof IComponentNamePO) {
      toDelete.add((IComponentNamePO)obj);
    }
  }
  List<String> itemNames=new ArrayList<String>();
  for (  IComponentNamePO compName : toDelete) {
    itemNames.add(compName.getName());
  }
  if (confirmDelete(itemNames)) {
    EntityManager s=Persistor.instance().openSession();
    try {
      EntityTransaction tx=Persistor.instance().getTransaction(s);
      Persistor.instance().lockPOSet(s,toDelete);
      for (      IComponentNamePO compName : toDelete) {
        s.remove(s.merge(compName));
      }
      Persistor.instance().commitTransaction(s,tx);
      EntityManager masterRO=GeneralStorage.getInstance().getMasterSession();
      IComponentNamePO temp;
      for (      IComponentNamePO compName : toDelete) {
        temp=masterRO.find(compName.getClass(),compName.getId());
        if (temp != null) {
          masterRO.detach(temp);
        }
        ComponentNamesBP.getInstance().removeComponentNamePO(compName.getGuid());
        DataEventDispatcher.getInstance().fireDataChangedListener(compName,DataState.Deleted,UpdateState.all);
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
 finally {
      Persistor.instance().dropSession(s);
    }
  }
  return null;
}",0.8208015899304405
95566,"/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  IComponentNamePO compName=getSelectedComponentName();
  if (compName != null) {
    EntityManager renameSession=GeneralStorage.getInstance().getMasterSession();
    try {
      ProjectComponentNameMapper compNameMapper=new ProjectComponentNameMapper(new ComponentNamesDecorator(renameSession),GeneralStorage.getInstance().getProject());
      String newName=getNewName(event,compNameMapper,compName);
      if (newName != null) {
        EntityTransaction tx=Persistor.instance().getTransaction(renameSession);
        rename(compNameMapper,compName.getGuid(),newName);
        Persistor.instance().commitTransaction(renameSession,tx);
        compNameMapper.getCompNameCache().updateStandardMapperAndCleanup(GeneralStorage.getInstance().getProject().getId());
        IComponentNamePO eventCompName=ComponentNamesBP.getInstance().getCompNamePo(compName.getGuid());
        DataEventDispatcher.getInstance().fireDataChangedListener(eventCompName,DataState.Renamed,UpdateState.all);
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  IComponentNamePO compName=getSelectedComponentName();
  if (compName != null) {
    EntityManager renameSession=Persistor.instance().openSession();
    try {
      ProjectComponentNameMapper compNameMapper=new ProjectComponentNameMapper(new ComponentNamesDecorator(renameSession),GeneralStorage.getInstance().getProject());
      String newName=getNewName(event,compNameMapper,compName);
      if (newName != null) {
        EntityTransaction tx=Persistor.instance().getTransaction(renameSession);
        rename(compNameMapper,compName.getGuid(),newName);
        Persistor.instance().commitTransaction(renameSession,tx);
        compNameMapper.getCompNameCache().updateStandardMapperAndCleanup(GeneralStorage.getInstance().getProject().getId());
        IComponentNamePO eventCompName=ComponentNamesBP.getInstance().getCompNamePo(compName.getGuid());
        DataEventDispatcher.getInstance().fireDataChangedListener(eventCompName,DataState.Renamed,UpdateState.all);
        EntityManager masterRO=GeneralStorage.getInstance().getMasterSession();
        IComponentNamePO refreshCN;
        refreshCN=masterRO.find(compName.getClass(),compName.getId());
        if (refreshCN != null) {
          masterRO.refresh(refreshCN);
        }
      }
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleProjectDeletedException();
    }
 finally {
      Persistor.instance().dropSession(renameSession);
    }
  }
  return null;
}",0.8615490061686086
95567,"/** 
 * register handler for project load and data change to clear caches
 */
public ComponentNameBrowserContentProvider(){
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addProjectLoadedListener(this,true);
  ded.addDataChangedListener(this,true);
}","/** 
 * register handler for project load and data change to clear caches
 */
public ComponentNameBrowserContentProvider(){
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addProjectLoadedListener(this,true);
  ded.addDataChangedListener(this,false);
}",0.9870609981515712
95568,"/** 
 * {@inheritDoc}
 */
public void inputChanged(final Viewer viewer,Object oldInput,final Object newInput){
  Validate.isTrue(viewer instanceof TreeViewer);
  m_childToParentMap.clear();
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  if (m_modelListener != null) {
    ded.removeDataChangedListener(m_modelListener);
    m_modelListener=null;
  }
  if (newInput != null) {
    m_modelListener=new IDataChangedListener(){
      /** 
 * {@inheritDoc} 
 */
      public void handleDataChanged(      DataChangedEvent... events){
        for (        DataChangedEvent e : events) {
          handleDataChanged(e.getPo(),e.getDataState(),e.getUpdateState());
        }
      }
      public void handleDataChanged(      IPersistentObject po,      DataState dataState,      UpdateState updateState){
        if (updateState != UpdateState.notInEditor) {
          StructuredViewer structuredViewer=(StructuredViewer)viewer;
          if (dataState == DataState.StructureModified) {
            boolean objectsAreEqual=structuredViewer.getComparer() != null ? structuredViewer.getComparer().equals(newInput,po) : newInput.equals(po);
            if (objectsAreEqual || po instanceof IAUTMainPO || po instanceof IObjectMappingPO) {
              structuredViewer.refresh();
            }
 else {
              structuredViewer.refresh(po);
            }
          }
 else           if (dataState == DataState.Renamed) {
            structuredViewer.update(po,null);
          }
        }
      }
    }
;
    ded.addDataChangedListener(m_modelListener,true);
  }
}","/** 
 * {@inheritDoc}
 */
public void inputChanged(final Viewer viewer,Object oldInput,final Object newInput){
  Validate.isTrue(viewer instanceof TreeViewer);
  m_childToParentMap.clear();
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  if (m_modelListener != null) {
    ded.removeDataChangedListener(m_modelListener);
    m_modelListener=null;
  }
  if (newInput != null) {
    m_modelListener=new IDataChangedListener(){
      /** 
 * {@inheritDoc} 
 */
      public void handleDataChanged(      DataChangedEvent... events){
        for (        DataChangedEvent e : events) {
          handleDataChanged(e.getPo(),e.getDataState(),e.getUpdateState());
        }
      }
      public void handleDataChanged(      IPersistentObject po,      DataState dataState,      UpdateState updateState){
        if (updateState != UpdateState.notInEditor) {
          StructuredViewer structuredViewer=(StructuredViewer)viewer;
          if (dataState == DataState.StructureModified) {
            boolean objectsAreEqual=structuredViewer.getComparer() != null ? structuredViewer.getComparer().equals(newInput,po) : newInput.equals(po);
            if (objectsAreEqual || po instanceof IAUTMainPO || po instanceof IObjectMappingPO) {
              structuredViewer.refresh();
            }
 else {
              structuredViewer.refresh(po);
            }
          }
 else           if (dataState == DataState.Renamed) {
            structuredViewer.update(po,null);
          }
        }
      }
    }
;
    ded.addDataChangedListener(m_modelListener,false);
  }
}",0.9977742448330684
95569,"/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IContainerAdapter.class)) {
    if (objectToAdapt instanceof ListCell) {
      return new CustomContainerAdapter((ListCell<?>)objectToAdapt);
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass == IContainerAdapter.class) {
    if (objectToAdapt instanceof ListCell) {
      return new CustomContainerAdapter((ListCell<?>)objectToAdapt);
    }
  }
  return null;
}",0.8854700854700854
95570,"/** 
 * @param targetAdapterClass Type of the adapter
 * @param objectToAdapt object that should be adapted
 * @return Returns an adapter for the objectToAdapt of typetargetAdapterClass. The collection of all supported adapter factories is iterated. The first value that is not null will be returned. <code>Null</code> will only be returned if no adapter can be found for the targetAdapterClass, none of the given factories can handle the objectToAdapt or the objectToAdapt itself is <code>null</code>.
 */
public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  if (objectToAdapt == null) {
    return null;
  }
  Collection<IAdapterFactory> registeredFactories=null;
  Class superClass=objectToAdapt.getClass();
  while (registeredFactories == null && superClass != Object.class) {
    registeredFactories=m_registrationMap.get(superClass);
    superClass=superClass.getSuperclass();
  }
  if (registeredFactories == null) {
    return null;
  }
  for (Iterator<IAdapterFactory> iterator=registeredFactories.iterator(); iterator.hasNext(); ) {
    IAdapterFactory adapterFactory=iterator.next();
    Object object=adapterFactory.getAdapter(targetAdapterClass,objectToAdapt);
    if (object != null) {
      return object;
    }
  }
  return null;
}","/** 
 * @param targetAdapterClass Type of the adapter
 * @param objectToAdapt object that should be adapted
 * @return Returns an adapter for the objectToAdapt of typetargetAdapterClass. The collection of all supported adapter factories is iterated. The first value that is not null will be returned. <code>Null</code> will only be returned if no adapter can be found for the targetAdapterClass, none of the given factories can handle the objectToAdapt or the objectToAdapt itself is <code>null</code>.
 */
public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  if (objectToAdapt == null) {
    return null;
  }
  Collection<IAdapterFactory> registeredFactories=null;
  Class superClass=objectToAdapt.getClass();
  registeredFactories=findAdapterFactories(objectToAdapt,superClass);
  while (registeredFactories != null && superClass != Object.class) {
    for (Iterator<IAdapterFactory> iterator=registeredFactories.iterator(); iterator.hasNext(); ) {
      IAdapterFactory adapterFactory=iterator.next();
      Object object=adapterFactory.getAdapter(targetAdapterClass,objectToAdapt);
      if (object != null) {
        return object;
      }
    }
    superClass=superClass.getSuperclass();
    registeredFactories=findAdapterFactories(objectToAdapt,superClass);
  }
  return null;
}",0.6814124951493985
95571,"/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IContainerAdapter.class)) {
    if (objectToAdapt instanceof ButtonBar) {
      return new ButtonBarContainerAdapter<ButtonBar>((ButtonBar)objectToAdapt);
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass == IContainerAdapter.class) {
    if (objectToAdapt instanceof ButtonBar) {
      return new ButtonBarContainerAdapter<ButtonBar>((ButtonBar)objectToAdapt);
    }
  }
  return null;
}",0.8903436988543372
95572,"@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.isAssignableFrom(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IContainerAdapter.class)) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}","@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.isAssignableFrom(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass == IContainerAdapter.class) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}",0.9428815004262576
95573,"/** 
 * @param nodes the nodes to delete
 * @param editor the editor to perfrom the deletion for
 */
public static void deleteNodesFromEditor(List<? extends INodePO> nodes,AbstractJBEditor editor){
  editor.getEditorHelper().getClipboard().clearContents();
  for (  INodePO node : nodes) {
    try {
      node.getParentNode().removeNode(node);
      if (node.getId() != null) {
        editor.getEditorHelper().getEditSupport().getSession().remove(node);
      }
      editor.getEditorHelper().setDirty(true);
      DataEventDispatcher.getInstance().fireDataChangedListener(node,DataState.Deleted,UpdateState.onlyInEditor);
    }
 catch (    PersistenceException e) {
      try {
        PersistenceManager.handleDBExceptionForEditor(node,e,editor.getEditorHelper().getEditSupport());
      }
 catch (      PMException pme) {
        PMExceptionHandler.handlePMExceptionForMasterSession(pme);
      }
    }
  }
}","/** 
 * @param nodes the nodes to delete
 * @param editor the editor to perfrom the deletion for
 */
public static void deleteNodesFromEditor(List<? extends INodePO> nodes,AbstractJBEditor editor){
  editor.getEditorHelper().getClipboard().clearContents();
  for (  INodePO node : nodes) {
    try {
      node.getParentNode().removeNode(node);
      if (node instanceof IExecTestCasePO) {
        IExecTestCasePO po=(IExecTestCasePO)node;
        Collection<ICompNamesPairPO> col=po.getCompNamesPairs();
        for (        ICompNamesPairPO iCompNamesPairPO : col) {
          iCompNamesPairPO.getSecondName();
        }
      }
      if (node.getId() != null) {
        editor.getEditorHelper().getEditSupport().getSession().remove(node);
      }
      createReuseEvents(editor,node);
      editor.getEditorHelper().setDirty(true);
      DataEventDispatcher.getInstance().fireDataChangedListener(node,DataState.Deleted,UpdateState.onlyInEditor);
    }
 catch (    PersistenceException e) {
      try {
        PersistenceManager.handleDBExceptionForEditor(node,e,editor.getEditorHelper().getEditSupport());
      }
 catch (      PMException pme) {
        PMExceptionHandler.handlePMExceptionForMasterSession(pme);
      }
    }
  }
}",0.8493023255813954
95574,"/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      originalCategory.removeAssociation(parent);
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}","/** 
 * Deletes the given Component Name from the object map.
 * @param toDelete The Component Name to delete.
 * @return the category to which the Component Name belonged before it wasdeleted.
 */
public IObjectMappingCategoryPO deleteCompName(IComponentNamePO toDelete){
  IObjectMappingCategoryPO originalCategory=null;
  IWritableComponentNameMapper compNameMapper=getEditor().getEditorHelper().getEditSupport().getCompMapper();
  IObjectMappingAssoziationPO parent=getAssociation(toDelete.getGuid());
  try {
    compNameMapper.changeReuse(parent,toDelete.getGuid(),null);
    IObjectMappingCategoryPO category=parent.getCategory();
    originalCategory=category;
    if (parent.getLogicalNames().isEmpty()) {
      if (originalCategory != null) {
        originalCategory.removeAssociation(parent);
      }
      if (parent.getTechnicalName() != null) {
        Stack<String> catPath=new Stack<String>();
        while (category.getParent() != null) {
          catPath.push(category.getName());
          category=category.getParent();
        }
        IObjectMappingCategoryPO newCategory=getEditor().getAut().getObjMap().getUnmappedTechnicalCategory();
        while (!catPath.isEmpty()) {
          String catName=catPath.pop();
          IObjectMappingCategoryPO subcategory=findSubcategory(newCategory,catName);
          if (subcategory == null) {
            subcategory=PoMaker.createObjectMappingCategoryPO(catName);
            newCategory.addCategory(subcategory);
          }
          newCategory=subcategory;
        }
        newCategory.addAssociation(parent);
      }
 else {
        getEditor().getEditorHelper().getEditSupport().getSession().remove(parent);
      }
    }
    DataEventDispatcher.getInstance().fireDataChangedListener(getEditor().getAut().getObjMap(),DataState.StructureModified,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException ite) {
    ErrorHandlingUtil.createMessageDialog(ite,ite.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,getEditor());
  }
  return originalCategory;
}",0.9884892086330936
95575,"/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass == IContainerAdapter.class) {
    if (objectToAdapt instanceof ListCell) {
      return new CustomContainerAdapter((ListCell<?>)objectToAdapt);
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IContainerAdapter.class)) {
    if (objectToAdapt instanceof ListCell) {
      return new CustomContainerAdapter((ListCell<?>)objectToAdapt);
    }
  }
  return null;
}",0.9606837606837608
95576,"/** 
 * @param targetAdapterClass Type of the adapter
 * @param objectToAdapt object that should be adapted
 * @return Returns an adapter for the objectToAdapt of typetargetAdapterClass. The collection of all supported adapter factories is iterated. The first value that is not null will be returned. <code>Null</code> will only be returned if no adapter can be found for the targetAdapterClass, none of the given factories can handle the objectToAdapt or the objectToAdapt itself is <code>null</code>.
 */
public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  if (objectToAdapt == null) {
    return null;
  }
  Collection<IAdapterFactory> registeredFactories=null;
  Class superClass=objectToAdapt.getClass();
  registeredFactories=findAdapterFactories(objectToAdapt,superClass);
  while (registeredFactories != null && superClass != Object.class) {
    for (Iterator<IAdapterFactory> iterator=registeredFactories.iterator(); iterator.hasNext(); ) {
      IAdapterFactory adapterFactory=iterator.next();
      Object object=adapterFactory.getAdapter(targetAdapterClass,objectToAdapt);
      if (object != null) {
        return object;
      }
    }
    superClass=superClass.getSuperclass();
    registeredFactories=findAdapterFactories(objectToAdapt,superClass);
  }
  return null;
}","/** 
 * @param targetAdapterClass Type of the adapter
 * @param objectToAdapt object that should be adapted
 * @return Returns an adapter for the objectToAdapt of typetargetAdapterClass. The collection of all supported adapter factories is iterated. The first value that is not null will be returned. <code>Null</code> will only be returned if no adapter can be found for the targetAdapterClass, none of the given factories can handle the objectToAdapt or the objectToAdapt itself is <code>null</code>.
 */
public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  if (objectToAdapt == null) {
    return null;
  }
  Collection<IAdapterFactory> registeredFactories=null;
  Class superClass=objectToAdapt.getClass();
  while (registeredFactories == null && superClass != Object.class) {
    registeredFactories=m_registrationMap.get(superClass);
    superClass=superClass.getSuperclass();
  }
  if (registeredFactories == null) {
    return null;
  }
  for (Iterator<IAdapterFactory> iterator=registeredFactories.iterator(); iterator.hasNext(); ) {
    IAdapterFactory adapterFactory=iterator.next();
    Object object=adapterFactory.getAdapter(targetAdapterClass,objectToAdapt);
    if (object != null) {
      return object;
    }
  }
  return null;
}",0.673651532790066
95577,"/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass == IContainerAdapter.class) {
    if (objectToAdapt instanceof ButtonBar) {
      return new ButtonBarContainerAdapter<ButtonBar>((ButtonBar)objectToAdapt);
    }
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IContainerAdapter.class)) {
    if (objectToAdapt instanceof ButtonBar) {
      return new ButtonBarContainerAdapter<ButtonBar>((ButtonBar)objectToAdapt);
    }
  }
  return null;
}",0.962356792144026
95578,"@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.isAssignableFrom(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass == IContainerAdapter.class) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}","@Override public Object getAdapter(Class targetAdapterClass,Object objectToAdapt){
  IComponent returnvalue=null;
  if (targetAdapterClass.isAssignableFrom(IComponent.class)) {
    returnvalue=getComponentAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IContainerAdapter.class)) {
    returnvalue=getContainerAdapter(objectToAdapt);
  }
  if (returnvalue == null && targetAdapterClass.isAssignableFrom(IComponent.class) && objectToAdapt instanceof Node) {
    return new JavaFXComponentAdapter<Node>((Node)objectToAdapt);
  }
  return returnvalue;
}",0.9803921568627452
95579,"/** 
 * @param nodes the nodes to delete
 * @param editor the editor to perfrom the deletion for
 */
public static void deleteNodesFromEditor(List<? extends INodePO> nodes,AbstractJBEditor editor){
  editor.getEditorHelper().getClipboard().clearContents();
  for (  INodePO node : nodes) {
    try {
      node.getParentNode().removeNode(node);
      if (node.getId() != null) {
        editor.getEditorHelper().getEditSupport().getSession().remove(node);
      }
      editor.getEditorHelper().setDirty(true);
      DataEventDispatcher.getInstance().fireDataChangedListener(node,DataState.Deleted,UpdateState.onlyInEditor);
    }
 catch (    PersistenceException e) {
      try {
        PersistenceManager.handleDBExceptionForEditor(node,e,editor.getEditorHelper().getEditSupport());
      }
 catch (      PMException pme) {
        PMExceptionHandler.handlePMExceptionForMasterSession(pme);
      }
    }
  }
}","/** 
 * @param nodes the nodes to delete
 * @param editor the editor to perfrom the deletion for
 */
public static void deleteNodesFromEditor(List<? extends INodePO> nodes,AbstractJBEditor editor){
  editor.getEditorHelper().getClipboard().clearContents();
  for (  INodePO node : nodes) {
    try {
      node.getParentNode().removeNode(node);
      if (node instanceof IExecTestCasePO) {
        IExecTestCasePO po=(IExecTestCasePO)node;
        Collection<ICompNamesPairPO> col=po.getCompNamesPairs();
        for (        ICompNamesPairPO iCompNamesPairPO : col) {
          iCompNamesPairPO.getSecondName();
        }
      }
      if (node.getId() != null) {
        editor.getEditorHelper().getEditSupport().getSession().remove(node);
      }
      createReuseEvents(editor,node);
      editor.getEditorHelper().setDirty(true);
      DataEventDispatcher.getInstance().fireDataChangedListener(node,DataState.Deleted,UpdateState.onlyInEditor);
    }
 catch (    PersistenceException e) {
      try {
        PersistenceManager.handleDBExceptionForEditor(node,e,editor.getEditorHelper().getEditSupport());
      }
 catch (      PMException pme) {
        PMExceptionHandler.handlePMExceptionForMasterSession(pme);
      }
    }
  }
}",0.8493023255813954
95580,"/** 
 * Sends a request to a Running AUT. The AUT should then connect to the Client using the provided connection information.
 * @param autId The ID of the AUT to which the message should be sent.
 * @param clientHostName The host name to which the AUT should connect.
 * @param clientPort The port number to which the AUT should connect.
 * @return a response that indicates whether the message was successfully sent. This response does <b>not</b> indicate whether the message  was successfully received and processed.
 */
public ConnectToAutResponseMessage sendConnectToClientMessage(AutIdentifier autId,String clientHostName,int clientPort){
synchronized (m_auts) {
    Communicator autSocket=m_auts.get(autId);
    if (autSocket == null) {
      String errorMsg=""String_Node_Str"";
      LOG.error(errorMsg);
      return new ConnectToAutResponseMessage(errorMsg);
    }
    try {
      Map<String,String> fragmentMap=new HashMap<>();
synchronized (m_autIdToRestartHandler) {
        String startClass=m_autIdToRestartHandler.get(autId).getAUTStartClass();
        Class autServerClass=Class.forName(startClass);
        AbstractStartToolkitAut autStarter=(AbstractStartToolkitAut)autServerClass.newInstance();
        String rcBundleID=autStarter.getRcBundleId();
        if (CommandConstants.RC_JAVAFX_BUNDLE_ID.equals(rcBundleID) || CommandConstants.RC_SWING_BUNDLE_ID.equals(rcBundleID) || CommandConstants.RC_SWT_BUNDLE_ID.equals(rcBundleID)) {
          List<Bundle> fragments=new ArrayList<Bundle>();
          fragments=AbstractStartToolkitAut.getFragmentsForBundleId(rcBundleID);
          for (          Bundle bundle : fragments) {
            StringBuilder pathBuilder=new StringBuilder();
            for (            String entry : AbstractStartToolkitAut.getPathforBundle(bundle)) {
              pathBuilder.append(entry).append(IStartAut.PATH_SEPARATOR);
            }
            if (pathBuilder.length() > 0) {
              fragmentMap.put(pathBuilder.substring(0,pathBuilder.lastIndexOf(IStartAut.PATH_SEPARATOR)),bundle.getHeaders().get(Constants.BUNDLE_NAME));
            }
          }
        }
      }
      autSocket.send(new ConnectToClientMessage(clientHostName,clientPort,fragmentMap));
    }
 catch (    CommunicationException|ClassNotFoundException|InstantiationException|IllegalAccessException ce) {
      LOG.error(ce.getLocalizedMessage(),ce);
      return new ConnectToAutResponseMessage(ce.getLocalizedMessage());
    }
    return new ConnectToAutResponseMessage(null);
  }
}","/** 
 * Sends a request to a Running AUT. The AUT should then connect to the Client using the provided connection information.
 * @param autId The ID of the AUT to which the message should be sent.
 * @param clientHostName The host name to which the AUT should connect.
 * @param clientPort The port number to which the AUT should connect.
 * @return a response that indicates whether the message was successfully sent. This response does <b>not</b> indicate whether the message  was successfully received and processed.
 */
public ConnectToAutResponseMessage sendConnectToClientMessage(AutIdentifier autId,String clientHostName,int clientPort){
synchronized (m_auts) {
    Communicator autSocket=m_auts.get(autId);
    if (autSocket == null) {
      LOG.error(Messages.AutConnectionError);
      return new ConnectToAutResponseMessage(Messages.AutConnectionError);
    }
    try {
      Map<String,String> fragmentMap=new HashMap<>();
synchronized (m_autIdToRestartHandler) {
        String startClass=m_autIdToRestartHandler.get(autId).getAUTStartClass();
        Class autServerClass=Class.forName(startClass);
        AbstractStartToolkitAut autStarter=(AbstractStartToolkitAut)autServerClass.newInstance();
        String rcBundleID=autStarter.getRcBundleId();
        if (CommandConstants.RC_JAVAFX_BUNDLE_ID.equals(rcBundleID) || CommandConstants.RC_SWING_BUNDLE_ID.equals(rcBundleID) || CommandConstants.RC_SWT_BUNDLE_ID.equals(rcBundleID)) {
          List<Bundle> fragments=new ArrayList<Bundle>();
          fragments=AbstractStartToolkitAut.getFragmentsForBundleId(rcBundleID);
          for (          Bundle bundle : fragments) {
            StringBuilder pathBuilder=new StringBuilder();
            for (            String entry : AbstractStartToolkitAut.getPathforBundle(bundle)) {
              pathBuilder.append(entry).append(IStartAut.PATH_SEPARATOR);
            }
            if (pathBuilder.length() > 0) {
              fragmentMap.put(pathBuilder.substring(0,pathBuilder.lastIndexOf(IStartAut.PATH_SEPARATOR)),bundle.getHeaders().get(Constants.BUNDLE_NAME));
            }
          }
        }
      }
      autSocket.send(new ConnectToClientMessage(clientHostName,clientPort,fragmentMap));
    }
 catch (    CommunicationException|ClassNotFoundException|InstantiationException|IllegalAccessException ce) {
      LOG.error(ce.getLocalizedMessage(),ce);
      return new ConnectToAutResponseMessage(ce.getLocalizedMessage());
    }
    return new ConnectToAutResponseMessage(null);
  }
}",0.9787234042553192
95581,"/** 
 * The contructor.
 * @param parentShell The shell.
 * @param autConfig The selected AUTConfiguration in the AUTPropertiesDialog.
 * @param toolkit the toolkit.
 * @param autName The name of the AUT that will be using this configuration.
 * @param autIdValidator The validator for the AUT ID text field.
 */
public AUTConfigPropertiesDialog(Shell parentShell,IAUTConfigPO autConfig,String toolkit,String autName,IValidator autIdValidator){
  super(parentShell);
  m_autConfig=autConfig;
  m_toolkit=toolkit;
  m_autName=autName;
  m_autIdValidator=autIdValidator;
}","/** 
 * The contructor.
 * @param parentShell The shell.
 * @param autConfig The selected AUTConfiguration in the AUTPropertiesDialog.
 * @param toolkit the toolkit.
 * @param autName The name of the AUT that will be using this configuration.
 * @param autIdValidator The validator for the AUT ID text field.
 * @param autConfigNameValidator The validator for the AUT Config Name
 */
public AUTConfigPropertiesDialog(Shell parentShell,IAUTConfigPO autConfig,String toolkit,String autName,IValidator autIdValidator,AutConfigNameValidator autConfigNameValidator){
  super(parentShell);
  m_autConfig=autConfig;
  m_toolkit=toolkit;
  m_autName=autName;
  m_autIdValidator=autIdValidator;
  m_autConfigNameValidator=autConfigNameValidator;
}",0.8715596330275229
95582,"/** 
 * {@inheritDoc}
 */
protected Control createDialogArea(Composite parent){
  DataEventDispatcher.getInstance().getDialogStatusListenerMgr().addListener(this);
  Plugin.getHelpSystem().setHelp(parent,ContextHelpIds.AUT_CONFIG_PROP_DIALOG);
  setTitle(Messages.ProjectWizardAutSettings);
  setMessage(Messages.ProjectWizardAUTData);
  try {
    Composite autConfigComposite=ToolkitSupportBP.getAutConfigComposite(m_toolkit,parent,SWT.H_SCROLL | SWT.V_SCROLL,m_autConfig.getConfigMap(),m_autName);
    autConfigComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
    if (autConfigComposite instanceof AutConfigComponent) {
      ((AutConfigComponent)autConfigComposite).setAutIdValidator(m_autIdValidator);
    }
  }
 catch (  ToolkitPluginException e) {
    log.error(Messages.NoAUTConfigPageForToolkit + StringConstants.COLON + StringConstants.SPACE+ String.valueOf(m_toolkit),e);
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NO_AUTCONFIG_DIALOG);
  }
  return parent;
}","/** 
 * {@inheritDoc}
 */
protected Control createDialogArea(Composite parent){
  DataEventDispatcher.getInstance().getDialogStatusListenerMgr().addListener(this);
  Plugin.getHelpSystem().setHelp(parent,ContextHelpIds.AUT_CONFIG_PROP_DIALOG);
  setTitle(Messages.ProjectWizardAutSettings);
  setMessage(Messages.ProjectWizardAUTData);
  try {
    Composite autConfigComposite=ToolkitSupportBP.getAutConfigComposite(m_toolkit,parent,SWT.H_SCROLL | SWT.V_SCROLL,m_autConfig.getConfigMap(),m_autName);
    autConfigComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
    if (autConfigComposite instanceof AutConfigComponent) {
      m_autConfigComponent=((AutConfigComponent)autConfigComposite);
      m_autConfigComponent.setAutIdValidator(m_autIdValidator);
      m_autConfigComponent.setAutConfignameValidator(m_autConfigNameValidator);
    }
  }
 catch (  ToolkitPluginException e) {
    log.error(Messages.NoAUTConfigPageForToolkit + StringConstants.COLON + StringConstants.SPACE+ String.valueOf(m_toolkit),e);
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NO_AUTCONFIG_DIALOG);
  }
  return parent;
}",0.9018318459370596
95583,"/** 
 * Handles the selectionEvent of the Edit Button.
 */
private void handleEditButtonEvent(){
  IAUTConfigPO autConfig=getSelectedAUTConf();
  if (autConfig != null) {
    Map<String,String> preEditConfig=PoMaker.createAUTConfigPO().getConfigMap();
    Utils.makeAutConfigCopy(autConfig.getConfigMap(),preEditConfig);
    AUTConfigPropertiesDialog dialog=new AUTConfigPropertiesDialog(m_editButton.getShell(),autConfig,getAutToolkit(),m_autMain.getName(),new AutIdValidator(m_project,m_autMain,autConfig));
    dialog.create();
    DialogUtils.setWidgetNameForModalDialog(dialog);
    dialog.getShell().setText(Messages.AUTPropertiesDialogAUTConfigTitle);
    dialog.open();
    if (dialog.getReturnCode() == Window.OK) {
      final Set<IAUTConfigPO> autConfigSet=m_autMain.getAutConfigSet();
      String[] listHelper=new String[autConfigSet.size()];
      int i=0;
      for (      IAUTConfigPO configPO : autConfigSet) {
        listHelper[i]=configPO.getName();
        i++;
      }
      setAutConfigList(listHelper);
    }
 else {
      Utils.makeAutConfigCopy(preEditConfig,autConfig.getConfigMap());
    }
    Map<String,String> newAutConfigMap=new HashMap<String,String>(autConfig.getConfigMap());
    autConfig.setConfigMap(newAutConfigMap);
    setFocus(new String[]{autConfig.getName()});
  }
}","/** 
 * Handles the selectionEvent of the Edit Button.
 */
private void handleEditButtonEvent(){
  IAUTConfigPO autConfig=getSelectedAUTConf();
  if (autConfig != null) {
    Map<String,String> preEditConfig=PoMaker.createAUTConfigPO().getConfigMap();
    Utils.makeAutConfigCopy(autConfig.getConfigMap(),preEditConfig);
    AUTConfigPropertiesDialog dialog=new AUTConfigPropertiesDialog(m_editButton.getShell(),autConfig,getAutToolkit(),m_autMain.getName(),new AutIdValidator(m_project,m_autMain,autConfig),new AutConfigNameValidator(m_autMain,autConfig));
    dialog.create();
    DialogUtils.setWidgetNameForModalDialog(dialog);
    dialog.getShell().setText(Messages.AUTPropertiesDialogAUTConfigTitle);
    dialog.open();
    if (dialog.getReturnCode() == Window.OK) {
      final Set<IAUTConfigPO> autConfigSet=m_autMain.getAutConfigSet();
      String[] listHelper=new String[autConfigSet.size()];
      int i=0;
      for (      IAUTConfigPO configPO : autConfigSet) {
        listHelper[i]=configPO.getName();
        i++;
      }
      setAutConfigList(listHelper);
    }
 else {
      Utils.makeAutConfigCopy(preEditConfig,autConfig.getConfigMap());
    }
    Map<String,String> newAutConfigMap=new HashMap<String,String>(autConfig.getConfigMap());
    autConfig.setConfigMap(newAutConfigMap);
    setFocus(new String[]{autConfig.getName()});
  }
}",0.9820089955022488
95584,"/** 
 * Edit a newly create AUT configuration
 * @param autConfig the new configuration
 */
private void editNewAUTConfig(IAUTConfigPO autConfig){
  String autName=m_autMain.getName();
  if (autName == null || autName.length() == 0) {
    autName=m_autNameText.getText();
  }
  String[] selection=m_autConfigList.getSelection();
  AUTConfigPropertiesDialog dialog=new AUTConfigPropertiesDialog(m_addButton.getShell(),autConfig,getAutToolkit(),autName,new AutIdValidator(m_project,m_autMain,autConfig));
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  dialog.getShell().setText(Messages.AUTPropertiesDialogAUTConfigTitle);
  dialog.open();
  if (dialog.getReturnCode() == Window.OK) {
    m_autConfigList.add(autConfig.getName());
    String[] autConfigList=m_autConfigList.getItems();
    setAutConfigList(autConfigList);
    m_autMain.addAutConfigToSet(autConfig);
    setFocus(new String[]{autConfig.getName()});
    return;
  }
  setFocus(selection);
}","/** 
 * Edit a newly create AUT configuration
 * @param autConfig the new configuration
 */
private void editNewAUTConfig(IAUTConfigPO autConfig){
  String autName=m_autMain.getName();
  if (autName == null || autName.length() == 0) {
    autName=m_autNameText.getText();
  }
  String[] selection=m_autConfigList.getSelection();
  AUTConfigPropertiesDialog dialog=new AUTConfigPropertiesDialog(m_addButton.getShell(),autConfig,getAutToolkit(),autName,new AutIdValidator(m_project,m_autMain,autConfig),new AutConfigNameValidator(m_autMain,autConfig));
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  dialog.getShell().setText(Messages.AUTPropertiesDialogAUTConfigTitle);
  dialog.open();
  if (dialog.getReturnCode() == Window.OK) {
    m_autConfigList.add(autConfig.getName());
    String[] autConfigList=m_autConfigList.getItems();
    setAutConfigList(autConfigList);
    m_autMain.addAutConfigToSet(autConfig);
    setFocus(new String[]{autConfig.getName()});
    return;
  }
  setFocus(selection);
}",0.9760717846460618
95585,"/** 
 * {@inheritDoc}
 */
public void addUsedProject(IReusedProjectPO reusedProject){
  Iterator it=getUsedProjects().iterator();
  while (it.hasNext()) {
    IReusedProjectPO oldReusedProject=(IReusedProjectPO)it.next();
    if (oldReusedProject.getName().equals(reusedProject.getName()) && oldReusedProject.getProjectVersion().compareTo(reusedProject.getProjectVersion()) <= 0) {
      removeUsedProject(oldReusedProject);
    }
  }
  getProjectProperties().addUsedProject(reusedProject);
}","/** 
 * {@inheritDoc}
 */
public void addUsedProject(IReusedProjectPO reusedProject){
  getProjectProperties().addUsedProject(reusedProject);
}",0.4503937007874016
95586,"/** 
 * Adds appropriate testcase libraries to the given project's reused  projects set.
 * @param newProject The project that will reuse the testcase libraries.
 */
private void addUnboundModules(IProjectPO newProject){
  ToolkitDescriptor desc=ComponentBuilder.getInstance().getCompSystem().getToolkitDescriptor(newProject.getToolkit());
  while (desc != null) {
    try {
      String moduleName=LIBRARY_PREFIX + StringUtils.lowerCase(desc.getName());
      IProjectPO ubmProject=ProjectPM.loadLatestVersionOfProjectByName(moduleName);
      if (ubmProject != null) {
        newProject.addUsedProject(PoMaker.createReusedProjectPO(ubmProject));
      }
 else {
        if (log.isInfoEnabled()) {
          log.info(Messages.Project + StringConstants.SPACE + StringConstants.APOSTROPHE+ moduleName+ StringConstants.APOSTROPHE+ Messages.DoesNotExist+ StringConstants.DOT);
        }
      }
    }
 catch (    JBException e) {
      log.error(e + StringConstants.COLON + StringConstants.SPACE+ e.getMessage());
    }
    desc=ComponentBuilder.getInstance().getCompSystem().getToolkitDescriptor(desc.getIncludes());
  }
}","/** 
 * Adds appropriate testcase libraries to the given project's reused  projects set.
 * @param newProject The project that will reuse the testcase libraries.
 */
private void addUnboundModules(IProjectPO newProject){
  ToolkitDescriptor desc=ComponentBuilder.getInstance().getCompSystem().getToolkitDescriptor(newProject.getToolkit());
  while (desc != null) {
    try {
      String moduleName=LIBRARY_PREFIX + StringUtils.lowerCase(desc.getName());
      IProjectPO ubmProject=ProjectPM.loadLatestVersionOfProjectByName(moduleName);
      if (ubmProject != null) {
        IReusedProjectPO[] reusedProj=new IReusedProjectPO[newProject.getUsedProjects().size()];
        newProject.getUsedProjects().toArray(reusedProj);
        for (int i=0; i < reusedProj.length; i++) {
          IReusedProjectPO oldReusedProject=reusedProj[i];
          if (oldReusedProject != null && oldReusedProject.getName().equals(ubmProject.getName()) && oldReusedProject.getProjectVersion().compareTo(ubmProject.getProjectVersion()) <= 0) {
            newProject.removeUsedProject(oldReusedProject);
          }
        }
        newProject.addUsedProject(PoMaker.createReusedProjectPO(ubmProject));
      }
 else {
        if (log.isInfoEnabled()) {
          log.info(Messages.Project + StringConstants.SPACE + StringConstants.APOSTROPHE+ moduleName+ StringConstants.APOSTROPHE+ Messages.DoesNotExist+ StringConstants.DOT);
        }
      }
    }
 catch (    JBException e) {
      log.error(e + StringConstants.COLON + StringConstants.SPACE+ e.getMessage());
    }
    desc=ComponentBuilder.getInstance().getCompSystem().getToolkitDescriptor(desc.getIncludes());
  }
}",0.8070554355651548
95587,"/** 
 * Checks every element with checks of the project for CheckStyle errors.
 */
public void doCompleteCheck(){
  Job checkEverythingJob=new CompleteTestStyleCheckJob(""String_Node_Str"");
  checkEverythingJob.setRule(SingleJobRule.TESTSTYLERULE);
  JobUtils.executeJob(checkEverythingJob,null);
  try {
    checkEverythingJob.join();
  }
 catch (  InterruptedException e) {
    LOG.warn(""String_Node_Str"",e);
  }
}","/** 
 * Checks every element with checks of the project for CheckStyle errors.
 */
public void doCompleteCheck(){
  Job checkEverythingJob=new CompleteTestStyleCheckJob(""String_Node_Str"");
  checkEverythingJob.setRule(new MultiRule(new ISchedulingRule[]{SingleJobRule.COMPLETENESSRULE,SingleJobRule.TESTSTYLERULE}));
  JobUtils.executeJob(checkEverythingJob,null);
  try {
    checkEverythingJob.join();
  }
 catch (  InterruptedException e) {
    LOG.warn(""String_Node_Str"",e);
  }
}",0.9232480533926584
95588,"/** 
 * {@inheritDoc} 
 */
public void handleDataChanged(DataChangedEvent... events){
  if (!isEnabled()) {
    return;
  }
  boolean isUpdateInEditor=true;
  for (  DataChangedEvent e : events) {
    if (e.getUpdateState() != UpdateState.onlyInEditor) {
      TestStyleJob tj=new TestStyleJob(""String_Node_Str"",events);
      tj.setRule(SingleJobRule.TESTSTYLERULE);
      JobUtils.executeJob(tj,null);
      for (      Job job : Job.getJobManager().find(tj)) {
        if (job != tj) {
          job.cancel();
        }
      }
      return;
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void handleDataChanged(DataChangedEvent... events){
  if (!isEnabled()) {
    return;
  }
  boolean isUpdateInEditor=true;
  for (  DataChangedEvent e : events) {
    if (e.getUpdateState() != UpdateState.onlyInEditor) {
      TestStyleJob tj=new TestStyleJob(""String_Node_Str"",events);
      tj.setRule(new MultiRule(new ISchedulingRule[]{SingleJobRule.COMPLETENESSRULE,SingleJobRule.TESTSTYLERULE}));
      JobUtils.executeJob(tj,null);
      for (      Job job : Job.getJobManager().find(tj)) {
        if (job != tj) {
          job.cancel();
        }
      }
      return;
    }
  }
}",0.9414758269720102
95589,"/** 
 * Packs the table.
 */
private void packTable(){
  final Table table=getTable();
  final TableColumn[] columns=table.getColumns();
  final int columnCount=columns.length;
  for (int i=1; i < columnCount; i++) {
    final TableColumn column=columns[i];
    column.pack();
    if (column.getWidth() < COLUMN_WIDTH) {
      column.setWidth(COLUMN_WIDTH);
    }
  }
}","/** 
 * Packs the table.
 */
private void packTable(){
  final Table table=getTable();
  final TableColumn[] columns=table.getColumns();
  final int columnCount=columns.length;
  for (int i=1; i < columnCount; i++) {
    final TableColumn column=columns[i];
    column.pack();
    column.setWidth(m_columnWidths != null ? m_columnWidths[i] : COLUMN_WIDTH);
  }
}",0.8426812585499316
95590,"/** 
 * creates the TableColumns with Parameter
 */
private void initTableViewerParameterColumns(){
  if (getParamInterfaceObj() == null) {
    return;
  }
  final Table table=getTable();
  String[] columnProperties=new String[getParamInterfaceObj().getParameterList().size() + 1];
  columnProperties[0]=initDataSetColumn();
  int i=1;
  for (  IParamDescriptionPO descr : getParamInterfaceObj().getParameterList()) {
    TableColumn column=new TableColumn(table,SWT.NONE);
    String columnName=descr.getName();
    column.setText(columnName);
    columnProperties[i++]=columnName;
    column.setWidth(COLUMN_WIDTH);
  }
  getTableViewer().setColumnProperties(columnProperties);
}","/** 
 * creates the TableColumns with Parameter
 */
private void initTableViewerParameterColumns(){
  if (getParamInterfaceObj() == null) {
    return;
  }
  final Table table=getTable();
  if (m_paramId == getParamInterfaceObj().getId()) {
    TableColumn[] tableColumns=table.getColumns();
    if (tableColumns != null && tableColumns.length != 0) {
      m_columnWidths=new int[tableColumns.length];
      int i=0;
      for (      TableColumn column : tableColumns) {
        m_columnWidths[i++]=column.getWidth();
      }
    }
  }
 else {
    m_paramId=getParamInterfaceObj().getId();
    m_columnWidths=null;
  }
  String[] columnProperties=new String[getParamInterfaceObj().getParameterList().size() + 1];
  columnProperties[0]=initDataSetColumn();
  int i=1;
  for (  IParamDescriptionPO descr : getParamInterfaceObj().getParameterList()) {
    TableColumn column=new TableColumn(table,SWT.NONE);
    String columnName=descr.getName();
    column.setText(columnName);
    columnProperties[i++]=columnName;
    if (m_columnWidths == null) {
      if (column.getWidth() < COLUMN_WIDTH) {
        column.setWidth(COLUMN_WIDTH);
      }
    }
 else {
      column.setWidth(m_columnWidths[i - 1]);
    }
  }
  getTableViewer().setColumnProperties(columnProperties);
}",0.6844262295081968
95591,"@Override public void closeConsole(){
  IConsole[] cons=ConsolePlugin.getDefault().getConsoleManager().getConsoles();
  ArrayList<IConsole> toRemove=new ArrayList<IConsole>();
  for (  IConsole c : cons) {
    if (c.getName().contains(CONNECTION_CONSOLE_NAME) && c instanceof MessageConsole) {
      toRemove.add(c);
    }
  }
  ConsolePlugin.getDefault().getConsoleManager().removeConsoles(toRemove.toArray(new IConsole[toRemove.size()]));
}","@Override public void closeConsole(){
  ConsolePlugin consolePlugin=ConsolePlugin.getDefault();
  if (consolePlugin != null && consolePlugin.getConsoleManager() != null) {
    IConsole[] cons=ConsolePlugin.getDefault().getConsoleManager().getConsoles();
    ArrayList<IConsole> toRemove=new ArrayList<IConsole>();
    for (    IConsole c : cons) {
      if (c.getName().contains(CONNECTION_CONSOLE_NAME) && c instanceof MessageConsole) {
        toRemove.add(c);
      }
    }
    ConsolePlugin.getDefault().getConsoleManager().removeConsoles(toRemove.toArray(new IConsole[toRemove.size()]));
  }
}",0.8403846153846154
95592,"/** 
 * only for Persistence (JPA / EclipseLink)!
 * @return the config
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"",joinColumns=@JoinColumn(name=""String_Node_Str"")) @MapKeyColumn(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @BatchFetch(value=BatchFetchType.JOIN) Map<String,String> getHbmConfigMap(){
  return m_config;
}","/** 
 * only for Persistence (JPA / EclipseLink)!
 * @return the config
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"",joinColumns=@JoinColumn(name=""String_Node_Str"")) @MapKeyColumn(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) Map<String,String> getHbmConfigMap(){
  return m_config;
}",0.9486166007905138
95593,"/** 
 * @return Returns the autMainList.
 */
@OneToMany(cascade=CascadeType.ALL,fetch=FetchType.EAGER,targetEntity=AUTMainPO.class) @JoinColumn(name=""String_Node_Str"") public Set<IAUTMainPO> getAutMainList(){
  return m_autMainList;
}","/** 
 * @return Returns the autMainList.
 */
@OneToMany(cascade=CascadeType.ALL,fetch=FetchType.EAGER,targetEntity=AUTMainPO.class) @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.JOIN) public Set<IAUTMainPO> getAutMainList(){
  return m_autMainList;
}",0.9230769230769232
95594,"/** 
 * @return Returns the autConfigSet.
 */
@OneToMany(fetch=FetchType.EAGER,cascade=CascadeType.ALL,targetEntity=AUTConfigPO.class,orphanRemoval=true) @BatchFetch(value=BatchFetchType.JOIN) public Set<IAUTConfigPO> getAutConfigSet(){
  return m_autConfigSet;
}","/** 
 * @return Returns the autConfigSet.
 */
@OneToMany(fetch=FetchType.EAGER,cascade=CascadeType.ALL,targetEntity=AUTConfigPO.class,orphanRemoval=true) public Set<IAUTConfigPO> getAutConfigSet(){
  return m_autConfigSet;
}",0.919917864476386
95595,"/** 
 * Finds a node within the project with the given ID.
 * @param nodeGuid The GUID of the node
 * @return the {@inheritDoc INodePO} with the given GUID, or <code>null</code> if the  {@link INodePO} cannot be found
 */
public static synchronized INodePO getNode(String nodeGuid){
  EntityManager session=GeneralStorage.getInstance().getMasterSession();
  Validate.notNull(session);
  Query specTcQuery=session.createQuery(""String_Node_Str"");
  specTcQuery.setParameter(""String_Node_Str"",nodeGuid);
  try {
    Object result=specTcQuery.getSingleResult();
    if (result instanceof INodePO) {
      return (INodePO)result;
    }
  }
 catch (  NoResultException nre) {
  }
  return null;
}","/** 
 * Finds a node within the project with the given ID.
 * @param projectId The ID of the parent project of the spec testcase
 * @param nodeGuid The GUID of the node
 * @param session may not be null
 * @return the spec testcase with the given guid, or <code>null</code> if the testcase cannot be found
 */
public static synchronized INodePO getNode(Long projectId,String nodeGuid,EntityManager session){
  Validate.notNull(session);
  Query specTcQuery=session.createQuery(""String_Node_Str"" + ""String_Node_Str"");
  specTcQuery.setParameter(""String_Node_Str"",nodeGuid);
  specTcQuery.setParameter(""String_Node_Str"",projectId);
  try {
    Object result=specTcQuery.getSingleResult();
    if (result instanceof INodePO) {
      return (INodePO)result;
    }
  }
 catch (  NoResultException nre) {
  }
  return null;
}",0.3512259774685222
95596,"/** 
 * This method is getting the Node from   {@link TestResultNode}.  If this is a generated   {@link ITestCasePO} than it is searched in the database for the correct node.
 * @param trNode the testResult node
 * @return an {@link INodePO} which can be of any kind and from any project
 */
private static INodePO getExecFromTestResultNode(TestResultNode trNode){
  INodePO nodePO=trNode.getNode();
  if (nodePO instanceof ITestCasePO && nodePO.isGenerated()) {
    nodePO=NodePM.getNode(nodePO.getGuid());
  }
  return nodePO;
}","/** 
 * This method is getting the Node from   {@link TestResultNode}.  If this is a generated   {@link ITestCasePO} than it is searched in the database for the correct node.
 * @param trNode the testResult node
 * @return an {@link INodePO} which can be of any kind and from any project
 */
private static INodePO getExecFromTestResultNode(TestResultNode trNode){
  INodePO nodePO=trNode.getNode();
  String guid=nodePO.getGuid();
  if (nodePO instanceof ITestCasePO && nodePO.isGenerated()) {
    nodePO=NodePM.getNode(GeneralStorage.getInstance().getProject().getId(),guid);
    if (nodePO == null) {
      for (      IReusedProjectPO usedProject : GeneralStorage.getInstance().getProject().getUsedProjects()) {
        nodePO=NodePM.getNode(usedProject.getId(),guid);
        if (nodePO != null) {
          break;
        }
      }
    }
  }
  return nodePO;
}",0.7383512544802867
95597,"/** 
 * @param structuredSel find the referenced specification test case for the given structured selection
 * @return a valid ISpecTestCasePO or <code>null</code> if no referencecould be found
 */
public static ISpecTestCasePO getSpecTC(IStructuredSelection structuredSel){
  IExecTestCasePO execTc=null;
  Object firstElement=structuredSel.getFirstElement();
  if (firstElement instanceof IExecTestCasePO) {
    execTc=(IExecTestCasePO)firstElement;
  }
 else   if (firstElement instanceof TestResultNode) {
    TestResultNode trNode=(TestResultNode)firstElement;
    INodePO nodePO=getExecFromTestResultNode(trNode);
    if (nodePO instanceof ITestCasePO && !(nodePO instanceof IExecTestCasePO)) {
      nodePO=NodePM.getNode(nodePO.getGuid());
    }
    while (!(nodePO instanceof IExecTestCasePO)) {
      trNode=trNode.getParent();
      if (trNode == null) {
        return null;
      }
      nodePO=getExecFromTestResultNode(trNode);
    }
    execTc=(IExecTestCasePO)nodePO;
  }
  if (execTc != null) {
    return execTc.getSpecTestCase();
  }
  return null;
}","/** 
 * @param structuredSel find the referenced specification test case for the given structured selection
 * @return a valid ISpecTestCasePO or <code>null</code> if no referencecould be found
 */
public static ISpecTestCasePO getSpecTC(IStructuredSelection structuredSel){
  IExecTestCasePO execTc=null;
  Object firstElement=structuredSel.getFirstElement();
  if (firstElement instanceof IExecTestCasePO) {
    execTc=(IExecTestCasePO)firstElement;
  }
 else   if (firstElement instanceof TestResultNode) {
    TestResultNode trNode=(TestResultNode)firstElement;
    INodePO nodePO=getExecFromTestResultNode(trNode);
    if (nodePO instanceof ITestCasePO && !(nodePO instanceof IExecTestCasePO)) {
      nodePO=NodePM.getNode(GeneralStorage.getInstance().getProject().getId(),nodePO.getGuid());
      if (nodePO == null) {
        for (        IReusedProjectPO usedProject : GeneralStorage.getInstance().getProject().getUsedProjects()) {
          nodePO=NodePM.getNode(usedProject.getId(),nodePO.getGuid());
          if (nodePO != null) {
            break;
          }
        }
      }
    }
    while (!(nodePO instanceof IExecTestCasePO)) {
      trNode=trNode.getParent();
      if (trNode == null) {
        return null;
      }
      nodePO=getExecFromTestResultNode(trNode);
    }
    execTc=(IExecTestCasePO)nodePO;
  }
  if (execTc != null) {
    return execTc.getSpecTestCase();
  }
  return null;
}",0.856338028169014
95598,"/** 
 * Finds a node within the project with the given ID.
 * @param nodeGuid The GUID of the node
 * @return the {@inheritDoc INodePO} with the given GUID, or <code>null</code> if the  {@link INodePO} cannot be found
 */
public static synchronized INodePO getNode(String nodeGuid){
  EntityManager session=GeneralStorage.getInstance().getMasterSession();
  Validate.notNull(session);
  Query specTcQuery=session.createQuery(""String_Node_Str"");
  specTcQuery.setParameter(""String_Node_Str"",nodeGuid);
  try {
    Object result=specTcQuery.getSingleResult();
    if (result instanceof INodePO) {
      return (INodePO)result;
    }
  }
 catch (  NoResultException nre) {
  }
  return null;
}","/** 
 * Finds a node within the project with the given ID.
 * @param projectId The ID of the parent project of the spec testcase
 * @param nodeGuid The GUID of the node
 * @param session may not be null
 * @return the spec testcase with the given guid, or <code>null</code> if the testcase cannot be found
 */
public static synchronized INodePO getNode(Long projectId,String nodeGuid,EntityManager session){
  Validate.notNull(session);
  Query specTcQuery=session.createQuery(""String_Node_Str"" + ""String_Node_Str"");
  specTcQuery.setParameter(""String_Node_Str"",nodeGuid);
  specTcQuery.setParameter(""String_Node_Str"",projectId);
  try {
    Object result=specTcQuery.getSingleResult();
    if (result instanceof INodePO) {
      return (INodePO)result;
    }
  }
 catch (  NoResultException nre) {
  }
  return null;
}",0.3512259774685222
95599,"/** 
 * This method is getting the Node from   {@link TestResultNode}.  If this is a generated   {@link ITestCasePO} than it is searched in the database for the correct node.
 * @param trNode the testResult node
 * @return an {@link INodePO} which can be of any kind and from any project
 */
private static INodePO getExecFromTestResultNode(TestResultNode trNode){
  INodePO nodePO=trNode.getNode();
  if (nodePO instanceof ITestCasePO && nodePO.isGenerated()) {
    nodePO=NodePM.getNode(nodePO.getGuid());
  }
  return nodePO;
}","/** 
 * This method is getting the Node from   {@link TestResultNode}.  If this is a generated   {@link ITestCasePO} than it is searched in the database for the correct node.
 * @param trNode the testResult node
 * @return an {@link INodePO} which can be of any kind and from any project
 */
private static INodePO getExecFromTestResultNode(TestResultNode trNode){
  INodePO nodePO=trNode.getNode();
  String guid=nodePO.getGuid();
  if (nodePO instanceof ITestCasePO && nodePO.isGenerated()) {
    nodePO=NodePM.getNode(GeneralStorage.getInstance().getProject().getId(),guid);
    if (nodePO == null) {
      for (      IReusedProjectPO usedProject : GeneralStorage.getInstance().getProject().getUsedProjects()) {
        nodePO=NodePM.getNode(usedProject.getId(),guid);
        if (nodePO != null) {
          break;
        }
      }
    }
  }
  return nodePO;
}",0.7383512544802867
95600,"/** 
 * @param structuredSel find the referenced specification test case for the given structured selection
 * @return a valid ISpecTestCasePO or <code>null</code> if no referencecould be found
 */
public static ISpecTestCasePO getSpecTC(IStructuredSelection structuredSel){
  IExecTestCasePO execTc=null;
  Object firstElement=structuredSel.getFirstElement();
  if (firstElement instanceof IExecTestCasePO) {
    execTc=(IExecTestCasePO)firstElement;
  }
 else   if (firstElement instanceof TestResultNode) {
    TestResultNode trNode=(TestResultNode)firstElement;
    INodePO nodePO=getExecFromTestResultNode(trNode);
    if (nodePO instanceof ITestCasePO && !(nodePO instanceof IExecTestCasePO)) {
      nodePO=NodePM.getNode(nodePO.getGuid());
    }
    while (!(nodePO instanceof IExecTestCasePO)) {
      trNode=trNode.getParent();
      if (trNode == null) {
        return null;
      }
      nodePO=getExecFromTestResultNode(trNode);
    }
    execTc=(IExecTestCasePO)nodePO;
  }
  if (execTc != null) {
    return execTc.getSpecTestCase();
  }
  return null;
}","/** 
 * @param structuredSel find the referenced specification test case for the given structured selection
 * @return a valid ISpecTestCasePO or <code>null</code> if no referencecould be found
 */
public static ISpecTestCasePO getSpecTC(IStructuredSelection structuredSel){
  IExecTestCasePO execTc=null;
  Object firstElement=structuredSel.getFirstElement();
  if (firstElement instanceof IExecTestCasePO) {
    execTc=(IExecTestCasePO)firstElement;
  }
 else   if (firstElement instanceof TestResultNode) {
    TestResultNode trNode=(TestResultNode)firstElement;
    INodePO nodePO=getExecFromTestResultNode(trNode);
    if (nodePO instanceof ITestCasePO && !(nodePO instanceof IExecTestCasePO)) {
      nodePO=NodePM.getNode(GeneralStorage.getInstance().getProject().getId(),nodePO.getGuid());
      if (nodePO == null) {
        for (        IReusedProjectPO usedProject : GeneralStorage.getInstance().getProject().getUsedProjects()) {
          nodePO=NodePM.getNode(usedProject.getId(),nodePO.getGuid());
          if (nodePO != null) {
            break;
          }
        }
      }
    }
    while (!(nodePO instanceof IExecTestCasePO)) {
      trNode=trNode.getParent();
      if (trNode == null) {
        return null;
      }
      nodePO=getExecFromTestResultNode(trNode);
    }
    execTc=(IExecTestCasePO)nodePO;
  }
  if (execTc != null) {
    return execTc.getSpecTestCase();
  }
  return null;
}",0.856338028169014
95601,"/** 
 * initializes the AUTServer. <br> 1. create communicator <br> 2. connect to client <br> 3. register shutdown hook, not yet <br> 4. register a AWTEventListener, not yet <br> 5. load the AUT <br> 6. send message AUTServerReady <br> In case of an error in step >2. send an AUTServerStateMessage with an error code
 * @param isRcpAccessible true, if this method was called by RcpAccessor Plug-in
 */
public void start(boolean isRcpAccessible){
  m_isRcpAccessible=isRcpAccessible;
  try {
    IRegisterAut autReg=parseAutReg();
    if (autReg == null) {
      String errorMessage=""String_Node_Str"";
      log.error(errorMessage);
      sendExitReason(errorMessage,AUTServerExitConstants.EXIT_MISSING_AGENT_INFO);
    }
    if (!isRcpAccessible && !isAgentSet()) {
      loadAUT();
    }
    if (m_isAgentSet || isRcpAccessible) {
      setAutThread(Thread.currentThread());
    }
    if (m_iteCommunicator != null) {
      m_iteCommunicator.send(new AUTServerStateMessage(AUTServerStateMessage.READY));
    }
 else {
      new Thread(""String_Node_Str""){
        public void run(){
          AUTStartCommand startCommand=new AUTStartCommand();
          startCommand.setMessage(new AUTStartMessage());
          startCommand.execute();
        }
      }
.start();
    }
    while ((getAutThread() == null || !getAutThread().isAlive()) && !isAutRunning()) {
      try {
        Thread.sleep(TimingConstantsServer.POLLING_DELAY_AUT_START);
      }
 catch (      InterruptedException e) {
      }
    }
    if (autReg != null) {
      try {
        autReg.register();
      }
 catch (      IOException ioe) {
        log.error(""String_Node_Str"",ioe);
        System.exit(AUTServerExitConstants.AUT_START_ERROR);
      }
    }
  }
 catch (  IllegalArgumentException iae) {
    log.error(""String_Node_Str"",iae);
    System.exit(AUTServerExitConstants.EXIT_INVALID_ARGS);
  }
catch (  CommunicationException ce) {
    log.error(""String_Node_Str"",ce);
    System.exit(AUTServerExitConstants.EXIT_COMMUNICATION_ERROR);
  }
catch (  SecurityException se) {
    log.error(""String_Node_Str"",se);
    System.exit(AUTServerExitConstants.EXIT_SECURITY_VIOLATION_REFLECTION);
  }
catch (  ClassNotFoundException cnfe) {
    sendExitReason(cnfe,AUTServerStateMessage.AUT_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  NoSuchMethodException nsme) {
    sendExitReason(nsme,AUTServerStateMessage.MAIN_METHOD_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  UnsupportedClassVersionError ucve) {
    sendExitReason(ucve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_AUT_WRONG_CLASS_VERSION);
  }
catch (  JBVersionException ve) {
    sendExitReason(ve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_UNKNOWN_ITE_CLIENT);
  }
}","/** 
 * initializes the AUTServer. <br> 1. create communicator <br> 2. connect to client <br> 3. register shutdown hook, not yet <br> 4. register a AWTEventListener, not yet <br> 5. load the AUT <br> 6. send message AUTServerReady <br> In case of an error in step >2. send an AUTServerStateMessage with an error code
 * @param isRcpAccessible true, if this method was called by RcpAccessor Plug-in
 */
public void start(boolean isRcpAccessible){
  m_isRcpAccessible=isRcpAccessible;
  try {
    IRegisterAut autReg=parseAutReg();
    if (autReg == null) {
      String errorMessage=""String_Node_Str"";
      log.error(errorMessage);
      sendExitReason(errorMessage,AUTServerExitConstants.EXIT_MISSING_AGENT_INFO);
    }
    if (!isRcpAccessible && !isAgentSet()) {
      loadAUT();
    }
    if (m_isAgentSet || isRcpAccessible) {
      setAutThread(Thread.currentThread());
    }
    if (m_iteCommunicator != null) {
      m_iteCommunicator.send(new AUTServerStateMessage(AUTServerStateMessage.READY));
    }
 else {
      new Thread(""String_Node_Str""){
        public void run(){
          AUTStartCommand startCommand=new AUTStartCommand();
          startCommand.setMessage(new AUTStartMessage());
          startCommand.execute();
        }
      }
.start();
    }
    while ((getAutThread() == null || !getAutThread().isAlive()) && !isAutRunning()) {
      try {
        Thread.sleep(TimingConstantsServer.POLLING_DELAY_AUT_START);
      }
 catch (      InterruptedException e) {
      }
    }
    if (autReg != null) {
      registerAutinAgent(autReg);
    }
  }
 catch (  IllegalArgumentException iae) {
    log.error(""String_Node_Str"",iae);
    System.exit(AUTServerExitConstants.EXIT_INVALID_ARGS);
  }
catch (  CommunicationException ce) {
    log.error(""String_Node_Str"",ce);
    System.exit(AUTServerExitConstants.EXIT_COMMUNICATION_ERROR);
  }
catch (  SecurityException se) {
    log.error(""String_Node_Str"",se);
    System.exit(AUTServerExitConstants.EXIT_SECURITY_VIOLATION_REFLECTION);
  }
catch (  ClassNotFoundException cnfe) {
    sendExitReason(cnfe,AUTServerStateMessage.AUT_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  NoSuchMethodException nsme) {
    sendExitReason(nsme,AUTServerStateMessage.MAIN_METHOD_NOT_FOUND);
    System.exit(AUTServerExitConstants.EXIT_AUT_NOT_FOUND);
  }
catch (  UnsupportedClassVersionError ucve) {
    sendExitReason(ucve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_AUT_WRONG_CLASS_VERSION);
  }
catch (  JBVersionException ve) {
    sendExitReason(ve,AUTServerStateMessage.EXIT_AUT_WRONG_CLASS_VERSION);
    System.exit(AUTServerExitConstants.EXIT_UNKNOWN_ITE_CLIENT);
  }
}",0.9630686886708296
95602,"/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=null;
  try {
    result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
      @Override public Stage call() throws Exception {
        List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
        for (        final Stage stage : stages) {
          if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
            return stage;
          }
        }
        return null;
      }
    }
);
  }
 catch (  IllegalStateException e) {
  }
  return result;
}","/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=null;
  result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
    @Override public Stage call() throws Exception {
      List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
      for (      final Stage stage : stages) {
        if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
          return stage;
        }
      }
      return null;
    }
  }
);
  return result;
}",0.9298360655737704
95603,"public Void run(){
  if (!m_slider.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(""String_Node_Str""));
  }
  Integer value=null;
  Dictionary<Integer,?> labelTable=m_slider.getLabelTable();
  if (labelTable != null) {
    Enumeration<Integer> keys=labelTable.keys();
    MatchUtil matcher=MatchUtil.getInstance();
    for (    Integer k : Collections.list(keys)) {
      Object o=labelTable.get(k);
      String stringToMatch;
      if (o instanceof JLabel) {
        stringToMatch=((JLabel)o).getText();
      }
 else {
        stringToMatch=String.valueOf(position);
      }
      if (matcher.match(stringToMatch,position,operator)) {
        value=k;
        break;
      }
    }
    if (value == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
    }
  }
 else {
    try {
      value=Integer.valueOf(position);
    }
 catch (    NumberFormatException nfe) {
      throwInvalidInputMessage();
    }
  }
  setValueProgrammatically(units,value);
  return null;
}","public Void run(){
  if (!m_slider.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(""String_Node_Str""));
  }
  Integer value=null;
  Dictionary<Integer,?> labelTable=m_slider.getLabelTable();
  String prefPos=getPreferredPosition(position,units);
  String possiblePos=getPossiblePosition(prefPos);
  int min=m_slider.getMinimum();
  int max=m_slider.getMaximum();
  int incr=getSliderIncrement();
  MatchUtil matcher=MatchUtil.getInstance();
  for (int val=min; val <= max; val+=incr) {
    if (labelTable != null) {
      Object label=labelTable.get(val);
      if (label != null && label instanceof JLabel) {
        if (matcher.match(((JLabel)label).getText(),possiblePos,operator)) {
          value=val;
          break;
        }
      }
    }
    if (matcher.match(String.valueOf(val),possiblePos,operator)) {
      value=val;
      break;
    }
  }
  if (value == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
  }
  m_slider.setValue(value);
  return null;
}",0.4874256973022405
95604,"/** 
 * {@inheritDoc}
 */
public void setPosition(final String position,final String operator,final String units){
  getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Void>(){
    public Void run(){
      if (!m_slider.isEnabled()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(""String_Node_Str""));
      }
      Integer value=null;
      Dictionary<Integer,?> labelTable=m_slider.getLabelTable();
      if (labelTable != null) {
        Enumeration<Integer> keys=labelTable.keys();
        MatchUtil matcher=MatchUtil.getInstance();
        for (        Integer k : Collections.list(keys)) {
          Object o=labelTable.get(k);
          String stringToMatch;
          if (o instanceof JLabel) {
            stringToMatch=((JLabel)o).getText();
          }
 else {
            stringToMatch=String.valueOf(position);
          }
          if (matcher.match(stringToMatch,position,operator)) {
            value=k;
            break;
          }
        }
        if (value == null) {
          throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
        }
      }
 else {
        try {
          value=Integer.valueOf(position);
        }
 catch (        NumberFormatException nfe) {
          throwInvalidInputMessage();
        }
      }
      setValueProgrammatically(units,value);
      return null;
    }
  }
);
}","/** 
 * {@inheritDoc}
 */
public void setPosition(final String position,final String operator,final String units){
  getEventThreadQueuer().invokeAndWait(""String_Node_Str"",new IRunnable<Void>(){
    public Void run(){
      if (!m_slider.isEnabled()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(""String_Node_Str""));
      }
      Integer value=null;
      Dictionary<Integer,?> labelTable=m_slider.getLabelTable();
      String prefPos=getPreferredPosition(position,units);
      String possiblePos=getPossiblePosition(prefPos);
      int min=m_slider.getMinimum();
      int max=m_slider.getMaximum();
      int incr=getSliderIncrement();
      MatchUtil matcher=MatchUtil.getInstance();
      for (int val=min; val <= max; val+=incr) {
        if (labelTable != null) {
          Object label=labelTable.get(val);
          if (label != null && label instanceof JLabel) {
            if (matcher.match(((JLabel)label).getText(),possiblePos,operator)) {
              value=val;
              break;
            }
          }
        }
        if (matcher.match(String.valueOf(val),possiblePos,operator)) {
          value=val;
          break;
        }
      }
      if (value == null) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
      }
      m_slider.setValue(value);
      return null;
    }
  }
);
}",0.560695652173913
95605,"/** 
 * {@inheritDoc}
 */
public boolean performFinish(){
  INodePO placeToInsert=m_listOfExecsToReplace.get(0);
  ISpecTestCasePO specTcToInsert=m_choosePage.getChoosenTestCase();
  try {
    Integer index=NewTestCaseHandlerTCEditor.getPositionToInsert(m_parentTC,placeToInsert);
    JBEditorHelper eh=m_editor.getEditorHelper();
    IExecTestCasePO replacementTCReference=TestCaseBP.addReferencedTestCase(m_parentTC,m_newExec,index);
    InteractionEventDispatcher.getDefault().fireProgammableSelectionEvent(new StructuredSelection(specTcToInsert));
    eh.getEditSupport().lockWorkVersion();
    eh.setDirty(true);
    m_editor.setSelection(new StructuredSelection(replacementTCReference));
  }
 catch (  PMException e) {
    NodeEditorInput inp=(NodeEditorInput)m_editor.getAdapter(NodeEditorInput.class);
    INodePO inpNode=inp.getNode();
    PMExceptionHandler.handlePMExceptionForMasterSession(e);
    try {
      m_editor.reOpenEditor(inpNode);
    }
 catch (    PMException e1) {
      PMExceptionHandler.handlePMExceptionForEditor(e1,m_editor);
    }
  }
  DeleteTreeItemHandlerTCEditor.deleteNodesFromEditor(m_listOfExecsToReplace,m_editor);
  return true;
}","/** 
 * {@inheritDoc}
 */
public boolean performFinish(){
  INodePO placeToInsert=m_listOfExecsToReplace.get(0);
  ISpecTestCasePO specTcToInsert=m_choosePage.getChoosenTestCase();
  try {
    Integer index=NewTestCaseHandlerTCEditor.getPositionToInsert(m_parentTC,placeToInsert);
    JBEditorHelper eh=m_editor.getEditorHelper();
    IExecTestCasePO replacementTCReference=TestCaseBP.addReferencedTestCase(m_parentTC,m_newExec,index);
    InteractionEventDispatcher.getDefault().fireProgammableSelectionEvent(new StructuredSelection(specTcToInsert));
    TestCaseBP.handleFirstReference(m_editor.getEditorHelper().getEditSupport(),m_choosePage.getChoosenTestCase(),false);
    eh.getEditSupport().lockWorkVersion();
    eh.setDirty(true);
    m_editor.setSelection(new StructuredSelection(replacementTCReference));
  }
 catch (  PMException e) {
    NodeEditorInput inp=(NodeEditorInput)m_editor.getAdapter(NodeEditorInput.class);
    INodePO inpNode=inp.getNode();
    PMExceptionHandler.handlePMExceptionForMasterSession(e);
    try {
      m_editor.reOpenEditor(inpNode);
    }
 catch (    PMException e1) {
      PMExceptionHandler.handlePMExceptionForEditor(e1,m_editor);
    }
  }
  DeleteTreeItemHandlerTCEditor.deleteNodesFromEditor(m_listOfExecsToReplace,m_editor);
  return true;
}",0.950446791226645
95606,"/** 
 * {@inheritDoc} 
 */
public TestErrorEvent execute() throws JBException {
  try {
    String runLocal=getValueForParam(CSConstants.EXEC_CONTEXT);
    TestResultNode resultNode=m_resultTreeTracker.getEndNode();
    if (CSConstants.EXEC_CONTEXT_ITE.equals(runLocal)) {
      String exec=getValueForParam(CSConstants.EXECUTABLE);
      String args=getValueForParam(CSConstants.EXEC_RAW_ARGS);
      boolean newEnvironment=Boolean.valueOf(getValueForParam(CSConstants.NEW_ENVIRONMENT));
      String splitChar=getValueForParam(CSConstants.RAW_ARG_SPLIT_CHAR);
      String encoding=getValueForParam(CSConstants.OUTPUT_ENCODING);
      String dir=getValueForParam(CSConstants.DIR);
      long timeout=Long.parseLong(getValueForParam(CSConstants.TIMEOUT));
      int expectedExitCode=Integer.parseInt(getValueForParam(CSConstants.EXPECTED_EXIT_CODE));
      Result result=CommandExecutor.exec(dir,exec,args,splitChar.charAt(0),timeout,encoding,newEnvironment);
      resultNode.setCommandLog(result.getCombinedOutput());
      int exitCode=result.getReturnValue();
      if (exitCode != expectedExitCode) {
        TestErrorEvent event=EventFactory.createVerifyFailed(String.valueOf(expectedExitCode),String.valueOf(exitCode));
        event.addProp(TestErrorEvent.Property.COMMAND_LOG_KEY,result.getCombinedOutput());
        return event;
      }
    }
 else {
      String sysOutAndErr=m_varStore.getValue(LAST_ACTION_RETURN);
      resultNode.setCommandLog(sysOutAndErr);
    }
  }
 catch (  IllegalCharsetNameException e) {
    return EventFactory.createActionError();
  }
catch (  UnsupportedCharsetException e) {
    return EventFactory.createActionError();
  }
catch (  ExecuteException e) {
    return EventFactory.createActionError();
  }
catch (  IOException e) {
    return EventFactory.createActionError();
  }
catch (  InterruptedException e) {
    return EventFactory.createActionError();
  }
catch (  TimeoutException e) {
    TestErrorEvent event=EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT);
    event.addProp(TestErrorEvent.Property.COMMAND_LOG_KEY,e.getMessage());
    return event;
  }
catch (  IllegalArgumentException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
catch (  InvalidDataException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public TestErrorEvent execute() throws JBException {
  try {
    String runLocal=getValueForParam(CSConstants.EXEC_CONTEXT);
    TestResultNode resultNode=m_resultTreeTracker.getEndNode();
    if (CSConstants.EXEC_CONTEXT_ITE.equals(runLocal)) {
      String exec=getValueForParam(CSConstants.EXECUTABLE);
      String args=getValueForParam(CSConstants.EXEC_RAW_ARGS);
      boolean newEnvironment=Boolean.valueOf(getValueForParam(CSConstants.NEW_ENVIRONMENT));
      String splitCharValue=getValueForParam(CSConstants.RAW_ARG_SPLIT_CHAR);
      splitCharValue=StringUtils.defaultIfEmpty(splitCharValue,null);
      char splitChar=(splitCharValue == null) ? null : splitCharValue.charAt(0);
      String encoding=getValueForParam(CSConstants.OUTPUT_ENCODING);
      String dir=getValueForParam(CSConstants.DIR);
      long timeout=Long.parseLong(getValueForParam(CSConstants.TIMEOUT));
      int expectedExitCode=Integer.parseInt(getValueForParam(CSConstants.EXPECTED_EXIT_CODE));
      Result result=CommandExecutor.exec(dir,exec,args,splitChar,timeout,encoding,newEnvironment);
      resultNode.setCommandLog(result.getCombinedOutput());
      int exitCode=result.getReturnValue();
      if (exitCode != expectedExitCode) {
        TestErrorEvent event=EventFactory.createVerifyFailed(String.valueOf(expectedExitCode),String.valueOf(exitCode));
        event.addProp(TestErrorEvent.Property.COMMAND_LOG_KEY,result.getCombinedOutput());
        return event;
      }
    }
 else {
      String sysOutAndErr=m_varStore.getValue(LAST_ACTION_RETURN);
      resultNode.setCommandLog(sysOutAndErr);
    }
  }
 catch (  IllegalCharsetNameException e) {
    return EventFactory.createActionError();
  }
catch (  UnsupportedCharsetException e) {
    return EventFactory.createActionError();
  }
catch (  ExecuteException e) {
    return EventFactory.createActionError();
  }
catch (  IOException e) {
    return EventFactory.createActionError();
  }
catch (  InterruptedException e) {
    return EventFactory.createActionError();
  }
catch (  TimeoutException e) {
    TestErrorEvent event=EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT);
    event.addProp(TestErrorEvent.Property.COMMAND_LOG_KEY,e.getMessage());
    return event;
  }
catch (  IllegalArgumentException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
catch (  InvalidDataException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
  return null;
}",0.9660253786328284
95607,"/** 
 * tries to set the position via drag & drop
 * @param units the units (percent or value)
 * @param value the value
 */
private void setPositionViaDragAndDrop(String units,Double value){
  Slider slider=getRealComponent();
  double min=slider.getMin();
  double max=slider.getMax();
  double currentRelPos=100 * (slider.getValue() - min) / (max - min);
  double futureRelPos=value;
  if (ValueSets.Measure.value.rcValue().equalsIgnoreCase(units)) {
    futureRelPos=100 * (value - min) / (max - min);
  }
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  int mouseButton=ValueSets.InteractionMode.primary.rcIntValue();
  dndHelper.setMouseButton(mouseButton);
  final IRobot robot=getRobot();
  boolean horizontal=slider.getOrientation().equals(Orientation.HORIZONTAL);
  if (horizontal) {
    getRobot().click(getTrack(),null,ClickOptions.create().setClickCount(0).setMouseButton(mouseButton),(int)Math.round(currentRelPos),false,50,false);
  }
 else {
    getRobot().click(getTrack(),null,ClickOptions.create().setClickCount(0).setMouseButton(mouseButton),50,false,100 - (int)Math.round(currentRelPos),false);
  }
  robot.mousePress(null,null,mouseButton);
  try {
    if (horizontal) {
      getRobot().click(getTrack(),null,ClickOptions.create().setClickCount(0).setMouseButton(mouseButton),(int)Math.round(futureRelPos),false,50,false);
    }
 else {
      getRobot().click(getTrack(),null,ClickOptions.create().setClickCount(0).setMouseButton(mouseButton),50,false,100 - (int)Math.round(futureRelPos),false);
    }
    TimeUtil.delay(200);
  }
  finally {
    getRobot().mouseRelease(null,null,mouseButton);
  }
}","/** 
 * tries to set the position via drag & drop
 * @param units the units (percent or value)
 * @param value the value
 */
private void setPositionViaDragAndDrop(String units,Double value){
  Slider slider=getRealComponent();
  double min=slider.getMin();
  double max=slider.getMax();
  double currentRelPos=100 * (slider.getValue() - min) / (max - min);
  double futureRelPos=value;
  if (ValueSets.Measure.value.rcValue().equalsIgnoreCase(units)) {
    futureRelPos=100 * (value - min) / (max - min);
  }
  final DragAndDropHelper dndHelper=DragAndDropHelper.getInstance();
  int mouseButton=ValueSets.InteractionMode.primary.rcIntValue();
  dndHelper.setMouseButton(mouseButton);
  final IRobot<Rectangle> robot=getRobot();
  boolean horizontal=slider.getOrientation().equals(Orientation.HORIZONTAL);
  if (horizontal) {
    moveHorizontal(currentRelPos,mouseButton);
  }
 else {
    moveVertical(currentRelPos,mouseButton);
  }
  robot.mousePress(null,null,mouseButton);
  try {
    if (horizontal) {
      moveHorizontal(futureRelPos - 2.0,mouseButton);
      TimeUtil.delay(200);
      moveHorizontal(futureRelPos,mouseButton);
      TimeUtil.delay(200);
      moveHorizontal(futureRelPos + 2.0,mouseButton);
      TimeUtil.delay(200);
      moveHorizontal(futureRelPos,mouseButton);
    }
 else {
      moveVertical(futureRelPos - 2.0,mouseButton);
      TimeUtil.delay(200);
      moveVertical(futureRelPos,mouseButton);
      TimeUtil.delay(200);
      moveVertical(futureRelPos + 2.0,mouseButton);
      TimeUtil.delay(200);
      moveVertical(futureRelPos,mouseButton);
    }
    TimeUtil.delay(200);
  }
  finally {
    getRobot().mouseRelease(null,null,mouseButton);
  }
}",0.513051305130513
95608,"@Override protected Process launch(CommandLine command,Map env,File dir) throws IOException {
  String cmdWorkingDirAbsolutePath=FilenameUtils.getFullPathNoEndSeparator(dir.getAbsolutePath());
  String executable=command.getExecutable();
  File commandFile=new File(dir.getCanonicalFile(),executable);
  boolean doesCommandExist=commandFile.exists();
  if (OS.isFamilyWindows() && (!FilenameUtils.equalsNormalizedOnSystem(CURRENT_VM_WORKING_DIR_ABS_PATH,cmdWorkingDirAbsolutePath) || !doesCommandExist)) {
    return m_windowsCommandLauncher.exec(command,env,dir);
  }
  return super.launch(command,env,dir);
}","@Override protected Process launch(CommandLine command,Map env,File dir) throws IOException {
  String cmdWorkingDirAbsolutePath=FilenameUtils.getFullPathNoEndSeparator(dir.getAbsolutePath());
  String executable=command.getExecutable();
  File commandFile=new File(dir.getCanonicalFile(),executable);
  boolean doesCommandExist=commandFile.exists();
  if (OS.isFamilyWindows()) {
    return m_windowsCommandLauncher.exec(command,env,dir);
  }
  return super.launch(command,env,dir);
}",0.8858447488584474
95609,"@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView table=getRealComponent();
      TableColumn<?,?> col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
 else {
        col=getRealComponent().getVisibleLeafColumn(column);
      }
      table.scrollToColumn(col);
      table.layout();
      List<? extends TableHeaderRow> headerRow=NodeTraverseHelper.getInstancesOf(table,TableHeaderRow.class);
      TableColumnHeader colH=null;
      for (      TableHeaderRow tableHeaderRow : headerRow) {
        colH=tableHeaderRow.getColumnHeaderFor(col);
        if (colH != null) {
          break;
        }
      }
      Rectangle b=NodeBounds.getAbsoluteBounds(colH);
      Rectangle tableB=NodeBounds.getAbsoluteBounds(table);
      return new Rectangle(Math.abs(tableB.x - b.x),Math.abs(tableB.y - b.y),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
    }
  }
);
  return result;
}","@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView table=getRealComponent();
      TableColumn<?,?> col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
 else {
        col=getRealComponent().getVisibleLeafColumn(column);
      }
      table.scrollToColumn(col);
      table.layout();
      List<? extends TableHeaderRow> headerRow=NodeTraverseHelper.getInstancesOf(table,TableHeaderRow.class);
      TableColumnHeader colH=null;
      for (      TableHeaderRow tableHeaderRow : headerRow) {
        colH=tableHeaderRow.getColumnHeaderFor(col);
        if (colH != null) {
          return NodeBounds.getRelativeBounds(colH,tableHeaderRow);
        }
      }
      return null;
    }
  }
);
  return result;
}",0.844946025515211
95610,"/** 
 * {@inheritDoc}
 */
public boolean performFinish(){
  INodePO placeToInsert=m_listOfExecsToReplace.get(0);
  ISpecTestCasePO specTcToInsert=m_choosePage.getChoosenTestCase();
  try {
    Integer index=NewTestCaseHandlerTCEditor.getPositionToInsert(m_parentTC,placeToInsert);
    JBEditorHelper eh=m_editor.getEditorHelper();
    IExecTestCasePO replacementTCReference=TestCaseBP.addReferencedTestCase(m_parentTC,m_newExec,index);
    InteractionEventDispatcher.getDefault().fireProgammableSelectionEvent(new StructuredSelection(specTcToInsert));
    eh.getEditSupport().lockWorkVersion();
    eh.setDirty(true);
    m_editor.setSelection(new StructuredSelection(replacementTCReference));
  }
 catch (  PMException e) {
    NodeEditorInput inp=(NodeEditorInput)m_editor.getAdapter(NodeEditorInput.class);
    INodePO inpNode=inp.getNode();
    PMExceptionHandler.handlePMExceptionForMasterSession(e);
    try {
      m_editor.reOpenEditor(inpNode);
    }
 catch (    PMException e1) {
      PMExceptionHandler.handlePMExceptionForEditor(e1,m_editor);
    }
  }
  DeleteTreeItemHandlerTCEditor.deleteNodesFromEditor(m_listOfExecsToReplace,m_editor);
  return true;
}","/** 
 * {@inheritDoc}
 */
public boolean performFinish(){
  INodePO placeToInsert=m_listOfExecsToReplace.get(0);
  ISpecTestCasePO specTcToInsert=m_choosePage.getChoosenTestCase();
  try {
    Integer index=NewTestCaseHandlerTCEditor.getPositionToInsert(m_parentTC,placeToInsert);
    JBEditorHelper eh=m_editor.getEditorHelper();
    IExecTestCasePO replacementTCReference=TestCaseBP.addReferencedTestCase(m_parentTC,m_newExec,index);
    InteractionEventDispatcher.getDefault().fireProgammableSelectionEvent(new StructuredSelection(specTcToInsert));
    TestCaseBP.handleFirstReference(m_editor.getEditorHelper().getEditSupport(),m_choosePage.getChoosenTestCase(),false);
    eh.getEditSupport().lockWorkVersion();
    eh.setDirty(true);
    m_editor.setSelection(new StructuredSelection(replacementTCReference));
  }
 catch (  PMException e) {
    NodeEditorInput inp=(NodeEditorInput)m_editor.getAdapter(NodeEditorInput.class);
    INodePO inpNode=inp.getNode();
    PMExceptionHandler.handlePMExceptionForMasterSession(e);
    try {
      m_editor.reOpenEditor(inpNode);
    }
 catch (    PMException e1) {
      PMExceptionHandler.handlePMExceptionForEditor(e1,m_editor);
    }
  }
  DeleteTreeItemHandlerTCEditor.deleteNodesFromEditor(m_listOfExecsToReplace,m_editor);
  return true;
}",0.950446791226645
95611,"/** 
 * @param parameters The parameters for starting the AUT.
 * @return The arguments for the AUT that were found in the givenparameters.
 */
protected List<String> createAutArguments(Map<String,String> parameters){
  List<String> argsList=new Vector<String>();
  final String joinedAutRunArgs=parameters.get(AutConfigConstants.AUT_RUN_AUT_ARGUMENTS);
  if (joinedAutRunArgs != null) {
    return Arrays.asList(StringUtils.split(joinedAutRunArgs,AutConfigConstants.AUT_RUN_AUT_ARGUMENTS_SEPARATOR_CHAR));
  }
  String autArguments=parameters.get(AutConfigConstants.AUT_ARGUMENTS);
  if (autArguments == null) {
    autArguments=StringConstants.EMPTY;
  }
  StringTokenizer args=new StringTokenizer(autArguments,WHITESPACE_DELIMITER);
  while (args.hasMoreTokens()) {
    String arg=args.nextToken();
    argsList.add(arg);
  }
  return argsList;
}","/** 
 * @param parameters The parameters for starting the AUT.
 * @return The arguments for the AUT that were found in the givenparameters.
 */
protected List<String> createAutArguments(Map<String,String> parameters){
  List<String> argsList=new Vector<String>();
  final String joinedAutRunArgs=parameters.get(AutConfigConstants.AUT_RUN_AUT_ARGUMENTS);
  if (joinedAutRunArgs != null) {
    return Arrays.asList(StringUtils.split(joinedAutRunArgs,AutConfigConstants.AUT_RUN_AUT_ARGUMENTS_SEPARATOR_CHAR));
  }
  processAutRunArguments(parameters,argsList);
  return argsList;
}",0.7302032235459005
95612,"/** 
 * @param projectId The (database) ID of the parent project.
 */
public void setParentProjectId(Long projectId){
  setHbmParentProjectId(projectId);
}","/** 
 * @param projectId The (database) ID of the parent project.
 */
public void setParentProjectId(Long projectId){
  setHbmParentProjectId(projectId);
  for (  IDataCellPO cell : getColumns()) {
    cell.setParentProjectId(projectId);
  }
}",0.7788944723618091
95613,"/** 
 * {@inheritDoc}
 */
public void setParentProjectId(Long projectId){
  super.setParentProjectId(projectId);
  if (getParameterInterface() != null) {
    getParameterInterface().setParentProjectId(projectId);
  }
}","/** 
 * {@inheritDoc}
 */
public void setParentProjectId(Long projectId){
  super.setParentProjectId(projectId);
  getDataManager().setParentProjectId(projectId);
  if (getParameterInterface() != null) {
    getParameterInterface().setParentProjectId(projectId);
  }
}",0.897119341563786
95614,"/** 
 * factory method to replace constructor
 * @param name The name of the category.
 * @return TestDataCategoryPO
 */
public static ITestDataCategoryPO createTestDataCategoryPO(String name){
  ITestDataCategoryPO testDataCategory=new TestDataCategoryPO();
  testDataCategory.setName(name);
  return testDataCategory;
}","/** 
 * factory method to replace constructor
 * @param name The name of the category.
 * @return TestDataCategoryPO
 */
public static ITestDataCategoryPO createTestDataCategoryPO(String name){
  ITestDataCategoryPO testDataCategory=createTestDataCategoryPO();
  testDataCategory.setName(name);
  return testDataCategory;
}",0.984472049689441
95615,"/** 
 * Creates and returns a Test Data Manager object using the arguments  provided.
 * @param name Name to use in referencing the created object.  May not be <code>null</code>.
 * @return the created Test Data Manager.
 */
public static ITestDataCubePO createTestDataCubePO(String name){
  return new TestDataCubePO(name);
}","/** 
 * Creates and returns a Test Data Manager object using the arguments  provided.
 * @param name Name to use in referencing the created object.  May not be <code>null</code>.
 * @return the created Test Data Manager.
 */
public static ITestDataCubePO createTestDataCubePO(String name){
  ITestDataCubePO dataCube=new TestDataCubePO(name);
  IProjectPO currentProject=GeneralStorage.getInstance().getProject();
  if (currentProject != null) {
    dataCube.setParentProjectId(currentProject.getId());
  }
  return dataCube;
}",0.7479484173505275
95616,"/** 
 * Sets parentProjectId for all existing child nodes.  {@inheritDoc}
 */
public void setParentProjectId(Long projectId){
  if (getProjectProperties() != null) {
    getProjectProperties().setParentProjectId(projectId);
  }
  if (getHbmAutCont() != null) {
    getHbmAutCont().setParentProjectId(projectId);
  }
  if (getHbmSpecObjCont() != null) {
    getHbmSpecObjCont().setParentProjectId(projectId);
  }
  if (getHbmExecObjCont() != null) {
    getHbmExecObjCont().setParentProjectId(projectId);
  }
  if (getHbmTestDataCubeContPO() != null) {
    getHbmTestDataCubeContPO().setParentProjectId(projectId);
  }
}","/** 
 * Sets parentProjectId for all existing child nodes.  {@inheritDoc}
 */
public void setParentProjectId(Long projectId){
  getDataManager().setParentProjectId(projectId);
  if (getProjectProperties() != null) {
    getProjectProperties().setParentProjectId(projectId);
  }
  if (getHbmAutCont() != null) {
    getHbmAutCont().setParentProjectId(projectId);
  }
  if (getHbmSpecObjCont() != null) {
    getHbmSpecObjCont().setParentProjectId(projectId);
  }
  if (getHbmExecObjCont() != null) {
    getHbmExecObjCont().setParentProjectId(projectId);
  }
  if (getHbmTestDataCubeContPO() != null) {
    getHbmTestDataCubeContPO().setParentProjectId(projectId);
  }
}",0.9611801242236024
95617,"/** 
 * {@inheritDoc}
 */
public void setParentProjectId(Long projectId){
  setHbmParentProjectId(projectId);
  for (  IParamDescriptionPO paramDesc : getHbmParameterList()) {
    paramDesc.setParentProjectId(projectId);
  }
}","/** 
 * {@inheritDoc}
 */
public void setParentProjectId(Long projectId){
  setHbmParentProjectId(projectId);
  for (  IParamDescriptionPO paramDesc : getHbmParameterList()) {
    paramDesc.setParentProjectId(projectId);
  }
  getDataManager().setParentProjectId(projectId);
}",0.900398406374502
95618,"/** 
 * @param s Session to use
 * @param key If of Project to preload
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void preloadData(EntityManager s,IProjectPO key) throws JBException {
  Set<Long> projectIds=new HashSet<Long>(17);
  projectIds.add(key.getId());
  findReusedProjects(projectIds,key.getProjectProperties().getUsedProjects());
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDistinctDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<ISpecTestCasePO> testCases=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<IExecTestCasePO> testCaseRefs=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  Map<String,ISpecTestCasePO> sTc=new HashMap<String,ISpecTestCasePO>();
  for (  ISpecTestCasePO testCase : testCases) {
    sTc.put(testCase.getGuid(),testCase);
  }
  for (  IExecTestCasePO testCaseRef : testCaseRefs) {
    ISpecTestCasePO spec=sTc.get(testCaseRef.getSpecTestCaseGuid());
    if (spec != null) {
      testCaseRef.setCachedSpecTestCase(spec);
    }
  }
}","/** 
 * @param s Session to use
 * @param key If of Project to preload
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void preloadData(EntityManager s,IProjectPO key) throws JBException {
  Set<Long> projectIds=new HashSet<Long>(17);
  projectIds.add(key.getId());
  findReusedProjects(projectIds,key.getProjectProperties().getUsedProjects());
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDistinctDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<ISpecTestCasePO> testCases=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<IExecTestCasePO> testCaseRefs=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  Map<String,ISpecTestCasePO> sTc=new HashMap<String,ISpecTestCasePO>();
  for (  ISpecTestCasePO testCase : testCases) {
    sTc.put(testCase.getGuid(),testCase);
  }
  for (  IExecTestCasePO testCaseRef : testCaseRefs) {
    ISpecTestCasePO spec=sTc.get(testCaseRef.getSpecTestCaseGuid());
    if (spec != null) {
      testCaseRef.setCachedSpecTestCase(spec);
    }
  }
}",0.9676850763807284
95619,"/** 
 * Import a project from an export file
 * @param fileName export file name
 * @param exportDir directory to use
 * @param monitor the progress monitor to use
 */
private void importProject(String fileName,String exportDir,IProgressMonitor monitor){
  File impFile=new File(fileName);
  if (!impFile.isAbsolute()) {
    impFile=new File(new File(exportDir),fileName);
  }
  try {
    List<URL> fileURLs=new ArrayList<URL>(1);
    fileURLs.add(impFile.toURI().toURL());
    FileStorageBP.importFiles(fileURLs,monitor,this,false);
  }
 catch (  PMException pme) {
    writeErrorLine(pme.getLocalizedMessage());
  }
catch (  ProjectDeletedException gdpde) {
    writeErrorLine(gdpde.getLocalizedMessage());
  }
catch (  MalformedURLException e) {
    writeErrorLine(e.getLocalizedMessage());
  }
}","/** 
 * Import a project from an export file
 * @param fileName export file name
 * @param exportDir directory to use
 * @param monitor the progress monitor to use
 */
private void importProject(String fileName,String exportDir,IProgressMonitor monitor){
  File impFile=new File(fileName);
  if (!impFile.isAbsolute()) {
    impFile=new File(new File(exportDir),fileName);
  }
  try {
    List<URL> fileURLs=new ArrayList<URL>(1);
    fileURLs.add(impFile.toURI().toURL());
    FileStorageBP.importFiles(fileURLs,monitor,this,false);
  }
 catch (  MalformedURLException e) {
    writeErrorLine(e.getLocalizedMessage());
  }
}",0.8623595505617978
95620,"/** 
 * Save a project as JUB witch contains an info file about exportation, a project file and a result file
 * @param proj original project object
 * @param monitor loader monitor
 * @param fileName Jubula file name
 * @param includeTestResultSummaries true if project contain test result summaries
 * @throws ProjectDeletedException
 * @throws PMException
 * @throws IOException
 * @throws InterruptedException 
 */
private static void writeToFile(IProjectPO proj,IProgressMonitor monitor,String fileName,boolean includeTestResultSummaries) throws ProjectDeletedException, PMException, IOException {
  String dir=Files.createTempDirectory(IMPORT_FOLDER_NAME).toString() + File.separatorChar;
  String infoFileName=dir + NFO;
  String projectFileName=dir + PJT;
  String testResultFileName=dir + RST;
  ArrayList<String> fileList=new ArrayList<String>();
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_EMPTY);
  ExportInfoDTO exportDTO=new ExportInfoDTO();
  exportDTO.setQualifier(ImportExportUtil.DATE_FORMATTER.format(new Date()));
  exportDTO.setEncoding(StandardCharsets.UTF_8.name());
  exportDTO.setVersion(JsonVersion.CURRENTLY_JSON_VERSION);
  try (FileWriterWithEncoding infoWriter=new FileWriterWithEncoding(infoFileName,StandardCharsets.UTF_8);FileWriterWithEncoding projectWriter=new FileWriterWithEncoding(projectFileName,StandardCharsets.UTF_8);FileWriterWithEncoding resultWriter=new FileWriterWithEncoding(testResultFileName,StandardCharsets.UTF_8)){
    mapper.writeValue(infoWriter,exportDTO);
    fileList.add(infoFileName);
    JsonExporter exporter=new JsonExporter(proj,monitor);
    ProjectDTO projectDTO=exporter.getProjectDTO();
    mapper.writeValue(projectWriter,projectDTO);
    fileList.add(projectFileName);
    if (includeTestResultSummaries) {
      exporter.writeTestResultSummariesToFile(resultWriter);
      fileList.add(testResultFileName);
    }
    monitor.subTask(Messages.ImportJsonStorageCompress);
    zipIt(fileName,fileList);
  }
 catch (  Exception e) {
    fileList.add(fileName);
    throw e;
  }
 finally {
    fileList.add(dir);
    deleteFiles(fileList);
  }
}","/** 
 * Save a project as JUB witch contains an info file about exportation, a project file and a result file
 * @param proj original project object
 * @param monitor loader monitor
 * @param fileName Jubula file name
 * @param includeTestResultSummaries true if project contain test result summaries
 * @throws ProjectDeletedException
 * @throws PMException
 * @throws IOException
 * @throws InterruptedException 
 */
private static void writeToFile(IProjectPO proj,IProgressMonitor monitor,String fileName,boolean includeTestResultSummaries) throws ProjectDeletedException, PMException, IOException {
  String dir=Files.createTempDirectory(TMP_EXCHANGE_FOLDER_NAME).toString() + File.separatorChar;
  String infoFileName=dir + NFO;
  String projectFileName=dir + PJT;
  String testResultFileName=dir + RST;
  ArrayList<String> fileList=new ArrayList<String>();
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_EMPTY);
  ExportInfoDTO exportDTO=new ExportInfoDTO();
  exportDTO.setQualifier(ImportExportUtil.DATE_FORMATTER.format(new Date()));
  exportDTO.setEncoding(StandardCharsets.UTF_8.name());
  exportDTO.setVersion(JsonVersion.CURRENTLY_JSON_VERSION);
  try (FileWriterWithEncoding infoWriter=new FileWriterWithEncoding(infoFileName,StandardCharsets.UTF_8);FileWriterWithEncoding projectWriter=new FileWriterWithEncoding(projectFileName,StandardCharsets.UTF_8);FileWriterWithEncoding resultWriter=new FileWriterWithEncoding(testResultFileName,StandardCharsets.UTF_8)){
    mapper.writeValue(infoWriter,exportDTO);
    fileList.add(infoFileName);
    JsonExporter exporter=new JsonExporter(proj,monitor);
    ProjectDTO projectDTO=exporter.getProjectDTO();
    mapper.writeValue(projectWriter,projectDTO);
    fileList.add(projectFileName);
    if (includeTestResultSummaries) {
      exporter.writeTestResultSummariesToFile(resultWriter);
      fileList.add(testResultFileName);
    }
    monitor.subTask(Messages.ImportJsonStorageCompress);
    zipIt(fileName,fileList);
  }
 catch (  Exception e) {
    fileList.add(fileName);
    throw e;
  }
 finally {
    fileList.add(dir);
    deleteFiles(fileList);
  }
}",0.9967562557924003
95621,"/** 
 * @param io console
 * @param projectDTO 
 */
private void existProjectHandling(IProgressConsole io,ProjectDTO projectDTO){
  String msg=NLS.bind(Messages.ErrorMessageIMPORT_PROJECT_XML_FAILED,new String[]{ProjectNameBP.getInstance().getName(projectDTO.getUuid(),false)}) + StringConstants.NEWLINE + NLS.bind(Messages.ErrorMessageIMPORT_PROJECT_XML_FAILED_EXISTING,new String[]{projectDTO.getName(),projectDTO.getProjectVersion().toString()});
  io.writeStatus(new Status(IStatus.INFO,Activator.PLUGIN_ID,msg));
}","/** 
 * @param io console
 * @param projectDTO 
 */
private void existProjectHandling(IProgressConsole io,ProjectDTO projectDTO){
  String msg=NLS.bind(Messages.ErrorMessageIMPORT_PROJECT_FAILED,new String[]{ProjectNameBP.getInstance().getName(projectDTO.getUuid(),false)}) + StringConstants.NEWLINE + NLS.bind(Messages.ErrorMessageIMPORT_PROJECT_FAILED_EXISTING,new String[]{projectDTO.getName(),projectDTO.getProjectVersion().toString()});
  io.writeStatus(new Status(IStatus.WARNING,Activator.PLUGIN_ID,msg));
}",0.4743465634075508
95622,"/** 
 * @param parameterList List of IParameterDetailsPOonly for Persistence (JPA / EclipseLink)
 */
TestResultPO(List<IParameterDetailsPO> parameterList){
  m_parameterList=parameterList;
  setTestResultAdditions(new ArrayList<ITestResultAdditionPO>(4));
}","/** 
 * @param parameterList List of IParameterDetailsPOonly for Persistence (JPA / EclipseLink)
 */
TestResultPO(List<IParameterDetailsPO> parameterList){
  m_parameterList=parameterList;
}",0.8501118568232662
95623,"/** 
 * @return the object responsible for maintaining the receiver's parameterinterface as well as test data.
 */
@ManyToOne(cascade=CascadeType.ALL,targetEntity=TestDataCubePO.class,fetch=FetchType.EAGER) @JoinColumn(name=""String_Node_Str"",unique=true) @BatchFetch(value=BatchFetchType.JOIN) private TestDataCubePO getParameterInterface(){
  return m_parameterInterface;
}","/** 
 * @return the object responsible for maintaining the receiver's parameterinterface as well as test data.
 */
@ManyToOne(cascade=CascadeType.ALL,targetEntity=TestDataCubePO.class,fetch=FetchType.EAGER) @JoinColumn(name=""String_Node_Str"",unique=true) private TestDataCubePO getParameterInterface(){
  return m_parameterInterface;
}",0.9449929478138224
95624,"@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle cellBounds=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeBounds=NodeBounds.getAbsoluteBounds(tree);
          int leftX;
          int cellWidth;
          Node disclosureNode=cell.getDisclosureNode();
          if (disclosureNode != null) {
            Rectangle closureNodeBounds=NodeBounds.getAbsoluteBounds(disclosureNode);
            leftX=((int)closureNodeBounds.getMaxX()) - treeBounds.x;
            cellWidth=(int)(cellBounds.getMaxX() - closureNodeBounds.getMaxX());
          }
 else {
            leftX=cellBounds.x - treeBounds.x;
            cellWidth=cellBounds.width;
          }
          int cellRelativeY=cellBounds.y - treeBounds.y;
          return new Rectangle(leftX,cellRelativeY,cellWidth,cellBounds.height);
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}","@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle b=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
          return new Rectangle(Math.abs(treeB.x - b.x),Math.abs(treeB.y - b.y),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}",0.7076683534449202
95625,"@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView tree=getTree();
      int index=tree.getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}","@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView<?> tree=getTree();
      int index=((TreeView)tree).getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}",0.9679218967921897
95626,"@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(treeB.getWidth()),Rounding.round(treeB.getHeight()));
      Rectangle intersection=rowBounds.intersection(visibleTreeBounds);
      if (intersection.isEmpty()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
      }
      return intersection;
    }
  }
);
  return result;
}","@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(tree.getWidth()),Rounding.round(tree.getHeight()));
      return rowBounds.intersection(visibleTreeBounds);
    }
  }
);
  return result;
}",0.6007905138339921
95627,"/** 
 * @param dto will be contained the test data manager infos
 * @param po data manager  
 */
private void fillTDManager(TDManagerDTO dto,ITDManager po){
  dto.setUniqueIds(po.getUniqueIds());
  for (  IDataSetPO dataSet : po.getDataSets()) {
    DataSetDTO dsDTO=new DataSetDTO();
    dsDTO.setColumns(dataSet.getColumns());
    dto.addDataSet(dsDTO);
  }
}","/** 
 * @param dto will be contained the test data manager infos
 * @param po data manager  
 */
private void fillTDManager(TDManagerDTO dto,ITDManager po){
  dto.setUniqueIds(po.getUniqueIds());
  for (  IDataSetPO dataSet : po.getDataSets()) {
    DataSetDTO dsDTO=new DataSetDTO();
    dsDTO.setColumns(dataSet.getColumnsCopy());
    dto.addDataSet(dsDTO);
  }
}",0.9944903581267218
95628,"/** 
 * Write the information from the Object to its corresponding XML element.
 * @param xml The XML element to be filled
 * @param po The persistent object which contains the information
 */
private void fillTestData(TestData xml,ITDManager po){
  for (  String uniqueId : po.getUniqueIds()) {
    xml.addUniqueIds(uniqueId);
  }
  int rowCnt=1;
  for (  IDataSetPO row : po.getDataSets()) {
    TestDataRow xmlRow=xml.addNewRow();
    xmlRow.setRowCount(rowCnt++);
    int colCnt=1;
    for (    String td : row.getColumns()) {
      TestDataCell xmlCell=xmlRow.addNewData();
      xmlCell.setColumnCount(colCnt++);
      xmlCell.setValue(td);
    }
  }
}","/** 
 * Write the information from the Object to its corresponding XML element.
 * @param xml The XML element to be filled
 * @param po The persistent object which contains the information
 */
private void fillTestData(TestData xml,ITDManager po){
  for (  String uniqueId : po.getUniqueIds()) {
    xml.addUniqueIds(uniqueId);
  }
  int rowCnt=1;
  for (  IDataSetPO row : po.getDataSets()) {
    TestDataRow xmlRow=xml.addNewRow();
    xmlRow.setRowCount(rowCnt++);
    for (int col=0; col < row.getColumnCount(); col++) {
      TestDataCell xmlCell=xmlRow.addNewData();
      xmlCell.setColumnCount(col + 1);
      xmlCell.setValue(row.getValueAt(col));
    }
  }
}",0.7782805429864253
95629,"/** 
 * This method is called if the Action of a CAP is not compatible with the current XML-Config-File.<br> The existent TDManager of the CAP is filled with the TestData
 * @param owner The CAP.
 * @param xmlCap The abstraction of the XML CAP (see Apache XML Beans)
 * @return the filled TDManager of the given owner
 */
private ITDManager fillTDManager(IParamNodePO owner,Cap xmlCap){
  final ITDManager tdman=owner.getDataManager();
  List<ParamDescription> parDescList=xmlCap.getParameterDescriptionList();
  final TestData testData=xmlCap.getTestdata();
  int tdRow=0;
  for (  TestDataRow rowXml : testData.getRowList()) {
    if (rowXml.getDataList().isEmpty()) {
      continue;
    }
    List<String> tdList=null;
    try {
      tdList=tdman.getDataSet(tdRow).getColumns();
    }
 catch (    IndexOutOfBoundsException ioobe) {
      final StringBuilder msgSb=new StringBuilder();
      msgSb.append(Messages.Component);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(xmlCap.getComponentType());
      msgSb.append(StringConstants.NEWLINE + Messages.Action);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(xmlCap.getActionName(),true));
      msgSb.append(StringConstants.NEWLINE + Messages.Parameter);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(parDescList.get(tdRow).getName(),true));
      final String msg=msgSb.toString();
      log.error(msg,ioobe);
      continue;
    }
    int tdCell=0;
    for (    TestDataCell cellXml : rowXml.getDataList()) {
      String uniqueId=parDescList.get(tdCell).getUniqueId();
      final int ownerIndex=owner.getDataManager().findColumnForParam(uniqueId);
      if (ownerIndex > -1) {
        tdList.set(ownerIndex,readData(cellXml,owner));
      }
      tdCell++;
    }
    tdman.clear();
    tdman.insertDataSet(PoMaker.createListWrapperPO(tdList),tdRow);
    tdRow++;
  }
  return tdman;
}","/** 
 * This method is called if the Action of a CAP is not compatible with the current XML-Config-File.<br> The existent TDManager of the CAP is filled with the TestData
 * @param owner The CAP.
 * @param xmlCap The abstraction of the XML CAP (see Apache XML Beans)
 * @return the filled TDManager of the given owner
 */
private ITDManager fillTDManager(IParamNodePO owner,Cap xmlCap){
  final ITDManager tdman=owner.getDataManager();
  List<ParamDescription> parDescList=xmlCap.getParameterDescriptionList();
  final TestData testData=xmlCap.getTestdata();
  int tdRow=0;
  for (  TestDataRow rowXml : testData.getRowList()) {
    if (rowXml.getDataList().isEmpty()) {
      continue;
    }
    List<String> tdList=null;
    try {
      tdList=tdman.getDataSet(tdRow).getColumnsCopy();
    }
 catch (    IndexOutOfBoundsException ioobe) {
      final StringBuilder msgSb=new StringBuilder();
      msgSb.append(Messages.Component);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(xmlCap.getComponentType());
      msgSb.append(StringConstants.NEWLINE + Messages.Action);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(xmlCap.getActionName(),true));
      msgSb.append(StringConstants.NEWLINE + Messages.Parameter);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(parDescList.get(tdRow).getName(),true));
      final String msg=msgSb.toString();
      log.error(msg,ioobe);
      continue;
    }
    int tdCell=0;
    for (    TestDataCell cellXml : rowXml.getDataList()) {
      String uniqueId=parDescList.get(tdCell).getUniqueId();
      final int ownerIndex=owner.getDataManager().findColumnForParam(uniqueId);
      if (ownerIndex > -1) {
        tdList.set(ownerIndex,readData(cellXml,owner));
      }
      tdCell++;
    }
    tdman.clear();
    tdman.insertDataSet(PoMaker.createListWrapperPO(tdList),tdRow);
    tdRow++;
  }
  return tdman;
}",0.9990074441687344
95630,"/** 
 * {@inheritDoc} 
 */
public void addColumn(String value){
  getColumns().add(value);
}","/** 
 * {@inheritDoc} 
 */
public void addColumn(String value){
  getColumns().add(StringUtils.defaultIfEmpty(value,StringConstants.UNICODE_NULL));
}",0.7634854771784232
95631,"/** 
 * {@inheritDoc} 
 */
public void setValueAt(int column,String value){
  getColumns().set(column,value);
}","/** 
 * {@inheritDoc} 
 */
public void setValueAt(int column,String value){
  getColumns().set(column,StringUtils.defaultIfEmpty(value,StringConstants.UNICODE_NULL));
}",0.7956989247311828
95632,"/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.JOIN) public List<String> getColumns(){
  return m_columns;
}","/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.JOIN) private List<String> getColumns(){
  return m_columns;
}",0.98379970544919
95633,"/** 
 * {@inheritDoc} 
 */
public String getValueAt(int column){
  return getColumns().get(column);
}","/** 
 * {@inheritDoc} 
 */
public String getValueAt(int column){
  String value=getColumns().get(column);
  if (StringConstants.UNICODE_NULL.equals(value)) {
    return null;
  }
  return value;
}",0.6464646464646465
95634,"/** 
 * @param references The references
 * @param row The row representation
 * @param dataSetRow The row index
 */
private void addParamReferences(List<TDCell> references,IDataSetPO row,int dataSetRow){
  int col=0;
  for (  String testData : row.getColumns()) {
    String uniqueId=getDataManager().getUniqueIds().get(col);
    IParamDescriptionPO desc=getParameterForUniqueId(uniqueId);
    ParamValueConverter conv=new ModelParamValueConverter(testData,this,desc);
    if (conv.containsReferences()) {
      references.add(new TDCell(testData,dataSetRow,col));
    }
    col++;
  }
}","/** 
 * @param references The references
 * @param row The row representation
 * @param dataSetRow The row index
 */
private void addParamReferences(List<TDCell> references,IDataSetPO row,int dataSetRow){
  for (int col=0; col < row.getColumnCount(); col++) {
    String testData=row.getValueAt(col);
    String uniqueId=getDataManager().getUniqueIds().get(col);
    IParamDescriptionPO desc=getParameterForUniqueId(uniqueId);
    ParamValueConverter conv=new ModelParamValueConverter(testData,this,desc);
    if (conv.containsReferences()) {
      references.add(new TDCell(testData,dataSetRow,col));
    }
    col++;
  }
}",0.9323432343234324
95635,"/** 
 * @return The number of columns
 */
@Transient public int getColumnCount(){
  int columns=0;
  try {
    List<IDataSetPO> dataTable=getDataTable();
    if (dataTable.size() > 0) {
      IDataSetPO listW=dataTable.get(0);
      columns=listW.getColumns().size();
    }
  }
 catch (  IndexOutOfBoundsException e) {
  }
  return columns;
}","/** 
 * @return The number of columns
 */
@Transient public int getColumnCount(){
  int columns=0;
  try {
    List<IDataSetPO> dataTable=getDataTable();
    if (dataTable.size() > 0) {
      IDataSetPO listW=dataTable.get(0);
      columns=listW.getColumnCount();
    }
  }
 catch (  IndexOutOfBoundsException e) {
  }
  return columns;
}",0.9809104258443464
95636,"/** 
 * Copies the data of this TDManager to the given TDManager
 * @param tdMan the TDManager to copy the data to
 * @return the given TDManager with the new data.
 */
public ITDManager deepCopy(ITDManager tdMan){
  for (  String uniqueId : getUniqueIds()) {
    tdMan.addUniqueId(uniqueId);
  }
  tdMan.clear();
  for (  IDataSetPO dataSet : getDataSets()) {
    List<String> newRow=new ArrayList<String>(dataSet.getColumnCount());
    for (    String testData : dataSet.getColumns()) {
      newRow.add(testData);
    }
    tdMan.insertDataSet(PoMaker.createListWrapperPO(newRow),tdMan.getDataSetCount());
  }
  return tdMan;
}","/** 
 * Copies the data of this TDManager to the given TDManager
 * @param tdMan the TDManager to copy the data to
 * @return the given TDManager with the new data.
 */
public ITDManager deepCopy(ITDManager tdMan){
  for (  String uniqueId : getUniqueIds()) {
    tdMan.addUniqueId(uniqueId);
  }
  tdMan.clear();
  for (  IDataSetPO dataSet : getDataSets()) {
    int columncount=dataSet.getColumnCount();
    List<String> newRow=new ArrayList<String>(columncount);
    for (int i=0; i < columncount; i++) {
      newRow.add(dataSet.getValueAt(i));
    }
    tdMan.insertDataSet(PoMaker.createListWrapperPO(newRow),tdMan.getDataSetCount());
  }
  return tdMan;
}",0.8754833720030936
95637,"/** 
 * create the items for the status line
 */
public static void createStatusLineItems(){
  IStatusLineManager manager=getStatusLineManager();
  StatusLineContributionItem connectionItem=new StatusLineContributionItem(CONNECTION_INFO_STATUSLINE_ITEM);
  manager.insertBefore(StatusLineManager.END_GROUP,connectionItem);
  manager.insertBefore(CONNECTION_INFO_STATUSLINE_ITEM,connectionItem);
  StatusLineContributionItem autToolKitItem=new StatusLineContributionItem(AUT_TOOLKIT_STATUSLINE_ITEM);
  autToolKitItem.setText(StringConstants.EMPTY);
  manager.insertBefore(CONNECTION_INFO_STATUSLINE_ITEM,autToolKitItem);
  manager.update(true);
}","/** 
 * create the items for the status line
 */
public static void createStatusLineItems(){
  IStatusLineManager manager=getStatusLineManager();
  StatusLineContributionItem connectionItem=new StatusLineContributionItem(CONNECTION_INFO_STATUSLINE_ITEM);
  manager.insertBefore(StatusLineManager.END_GROUP,connectionItem);
  StatusLineContributionItem autToolKitItem=new StatusLineContributionItem(AUT_TOOLKIT_STATUSLINE_ITEM);
  autToolKitItem.setText(StringConstants.EMPTY);
  manager.insertBefore(CONNECTION_INFO_STATUSLINE_ITEM,autToolKitItem);
  manager.update(true);
}",0.940983606557377
95638,"/** 
 * {@inheritDoc}
 */
public boolean isTestDataComplete(){
  if (StringUtils.isEmpty(getDataFile())) {
    final int paramListSize=getParameterListSize();
    ITDManager testDataManager=getDataManager();
    if ((testDataManager.getDataSetCount() == 0) && (paramListSize > 0)) {
      return false;
    }
    if (getParameterListSize() > testDataManager.getColumnCount()) {
      return false;
    }
    List<IParamDescriptionPO> requiredParameters=new ArrayList<IParamDescriptionPO>(getParameterList());
    IParameterInterfacePO refDataCube=getReferencedDataCube();
    for (int i=0; i < testDataManager.getDataSetCount(); i++) {
      for (      IParamDescriptionPO paramDesc : requiredParameters) {
        int column=testDataManager.findColumnForParam(paramDesc.getUniqueId());
        if (refDataCube != null) {
          IParamDescriptionPO dataCubeParam=refDataCube.getParameterForName(paramDesc.getName());
          if (dataCubeParam != null) {
            column=testDataManager.findColumnForParam(dataCubeParam.getUniqueId());
          }
        }
        if (column == -1) {
          return false;
        }
        String value=TestDataBP.INSTANCE.getTestData(this,testDataManager,paramDesc,i);
        if (value != null) {
          ModelParamValueConverter mpvc=new ModelParamValueConverter(value,this,paramDesc);
          List<RefToken> referenceTokens=mpvc.getRefTokens();
          String uiValue=mpvc.getGuiString();
          for (          RefToken token : referenceTokens) {
            if (uiValue.contains(token.getModelString())) {
              return false;
            }
          }
        }
 else {
          return false;
        }
      }
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
public boolean isTestDataComplete(){
  if (StringUtils.isEmpty(getDataFile())) {
    final int paramListSize=getParameterListSize();
    ITDManager testDataManager=getDataManager();
    if ((testDataManager.getDataSetCount() == 0) && (paramListSize > 0)) {
      return false;
    }
    if (getParameterListSize() > testDataManager.getColumnCount()) {
      return false;
    }
    List<IParamDescriptionPO> requiredParameters=new ArrayList<IParamDescriptionPO>(getParameterList());
    IParameterInterfacePO refDataCube=getReferencedDataCube();
    for (int i=0; i < testDataManager.getDataSetCount(); i++) {
      for (      IParamDescriptionPO paramDesc : requiredParameters) {
        int column=testDataManager.findColumnForParam(paramDesc.getUniqueId());
        if (refDataCube != null) {
          IParamDescriptionPO dataCubeParam=refDataCube.getParameterForName(paramDesc.getName());
          if (dataCubeParam != null) {
            column=testDataManager.findColumnForParam(dataCubeParam.getUniqueId());
          }
        }
        if (column == -1) {
          return false;
        }
        String value=TestDataBP.INSTANCE.getTestData(this,testDataManager,paramDesc,i);
        if (StringUtils.isNotEmpty(value)) {
          ModelParamValueConverter mpvc=new ModelParamValueConverter(value,this,paramDesc);
          List<RefToken> referenceTokens=mpvc.getRefTokens();
          String uiValue=mpvc.getGuiString();
          for (          RefToken token : referenceTokens) {
            if (uiValue.contains(token.getModelString())) {
              return false;
            }
          }
        }
 else {
          return false;
        }
      }
    }
  }
  return true;
}",0.9906596614127262
95639,"/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param owner The ParamNode which holds this TDManager
 * @param dto Abstraction of the DTO elementthe test data, otherwise a new TDManager is created.
 * @return a persistent object generated from the information in the DTOelement
 * @param assignNewGuids <code>true</code> if the parameters were givennew unique IDs. Otherwise <code>false</code>.
 */
private ITDManager createTDManager(IParameterInterfacePO owner,TDManagerDTO dto,boolean assignNewGuids){
  if (dto == null) {
    return PoMaker.createTDManagerPO(owner);
  }
  final ITDManager tdman;
  List<String> uniqueIds=new ArrayList<String>(dto.getUniqueIds());
  if (assignNewGuids) {
    List<String> newUniqueIds=new ArrayList<String>();
    for (    String id : uniqueIds) {
      if (Pattern.matches(""String_Node_Str"" + GUID_LENGTH + ""String_Node_Str"",id) && m_oldToNewGuids.containsKey(id)) {
        newUniqueIds.add(m_oldToNewGuids.get(id));
      }
 else {
        newUniqueIds.add(id);
      }
    }
    uniqueIds=newUniqueIds;
  }
  if (uniqueIds.isEmpty()) {
    tdman=PoMaker.createTDManagerPO(owner);
  }
 else {
    tdman=PoMaker.createTDManagerPO(owner,uniqueIds);
  }
  for (  DataRowDTO row : dto.getDataSets()) {
    final List<String> td=new ArrayList<String>(row.getColumns().size());
    for (    String column : row.getColumns()) {
      td.add(readData(column,owner));
    }
    tdman.insertDataSet(PoMaker.createListWrapperPO(td),tdman.getDataSetCount());
  }
  return tdman;
}","/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param owner The ParamNode which holds this TDManager
 * @param dto Abstraction of the DTO elementthe test data, otherwise a new TDManager is created.
 * @return a persistent object generated from the information in the DTOelement
 * @param assignNewGuids <code>true</code> if the parameters were givennew unique IDs. Otherwise <code>false</code>.
 */
private ITDManager createTDManager(IParameterInterfacePO owner,TDManagerDTO dto,boolean assignNewGuids){
  if (dto == null) {
    return PoMaker.createTDManagerPO(owner);
  }
  final ITDManager tdman;
  List<String> uniqueIds=new ArrayList<String>(dto.getUniqueIds());
  if (assignNewGuids) {
    List<String> newUniqueIds=new ArrayList<String>();
    for (    String id : uniqueIds) {
      if (Pattern.matches(""String_Node_Str"" + ImportExportUtil.UUID_LENGTH + ""String_Node_Str"",id) && m_oldToNewGuids.containsKey(id)) {
        newUniqueIds.add(m_oldToNewGuids.get(id));
      }
 else {
        newUniqueIds.add(id);
      }
    }
    uniqueIds=newUniqueIds;
  }
  if (uniqueIds.isEmpty()) {
    tdman=PoMaker.createTDManagerPO(owner);
  }
 else {
    tdman=PoMaker.createTDManagerPO(owner,uniqueIds);
  }
  for (  DataRowDTO row : dto.getDataSets()) {
    final List<String> td=new ArrayList<String>(row.getColumns().size());
    for (    String column : row.getColumns()) {
      td.add(readData(column,owner));
    }
    tdman.insertDataSet(PoMaker.createListWrapperPO(td),tdman.getDataSetCount());
  }
  return tdman;
}",0.9941842669115396
95640,"/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param dto Abstraction of the DTO element
 * @param assignNewGuid <code>true</code> if the testcase should be assigned a new GUID. Otherwise <code>false</code>.
 * @param mapper mapper to resolve param names
 * @return a persistent object generated from the information in the DTO element
 * @throws InvalidDataException 
 */
private ISpecTestCasePO createTestCaseBase(IProjectPO proj,TestCaseDTO dto,boolean assignNewGuid,IParamNameMapper mapper) throws InvalidDataException {
  ISpecTestCasePO tc;
  if (assignNewGuid) {
    tc=NodeMaker.createSpecTestCasePO(dto.getName());
    m_tcRef.put(tc.getGuid(),tc);
    m_oldToNewGuids.put(dto.getUuid(),tc.getGuid());
  }
 else {
    tc=NodeMaker.createSpecTestCasePO(dto.getName(),dto.getUuid());
    m_tcRef.put(dto.getUuid(),tc);
  }
  tc.setComment(dto.getComment());
  tc.setDescription(dto.getDescription());
  tc.setGenerated(dto.getGenerated());
  tc.setTaskId(dto.getTaskId());
  tc.setInterfaceLocked(dto.isInterfaceLocked());
  tc.setDataFile(dto.getDatafile());
  fillTrackedChangesInformation(tc,dto);
  if (dto.getReferencedTestData() != null) {
    String referencedDataName=dto.getReferencedTestData();
    for (    IParameterInterfacePO testDataCube : TestDataCubeBP.getAllTestDataCubesFor(proj)) {
      if (referencedDataName.equals(testDataCube.getName())) {
        tc.setReferencedDataCube(testDataCube);
        break;
      }
    }
  }
  for (  ParamDescriptionDTO pdDto : dto.getParameterDescription()) {
    String uniqueId=pdDto.getUuid();
    if (assignNewGuid) {
      IParamDescriptionPO paramDesc=tc.addParameter(pdDto.getType(),pdDto.getName(),mapper);
      m_oldToNewGuids.put(uniqueId,paramDesc.getUniqueId());
    }
 else {
      if (uniqueId != null && Pattern.matches(""String_Node_Str"" + GUID_LENGTH + ""String_Node_Str"",uniqueId)) {
        tc.addParameter(pdDto.getType(),pdDto.getName(),uniqueId,mapper);
      }
 else {
        tc.addParameter(pdDto.getType(),pdDto.getName(),mapper);
      }
    }
  }
  tc.setDataManager(createTDManager(tc,dto.getTDManager(),assignNewGuid));
  if (!assignNewGuid) {
    generateRefTestCase(dto,proj,tc,assignNewGuid);
  }
  return tc;
}","/** 
 * Creates the instance of the persistent object which is defined by the DTO element used as parameter. The method generates all dependent objects as well.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param dto Abstraction of the DTO element
 * @param assignNewGuid <code>true</code> if the testcase should be assigned a new GUID. Otherwise <code>false</code>.
 * @param mapper mapper to resolve param names
 * @return a persistent object generated from the information in the DTO element
 * @throws InvalidDataException 
 */
private ISpecTestCasePO createTestCaseBase(IProjectPO proj,TestCaseDTO dto,boolean assignNewGuid,IParamNameMapper mapper) throws InvalidDataException {
  ISpecTestCasePO tc;
  if (assignNewGuid) {
    tc=NodeMaker.createSpecTestCasePO(dto.getName());
    m_tcRef.put(tc.getGuid(),tc);
    m_oldToNewGuids.put(dto.getUuid(),tc.getGuid());
  }
 else {
    tc=NodeMaker.createSpecTestCasePO(dto.getName(),dto.getUuid());
    m_tcRef.put(dto.getUuid(),tc);
  }
  tc.setComment(dto.getComment());
  tc.setDescription(dto.getDescription());
  tc.setGenerated(dto.getGenerated());
  tc.setTaskId(dto.getTaskId());
  tc.setInterfaceLocked(dto.isInterfaceLocked());
  tc.setDataFile(dto.getDatafile());
  fillTrackedChangesInformation(tc,dto);
  if (dto.getReferencedTestData() != null) {
    String referencedDataName=dto.getReferencedTestData();
    for (    IParameterInterfacePO testDataCube : TestDataCubeBP.getAllTestDataCubesFor(proj)) {
      if (referencedDataName.equals(testDataCube.getName())) {
        tc.setReferencedDataCube(testDataCube);
        break;
      }
    }
  }
  for (  ParamDescriptionDTO pdDto : dto.getParameterDescription()) {
    String uniqueId=pdDto.getUuid();
    if (assignNewGuid) {
      IParamDescriptionPO paramDesc=tc.addParameter(pdDto.getType(),pdDto.getName(),mapper);
      m_oldToNewGuids.put(uniqueId,paramDesc.getUniqueId());
    }
 else {
      if (uniqueId != null && Pattern.matches(""String_Node_Str"" + ImportExportUtil.UUID_LENGTH + ""String_Node_Str"",uniqueId)) {
        tc.addParameter(pdDto.getType(),pdDto.getName(),uniqueId,mapper);
      }
 else {
        tc.addParameter(pdDto.getType(),pdDto.getName(),mapper);
      }
    }
  }
  tc.setDataManager(createTDManager(tc,dto.getTDManager(),assignNewGuid));
  if (!assignNewGuid) {
    generateRefTestCase(dto,proj,tc,assignNewGuid);
  }
  return tc;
}",0.9962173999601832
95641,"/** 
 * Save a project as JUB witch contains an info file about exportation, a project file and a result file
 * @param proj original project object
 * @param monitor loader monitor
 * @param fileName Jubula file name
 * @param includeTestResultSummaries true if project contain test result summaries
 * @throws ProjectDeletedException
 * @throws PMException
 * @throws IOException
 * @throws InterruptedException 
 */
private static void writeToFile(IProjectPO proj,IProgressMonitor monitor,String fileName,boolean includeTestResultSummaries) throws ProjectDeletedException, PMException, IOException {
  String dir=Files.createTempDirectory(IMPORT_FOLDER_NAME).toString() + File.separatorChar;
  String infoFileName=dir + NFO;
  String projectFileName=dir + PJT;
  String testResultFileName=dir + RST;
  ArrayList<String> fileList=new ArrayList<String>();
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_EMPTY);
  ExportInfoDTO exportDTO=new ExportInfoDTO();
  exportDTO.setQualifier(ImportExportUtil.DATE_FORMATTER.format(new Date()));
  exportDTO.setEncoding(RECOMMENDED_CHAR_ENCODING);
  exportDTO.setVersion(JsonVersion.CURRENTLY_JSON_VERSION);
  try (FileWriterWithEncoding infoWriter=new FileWriterWithEncoding(infoFileName,UTF_8_CHAR_ENCODING);FileWriterWithEncoding projectWriter=new FileWriterWithEncoding(projectFileName,RECOMMENDED_CHAR_ENCODING);FileWriterWithEncoding resultWriter=new FileWriterWithEncoding(testResultFileName,RECOMMENDED_CHAR_ENCODING)){
    mapper.writeValue(infoWriter,exportDTO);
    fileList.add(infoFileName);
    JsonExporter exporter=new JsonExporter(proj,monitor);
    ProjectDTO projectDTO=exporter.getProjectDTO();
    mapper.writeValue(projectWriter,projectDTO);
    fileList.add(projectFileName);
    if (includeTestResultSummaries) {
      exporter.writeTestResultSummariesToFile(resultWriter);
      fileList.add(testResultFileName);
    }
    monitor.subTask(Messages.ImportJsonStorageCompress);
    zipIt(fileName,fileList);
  }
 catch (  Exception e) {
    fileList.add(fileName);
    throw e;
  }
 finally {
    fileList.add(dir);
    deleteFiles(fileList);
  }
}","/** 
 * Save a project as JUB witch contains an info file about exportation, a project file and a result file
 * @param proj original project object
 * @param monitor loader monitor
 * @param fileName Jubula file name
 * @param includeTestResultSummaries true if project contain test result summaries
 * @throws ProjectDeletedException
 * @throws PMException
 * @throws IOException
 * @throws InterruptedException 
 */
private static void writeToFile(IProjectPO proj,IProgressMonitor monitor,String fileName,boolean includeTestResultSummaries) throws ProjectDeletedException, PMException, IOException {
  String dir=Files.createTempDirectory(IMPORT_FOLDER_NAME).toString() + File.separatorChar;
  String infoFileName=dir + NFO;
  String projectFileName=dir + PJT;
  String testResultFileName=dir + RST;
  ArrayList<String> fileList=new ArrayList<String>();
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(Include.NON_EMPTY);
  ExportInfoDTO exportDTO=new ExportInfoDTO();
  exportDTO.setQualifier(ImportExportUtil.DATE_FORMATTER.format(new Date()));
  exportDTO.setEncoding(StandardCharsets.UTF_8.name());
  exportDTO.setVersion(JsonVersion.CURRENTLY_JSON_VERSION);
  try (FileWriterWithEncoding infoWriter=new FileWriterWithEncoding(infoFileName,StandardCharsets.UTF_8);FileWriterWithEncoding projectWriter=new FileWriterWithEncoding(projectFileName,StandardCharsets.UTF_8);FileWriterWithEncoding resultWriter=new FileWriterWithEncoding(testResultFileName,StandardCharsets.UTF_8)){
    mapper.writeValue(infoWriter,exportDTO);
    fileList.add(infoFileName);
    JsonExporter exporter=new JsonExporter(proj,monitor);
    ProjectDTO projectDTO=exporter.getProjectDTO();
    mapper.writeValue(projectWriter,projectDTO);
    fileList.add(projectFileName);
    if (includeTestResultSummaries) {
      exporter.writeTestResultSummariesToFile(resultWriter);
      fileList.add(testResultFileName);
    }
    monitor.subTask(Messages.ImportJsonStorageCompress);
    zipIt(fileName,fileList);
  }
 catch (  Exception e) {
    fileList.add(fileName);
    throw e;
  }
 finally {
    fileList.add(dir);
    deleteFiles(fileList);
  }
}",0.883731724297981
95642,"/** 
 * @param url of import file
 * @param paramNameMapper 
 * @param compNameCache 
 * @param assignNewGuid 
 * @param testResultNeeded 
 * @param monitor 
 * @param io console
 * @return IProjectPO new project object 
 * @throws JBVersionException 
 * @throws PMReadException 
 * @throws InterruptedException 
 * @throws PMSaveException 
 */
public IProjectPO readProject(URL url,ParamNameBPDecorator paramNameMapper,final IWritableComponentNameCache compNameCache,boolean assignNewGuid,boolean testResultNeeded,IProgressMonitor monitor,IProgressConsole io) throws JBVersionException, PMReadException, InterruptedException {
  SubMonitor subMonitor=SubMonitor.convert(monitor,Messages.ImportFileBPReading,testResultNeeded ? 2 : 1);
  IProjectPO projectPO=null;
  String folderSrc=null;
  try {
    monitor.subTask(Messages.ImportJsonStoragePreparing);
    folderSrc=Files.createTempDirectory(IMPORT_FOLDER_NAME).toString();
    String fileName=url.getPath().substring(url.getPath().lastIndexOf(File.separatorChar) + 1,url.getPath().lastIndexOf(StringConstants.DOT));
    fileName=URLDecoder.decode(fileName,RECOMMENDED_CHAR_ENCODING);
    String path=URLDecoder.decode(url.getPath(),RECOMMENDED_CHAR_ENCODING);
    unZipIt(path,folderSrc);
    ObjectMapper mapper=new ObjectMapper();
    String infoPath=folderSrc + File.separatorChar + NFO;
    String projectPath=folderSrc + File.separatorChar + PJT;
    InputStreamReader inforReader=new InputStreamReader(new FileInputStream(infoPath),UTF_8_CHAR_ENCODING);
    ExportInfoDTO exportDTO=mapper.readValue(inforReader,ExportInfoDTO.class);
    checkMinimumRequiredJSONVersion(exportDTO);
    InputStreamReader projectReader=new InputStreamReader(new FileInputStream(projectPath),exportDTO.getEncoding());
    ProjectDTO projectDTO=mapper.readValue(projectReader,ProjectDTO.class);
    if (projectExists(projectDTO)) {
      existProjectHandling(io,projectDTO);
      return null;
    }
    projectPO=load(projectDTO,subMonitor.newChild(1),io,assignNewGuid,paramNameMapper,compNameCache,false);
    if (testResultNeeded) {
      String resultPath=folderSrc + File.separatorChar + RST;
      InputStreamReader resultReader=new InputStreamReader(new FileInputStream(resultPath),exportDTO.getEncoding());
      JsonImporter importer=new JsonImporter(monitor,io,false);
      ArrayList<TestresultSummaryDTO> resultDTOs=mapper.readValue(resultReader,new TypeReference<ArrayList<TestresultSummaryDTO>>(){
      }
);
      importer.initTestResultSummaries(subMonitor.newChild(1),resultDTOs,projectPO);
    }
  }
 catch (  IOException e) {
    if (!monitor.isCanceled()) {
      log.info(Messages.GeneralIoExeption);
      throw new PMReadException(Messages.InvalidImportFile,MessageIDs.E_IO_EXCEPTION);
    }
  }
 finally {
    if (folderSrc != null) {
      deleteFiles(Arrays.asList(folderSrc));
    }
  }
  return projectPO;
}","/** 
 * @param url of import file
 * @param paramNameMapper 
 * @param compNameCache 
 * @param assignNewGuid 
 * @param monitor 
 * @param io console
 * @return IProjectPO new project object 
 * @throws JBVersionException 
 * @throws PMReadException 
 * @throws InterruptedException 
 * @throws PMSaveException 
 */
public IProjectPO readProject(URL url,ParamNameBPDecorator paramNameMapper,final IWritableComponentNameCache compNameCache,boolean assignNewGuid,IProgressMonitor monitor,IProgressConsole io) throws JBVersionException, PMReadException, InterruptedException {
  SubMonitor subMonitor=SubMonitor.convert(monitor,Messages.ImportFileBPReading,2);
  IProjectPO projectPO=null;
  monitor.subTask(Messages.ImportJsonStoragePreparing);
  try (InputStream urlInputStream=url.openStream();ZipInputStream zipInputStream=new ZipInputStream(urlInputStream,StandardCharsets.UTF_8)){
    ObjectMapper mapper=new ObjectMapper();
    mapper.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);
    Map<String,Class> fileTypeMapping=new HashMap<>();
    fileTypeMapping.put(NFO,ExportInfoDTO.class);
    fileTypeMapping.put(PJT,ProjectDTO.class);
    TypeReference tr=new TypeReference<ArrayList<TestresultSummaryDTO>>(){
    }
;
    Map<String,Object> allDTOs=new HashMap<>();
    for (int i=0; i < 3; i++) {
      ZipEntry entry=zipInputStream.getNextEntry();
      String entryName=entry.getName();
      Class entryTypeMapping=fileTypeMapping.get(entryName);
      allDTOs.put(entryName,entryTypeMapping != null ? mapper.readValue(zipInputStream,entryTypeMapping) : mapper.readValue(zipInputStream,tr));
    }
    ExportInfoDTO exportDTO=(ExportInfoDTO)allDTOs.get(NFO);
    checkMinimumRequiredJSONVersion(exportDTO);
    ProjectDTO projectDTO=(ProjectDTO)allDTOs.get(PJT);
    if (projectExists(projectDTO)) {
      existProjectHandling(io,projectDTO);
      return null;
    }
    projectPO=load(projectDTO,subMonitor.newChild(1),io,assignNewGuid,paramNameMapper,compNameCache,false);
    JsonImporter importer=new JsonImporter(monitor,io,false);
    List<TestresultSummaryDTO> summaryDTOs=(List<TestresultSummaryDTO>)allDTOs.get(RST);
    importer.initTestResultSummaries(subMonitor.newChild(1),summaryDTOs,projectPO);
  }
 catch (  IOException e) {
    if (!monitor.isCanceled()) {
      log.info(Messages.GeneralIoExeption);
      throw new PMReadException(Messages.InvalidImportFile,MessageIDs.E_IO_EXCEPTION);
    }
  }
  return projectPO;
}",0.4895657078398195
95643,"/** 
 * Creates the instance of the persistent object which is defined by the XML element used as parameter. The method generates all dependent objects as well.
 * @param owner The ParamNode which holds this TDManager
 * @param xml Abstraction of the XML element (see Apache XML Beans)the test data, otherwise a new TDManager is created.
 * @return a persistent object generated from the information in the XMLelement
 * @param assignNewGuids <code>true</code> if the parameters were givennew unique IDs. Otherwise <code>false</code>.
 */
private ITDManager createTDManager(IParameterInterfacePO owner,TestData xml,boolean assignNewGuids){
  List<String> uniqueIds=new ArrayList<String>(xml.getUniqueIdsList());
  final ITDManager tdman;
  if (assignNewGuids) {
    List<String> newUniqueIds=new ArrayList<String>();
    for (    String id : uniqueIds) {
      if (Pattern.matches(""String_Node_Str"" + GUID_LENGTH + ""String_Node_Str"",id) && m_oldToNewGuids.containsKey(id)) {
        newUniqueIds.add(m_oldToNewGuids.get(id));
      }
 else {
        newUniqueIds.add(id);
      }
    }
    uniqueIds=newUniqueIds;
  }
  if (uniqueIds.isEmpty()) {
    tdman=PoMaker.createTDManagerPO(owner);
  }
 else {
    tdman=PoMaker.createTDManagerPO(owner,uniqueIds);
  }
  for (  TestDataRow rowXml : xml.getRowList()) {
    final List<String> td=new ArrayList<String>(rowXml.sizeOfDataArray());
    for (    TestDataCell cellXml : rowXml.getDataList()) {
      td.add(readData(cellXml,owner));
    }
    tdman.insertDataSet(PoMaker.createListWrapperPO(td),tdman.getDataSetCount());
  }
  return tdman;
}","/** 
 * Creates the instance of the persistent object which is defined by the XML element used as parameter. The method generates all dependent objects as well.
 * @param owner The ParamNode which holds this TDManager
 * @param xml Abstraction of the XML element (see Apache XML Beans)the test data, otherwise a new TDManager is created.
 * @return a persistent object generated from the information in the XMLelement
 * @param assignNewGuids <code>true</code> if the parameters were givennew unique IDs. Otherwise <code>false</code>.
 */
private ITDManager createTDManager(IParameterInterfacePO owner,TestData xml,boolean assignNewGuids){
  List<String> uniqueIds=new ArrayList<String>(xml.getUniqueIdsList());
  final ITDManager tdman;
  if (assignNewGuids) {
    List<String> newUniqueIds=new ArrayList<String>();
    for (    String id : uniqueIds) {
      if (Pattern.matches(""String_Node_Str"" + ImportExportUtil.UUID_LENGTH + ""String_Node_Str"",id) && m_oldToNewGuids.containsKey(id)) {
        newUniqueIds.add(m_oldToNewGuids.get(id));
      }
 else {
        newUniqueIds.add(id);
      }
    }
    uniqueIds=newUniqueIds;
  }
  if (uniqueIds.isEmpty()) {
    tdman=PoMaker.createTDManagerPO(owner);
  }
 else {
    tdman=PoMaker.createTDManagerPO(owner,uniqueIds);
  }
  for (  TestDataRow rowXml : xml.getRowList()) {
    final List<String> td=new ArrayList<String>(rowXml.sizeOfDataArray());
    for (    TestDataCell cellXml : rowXml.getDataList()) {
      td.add(readData(cellXml,owner));
    }
    tdman.insertDataSet(PoMaker.createListWrapperPO(td),tdman.getDataSetCount());
  }
  return tdman;
}",0.9940717628705148
95644,"/** 
 * Creates the instance of the persistent object which is defined by the XML element used as parameter. The method generates all dependent objects as well.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param xml Abstraction of the XML element (see Apache XML Beans)
 * @param assignNewGuid <code>true</code> if the testcase should be assigned a new GUID. Otherwise  <code>false</code>.
 * @param mapper mapper to resolve param names
 * @return a persistent object generated from the information in the XMLelement
 */
private ISpecTestCasePO createTestCaseBase(IProjectPO proj,TestCase xml,boolean assignNewGuid,IParamNameMapper mapper){
  ISpecTestCasePO tc;
  if (xml.getId() != null) {
    tc=NodeMaker.createSpecTestCasePO(xml.getName());
    m_tcRef.put(xml.getId(),tc);
  }
 else   if (assignNewGuid) {
    tc=NodeMaker.createSpecTestCasePO(xml.getName());
    m_tcRef.put(tc.getGuid(),tc);
    m_oldToNewGuids.put(xml.getGUID(),tc.getGuid());
  }
 else {
    tc=NodeMaker.createSpecTestCasePO(xml.getName(),xml.getGUID());
    m_tcRef.put(xml.getGUID(),tc);
  }
  tc.setComment(xml.getComment());
  tc.setDescription(xml.getDescription());
  tc.setGenerated(xml.getGenerated());
  tc.setTaskId(xml.getTaskId());
  tc.setInterfaceLocked(xml.getInterfaceLocked());
  tc.setDataFile(xml.getDatafile());
  fillTrackedChangesInformation(tc,xml);
  if (xml.getReferencedTestData() != null) {
    String referencedDataName=xml.getReferencedTestData();
    for (    IParameterInterfacePO testDataCube : TestDataCubeBP.getAllTestDataCubesFor(proj)) {
      if (referencedDataName.equals(testDataCube.getName())) {
        tc.setReferencedDataCube(testDataCube);
        break;
      }
    }
  }
  for (  ParamDescription pdXml : xml.getParameterDescriptionList()) {
    String uniqueId=pdXml.getUniqueId();
    if (assignNewGuid) {
      IParamDescriptionPO paramDesc=tc.addParameter(pdXml.getType(),pdXml.getName(),mapper);
      m_oldToNewGuids.put(uniqueId,paramDesc.getUniqueId());
    }
 else {
      if (uniqueId != null && Pattern.matches(""String_Node_Str"" + GUID_LENGTH + ""String_Node_Str"",uniqueId)) {
        tc.addParameter(pdXml.getType(),pdXml.getName(),uniqueId,mapper);
      }
 else {
        tc.addParameter(pdXml.getType(),pdXml.getName(),mapper);
      }
    }
  }
  tc.setDataManager(createTDManager(tc,xml.getTestdata(),assignNewGuid));
  return tc;
}","/** 
 * Creates the instance of the persistent object which is defined by the XML element used as parameter. The method generates all dependent objects as well.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param xml Abstraction of the XML element (see Apache XML Beans)
 * @param assignNewGuid <code>true</code> if the testcase should be assigned a new GUID. Otherwise  <code>false</code>.
 * @param mapper mapper to resolve param names
 * @return a persistent object generated from the information in the XMLelement
 */
private ISpecTestCasePO createTestCaseBase(IProjectPO proj,TestCase xml,boolean assignNewGuid,IParamNameMapper mapper){
  ISpecTestCasePO tc;
  if (xml.getId() != null) {
    tc=NodeMaker.createSpecTestCasePO(xml.getName());
    m_tcRef.put(xml.getId(),tc);
  }
 else   if (assignNewGuid) {
    tc=NodeMaker.createSpecTestCasePO(xml.getName());
    m_tcRef.put(tc.getGuid(),tc);
    m_oldToNewGuids.put(xml.getGUID(),tc.getGuid());
  }
 else {
    tc=NodeMaker.createSpecTestCasePO(xml.getName(),xml.getGUID());
    m_tcRef.put(xml.getGUID(),tc);
  }
  tc.setComment(xml.getComment());
  tc.setDescription(xml.getDescription());
  tc.setGenerated(xml.getGenerated());
  tc.setTaskId(xml.getTaskId());
  tc.setInterfaceLocked(xml.getInterfaceLocked());
  tc.setDataFile(xml.getDatafile());
  fillTrackedChangesInformation(tc,xml);
  if (xml.getReferencedTestData() != null) {
    String referencedDataName=xml.getReferencedTestData();
    for (    IParameterInterfacePO testDataCube : TestDataCubeBP.getAllTestDataCubesFor(proj)) {
      if (referencedDataName.equals(testDataCube.getName())) {
        tc.setReferencedDataCube(testDataCube);
        break;
      }
    }
  }
  for (  ParamDescription pdXml : xml.getParameterDescriptionList()) {
    String uniqueId=pdXml.getUniqueId();
    if (assignNewGuid) {
      IParamDescriptionPO paramDesc=tc.addParameter(pdXml.getType(),pdXml.getName(),mapper);
      m_oldToNewGuids.put(uniqueId,paramDesc.getUniqueId());
    }
 else {
      if (uniqueId != null && Pattern.matches(""String_Node_Str"" + ImportExportUtil.UUID_LENGTH + ""String_Node_Str"",uniqueId)) {
        tc.addParameter(pdXml.getType(),pdXml.getName(),uniqueId,mapper);
      }
 else {
        tc.addParameter(pdXml.getType(),pdXml.getName(),mapper);
      }
    }
  }
  tc.setDataManager(createTDManager(tc,xml.getTestdata(),assignNewGuid));
  return tc;
}",0.9962309065661576
95645,"/** 
 * Returns the valis staus of the node.<br> Normally all Nodes are valid. only CapPOs with an InvalidComponent should return false.
 * @return true if the Node is valid, false otherwise. 
 */
public boolean isValid();","/** 
 * Returns the valid status of the node.<br> Normally all Nodes are valid. only CapPOs with an InvalidComponent should return false.
 * @return true if the Node is valid, false otherwise. 
 */
public boolean isValid();",0.9752808988764043
95646,"/** 
 * @return the object responsible for maintaining the receiver's parameterinterface as well as test data.
 */
@ManyToOne(cascade=CascadeType.ALL,targetEntity=TestDataCubePO.class,fetch=FetchType.EAGER) @JoinColumn(name=""String_Node_Str"",unique=true) @BatchFetch(value=BatchFetchType.JOIN) private TestDataCubePO getParameterInterface(){
  return m_parameterInterface;
}","/** 
 * @return the object responsible for maintaining the receiver's parameterinterface as well as test data.
 */
@ManyToOne(cascade=CascadeType.ALL,targetEntity=TestDataCubePO.class,fetch=FetchType.EAGER) @JoinColumn(name=""String_Node_Str"",unique=true) private TestDataCubePO getParameterInterface(){
  return m_parameterInterface;
}",0.9449929478138224
95647,"@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle cellBounds=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeBounds=NodeBounds.getAbsoluteBounds(tree);
          int leftX;
          int cellWidth;
          Node disclosureNode=cell.getDisclosureNode();
          if (disclosureNode != null) {
            Rectangle closureNodeBounds=NodeBounds.getAbsoluteBounds(disclosureNode);
            leftX=((int)closureNodeBounds.getMaxX()) - treeBounds.x;
            cellWidth=(int)(cellBounds.getMaxX() - closureNodeBounds.getMaxX());
          }
 else {
            leftX=cellBounds.x - treeBounds.x;
            cellWidth=cellBounds.width;
          }
          int cellRelativeY=cellBounds.y - treeBounds.y;
          return new Rectangle(leftX,cellRelativeY,cellWidth,cellBounds.height);
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}","@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle b=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
          return new Rectangle(Math.abs(treeB.x - b.x),Math.abs(treeB.y - b.y),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}",0.7076683534449202
95648,"@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView tree=getTree();
      int index=tree.getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}","@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView<?> tree=getTree();
      int index=((TreeView)tree).getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}",0.9679218967921897
95649,"@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(treeB.getWidth()),Rounding.round(treeB.getHeight()));
      Rectangle intersection=rowBounds.intersection(visibleTreeBounds);
      if (intersection.isEmpty()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
      }
      return intersection;
    }
  }
);
  return result;
}","@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(tree.getWidth()),Rounding.round(tree.getHeight()));
      return rowBounds.intersection(visibleTreeBounds);
    }
  }
);
  return result;
}",0.6007905138339921
95650,"/** 
 * @param dto will be contained the test data manager infos
 * @param po data manager  
 */
private void fillTDManager(TDManagerDTO dto,ITDManager po){
  dto.setUniqueIds(po.getUniqueIds());
  for (  IDataSetPO dataSet : po.getDataSets()) {
    DataSetDTO dsDTO=new DataSetDTO();
    dsDTO.setColumns(dataSet.getColumns());
    dto.addDataSet(dsDTO);
  }
}","/** 
 * @param dto will be contained the test data manager infos
 * @param po data manager  
 */
private void fillTDManager(TDManagerDTO dto,ITDManager po){
  dto.setUniqueIds(po.getUniqueIds());
  for (  IDataSetPO dataSet : po.getDataSets()) {
    DataSetDTO dsDTO=new DataSetDTO();
    dsDTO.setColumns(dataSet.getColumnsCopy());
    dto.addDataSet(dsDTO);
  }
}",0.9944903581267218
95651,"/** 
 * Write the information from the Object to its corresponding XML element.
 * @param xml The XML element to be filled
 * @param po The persistent object which contains the information
 */
private void fillTestData(TestData xml,ITDManager po){
  for (  String uniqueId : po.getUniqueIds()) {
    xml.addUniqueIds(uniqueId);
  }
  int rowCnt=1;
  for (  IDataSetPO row : po.getDataSets()) {
    TestDataRow xmlRow=xml.addNewRow();
    xmlRow.setRowCount(rowCnt++);
    int colCnt=1;
    for (    String td : row.getColumns()) {
      TestDataCell xmlCell=xmlRow.addNewData();
      xmlCell.setColumnCount(colCnt++);
      xmlCell.setValue(td);
    }
  }
}","/** 
 * Write the information from the Object to its corresponding XML element.
 * @param xml The XML element to be filled
 * @param po The persistent object which contains the information
 */
private void fillTestData(TestData xml,ITDManager po){
  for (  String uniqueId : po.getUniqueIds()) {
    xml.addUniqueIds(uniqueId);
  }
  int rowCnt=1;
  for (  IDataSetPO row : po.getDataSets()) {
    TestDataRow xmlRow=xml.addNewRow();
    xmlRow.setRowCount(rowCnt++);
    for (int col=0; col < row.getColumnCount(); col++) {
      TestDataCell xmlCell=xmlRow.addNewData();
      xmlCell.setColumnCount(col + 1);
      xmlCell.setValue(row.getValueAt(col));
    }
  }
}",0.7782805429864253
95652,"/** 
 * This method is called if the Action of a CAP is not compatible with the current XML-Config-File.<br> The existent TDManager of the CAP is filled with the TestData
 * @param owner The CAP.
 * @param xmlCap The abstraction of the XML CAP (see Apache XML Beans)
 * @return the filled TDManager of the given owner
 */
private ITDManager fillTDManager(IParamNodePO owner,Cap xmlCap){
  final ITDManager tdman=owner.getDataManager();
  List<ParamDescription> parDescList=xmlCap.getParameterDescriptionList();
  final TestData testData=xmlCap.getTestdata();
  int tdRow=0;
  for (  TestDataRow rowXml : testData.getRowList()) {
    if (rowXml.getDataList().isEmpty()) {
      continue;
    }
    List<String> tdList=null;
    try {
      tdList=tdman.getDataSet(tdRow).getColumns();
    }
 catch (    IndexOutOfBoundsException ioobe) {
      final StringBuilder msgSb=new StringBuilder();
      msgSb.append(Messages.Component);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(xmlCap.getComponentType());
      msgSb.append(StringConstants.NEWLINE + Messages.Action);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(xmlCap.getActionName(),true));
      msgSb.append(StringConstants.NEWLINE + Messages.Parameter);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(parDescList.get(tdRow).getName(),true));
      final String msg=msgSb.toString();
      log.error(msg,ioobe);
      continue;
    }
    int tdCell=0;
    for (    TestDataCell cellXml : rowXml.getDataList()) {
      String uniqueId=parDescList.get(tdCell).getUniqueId();
      final int ownerIndex=owner.getDataManager().findColumnForParam(uniqueId);
      if (ownerIndex > -1) {
        tdList.set(ownerIndex,readData(cellXml,owner));
      }
      tdCell++;
    }
    tdman.clear();
    tdman.insertDataSet(PoMaker.createListWrapperPO(tdList),tdRow);
    tdRow++;
  }
  return tdman;
}","/** 
 * This method is called if the Action of a CAP is not compatible with the current XML-Config-File.<br> The existent TDManager of the CAP is filled with the TestData
 * @param owner The CAP.
 * @param xmlCap The abstraction of the XML CAP (see Apache XML Beans)
 * @return the filled TDManager of the given owner
 */
private ITDManager fillTDManager(IParamNodePO owner,Cap xmlCap){
  final ITDManager tdman=owner.getDataManager();
  List<ParamDescription> parDescList=xmlCap.getParameterDescriptionList();
  final TestData testData=xmlCap.getTestdata();
  int tdRow=0;
  for (  TestDataRow rowXml : testData.getRowList()) {
    if (rowXml.getDataList().isEmpty()) {
      continue;
    }
    List<String> tdList=null;
    try {
      tdList=tdman.getDataSet(tdRow).getColumnsCopy();
    }
 catch (    IndexOutOfBoundsException ioobe) {
      final StringBuilder msgSb=new StringBuilder();
      msgSb.append(Messages.Component);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(xmlCap.getComponentType());
      msgSb.append(StringConstants.NEWLINE + Messages.Action);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(xmlCap.getActionName(),true));
      msgSb.append(StringConstants.NEWLINE + Messages.Parameter);
      msgSb.append(StringConstants.COLON + StringConstants.SPACE);
      msgSb.append(CompSystemI18n.getString(parDescList.get(tdRow).getName(),true));
      final String msg=msgSb.toString();
      log.error(msg,ioobe);
      continue;
    }
    int tdCell=0;
    for (    TestDataCell cellXml : rowXml.getDataList()) {
      String uniqueId=parDescList.get(tdCell).getUniqueId();
      final int ownerIndex=owner.getDataManager().findColumnForParam(uniqueId);
      if (ownerIndex > -1) {
        tdList.set(ownerIndex,readData(cellXml,owner));
      }
      tdCell++;
    }
    tdman.clear();
    tdman.insertDataSet(PoMaker.createListWrapperPO(tdList),tdRow);
    tdRow++;
  }
  return tdman;
}",0.9990074441687344
95653,"/** 
 * {@inheritDoc} 
 */
public void addColumn(String value){
  getColumns().add(value);
}","/** 
 * {@inheritDoc} 
 */
public void addColumn(String value){
  getColumns().add(StringUtils.defaultIfEmpty(value,StringConstants.UNICODE_NULL));
}",0.7634854771784232
95654,"/** 
 * {@inheritDoc} 
 */
public void setValueAt(int column,String value){
  getColumns().set(column,value);
}","/** 
 * {@inheritDoc} 
 */
public void setValueAt(int column,String value){
  getColumns().set(column,StringUtils.defaultIfEmpty(value,StringConstants.UNICODE_NULL));
}",0.7956989247311828
95655,"/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.JOIN) public List<String> getColumns(){
  return m_columns;
}","/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.JOIN) private List<String> getColumns(){
  return m_columns;
}",0.98379970544919
95656,"/** 
 * {@inheritDoc} 
 */
public String getValueAt(int column){
  return getColumns().get(column);
}","/** 
 * {@inheritDoc} 
 */
public String getValueAt(int column){
  String value=getColumns().get(column);
  if (StringConstants.UNICODE_NULL.equals(value)) {
    return null;
  }
  return value;
}",0.6464646464646465
95657,"/** 
 * @param references The references
 * @param row The row representation
 * @param dataSetRow The row index
 */
private void addParamReferences(List<TDCell> references,IDataSetPO row,int dataSetRow){
  int col=0;
  for (  String testData : row.getColumns()) {
    String uniqueId=getDataManager().getUniqueIds().get(col);
    IParamDescriptionPO desc=getParameterForUniqueId(uniqueId);
    ParamValueConverter conv=new ModelParamValueConverter(testData,this,desc);
    if (conv.containsReferences()) {
      references.add(new TDCell(testData,dataSetRow,col));
    }
    col++;
  }
}","/** 
 * @param references The references
 * @param row The row representation
 * @param dataSetRow The row index
 */
private void addParamReferences(List<TDCell> references,IDataSetPO row,int dataSetRow){
  for (int col=0; col < row.getColumnCount(); col++) {
    String testData=row.getValueAt(col);
    String uniqueId=getDataManager().getUniqueIds().get(col);
    IParamDescriptionPO desc=getParameterForUniqueId(uniqueId);
    ParamValueConverter conv=new ModelParamValueConverter(testData,this,desc);
    if (conv.containsReferences()) {
      references.add(new TDCell(testData,dataSetRow,col));
    }
    col++;
  }
}",0.9323432343234324
95658,"/** 
 * @return The number of columns
 */
@Transient public int getColumnCount(){
  int columns=0;
  try {
    List<IDataSetPO> dataTable=getDataTable();
    if (dataTable.size() > 0) {
      IDataSetPO listW=dataTable.get(0);
      columns=listW.getColumns().size();
    }
  }
 catch (  IndexOutOfBoundsException e) {
  }
  return columns;
}","/** 
 * @return The number of columns
 */
@Transient public int getColumnCount(){
  int columns=0;
  try {
    List<IDataSetPO> dataTable=getDataTable();
    if (dataTable.size() > 0) {
      IDataSetPO listW=dataTable.get(0);
      columns=listW.getColumnCount();
    }
  }
 catch (  IndexOutOfBoundsException e) {
  }
  return columns;
}",0.9809104258443464
95659,"/** 
 * Copies the data of this TDManager to the given TDManager
 * @param tdMan the TDManager to copy the data to
 * @return the given TDManager with the new data.
 */
public ITDManager deepCopy(ITDManager tdMan){
  for (  String uniqueId : getUniqueIds()) {
    tdMan.addUniqueId(uniqueId);
  }
  tdMan.clear();
  for (  IDataSetPO dataSet : getDataSets()) {
    List<String> newRow=new ArrayList<String>(dataSet.getColumnCount());
    for (    String testData : dataSet.getColumns()) {
      newRow.add(testData);
    }
    tdMan.insertDataSet(PoMaker.createListWrapperPO(newRow),tdMan.getDataSetCount());
  }
  return tdMan;
}","/** 
 * Copies the data of this TDManager to the given TDManager
 * @param tdMan the TDManager to copy the data to
 * @return the given TDManager with the new data.
 */
public ITDManager deepCopy(ITDManager tdMan){
  for (  String uniqueId : getUniqueIds()) {
    tdMan.addUniqueId(uniqueId);
  }
  tdMan.clear();
  for (  IDataSetPO dataSet : getDataSets()) {
    int columncount=dataSet.getColumnCount();
    List<String> newRow=new ArrayList<String>(columncount);
    for (int i=0; i < columncount; i++) {
      newRow.add(dataSet.getValueAt(i));
    }
    tdMan.insertDataSet(PoMaker.createListWrapperPO(newRow),tdMan.getDataSetCount());
  }
  return tdMan;
}",0.8754833720030936
95660,"/** 
 * Line-feeds the given String array at \n
 * @param strArray the string to line feed
 * @return the line feeded strings as an array
 */
private static String[] lineFeed(String[] strArray){
  List<String> strList=new ArrayList<String>();
  for (  String str : strArray) {
    StringTokenizer tok=new StringTokenizer(str,StringConstants.NEWLINE);
    while (tok.hasMoreElements()) {
      strList.add(tok.nextToken());
    }
  }
  return strList.toArray(new String[strList.size()]);
}","/** 
 * Line-feeds the given String array at \n
 * @param strArray the string to line feed
 * @return the line feeded strings as an array
 */
private static String[] lineFeed(String[] strArray){
  List<String> strList=new ArrayList<String>();
  for (  String str : strArray) {
    if (str != null) {
      StringTokenizer tok=new StringTokenizer(str,StringConstants.NEWLINE);
      while (tok.hasMoreElements()) {
        strList.add(tok.nextToken());
      }
    }
  }
  return strList.toArray(new String[strList.size()]);
}",0.9634748272458046
95661,"@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle b=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
          return new Rectangle(Math.abs(treeB.x - b.x),Math.abs(treeB.y - b.y),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}","@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle cellBounds=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeBounds=NodeBounds.getAbsoluteBounds(tree);
          int leftX;
          int cellWidth;
          Node disclosureNode=cell.getDisclosureNode();
          if (disclosureNode != null) {
            Rectangle closureNodeBounds=NodeBounds.getAbsoluteBounds(disclosureNode);
            leftX=((int)closureNodeBounds.getMaxX()) - treeBounds.x;
            cellWidth=(int)(cellBounds.getMaxX() - closureNodeBounds.getMaxX());
          }
 else {
            leftX=cellBounds.x - treeBounds.x;
            cellWidth=cellBounds.width;
          }
          int cellRelativeY=cellBounds.y - treeBounds.y;
          return new Rectangle(leftX,cellRelativeY,cellWidth,cellBounds.height);
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}",0.7084468664850136
95662,"@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView<?> tree=getTree();
      int index=((TreeView)tree).getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}","@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView tree=getTree();
      int index=tree.getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}",0.9679218967921897
95663,"@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(tree.getWidth()),Rounding.round(tree.getHeight()));
      return rowBounds.intersection(visibleTreeBounds);
    }
  }
);
  return result;
}","@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(treeB.getWidth()),Rounding.round(treeB.getHeight()));
      Rectangle intersection=rowBounds.intersection(visibleTreeBounds);
      if (intersection.isEmpty()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
      }
      return intersection;
    }
  }
);
  return result;
}",0.7462450592885376
95664,"/** 
 * updates the modelString after substitution of guids in references
 */
private void updateModelString(){
  StringBuilder builder=new StringBuilder();
  String oldModelString=getModelString();
  for (  IParamValueToken token : getTokens()) {
    builder.append(token.getModelString());
  }
  setModelString(builder.toString());
  for (  IDataSetPO dataSet : getCurrentNode().getDataManager().getDataSets()) {
    for (int i=0; i < dataSet.getColumnCount(); i++) {
      if (dataSet.getValueAt(i).equals(oldModelString)) {
        dataSet.setValueAt(i,getModelString());
        return;
      }
    }
  }
}","/** 
 * updates the modelString after substitution of guids in references
 */
private void updateModelString(){
  StringBuilder builder=new StringBuilder();
  String oldModelString=getModelString();
  for (  IParamValueToken token : getTokens()) {
    builder.append(token.getModelString());
  }
  setModelString(builder.toString());
  for (  IDataSetPO dataSet : getCurrentNode().getDataManager().getDataSets()) {
    for (int i=0; i < dataSet.getColumnCount(); i++) {
      String data=dataSet.getValueAt(i);
      if (data != null && data.equals(oldModelString)) {
        dataSet.setValueAt(i,getModelString());
        return;
      }
    }
  }
}",0.8716323296354992
95665,"/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.JOIN) public List<String> getColumns(){
  return m_columns;
}","/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.EXISTS) public List<String> getColumns(){
  return m_columns;
}",0.9882352941176472
95666,"@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle b=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
          return new Rectangle(Math.abs(treeB.x - b.x),Math.abs(treeB.y - b.y),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}","@Override public Rectangle getNodeBounds(final TreeItem<?> node){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      List<? extends TreeCell> tCells=NodeTraverseHelper.getInstancesOf(tree,TreeCell.class);
      for (      TreeCell<?> cell : tCells) {
        TreeItem<?> item=cell.getTreeItem();
        if (NodeTraverseHelper.isVisible(cell) && (item != null && item.equals(node))) {
          Rectangle cellBounds=NodeBounds.getAbsoluteBounds(cell);
          Rectangle treeBounds=NodeBounds.getAbsoluteBounds(tree);
          int leftX;
          int cellWidth;
          Node disclosureNode=cell.getDisclosureNode();
          if (disclosureNode != null) {
            Rectangle closureNodeBounds=NodeBounds.getAbsoluteBounds(disclosureNode);
            leftX=((int)closureNodeBounds.getMaxX()) - treeBounds.x;
            cellWidth=(int)(cellBounds.getMaxX() - closureNodeBounds.getMaxX());
          }
 else {
            leftX=cellBounds.x - treeBounds.x;
            cellWidth=cellBounds.width;
          }
          int cellRelativeY=cellBounds.y - treeBounds.y;
          return new Rectangle(leftX,cellRelativeY,cellWidth,cellBounds.height);
        }
      }
      return null;
    }
  }
);
  if (result == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
  }
  return result;
}",0.7084468664850136
95667,"@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView<?> tree=getTree();
      int index=((TreeView)tree).getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}","@Override public void scrollNodeToVisible(final TreeItem<?> node){
  EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
    @Override public Void call() throws Exception {
      TreeView tree=getTree();
      int index=tree.getRow(node);
      tree.scrollTo(index);
      tree.layout();
      return null;
    }
  }
);
}",0.9679218967921897
95668,"@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(tree.getWidth()),Rounding.round(tree.getHeight()));
      return rowBounds.intersection(visibleTreeBounds);
    }
  }
);
  return result;
}","@Override public Rectangle getVisibleRowBounds(final Rectangle rowBounds){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TreeView<?> tree=getTree();
      tree.layout();
      Rectangle treeB=NodeBounds.getAbsoluteBounds(tree);
      Rectangle visibleTreeBounds=new Rectangle(0,0,Rounding.round(treeB.getWidth()),Rounding.round(treeB.getHeight()));
      Rectangle intersection=rowBounds.intersection(visibleTreeBounds);
      if (intersection.isEmpty()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_VISIBLE));
      }
      return intersection;
    }
  }
);
  return result;
}",0.7462450592885376
95669,"@Override protected void startTasks() throws ExceptionInInitializerError, InvocationTargetException, NoSuchMethodException {
  addToolKitEventListenerToAUT();
  invokeAUT();
}","@Override protected void startTasks() throws ExceptionInInitializerError, InvocationTargetException, NoSuchMethodException {
  addToolKitEventListenerToAUT();
  invokeAUT();
  long start=System.currentTimeMillis();
  while (!checkInitialization() || ((System.currentTimeMillis() - start) < TOOLKIT_INITIALIZED_TIMEOUT)) {
    try {
      Thread.sleep(50);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.5972696245733788
95670,"/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=null;
  try {
    result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
      @Override public Stage call() throws Exception {
        List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
        for (        final Stage stage : stages) {
          if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
            return stage;
          }
        }
        return null;
      }
    }
);
  }
 catch (  IllegalStateException e) {
  }
  return result;
}","/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
    @Override public Stage call() throws Exception {
      List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
      for (      final Stage stage : stages) {
        if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
          return stage;
        }
      }
      return null;
    }
  }
);
  return result;
}",0.919205298013245
95671,"/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isFocused()) {
        stage.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.focusedProperty().removeListener(focusListener);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isFocused();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  final Stage stage=getStageByTitle(title,operator);
  if (stage == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isFocused()) {
        stage.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.focusedProperty().removeListener(focusListener);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isFocused();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}",0.9117442668519804
95672,"@Override protected void startTasks() throws ExceptionInInitializerError, InvocationTargetException, NoSuchMethodException {
  addToolKitEventListenerToAUT();
  invokeAUT();
  long start=System.currentTimeMillis();
  while (!checkInitialization() || ((System.currentTimeMillis() - start) < TOOLKIT_INITIALIZED_TIMEOUT)) {
    try {
      Thread.sleep(50);
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override protected void startTasks() throws ExceptionInInitializerError, InvocationTargetException, NoSuchMethodException {
  addToolKitEventListenerToAUT();
  invokeAUT();
}",0.5972696245733788
95673,"/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
    @Override public Stage call() throws Exception {
      List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
      for (      final Stage stage : stages) {
        if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
          return stage;
        }
      }
      return null;
    }
  }
);
  return result;
}","/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=null;
  try {
    result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
      @Override public Stage call() throws Exception {
        List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
        for (        final Stage stage : stages) {
          if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
            return stage;
          }
        }
        return null;
      }
    }
);
  }
 catch (  IllegalStateException e) {
  }
  return result;
}",0.9390728476821192
95674,"/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  final Stage stage=getStageByTitle(title,operator);
  if (stage == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isFocused()) {
        stage.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.focusedProperty().removeListener(focusListener);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isFocused();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isFocused()) {
        stage.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.focusedProperty().removeListener(focusListener);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isFocused();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}",0.9117442668519804
95675,"/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
    @Override public Stage call() throws Exception {
      List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
      for (      final Stage stage : stages) {
        if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
          return stage;
        }
      }
      return null;
    }
  }
);
  return result;
}","/** 
 * Looks through the Hierarchy for a Stage with a given Title.
 * @param title the Title of the Stage to look for
 * @param operator the operator
 * @return the Stage or null
 */
private Stage getStageByTitle(final String title,final String operator){
  Stage result=null;
  try {
    result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Stage>(){
      @Override public Stage call() throws Exception {
        List<? extends Stage> stages=ComponentHandler.getAssignableFrom(Stage.class);
        for (        final Stage stage : stages) {
          if (MatchUtil.getInstance().match(stage.getTitle(),title,operator)) {
            return stage;
          }
        }
        return null;
      }
    }
);
  }
 catch (  IllegalStateException e) {
  }
  return result;
}",0.9390728476821192
95676,"/** 
 * Waits <code>timeMillSec</code> if the application opens a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is shown
 */
public void rcWaitForWindow(final String title,String operator,int pTimeout,int delay){
  final Stage s=getStageByTitle(title,operator);
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.COMP_NOT_FOUND));
  }
  final CountDownLatch signal=new CountDownLatch(1);
  final EventHandler<WindowEvent> showHandler=new EventHandler<WindowEvent>(){
    @Override public void handle(    WindowEvent event){
      signal.countDown();
    }
  }
;
  boolean isShowing=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!s.isShowing()) {
        s.addEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
        return false;
      }
      return true;
    }
  }
);
  if (!isShowing) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      s.removeEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return s.isShowing();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * Waits <code>timeMillSec</code> if the application opens a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is shown
 */
public void rcWaitForWindow(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.COMP_NOT_FOUND));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final EventHandler<WindowEvent> showHandler=new EventHandler<WindowEvent>(){
    @Override public void handle(    WindowEvent event){
      signal.countDown();
    }
  }
;
  boolean isShowing=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isShowing()) {
        stage.addEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
        return false;
      }
      return true;
    }
  }
);
  if (!isShowing) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.removeEventFilter(WindowEvent.WINDOW_SHOWN,showHandler);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isShowing();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}",0.9057988744800588
95677,"/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  final Stage s=getStageByTitle(title,operator);
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!s.isFocused()) {
        s.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      s.focusedProperty().removeListener(focusListener);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return s.isFocused();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * Waits <code>timeMillSec</code> if the application activates a window with the given title.
 * @param title the title
 * @param operator the comparing operator
 * @param pTimeout the time in ms
 * @param delay delay after the window is activated
 */
public void rcWaitForWindowActivation(final String title,String operator,int pTimeout,int delay){
  Stage s=null;
  try {
    long timeout=pTimeout;
    long done=System.currentTimeMillis() + timeout;
    long now;
    do {
      s=getStageByTitle(title,operator);
      now=System.currentTimeMillis();
      timeout=done - now;
      Thread.sleep(50);
    }
 while (timeout > 0 && s == null);
  }
 catch (  InterruptedException e) {
    throw new RobotException(e);
  }
  if (s == null) {
    log.error(""String_Node_Str"" + title + ""String_Node_Str""+ operator);
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
  }
  final Stage stage=s;
  final CountDownLatch signal=new CountDownLatch(1);
  final ChangeListener<Boolean> focusListener=new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> observable,    Boolean oldValue,    Boolean newValue){
      if (newValue) {
        signal.countDown();
      }
    }
  }
;
  boolean isFocused=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      if (!stage.isFocused()) {
        stage.focusedProperty().addListener(focusListener);
        return false;
      }
      return true;
    }
  }
);
  if (isFocused) {
    try {
      signal.await(pTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR));
    }
 finally {
      stage.focusedProperty().removeListener(focusListener);
    }
    boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return stage.isFocused();
      }
    }
);
    if (!result) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.TIMEOUT_EXPIRED));
    }
  }
  TimeUtil.delay(delay);
}",0.910319124155602
95678,"/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.EXISTS) public List<String> getColumns(){
  return m_columns;
}","/** 
 * @return the columns
 */
@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name=""String_Node_Str"") @Column(name=""String_Node_Str"",length=MAX_STRING_LENGTH) @OrderColumn(name=""String_Node_Str"") @JoinColumn(name=""String_Node_Str"") @BatchFetch(value=BatchFetchType.JOIN) public List<String> getColumns(){
  return m_columns;
}",0.9882352941176472
95679,"/** 
 * Invokes the specified Method
 * @param variableName name of the variable of the cap. This isn't used.
 * @param fqcn Fully qualified class name
 * @param name name of the Method
 * @param timeout the timeout
 * @return returns the string representation of the return value of theinvoked method
 */
public String rcInvokeMethodStoreReturn(final String variableName,final String fqcn,final String name,int timeout){
  try {
    Object result=m_threadQueuer.invokeAndWait(""String_Node_Str"",createCallable(fqcn,name),timeout);
    return result.toString();
  }
 catch (  TimeoutException e) {
    throw new StepExecutionException(e.toString(),EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT));
  }
}","/** 
 * Invokes the specified Method
 * @param variableName name of the variable of the cap. This isn't used.
 * @param fqcn Fully qualified class name
 * @param name name of the Method
 * @param timeout the timeout
 * @return returns the string representation of the return value of theinvoked method
 */
public String rcInvokeMethodStoreReturn(final String variableName,final String fqcn,final String name,int timeout){
  try {
    Object result=m_threadQueuer.invokeAndWait(""String_Node_Str"",createCallable(fqcn,name),timeout);
    return result == null ? StringConstants.NULL : result.toString();
  }
 catch (  TimeoutException e) {
    throw new StepExecutionException(e.toString(),EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT));
  }
}",0.973045822102426
95680,"/** 
 * Invokes the specified Method
 * @param variableName name of the variable of the cap. This isn't used.
 * @param fqcn Fully qualified class name
 * @param name name of the Method
 * @param timeout the timeout
 * @return returns the string representation of the return value of theinvoked method
 */
public String rcInvokeMethodStoreReturn(final String variableName,final String fqcn,final String name,int timeout){
  IRobotFactory factory=getComponent().getRobotFactory();
  IEventThreadQueuer queuer=factory.getEventThreadQueuer();
  try {
    Object result=queuer.invokeAndWait(""String_Node_Str"",createCallable(fqcn,name),timeout);
    return result.toString();
  }
 catch (  TimeoutException e) {
    throw new StepExecutionException(e.toString(),EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT));
  }
}","/** 
 * Invokes the specified Method
 * @param variableName name of the variable of the cap. This isn't used.
 * @param fqcn Fully qualified class name
 * @param name name of the Method
 * @param timeout the timeout
 * @return returns the string representation of the return value of theinvoked method
 */
public String rcInvokeMethodStoreReturn(final String variableName,final String fqcn,final String name,int timeout){
  IRobotFactory factory=getComponent().getRobotFactory();
  IEventThreadQueuer queuer=factory.getEventThreadQueuer();
  try {
    Object result=queuer.invokeAndWait(""String_Node_Str"",createCallable(fqcn,name),timeout);
    return result == null ? StringConstants.NULL : result.toString();
  }
 catch (  TimeoutException e) {
    throw new StepExecutionException(e.toString(),EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT));
  }
}",0.976525821596244
95681,"/** 
 * Throws the appropriate StepExecutionException for a given exception which occurred during the method invocation
 * @param e the occurred exception
 */
public static void handleException(Throwable e){
  if (e instanceof InvocationTargetException) {
    Throwable cause=e.getCause();
    if (cause instanceof IllegalStateException) {
      throw new StepExecutionException(e.toString(),EventFactory.createVerifyFailed(""String_Node_Str"",cause.toString()));
    }
    throw new StepExecutionException(cause.toString(),EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR,new String[]{cause.toString()}));
  }
  throw new StepExecutionException(e.toString(),EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR,new String[]{e.toString()}));
}","/** 
 * Throws the appropriate StepExecutionException for a given exception which occurred during the method invocation
 * @param e the occurred exception
 */
public static void handleException(Throwable e){
  if (e instanceof InvocationTargetException) {
    Throwable cause=e.getCause();
    if (cause instanceof IllegalStateException) {
      throw new StepExecutionException(e.toString(),EventFactory.createVerifyFailed(""String_Node_Str"",cause.toString()));
    }
    throw new StepExecutionException(cause.toString(),EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR,new String[]{cause.toString()}));
  }
  if (e instanceof NullPointerException) {
    log.warn(""String_Node_Str"",e);
    throw new StepExecutionException(e.toString(),EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR,new String[]{""String_Node_Str""}));
  }
  throw new StepExecutionException(e.toString(),EventFactory.createActionError(TestErrorEvent.EXECUTION_ERROR,new String[]{e.toString()}));
}",0.8558404558404559
95682,"/** 
 * updates the modelString after substitution of guids in references
 */
private void updateModelString(){
  StringBuilder builder=new StringBuilder();
  for (  IParamValueToken token : getTokens()) {
    builder.append(token.getModelString());
  }
  setModelString(builder.toString());
}","/** 
 * updates the modelString after substitution of guids in references
 */
private void updateModelString(){
  StringBuilder builder=new StringBuilder();
  String oldModelString=getModelString();
  for (  IParamValueToken token : getTokens()) {
    builder.append(token.getModelString());
  }
  setModelString(builder.toString());
  for (  IDataSetPO dataSet : getCurrentNode().getDataManager().getDataSets()) {
    for (int i=0; i < dataSet.getColumnCount(); i++) {
      if (dataSet.getValueAt(i).equals(oldModelString)) {
        dataSet.setValueAt(i,getModelString());
        return;
      }
    }
  }
}",0.6482300884955752
95683,"/** 
 * Creates a Checkbox for the given monitoring composite,  which was specified in the extension point.     * 
 * @param composite The composite to add the widget on
 * @param att The current attribute
 */
private void createMonitoringCheckBoxWidget(Composite composite,final MonitoringAttribute att){
  final String autId=getConfigValue(AutConfigConstants.AUT_ID);
  final Button b=UIComponentHelper.createToggleButton(composite,1);
  b.setData(MonitoringConstants.MONITORING_KEY,att.getId());
  b.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent event){
      showMonitoringInfoDialog(autId);
      putConfigValue(att.getId(),String.valueOf(b.getSelection()));
    }
  }
);
}","/** 
 * Creates a Checkbox for the given monitoring composite,  which was specified in the extension point.     * 
 * @param composite The composite to add the widget on
 * @param att The current attribute
 */
private void createMonitoringCheckBoxWidget(Composite composite,final MonitoringAttribute att){
  final String autId=getConfigValue(AutConfigConstants.AUT_ID);
  final Button b=UIComponentHelper.createToggleButton(composite,1);
  b.setData(MonitoringConstants.MONITORING_KEY,att.getId());
  if (Boolean.parseBoolean(getConfigValue(att.getId()))) {
    b.setSelection(true);
  }
  b.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent event){
      showMonitoringInfoDialog(autId);
      putConfigValue(att.getId(),String.valueOf(b.getSelection()));
    }
  }
);
}",0.9423201555411536
95684,"/** 
 * Returns the components with the specified typeName.
 * @param typeName Name of the specified component.
 * @return the specified Components.
 */
public List<ConcreteComponent> findComponents(String typeName){
  Validate.notNull(typeName);
  List<ConcreteComponent> list=getComponents();
  List<ConcreteComponent> comps=new LinkedList<ConcreteComponent>();
  for (  ConcreteComponent cc : list) {
    if (cc.getComponentClass() != null && cc.getComponentClass().getName().equals(typeName)) {
      comps.add(cc);
    }
  }
  if (!(comps.isEmpty())) {
    return comps;
  }
  String message=""String_Node_Str"" + typeName + ""String_Node_Str"";
  log.error(message);
  throw new ConfigXmlException(message,MessageIDs.E_NO_COMPONENT);
}","/** 
 * Returns the components with the specified typeName.
 * @param typeName Name of the specified component.
 * @return the specified Components.
 */
public List<ConcreteComponent> findComponents(String typeName){
  Validate.notNull(typeName);
  Set<ConcreteComponent> list=getComponents();
  List<ConcreteComponent> comps=new LinkedList<ConcreteComponent>();
  for (  ConcreteComponent cc : list) {
    if (cc.getComponentClass() != null && cc.getComponentClass().getName().equals(typeName)) {
      comps.add(cc);
    }
  }
  if (!(comps.isEmpty())) {
    return comps;
  }
  String message=""String_Node_Str"" + typeName + ""String_Node_Str"";
  log.error(message);
  throw new ConfigXmlException(message,MessageIDs.E_NO_COMPONENT);
}",0.9966055668703326
95685,"/** 
 * Returns the component with the specified typeName.
 * @param typeName Name of the specified component.
 * @return the specified Component.
 */
public Component findComponent(String typeName){
  Validate.notNull(typeName);
  List<ConcreteComponent> list=getComponents();
  for (  ConcreteComponent cc : list) {
    if (cc.getComponentClass() != null && cc.getComponentClass().getName().equals(typeName)) {
      return cc;
    }
  }
  String message=""String_Node_Str"" + typeName + ""String_Node_Str"";
  log.error(message);
  throw new ConfigXmlException(message,MessageIDs.E_NO_COMPONENT);
}","/** 
 * Returns the component with the specified typeName.
 * @param typeName Name of the specified component.
 * @return the specified Component.
 */
public Component findComponent(String typeName){
  Validate.notNull(typeName);
  Set<ConcreteComponent> list=getComponents();
  for (  ConcreteComponent cc : list) {
    if (cc.getComponentClass() != null && cc.getComponentClass().getName().equals(typeName)) {
      return cc;
    }
  }
  String message=""String_Node_Str"" + typeName + ""String_Node_Str"";
  log.error(message);
  throw new ConfigXmlException(message,MessageIDs.E_NO_COMPONENT);
}",0.9958088851634534
95686,"/** 
 * @return Returns the components.
 */
public List<ConcreteComponent> getComponents(){
  return m_components;
}","/** 
 * @return Returns the components.
 */
public Set<ConcreteComponent> getComponents(){
  return m_components;
}",0.9783549783549784
95687,"/** 
 * private constructor (singleton) <br> initializes the cache 
 */
private AUTServerConfiguration(){
  m_implClassNames=new HashMap<String,String>();
  m_implClassCache=new HashMap();
  m_components=new ArrayList<ConcreteComponent>();
}","/** 
 * private constructor (singleton) <br> initializes the cache 
 */
private AUTServerConfiguration(){
  m_implClassNames=new HashMap<String,String>();
  m_implClassCache=new HashMap();
  m_components=new HashSet<ConcreteComponent>();
}",0.9708333333333332
95688,"/** 
 * @return a set of supported type identifier
 */
public Set<ComponentClass> getSupportedTypes(){
  if (m_supportedComponentTypes != null) {
    return m_supportedComponentTypes;
  }
  m_supportedComponentTypes=new HashSet<ComponentClass>();
  List<ConcreteComponent> supportedComponents=AUTServerConfiguration.getInstance().getComponents();
  Iterator<ConcreteComponent> iterator=supportedComponents.iterator();
  while (iterator.hasNext()) {
    ConcreteComponent c=iterator.next();
    if (!c.hasDefaultMapping()) {
      List ccl=c.getCompClass();
      Iterator compClassIterator=ccl.iterator();
      while (compClassIterator.hasNext()) {
        ComponentClass cc=(ComponentClass)compClassIterator.next();
        m_supportedComponentTypes.add(cc);
      }
    }
  }
  return m_supportedComponentTypes;
}","/** 
 * @return a set of supported type identifier
 */
public Set<ComponentClass> getSupportedTypes(){
  if (m_supportedComponentTypes != null) {
    return m_supportedComponentTypes;
  }
  m_supportedComponentTypes=new HashSet<ComponentClass>();
  Set<ConcreteComponent> supportedComponents=AUTServerConfiguration.getInstance().getComponents();
  Iterator<ConcreteComponent> iterator=supportedComponents.iterator();
  while (iterator.hasNext()) {
    ConcreteComponent c=iterator.next();
    if (!c.hasDefaultMapping()) {
      List ccl=c.getCompClass();
      Iterator compClassIterator=ccl.iterator();
      while (compClassIterator.hasNext()) {
        ComponentClass cc=(ComponentClass)compClassIterator.next();
        m_supportedComponentTypes.add(cc);
      }
    }
  }
  return m_supportedComponentTypes;
}",0.996934396076027
95689,"/** 
 * @param xml XML storage for the project
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise  <code>false</code>.
 * @return a new IProjectPO
 */
private IProjectPO initProject(Project xml,boolean assignNewGuid){
  IProjectPO proj=null;
  if (xml.getGUID() != null) {
    Integer majorProjVersion=null;
    if (!xml.isNilMajorProjectVersion() && xml.isSetMajorProjectVersion() || xml.isSetMajorNumber()) {
      majorProjVersion=xml.isSetMajorNumber() ? xml.getMajorNumber() : xml.getMajorProjectVersion();
    }
    Integer minorProjVersion=null;
    if (!xml.isNilMinorProjectVersion() && xml.isSetMinorProjectVersion() || xml.isSetMinorNumber()) {
      minorProjVersion=xml.isSetMinorNumber() ? xml.getMinorNumber() : xml.getMinorProjectVersion();
    }
    Integer microProjVersion=!xml.isSetMicroProjectVersion() || xml.isNilMicroProjectVersion() ? null : xml.getMicroProjectVersion();
    String postFixProjVersion=!xml.isSetProjectVersionQualifier() || xml.isNilProjectVersionQualifier() ? null : xml.getProjectVersionQualifier();
    if (!assignNewGuid) {
      proj=NodeMaker.createProjectPO(IVersion.JB_CLIENT_METADATA_VERSION,majorProjVersion,minorProjVersion,microProjVersion,postFixProjVersion,xml.getGUID());
    }
 else {
      proj=NodeMaker.createProjectPO(IVersion.JB_CLIENT_METADATA_VERSION,majorProjVersion,minorProjVersion,microProjVersion,postFixProjVersion);
    }
    ProjectNameBP.getInstance().setName(xml.getGUID(),xml.getName(),false);
  }
 else {
    proj=NodeMaker.createProjectPO(xml.getName(),IVersion.JB_CLIENT_METADATA_VERSION);
    if (assignNewGuid) {
      m_oldToNewGuids.put(xml.getGUID(),proj.getGuid());
    }
  }
  return proj;
}","/** 
 * @param xml XML storage for the project
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise  <code>false</code>.
 * @return a new IProjectPO
 */
private IProjectPO initProject(Project xml,boolean assignNewGuid){
  IProjectPO proj=null;
  if (xml.getGUID() != null) {
    Integer majorProjVersion=null;
    if (!xml.isNilMajorProjectVersion() && xml.isSetMajorProjectVersion() || xml.isSetMajorNumber()) {
      majorProjVersion=xml.isSetMajorNumber() ? xml.getMajorNumber() : xml.getMajorProjectVersion();
    }
    Integer minorProjVersion=null;
    if (!xml.isNilMinorProjectVersion() && xml.isSetMinorProjectVersion() || xml.isSetMinorNumber()) {
      minorProjVersion=xml.isSetMinorNumber() ? xml.getMinorNumber() : xml.getMinorProjectVersion();
    }
    Integer microProjVersion=!xml.isSetMicroProjectVersion() || xml.isNilMicroProjectVersion() ? null : xml.getMicroProjectVersion();
    String postFixProjVersion=!xml.isSetProjectVersionQualifier() || xml.isNilProjectVersionQualifier() ? null : xml.getProjectVersionQualifier();
    if (!assignNewGuid) {
      proj=NodeMaker.createProjectPO(IVersion.JB_CLIENT_METADATA_VERSION,majorProjVersion,minorProjVersion,microProjVersion,postFixProjVersion,xml.getGUID());
    }
 else {
      proj=NodeMaker.createProjectPO(IVersion.JB_CLIENT_METADATA_VERSION,majorProjVersion,minorProjVersion,microProjVersion,postFixProjVersion);
      m_oldToNewGuids.put(xml.getGUID(),proj.getGuid());
    }
    ProjectNameBP.getInstance().setName(proj.getGuid(),xml.getName(),false);
  }
 else {
    proj=NodeMaker.createProjectPO(xml.getName(),IVersion.JB_CLIENT_METADATA_VERSION);
    if (assignNewGuid) {
      m_oldToNewGuids.put(xml.getGUID(),proj.getGuid());
    }
  }
  return proj;
}",0.9604072398190046
95690,"/** 
 * execute delete-test-result of summary without commit
 * @param session Session
 * @param resultId id of testresult-summary-entry, or <code>null</code> if all test results should be deleted.
 */
public static final void executeDeleteTestresultOfSummary(EntityManager session,Long resultId){
  boolean isDeleteAll=resultId == null;
  String paramQueryBaseString=""String_Node_Str"";
  if (isDeleteAll) {
    session.createNativeQuery(paramQueryBaseString).executeUpdate();
  }
 else {
    Query paramQuery=session.createNativeQuery(paramQueryBaseString + ""String_Node_Str"");
    paramQuery.setParameter(""String_Node_Str"",resultId);
    paramQuery.executeUpdate();
  }
  StringBuilder resultQueryBuilder=new StringBuilder();
  resultQueryBuilder.append(""String_Node_Str"");
  if (!isDeleteAll) {
    resultQueryBuilder.append(""String_Node_Str"");
  }
  Query resultQuery=session.createQuery(resultQueryBuilder.toString());
  if (!isDeleteAll) {
    resultQuery.setParameter(""String_Node_Str"",resultId);
  }
  resultQuery.executeUpdate();
}","/** 
 * execute delete-test-result of summary without commit
 * @param session Session
 * @param resultId id of testresult-summary-entry, or <code>null</code> if all test results should be deleted.
 */
public static final void executeDeleteTestresultOfSummary(EntityManager session,Long resultId){
  boolean isDeleteAll=resultId == null;
  String paramQueryBaseString=""String_Node_Str"";
  String queryExtension=""String_Node_Str"";
  if (isDeleteAll) {
    session.createNativeQuery(paramQueryBaseString).executeUpdate();
  }
 else {
    Query paramQuery=session.createNativeQuery(paramQueryBaseString + queryExtension);
    paramQuery.setParameter(""String_Node_Str"",resultId);
    paramQuery.executeUpdate();
  }
  String additionsQueryBaseString=""String_Node_Str"";
  if (isDeleteAll) {
    session.createNativeQuery(additionsQueryBaseString).executeUpdate();
  }
 else {
    Query commentQuery=session.createNativeQuery(additionsQueryBaseString + queryExtension);
    commentQuery.setParameter(""String_Node_Str"",resultId);
    commentQuery.executeUpdate();
  }
  StringBuilder resultQueryBuilder=new StringBuilder();
  resultQueryBuilder.append(""String_Node_Str"");
  if (!isDeleteAll) {
    resultQueryBuilder.append(""String_Node_Str"");
  }
  Query resultQuery=session.createQuery(resultQueryBuilder.toString());
  if (!isDeleteAll) {
    resultQuery.setParameter(""String_Node_Str"",resultId);
  }
  resultQuery.executeUpdate();
}",0.8286755771567437
95691,"/** 
 * gets an array of connections which target the   {@link GraphicalEditPart}
 * @param editPart the edit part
 * @return the connections which are going to another edit part
 */
private ConnectionEditPart[] getTargetConnectionEditParts(GraphicalEditPart editPart){
  List<?> targetConnectionList=editPart.getSourceConnections();
  ConnectionEditPart[] targetConnections=targetConnectionList.toArray(new ConnectionEditPart[targetConnectionList.size()]);
  return targetConnections;
}","/** 
 * gets an array of connections which target the   {@link GraphicalEditPart}
 * @param editPart the edit part
 * @return the connections which are going to another edit part
 */
private ConnectionEditPart[] getTargetConnectionEditParts(GraphicalEditPart editPart){
  List<?> targetConnectionList=editPart.getTargetConnections();
  ConnectionEditPart[] targetConnections=targetConnectionList.toArray(new ConnectionEditPart[targetConnectionList.size()]);
  return targetConnections;
}",0.9876796714579056
95692,"/** 
 * Finds and clicks the figure for the given path.
 * @param textPath The path to the figure.
 * @param operator The operator used for matching.
 * @param count The number of times to click.
 * @param button The mouse button to use for the click.
 */
public void rcClickFigure(String textPath,String operator,int count,int button){
  IFigure figure=FigureCanvasUtil.findFigure(findEditPart(textPath,operator));
  nullCheckFigure(figure);
  clickFigure(count,button,figure);
}","/** 
 * Finds and clicks the figure for the given path.
 * @param textPath The path to the figure.
 * @param operator The operator used for matching.
 * @param count The number of times to click.
 * @param button The mouse button to use for the click.
 */
public void rcClickFigure(String textPath,String operator,int count,int button){
  IFigure figure=FigureCanvasUtil.findFigure(findEditPart(textPath,operator));
  if (figure == null) {
    getRobot().click(getViewerControl(),getFigureBoundsChecked(textPath,operator),ClickOptions.create().setScrollToVisible(false).setClickCount(count).setMouseButton(button));
    return;
  }
  clickFigure(count,button,figure);
}",0.8093994778067886
95693,"/** 
 * {@inheritDoc}
 */
public void handlePropertyChanged(boolean isCompNameChanged){
  super.handlePropertyChanged(isCompNameChanged);
  m_eventHandlerTreeViewer.refresh();
}","/** 
 * {@inheritDoc}
 */
public void handlePropertyChanged(boolean isCompNameChanged){
  super.handlePropertyChanged(isCompNameChanged);
  Plugin.getDisplay().syncExec(new Runnable(){
    public void run(){
      getEventHandlerTreeViewer().refresh();
    }
  }
);
}",0.7792792792792793
95694,"public void run(){
  if (getEditorHelper().requestEditableState() != JBEditorHelper.EditableState.OK) {
    return;
  }
  if (!hasDefaultMapping) {
    String capComponentName=m_objectMappingManager.addMapping(recordAut,ci,newCap.getComponentName());
    newCap.setComponentName(capComponentName);
  }
  getTreeViewer().refresh(false);
  getTreeViewer().setSelection(new StructuredSelection(newCap),true);
  getEditorHelper().setDirty(true);
}","public void run(){
  getEventHandlerTreeViewer().refresh();
}",0.2261904761904762
95695,"@Override public void refresh(){
  super.refresh();
  getEventHandlerTreeViewer().refresh(true);
}","@Override public void refresh(){
  super.refresh();
  Plugin.getDisplay().syncExec(new Runnable(){
    public void run(){
      getEventHandlerTreeViewer().refresh();
    }
  }
);
}",0.6738351254480287
95696,"/** 
 * {@inheritDoc}
 */
public void handlePropertyChanged(boolean isCompNameChanged){
  createPartName();
  getTreeViewer().refresh();
}","/** 
 * {@inheritDoc}
 */
public void handlePropertyChanged(boolean isCompNameChanged){
  createPartName();
  Plugin.getDisplay().syncExec(new Runnable(){
    public void run(){
      getTreeViewer().refresh();
    }
  }
);
}",0.7548209366391184
95697,"/** 
 * Refreshes the editors viewer
 */
public void refresh(){
  getTreeViewer().refresh(true);
}","/** 
 * Refreshes the editors viewer
 */
public void refresh(){
  Plugin.getDisplay().syncExec(new Runnable(){
    public void run(){
      getTreeViewer().refresh(true);
    }
  }
);
}",0.6925795053003534
95698,"/** 
 * {@inheritDoc} 
 */
public void handlePropertyChanged(boolean isCompNameChanged){
  getMainTreeViewer().refresh();
}","/** 
 * {@inheritDoc} 
 */
public void handlePropertyChanged(boolean isCompNameChanged){
  Plugin.getDisplay().syncExec(new Runnable(){
    public void run(){
      getMainTreeViewer().refresh();
    }
  }
);
}",0.7327327327327328
95699,"protected IStatus run(IProgressMonitor monitor){
  monitor.beginTask(jobName,IProgressMonitor.UNKNOWN);
  ActivateInspectorMessage message=new ActivateInspectorMessage();
  try {
    AUTConnection.getInstance().connectToAut(autId,new NullProgressMonitor());
    AUTConnection.getInstance().request(message,new ActivateInspectorResponseCommand(),5000);
  }
 catch (  NotConnectedException nce) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NO_AUT_CONNECTION_ERROR);
  }
catch (  ConnectionException ce) {
    ErrorHandlingUtil.createMessageDialog(ce,null,null);
  }
catch (  CommunicationException ce) {
    ErrorHandlingUtil.createMessageDialog(ce,null,null);
  }
  monitor.done();
  return Status.OK_STATUS;
}","protected IStatus run(IProgressMonitor monitor){
  monitor.beginTask(jobName,IProgressMonitor.UNKNOWN);
  AutIdentifier autId=null;
  try {
    autId=(AutIdentifier)event.getObjectParameterForExecution(AUT_ID);
    lastAut=autId;
  }
 catch (  ExecutionException e) {
    InspectableAutSourceProvider iasp=new InspectableAutSourceProvider();
    Object inspectableAUTs=iasp.getCurrentState().get(InspectableAutSourceProvider.INSPECTABLE_AUTS);
    if (inspectableAUTs != null && inspectableAUTs instanceof List) {
      List auts=(List)inspectableAUTs;
      if (auts.size() == 1) {
        Object object=auts.get(0);
        autId=object instanceof AutIdentifier ? (AutIdentifier)object : null;
        lastAut=autId;
      }
 else       if (lastAut != null && auts.contains(lastAut)) {
        autId=lastAut;
      }
    }
  }
  if (autId == null) {
    return Status.CANCEL_STATUS;
  }
  ActivateInspectorMessage message=new ActivateInspectorMessage();
  try {
    AUTConnection.getInstance().connectToAut(autId,new NullProgressMonitor());
    AUTConnection.getInstance().request(message,new ActivateInspectorResponseCommand(),5000);
  }
 catch (  NotConnectedException nce) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NO_AUT_CONNECTION_ERROR);
  }
catch (  ConnectionException ce) {
    ErrorHandlingUtil.createMessageDialog(ce,null,null);
  }
catch (  CommunicationException ce) {
    ErrorHandlingUtil.createMessageDialog(ce,null,null);
  }
  monitor.done();
  return Status.OK_STATUS;
}",0.647507858105074
95700,"/** 
 * {@inheritDoc}
 */
public Object execute(ExecutionEvent event) throws ExecutionException {
  final AutIdentifier autId=(AutIdentifier)event.getObjectParameterForExecution(AUT_ID);
  final String jobName=Messages.UIJobActivateInspector;
  Job activateInspectorJob=new Job(jobName){
    protected IStatus run(    IProgressMonitor monitor){
      monitor.beginTask(jobName,IProgressMonitor.UNKNOWN);
      ActivateInspectorMessage message=new ActivateInspectorMessage();
      try {
        AUTConnection.getInstance().connectToAut(autId,new NullProgressMonitor());
        AUTConnection.getInstance().request(message,new ActivateInspectorResponseCommand(),5000);
      }
 catch (      NotConnectedException nce) {
        ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NO_AUT_CONNECTION_ERROR);
      }
catch (      ConnectionException ce) {
        ErrorHandlingUtil.createMessageDialog(ce,null,null);
      }
catch (      CommunicationException ce) {
        ErrorHandlingUtil.createMessageDialog(ce,null,null);
      }
      monitor.done();
      return Status.OK_STATUS;
    }
  }
;
  activateInspectorJob.setSystem(true);
  JobUtils.executeJob(activateInspectorJob,null);
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object execute(final ExecutionEvent event){
  final String jobName=Messages.UIJobActivateInspector;
  Job activateInspectorJob=new Job(jobName){
    protected IStatus run(    IProgressMonitor monitor){
      monitor.beginTask(jobName,IProgressMonitor.UNKNOWN);
      AutIdentifier autId=null;
      try {
        autId=(AutIdentifier)event.getObjectParameterForExecution(AUT_ID);
        lastAut=autId;
      }
 catch (      ExecutionException e) {
        InspectableAutSourceProvider iasp=new InspectableAutSourceProvider();
        Object inspectableAUTs=iasp.getCurrentState().get(InspectableAutSourceProvider.INSPECTABLE_AUTS);
        if (inspectableAUTs != null && inspectableAUTs instanceof List) {
          List auts=(List)inspectableAUTs;
          if (auts.size() == 1) {
            Object object=auts.get(0);
            autId=object instanceof AutIdentifier ? (AutIdentifier)object : null;
            lastAut=autId;
          }
 else           if (lastAut != null && auts.contains(lastAut)) {
            autId=lastAut;
          }
        }
      }
      if (autId == null) {
        return Status.CANCEL_STATUS;
      }
      ActivateInspectorMessage message=new ActivateInspectorMessage();
      try {
        AUTConnection.getInstance().connectToAut(autId,new NullProgressMonitor());
        AUTConnection.getInstance().request(message,new ActivateInspectorResponseCommand(),5000);
      }
 catch (      NotConnectedException nce) {
        ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NO_AUT_CONNECTION_ERROR);
      }
catch (      ConnectionException ce) {
        ErrorHandlingUtil.createMessageDialog(ce,null,null);
      }
catch (      CommunicationException ce) {
        ErrorHandlingUtil.createMessageDialog(ce,null,null);
      }
      monitor.done();
      return Status.OK_STATUS;
    }
  }
;
  activateInspectorJob.setSystem(true);
  JobUtils.executeJob(activateInspectorJob,null);
  return null;
}",0.684957426679281
95701,"/** 
 * Shows the SpecTS in the Test Suite Browser
 * @param node the node to show
 * @param viewPart the view part to show the specification in
 */
protected void showSpecUINode(INodePO node,IViewPart viewPart){
  if (!Utils.openPerspective(Constants.SPEC_PERSPECTIVE)) {
    return;
  }
  if (!PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getPerspective().getId().equals(Constants.SPEC_PERSPECTIVE)) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.I_NO_PERSPECTIVE_CHANGE);
    return;
  }
  if (viewPart instanceof AbstractJBTreeView) {
    AbstractJBTreeView jbtv=(AbstractJBTreeView)viewPart;
    Plugin.activate(jbtv);
    UINodeBP.selectNodeInTree(node.getId(),jbtv.getTreeViewer(),jbtv.getEntityManager());
  }
}","/** 
 * Shows the node in the specific viewPart if possible
 * @param node the node to show
 * @param viewPartID the view part ID to show the specification in
 */
protected void showSpecUINode(INodePO node,String viewPartID){
  if (!openSpecPerspectiveAndShowError()) {
    return;
  }
  IViewPart viewPart=Plugin.showView(viewPartID);
  activatViewAndSelect(node,viewPart);
}",0.1064773735581189
95702,"/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  ISpecTestCasePO specTc=UINodeBP.getSpecTC(getSelection());
  if (specTc != null) {
    showSpecUINode(specTc,MultipleTCBTracker.getInstance().getMainTCB());
    return null;
  }
  ITestSuitePO testSuite=UINodeBP.getSpecTS(getSelection());
  if (testSuite != null) {
    IViewPart view=Plugin.showView(Constants.TS_BROWSER_ID);
    showSpecUINode(testSuite,view);
  }
  return null;
}","/** 
 * {@inheritDoc} 
 */
public Object executeImpl(ExecutionEvent event){
  ISpecTestCasePO specTc=UINodeBP.getSpecTC(getSelection());
  if (specTc != null) {
    showSpecUINode(specTc,MultipleTCBTracker.getInstance().getMainTCB());
    return null;
  }
  ITestSuitePO testSuite=UINodeBP.getSpecTS(getSelection());
  if (testSuite != null) {
    showSpecUINode(testSuite,Constants.TS_BROWSER_ID);
  }
  return null;
}",0.8977272727272727
95703,"/** 
 * Creates the initial Context of this Editor.<br> Subclasses may override this method. 
 * @param parent Composite
 */
public void createPartControlImpl(Composite parent){
  createSashForm(parent);
  setParentComposite(parent);
  setInitialInput();
  ColumnViewerToolTipSupport.enableFor(getTreeViewer());
  DecoratingCellLabelProvider lp=new DecoratingCellLabelProvider(new TooltipLabelProvider(),Plugin.getDefault().getWorkbench().getDecoratorManager().getLabelDecorator());
  getTreeViewer().setLabelProvider(lp);
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addPropertyChangedListener(this,true);
  addDragAndDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getInstance()});
  getEditorHelper().addListeners();
  setActionHandlers();
  addDoubleClickListener(CommandIDs.OPEN_SPECIFICATION_COMMAND_ID,getMainTreeViewer());
  GuiEventDispatcher.getInstance().addEditorDirtyStateListener(this,true);
  ded.addDataChangedListener(new CentralTestDataUpdateListener(),false);
  ded.addParamChangedListener(this,true);
}","/** 
 * Creates the initial Context of this Editor.<br> Subclasses may override this method. 
 * @param parent Composite
 */
public void createPartControlImpl(Composite parent){
  createSashForm(parent);
  setParentComposite(parent);
  setInitialInput();
  ColumnViewerToolTipSupport.enableFor(getTreeViewer());
  DecoratingCellLabelProvider lp=new DecoratingCellLabelProvider(new TooltipLabelProvider(),Plugin.getDefault().getWorkbench().getDecoratorManager().getLabelDecorator());
  getTreeViewer().setLabelProvider(lp);
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addPropertyChangedListener(this,true);
  addDragAndDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getInstance()});
  getEditorHelper().addListeners();
  setActionHandlers();
  addDoubleClickListener(CommandIDs.OPEN_SPECIFICATION_COMMAND_ID,getMainTreeViewer());
  GuiEventDispatcher.getInstance().addEditorDirtyStateListener(this,true);
  ded.addDataChangedListener(m_ctdUpdateListener,false);
  ded.addParamChangedListener(this,true);
}",0.9876425855513308
95704,"/** 
 * Cleanup on closing.
 */
public void dispose(){
  try {
    DataEventDispatcher ded=DataEventDispatcher.getInstance();
    if (CAPRecordedCommand.getRecordListener() == this) {
      CAPRecordedCommand.setRecordListener(null);
      TestExecutionContributor.getInstance().getClientTest().resetToTesting();
    }
    if (getEditorSite() != null && getEditorSite().getPage() != null) {
      ded.fireRecordModeStateChanged(RecordModeState.notRunning);
      removeGlobalActionHandler();
    }
    ded.removeParamChangedListener(this);
  }
  finally {
    super.dispose();
  }
}","/** 
 * Cleanup on closing.
 */
public void dispose(){
  try {
    DataEventDispatcher ded=DataEventDispatcher.getInstance();
    ded.removeParamChangedListener(this);
    ded.removeDataChangedListener(m_ctdUpdateListener);
    if (CAPRecordedCommand.getRecordListener() == this) {
      CAPRecordedCommand.setRecordListener(null);
      TestExecutionContributor.getInstance().getClientTest().resetToTesting();
    }
    if (getEditorSite() != null && getEditorSite().getPage() != null) {
      ded.fireRecordModeStateChanged(RecordModeState.notRunning);
      removeGlobalActionHandler();
    }
  }
  finally {
    super.dispose();
  }
}",0.8852459016393442
95705,"/** 
 * Use this method only from the FX-Thread! Removes the Border
 * @param n the Node
 */
public static void removeHighlight(Node n){
  n.setEffect(oldEffects.remove(n));
}","/** 
 * Use this method only from the FX-Thread! Removes the Border
 * @param n the Node
 */
public static void removeHighlight(Node n){
  if (n.effectProperty().isBound()) {
    return;
  }
  n.setEffect(oldEffects.remove(n));
}",0.8663366336633663
95706,"/** 
 * Use this method only from the FX-Thread! Draws a border around the given Node
 * @param n the Node
 */
public static void drawHighlight(Node n){
  if (n.getEffect() != null) {
    oldEffects.put(n,n.getEffect());
  }
  n.setEffect(new InnerShadow(10,Color.GREEN));
}","/** 
 * Use this method only from the FX-Thread! Draws a border around the given Node
 * @param n the Node
 */
public static void drawHighlight(Node n){
  if (n.effectProperty().isBound()) {
    return;
  }
  if (n.getEffect() != null) {
    oldEffects.put(n,n.getEffect());
  }
  n.setEffect(new InnerShadow(10,Color.GREEN));
}",0.9102990033222592
95707,"/** 
 * Returns a sorted map consisting of the bean properties of a component
 * @param currComp the component
 * @return the sorted map of properties
 */
public static Map<String,String> getMapOfComponentProperties(final Object currComp){
  PropertyDescriptor[] propertyDescriptors=PropertyUtils.getPropertyDescriptors(currComp);
  Map<String,String> componentProperties=new TreeMap<String,String>();
  for (int i=0; i < propertyDescriptors.length; i++) {
    PropertyDescriptor pd=propertyDescriptors[i];
    String propertyName=pd.getName();
    try {
      Method readMethod=pd.getReadMethod();
      if (readMethod != null) {
        componentProperties.put(propertyName,getPropertyValue(currComp,propertyName));
      }
 else {
        componentProperties.put(propertyName,""String_Node_Str"");
      }
    }
 catch (    IllegalArgumentException e) {
      componentProperties.put(propertyName,""String_Node_Str"");
    }
  }
  return componentProperties;
}","/** 
 * Returns a sorted map consisting of the bean properties of a component
 * @param currComp the component
 * @return the sorted map of properties
 */
public static Map<String,String> getMapOfComponentProperties(final Object currComp){
  PropertyDescriptor[] propertyDescriptors=PropertyUtils.getPropertyDescriptors(currComp);
  Map<String,String> componentProperties=new TreeMap<String,String>();
  for (int i=0; i < propertyDescriptors.length; i++) {
    PropertyDescriptor pd=propertyDescriptors[i];
    String propertyName=pd.getName();
    try {
      Method readMethod=pd.getReadMethod();
      if (readMethod != null) {
        componentProperties.put(propertyName,getPropertyValue(currComp,propertyName));
      }
 else {
        componentProperties.put(propertyName,""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"" + propertyName + ""String_Node_Str""+ currComp.toString()+ ""String_Node_Str"",e);
      componentProperties.put(propertyName,""String_Node_Str"");
    }
  }
  return componentProperties;
}",0.9369727047146402
95708,"/** 
 * {@inheritDoc}
 */
@Override public boolean isFallBackEventMatching(List eventObjects,Object graphicsComponent){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isFallBackEventMatching(List eventObjects,Object graphicsComponent){
  int clickEventCount=0;
  for (  Object object : eventObjects) {
    Event e=(Event)object;
    if (e != null && e.getEventType().equals(MouseEvent.MOUSE_CLICKED)) {
      clickEventCount++;
    }
  }
  return clickEventCount == m_clickOptions.getClickCount();
}",0.4884615384615384
95709,"/** 
 * Calculates the timeout for a Show Text Action
 * @param messageCap The message cap
 * @return The timeout to use, or -1 if the timeout cannot be calculated
 */
private int calculateShowTextTimeout(MessageCap messageCap){
  MessageParam textParam=(MessageParam)messageCap.getMessageParams().get(0);
  MessageParam timePerWordParam=(MessageParam)messageCap.getMessageParams().get(2);
  try {
    int numWords=StringParsing.countWords(textParam.getValue());
    return Integer.parseInt(timePerWordParam.getValue()) * numWords;
  }
 catch (  NumberFormatException e) {
    LOG.warn(Messages.ErrorParsingTimeoutParameter + StringConstants.DOT + StringConstants.SPACE+ Messages.UsingDefaultValue+ StringConstants.DOT,e);
  }
  return -1;
}","/** 
 * Calculates the timeout for a Show Text Action
 * @param messageCap The message cap
 * @return The timeout to use, or -1 if the timeout cannot be calculated
 */
private int calculateShowTextTimeout(MessageCap messageCap){
  MessageParam textParam=messageCap.getMessageParams().get(0);
  MessageParam timePerWordParam=messageCap.getMessageParams().get(2);
  try {
    int numWords=StringParsing.countWords(textParam.getValue());
    return Integer.parseInt(timePerWordParam.getValue()) * numWords;
  }
 catch (  NumberFormatException e) {
    LOG.warn(Messages.ErrorParsingTimeoutParameter + StringConstants.DOT + StringConstants.SPACE+ Messages.UsingDefaultValue+ StringConstants.DOT,e);
  }
  return -1;
}",0.9422283356258596
95710,"/** 
 * Calculates the request timeout. Important if an action has a higher timeout than the standard request timeout.
 * @param messageCap the MessageCap
 * @return the calculated timeout.
 */
private int calculateRequestTimeout(MessageCap messageCap){
  List<Integer> timeOuts=new ArrayList<Integer>();
  IParamDescriptionPO desc1=m_currentCap.getParameterForUniqueId(COMP_SYSTEM_TIMEOUT);
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  desc1=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  int timeout=0;
  for (  int index : timeOuts) {
    if (index > -1) {
      final MessageParam param=(MessageParam)messageCap.getMessageParams().get(index);
      final String paramTimeOut=param.getValue();
      timeout+=Integer.parseInt(paramTimeOut);
    }
  }
  boolean isShowText=messageCap.getMethod().equals(""String_Node_Str"");
  if (isShowText) {
    int showTextTimeout=calculateShowTextTimeout(messageCap);
    if (showTextTimeout != -1) {
      timeout+=showTextTimeout;
    }
  }
  return m_requestTimeout + timeout;
}","/** 
 * Calculates the request timeout. Important if an action has a higher timeout than the standard request timeout.
 * @param messageCap the MessageCap
 * @return the calculated timeout.
 */
private int calculateRequestTimeout(MessageCap messageCap){
  List<Integer> timeOuts=new ArrayList<Integer>();
  IParamDescriptionPO desc1=m_currentCap.getParameterForUniqueId(COMP_SYSTEM_TIMEOUT);
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  desc1=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  int timeout=0;
  for (  int index : timeOuts) {
    if (index > -1) {
      final MessageParam param=messageCap.getMessageParams().get(index);
      final String paramTimeOut=param.getValue();
      timeout+=Integer.parseInt(paramTimeOut);
    }
  }
  boolean isShowText=messageCap.getMethod().equals(""String_Node_Str"");
  if (isShowText) {
    int showTextTimeout=calculateShowTextTimeout(messageCap);
    if (showTextTimeout != -1) {
      timeout+=showTextTimeout;
    }
  }
  return m_requestTimeout + timeout;
}",0.9936936936936936
95711,"/** 
 * minimzes the component name, e.g. javax.swing.JButton_1 to Button_1
 * @param capName String
 * @return the minimized CapName
 */
private String minimizeCapName(String capName){
  String minCapName=capName;
  String[] nameParts=null;
  nameParts=minCapName.split(""String_Node_Str"",2);
  if (nameParts[0].lastIndexOf(""String_Node_Str"") > -1 && nameParts[0].length() > (nameParts[0].lastIndexOf(""String_Node_Str"") + 1)) {
    nameParts[0]=nameParts[0].substring(nameParts[0].lastIndexOf(""String_Node_Str"") + 1);
  }
  minCapName=nameParts[0];
  if (nameParts.length > 1) {
    minCapName=minCapName + ""String_Node_Str"" + nameParts[1];
  }
  return minCapName;
}","/** 
 * minimizes the component name, e.g. javax.swing.JButton_1 to Button_1
 * @param capName String
 * @return the minimized CapName
 */
private String minimizeCapName(String capName){
  String minCapName=capName;
  String[] nameParts=null;
  nameParts=minCapName.split(""String_Node_Str"",2);
  if (nameParts[0].lastIndexOf(""String_Node_Str"") > -1 && nameParts[0].length() > (nameParts[0].lastIndexOf(""String_Node_Str"") + 1)) {
    nameParts[0]=nameParts[0].substring(nameParts[0].lastIndexOf(""String_Node_Str"") + 1);
  }
  minCapName=nameParts[0];
  if (nameParts.length > 1) {
    minCapName=minCapName + ""String_Node_Str"" + nameParts[1];
  }
  return minCapName;
}",0.999250936329588
95712,"/** 
 * The default constructor 
 */
public MessageCap(){
  super();
  m_messageParams=new ArrayList();
}","/** 
 * The default constructor 
 */
public MessageCap(){
  super();
  m_messageParams=new ArrayList<MessageParam>();
}",0.9375
95713,"/** 
 * @return Returns the messageParams. 
 */
public List getMessageParams(){
  return m_messageParams;
}","/** 
 * @return Returns the messageParams. 
 */
public List<MessageParam> getMessageParams(){
  return m_messageParams;
}",0.9385964912280702
95714,"/** 
 * {@inheritDoc}
 */
public String toString(){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"" + getMethod());
  builder.append(""String_Node_Str"" + getCi());
  builder.append(""String_Node_Str"");
  for (Iterator iterator=getMessageParams().iterator(); iterator.hasNext(); ) {
    MessageParam parameter=(MessageParam)iterator.next();
    builder.append(parameter.getValue() + ""String_Node_Str"");
  }
  if (getPostExecutionCommand() != null) {
    builder.append(""String_Node_Str"");
    builder.append(getPostExecutionCommand().getClass().getCanonicalName());
  }
  return builder.toString();
}","/** 
 * {@inheritDoc}
 */
public String toString(){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"" + getMethod());
  builder.append(""String_Node_Str"" + getCi());
  builder.append(""String_Node_Str"");
  for (Iterator<MessageParam> iterator=getMessageParams().iterator(); iterator.hasNext(); ) {
    MessageParam parameter=iterator.next();
    builder.append(parameter.getValue() + ""String_Node_Str"");
  }
  if (getPostExecutionCommand() != null) {
    builder.append(""String_Node_Str"");
    builder.append(getPostExecutionCommand().getClass().getCanonicalName());
  }
  return builder.toString();
}",0.9777424483306836
95715,"/** 
 * Gets the implementation class. 
 * @param response The response message.
 * @return the implementation class or null if an error occurs.
 */
protected Object getImplClass(CAPTestResponseMessage response){
  Object implClass=null;
  final MessageCap messageCap=m_capTestMessage.getMessageCap();
  IComponentIdentifier ci=messageCap.getCi();
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + (ci == null ? ""String_Node_Str"" : ci.getComponentClassName()));
  }
  try {
    if (!messageCap.hasDefaultMapping()) {
      Validate.notNull(ci);
    }
    int timeout=TimingConstantsServer.DEFAULT_FIND_COMPONENT_TIMEOUT;
    boolean isWaitForComponent=WidgetTester.RC_METHOD_NAME_WAIT_FOR_COMPONENT.equals(messageCap.getMethod());
    if (isWaitForComponent) {
      MessageParam timeoutParam=(MessageParam)messageCap.getMessageParams().get(0);
      try {
        timeout=Integer.parseInt(timeoutParam.getValue());
      }
 catch (      NumberFormatException e) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    final AUTServerConfiguration rcConfig=AUTServerConfiguration.getInstance();
    if (!messageCap.hasDefaultMapping()) {
      Object component=AUTServer.getInstance().findComponent(ci,timeout);
      implClass=rcConfig.prepareImplementationClass(component,component.getClass());
    }
 else {
      implClass=rcConfig.getImplementationClass(ci.getComponentClassName());
    }
    if (isWaitForComponent) {
      MessageParam delayParam=(MessageParam)messageCap.getMessageParams().get(1);
      try {
        int delay=Integer.parseInt(delayParam.getValue());
        TimeUtil.delay(delay);
      }
 catch (      IllegalArgumentException iae) {
        handleInvalidInput(""String_Node_Str"" + CompSystemI18n.getString(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalArgumentException e) {
    handleComponentNotFound(response,e);
  }
catch (  ComponentNotFoundException e) {
    if (WidgetTester.RC_METHOD_NAME_CHECK_EXISTENCE.equals(messageCap.getMethod())) {
      MessageParam isVisibleParam=(MessageParam)messageCap.getMessageParams().get(0);
      handleComponentDoesNotExist(response,Boolean.valueOf(isVisibleParam.getValue()).booleanValue());
    }
 else {
      handleComponentNotFound(response,e);
    }
  }
catch (  UnsupportedComponentException buce) {
    LOG.error(buce.getLocalizedMessage(),buce);
    response.setTestErrorEvent(EventFactory.createConfigErrorEvent());
  }
catch (  Throwable e) {
    if (LOG.isErrorEnabled()) {
      LOG.error(e.getLocalizedMessage(),e);
    }
    response.setTestErrorEvent(EventFactory.createImplClassErrorEvent());
  }
  return implClass;
}","/** 
 * Gets the implementation class. 
 * @param response The response message.
 * @return the implementation class or null if an error occurs.
 */
protected Object getImplClass(CAPTestResponseMessage response){
  Object implClass=null;
  final MessageCap messageCap=m_capTestMessage.getMessageCap();
  IComponentIdentifier ci=messageCap.getCi();
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + (ci == null ? ""String_Node_Str"" : ci.getComponentClassName()));
  }
  try {
    if (!messageCap.hasDefaultMapping()) {
      Validate.notNull(ci);
    }
    int timeout=TimingConstantsServer.DEFAULT_FIND_COMPONENT_TIMEOUT;
    boolean isWaitForComponent=WidgetTester.RC_METHOD_NAME_WAIT_FOR_COMPONENT.equals(messageCap.getMethod());
    if (isWaitForComponent) {
      MessageParam timeoutParam=messageCap.getMessageParams().get(0);
      try {
        timeout=Integer.parseInt(timeoutParam.getValue());
      }
 catch (      NumberFormatException e) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    final AUTServerConfiguration rcConfig=AUTServerConfiguration.getInstance();
    if (!messageCap.hasDefaultMapping()) {
      Object component=AUTServer.getInstance().findComponent(ci,timeout);
      implClass=rcConfig.prepareImplementationClass(component,component.getClass());
    }
 else {
      implClass=rcConfig.getImplementationClass(ci.getComponentClassName());
    }
    if (isWaitForComponent) {
      MessageParam delayParam=messageCap.getMessageParams().get(1);
      try {
        int delay=Integer.parseInt(delayParam.getValue());
        TimeUtil.delay(delay);
      }
 catch (      IllegalArgumentException iae) {
        handleInvalidInput(""String_Node_Str"" + CompSystemI18n.getString(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalArgumentException e) {
    handleComponentNotFound(response,e);
  }
catch (  ComponentNotFoundException e) {
    if (WidgetTester.RC_METHOD_NAME_CHECK_EXISTENCE.equals(messageCap.getMethod())) {
      MessageParam isVisibleParam=messageCap.getMessageParams().get(0);
      handleComponentDoesNotExist(response,Boolean.valueOf(isVisibleParam.getValue()).booleanValue());
    }
 else {
      handleComponentNotFound(response,e);
    }
  }
catch (  UnsupportedComponentException buce) {
    LOG.error(buce.getLocalizedMessage(),buce);
    response.setTestErrorEvent(EventFactory.createConfigErrorEvent());
  }
catch (  Throwable e) {
    if (LOG.isErrorEnabled()) {
      LOG.error(e.getLocalizedMessage(),e);
    }
    response.setTestErrorEvent(EventFactory.createImplClassErrorEvent());
  }
  return implClass;
}",0.9920754716981132
95716,"/** 
 * Creates a new method invoker.
 * @param messageCap The message data
 * @throws MethodParamException If the action method parameters cannot be evaluated successfully.
 */
public MethodInvoker(MessageCap messageCap) throws MethodParamException {
  m_methodParams=new MethodParams();
  List paramList=messageCap.getMessageParams();
  for (Iterator it=paramList.iterator(); it.hasNext(); ) {
    MessageParam param=(MessageParam)it.next();
    m_methodParams.add(param);
  }
  m_messageCap=messageCap;
}","/** 
 * Creates a new method invoker.
 * @param messageCap The message data
 * @throws MethodParamException If the action method parameters cannot be evaluated successfully.
 */
public MethodInvoker(MessageCap messageCap) throws MethodParamException {
  m_methodParams=new MethodParams();
  List<MessageParam> paramList=messageCap.getMessageParams();
  for (Iterator<MessageParam> it=paramList.iterator(); it.hasNext(); ) {
    MessageParam param=it.next();
    m_methodParams.add(param);
  }
  m_messageCap=messageCap;
}",0.9591439688715954
95717,"/** 
 * constructor to add the stage which has focus to our event confirming mechanism
 */
public JavaFXApplicationTester(){
  RobotJavaFXImpl robot=((RobotJavaFXImpl)getRobot());
  Stage focusStage=CurrentStages.getfocusStage();
  robot.getInterceptor().addSceneGraph(focusStage.getScene().windowProperty());
}","/** 
 * constructor to add the stage which has focus to our event confirming mechanism
 */
public JavaFXApplicationTester(){
  for (  Stage s : CurrentStages.getStageList()) {
    ((RobotJavaFXImpl)getRobot()).getInterceptor().addSceneGraph(s.getScene().windowProperty());
  }
}",0.6994906621392191
95718,"/** 
 * @param original The original, or base, image.
 * @return the ""cut"" version of the image. Client should not dispose this image.
 */
public static Image getCutImage(Image original){
  Image cutImage=GENERATED_IMAGES.get(original);
  if (cutImage == null) {
    cutImage=new Image(original.getDevice(),original,SWT.IMAGE_GRAY);
    GENERATED_IMAGES.put(original,cutImage);
  }
  return cutImage;
}","/** 
 * @param original The original, or base, image.
 * @return the ""cut"" version of the image. Client should not dispose this image.
 */
public static Image getCutImage(Image original){
  Image cutImage=GRAYED_IMAGES.get(original);
  if (cutImage == null) {
    cutImage=new Image(original.getDevice(),original,SWT.IMAGE_GRAY);
    GRAYED_IMAGES.put(original,cutImage);
  }
  return cutImage;
}",0.987468671679198
95719,"/** 
 * {@inheritDoc}
 */
@Override public boolean isFallBackEventMatching(List eventObjects,Object graphicsComponent){
  int clickEventCount=0;
  for (  Object object : eventObjects) {
    Event e=(Event)object;
    if (e != null && e.getEventType().equals(MouseEvent.MOUSE_CLICKED)) {
      clickEventCount++;
    }
  }
  return clickEventCount == m_clickOptions.getClickCount();
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isFallBackEventMatching(List eventObjects,Object graphicsComponent){
  List<MouseEvent> catchedEvents=new ArrayList<MouseEvent>();
  for (  Object object : eventObjects) {
    Event e=(Event)object;
    if (e != null && e.getEventType().equals(MouseEvent.MOUSE_CLICKED)) {
      catchedEvents.add((MouseEvent)e);
    }
  }
  for (int i=0; i < catchedEvents.size(); i++) {
    int clickEventCount=getClickCount(catchedEvents.get(i));
    for (int j=(i + 1); j < catchedEvents.size(); j++) {
      if (catchedEvents.get(i).getSource().equals(catchedEvents.get(j).getSource())) {
        clickEventCount+=getClickCount(catchedEvents.get(j));
      }
    }
    if (clickEventCount == m_clickOptions.getClickCount()) {
      return true;
    }
  }
  return false;
}",0.5661641541038526
95720,"/** 
 * Gets the rendered text of a TreeTableCell
 * @param node this can be a cell or a tree item
 * @param col if node is a tree item this parameter is used to find the cell to get the rendered text from
 * @return the rendered text
 */
private String getRenderedTextFromCell(final Object node,final int col){
  String result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      if (node instanceof TreeTableCell) {
        TreeTableCell<?,?> cell=(TreeTableCell<?,?>)node;
        return cell.getText();
      }
 else       if (node instanceof TreeItem) {
        TreeItem<?> item=(TreeItem<?>)node;
        TreeTableView<?> treeTable=getTree();
        List<TreeTableCell> cells=new NodeTraverseHelper<TreeTableCell>().getInstancesOf(treeTable,TreeTableCell.class);
        for (        TreeTableCell<?,?> cell : cells) {
          TreeTableRow<?> ttRow=cell.getTreeTableRow();
          if (ttRow == null) {
            continue;
          }
          TreeItem<?> checkItem=ttRow.getTreeItem();
          if (checkItem == null) {
            continue;
          }
          if (item != null && checkItem.equals(item) && treeTable.getColumns().indexOf(cell.getTableColumn()) == col) {
            return cell.getText();
          }
        }
      }
      return null;
    }
  }
);
  return result;
}","/** 
 * Gets the rendered text of a TreeTableCell
 * @param node this can be a cell or a tree item
 * @param col if node is a tree item this parameter is used to find the cell to get the rendered text from
 * @return the rendered text
 */
private String getRenderedTextFromCell(final Object node,final int col){
  if (node instanceof TreeItem<?>) {
    scrollNodeToVisible(node);
  }
  String result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      if (node instanceof TreeTableCell) {
        TreeTableCell<?,?> cell=(TreeTableCell<?,?>)node;
        return cell.getText();
      }
 else       if (node instanceof TreeItem) {
        TreeItem<?> item=(TreeItem<?>)node;
        TreeTableView<?> treeTable=getTree();
        List<TreeTableCell> cells=new NodeTraverseHelper<TreeTableCell>().getInstancesOf(treeTable,TreeTableCell.class);
        for (        TreeTableCell<?,?> cell : cells) {
          TreeTableRow<?> ttRow=cell.getTreeTableRow();
          if (ttRow == null) {
            continue;
          }
          TreeItem<?> checkItem=ttRow.getTreeItem();
          if (checkItem == null) {
            continue;
          }
          if (item != null && checkItem.equals(item) && treeTable.getColumns().indexOf(cell.getTableColumn()) == col) {
            return cell.getText();
          }
        }
      }
      return null;
    }
  }
);
  return result;
}",0.9748427672955976
95721,"@Override public int getIndexOfChild(final Object parent,final Object child){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    @Override public Integer call() throws Exception {
      return ((TreeItem<?>)parent).getChildren().indexOf(child);
    }
  }
);
}","@Override public int getIndexOfChild(final Object parent,final Object child){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    @Override public Integer call() throws Exception {
      if (parent == null) {
        Object[] rootNodes=getRootNodes();
        for (int i=0; i < rootNodes.length; i++) {
          if (ObjectUtils.equals(rootNodes[i],child)) {
            return i;
          }
        }
        return -1;
      }
      List<?> children=((TreeItem<?>)parent).getChildren();
      if (children.contains(child)) {
        return children.indexOf(child);
      }
      return -1;
    }
  }
);
}",0.6173096976016684
95722,"@Override public Integer call() throws Exception {
  return ((TreeItem<?>)parent).getChildren().indexOf(child);
}","@Override public Integer call() throws Exception {
  if (parent == null) {
    Object[] rootNodes=getRootNodes();
    for (int i=0; i < rootNodes.length; i++) {
      if (ObjectUtils.equals(rootNodes[i],child)) {
        return i;
      }
    }
    return -1;
  }
  List<?> children=((TreeItem<?>)parent).getChildren();
  if (children.contains(child)) {
    return children.indexOf(child);
  }
  return -1;
}",0.4069097888675624
95723,"/** 
 * @return the IMenuAdapter.
 * @throws StepExecutionException if the active window has no menu bar.
 */
protected IMenuComponent getAndCheckMenu() throws StepExecutionException {
  Object menu=getMenuAdapter().getRealComponent();
  if (menu == null) {
    throw new StepExecutionException(I18n.getString(TestErrorEvent.NO_MENU_BAR),EventFactory.createActionError(TestErrorEvent.NO_MENU_BAR));
  }
  return getMenuAdapter();
}","/** 
 * @return the IMenuAdapter.
 * @throws StepExecutionException if the active window has no menu bar.
 */
protected IMenuComponent getAndCheckMenu() throws StepExecutionException {
  IMenuComponent menuAdapter=getMenuAdapter();
  if (menuAdapter == null || menuAdapter.getRealComponent() == null) {
    throw new StepExecutionException(I18n.getString(TestErrorEvent.NO_MENU_BAR),EventFactory.createActionError(TestErrorEvent.NO_MENU_BAR));
  }
  return menuAdapter;
}",0.8691796008869179
95724,"/** 
 * implementation for ""wait for component""
 * @param timeout the maximum amount of time to wait for the component
 * @param delay the time to wait after the component is found
 */
public void waitForComponent(int timeout,int delay){
  if (getComponent().getRealComponent() == null) {
    long start=System.currentTimeMillis();
    do {
      RobotTiming.sleepWaitForComponentPollingDelay();
    }
 while (System.currentTimeMillis() - start < timeout && getComponent().getRealComponent() == null);
    if (getComponent().getRealComponent() == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createComponentNotFoundErrorEvent());
    }
  }
  TimeUtil.delay(delay);
}","/** 
 * implementation for ""wait for component""
 * @param timeout the maximum amount of time to wait for the component
 * @param delay the time to wait after the component is found
 */
public void waitForComponent(int timeout,int delay){
  IComponent component=getComponent();
  if (component == null || component.getRealComponent() == null) {
    long start=System.currentTimeMillis();
    do {
      RobotTiming.sleepWaitForComponentPollingDelay();
      component=getComponent();
    }
 while (System.currentTimeMillis() - start < timeout && (component == null || component.getRealComponent() == null));
    if (component == null || component.getRealComponent() == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createComponentNotFoundErrorEvent());
    }
  }
  TimeUtil.delay(delay);
}",0.8650427913100724
95725,"/** 
 * Looks for the bundle with the given ID and the highest Version. This search  also includes non active bundles.
 * @param bundleId the bundle ID to look for
 * @return the bundle
 */
private static Bundle bundleLookupWithInactive(String bundleId){
  Bundle[] bundles=EclipseStarter.getSystemBundleContext().getBundles();
  Bundle result=null;
  Version currVersion=Version.emptyVersion;
  for (  Bundle bundle : bundles) {
    if (bundle.getSymbolicName().contains(bundleId) && bundle.getVersion().compareTo(currVersion) > 0) {
      result=bundle;
      currVersion=bundle.getVersion();
    }
  }
  return result;
}","/** 
 * Looks for the bundle with the given ID and the highest Version. This search  also includes non active bundles.
 * @param bundleId the bundle ID to look for
 * @return the bundle
 */
private static Bundle bundleLookupWithInactive(String bundleId){
  Bundle[] bundles=EclipseStarter.getSystemBundleContext().getBundles();
  Bundle result=null;
  Version currVersion=Version.emptyVersion;
  for (  Bundle bundle : bundles) {
    if (bundle.getSymbolicName().equals(bundleId) && bundle.getVersion().compareTo(currVersion) > 0) {
      result=bundle;
      currVersion=bundle.getVersion();
    }
  }
  return result;
}",0.990353697749196
95726,"@Override protected Cell getCellAtMousePosition() throws StepExecutionException {
  final Point p=getRobot().getCurrentMousePosition();
  Cell result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Cell>(){
    @Override public Cell call() throws Exception {
      TableView<?> table=(TableView<?>)getRealComponent();
      table.layout();
      List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
      for (      TableCell<?,?> cell : tCells) {
        if (NodeBounds.getAbsoluteBounds(cell).contains(p) && cell.getTableView().equals(table)) {
          TableColumn cellColumn=cell.getTableColumn();
          int col=table.getVisibleLeafIndex(cellColumn);
          return new Cell(cell.getIndex(),col);
        }
      }
      return null;
    }
  }
);
  return result;
}","@Override protected Cell getCellAtMousePosition() throws StepExecutionException {
  final Point p=getRobot().getCurrentMousePosition();
  Cell result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Cell>(){
    @Override public Cell call() throws Exception {
      TableView<?> table=(TableView<?>)getRealComponent();
      table.layout();
      List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
      for (      TableCell<?,?> cell : tCells) {
        if (NodeBounds.checkIfContains(new Point2D(p.x,p.y),cell) && cell.getTableView().equals(table)) {
          TableColumn cellColumn=cell.getTableColumn();
          int col=table.getVisibleLeafIndex(cellColumn);
          return new Cell(cell.getIndex(),col);
        }
      }
      return null;
    }
  }
);
  return result;
}",0.9552238805970148
95727,"/** 
 * @param autId The ID of the AUT for which to start the Object Mapping Mode.
 * @param editor the actual om-editor
 * @param unmappedTechNames the top-level category for unmapped Technical Names
 */
private void startMappingMode(AutIdentifier autId,ObjectMappingMultiPageEditor editor,IObjectMappingCategoryPO unmappedTechNames){
  IObjectMappingCategoryPO category=null;
  if (!(editor.getTreeViewer().getSelection() instanceof IStructuredSelection) || !(editor.getTreeViewer().getContentProvider() instanceof ITreeContentProvider)) {
    return;
  }
  IStructuredSelection selection=(IStructuredSelection)editor.getTreeViewer().getSelection();
  Object node;
  if (selection.size() == 1) {
    node=selection.getFirstElement();
    if (node instanceof IObjectMappingCategoryPO && OMEditorDndSupport.getSection((IObjectMappingCategoryPO)node).equals(unmappedTechNames)) {
      category=(IObjectMappingCategoryPO)node;
    }
 else     if (node instanceof IObjectMappingAssoziationPO && OMEditorDndSupport.getSection((IObjectMappingAssoziationPO)node).equals(unmappedTechNames)) {
      category=((IObjectMappingAssoziationPO)node).getCategory();
    }
    if (category != null) {
      editor.getOmEditorBP().setCategoryToCreateIn(category);
    }
 else {
      ObjectMappingEventDispatcher.setCategoryToCreateIn(null);
    }
  }
  if (!AutAgentRegistration.getInstance().getRegisteredAuts().contains(autId)) {
    String message=Messages.OMStartMappingModeActionError1;
    ErrorHandlingUtil.createMessageDialog(new JBException(message,MessageIDs.E_UNEXPECTED_EXCEPTION),null,new String[]{message});
  }
 else {
    int mod=Plugin.getDefault().getPreferenceStore().getInt(Constants.MAPPING_MOD_KEY);
    int key=Plugin.getDefault().getPreferenceStore().getInt(Constants.MAPPING_TRIGGER_KEY);
    int type=Plugin.getDefault().getPreferenceStore().getInt(Constants.MAPPING_TRIGGER_TYPE_KEY);
    final String toolkit=editor.getAut().getToolkit();
    if (toolkit.equals(CommandConstants.SWT_TOOLKIT) || toolkit.equals(CommandConstants.RCP_TOOLKIT)) {
      mod=KeyConverter.convertSwingStateMask(mod);
      key=KeyConverter.convertSwingToSwt(key);
    }
    Job startObjectMappingModeJob=new StartObjectMappingModeJob(editor,autId,mod,key,category,type);
    startObjectMappingModeJob.setSystem(true);
    JobUtils.executeJob(startObjectMappingModeJob,null);
  }
}","/** 
 * @param autId The ID of the AUT for which to start the Object Mapping Mode.
 * @param editor the actual om-editor
 * @param unmappedTechNames the top-level category for unmapped Technical Names
 */
private void startMappingMode(AutIdentifier autId,ObjectMappingMultiPageEditor editor,IObjectMappingCategoryPO unmappedTechNames){
  IObjectMappingCategoryPO category=null;
  TreeViewer treeViewer=editor.getTreeViewer();
  if (treeViewer != null && ((treeViewer.getSelection() instanceof IStructuredSelection) || (treeViewer.getContentProvider() instanceof ITreeContentProvider))) {
    IStructuredSelection selection=(IStructuredSelection)treeViewer.getSelection();
    Object node;
    if (selection.size() == 1) {
      node=selection.getFirstElement();
      if (node instanceof IObjectMappingCategoryPO && OMEditorDndSupport.getSection((IObjectMappingCategoryPO)node).equals(unmappedTechNames)) {
        category=(IObjectMappingCategoryPO)node;
      }
 else       if (node instanceof IObjectMappingAssoziationPO && OMEditorDndSupport.getSection((IObjectMappingAssoziationPO)node).equals(unmappedTechNames)) {
        category=((IObjectMappingAssoziationPO)node).getCategory();
      }
      if (category != null) {
        editor.getOmEditorBP().setCategoryToCreateIn(category);
      }
 else {
        ObjectMappingEventDispatcher.setCategoryToCreateIn(null);
      }
    }
  }
  if (!AutAgentRegistration.getInstance().getRegisteredAuts().contains(autId)) {
    String message=Messages.OMStartMappingModeActionError1;
    ErrorHandlingUtil.createMessageDialog(new JBException(message,MessageIDs.E_UNEXPECTED_EXCEPTION),null,new String[]{message});
  }
 else {
    IPreferenceStore preferenceStore=Plugin.getDefault().getPreferenceStore();
    int mod=preferenceStore.getInt(Constants.MAPPING_MOD_KEY);
    int key=preferenceStore.getInt(Constants.MAPPING_TRIGGER_KEY);
    int type=preferenceStore.getInt(Constants.MAPPING_TRIGGER_TYPE_KEY);
    final String toolkit=editor.getAut().getToolkit();
    if (toolkit.equals(CommandConstants.SWT_TOOLKIT) || toolkit.equals(CommandConstants.RCP_TOOLKIT)) {
      mod=KeyConverter.convertSwingStateMask(mod);
      key=KeyConverter.convertSwingToSwt(key);
    }
    Job startObjectMappingModeJob=new StartObjectMappingModeJob(editor,autId,mod,key,category,type);
    startObjectMappingModeJob.setSystem(true);
    JobUtils.executeJob(startObjectMappingModeJob,null);
  }
}",0.8733333333333333
95728,"/** 
 * @param from mouse move start point
 * @param to from mouse move end point
 * @param firstHorizontal whether to move horizontal first
 * @param path the path from start to end
 * @param xCoords x-coordinates from start to end
 * @param yCoords y-coordinates from start to end
 * @return optimized path containing not all points (more accurate near start and end).
 */
private static List<Point> optimizePath(Point from,Point to,boolean firstHorizontal,List<Point> path,int[] xCoords,int[] yCoords){
  List<Point> optimizedPath=new ArrayList<Point>();
  int totalSteps=path.size();
  int stepFactor=10;
  int amountOfSteps=1 + Math.round(totalSteps / stepFactor);
  boolean turningPointInserted=false;
  for (int i=1; i < amountOfSteps; i++) {
    double distance=(-2d / Math.pow(amountOfSteps,3)) * Math.pow(i,3) + (3d / Math.pow(amountOfSteps,2)) * Math.pow(i,2);
    int index=Math.min((int)Math.round((distance * totalSteps)),totalSteps - 1);
    Point nextPoint=path.get(index);
    if (!turningPointInserted) {
      if (firstHorizontal) {
        float turningPointDistance=((float)xCoords.length) / totalSteps;
        if (distance > turningPointDistance) {
          optimizedPath.add(new Point(to.x,from.y));
          turningPointInserted=true;
        }
      }
 else {
        float turningPointDistance=((float)yCoords.length) / totalSteps;
        if (distance > turningPointDistance) {
          optimizedPath.add(new Point(from.x,to.y));
          turningPointInserted=true;
        }
      }
    }
    if (!optimizedPath.isEmpty() && !(optimizedPath.get(optimizedPath.size() - 1).equals(nextPoint))) {
      optimizedPath.add(nextPoint);
    }
  }
  Point end=new Point(to.x,to.y);
  if (!optimizedPath.isEmpty() && !(optimizedPath.get(optimizedPath.size() - 1).equals(end))) {
    optimizedPath.add(end);
  }
  return optimizedPath;
}","/** 
 * @param from mouse move start point
 * @param to from mouse move end point
 * @param firstHorizontal whether to move horizontal first
 * @param path the path from start to end
 * @param xCoords x-coordinates from start to end
 * @param yCoords y-coordinates from start to end
 * @return optimized path containing not all points (more accurate near start and end).
 */
private static List<Point> optimizePath(Point from,Point to,boolean firstHorizontal,List<Point> path,int[] xCoords,int[] yCoords){
  List<Point> optimizedPath=new ArrayList<Point>();
  int totalSteps=path.size();
  int stepFactor=10;
  int amountOfSteps=1 + Math.round(totalSteps / stepFactor);
  boolean turningPointInserted=false;
  for (int i=1; i < amountOfSteps; i++) {
    double distance=(-2d / Math.pow(amountOfSteps,3)) * Math.pow(i,3) + (3d / Math.pow(amountOfSteps,2)) * Math.pow(i,2);
    int index=Math.min((int)Math.round((distance * totalSteps)),totalSteps - 1);
    Point nextPoint=path.get(index);
    if (!turningPointInserted) {
      if (firstHorizontal) {
        float turningPointDistance=((float)xCoords.length) / totalSteps;
        if (distance > turningPointDistance) {
          optimizedPath.add(new Point(to.x,from.y));
          turningPointInserted=true;
        }
      }
 else {
        float turningPointDistance=((float)yCoords.length) / totalSteps;
        if (distance > turningPointDistance) {
          optimizedPath.add(new Point(from.x,to.y));
          turningPointInserted=true;
        }
      }
    }
    if (!optimizedPath.isEmpty() && !(optimizedPath.get(optimizedPath.size() - 1).equals(nextPoint))) {
      optimizedPath.add(nextPoint);
    }
  }
  Point end=new Point(to.x,to.y);
  if (optimizedPath.isEmpty() || (!(optimizedPath.get(optimizedPath.size() - 1).equals(end)))) {
    optimizedPath.add(end);
  }
  return optimizedPath;
}",0.9846732992739984
95729,"/** 
 * {@inheritDoc}
 */
public boolean isFallBackEventMatching(List eventObjects,Object comp){
  return false;
}","/** 
 * {@inheritDoc}
 */
public boolean isFallBackEventMatching(List eventObjects,Object comp){
  if (comp instanceof CCombo) {
    CCombo combo=(CCombo)comp;
    for (    Object o : eventObjects) {
      Event e=(Event)o;
      Widget w=e.widget;
      if (w instanceof Control) {
        final Control c=(Control)w;
        Composite parent=(Composite)new EventThreadQueuerSwtImpl().invokeAndWait(""String_Node_Str"",new IRunnable(){
          public Object run(){
            return c.getParent();
          }
        }
);
        if (parent == combo && isMatching(e)) {
          return true;
        }
      }
    }
  }
  return false;
}",0.262251655629139
95730,"/** 
 * Names the given hierarchy container. <br> If the managed component has a unique name, this name is used. Otherwise a name (unique for the hierachy level) is created.
 * @param hierarchyContainer the SwingHierarchyContainer to name, if SwingHierarchyContainer is null, no action is performed and no exception is thrown.
 */
protected void name(JavaFXHierarchyContainer hierarchyContainer){
  final JavaFXComponent comp=hierarchyContainer.getComponent();
  String compName;
  Object component;
  Object realComponent=comp.getRealComponent();
  if (realComponent instanceof Node) {
    component=realComponent;
    compName=((Node)component).getId();
  }
 else   if (realComponent instanceof MenuItem) {
    component=realComponent;
    compName=((MenuItem)component).getId();
  }
 else {
    compName=null;
    component=realComponent;
  }
  if (realComponent instanceof Stage) {
    List<Stage> stages=CurrentStages.getStageList();
    ArrayList<String> names=new ArrayList<>();
    for (    Stage stage : stages) {
      JavaFXHierarchyContainer c=getHierarchyContainer(stage);
      if (c != null && c != hierarchyContainer) {
        names.add(c.getName());
      }
    }
    String name=null;
    int count=0;
    while (!isUniqueName(name,names)) {
      count++;
      name=createName(realComponent,count);
    }
    comp.setName(name);
    hierarchyContainer.setName(name,true);
    return;
  }
  JavaFXHierarchyContainer hierParent=(JavaFXHierarchyContainer)hierarchyContainer.getPrnt();
  if (hierarchyContainer.getName() != null && hierarchyContainer.getName().length() != 0 && !(hierarchyContainer.getName().equals(""String_Node_Str""))) {
    if (isUniqueName(hierParent,hierarchyContainer.getName(),hierarchyContainer)) {
      return;
    }
 else     if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"" + hierarchyContainer.getName() + ""String_Node_Str"");
    }
  }
  int count=0;
  String originalName=null;
  String newName=null;
  boolean newNameGenerated=(compName == null);
  if (compName != null) {
    originalName=compName;
    newName=compName;
  }
  if (newName == null) {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(component,count);
    }
  }
 else {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(originalName,count);
    }
  }
  comp.setName(newName);
  hierarchyContainer.setName(newName,newNameGenerated);
}","/** 
 * Names the given hierarchy container. <br> If the managed component has a unique name, this name is used. Otherwise a name (unique for the hierachy level) is created.
 * @param hierarchyContainer the SwingHierarchyContainer to name, if SwingHierarchyContainer is null, no action is performed and no exception is thrown.
 */
protected void name(JavaFXHierarchyContainer hierarchyContainer){
  final JavaFXComponent comp=hierarchyContainer.getComponent();
  String compName;
  Object realComponent=comp.getRealComponent();
  if (realComponent instanceof Node) {
    compName=((Node)realComponent).getId();
  }
 else   if (realComponent instanceof MenuItem) {
    compName=((MenuItem)realComponent).getId();
  }
 else {
    compName=null;
  }
  if (realComponent instanceof Stage) {
    List<Stage> stages=CurrentStages.getStageList();
    ArrayList<String> names=new ArrayList<>();
    for (    Stage stage : stages) {
      JavaFXHierarchyContainer c=getHierarchyContainer(stage);
      if (c != null && c != hierarchyContainer) {
        names.add(c.getName());
      }
    }
    String name=null;
    int count=0;
    while (!isUniqueName(name,names)) {
      count++;
      name=createName(realComponent,count);
    }
    comp.setName(name);
    hierarchyContainer.setName(name,true);
    return;
  }
  JavaFXHierarchyContainer hierParent=(JavaFXHierarchyContainer)hierarchyContainer.getPrnt();
  if (hierarchyContainer.getName() != null && hierarchyContainer.getName().length() != 0 && !(hierarchyContainer.getName().trim().isEmpty())) {
    if (isUniqueName(hierParent,hierarchyContainer.getName(),hierarchyContainer)) {
      return;
    }
 else     if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"" + hierarchyContainer.getName() + ""String_Node_Str"");
    }
  }
  int count=0;
  String originalName=null;
  String newName=null;
  boolean newNameGenerated=(compName == null);
  if (compName != null && !(compName.isEmpty()) && !(compName.trim().isEmpty())) {
    originalName=compName;
    newName=compName;
  }
  if (newName == null) {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(realComponent,count);
    }
  }
 else {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(originalName,count);
    }
  }
  comp.setName(newName);
  hierarchyContainer.setName(newName,newNameGenerated);
}",0.8360889977546438
95731,"/** 
 * Returns the node under the given point
 * @param pos the point
 * @return the component
 */
public static Node getComponentByPos(Point2D pos){
  List<? extends Window> comps=getAssignableFrom(Window.class);
  List<Node> matches=new ArrayList<Node>();
  for (  Window window : comps) {
    if (window.isFocused() && window.isShowing()) {
      Parent root=window.getScene().getRoot();
      matches=getAllNodesforPos(root,pos,matches);
    }
  }
  List<Node> result=new ArrayList<Node>();
  for (  Node n : matches) {
    if (n.getScene() == null || !isSupported(n.getClass()) || !n.isVisible()) {
      continue;
    }
    boolean add=true;
    Parent parent=n.getParent();
    while (parent != null) {
      if (parent instanceof Skinnable) {
        if (isContentNode(n,parent)) {
          break;
        }
        Skin<?> skin=((Skinnable)parent).getSkin();
        if (skin instanceof SkinBase) {
          if (isSkinNode(n,(SkinBase<?>)skin)) {
            add=false;
            break;
          }
        }
 else {
          parent=parent.getParent();
        }
      }
 else {
        parent=parent.getParent();
      }
    }
    if (add) {
      result.add(n);
    }
  }
  if (result.size() == 0) {
    return null;
  }
  if (result.size() == 1) {
    return result.get(0);
  }
  return filterMatches(result);
}","/** 
 * Returns the node under the given point
 * @param pos the point
 * @return the component
 */
public static Node getComponentByPos(Point2D pos){
  List<? extends Window> comps=getAssignableFrom(Window.class);
  List<Node> matches=new ArrayList<Node>();
  for (  Window window : comps) {
    if (window.isFocused() && window.isShowing()) {
      Parent root=window.getScene().getRoot();
      matches=getAllNodesforPos(root,pos,matches);
    }
  }
  List<Node> result=new ArrayList<Node>();
  for (  Node n : matches) {
    if (n.getScene() == null || !isSupported(n.getClass()) || !n.isVisible()) {
      continue;
    }
    boolean add=true;
    Parent parent=n.getParent();
    while (parent != null) {
      if (parent instanceof Skinnable || isContainer(parent)) {
        if (isContentNode(n,parent)) {
          break;
        }
        Skin<?> skin=((Skinnable)parent).getSkin();
        if (skin instanceof SkinBase) {
          if (isSkinNode(n,(SkinBase<?>)skin)) {
            add=false;
            break;
          }
        }
 else {
          parent=parent.getParent();
        }
      }
 else {
        parent=parent.getParent();
      }
    }
    if (add) {
      result.add(n);
    }
  }
  if (result.size() == 0) {
    return null;
  }
  if (result.size() == 1) {
    return result.get(0);
  }
  return filterMatches(result);
}",0.99142111152555
95732,"@Override public Node[] call() throws Exception {
  if (item.isDisable()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  Parent p=(Parent)item.getParentPopup().getSkin().getNode();
  List<Node> ctxtMCont=p.getChildrenUnmodifiable();
  VBox mBox=null;
  for (  Node node : ctxtMCont) {
    if (node instanceof VBox) {
      mBox=(VBox)node;
      break;
    }
  }
  int itemIndex=item.getParentPopup().getItems().indexOf(item);
  Node itemNode=mBox.getChildrenUnmodifiable().get(itemIndex);
  Node itemOwner=item.getParentPopup().getOwnerNode();
  return new Node[]{itemNode,itemOwner};
}","@Override public Node[] call() throws Exception {
  if (item.isDisable()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  Parent p=(Parent)item.getParentPopup().getSkin().getNode();
  List<Node> ctxtMCont=p.getChildrenUnmodifiable();
  VBox mBox=null;
  for (  Node node : ctxtMCont) {
    if (node instanceof VBox) {
      mBox=(VBox)node;
      break;
    }
  }
  if (mBox == null) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.POPUP_NOT_FOUND));
  }
  int itemIndex=item.getParentPopup().getItems().indexOf(item);
  Node itemNode=mBox.getChildrenUnmodifiable().get(itemIndex);
  Node itemOwner=item.getParentPopup().getOwnerNode();
  return new Node[]{itemNode,itemOwner};
}",0.9022757697456492
95733,"/** 
 * Clicks on a menu item
 */
protected void clickMenuItem(){
  final IRobot robot=getRobot();
  final MenuItem item=getRealComponent();
  Node[] nodes=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Node[]>(){
    @Override public Node[] call() throws Exception {
      if (item.isDisable()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
      }
      Parent p=(Parent)item.getParentPopup().getSkin().getNode();
      List<Node> ctxtMCont=p.getChildrenUnmodifiable();
      VBox mBox=null;
      for (      Node node : ctxtMCont) {
        if (node instanceof VBox) {
          mBox=(VBox)node;
          break;
        }
      }
      int itemIndex=item.getParentPopup().getItems().indexOf(item);
      Node itemNode=mBox.getChildrenUnmodifiable().get(itemIndex);
      Node itemOwner=item.getParentPopup().getOwnerNode();
      return new Node[]{itemNode,itemOwner};
    }
  }
);
  if (nodes[1] != null && nodes[1] instanceof MenuButton) {
    robot.click(nodes[0],null,ClickOptions.create().setFirstHorizontal(false));
  }
 else {
    robot.click(nodes[0],null);
  }
}","/** 
 * Clicks on a menu item
 */
protected void clickMenuItem(){
  final IRobot robot=getRobot();
  final MenuItem item=getRealComponent();
  Node[] nodes=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Node[]>(){
    @Override public Node[] call() throws Exception {
      if (item.isDisable()) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
      }
      Parent p=(Parent)item.getParentPopup().getSkin().getNode();
      List<Node> ctxtMCont=p.getChildrenUnmodifiable();
      VBox mBox=null;
      for (      Node node : ctxtMCont) {
        if (node instanceof VBox) {
          mBox=(VBox)node;
          break;
        }
      }
      if (mBox == null) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.POPUP_NOT_FOUND));
      }
      int itemIndex=item.getParentPopup().getItems().indexOf(item);
      Node itemNode=mBox.getChildrenUnmodifiable().get(itemIndex);
      Node itemOwner=item.getParentPopup().getOwnerNode();
      return new Node[]{itemNode,itemOwner};
    }
  }
);
  if (nodes[1] != null && nodes[1] instanceof MenuButton) {
    robot.click(nodes[0],null,ClickOptions.create().setFirstHorizontal(false));
  }
 else {
    robot.click(nodes[0],null);
  }
}",0.9375987361769352
95734,"/** 
 * Sets the classpaths, <br> creates a ClassLoader for the AUTServer with its own classpath,<br> loads the AUTServer with the created ClassLoader <br> and calls the main-method of the AUTServer via Reflection.<br>
 * @param args Arguments of the main method{@inheritDoc}
 */
public static void main(String[] args){
  URL[] urls=PathSplitter.createUrls(args[Constants.ARG_AUTSERVER_CLASSPATH]);
  URLClassLoader autServerClassLoader;
  String useClassicClassLoaderValue=null;
  try {
    useClassicClassLoaderValue=System.getenv(ENV_VAR_USE_CLASSIC_CLASSLOADER);
  }
 catch (  Throwable t) {
  }
  if (useClassicClassLoaderValue == null) {
    useClassicClassLoaderValue=System.getProperty(ENV_VAR_USE_CLASSIC_CLASSLOADER);
  }
  if (useClassicClassLoaderValue != null) {
    autServerClassLoader=new UrlClassicClassLoader(urls,ClassLoader.getSystemClassLoader().getParent());
  }
 else {
    autServerClassLoader=new UrlDefaultClassLoader(urls,ClassLoader.getSystemClassLoader());
  }
  Thread.currentThread().setContextClassLoader(autServerClassLoader);
  try {
    Class autServerClass=autServerClassLoader.loadClass(Constants.AUTSERVER_CLASSNAME);
    Method mainMethod=autServerClass.getMethod(""String_Node_Str"",new Class[]{args.getClass()});
    mainMethod.invoke(null,new Object[]{args});
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    log.error(e.toString() + ""String_Node_Str"" + Arrays.toString(e.getStackTrace()));
    System.exit(AUTServerExitConstants.AUT_START_ERROR_CNFE);
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
    log.error(e.toString() + ""String_Node_Str"" + Arrays.toString(e.getStackTrace()));
    System.exit(AUTServerExitConstants.AUT_START_ERROR_IACCE);
  }
catch (  SecurityException e) {
    e.printStackTrace();
    log.error(e.toString() + ""String_Node_Str"" + Arrays.toString(e.getStackTrace()));
    System.exit(AUTServerExitConstants.EXIT_SECURITY_VIOLATION_REFLECTION);
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
    log.error(e.toString() + ""String_Node_Str"" + Arrays.toString(e.getStackTrace()));
    System.exit(AUTServerExitConstants.AUT_START_ERROR_NSME);
  }
catch (  IllegalArgumentException e) {
    e.printStackTrace();
    log.error(e.toString() + ""String_Node_Str"" + Arrays.toString(e.getStackTrace()));
    System.exit(AUTServerExitConstants.AUT_START_ERROR_IARGE);
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
    log.error(e.toString() + ""String_Node_Str"" + Arrays.toString(e.getStackTrace()));
    System.exit(AUTServerExitConstants.AUT_START_ERROR_INVTE);
  }
}","/** 
 * Sets the classpaths, <br> creates a ClassLoader for the AUTServer with its own classpath,<br> loads the AUTServer with the created ClassLoader <br> and calls the main-method of the AUTServer via Reflection.<br>
 * @param args Arguments of the main method{@inheritDoc}
 */
public static void main(String[] args){
  URL[] urls=PathSplitter.createUrls(args[Constants.ARG_AUTSERVER_CLASSPATH]);
  URLClassLoader autServerClassLoader;
  String useClassicClassLoaderValue=null;
  try {
    useClassicClassLoaderValue=System.getenv(ENV_VAR_USE_CLASSIC_CLASSLOADER);
  }
 catch (  Throwable t) {
  }
  if (useClassicClassLoaderValue == null) {
    useClassicClassLoaderValue=System.getProperty(ENV_VAR_USE_CLASSIC_CLASSLOADER);
  }
  if (useClassicClassLoaderValue != null) {
    autServerClassLoader=new UrlClassicClassLoader(urls,ClassLoader.getSystemClassLoader().getParent());
  }
 else {
    autServerClassLoader=new UrlDefaultClassLoader(urls,ClassLoader.getSystemClassLoader());
  }
  Thread.currentThread().setContextClassLoader(autServerClassLoader);
  try {
    Class autServerClass=autServerClassLoader.loadClass(Constants.AUTSERVER_CLASSNAME);
    Method mainMethod=autServerClass.getMethod(""String_Node_Str"",new Class[]{args.getClass()});
    mainMethod.invoke(null,new Object[]{args});
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    System.exit(AUTServerExitConstants.AUT_START_ERROR_CNFE);
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
    System.exit(AUTServerExitConstants.AUT_START_ERROR_IACCE);
  }
catch (  SecurityException e) {
    e.printStackTrace();
    System.exit(AUTServerExitConstants.EXIT_SECURITY_VIOLATION_REFLECTION);
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
    System.exit(AUTServerExitConstants.AUT_START_ERROR_NSME);
  }
catch (  IllegalArgumentException e) {
    e.printStackTrace();
    System.exit(AUTServerExitConstants.AUT_START_ERROR_IARGE);
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
    System.exit(AUTServerExitConstants.AUT_START_ERROR_INVTE);
  }
}",0.7440374787052811
95735,"/** 
 * {@inheritDoc}
 */
public Object execute(ExecutionEvent event) throws ExecutionException {
  ISelection selection=HandlerUtil.getCurrentSelection(event);
  IStructuredSelection structuredSelection=null;
  if (selection instanceof IStructuredSelection) {
    structuredSelection=(IStructuredSelection)selection;
  }
  List<ITestResultSummaryPO> selectedSummaryList=new ArrayList<ITestResultSummaryPO>(structuredSelection.size());
  if (Persistor.instance() != null) {
    List<Number> idsWithDetails=TestResultPM.computeTestresultIdsWithDetails(GeneralStorage.getInstance().getMasterSession());
    for (    Object selectedElement : structuredSelection.toArray()) {
      if (selectedElement instanceof ITestResultSummaryPO && idsWithDetails.contains(((ITestResultSummaryPO)selectedElement).getId())) {
        selectedSummaryList.add((ITestResultSummaryPO)selectedElement);
      }
    }
  }
  final ITestResultSummaryPO[] selectedSummaries=selectedSummaryList.toArray(new ITestResultSummaryPO[selectedSummaryList.size()]);
  if (selectedSummaries.length == 0) {
    MessageDialog.openInformation(HandlerUtil.getActiveShell(event),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Job exportJob=new ExportTestResultsJob(selectedSummaries,RWT.getRequest().getContextPath() + RWT.getRequest().getServletPath(),Display.getCurrent(),RWT.getResponse());
  exportJob.setUser(true);
  JobUtils.executeJob(exportJob,HandlerUtil.getActivePart(event));
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object execute(ExecutionEvent event) throws ExecutionException {
  ISelection selection=HandlerUtil.getCurrentSelection(event);
  IStructuredSelection structuredSelection=null;
  if (selection instanceof IStructuredSelection) {
    structuredSelection=(IStructuredSelection)selection;
  }
  List<ITestResultSummaryPO> selectedSummaryList=new ArrayList<ITestResultSummaryPO>(structuredSelection.size());
  if (Persistor.instance() != null) {
    for (    Object selectedElement : structuredSelection.toArray()) {
      if (selectedElement instanceof ITestResultSummaryPO) {
        ITestResultSummaryPO summary=(ITestResultSummaryPO)selectedElement;
        if (summary.hasTestResultDetails()) {
          selectedSummaryList.add(summary);
        }
      }
    }
  }
  final ITestResultSummaryPO[] selectedSummaries=selectedSummaryList.toArray(new ITestResultSummaryPO[selectedSummaryList.size()]);
  if (selectedSummaries.length == 0) {
    MessageDialog.openInformation(HandlerUtil.getActiveShell(event),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Job exportJob=new ExportTestResultsJob(selectedSummaries,RWT.getRequest().getContextPath() + RWT.getRequest().getServletPath(),Display.getCurrent(),RWT.getResponse());
  exportJob.setUser(true);
  JobUtils.executeJob(exportJob,HandlerUtil.getActivePart(event));
  return null;
}",0.8805604203152364
95736,"/** 
 * @return a list of pending summaries
 */
protected List<ITestResultSummaryPO> getPendingSummaries(){
  final List<ITestResultSummaryPO> pendingSummaries=new LinkedList<ITestResultSummaryPO>();
  Iterator<Object> iterator=getSelection().iterator();
  while (iterator.hasNext()) {
    Object o=iterator.next();
    if (o instanceof ITestResultSummaryPO) {
      ITestResultSummaryPO summary=(ITestResultSummaryPO)o;
      if (TestResultPM.hasTestResultDetails(GeneralStorage.getInstance().getMasterSession(),summary.getId()) && AlmReportStatus.NOT_YET_REPORTED.equals(summary.getAlmReportStatus())) {
        pendingSummaries.add(summary);
      }
    }
  }
  return pendingSummaries;
}","/** 
 * @return a list of pending summaries
 */
protected List<ITestResultSummaryPO> getPendingSummaries(){
  final List<ITestResultSummaryPO> pendingSummaries=new LinkedList<ITestResultSummaryPO>();
  Iterator<Object> iterator=getSelection().iterator();
  while (iterator.hasNext()) {
    Object o=iterator.next();
    if (o instanceof ITestResultSummaryPO) {
      ITestResultSummaryPO summary=(ITestResultSummaryPO)o;
      if (summary.hasTestResultDetails() && AlmReportStatus.NOT_YET_REPORTED.equals(summary.getAlmReportStatus())) {
        pendingSummaries.add(summary);
      }
    }
  }
  return pendingSummaries;
}",0.9375951293759512
95737,"/** 
 * {@inheritDoc}
 */
public void init(IWorkbench workbench,IStructuredSelection selection){
  setNeedsProgressMonitor(true);
  List<ITestResultSummaryPO> selectedSummaryList=new ArrayList<ITestResultSummaryPO>(selection.size());
  if (Persistor.instance() != null) {
    List<Number> idsWithDetails=TestResultPM.computeTestresultIdsWithDetails(GeneralStorage.getInstance().getMasterSession());
    for (    Object selectedElement : selection.toArray()) {
      if (selectedElement instanceof ITestResultSummaryPO && idsWithDetails.contains(((ITestResultSummaryPO)selectedElement).getId())) {
        selectedSummaryList.add((ITestResultSummaryPO)selectedElement);
      }
    }
  }
  m_selectedSummaries=selectedSummaryList.toArray(new ITestResultSummaryPO[selectedSummaryList.size()]);
  setWindowTitle(NLS.bind(Messages.ExportTestResultDetailsWizardWindowTitle,m_selectedSummaries.length));
}","/** 
 * {@inheritDoc}
 */
public void init(IWorkbench workbench,IStructuredSelection selection){
  setNeedsProgressMonitor(true);
  List<ITestResultSummaryPO> selectedSummaryList=new ArrayList<ITestResultSummaryPO>(selection.size());
  if (Persistor.instance() != null) {
    for (    Object selectedElement : selection.toArray()) {
      if (selectedElement instanceof ITestResultSummaryPO && ((ITestResultSummaryPO)selectedElement).hasTestResultDetails()) {
        selectedSummaryList.add((ITestResultSummaryPO)selectedElement);
      }
    }
  }
  m_selectedSummaries=selectedSummaryList.toArray(new ITestResultSummaryPO[selectedSummaryList.size()]);
  setWindowTitle(NLS.bind(Messages.ExportTestResultDetailsWizardWindowTitle,m_selectedSummaries.length));
}",0.8922335942203492
95738,"/** 
 * @param event the execution event
 * @param session the session to use
 * @throws ExecutionException
 * @return the input if found - otherwise null
 */
private IEditorInput getEditorInputFromTestResultSummaryView(ExecutionEvent event,EntityManager session) throws ExecutionException {
  IStructuredSelection structuredSel=getSelection();
  Iterator selectedTestResultSummaries=structuredSel.iterator();
  IEditorInput editorInput=null;
  while (selectedTestResultSummaries.hasNext()) {
    Object firstElement=selectedTestResultSummaries.next();
    if (firstElement instanceof ITestResultSummaryPO) {
      ITestResultSummaryPO result=(ITestResultSummaryPO)firstElement;
      if (TestResultPM.hasTestResultDetails(session,result.getId())) {
        editorInput=new TestResultEditorInput(result);
      }
    }
 else {
      LOG.info(Messages.SelectedElementIsNotTestResultSummary + StringConstants.DOT);
    }
  }
  return editorInput;
}","/** 
 * @param event the execution event
 * @param session the session to use
 * @throws ExecutionException
 * @return the input if found - otherwise null
 */
private IEditorInput getEditorInputFromTestResultSummaryView(ExecutionEvent event,EntityManager session) throws ExecutionException {
  IStructuredSelection structuredSel=getSelection();
  Iterator selectedTestResultSummaries=structuredSel.iterator();
  IEditorInput editorInput=null;
  while (selectedTestResultSummaries.hasNext()) {
    Object firstElement=selectedTestResultSummaries.next();
    if (firstElement instanceof ITestResultSummaryPO) {
      ITestResultSummaryPO result=(ITestResultSummaryPO)firstElement;
      if (result.hasTestResultDetails()) {
        editorInput=new TestResultEditorInput(result);
      }
    }
 else {
      LOG.info(Messages.SelectedElementIsNotTestResultSummary + StringConstants.DOT);
    }
  }
  return editorInput;
}",0.9785407725321889
95739,"/** 
 * {@inheritDoc} 
 */
public boolean testImpl(Object receiver,String property,Object[] args){
  final GeneralStorage instance=GeneralStorage.getInstance();
  if (instance != null) {
    final EntityManager masterSession=instance.getMasterSession();
    if (masterSession.isOpen()) {
      ITestResultSummaryPO summary=(ITestResultSummaryPO)receiver;
      if (property.equals(HAS_MONITORING_DATA_PROP)) {
        return summary.isReportWritten();
      }
      if (property.equals(HAS_TEST_RESULT_DETAILS_PROP)) {
        return TestResultPM.hasTestResultDetails(masterSession,summary.getId());
      }
 else       if (property.equals(HAS_PENDING_ALM_REPORT_PROP)) {
        return hasPendingALMReport(summary,masterSession);
      }
    }
  }
  return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean testImpl(Object receiver,String property,Object[] args){
  ITestResultSummaryPO summary=(ITestResultSummaryPO)receiver;
  if (property.equals(HAS_MONITORING_DATA_PROP)) {
    return summary.isReportWritten();
  }
  if (property.equals(HAS_TEST_RESULT_DETAILS_PROP)) {
    return summary.hasTestResultDetails();
  }
 else   if (property.equals(HAS_PENDING_ALM_REPORT_PROP)) {
    return hasPendingALMReport(summary);
  }
  return false;
}",0.6313253012048192
95740,"/** 
 * @param summary the summary to check
 * @param session the session to use
 * @return the pending status
 */
public static boolean hasPendingALMReport(ITestResultSummaryPO summary,final EntityManager session){
  return summary.isTestsuiteRelevant() && TestResultPM.hasTestResultDetails(session,summary.getId()) && summary.getAlmReportStatus() == AlmReportStatus.NOT_YET_REPORTED;
}","/** 
 * @param summary the summary to check
 * @return the pending status
 */
public static boolean hasPendingALMReport(ITestResultSummaryPO summary){
  return summary.isTestsuiteRelevant() && summary.hasTestResultDetails() && summary.getAlmReportStatus() == AlmReportStatus.NOT_YET_REPORTED;
}",0.8428781204111601
95741,"/** 
 * @param tableViewer the table viewer
 */
private void addDetailsColumn(TableViewer tableViewer){
  TableViewerColumn column=new TableViewerColumn(tableViewer,SWT.NONE);
  column.getColumn().setWidth(70);
  column.getColumn().setToolTipText(Messages.TestresultSummaryColumnDescriptionDetails);
  column.getColumn().setText(TESTRESULT_SUMMARY_DETAILS_AVAILABLE);
  column.getColumn().setMoveable(true);
  column.setLabelProvider(new TestresultSummaryViewColumnLabelProvider(){
    public Image getImage(    Object element){
      String text=String.valueOf(m_detailedSummaryIds.contains(((ITestResultSummaryPO)element).getId()));
      if (text.equals(Boolean.TRUE.toString())) {
        return IconConstants.TRSV_DETAILS;
      }
      return IconConstants.TRSV_NODETAILS;
    }
    public String getText(    Object element){
      return null;
    }
  }
);
  createMenuItem(m_headerMenu,column.getColumn());
  new ColumnViewerSorter(tableViewer,column){
    @Override protected int doCompare(    Viewer viewer,    Object e1,    Object e2){
      return getCommonsComparator().compare(m_detailedSummaryIds.contains(((ITestResultSummaryPO)e1).getId()),m_detailedSummaryIds.contains(((ITestResultSummaryPO)e2).getId()));
    }
  }
;
}","/** 
 * @param tableViewer the table viewer
 */
private void addDetailsColumn(TableViewer tableViewer){
  TableViewerColumn column=new TableViewerColumn(tableViewer,SWT.NONE);
  column.getColumn().setWidth(70);
  column.getColumn().setToolTipText(Messages.TestresultSummaryColumnDescriptionDetails);
  column.getColumn().setText(TESTRESULT_SUMMARY_DETAILS_AVAILABLE);
  column.getColumn().setMoveable(true);
  column.setLabelProvider(new TestresultSummaryViewColumnLabelProvider(){
    public Image getImage(    Object element){
      if (((ITestResultSummaryPO)element).hasTestResultDetails()) {
        return IconConstants.TRSV_DETAILS;
      }
      return IconConstants.TRSV_NODETAILS;
    }
    public String getText(    Object element){
      return null;
    }
  }
);
  createMenuItem(m_headerMenu,column.getColumn());
  new ColumnViewerSorter(tableViewer,column){
    @Override protected int doCompare(    Viewer viewer,    Object e1,    Object e2){
      return getCommonsComparator().compare(((ITestResultSummaryPO)e1).hasTestResultDetails(),((ITestResultSummaryPO)e2).hasTestResultDetails());
    }
  }
;
}",0.8947368421052632
95742,"/** 
 * refresh view
 */
public void loadViewInput(){
  m_tableViewer.getControl().getDisplay().asyncExec(new Runnable(){
    public void run(){
      List<ITestResultSummaryPO> metaList;
      try {
        int maxNoOfDays=Plugin.getDefault().getPreferenceStore().getInt(Constants.MAX_NUMBER_OF_DAYS_KEY);
        Date startTime=DateUtils.addDays(new Date(),maxNoOfDays * -1);
        metaList=TestResultSummaryPM.findAllTestResultSummaries(startTime);
        if (Persistor.instance() != null) {
          m_detailedSummaryIds=TestResultPM.computeTestresultIdsWithDetails(GeneralStorage.getInstance().getMasterSession());
        }
        if (metaList != null) {
          m_tableViewer.setInput(metaList.toArray());
        }
      }
 catch (      JBException e) {
        String msg=Messages.CantLoadMetadataFromDatabase;
        log.error(msg,e);
        showErrorDialog(msg);
      }
      ISelection s=m_tableViewer.getSelection();
      m_tableViewer.setSelection(null);
      m_tableViewer.setSelection(s);
    }
  }
);
}","/** 
 * refresh view
 */
public void loadViewInput(){
  m_tableViewer.getControl().getDisplay().asyncExec(new Runnable(){
    public void run(){
      List<ITestResultSummaryPO> metaList;
      try {
        int maxNoOfDays=Plugin.getDefault().getPreferenceStore().getInt(Constants.MAX_NUMBER_OF_DAYS_KEY);
        Date startTime=DateUtils.addDays(new Date(),maxNoOfDays * -1);
        metaList=TestResultSummaryPM.findAllTestResultSummaries(startTime);
        if (metaList != null) {
          m_tableViewer.setInput(metaList.toArray());
        }
      }
 catch (      JBException e) {
        String msg=Messages.CantLoadMetadataFromDatabase;
        log.error(msg,e);
        showErrorDialog(msg);
      }
      ISelection s=m_tableViewer.getSelection();
      m_tableViewer.setSelection(null);
      m_tableViewer.setSelection(s);
    }
  }
);
}",0.9043570669500532
95743,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public boolean isElementVisible(Viewer viewer,Object element){
  ITestResultSummaryPO m=(ITestResultSummaryPO)element;
  String metaValue=StringConstants.EMPTY;
  if (m_filterType.equals(TESTRESULT_SUMMARY_DATE)) {
    metaValue=DTF_DEFAULT.format(m.getTestsuiteDate());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTRUN_ID)) {
    metaValue=String.valueOf(m.getId());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TEST_JOB_START_TIME)) {
    Date date=m.getTestJobStartTime();
    metaValue=date != null ? DTF_LONG.format(date) : StringUtils.EMPTY;
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TEST_JOB)) {
    metaValue=m.getTestJobName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTRUN_STATE)) {
    metaValue=m.getTestRunState();
  }
 else   if (m_filterType.equals(TESTRESULT_ALM_REPORT_STATE)) {
    metaValue=getDescriptiveALMStatusDescription(m);
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_PROJECT_NAME)) {
    metaValue=m.getProjectName();
  }
 else   if (m_filterType.equals(TESTRESULT_PROJECT_VERSION)) {
    metaValue=getProjectVersion(m);
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTSUITE)) {
    metaValue=m.getTestsuiteName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTSUITE_STATUS)) {
    metaValue=m.getStatusString();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_NAME)) {
    metaValue=m.getAutName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_ID)) {
    metaValue=m.getAutId();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_CONFIG)) {
    metaValue=m.getAutConfigName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_AGENT_HOSTNAME)) {
    metaValue=m.getAutAgentName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_HOSTNAME)) {
    metaValue=m.getAutHostname();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_OS)) {
    metaValue=m.getAutOS();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TOOLKIT)) {
    metaValue=m.getAutToolkit();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_LANGUAGE)) {
    metaValue=m.getTestsuiteLanguage();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_START_TIME)) {
    metaValue=DTF_LONG.format(m.getTestsuiteStartTime());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_END_TIME)) {
    metaValue=DTF_LONG.format(m.getTestsuiteEndTime());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_DURATION)) {
    metaValue=m.getTestsuiteDuration();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_EXPECTED_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteExpectedTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_EXECUTED_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteExecutedTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_HANDLER_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteEventHandlerTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_CMD_PARAM)) {
    metaValue=m.getAutCmdParameter();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTRUN_RELEVANT)) {
    metaValue=String.valueOf(m.isTestsuiteRelevant());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_DETAILS_AVAILABLE)) {
    metaValue=String.valueOf(m_detailedSummaryIds.contains(m.getId()));
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_NUMBER_OF_FAILED_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteFailedTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_COMMENT_TITLE)) {
    metaValue=StringUtils.defaultString(m.getCommentTitle());
  }
  return wordMatches(metaValue);
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public boolean isElementVisible(Viewer viewer,Object element){
  ITestResultSummaryPO m=(ITestResultSummaryPO)element;
  String metaValue=StringConstants.EMPTY;
  if (m_filterType.equals(TESTRESULT_SUMMARY_DATE)) {
    metaValue=DTF_DEFAULT.format(m.getTestsuiteDate());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTRUN_ID)) {
    metaValue=String.valueOf(m.getId());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TEST_JOB_START_TIME)) {
    Date date=m.getTestJobStartTime();
    metaValue=date != null ? DTF_LONG.format(date) : StringUtils.EMPTY;
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TEST_JOB)) {
    metaValue=m.getTestJobName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTRUN_STATE)) {
    metaValue=m.getTestRunState();
  }
 else   if (m_filterType.equals(TESTRESULT_ALM_REPORT_STATE)) {
    metaValue=getDescriptiveALMStatusDescription(m);
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_PROJECT_NAME)) {
    metaValue=m.getProjectName();
  }
 else   if (m_filterType.equals(TESTRESULT_PROJECT_VERSION)) {
    metaValue=getProjectVersion(m);
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTSUITE)) {
    metaValue=m.getTestsuiteName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTSUITE_STATUS)) {
    metaValue=m.getStatusString();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_NAME)) {
    metaValue=m.getAutName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_ID)) {
    metaValue=m.getAutId();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_CONFIG)) {
    metaValue=m.getAutConfigName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_AGENT_HOSTNAME)) {
    metaValue=m.getAutAgentName();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_HOSTNAME)) {
    metaValue=m.getAutHostname();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_AUT_OS)) {
    metaValue=m.getAutOS();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TOOLKIT)) {
    metaValue=m.getAutToolkit();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_LANGUAGE)) {
    metaValue=m.getTestsuiteLanguage();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_START_TIME)) {
    metaValue=DTF_LONG.format(m.getTestsuiteStartTime());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_END_TIME)) {
    metaValue=DTF_LONG.format(m.getTestsuiteEndTime());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_DURATION)) {
    metaValue=m.getTestsuiteDuration();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_EXPECTED_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteExpectedTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_EXECUTED_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteExecutedTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_HANDLER_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteEventHandlerTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_CMD_PARAM)) {
    metaValue=m.getAutCmdParameter();
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_TESTRUN_RELEVANT)) {
    metaValue=String.valueOf(m.isTestsuiteRelevant());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_DETAILS_AVAILABLE)) {
    metaValue=String.valueOf(m.hasTestResultDetails());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_NUMBER_OF_FAILED_CAPS)) {
    metaValue=String.valueOf(m.getTestsuiteFailedTeststeps());
  }
 else   if (m_filterType.equals(TESTRESULT_SUMMARY_COMMENT_TITLE)) {
    metaValue=StringUtils.defaultString(m.getCommentTitle());
  }
  return wordMatches(metaValue);
}",0.9918544664675536
95744,"/** 
 * executes the complete test
 * @throws CommunicationException Error
 * @return boolean true if all testsuites completed successfully or if test execution was successful up to specified mode of no-run option
 */
public boolean executeJob() throws CommunicationException {
  String noRun=m_job.getNoRunOptMode();
  if (AbstractCmdlineClient.isNoRun()) {
    sysOut(StringConstants.TAB + NLS.bind(Messages.ExecutionControllerNoRunExecutionBegin,TestExecutionConstants.runSteps.valueOf(noRun.toUpperCase()).getDescription()));
  }
  WatchdogTimer timer=null;
  if (m_job.getTimeout() > 0) {
    timer=new WatchdogTimer(m_job.getTimeout());
    timer.start();
  }
  IClientTest clientTest=ClientTest.instance();
  if (!prepareAUTAgentConnection(clientTest)) {
    return false;
  }
 else   if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.runSteps.CAA)) {
    return true;
  }
  clientTest.setScreenshotXMLFlag(m_job.isXMLScreenshot());
  prepareDBConnection();
  if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.runSteps.CDB)) {
    return true;
  }
  loadProject();
  if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.runSteps.LP)) {
    return true;
  }
  checkTestCompleteness();
  if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.runSteps.CC)) {
    return true;
  }
  m_idle=true;
  if (m_shutdown) {
    sysOut(Messages.ReceivedShutdownCommand);
    endTestExecution();
  }
  try {
    if (m_rmiBase != null) {
      doClcService();
    }
 else {
      ensureAutIsStarted(m_job.getActualTestSuite(),m_job.getAutConfig());
      if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.runSteps.SA)) {
        return true;
      }
      doTest(m_job.getTestJob() != null);
    }
  }
 catch (  ToolkitPluginException e1) {
    sysErr(NLS.bind(Messages.ExecutionControllerAUT,Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE));
  }
  if (timer != null) {
    timer.abort();
  }
  return isNoErrorWhileExecution();
}","/** 
 * executes the complete test
 * @throws CommunicationException Error
 * @return boolean true if all testsuites completed successfully or if test execution was successful up to specified mode of no-run option
 */
public boolean executeJob() throws CommunicationException {
  String noRun=m_job.getNoRunOptMode();
  if (AbstractCmdlineClient.isNoRun()) {
    sysOut(StringConstants.TAB + NLS.bind(Messages.ExecutionControllerNoRunExecutionBegin,TestExecutionConstants.RunSteps.valueOf(noRun.toUpperCase()).getDescription()));
  }
  WatchdogTimer timer=null;
  if (m_job.getTimeout() > 0) {
    timer=new WatchdogTimer(m_job.getTimeout());
    timer.start();
  }
  IClientTest clientTest=ClientTest.instance();
  if (!prepareAUTAgentConnection(clientTest)) {
    return false;
  }
 else   if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.RunSteps.CAA)) {
    return true;
  }
  clientTest.setScreenshotXMLFlag(m_job.isXMLScreenshot());
  prepareDBConnection();
  if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.RunSteps.CDB)) {
    return true;
  }
  loadProject();
  if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.RunSteps.LP)) {
    return true;
  }
  checkTestCompleteness();
  if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.RunSteps.CC)) {
    return true;
  }
  m_idle=true;
  if (m_shutdown) {
    sysOut(Messages.ReceivedShutdownCommand);
    endTestExecution();
  }
  try {
    if (m_rmiBase != null) {
      doClcService();
    }
 else {
      ensureAutIsStarted(m_job.getActualTestSuite(),m_job.getAutConfig());
      if (TestExecution.shouldExecutionStop(noRun,TestExecutionConstants.RunSteps.SA)) {
        return true;
      }
      doTest(m_job.getTestJob() != null);
    }
  }
 catch (  ToolkitPluginException e1) {
    sysErr(NLS.bind(Messages.ExecutionControllerAUT,Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE));
  }
  if (timer != null) {
    timer.abort();
  }
  return isNoErrorWhileExecution();
}",0.997
95745,"/** 
 * {@inheritDoc}
 */
public void marshal(Object arg0,HierarchicalStreamWriter arg1,MarshallingContext arg2){
  JobConfiguration job=(JobConfiguration)arg0;
  arg1.startNode(ClientTestStrings.PROJECT);
  arg1.setValue(job.getProjectName());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.PROJECT_VERSION);
  arg1.setValue(job.getProjectVersion().toString());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.SERVER);
  arg1.setValue(job.getServer());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.PORT);
  arg1.setValue(String.valueOf(validateAndParseIntPortNumber(Integer.toString(job.getPort()))));
  arg1.endNode();
  arg1.startNode(ClientTestStrings.DBURL);
  arg1.setValue(job.getDb());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.DB_USER);
  arg1.setValue(job.getDbuser());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.DB_PW);
  arg1.setValue(job.getDbpw());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.RESULTDIR);
  arg1.setValue(job.getResultDir());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.TESTSUITE);
  arg1.setValue(job.getTestSuiteName());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.AUT_CONFIG);
  arg1.setValue(job.getAutConfigName());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.LANGUAGE);
  arg1.setValue(job.getLanguage().toString());
  arg1.endNode();
  arg1.startNode(ClientStrings.NORUN);
  arg1.setValue(TestExecutionConstants.runSteps.validateRunStep(job.getNoRunOptMode()));
  arg1.endNode();
  arg1.startNode(ClientStrings.RESULT_NAME);
  arg1.setValue(job.getFileName());
  arg1.endNode();
}","/** 
 * {@inheritDoc}
 */
public void marshal(Object arg0,HierarchicalStreamWriter arg1,MarshallingContext arg2){
  JobConfiguration job=(JobConfiguration)arg0;
  arg1.startNode(ClientTestStrings.PROJECT);
  arg1.setValue(job.getProjectName());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.PROJECT_VERSION);
  arg1.setValue(job.getProjectVersion().toString());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.SERVER);
  arg1.setValue(job.getServer());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.PORT);
  arg1.setValue(String.valueOf(validateAndParseIntPortNumber(Integer.toString(job.getPort()))));
  arg1.endNode();
  arg1.startNode(ClientTestStrings.DBURL);
  arg1.setValue(job.getDb());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.DB_USER);
  arg1.setValue(job.getDbuser());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.DB_PW);
  arg1.setValue(job.getDbpw());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.RESULTDIR);
  arg1.setValue(job.getResultDir());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.TESTSUITE);
  arg1.setValue(job.getTestSuiteName());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.AUT_CONFIG);
  arg1.setValue(job.getAutConfigName());
  arg1.endNode();
  arg1.startNode(ClientTestStrings.LANGUAGE);
  arg1.setValue(job.getLanguage().toString());
  arg1.endNode();
  arg1.startNode(ClientStrings.NORUN);
  arg1.setValue(TestExecutionConstants.RunSteps.validateRunStep(job.getNoRunOptMode()));
  arg1.endNode();
  arg1.startNode(ClientStrings.RESULT_NAME);
  arg1.setValue(job.getFileName());
  arg1.endNode();
}",0.9993722536095416
95746,"/** 
 * parses the command line parameter when the parameter startserver was set set the parsed parameter into a job object
 * @param cmd CommandLine
 */
public void parseOptionsWithServer(CommandLine cmd){
  String defaultBasePath=getDefaultDataDirPath();
  parseDBOptions(cmd);
  if (cmd.hasOption(ClientTestStrings.STARTSERVER)) {
    setServerPort(cmd.getOptionValue(ClientTestStrings.STARTSERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT)) {
    setProjectName(cmd.getOptionValue(ClientTestStrings.PROJECT));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT_VERSION)) {
    String[] numbers=cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION).split(""String_Node_Str"");
    if (numbers.length == 2) {
      try {
        ProjectVersion version=VersionStringUtils.createProjectVersion(cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION));
        m_projectVersion=version;
      }
 catch (      VersionStringUtils.MalformedVersionException e) {
      }
    }
  }
  if (cmd.hasOption(ClientTestStrings.SERVER)) {
    setServer(cmd.getOptionValue(ClientTestStrings.SERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PORT)) {
    setPort(validateAndParseIntPortNumber(cmd.getOptionValue(ClientTestStrings.PORT)));
  }
  if (cmd.hasOption(ClientTestStrings.AUTO_SCREENSHOT)) {
    setAutoScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.NO_XML_SCREENSHOT)) {
    setXMLScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.RESULTDIR)) {
    setResultDir(FileUtils.resolveAgainstBasePath(cmd.getOptionValue(ClientTestStrings.RESULTDIR),defaultBasePath));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_CONFIG)) {
    setAutConfigName(cmd.getOptionValue(ClientTestStrings.AUT_CONFIG));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_ID)) {
    String autIdString=cmd.getOptionValue(ClientTestStrings.AUT_ID);
    if (autIdString != null) {
      setAutId(new AutIdentifier(autIdString));
    }
  }
  if (cmd.hasOption(ClientTestStrings.DATA_DIR)) {
    setDataDir(FileUtils.resolveAgainstBasePath(cmd.getOptionValue(ClientTestStrings.DATA_DIR),defaultBasePath));
  }
  if (cmd.hasOption(ClientTestStrings.LANGUAGE)) {
    setLanguage(LocaleUtil.convertStrToLocale(cmd.getOptionValue(ClientTestStrings.LANGUAGE)));
  }
  if (cmd.hasOption(ClientStrings.NORUN)) {
    setNoRunOptMode(TestExecutionConstants.runSteps.validateRunStep(cmd.getOptionValue(ClientStrings.NORUN)));
  }
}","/** 
 * parses the command line parameter when the parameter startserver was set set the parsed parameter into a job object
 * @param cmd CommandLine
 */
public void parseOptionsWithServer(CommandLine cmd){
  String defaultBasePath=getDefaultDataDirPath();
  parseDBOptions(cmd);
  if (cmd.hasOption(ClientTestStrings.STARTSERVER)) {
    setServerPort(cmd.getOptionValue(ClientTestStrings.STARTSERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT)) {
    setProjectName(cmd.getOptionValue(ClientTestStrings.PROJECT));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT_VERSION)) {
    String[] numbers=cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION).split(""String_Node_Str"");
    if (numbers.length == 2) {
      try {
        ProjectVersion version=VersionStringUtils.createProjectVersion(cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION));
        m_projectVersion=version;
      }
 catch (      VersionStringUtils.MalformedVersionException e) {
      }
    }
  }
  if (cmd.hasOption(ClientTestStrings.SERVER)) {
    setServer(cmd.getOptionValue(ClientTestStrings.SERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PORT)) {
    setPort(validateAndParseIntPortNumber(cmd.getOptionValue(ClientTestStrings.PORT)));
  }
  if (cmd.hasOption(ClientTestStrings.AUTO_SCREENSHOT)) {
    setAutoScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.NO_XML_SCREENSHOT)) {
    setXMLScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.RESULTDIR)) {
    setResultDir(FileUtils.resolveAgainstBasePath(cmd.getOptionValue(ClientTestStrings.RESULTDIR),defaultBasePath));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_CONFIG)) {
    setAutConfigName(cmd.getOptionValue(ClientTestStrings.AUT_CONFIG));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_ID)) {
    String autIdString=cmd.getOptionValue(ClientTestStrings.AUT_ID);
    if (autIdString != null) {
      setAutId(new AutIdentifier(autIdString));
    }
  }
  if (cmd.hasOption(ClientTestStrings.DATA_DIR)) {
    setDataDir(FileUtils.resolveAgainstBasePath(cmd.getOptionValue(ClientTestStrings.DATA_DIR),defaultBasePath));
  }
  if (cmd.hasOption(ClientTestStrings.LANGUAGE)) {
    setLanguage(LocaleUtil.convertStrToLocale(cmd.getOptionValue(ClientTestStrings.LANGUAGE)));
  }
  if (cmd.hasOption(ClientStrings.NORUN)) {
    setNoRunOptMode(TestExecutionConstants.RunSteps.validateRunStep(cmd.getOptionValue(ClientStrings.NORUN)));
  }
}",0.9995848899958488
95747,"/** 
 * {@inheritDoc}
 * @throws IllegalArgumentException if no suitable Database Connection can be found.
 */
public Object unmarshal(HierarchicalStreamReader arg0,UnmarshallingContext arg1) throws IllegalArgumentException {
  JobConfiguration job=new JobConfiguration();
  while (arg0.hasMoreChildren()) {
    arg0.moveDown();
    if (arg0.getNodeName().equals(ClientTestStrings.PROJECT)) {
      job.setProjectName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PROJECT_VERSION)) {
      job.setProjectVersion(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.SERVER)) {
      job.setServer(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PORT)) {
      job.setPort(validateAndParseIntPortNumber(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.RESULTDIR)) {
      job.setResultDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DBURL)) {
      String dbURL=arg0.getValue();
      job.setDb(dbURL);
      DatabaseConnectionInfo connectionInfo=getConnectionInfo(dbURL);
      job.setDbscheme(connectionInfo);
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_SCHEME)) {
      job.setDbConnectionName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_USER)) {
      job.setDbuser(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_PW)) {
      job.setDbpw(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.LANGUAGE)) {
      job.setLanguage(LocaleUtil.convertStrToLocale(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_CONFIG)) {
      job.setAutConfigName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_ID)) {
      job.setAutId(new AutIdentifier(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DATA_DIR)) {
      job.setDataDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTSUITE)) {
      job.setTestSuiteName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTJOB)) {
      job.setTestJobName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientStrings.NORUN)) {
      job.setNoRunOptMode(TestExecutionConstants.runSteps.validateRunStep(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientStrings.RESULT_NAME)) {
      job.setFileName(arg0.getValue());
    }
    arg0.moveUp();
  }
  return job;
}","/** 
 * {@inheritDoc}
 * @throws IllegalArgumentException if no suitable Database Connection can be found.
 */
public Object unmarshal(HierarchicalStreamReader arg0,UnmarshallingContext arg1) throws IllegalArgumentException {
  JobConfiguration job=new JobConfiguration();
  while (arg0.hasMoreChildren()) {
    arg0.moveDown();
    if (arg0.getNodeName().equals(ClientTestStrings.PROJECT)) {
      job.setProjectName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PROJECT_VERSION)) {
      job.setProjectVersion(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.SERVER)) {
      job.setServer(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PORT)) {
      job.setPort(validateAndParseIntPortNumber(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.RESULTDIR)) {
      job.setResultDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DBURL)) {
      String dbURL=arg0.getValue();
      job.setDb(dbURL);
      DatabaseConnectionInfo connectionInfo=getConnectionInfo(dbURL);
      job.setDbscheme(connectionInfo);
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_SCHEME)) {
      job.setDbConnectionName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_USER)) {
      job.setDbuser(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_PW)) {
      job.setDbpw(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.LANGUAGE)) {
      job.setLanguage(LocaleUtil.convertStrToLocale(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_CONFIG)) {
      job.setAutConfigName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_ID)) {
      job.setAutId(new AutIdentifier(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DATA_DIR)) {
      job.setDataDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTSUITE)) {
      job.setTestSuiteName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTJOB)) {
      job.setTestJobName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientStrings.NORUN)) {
      job.setNoRunOptMode(TestExecutionConstants.RunSteps.validateRunStep(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientStrings.RESULT_NAME)) {
      job.setFileName(arg0.getValue());
    }
    arg0.moveUp();
  }
  return job;
}",0.9996338337605272
95748,"/** 
 * parses command line parameter and set them into job object
 * @param cmd CommandLine
 */
public void parseJobOptions(CommandLine cmd){
  if (cmd.hasOption(ClientTestStrings.PROJECT)) {
    setProjectName(cmd.getOptionValue(ClientTestStrings.PROJECT));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT_VERSION)) {
    try {
      ProjectVersion version=VersionStringUtils.createProjectVersion(cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION));
      m_projectVersion=version;
    }
 catch (    VersionStringUtils.MalformedVersionException e) {
    }
  }
  if (cmd.hasOption(ClientTestStrings.SERVER)) {
    setServer(cmd.getOptionValue(ClientTestStrings.SERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PORT)) {
    setPort(validateAndParseIntPortNumber(cmd.getOptionValue(ClientTestStrings.PORT)));
  }
  parseDBOptions(cmd);
  parseResultDirOptions(cmd);
  parseDataDirOptions(cmd);
  if (cmd.hasOption(ClientTestStrings.AUT_CONFIG)) {
    setAutConfigName(cmd.getOptionValue(ClientTestStrings.AUT_CONFIG));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_ID)) {
    String autIdString=cmd.getOptionValue(ClientTestStrings.AUT_ID);
    if (autIdString != null) {
      setAutId(new AutIdentifier(autIdString));
    }
  }
  if (cmd.hasOption(ClientTestStrings.LANGUAGE)) {
    setLanguage(LocaleUtil.convertStrToLocale(cmd.getOptionValue(ClientTestStrings.LANGUAGE)));
  }
  if (cmd.hasOption(ClientTestStrings.TESTSUITE)) {
    String tsName=cmd.getOptionValue(ClientTestStrings.TESTSUITE);
    List<String> tsNamesList=new ArrayList<String>();
    tsNamesList.add(tsName);
    setTestSuiteNames(tsNamesList);
  }
  if (cmd.hasOption(ClientTestStrings.TESTJOB)) {
    setTestJobName(cmd.getOptionValue(ClientTestStrings.TESTJOB));
  }
  if (cmd.hasOption(ClientTestStrings.AUTO_SCREENSHOT)) {
    setAutoScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.NO_XML_SCREENSHOT)) {
    setXMLScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.TIMEOUT)) {
    try {
      setTimeout(Integer.parseInt(cmd.getOptionValue(ClientTestStrings.TIMEOUT)));
    }
 catch (    NumberFormatException e) {
      setTimeout(Constants.INVALID_VALUE);
    }
  }
  if (cmd.hasOption(ClientStrings.NORUN)) {
    setNoRunOptMode(TestExecutionConstants.runSteps.validateRunStep(cmd.getOptionValue(ClientStrings.NORUN)));
  }
  if (cmd.hasOption(ClientStrings.RESULT_NAME)) {
    setFileName(cmd.getOptionValue(ClientStrings.RESULT_NAME));
  }
}","/** 
 * parses command line parameter and set them into job object
 * @param cmd CommandLine
 */
public void parseJobOptions(CommandLine cmd){
  if (cmd.hasOption(ClientTestStrings.PROJECT)) {
    setProjectName(cmd.getOptionValue(ClientTestStrings.PROJECT));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT_VERSION)) {
    try {
      ProjectVersion version=VersionStringUtils.createProjectVersion(cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION));
      m_projectVersion=version;
    }
 catch (    VersionStringUtils.MalformedVersionException e) {
    }
  }
  if (cmd.hasOption(ClientTestStrings.SERVER)) {
    setServer(cmd.getOptionValue(ClientTestStrings.SERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PORT)) {
    setPort(validateAndParseIntPortNumber(cmd.getOptionValue(ClientTestStrings.PORT)));
  }
  parseDBOptions(cmd);
  parseResultDirOptions(cmd);
  parseDataDirOptions(cmd);
  if (cmd.hasOption(ClientTestStrings.AUT_CONFIG)) {
    setAutConfigName(cmd.getOptionValue(ClientTestStrings.AUT_CONFIG));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_ID)) {
    String autIdString=cmd.getOptionValue(ClientTestStrings.AUT_ID);
    if (autIdString != null) {
      setAutId(new AutIdentifier(autIdString));
    }
  }
  if (cmd.hasOption(ClientTestStrings.LANGUAGE)) {
    setLanguage(LocaleUtil.convertStrToLocale(cmd.getOptionValue(ClientTestStrings.LANGUAGE)));
  }
  if (cmd.hasOption(ClientTestStrings.TESTSUITE)) {
    String tsName=cmd.getOptionValue(ClientTestStrings.TESTSUITE);
    List<String> tsNamesList=new ArrayList<String>();
    tsNamesList.add(tsName);
    setTestSuiteNames(tsNamesList);
  }
  if (cmd.hasOption(ClientTestStrings.TESTJOB)) {
    setTestJobName(cmd.getOptionValue(ClientTestStrings.TESTJOB));
  }
  if (cmd.hasOption(ClientTestStrings.AUTO_SCREENSHOT)) {
    setAutoScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.NO_XML_SCREENSHOT)) {
    setXMLScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.TIMEOUT)) {
    try {
      setTimeout(Integer.parseInt(cmd.getOptionValue(ClientTestStrings.TIMEOUT)));
    }
 catch (    NumberFormatException e) {
      setTimeout(Constants.INVALID_VALUE);
    }
  }
  if (cmd.hasOption(ClientStrings.NORUN)) {
    setNoRunOptMode(TestExecutionConstants.RunSteps.validateRunStep(cmd.getOptionValue(ClientStrings.NORUN)));
  }
  if (cmd.hasOption(ClientStrings.RESULT_NAME)) {
    setFileName(cmd.getOptionValue(ClientStrings.RESULT_NAME));
  }
}",0.99959266802444
95749,"/** 
 * @param noRunMode String noRun option mode
 * @param step current step of noRun execution
 * @return true is no run execution must be finishedreturn false if test run without no-run option or the last step of no run execution is not jet reached
 */
public static boolean shouldExecutionStop(String noRunMode,TestExecutionConstants.runSteps step){
  if (StringUtils.isEmpty(noRunMode)) {
    return false;
  }
  return noRunMode.equals(step.getStepValue());
}","/** 
 * @param noRunMode String noRun option mode
 * @param step current step of noRun execution
 * @return true is no run execution must be finishedreturn false if test run without no-run option or the last step of no run execution is not jet reached
 */
public static boolean shouldExecutionStop(String noRunMode,TestExecutionConstants.RunSteps step){
  if (StringUtils.isEmpty(noRunMode)) {
    return false;
  }
  return noRunMode.equals(step.getStepValue());
}",0.9978494623655914
95750,"/** 
 * @param testSuite testSuite
 * @param locale language valid for testexecution
 * @param monitor the progress monitor to use
 * @param noRunOptMode the value of no-run option argument if it was specified, null otherwise
 */
private void startTestSuite(ITestSuitePO testSuite,Locale locale,IProgressMonitor monitor,String noRunOptMode){
  Validate.notNull(testSuite,""String_Node_Str"");
  ICapPO firstCap=null;
  m_expectedNumberOfSteps=0;
  m_trav=new Traverser(testSuite,locale);
  try {
    monitor.subTask(Messages.StartingTestSuite_resolvingTestStepsToExecute);
    monitor.subTask(Messages.StartingTestSuite_buildingTestExecutionTree);
    Traverser copier=new Traverser(testSuite,locale);
    ResultTreeBuilder resultTreeBuilder=new ResultTreeBuilder(copier);
    copier.addExecStackModificationListener(resultTreeBuilder);
    ICapPO iterNode=copier.next();
    while (iterNode != null) {
      iterNode=copier.next();
      m_expectedNumberOfSteps++;
    }
    Map<String,String> autConfigMap=getConnectedAUTsConfigMap();
    resetMonitoringData(autConfigMap,monitor);
    if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.runSteps.BT)) {
      endTestExecution();
      return;
    }
    TestResultBP.getInstance().setResultTestModel(new TestResult(resultTreeBuilder.getRootNode(),autConfigMap));
    initTestExecutionMessage(autConfigMap,monitor);
    m_resultTreeTracker=new ResultTreeTracker(resultTreeBuilder.getRootNode(),m_externalTestDataBP);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,ClientTestImpl.TEST_SUITE_EXECUTION_RELATIVE_WORK_AMOUNT);
    subMonitor.beginTask(NLS.bind(Messages.StartWorkingWithTestSuite,testSuite.getName()),m_expectedNumberOfSteps);
    m_stepCounter=new StepCounter(subMonitor);
    addTestExecutionListener();
    setStepSpeed(testSuite.getStepDelay());
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_RESULT_TREE_READY));
    monitor.subTask(NLS.bind(Messages.StartingTestSuite,testSuite.getName()));
    firstCap=m_trav.next();
  }
 catch (  JBException e) {
    LOG.error(Messages.IncompleteTestdata,e);
    fireError(e);
  }
  if (firstCap != null) {
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_START));
    processCap(firstCap);
  }
 else {
    endTestExecution();
  }
}","/** 
 * @param testSuite testSuite
 * @param locale language valid for testexecution
 * @param monitor the progress monitor to use
 * @param noRunOptMode the value of no-run option argument if it was specified, null otherwise
 */
private void startTestSuite(ITestSuitePO testSuite,Locale locale,IProgressMonitor monitor,String noRunOptMode){
  Validate.notNull(testSuite,""String_Node_Str"");
  ICapPO firstCap=null;
  m_expectedNumberOfSteps=0;
  m_trav=new Traverser(testSuite,locale);
  try {
    monitor.subTask(Messages.StartingTestSuite_resolvingTestStepsToExecute);
    monitor.subTask(Messages.StartingTestSuite_buildingTestExecutionTree);
    Traverser copier=new Traverser(testSuite,locale);
    ResultTreeBuilder resultTreeBuilder=new ResultTreeBuilder(copier);
    copier.addExecStackModificationListener(resultTreeBuilder);
    ICapPO iterNode=copier.next();
    while (iterNode != null) {
      iterNode=copier.next();
      m_expectedNumberOfSteps++;
    }
    Map<String,String> autConfigMap=getConnectedAUTsConfigMap();
    resetMonitoringData(autConfigMap,monitor);
    if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.RunSteps.BT)) {
      endTestExecution();
      return;
    }
    TestResultBP.getInstance().setResultTestModel(new TestResult(resultTreeBuilder.getRootNode(),autConfigMap));
    initTestExecutionMessage(autConfigMap,monitor);
    m_resultTreeTracker=new ResultTreeTracker(resultTreeBuilder.getRootNode(),m_externalTestDataBP);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,ClientTestImpl.TEST_SUITE_EXECUTION_RELATIVE_WORK_AMOUNT);
    subMonitor.beginTask(NLS.bind(Messages.StartWorkingWithTestSuite,testSuite.getName()),m_expectedNumberOfSteps);
    m_stepCounter=new StepCounter(subMonitor);
    addTestExecutionListener();
    setStepSpeed(testSuite.getStepDelay());
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_RESULT_TREE_READY));
    monitor.subTask(NLS.bind(Messages.StartingTestSuite,testSuite.getName()));
    firstCap=m_trav.next();
  }
 catch (  JBException e) {
    LOG.error(Messages.IncompleteTestdata,e);
    fireError(e);
  }
  if (firstCap != null) {
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_START));
    processCap(firstCap);
  }
 else {
    endTestExecution();
  }
}",0.9995759117896522
95751,"/** 
 * This method executes the given Test Suite
 * @param testSuite the TestSuitePO that will be tested
 * @param locale Locale
 * @param autoScreenshot whether screenshots should be automatically taken in case of test execution errors
 * @param autId The ID of the Running AUT on which the test will take place.
 * @param externalVars a map of externally set variables; may be <code>null</code>
 * @param summary The Test Result Summary for the executed test.  Must not be <code>null</code>.
 * @param monitor the monitor to use
 * @param noRunOptMode The value of no-run option argument if it was specified, null otherwise
 */
public void executeTestSuite(ITestSuitePO testSuite,Locale locale,AutIdentifier autId,boolean autoScreenshot,Map<String,String> externalVars,ITestResultSummaryPO summary,final IProgressMonitor monitor,String noRunOptMode){
  m_stopped=false;
  m_autoScreenshot=autoScreenshot;
  setPaused(false);
  Validate.notNull(testSuite,Messages.TestsuiteMustNotBeNull);
  m_executionLanguage=locale;
  monitor.subTask(NLS.bind(Messages.PreparingTestSuiteExecution,testSuite.getName()));
  m_externalTestDataBP.clearExternalData();
  if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.runSteps.PTE)) {
    monitor.setCanceled(true);
    return;
  }
  try {
    if (AUTConnection.getInstance().connectToAut(autId,new SubProgressMonitor(monitor,0))) {
      if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.runSteps.CA)) {
        endTestExecution();
        return;
      }
      summary.setAutHostname(AUTConnection.getInstance().getCommunicator().getConnection().getAddress().getCanonicalHostName());
      summary.setAutAgentName(AutAgentConnection.getInstance().getCommunicator().getHostName());
      monitor.subTask(Messages.StartingTestSuite_resolvingPredefinedVariables);
      m_varStore.storeEnvironmentVariables();
      storePredefinedVariables(m_varStore,testSuite);
      storeExternallyDefinedVariables(m_varStore,externalVars);
      if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.runSteps.RPV)) {
        endTestExecution();
        return;
      }
      startTestSuite(testSuite,locale,monitor,noRunOptMode);
      final AtomicBoolean testSuiteFinished=new AtomicBoolean();
      ClientTest.instance().addTestExecutionEventListener(new ITestExecutionEventListener(){
        public void endTestExecution(){
          try {
            AUTConnection.getInstance().close();
          }
 catch (          ConnectionException e) {
          }
          ClientTest.instance().removeTestExecutionEventListener(this);
          testSuiteFinished.set(true);
        }
        public void stateChanged(        TestExecutionEvent event){
        }
      }
);
      while (!testSuiteFinished.get()) {
        TimeUtil.delay(250);
      }
    }
 else {
      handleNoConnectionToAUT(testSuite,autId);
    }
  }
 catch (  ConnectionException e) {
    LOG.error(Messages.UnableToConnectToAUT + StringConstants.DOT,e);
  }
}","/** 
 * This method executes the given Test Suite
 * @param testSuite the TestSuitePO that will be tested
 * @param locale Locale
 * @param autoScreenshot whether screenshots should be automatically taken in case of test execution errors
 * @param autId The ID of the Running AUT on which the test will take place.
 * @param externalVars a map of externally set variables; may be <code>null</code>
 * @param summary The Test Result Summary for the executed test.  Must not be <code>null</code>.
 * @param monitor the monitor to use
 * @param noRunOptMode The value of no-run option argument if it was specified, null otherwise
 */
public void executeTestSuite(ITestSuitePO testSuite,Locale locale,AutIdentifier autId,boolean autoScreenshot,Map<String,String> externalVars,ITestResultSummaryPO summary,final IProgressMonitor monitor,String noRunOptMode){
  m_stopped=false;
  m_autoScreenshot=autoScreenshot;
  setPaused(false);
  Validate.notNull(testSuite,Messages.TestsuiteMustNotBeNull);
  m_executionLanguage=locale;
  monitor.subTask(NLS.bind(Messages.PreparingTestSuiteExecution,testSuite.getName()));
  m_externalTestDataBP.clearExternalData();
  if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.RunSteps.PTE)) {
    monitor.setCanceled(true);
    return;
  }
  try {
    if (AUTConnection.getInstance().connectToAut(autId,new SubProgressMonitor(monitor,0))) {
      if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.RunSteps.CA)) {
        endTestExecution();
        return;
      }
      summary.setAutHostname(AUTConnection.getInstance().getCommunicator().getConnection().getAddress().getCanonicalHostName());
      summary.setAutAgentName(AutAgentConnection.getInstance().getCommunicator().getHostName());
      monitor.subTask(Messages.StartingTestSuite_resolvingPredefinedVariables);
      m_varStore.storeEnvironmentVariables();
      storePredefinedVariables(m_varStore,testSuite);
      storeExternallyDefinedVariables(m_varStore,externalVars);
      if (TestExecution.shouldExecutionStop(noRunOptMode,TestExecutionConstants.RunSteps.RPV)) {
        endTestExecution();
        return;
      }
      startTestSuite(testSuite,locale,monitor,noRunOptMode);
      final AtomicBoolean testSuiteFinished=new AtomicBoolean();
      ClientTest.instance().addTestExecutionEventListener(new ITestExecutionEventListener(){
        public void endTestExecution(){
          try {
            AUTConnection.getInstance().close();
          }
 catch (          ConnectionException e) {
          }
          ClientTest.instance().removeTestExecutionEventListener(this);
          testSuiteFinished.set(true);
        }
        public void stateChanged(        TestExecutionEvent event){
        }
      }
);
      while (!testSuiteFinished.get()) {
        TimeUtil.delay(250);
      }
    }
 else {
      handleNoConnectionToAUT(testSuite,autId);
    }
  }
 catch (  ConnectionException e) {
    LOG.error(Messages.UnableToConnectToAUT + StringConstants.DOT,e);
  }
}",0.9990069513406156
95752,"/** 
 * gets the default no run mode
 * @return the default no run mode
 */
private static String getDefaultNoRunMode(){
  final runSteps defaultMode=TestExecutionConstants.runSteps.CC;
  return defaultMode.getStepValue();
}","/** 
 * gets the default no run mode
 * @return the default no run mode
 */
private static String getDefaultNoRunMode(){
  final RunSteps defaultMode=TestExecutionConstants.RunSteps.CC;
  return defaultMode.getStepValue();
}",0.9910714285714286
95753,"/** 
 * validates the argument of no-run option sets default value of no-run option if no argument is given
 * @param runStepValue the value to be validated
 * @return true the given value if it is valid,default value if no argument is given and EXIT_INVALID_ARGUMENT (""invalid argument"") if the argument is invalid
 */
public static String validateRunStep(String runStepValue){
  if (StringUtils.isEmpty(runStepValue)) {
    return getDefaultNoRunMode();
  }
  for (  runSteps noRunOptMode : TestExecutionConstants.runSteps.values()) {
    if (noRunOptMode.getStepValue().equals(runStepValue)) {
      return runStepValue;
    }
  }
  return EXIT_INVALID_ARGUMENT;
}","/** 
 * validates the argument of no-run option sets default value of no-run option if no argument is given
 * @param runStepValue the value to be validated
 * @return true the given value if it is valid,default value if no argument is given and EXIT_INVALID_ARGUMENT (""invalid argument"") if the argument is invalid
 */
public static String validateRunStep(String runStepValue){
  if (StringUtils.isEmpty(runStepValue)) {
    return getDefaultNoRunMode();
  }
  for (  RunSteps noRunOptMode : TestExecutionConstants.RunSteps.values()) {
    if (noRunOptMode.getStepValue().equals(runStepValue)) {
      return runStepValue;
    }
  }
  return EXIT_INVALID_ARGUMENT;
}",0.9970014992503748
95754,"/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  DirectoryDialog directoryDialog=createDirectoryDialog();
  genPath=directoryDialog.open();
  if (genPath != null) {
    org.eclipse.jubula.client.ui.rcp.utils.Utils.storeLastDirPath(directoryDialog.getFilterPath());
    File directory=new File(genPath);
    if (directory.list().length == 0) {
      InputDialog inputDialog=new InputDialog(getActiveShell(),Messages.InputDialogName,Messages.InputDialogMessage,StringConstants.EMPTY,new PackageNameValidator());
      if (inputDialog.open() == Window.OK) {
        genPackage=inputDialog.getValue();
        IWorkbench workbench=PlatformUI.getWorkbench();
        try {
          workbench.getProgressService().run(true,true,new ConvertProjectOperation());
        }
 catch (        InvocationTargetException|InterruptedException e) {
          LOG.error(Messages.ErrorWhileConverting,e);
        }
      }
    }
 else {
      ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NON_EMPTY_DIRECTORY);
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  language=WorkingLanguageBP.getInstance().getWorkingLanguage();
  DirectoryDialog directoryDialog=createDirectoryDialog();
  genPath=directoryDialog.open();
  if (genPath != null) {
    org.eclipse.jubula.client.ui.rcp.utils.Utils.storeLastDirPath(directoryDialog.getFilterPath());
    File directory=new File(genPath);
    if (directory.list().length == 0) {
      InputDialog inputDialog=new InputDialog(getActiveShell(),Messages.InputDialogName,Messages.InputDialogMessage,StringConstants.EMPTY,new PackageNameValidator());
      if (inputDialog.open() == Window.OK) {
        genPackage=inputDialog.getValue();
        IWorkbench workbench=PlatformUI.getWorkbench();
        try {
          workbench.getProgressService().run(true,true,new ConvertProjectOperation());
        }
 catch (        InvocationTargetException|InterruptedException e) {
          LOG.error(Messages.ErrorWhileConverting,e);
        }
      }
    }
 else {
      ErrorHandlingUtil.createMessageDialog(MessageIDs.E_NON_EMPTY_DIRECTORY);
    }
  }
  return null;
}",0.9700322729368372
95755,"/** 
 * @param monitor the monitor to use
 * @param taskIdToALMChange the comment mapping
 * @return status
 */
private IStatus reportToALM(IProgressMonitor monitor,Map<String,List<ALMChange>> taskIdToALMChange){
  String repoLabel=m_reportProps.getALMRepositoryName();
  boolean failed=false;
  Set<String> taskIds=taskIdToALMChange.keySet();
  int taskAmount=taskIds.size();
  IProgressConsole c=getConsole();
  int successCount=0;
  if (taskAmount > 0) {
    String out=NLS.bind(Messages.ReportToALMJob,taskAmount,repoLabel);
    monitor.beginTask(out,taskAmount);
    c.writeLine(out);
    int overallCommentCount=0;
    int overallFieldUpdateCount=0;
    for (    String taskId : taskIds) {
      List<ALMChange> changes=taskIdToALMChange.get(taskId);
      List<CommentEntry> comments=new LinkedList<CommentEntry>();
      List<FieldUpdate> fieldUpdates=new LinkedList<FieldUpdate>();
      split(changes,comments,fieldUpdates);
      boolean commentingSucceeded=true;
      IStatus fieldUpdateStatus=Status.OK_STATUS;
      int commentAmount=comments.size();
      if (commentAmount > 0) {
        writeStatus(c,taskId,commentAmount,Messages.ReportingComment,Messages.ReportingComments);
        commentingSucceeded=ALMAccess.createComment(repoLabel,taskId,comments,monitor);
        if (!commentingSucceeded) {
          failed=true;
          c.writeErrorLine(NLS.bind(Messages.ReportingTaskFailed,taskId));
        }
 else {
          overallCommentCount+=commentAmount;
        }
      }
      int fieldUpdateAmount=fieldUpdates.size();
      if (fieldUpdateAmount > 0) {
        writeStatus(c,taskId,fieldUpdateAmount,Messages.ReportingFieldUpdate,Messages.ReportingFieldUpdates);
        fieldUpdateStatus=ALMAccess.updateFields(repoLabel,taskId,fieldUpdates,monitor);
        if (!fieldUpdateStatus.isOK()) {
          failed=true;
          c.writeErrorLine(fieldUpdateStatus.getMessage());
          c.writeErrorLine(NLS.bind(Messages.ReportingTaskFailed,taskId));
        }
 else {
          overallFieldUpdateCount+=fieldUpdateAmount;
        }
      }
      if (fieldUpdateStatus.isOK() && commentingSucceeded) {
        successCount++;
      }
      monitor.worked(1);
    }
    c.writeLine(NLS.bind(Messages.ReportToALMJobDone,new Integer[]{overallCommentCount,overallFieldUpdateCount,successCount,taskAmount}));
    monitor.done();
  }
 else {
    c.writeLine(Messages.NothingToReport);
  }
  if (!failed || successCount > 0) {
    return Status.OK_STATUS;
  }
  return new Status(IStatus.ERROR,Activator.ID,""String_Node_Str"");
}","/** 
 * @param monitor the monitor to use
 * @param taskIdToALMChange the comment mapping
 * @return status
 */
private IStatus reportToALM(IProgressMonitor monitor,Map<String,List<ALMChange>> taskIdToALMChange){
  String repoLabel=m_reportProps.getALMRepositoryName();
  boolean failed=false;
  Set<String> taskIds=taskIdToALMChange.keySet();
  int taskAmount=taskIds.size();
  IProgressConsole c=getConsole();
  int successCount=0;
  if (taskAmount > 0) {
    String out=NLS.bind(Messages.ReportToALMJob,taskAmount,repoLabel);
    monitor.beginTask(out,taskAmount);
    c.writeLine(out);
    int overallCommentCount=0;
    int overallFieldUpdateCount=0;
    for (    String taskId : taskIds) {
      List<ALMChange> changes=taskIdToALMChange.get(taskId);
      List<CommentEntry> comments=new LinkedList<CommentEntry>();
      List<FieldUpdate> fieldUpdates=new LinkedList<FieldUpdate>();
      split(changes,comments,fieldUpdates);
      boolean commentingSucceeded=true;
      IStatus fieldUpdateStatus=Status.OK_STATUS;
      int commentAmount=comments.size();
      if (commentAmount > 0) {
        writeStatus(c,taskId,commentAmount,Messages.ReportingComment,Messages.ReportingComments);
        commentingSucceeded=ALMAccess.createComment(repoLabel,taskId,comments,monitor);
        if (!commentingSucceeded) {
          failed=true;
          c.writeErrorLine(NLS.bind(Messages.ReportingTaskFailed,taskId));
        }
 else {
          overallCommentCount+=commentAmount;
        }
      }
      int fieldUpdateAmount=fieldUpdates.size();
      if (fieldUpdateAmount > 0) {
        writeStatus(c,taskId,fieldUpdateAmount,Messages.ReportingFieldUpdate,Messages.ReportingFieldUpdates);
        fieldUpdateStatus=ALMAccess.updateFields(repoLabel,taskId,fieldUpdates,monitor);
        if (!fieldUpdateStatus.isOK()) {
          failed=true;
          c.writeErrorLine(fieldUpdateStatus.getMessage());
          c.writeErrorLine(NLS.bind(Messages.ReportingTaskFailed,taskId));
          if (fieldUpdateStatus.getSeverity() == IStatus.CANCEL) {
            break;
          }
        }
 else {
          overallFieldUpdateCount+=fieldUpdateAmount;
        }
      }
      if (fieldUpdateStatus.isOK() && commentingSucceeded) {
        successCount++;
      }
      monitor.worked(1);
    }
    c.writeLine(NLS.bind(Messages.ReportToALMJobDone,new Integer[]{overallCommentCount,overallFieldUpdateCount,successCount,taskAmount}));
    monitor.done();
  }
 else {
    c.writeLine(Messages.NothingToReport);
  }
  if (!failed || successCount > 0) {
    return Status.OK_STATUS;
  }
  return new Status(IStatus.ERROR,Activator.ID,""String_Node_Str"");
}",0.9811538461538462
95756,"/** 
 * creates the project name field
 * @param composite parent
 * @param withName true if the name field should be created
 */
private void createNameField(Composite composite,boolean withName){
  if (!withName) {
    return;
  }
  GridData gridData=newGridData();
  new Label(composite,SWT.NONE).setText(Messages.SaveProjectAsActionLabel);
  m_projectNameField=new CheckedProjectNameText(composite,SWT.SINGLE | SWT.BORDER);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_projectNameField);
  gridData.widthHint=0;
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=GridData.FILL;
  m_projectNameField.setLayoutData(gridData);
  m_projectNameField.setText(StringUtils.defaultString(null));
  LayoutUtil.setMaxChar(m_projectNameField,m_length);
  m_projectNameField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
}","/** 
 * creates the project name field
 * @param composite parent
 * @param withName true if the name field should be created
 */
private void createNameField(Composite composite,boolean withName){
  if (!withName) {
    return;
  }
  GridData gridData=newGridData();
  new Label(composite,SWT.NONE).setText(Messages.SaveProjectAsActionLabel);
  m_projectNameField=new CheckedProjectNameText(composite,SWT.SINGLE | SWT.BORDER);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_projectNameField);
  gridData.widthHint=0;
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=GridData.FILL;
  m_projectNameField.setLayoutData(gridData);
  m_projectNameField.setText(StringUtils.defaultString(null));
  m_projectNameField.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  LayoutUtil.setMaxChar(m_projectNameField,m_length);
  m_projectNameField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
}",0.956122448979592
95757,"/** 
 * @param area The composite. creates the text field to edit the TestSuite name.
 * @param version the inital version for the fields
 */
private void createVersionFields(Composite area,ProjectVersion version){
  new Label(area,SWT.NONE).setText(Messages.CreateNewProjectVersionActionVersionNumbers);
  m_majorVersionField=new CheckedIntText(area,SWT.SINGLE | SWT.BORDER,true,0,Integer.MAX_VALUE);
  GridData gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_majorVersionField);
  gridData.widthHint=Dialog.convertWidthInCharsToPixels(LayoutUtil.getFontMetrics(m_majorVersionField),6);
  m_majorVersionField.setLayoutData(gridData);
  m_majorVersionField.setText(version.getMajorNumber() != null ? String.valueOf(version.getMajorNumber()) : StringConstants.EMPTY);
  LayoutUtil.setMaxChar(m_majorVersionField,m_length);
  m_majorVersionField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
  m_minorVersionField=new CheckedIntText(area,SWT.SINGLE | SWT.BORDER,true,0,Integer.MAX_VALUE);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_minorVersionField);
  gridData.widthHint=Dialog.convertWidthInCharsToPixels(LayoutUtil.getFontMetrics(m_minorVersionField),6);
  m_minorVersionField.setLayoutData(gridData);
  m_minorVersionField.setText(version.getMinorNumber() != null ? String.valueOf(version.getMinorNumber()) : StringConstants.EMPTY);
  LayoutUtil.setMaxChar(m_minorVersionField,m_length);
  m_minorVersionField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
  m_microVersionField=new CheckedIntText(area,SWT.SINGLE | SWT.BORDER,true,0,Integer.MAX_VALUE);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_microVersionField);
  gridData.widthHint=Dialog.convertWidthInCharsToPixels(LayoutUtil.getFontMetrics(m_microVersionField),11);
  m_microVersionField.setLayoutData(gridData);
  m_microVersionField.setText(version.getMicroNumber() != null ? String.valueOf(version.getMicroNumber()) : StringConstants.EMPTY);
  LayoutUtil.setMaxChar(m_microVersionField,m_length);
  m_microVersionField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
  new Label(area,SWT.NONE).setText(Messages.CreateNewProjectVersionActionQualifierLabel);
  m_versionQualifierField=new Text(area,SWT.SINGLE | SWT.BORDER);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_versionQualifierField);
  gridData.widthHint=0;
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=GridData.FILL;
  m_versionQualifierField.setLayoutData(gridData);
  m_versionQualifierField.setText(StringUtils.defaultIfBlank(version.getVersionQualifier(),StringConstants.EMPTY));
  LayoutUtil.setMaxChar(m_versionQualifierField,m_length);
  m_versionQualifierField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
}","/** 
 * @param area The composite. creates the text field to edit the TestSuite name.
 * @param version the inital version for the fields
 */
private void createVersionFields(Composite area,ProjectVersion version){
  new Label(area,SWT.NONE).setText(Messages.CreateNewProjectVersionActionVersionNumbers);
  m_majorVersionField=new CheckedIntText(area,SWT.SINGLE | SWT.BORDER,true,0,Integer.MAX_VALUE);
  GridData gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_majorVersionField);
  gridData.widthHint=Dialog.convertWidthInCharsToPixels(LayoutUtil.getFontMetrics(m_majorVersionField),6);
  m_majorVersionField.setLayoutData(gridData);
  m_majorVersionField.setText(version.getMajorNumber() != null ? String.valueOf(version.getMajorNumber()) : StringConstants.EMPTY);
  LayoutUtil.setMaxChar(m_majorVersionField,m_length);
  m_majorVersionField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
  m_majorVersionField.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  m_minorVersionField=new CheckedIntText(area,SWT.SINGLE | SWT.BORDER,true,0,Integer.MAX_VALUE);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_minorVersionField);
  gridData.widthHint=Dialog.convertWidthInCharsToPixels(LayoutUtil.getFontMetrics(m_minorVersionField),6);
  m_minorVersionField.setLayoutData(gridData);
  m_minorVersionField.setText(version.getMinorNumber() != null ? String.valueOf(version.getMinorNumber()) : StringConstants.EMPTY);
  LayoutUtil.setMaxChar(m_minorVersionField,m_length);
  m_minorVersionField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
  m_minorVersionField.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  m_microVersionField=new CheckedIntText(area,SWT.SINGLE | SWT.BORDER,true,0,Integer.MAX_VALUE);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_microVersionField);
  gridData.widthHint=Dialog.convertWidthInCharsToPixels(LayoutUtil.getFontMetrics(m_microVersionField),11);
  m_microVersionField.setLayoutData(gridData);
  m_microVersionField.setText(version.getMicroNumber() != null ? String.valueOf(version.getMicroNumber()) : StringConstants.EMPTY);
  LayoutUtil.setMaxChar(m_microVersionField,m_length);
  m_microVersionField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
  m_microVersionField.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  new Label(area,SWT.NONE).setText(Messages.CreateNewProjectVersionActionQualifierLabel);
  m_versionQualifierField=new Text(area,SWT.SINGLE | SWT.BORDER);
  gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_versionQualifierField);
  gridData.widthHint=0;
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=GridData.FILL;
  m_versionQualifierField.setLayoutData(gridData);
  m_versionQualifierField.setText(StringUtils.defaultIfBlank(version.getVersionQualifier(),StringConstants.EMPTY));
  LayoutUtil.setMaxChar(m_versionQualifierField,m_length);
  m_versionQualifierField.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      modifyVersionFieldAction();
    }
  }
);
  m_versionQualifierField.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
}",0.9464557347125038
95758,"/** 
 * Checks all available projects
 * @return list of all projects
 */
private List<IProjectPO> checkAllAvailableProjects(){
  List<IProjectPO> projList=null;
  try {
    projList=ProjectPM.findAllProjects();
    if (projList.isEmpty()) {
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          ErrorHandlingUtil.createMessageDialog(MessageIDs.I_NO_PROJECT_IN_DB);
        }
      }
);
      Plugin.stopLongRunning();
    }
 else {
      SortedMap<String,List<String>> projNameToVersionMap=new TreeMap<String,List<String>>();
      for (      IProjectPO proj : projList) {
        String projName=proj.getName();
        String projVersion=proj.getVersionString();
        if (!projNameToVersionMap.containsKey(projName)) {
          projNameToVersionMap.put(projName,new ArrayList<String>());
        }
        projNameToVersionMap.get(projName).add(projVersion);
      }
    }
  }
 catch (  final JBException e) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        ErrorHandlingUtil.createMessageDialog(e,null,null);
      }
    }
);
  }
  return projList;
}","/** 
 * Checks all available projects
 * @return list of all projects
 */
private List<IProjectPO> checkAllAvailableProjects(){
  List<IProjectPO> projList=null;
  try {
    projList=ProjectPM.findAllProjects();
    if (projList.isEmpty()) {
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          ErrorHandlingUtil.createMessageDialog(MessageIDs.I_NO_PROJECT_IN_DB);
        }
      }
);
      Plugin.stopLongRunning();
    }
 else {
      SortedMap<String,List<String>> projNameToVersionMap=new TreeMap<String,List<String>>();
      for (      IProjectPO proj : projList) {
        String projName=proj.getName();
        String projVersion=proj.getVersionString();
        if (!StringUtils.isBlank(projName) && !projNameToVersionMap.containsKey(projName)) {
          projNameToVersionMap.put(projName,new ArrayList<String>());
        }
        projNameToVersionMap.get(projName).add(projVersion);
      }
    }
  }
 catch (  final JBException e) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        ErrorHandlingUtil.createMessageDialog(e,null,null);
      }
    }
);
  }
  return projList;
}",0.985178727114211
95759,"/** 
 * Opens the dialog to change the project name
 * @return the dialog
 */
private VersionDialog openInputDialog(){
  VersionDialog dialog=new VersionDialog(getActiveShell(),Messages.SaveProjectAsActionTitle,Messages.SaveProjectAsActionMessage,IconConstants.BIG_PROJECT_STRING,Messages.SaveProjectAsActionShellTitle,true){
    /** 
 * {@inheritDoc}
 */
    protected boolean isInputAllowed(){
      final String newProjectName=getProjectNameFieldValue();
      boolean isInputAllowed=true;
      if (!ProjectNameBP.isValidProjectName(newProjectName,true)) {
        setErrorMessage(Messages.SaveProjectAsActionInvalidName);
        isInputAllowed=false;
      }
      if (ProjectPM.doesProjectNameExist(newProjectName)) {
        setErrorMessage(Messages.SaveProjectAsActionDoubleOrInvalidName);
        isInputAllowed=false;
      }
      return isInputAllowed;
    }
    /** 
 * {@inheritDoc}
 */
    protected void okPressed(){
      if (ProjectPM.doesProjectNameExist(getProjectNameFieldValue())) {
        ErrorHandlingUtil.createMessageDialog(MessageIDs.E_PROJECTNAME_ALREADY_EXISTS,new Object[]{getProjectNameFieldValue()},null);
        return;
      }
      super.okPressed();
    }
  }
;
  dialog.setHelpAvailable(true);
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.DIALOG_PROJECT_SAVEAS);
  dialog.open();
  return dialog;
}","/** 
 * Opens the dialog to change the project name
 * @return the dialog
 */
private VersionDialog openInputDialog(){
  VersionDialog dialog=new VersionDialog(getActiveShell(),Messages.SaveProjectAsActionTitle,Messages.SaveProjectAsActionMessage,IconConstants.BIG_PROJECT_STRING,Messages.SaveProjectAsActionShellTitle,true){
    /** 
 * {@inheritDoc}
 */
    protected boolean isInputAllowed(){
      final String newProjectName=getProjectNameFieldValue();
      boolean isInputAllowed=true;
      if (StringUtils.isBlank(newProjectName) || !ProjectNameBP.isValidProjectName(newProjectName,true)) {
        setErrorMessage(Messages.SaveProjectAsActionInvalidName);
        isInputAllowed=false;
      }
      if (ProjectPM.doesProjectNameExist(newProjectName)) {
        setErrorMessage(Messages.SaveProjectAsActionDoubleOrInvalidName);
        isInputAllowed=false;
      }
      return isInputAllowed;
    }
    /** 
 * {@inheritDoc}
 */
    protected void okPressed(){
      String newProjectName=getProjectNameFieldValue();
      if (ProjectPM.doesProjectNameExist(newProjectName) || StringUtils.isBlank(newProjectName)) {
        ErrorHandlingUtil.createMessageDialog(MessageIDs.E_PROJECTNAME_ALREADY_EXISTS,new Object[]{getProjectNameFieldValue()},null);
        return;
      }
      super.okPressed();
    }
  }
;
  dialog.setHelpAvailable(true);
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.DIALOG_PROJECT_SAVEAS);
  dialog.open();
  return dialog;
}",0.9416107382550336
95760,"/** 
 * {@inheritDoc}
 */
protected void okPressed(){
  if (ProjectPM.doesProjectNameExist(getProjectNameFieldValue())) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_PROJECTNAME_ALREADY_EXISTS,new Object[]{getProjectNameFieldValue()},null);
    return;
  }
  super.okPressed();
}","/** 
 * {@inheritDoc}
 */
protected void okPressed(){
  String newProjectName=getProjectNameFieldValue();
  if (ProjectPM.doesProjectNameExist(newProjectName) || StringUtils.isBlank(newProjectName)) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_PROJECTNAME_ALREADY_EXISTS,new Object[]{getProjectNameFieldValue()},null);
    return;
  }
  super.okPressed();
}",0.8012139605462822
95761,"/** 
 * {@inheritDoc}
 */
protected boolean isInputAllowed(){
  final String newProjectName=getProjectNameFieldValue();
  boolean isInputAllowed=true;
  if (!ProjectNameBP.isValidProjectName(newProjectName,true)) {
    setErrorMessage(Messages.SaveProjectAsActionInvalidName);
    isInputAllowed=false;
  }
  if (ProjectPM.doesProjectNameExist(newProjectName)) {
    setErrorMessage(Messages.SaveProjectAsActionDoubleOrInvalidName);
    isInputAllowed=false;
  }
  return isInputAllowed;
}","/** 
 * {@inheritDoc}
 */
protected boolean isInputAllowed(){
  final String newProjectName=getProjectNameFieldValue();
  boolean isInputAllowed=true;
  if (StringUtils.isBlank(newProjectName) || !ProjectNameBP.isValidProjectName(newProjectName,true)) {
    setErrorMessage(Messages.SaveProjectAsActionInvalidName);
    isInputAllowed=false;
  }
  if (ProjectPM.doesProjectNameExist(newProjectName)) {
    setErrorMessage(Messages.SaveProjectAsActionDoubleOrInvalidName);
    isInputAllowed=false;
  }
  return isInputAllowed;
}",0.9616519174041298
95762,"/** 
 * @param graphicsComponent The graphics component the key code is typed in, may be null
 * @param keycode The key code.
 * @param isUpperCase Boolean whether character is upper case.
 */
public void keyType(Object graphicsComponent,int keycode,boolean isUpperCase) throws RobotException {
  try {
    InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.KEY_EVENT_MASK});
    IRobotEventConfirmer confirmer=m_interceptor.intercept(options);
    try {
      if (isUpperCase) {
        m_robot.keyPress(java.awt.event.KeyEvent.VK_SHIFT);
      }
      m_robot.keyPress(keycode);
    }
  finally {
      m_robot.keyRelease(keycode);
      if (isUpperCase) {
        m_robot.keyRelease(java.awt.event.KeyEvent.VK_SHIFT);
      }
    }
    confirmer.waitToConfirm(graphicsComponent,new KeyJavaFXEventMatcher(KeyEvent.KEY_RELEASED));
  }
 catch (  IllegalArgumentException e) {
    throw new RobotException(e);
  }
}","/** 
 * @param graphicsComponent The graphics component the key code is typed in, may be null
 * @param keycode The key code.
 * @param isUpperCase Boolean whether character is upper case.
 */
public void keyType(final Object graphicsComponent,final int keycode,final boolean isUpperCase) throws RobotException {
  try {
    InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.KEY_EVENT_MASK});
    IRobotEventConfirmer confirmer=m_interceptor.intercept(options);
    EventTarget target=(EventTarget)graphicsComponent;
    if (target == null) {
      target=CurrentStages.getfocusStage();
    }
    Event.fireEvent(target,new KeyEvent(KeyEvent.KEY_TYPED,""String_Node_Str"",KeyCodeMap.valueOf(keycode).getName(),KeyCodeMap.valueOf(keycode),isUpperCase,false,false,false));
    confirmer.waitToConfirm(graphicsComponent,new KeyJavaFXEventMatcher(KeyEvent.KEY_TYPED));
  }
 catch (  IllegalArgumentException e) {
    throw new RobotException(e);
  }
}",0.6090621707060063
95763,"/** 
 * Searches the hierarchy-map for components that are assignable from the given type
 * @param type the type to look for
 * @param < T > component type
 * @return List
 */
public static <T>List<? extends T> getAssignableFrom(Class<T> type){
  Set<JavaFXComponent> keys=(Set<JavaFXComponent>)hierarchy.getHierarchyMap().keySet();
  List<T> result=new ArrayList<T>();
  for (  JavaFXComponent object : keys) {
    if (type.isAssignableFrom(object.getRealComponentType())) {
      result.add(type.cast(object.getRealComponent()));
    }
  }
  return result;
}","/** 
 * Searches the hierarchy-map (in the JavaFX-Thread) for components that are assignable from the given type
 * @param type the type to look for
 * @param < T > component type
 * @return List
 */
public static <T>List<? extends T> getAssignableFrom(final Class<T> type){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<List<? extends T>>(){
    @Override public List<? extends T> call() throws Exception {
      Set<JavaFXComponent> keys=(Set<JavaFXComponent>)hierarchy.getHierarchyMap().keySet();
      List<T> result=new ArrayList<T>();
      for (      JavaFXComponent object : keys) {
        if (type.isAssignableFrom(object.getRealComponentType())) {
          result.add(type.cast(object.getRealComponent()));
        }
      }
      return result;
    }
  }
);
}",0.8195763330898466
95764,"/** 
 * {@inheritDoc}
 */
public Rectangle getBoundsAt(final int index){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    public Rectangle call(){
      return NodeBounds.getRelativeBounds(getRealComponent().getPanes().get(index),getRealComponent());
    }
  }
);
}","/** 
 * {@inheritDoc}
 */
public Rectangle getBoundsAt(final int index){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    public Rectangle call(){
      getRealComponent().layout();
      return NodeBounds.getRelativeBounds(getRealComponent().getPanes().get(index),getRealComponent());
    }
  }
);
}",0.9475262368815592
95765,"/** 
 * Names the given hierarchy container. <br> If the managed component has a unique name, this name is used. Otherwise a name (unique for the hierachy level) is created.
 * @param hierarchyContainer the SwingHierarchyContainer to name, if SwingHierarchyContainer is null, no action is performed and no exception is thrown.
 */
protected void name(JavaFXHierarchyContainer hierarchyContainer){
  final JavaFXComponent comp=hierarchyContainer.getComponent();
  String compName;
  Object component;
  Object realComponent=comp.getRealComponent();
  if (realComponent instanceof Node) {
    component=realComponent;
    compName=((Node)component).getId();
  }
 else   if (realComponent instanceof MenuItem) {
    component=realComponent;
    compName=((MenuItem)component).getId();
  }
 else {
    compName=null;
    component=realComponent;
  }
  JavaFXHierarchyContainer hierParent=(JavaFXHierarchyContainer)hierarchyContainer.getPrnt();
  if (hierarchyContainer.getName() != null && hierarchyContainer.getName().length() != 0 && !(hierarchyContainer.getName().equals(""String_Node_Str""))) {
    if (isUniqueName(hierParent,hierarchyContainer.getName(),hierarchyContainer)) {
      return;
    }
 else     if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"" + hierarchyContainer.getName() + ""String_Node_Str"");
    }
  }
  int count=0;
  String originalName=null;
  String newName=null;
  boolean newNameGenerated=(compName == null);
  if (compName != null) {
    originalName=compName;
    newName=compName;
  }
  if (newName == null) {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(component,count);
    }
  }
 else {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(originalName,count);
    }
  }
  comp.setName(newName);
  hierarchyContainer.setName(newName,newNameGenerated);
}","/** 
 * Names the given hierarchy container. <br> If the managed component has a unique name, this name is used. Otherwise a name (unique for the hierachy level) is created.
 * @param hierarchyContainer the SwingHierarchyContainer to name, if SwingHierarchyContainer is null, no action is performed and no exception is thrown.
 */
protected void name(JavaFXHierarchyContainer hierarchyContainer){
  final JavaFXComponent comp=hierarchyContainer.getComponent();
  String compName;
  Object component;
  Object realComponent=comp.getRealComponent();
  if (realComponent instanceof Node) {
    component=realComponent;
    compName=((Node)component).getId();
  }
 else   if (realComponent instanceof MenuItem) {
    component=realComponent;
    compName=((MenuItem)component).getId();
  }
 else {
    compName=null;
    component=realComponent;
  }
  if (realComponent instanceof Stage) {
    List<Stage> stages=CurrentStages.getStageList();
    ArrayList<String> names=new ArrayList<>();
    for (    Stage stage : stages) {
      JavaFXHierarchyContainer c=getHierarchyContainer(stage);
      if (c != null && c != hierarchyContainer) {
        names.add(c.getName());
      }
    }
    String name=null;
    int count=0;
    while (!isUniqueName(name,names)) {
      count++;
      name=createName(realComponent,count);
    }
    comp.setName(name);
    hierarchyContainer.setName(name,true);
    return;
  }
  JavaFXHierarchyContainer hierParent=(JavaFXHierarchyContainer)hierarchyContainer.getPrnt();
  if (hierarchyContainer.getName() != null && hierarchyContainer.getName().length() != 0 && !(hierarchyContainer.getName().equals(""String_Node_Str""))) {
    if (isUniqueName(hierParent,hierarchyContainer.getName(),hierarchyContainer)) {
      return;
    }
 else     if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"" + hierarchyContainer.getName() + ""String_Node_Str"");
    }
  }
  int count=0;
  String originalName=null;
  String newName=null;
  boolean newNameGenerated=(compName == null);
  if (compName != null) {
    originalName=compName;
    newName=compName;
  }
  if (newName == null) {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(component,count);
    }
  }
 else {
    while (!isUniqueName(hierParent,newName,hierarchyContainer)) {
      count++;
      newName=createName(originalName,count);
    }
  }
  comp.setName(newName);
  hierarchyContainer.setName(newName,newNameGenerated);
}",0.8660734656627881
95766,"/** 
 * Checks for uniqueness of <code>name</code> for the components in <code>parent</code>.<br> If parent is null every name is unique, a null name is NEVER unique. If both parameters are null, false is returned. <br>
 * @param parent the hierarchy container containing the components which are checked.
 * @param name the name to check
 * @param container The component for which the name is being checked.
 * @return true if the name is treated as unique, false otherwise.
 */
protected boolean isUniqueName(JavaFXHierarchyContainer parent,String name,JavaFXHierarchyContainer container){
  if (name == null) {
    return false;
  }
  if (parent == null) {
    return true;
  }
  List<JavaFXHierarchyContainer> compIDs=parent.getContainerList();
  for (  JavaFXHierarchyContainer childContainer : compIDs) {
    String childName=childContainer.getName();
    if (name.equals(childName) && childContainer != container) {
      return false;
    }
  }
  return true;
}","/** 
 * Checks for uniqueness of given name using the given list
 * @param name the name to check
 * @param otherNames the list with the names
 * @return true or false
 */
protected boolean isUniqueName(String name,List<String> otherNames){
  if (name == null || otherNames == null) {
    return false;
  }
 else   if (otherNames.isEmpty()) {
    return true;
  }
  return !otherNames.contains(name);
}",0.2069970845481049
95767,"/** 
 * @param xml XML storage for the project
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise  <code>false</code>.
 * @return a new IProjectPO
 */
private IProjectPO initProject(Project xml,boolean assignNewGuid){
  IProjectPO proj=null;
  if (xml.getGUID() != null) {
    Integer majorProjVersion=null;
    if (!xml.isNilMajorProjectVersion() && xml.isSetMajorProjectVersion() || xml.isSetMajorNumber()) {
      majorProjVersion=xml.isSetMajorNumber() ? xml.getMajorNumber() : xml.getMajorProjectVersion();
    }
    Integer minorProjVersion=null;
    if (!xml.isNilMinorProjectVersion() && xml.isSetMinorProjectVersion() || xml.isSetMinorNumber()) {
      minorProjVersion=xml.isSetMinorNumber() ? xml.getMinorNumber() : xml.getMinorProjectVersion();
    }
    Integer microProjVersion=!xml.isSetMicroProjectVersion() || xml.isNilMicroProjectVersion() ? null : xml.getMicroProjectVersion();
    String postFixProjVersion=!xml.isSetProjectVersionQualifier() || xml.isNilProjectVersionQualifier() ? null : xml.getProjectVersionQualifier();
    proj=NodeMaker.createProjectPO(IVersion.JB_CLIENT_METADATA_VERSION,majorProjVersion,minorProjVersion,microProjVersion,postFixProjVersion,xml.getGUID());
    ProjectNameBP.getInstance().setName(xml.getGUID(),xml.getName(),false);
  }
 else {
    proj=NodeMaker.createProjectPO(xml.getName(),IVersion.JB_CLIENT_METADATA_VERSION);
    if (assignNewGuid) {
      m_oldToNewGuids.put(xml.getGUID(),proj.getGuid());
    }
  }
  return proj;
}","/** 
 * @param xml XML storage for the project
 * @param assignNewGuid <code>true</code> if the project and all subnodesshould be assigned new GUIDs. Otherwise  <code>false</code>.
 * @return a new IProjectPO
 */
private IProjectPO initProject(Project xml,boolean assignNewGuid){
  IProjectPO proj=null;
  if (xml.getGUID() != null) {
    Integer majorProjVersion=null;
    if (!xml.isNilMajorProjectVersion() && xml.isSetMajorProjectVersion() || xml.isSetMajorNumber()) {
      majorProjVersion=xml.isSetMajorNumber() ? xml.getMajorNumber() : xml.getMajorProjectVersion();
    }
    Integer minorProjVersion=null;
    if (!xml.isNilMinorProjectVersion() && xml.isSetMinorProjectVersion() || xml.isSetMinorNumber()) {
      minorProjVersion=xml.isSetMinorNumber() ? xml.getMinorNumber() : xml.getMinorProjectVersion();
    }
    Integer microProjVersion=!xml.isSetMicroProjectVersion() || xml.isNilMicroProjectVersion() ? null : xml.getMicroProjectVersion();
    String postFixProjVersion=!xml.isSetProjectVersionQualifier() || xml.isNilProjectVersionQualifier() ? null : xml.getProjectVersionQualifier();
    if (!assignNewGuid) {
      proj=NodeMaker.createProjectPO(IVersion.JB_CLIENT_METADATA_VERSION,majorProjVersion,minorProjVersion,microProjVersion,postFixProjVersion,xml.getGUID());
    }
 else {
      proj=NodeMaker.createProjectPO(IVersion.JB_CLIENT_METADATA_VERSION,majorProjVersion,minorProjVersion,microProjVersion,postFixProjVersion);
    }
    ProjectNameBP.getInstance().setName(xml.getGUID(),xml.getName(),false);
  }
 else {
    proj=NodeMaker.createProjectPO(xml.getName(),IVersion.JB_CLIENT_METADATA_VERSION);
    if (assignNewGuid) {
      m_oldToNewGuids.put(xml.getGUID(),proj.getGuid());
    }
  }
  return proj;
}",0.8876712328767123
95768,"/** 
 * Takes the supplied input stream and parses it. According to the content an instance of IProjetPO along with its associated components is created.
 * @param projectXmlStream input stream for XML representation of a project
 * @param assignNewGuid Flag for assigning the project a new GUID and version
 * @param majorVersion Major version number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param minorVersion Minor version number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param microVersion Micro version number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param versionQualifier Version Qualifier number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param paramNameMapper mapper to resolve param names
 * @param compNameCache cache to resolve component names
 * @param monitor The progress monitor for this potentially long-running operation.
 * @param io the device to write the import output
 * @param skipTrackingInformation whether to skip importing of tracked information
 * @return an transient IProjectPO and its components
 * @throws PMReadException in case of a invalid XML string
 * @throws JBVersionException in case of version conflict between used toolkits of imported project and the installed toolkit plug-ins
 * @throws InterruptedException if the operation was canceled.
 */
public static IProjectPO load(InputStream projectXmlStream,boolean assignNewGuid,Integer majorVersion,Integer minorVersion,Integer microVersion,String versionQualifier,IParamNameMapper paramNameMapper,IWritableComponentNameCache compNameCache,IProgressMonitor monitor,IProgressConsole io,boolean skipTrackingInformation) throws PMReadException, JBVersionException, InterruptedException {
  ContentDocument contentDoc;
  try {
    contentDoc=getContent(projectXmlStream);
    Project projectXml=contentDoc.getContent().getProject();
    int numExecTestCases=projectXml.selectPath(XPATH_FOR_EXEC_TCS).length;
    monitor.beginTask(StringConstants.EMPTY,numExecTestCases + 1);
    monitor.worked(1);
    XmlImporter xmlImporter=new XmlImporter(monitor,io,skipTrackingInformation);
    if (assignNewGuid && (majorVersion != null || versionQualifier != null)) {
      return xmlImporter.createProject(projectXml,assignNewGuid,majorVersion,minorVersion,microVersion,versionQualifier,paramNameMapper,compNameCache);
    }
    if (assignNewGuid) {
      return xmlImporter.createProject(projectXml,assignNewGuid,paramNameMapper,compNameCache);
    }
 else     if (majorVersion != null || versionQualifier != null) {
      return xmlImporter.createProject(projectXml,false,majorVersion,minorVersion,microVersion,versionQualifier,paramNameMapper,compNameCache);
    }
    return xmlImporter.createProject(projectXml,paramNameMapper,compNameCache);
  }
 catch (  XmlException e) {
    throw new PMReadException(Messages.InvalidImportFile,MessageIDs.E_LOAD_PROJECT);
  }
catch (  InvalidDataException e) {
    throw new PMReadException(Messages.InvalidImportFile,e.getErrorId());
  }
}","/** 
 * Takes the supplied input stream and parses it. According to the content an instance of IProjetPO along with its associated components is created.
 * @param projectXmlStream input stream for XML representation of a project
 * @param assignNewGuid Flag for assigning the project a new GUID and version
 * @param majorVersion Major version number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param minorVersion Minor version number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param microVersion Micro version number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param versionQualifier Version Qualifier number for the created object, or <code>null</code> if the version from the imported XML should be used.
 * @param paramNameMapper mapper to resolve param names
 * @param compNameCache cache to resolve component names
 * @param monitor The progress monitor for this potentially long-running operation.
 * @param io the device to write the import output
 * @param skipTrackingInformation whether to skip importing of tracked information
 * @return an transient IProjectPO and its components
 * @throws PMReadException in case of a invalid XML string
 * @throws JBVersionException in case of version conflict between used toolkits of imported project and the installed toolkit plug-ins
 * @throws InterruptedException if the operation was canceled.
 */
public static IProjectPO load(InputStream projectXmlStream,boolean assignNewGuid,Integer majorVersion,Integer minorVersion,Integer microVersion,String versionQualifier,IParamNameMapper paramNameMapper,IWritableComponentNameCache compNameCache,IProgressMonitor monitor,IProgressConsole io,boolean skipTrackingInformation) throws PMReadException, JBVersionException, InterruptedException {
  ContentDocument contentDoc;
  try {
    contentDoc=getContent(projectXmlStream);
    Project projectXml=contentDoc.getContent().getProject();
    int numExecTestCases=projectXml.selectPath(XPATH_FOR_EXEC_TCS).length;
    monitor.beginTask(StringConstants.EMPTY,numExecTestCases + 1);
    monitor.worked(1);
    XmlImporter xmlImporter=new XmlImporter(monitor,io,skipTrackingInformation);
    if (assignNewGuid && (majorVersion != null || versionQualifier != null)) {
      return xmlImporter.createProject(projectXml,assignNewGuid,majorVersion,minorVersion,microVersion,versionQualifier,paramNameMapper,compNameCache);
    }
 else     if (assignNewGuid) {
      return xmlImporter.createProject(projectXml,assignNewGuid,paramNameMapper,compNameCache);
    }
    return xmlImporter.createProject(projectXml,paramNameMapper,compNameCache);
  }
 catch (  XmlException e) {
    throw new PMReadException(Messages.InvalidImportFile,MessageIDs.E_LOAD_PROJECT);
  }
catch (  InvalidDataException e) {
    throw new PMReadException(Messages.InvalidImportFile,e.getErrorId());
  }
}",0.9641704325371208
95769,"@Override public String getText(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      Object value=getRealComponent().getValue();
      if (value == null) {
        return null;
      }
      return value.toString();
    }
  }
);
}","@Override public String getText(){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      ObservableList<Node> children=getRealComponent().getChildrenUnmodifiable();
      ListCell text=null;
      for (      Node node : children) {
        if (node instanceof ListCell) {
          text=(ListCell)node;
        }
      }
      if (text != null) {
        return text.getText();
      }
      return null;
    }
  }
);
}",0.6862514688601645
95770,"/** 
 * Gets the index path for a given column 
 * @param column the column
 * @param table the table of the column
 * @return the index path
 */
private String getColumnPath(TableColumnBase column,TableView table){
  String colPath=""String_Node_Str"";
  TableColumnBase nxtColumn=column;
  while (nxtColumn.getParentColumn() != null) {
    colPath=TestDataConstants.PATH_CHAR_DEFAULT + (nxtColumn.getParentColumn().getColumns().indexOf(nxtColumn) + 1) + colPath;
    nxtColumn=nxtColumn.getParentColumn();
  }
  colPath=(table.getColumns().indexOf(nxtColumn) + 1) + colPath;
  return colPath;
}","/** 
 * Gets the index path for a given column 
 * @param column the column
 * @param table the table of the column
 * @return the index path
 */
private String getColumnPath(TableColumnBase column,TableView table){
  String colPath=""String_Node_Str"";
  TableColumnBase nxtColumn=column;
  while (nxtColumn.getParentColumn() != null) {
    colPath=String.valueOf(TestDataConstants.PATH_CHAR_DEFAULT).concat(String.valueOf((nxtColumn.getParentColumn().getColumns().indexOf(nxtColumn) + 1) + colPath));
    nxtColumn=nxtColumn.getParentColumn();
  }
  colPath=(table.getColumns().indexOf(nxtColumn) + 1) + colPath;
  return colPath;
}",0.7177814029363785
95771,"/** 
 * Returns the internal index of the first column which contains the given value CALL IN JAVAFX-THREAD!
 * @param value the value
 * @param operator the operator
 * @param searchType the searchType
 * @param adapter the adapter class
 * @param implRow the row
 * @return String with the column path or null
 */
private String getColumnByValue(final String value,final String operator,final String searchType,final ITableComponent adapter,final int implRow){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      final int columnCount=adapter.getColumnCount();
      if (columnCount > 0) {
        int startIndex=getStartingColIndex(searchType);
        List<TableColumn> columns=((TableView)getRealComponent()).getVisibleLeafColumns();
        for (int i=startIndex; i < columns.size(); i++) {
          TableColumn column=columns.get(i);
          int index=adapter.getColumnFromString(getColumnPath(column,(TableView)getRealComponent()),""String_Node_Str"");
          String cellValue=adapter.getCellText(implRow,index);
          if (MatchUtil.getInstance().match(cellValue,value,operator)) {
            return getColumnPath(column,(TableView)getRealComponent());
          }
        }
      }
      return null;
    }
  }
);
}","/** 
 * Returns the internal index of the first column which contains the given value CALL IN JAVAFX-THREAD!
 * @param value the value
 * @param operator the operator
 * @param searchType the searchType
 * @param adapter the adapter class
 * @param implRow the row
 * @return String with the column path or null
 */
private String getColumnByValue(final String value,final String operator,final String searchType,final ITableComponent adapter,final int implRow){
  return EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call(){
      final int columnCount=adapter.getColumnCount();
      if (columnCount > 0) {
        int startIndex=getStartingColIndex(searchType) - 1;
        List<TableColumn> columns=((TableView)getRealComponent()).getVisibleLeafColumns();
        for (int i=startIndex; i < columns.size(); i++) {
          TableColumn column=columns.get(i);
          int index=adapter.getColumnFromString(getColumnPath(column,(TableView)getRealComponent()),""String_Node_Str"");
          String cellValue=adapter.getCellText(implRow,index);
          if (MatchUtil.getInstance().match(cellValue,value,operator)) {
            return getColumnPath(column,(TableView)getRealComponent());
          }
        }
      }
      return null;
    }
  }
);
}",0.9917106254709872
95772,"/** 
 * @param searchType Determines column where the search begins (""relative"" or ""absolute"")
 * @return The index from which to begin a search, based on the search typeand (if appropriate) the currently selected cell.
 */
private int getStartingColIndex(String searchType){
  int startingIndex=0;
  if (searchType.equalsIgnoreCase(CompSystemConstants.SEARCH_TYPE_RELATIVE)) {
    startingIndex=((ITableComponent)getComponent()).getSelectedCell().getCol() + 1;
  }
  return startingIndex;
}","/** 
 * @param searchType Determines column where the search begins (""relative"" or ""absolute"")
 * @return The index from which to begin a search, based on the search typeand (if appropriate) the currently selected cell.
 */
private int getStartingColIndex(String searchType){
  int startingIndex=0;
  if (searchType.equalsIgnoreCase(CompSystemConstants.SEARCH_TYPE_RELATIVE)) {
    Cell c=((ITableComponent)getComponent()).getSelectedCell();
    if (c == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_SELECTION));
    }
    startingIndex=c.getCol() + 1;
  }
  return startingIndex;
}",0.7705779334500875
95773,"@Override public Cell getSelectedCell() throws StepExecutionException {
  Cell result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Cell>(){
    @Override public Cell call() throws Exception {
      ObservableList list=getRealComponent().getSelectionModel().getSelectedCells();
      TableView table=getRealComponent();
      if (list.size() > 0) {
        TablePosition pos=null;
        for (        Object object : list) {
          TablePosition curr=(TablePosition)object;
          if (curr.getRow() == table.getSelectionModel().getSelectedIndex()) {
            pos=curr;
            break;
          }
        }
        if (pos != null) {
          return new Cell(pos.getRow(),pos.getColumn());
        }
      }
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_SELECTION));
    }
  }
);
  return result;
}","@Override public Cell getSelectedCell() throws StepExecutionException {
  Cell result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Cell>(){
    @Override public Cell call() throws StepExecutionException {
      TableView table=getRealComponent();
      ObservableList list=table.getSelectionModel().getSelectedCells();
      if (list.size() > 0) {
        TablePosition pos=null;
        for (        Object object : list) {
          TablePosition curr=(TablePosition)object;
          if (curr.getRow() == table.getSelectionModel().getSelectedIndex()) {
            pos=curr;
            break;
          }
        }
        if (pos != null) {
          return new Cell(pos.getRow(),pos.getColumn());
        }
      }
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_SELECTION));
    }
  }
);
  return result;
}",0.9332591768631812
95774,"@Override public String getCellText(final int row,final int column){
  String result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      TableView<?> table=getRealComponent();
      TableColumn col=table.getVisibleLeafColumn(column);
      table.scrollTo(row);
      table.scrollToColumn(col);
      table.layout();
      List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
      for (      TableCell<?,?> cell : tCells) {
        if (cell.getIndex() == row && cell.getTableColumn() == col && cell.getTableView() == table) {
          String txt=cell.getText();
          if (txt == null && cell instanceof TextFieldTableCell && cell.isEditing()) {
            TextField f=(TextField)cell.getGraphic();
            txt=f.getText();
          }
          return txt;
        }
      }
      return null;
    }
  }
);
  return result;
}","@Override public String getCellText(final int row,final int column){
  String result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<String>(){
    @Override public String call() throws Exception {
      TableView<?> table=getRealComponent();
      TableColumn col=null;
      if (m_columns.size() == 0) {
        col=table.getVisibleLeafColumn(column);
      }
 else {
        col=m_columns.get(column);
      }
      table.scrollTo(row);
      table.scrollToColumn(col);
      table.layout();
      List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
      for (      TableCell<?,?> cell : tCells) {
        if (cell.getIndex() == row && cell.getTableColumn() == col && cell.getTableView() == table) {
          String txt=cell.getText();
          if (txt == null && cell instanceof TextFieldTableCell && cell.isEditing()) {
            TextField f=(TextField)cell.getGraphic();
            txt=f.getText();
          }
          return txt;
        }
      }
      return null;
    }
  }
);
  return result;
}",0.9448818897637796
95775,"@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView<?> table=getRealComponent();
      TableColumn col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
      col=getRealComponent().getVisibleLeafColumn(column);
      table.scrollToColumn(col);
      table.layout();
      Parent headerRow=(Parent)table.lookup(""String_Node_Str"");
      Set<Node> columnHeaders=headerRow.lookupAll(""String_Node_Str"");
      Point2D parentPos=table.localToScreen(0,0);
      for (      Node n : columnHeaders) {
        TableColumnHeader colH=(TableColumnHeader)n;
        if (colH.getTableColumn().equals(col)) {
          Bounds b=n.getBoundsInParent();
          Point2D pos=n.localToScreen(0,0);
          return new Rectangle(Rounding.round(pos.getX() - parentPos.getX()),Rounding.round(pos.getY() - parentPos.getY()),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  return result;
}","@Override public Rectangle getHeaderBounds(final int column){
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView<?> table=getRealComponent();
      TableColumn col;
      if (m_columns.size() > 0) {
        col=m_columns.get(column);
      }
 else {
        col=getRealComponent().getVisibleLeafColumn(column);
      }
      table.scrollToColumn(col);
      table.layout();
      Parent headerRow=(Parent)table.lookup(""String_Node_Str"");
      Set<Node> columnHeaders=headerRow.lookupAll(""String_Node_Str"");
      Point2D parentPos=table.localToScreen(0,0);
      for (      Node n : columnHeaders) {
        TableColumnHeader colH=(TableColumnHeader)n;
        if (colH.getTableColumn().equals(col)) {
          Bounds b=n.getBoundsInParent();
          Point2D pos=n.localToScreen(0,0);
          return new Rectangle(Rounding.round(pos.getX() - parentPos.getX()),Rounding.round(pos.getY() - parentPos.getY()),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  return result;
}",0.9922413793103448
95776,"@Override public boolean isCellEditable(final int row,final int column){
  boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      TableView<?> table=getRealComponent();
      if (table.isEditable()) {
        TableColumn col=table.getVisibleLeafColumn(column);
        if (col.isEditable()) {
          table.scrollTo(row);
          table.scrollToColumn(col);
          table.layout();
          List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
          for (          TableCell<?,?> cell : tCells) {
            if (cell.getIndex() == row && cell.getTableColumn() == col && cell.getTableView() == table) {
              return cell.isEditable();
            }
          }
        }
      }
      return false;
    }
  }
);
  return result;
}","@Override public boolean isCellEditable(final int row,final int column){
  boolean result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      TableView<?> table=getRealComponent();
      if (table.isEditable()) {
        TableColumn col=null;
        if (m_columns.size() == 0) {
          col=table.getVisibleLeafColumn(column);
        }
 else {
          col=m_columns.get(column);
        }
        if (col.isEditable()) {
          table.scrollTo(row);
          table.scrollToColumn(col);
          table.layout();
          List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
          for (          TableCell<?,?> cell : tCells) {
            if (cell.getIndex() == row && cell.getTableColumn() == col && cell.getTableView() == table) {
              return cell.isEditable();
            }
          }
        }
      }
      return false;
    }
  }
);
  return result;
}",0.9356540084388184
95777,"@Override public int getColumnFromString(final String colPath,final String op){
  Integer result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    @Override public Integer call() throws Exception {
      TableView table=getRealComponent();
      TableColumn column=null;
      List<String> path=StringParsing.splitToList(colPath,TestDataConstants.PATH_CHAR_DEFAULT,TestDataConstants.ESCAPE_CHAR_DEFAULT,false);
      ObservableList<TableColumn> columns;
      if (colPath.contains(""String_Node_Str"" + TestDataConstants.PATH_CHAR_DEFAULT)) {
        columns=table.getColumns();
      }
 else {
        columns=table.getVisibleLeafColumns();
      }
      Iterator<String> pathIterator=path.iterator();
      String currCol=null;
      while (pathIterator.hasNext()) {
        try {
          currCol=pathIterator.next();
          int usrIdxCol=Integer.parseInt(currCol);
          if (usrIdxCol == 0) {
            usrIdxCol=usrIdxCol + 1;
          }
          int i=IndexConverter.toImplementationIndex(usrIdxCol);
          if (pathIterator.hasNext()) {
            columns=columns.get(i).getColumns();
          }
 else {
            column=columns.get(i);
          }
        }
 catch (        NumberFormatException nfe) {
          try {
            columns=table.getColumns();
            if (columns.size() <= 0) {
              throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_HEADER));
            }
            for (int i=0; i < columns.size(); i++) {
              TableColumn c=columns.get(i);
              String header=c.getText();
              if (MatchUtil.getInstance().match(header,currCol,op)) {
                if (pathIterator.hasNext()) {
                  columns=columns.get(i).getColumns();
                }
 else {
                  column=columns.get(i);
                }
              }
            }
          }
 catch (          IllegalArgumentException iae) {
          }
        }
      }
      if (table.getVisibleLeafColumns().contains(column)) {
        return table.getVisibleLeafColumns().indexOf(column);
      }
      m_columns.add(column);
      return m_columns.indexOf(column);
    }
  }
);
  return result.intValue();
}","@Override public int getColumnFromString(final String colPath,final String op){
  Integer result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Integer>(){
    @Override public Integer call() throws Exception {
      TableView table=getRealComponent();
      TableColumn column=null;
      List<String> path=StringParsing.splitToList(colPath,TestDataConstants.PATH_CHAR_DEFAULT,TestDataConstants.ESCAPE_CHAR_DEFAULT,false);
      ObservableList<TableColumn> columns;
      if (colPath.contains(""String_Node_Str"" + TestDataConstants.PATH_CHAR_DEFAULT)) {
        columns=table.getColumns();
      }
 else {
        columns=table.getVisibleLeafColumns();
      }
      Iterator<String> pathIterator=path.iterator();
      String currCol=null;
      while (pathIterator.hasNext()) {
        try {
          currCol=pathIterator.next();
          int usrIdxCol=Integer.parseInt(currCol);
          if (usrIdxCol == 0) {
            usrIdxCol=usrIdxCol + 1;
          }
          int i=IndexConverter.toImplementationIndex(usrIdxCol);
          if (pathIterator.hasNext()) {
            columns=columns.get(i).getColumns();
          }
 else {
            column=columns.get(i);
          }
        }
 catch (        NumberFormatException nfe) {
          try {
            if (path.size() <= 1) {
              columns=table.getColumns();
            }
            if (columns.size() <= 0) {
              throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_HEADER));
            }
            for (            TableColumn c : columns) {
              String header=c.getText();
              if (MatchUtil.getInstance().match(header,currCol,op)) {
                column=c;
                if (pathIterator.hasNext()) {
                  columns=c.getColumns();
                }
                break;
              }
            }
          }
 catch (          IllegalArgumentException iae) {
          }
        }
      }
      if (column == null) {
        throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
      }
      if (table.getVisibleLeafColumns().contains(column)) {
        return table.getVisibleLeafColumns().indexOf(column);
      }
      m_columns.add(column);
      return m_columns.indexOf(column);
    }
  }
);
  return result.intValue();
}",0.814974182444062
95778,"@Override public Rectangle scrollCellToVisible(final int row,final int column) throws StepExecutionException {
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView<?> table=getRealComponent();
      TableColumn col=table.getVisibleLeafColumn(column);
      table.scrollTo(row);
      table.scrollToColumn(col);
      table.layout();
      List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
      for (      TableCell<?,?> cell : tCells) {
        if (cell.getIndex() == row && cell.getTableColumn() == col && cell.getTableView() == table) {
          Bounds b=cell.getBoundsInParent();
          Point2D pos=cell.localToScreen(0,0);
          Point2D parentPos=table.localToScreen(0,0);
          return new Rectangle(Rounding.round(pos.getX() - parentPos.getX()),Rounding.round(pos.getY() - parentPos.getY()),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  return result;
}","@Override public Rectangle scrollCellToVisible(final int row,final int column) throws StepExecutionException {
  Rectangle result=EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Rectangle>(){
    @Override public Rectangle call() throws Exception {
      TableView<?> table=getRealComponent();
      TableColumn col=null;
      if (m_columns.size() == 0) {
        col=table.getVisibleLeafColumn(column);
      }
 else {
        col=m_columns.get(column);
      }
      table.scrollTo(row);
      table.scrollToColumn(col);
      table.layout();
      List<? extends TableCell> tCells=ComponentHandler.getAssignableFrom(TableCell.class);
      for (      TableCell<?,?> cell : tCells) {
        if (cell.getIndex() == row && cell.getTableColumn() == col && cell.getTableView() == table) {
          Bounds b=cell.getBoundsInParent();
          Point2D pos=cell.localToScreen(0,0);
          Point2D parentPos=table.localToScreen(0,0);
          return new Rectangle(Rounding.round(pos.getX() - parentPos.getX()),Rounding.round(pos.getY() - parentPos.getY()),Rounding.round(b.getWidth()),Rounding.round(b.getHeight()));
        }
      }
      return null;
    }
  }
);
  return result;
}",0.9515570934256056
95779,"/** 
 * @param searchType Determines column where the search begins (""relative"" or ""absolute"")
 * @return The index from which to begin a search, based on the search typeand (if appropriate) the currently selected cell.
 */
private int getStartingColIndex(String searchType){
  int startingIndex=0;
  if (searchType.equalsIgnoreCase(CompSystemConstants.SEARCH_TYPE_RELATIVE)) {
    Cell c=((ITableComponent)getComponent()).getSelectedCell();
    if (c == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_SELECTION));
    }
    startingIndex=c.getCol() + 1;
  }
  return startingIndex;
}","/** 
 * @param searchType Determines column where the search begins (""relative"" or ""absolute"")
 * @return The index from which to begin a search, based on the search typeand (if appropriate) the currently selected cell.
 */
private int getStartingColIndex(String searchType){
  int startingIndex=0;
  if (searchType.equalsIgnoreCase(CompSystemConstants.SEARCH_TYPE_RELATIVE)) {
    Cell c=((ITableComponent)getComponent()).getSelectedCell();
    if (c == null) {
      throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NO_SELECTION));
    }
    startingIndex=c.getCol();
  }
  return startingIndex + 1;
}",0.956989247311828
95780,"/** 
 * @param exception -
 * @param stackTraceArray -
 * @return boolean
 */
private boolean checkStackTrace(Throwable exception,StackTraceElement[] stackTraceArray){
  for (int i=0; i < stackTraceArray.length; ++i) {
    String className=stackTraceArray[i].getClassName();
    if ((exception instanceof IllegalArgumentException) && KeySequence.class.getName().equals(className)) {
      return false;
    }
 else     if ((exception instanceof IllegalArgumentException) && stackTraceArray[i].toString().contains(""String_Node_Str"")) {
      return false;
    }
 else     if ((exception instanceof ClassCastException) && stackTraceArray[i].toString().contains(""String_Node_Str"")) {
      return false;
    }
 else     if ((exception instanceof NullPointerException) && KeySequenceText.class.getName().equals(className)) {
      return false;
    }
 else     if ((exception instanceof NullPointerException) && className != null && className.startsWith(ConsoleView.class.getName())) {
      return false;
    }
 else     if ((exception instanceof NullPointerException) && Plugin.isGEFException(exception)) {
      return false;
    }
 else     if ((exception instanceof NullPointerException) && Plugin.isRCPException(exception)) {
      return false;
    }
 else     if (exception instanceof NumberFormatException && IPageLayout.ID_PROBLEM_VIEW.equals(getActivePartId())) {
      return false;
    }
  }
  return true;
}","/** 
 * @param exception -
 * @param stackTraceArray -
 * @return boolean
 */
private boolean checkStackTrace(Throwable exception,StackTraceElement[] stackTraceArray){
  for (int i=0; i < stackTraceArray.length; ++i) {
    final StackTraceElement stackTraceElement=stackTraceArray[i];
    String className=stackTraceElement.getClassName();
    if ((exception instanceof IllegalArgumentException) && KeySequence.class.getName().equals(className)) {
      return false;
    }
 else     if (stackTraceElement.toString().contains(""String_Node_Str"")) {
      if ((exception instanceof IllegalArgumentException) || (exception instanceof ClassCastException) || (exception instanceof ConcurrentModificationException)) {
        return false;
      }
    }
 else     if ((exception instanceof NullPointerException) && KeySequenceText.class.getName().equals(className)) {
      return false;
    }
 else     if ((exception instanceof NullPointerException) && className != null && className.startsWith(ConsoleView.class.getName())) {
      return false;
    }
 else     if ((exception instanceof NullPointerException) && Plugin.isGEFException(exception)) {
      return false;
    }
 else     if ((exception instanceof NullPointerException) && Plugin.isRCPException(exception)) {
      return false;
    }
 else     if (exception instanceof NumberFormatException && IPageLayout.ID_PROBLEM_VIEW.equals(getActivePartId())) {
      return false;
    }
  }
  return true;
}",0.8354782608695652
95781,"/** 
 * {@inheritDoc}
 */
public int compare(Viewer viewer,Object e1,Object e2){
  if (isOnlyFirstObjectInstanceOfClass(e1,e2,ICategoryPO.class) || isOnlyFirstObjectInstanceOfClass(e1,e2,IReusedProjectPO.class)) {
    return -1;
  }
  if (isOnlyFirstObjectInstanceOfClass(e2,e1,ICategoryPO.class) || isOnlyFirstObjectInstanceOfClass(e2,e1,IReusedProjectPO.class)) {
    return 1;
  }
  if (isOnlyFirstObjectInstanceOfClass(e1,e2,IEventExecTestCasePO.class)) {
    return -1;
  }
  if (isOnlyFirstObjectInstanceOfClass(e2,e1,IEventExecTestCasePO.class)) {
    return 1;
  }
  if (e1 instanceof IExecTestCasePO || e2 instanceof IExecTestCasePO || e1 instanceof ICapPO|| e2 instanceof ICapPO|| e1 instanceof IRefTestSuitePO|| e2 instanceof IRefTestSuitePO) {
    return 0;
  }
  return super.compare(viewer,e1,e2);
}","/** 
 * {@inheritDoc} 
 */
public int compare(Viewer viewer,Object e1,Object e2){
  List<Class<?>> preferredTypes=new ArrayList<>(3);
  preferredTypes.add(IReusedProjectPO.class);
  preferredTypes.add(ICategoryPO.class);
  preferredTypes.add(IEventExecTestCasePO.class);
  for (  Class c : preferredTypes) {
    if (isOnlyFirstObjectInstanceOfClass(e1,e2,c)) {
      return -1;
    }
    if (isOnlyFirstObjectInstanceOfClass(e2,e1,c)) {
      return 1;
    }
  }
  if (e1 instanceof IExecTestCasePO || e2 instanceof IExecTestCasePO || e1 instanceof ICapPO|| e2 instanceof ICapPO|| e1 instanceof IRefTestSuitePO|| e2 instanceof IRefTestSuitePO) {
    return 0;
  }
  return super.compare(viewer,e1,e2);
}",0.5145118733509235
95782,"/** 
 * @param specTcGuid The GUID of the reused test case.
 * @param parentProjectIds All returned test cases will have one of these astheir project parent ID.
 * @param s The session into which the test cases will be loaded.
 * @return list of test cases.
 */
@SuppressWarnings(""String_Node_Str"") private static synchronized List<IExecTestCasePO> getExecTestCasesFor(String specTcGuid,List<Long> parentProjectIds,EntityManager s){
  StringBuffer queryBuffer=new StringBuffer(""String_Node_Str"");
  for (  long id : parentProjectIds) {
    queryBuffer.append(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  queryBuffer.delete(queryBuffer.length() - 4,queryBuffer.length());
  queryBuffer.append(""String_Node_Str"");
  Query q=s.createQuery(queryBuffer.toString());
  q.setParameter(""String_Node_Str"",specTcGuid);
  List<IExecTestCasePO> execTcList=q.getResultList();
  return execTcList;
}","/** 
 * @param specTcGuid The GUID of the reused test case.
 * @param parentProjectIds All returned test cases will have one of these astheir project parent ID.
 * @param s The session into which the test cases will be loaded.
 * @return list of test cases.
 */
@SuppressWarnings(""String_Node_Str"") private static synchronized List<IExecTestCasePO> getExecTestCasesFor(String specTcGuid,List<Long> parentProjectIds,EntityManager s){
  StringBuffer queryBuffer=new StringBuffer(""String_Node_Str"");
  Query q=s.createQuery(queryBuffer.toString());
  q.setParameter(""String_Node_Str"",specTcGuid);
  q.setParameter(""String_Node_Str"",parentProjectIds);
  List<IExecTestCasePO> execTcList=q.getResultList();
  return execTcList;
}",0.8111455108359134
95783,"/** 
 * @param tsGuid The GUID of the reused test suite.
 * @param parentProjectIds All returned test suites will have one of these astheir project parent ID.
 * @param s The session into which the test cases will be loaded.
 * @return list of test suites.
 */
@SuppressWarnings(""String_Node_Str"") private static synchronized List<IRefTestSuitePO> getRefTestSuitesFor(String tsGuid,List<Long> parentProjectIds,EntityManager s){
  StringBuffer queryBuffer=new StringBuffer(""String_Node_Str"");
  for (  long id : parentProjectIds) {
    queryBuffer.append(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  queryBuffer.delete(queryBuffer.length() - 4,queryBuffer.length());
  queryBuffer.append(""String_Node_Str"");
  Query q=s.createQuery(queryBuffer.toString());
  q.setParameter(""String_Node_Str"",tsGuid);
  List<IRefTestSuitePO> refTestSuiteList=q.getResultList();
  return refTestSuiteList;
}","/** 
 * @param tsGuid The GUID of the reused test suite.
 * @param parentProjectIds All returned test suites will have one of these astheir project parent ID.
 * @param s The session into which the test cases will be loaded.
 * @return list of test suites.
 */
@SuppressWarnings(""String_Node_Str"") private static synchronized List<IRefTestSuitePO> getRefTestSuitesFor(String tsGuid,List<Long> parentProjectIds,EntityManager s){
  StringBuffer queryBuffer=new StringBuffer(""String_Node_Str"");
  Query q=s.createQuery(queryBuffer.toString());
  q.setParameter(""String_Node_Str"",tsGuid);
  q.setParameter(""String_Node_Str"",parentProjectIds);
  List<IRefTestSuitePO> refTestSuiteList=q.getResultList();
  return refTestSuiteList;
}",0.8167797655768044
95784,"/** 
 * Returns the node under the given point
 * @param pos the point
 * @return the component
 */
public static Node getComponentByPos(Point2D pos){
  List<? extends Node> comps=getAssignableFrom(Node.class);
  List<Node> matches=new ArrayList<Node>();
  for (  Node n : comps) {
    if (n.getScene() == null || !NodeBounds.checkIfContains(pos,n)) {
      continue;
    }
    if (isSupported(n.getClass())) {
      boolean add=true;
      Parent parent=n.getParent();
      while (parent != null) {
        if (parent instanceof Skinnable) {
          if (isContentNode(n,parent)) {
            break;
          }
          Skin skin=((Skinnable)parent).getSkin();
          if (skin instanceof SkinBase) {
            if (isSkinNode(n,(SkinBase)skin)) {
              add=false;
              break;
            }
          }
        }
 else {
          parent=parent.getParent();
        }
      }
      if (add) {
        matches.add(n);
      }
    }
  }
  if (matches.size() == 0) {
    return null;
  }
  if (matches.size() == 1) {
    return matches.get(0);
  }
  return filterMatches(matches);
}","/** 
 * Returns the node under the given point
 * @param pos the point
 * @return the component
 */
public static Node getComponentByPos(Point2D pos){
  List<? extends Window> comps=getAssignableFrom(Window.class);
  List<Node> matches=new ArrayList<Node>();
  for (  Window window : comps) {
    if (window.isFocused() && window.isShowing()) {
      Parent root=window.getScene().getRoot();
      matches=getAllNodesforPos(root,pos,matches);
    }
  }
  List<Node> result=new ArrayList<Node>();
  for (  Node n : matches) {
    if (n.getScene() == null || !isSupported(n.getClass()) || !n.isVisible()) {
      continue;
    }
    boolean add=true;
    Parent parent=n.getParent();
    while (parent != null) {
      if (parent instanceof Skinnable) {
        if (isContentNode(n,parent)) {
          break;
        }
        Skin skin=((Skinnable)parent).getSkin();
        if (skin instanceof SkinBase) {
          if (isSkinNode(n,(SkinBase)skin)) {
            add=false;
            break;
          }
        }
 else {
          parent=parent.getParent();
        }
      }
 else {
        parent=parent.getParent();
      }
    }
    if (add) {
      result.add(n);
    }
  }
  if (result.size() == 0) {
    return null;
  }
  if (result.size() == 1) {
    return result.get(0);
  }
  return filterMatches(result);
}",0.5691927512355849
95785,"/** 
 * Removes a container from the hierarchy. This means that the following references will be removed: <br> -Container from the hierarchy Map <br> -The component of the given container from the real map <br> -The reference from the parent container to the given container <br> -The actions mentioned above for all children of this container
 * @param ctner the container that will be deleted
 */
public void removeContainer(JavaFXHierarchyContainer ctner){
  m_lock.lock();
  try {
    Map contMap=getHierarchyMap();
    Map realMap=getRealMap();
    JavaFXComponent fxComp=ctner.getComponent();
    fxComp.removeChangeListener();
    contMap.remove(ctner.getComponent());
    realMap.remove(fxComp.getRealComponent());
    JavaFXHierarchyContainer parent=(JavaFXHierarchyContainer)ctner.getPrnt();
    if (parent != null) {
      JavaFXHierarchyContainer[] parentComp=parent.getChildren();
      int i=0;
      for (      JavaFXHierarchyContainer comp : parentComp) {
        if (comp == ctner) {
          parentComp[i]=null;
          break;
        }
        i++;
      }
    }
    ArrayList<JavaFXHierarchyContainer> children=new ArrayList<JavaFXHierarchyContainer>(Arrays.asList(ctner.getChildren()));
    for (    JavaFXHierarchyContainer child : children) {
      removeContainer(child);
    }
  }
  finally {
    m_lock.unlock();
  }
}","/** 
 * Removes a container from the hierarchy. This means that the following references will be removed: <br> -Container from the hierarchy Map <br> -The component of the given container from the real map <br> -The reference from the parent container to the given container <br> -The actions mentioned above for all children of this container
 * @param ctner the container that will be deleted
 */
public void removeContainer(JavaFXHierarchyContainer ctner){
  m_lock.lock();
  try {
    Map contMap=getHierarchyMap();
    Map realMap=getRealMap();
    JavaFXComponent fxComp=ctner.getComponent();
    fxComp.removeChangeListener();
    contMap.remove(ctner.getComponent());
    realMap.remove(fxComp.getRealComponent());
    JavaFXHierarchyContainer parent=(JavaFXHierarchyContainer)ctner.getPrnt();
    if (parent != null) {
      parent.remove(ctner);
    }
    List<JavaFXHierarchyContainer> children=new ArrayList<>(ctner.getContainerList());
    for (    JavaFXHierarchyContainer child : children) {
      removeContainer(child);
    }
  }
  finally {
    m_lock.unlock();
  }
}",0.7574013157894737
95786,"@Override protected List<String> getComponentContext(Object component){
  JavaFXHierarchyContainer parent;
  JavaFXHierarchyContainer comp;
  List<String> context=new ArrayList<String>();
  if (component instanceof JavaFXHierarchyContainer) {
    comp=(JavaFXHierarchyContainer)component;
  }
 else {
    comp=getHierarchyContainer(component);
  }
  parent=(JavaFXHierarchyContainer)comp.getPrnt();
  if (parent != null) {
    JavaFXHierarchyContainer[] comps=parent.getChildren();
    for (int i=0; i < comps.length; i++) {
      JavaFXHierarchyContainer child=comps[i];
      if (!child.equals(comp)) {
        String toAdd=child.getName();
        context.add(toAdd);
      }
    }
  }
  return context;
}","@Override protected List<String> getComponentContext(Object component){
  JavaFXHierarchyContainer parent;
  JavaFXHierarchyContainer comp;
  List<String> context=new ArrayList<String>();
  if (component instanceof JavaFXHierarchyContainer) {
    comp=(JavaFXHierarchyContainer)component;
  }
 else {
    comp=getHierarchyContainer(component);
  }
  parent=(JavaFXHierarchyContainer)comp.getPrnt();
  if (parent != null) {
    List<JavaFXHierarchyContainer> comps=parent.getContainerList();
    for (    JavaFXHierarchyContainer child : comps) {
      if (!child.equals(comp)) {
        String toAdd=child.getName();
        context.add(toAdd);
      }
    }
  }
  return context;
}",0.939568345323741
95787,"/** 
 * Checks for uniqueness of <code>name</code> for the components in <code>parent</code>.<br> If parent is null every name is unique, a null name is NEVER unique. If both parameters are null, false is returned. <br>
 * @param parent the hierarchy container containing the components which are checked.
 * @param name the name to check
 * @param container The component for which the name is being checked.
 * @return true if the name is treated as unique, false otherwise.
 */
protected boolean isUniqueName(JavaFXHierarchyContainer parent,String name,JavaFXHierarchyContainer container){
  if (name == null) {
    return false;
  }
  if (parent == null) {
    return true;
  }
  JavaFXHierarchyContainer[] compIDs=parent.getChildren();
  final int length=compIDs.length;
  for (int index=0; index < length; index++) {
    JavaFXHierarchyContainer childContainer=compIDs[index];
    String childName=childContainer.getName();
    if (name.equals(childName) && childContainer != container) {
      return false;
    }
  }
  return true;
}","/** 
 * Checks for uniqueness of <code>name</code> for the components in <code>parent</code>.<br> If parent is null every name is unique, a null name is NEVER unique. If both parameters are null, false is returned. <br>
 * @param parent the hierarchy container containing the components which are checked.
 * @param name the name to check
 * @param container The component for which the name is being checked.
 * @return true if the name is treated as unique, false otherwise.
 */
protected boolean isUniqueName(JavaFXHierarchyContainer parent,String name,JavaFXHierarchyContainer container){
  if (name == null) {
    return false;
  }
  if (parent == null) {
    return true;
  }
  List<JavaFXHierarchyContainer> compIDs=parent.getContainerList();
  for (  JavaFXHierarchyContainer childContainer : compIDs) {
    String childName=childContainer.getName();
    if (name.equals(childName) && childContainer != container) {
      return false;
    }
  }
  return true;
}",0.940825459970164
95788,"@Override public void onChanged(Change<? extends Object> c){
  c.next();
  List<? extends Object> changedObjects=c.getAddedSubList();
  for (  Object o : changedObjects) {
    m_hierarchy.createHierarchyFrom(o);
  }
  changedObjects=c.getRemoved();
  for (  Object o : changedObjects) {
    m_hierarchy.removeComponentFromHierarchy(o);
  }
}","@Override public void onChanged(Change<? extends Object> c){
  c.next();
  List<? extends Object> changedObjects=c.getRemoved();
  for (  Object o : changedObjects) {
    m_hierarchy.removeComponentFromHierarchy(o);
  }
  changedObjects=c.getAddedSubList();
  for (  Object o : changedObjects) {
    m_hierarchy.createHierarchyFrom(o);
  }
}",0.6363636363636364
95789,"/** 
 * Checks if this container has the given container as child container
 * @param child the child container
 * @return true if this container has the given container, false if not.
 */
public boolean contains(JavaFXHierarchyContainer child){
  JavaFXHierarchyContainer[] children=getChildren();
  for (  JavaFXHierarchyContainer cont : children) {
    if (cont.equals(child)) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if this container has the given container as child container
 * @param child the child container
 * @return true if this container has the given container, false if not.
 */
public boolean contains(JavaFXHierarchyContainer child){
  List<JavaFXHierarchyContainer> children=getContainerList();
  for (  JavaFXHierarchyContainer cont : children) {
    if (cont.equals(child)) {
      return true;
    }
  }
  return false;
}",0.96878612716763
95790,"/** 
 * Gets the implementation class. 
 * @param response The response message.
 * @return the implementation class or null if an error occurs.
 */
protected Object getImplClass(CAPTestResponseMessage response){
  Object implClass=null;
  final MessageCap messageCap=m_capTestMessage.getMessageCap();
  IComponentIdentifier ci=messageCap.getCi();
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + (ci == null ? ""String_Node_Str"" : ci.getComponentClassName()));
  }
  try {
    if (!messageCap.hasDefaultMapping()) {
      Validate.notNull(ci);
    }
    int timeout=500;
    boolean isWaitForComponent=WidgetTester.RC_METHOD_NAME_WAIT_FOR_COMPONENT.equals(messageCap.getMethod());
    if (isWaitForComponent) {
      MessageParam timeoutParam=(MessageParam)messageCap.getMessageParams().get(0);
      try {
        timeout=Integer.parseInt(timeoutParam.getValue());
      }
 catch (      NumberFormatException e) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    if (!messageCap.hasDefaultMapping()) {
      Object component=findComponent(ci,timeout);
      implClass=AUTServerConfiguration.getInstance().prepareImplementationClass(component,component.getClass());
    }
 else {
      implClass=AUTServerConfiguration.getInstance().getImplementationClass(ci.getComponentClassName());
    }
    if (isWaitForComponent) {
      MessageParam delayParam=(MessageParam)messageCap.getMessageParams().get(1);
      try {
        int delay=Integer.parseInt(delayParam.getValue());
        TimeUtil.delay(delay);
      }
 catch (      IllegalArgumentException iae) {
        handleInvalidInput(""String_Node_Str"" + CompSystemI18n.getString(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalArgumentException e) {
    handleComponentNotFound(response,e);
  }
catch (  ComponentNotFoundException e) {
    if (WidgetTester.RC_METHOD_NAME_CHECK_EXISTENCE.equals(messageCap.getMethod())) {
      MessageParam isVisibleParam=(MessageParam)messageCap.getMessageParams().get(0);
      handleComponentDoesNotExist(response,Boolean.valueOf(isVisibleParam.getValue()).booleanValue());
    }
 else {
      handleComponentNotFound(response,e);
    }
  }
catch (  UnsupportedComponentException buce) {
    LOG.error(buce.getLocalizedMessage(),buce);
    response.setTestErrorEvent(EventFactory.createConfigErrorEvent());
  }
catch (  Throwable e) {
    if (LOG.isErrorEnabled()) {
      LOG.error(e.getLocalizedMessage(),e);
    }
    response.setTestErrorEvent(EventFactory.createImplClassErrorEvent());
  }
  return implClass;
}","/** 
 * Gets the implementation class. 
 * @param response The response message.
 * @return the implementation class or null if an error occurs.
 */
protected Object getImplClass(CAPTestResponseMessage response){
  Object implClass=null;
  final MessageCap messageCap=m_capTestMessage.getMessageCap();
  IComponentIdentifier ci=messageCap.getCi();
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + (ci == null ? ""String_Node_Str"" : ci.getComponentClassName()));
  }
  try {
    if (!messageCap.hasDefaultMapping()) {
      Validate.notNull(ci);
    }
    int timeout=TimingConstantsServer.DEFAULT_FIND_COMPONENT_TIMEOUT;
    boolean isWaitForComponent=WidgetTester.RC_METHOD_NAME_WAIT_FOR_COMPONENT.equals(messageCap.getMethod());
    if (isWaitForComponent) {
      MessageParam timeoutParam=(MessageParam)messageCap.getMessageParams().get(0);
      try {
        timeout=Integer.parseInt(timeoutParam.getValue());
      }
 catch (      NumberFormatException e) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    if (!messageCap.hasDefaultMapping()) {
      Object component=findComponent(ci,timeout);
      implClass=AUTServerConfiguration.getInstance().prepareImplementationClass(component,component.getClass());
    }
 else {
      implClass=AUTServerConfiguration.getInstance().getImplementationClass(ci.getComponentClassName());
    }
    if (isWaitForComponent) {
      MessageParam delayParam=(MessageParam)messageCap.getMessageParams().get(1);
      try {
        int delay=Integer.parseInt(delayParam.getValue());
        TimeUtil.delay(delay);
      }
 catch (      IllegalArgumentException iae) {
        handleInvalidInput(""String_Node_Str"" + CompSystemI18n.getString(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalArgumentException e) {
    handleComponentNotFound(response,e);
  }
catch (  ComponentNotFoundException e) {
    if (WidgetTester.RC_METHOD_NAME_CHECK_EXISTENCE.equals(messageCap.getMethod())) {
      MessageParam isVisibleParam=(MessageParam)messageCap.getMessageParams().get(0);
      handleComponentDoesNotExist(response,Boolean.valueOf(isVisibleParam.getValue()).booleanValue());
    }
 else {
      handleComponentNotFound(response,e);
    }
  }
catch (  UnsupportedComponentException buce) {
    LOG.error(buce.getLocalizedMessage(),buce);
    response.setTestErrorEvent(EventFactory.createConfigErrorEvent());
  }
catch (  Throwable e) {
    if (LOG.isErrorEnabled()) {
      LOG.error(e.getLocalizedMessage(),e);
    }
    response.setTestErrorEvent(EventFactory.createImplClassErrorEvent());
  }
  return implClass;
}",0.9894169713296131
95791,"/** 
 * Removes a container from the hierarchy. This means that the following references will be removed: <br> -Container from the hierarchy Map <br> -The component of the given container from the real map <br> -The reference from the parent container to the given container <br> -The actions mentioned above for all children of this container
 * @param ctner the container that will be deleted
 */
public void removeContainer(JavaFXHierarchyContainer ctner){
  m_lock.lock();
  try {
    Map contMap=getHierarchyMap();
    Map realMap=getRealMap();
    JavaFXComponent fxComp=ctner.getComponent();
    fxComp.removeChangeListener();
    contMap.remove(ctner.getComponent());
    realMap.remove(fxComp.getRealComponent());
    JavaFXHierarchyContainer parent=(JavaFXHierarchyContainer)ctner.getPrnt();
    if (parent != null) {
      parent.remove(ctner);
    }
    List<JavaFXHierarchyContainer> children=new ArrayList<>(ctner.getContainerList());
    for (    JavaFXHierarchyContainer child : children) {
      removeContainer(child);
    }
  }
  finally {
    m_lock.unlock();
  }
}","/** 
 * Removes a container from the hierarchy. This means that the following references will be removed: <br> -Container from the hierarchy Map <br> -The component of the given container from the real map <br> -The reference from the parent container to the given container <br> -The actions mentioned above for all children of this container
 * @param ctner the container that will be deleted
 */
public void removeContainer(JavaFXHierarchyContainer ctner){
  lock.lock();
  try {
    Map contMap=getHierarchyMap();
    Map realMap=getRealMap();
    JavaFXComponent fxComp=ctner.getComponent();
    fxComp.removeChangeListener();
    contMap.remove(ctner.getComponent());
    realMap.remove(fxComp.getRealComponent());
    JavaFXHierarchyContainer parent=(JavaFXHierarchyContainer)ctner.getPrnt();
    if (parent != null) {
      parent.remove(ctner);
    }
    List<JavaFXHierarchyContainer> children=new ArrayList<>(ctner.getContainerList());
    for (    JavaFXHierarchyContainer child : children) {
      removeContainer(child);
    }
  }
  finally {
    lock.unlock();
  }
}",0.9981532779316712
95792,"/** 
 * Returns the lock of the hierarchy
 * @return the lock
 */
public ReentrantLock getLock(){
  return m_lock;
}","/** 
 * Returns the lock of the hierarchy
 * @return the lock
 */
public static ReentrantLock getLock(){
  return lock;
}",0.9620253164556962
95793,"/** 
 * Creates the Hierarchy from a given Object
 * @param o the Object
 */
public void createHierarchyFrom(Object o){
  m_lock.lock();
  try {
    Map realMap=getRealMap();
    Object parent=ParentGetter.get(o);
    Object lastParent=parent;
    while (parent != null) {
      if (realMap.containsKey(parent)) {
        lastParent=parent;
        break;
      }
      lastParent=parent;
      parent=ParentGetter.get(parent);
    }
    createHierarchy(lastParent == null ? o : lastParent);
  }
  finally {
    m_lock.unlock();
  }
}","/** 
 * Creates the Hierarchy from a given Object
 * @param o the Object
 */
public void createHierarchyFrom(Object o){
  lock.lock();
  try {
    Map realMap=getRealMap();
    Object parent=ParentGetter.get(o);
    Object lastParent=parent;
    while (parent != null) {
      if (realMap.containsKey(parent)) {
        lastParent=parent;
        break;
      }
      lastParent=parent;
      parent=ParentGetter.get(parent);
    }
    createHierarchy(lastParent == null ? o : lastParent);
  }
  finally {
    lock.unlock();
  }
}",0.9962406015037594
95794,"/** 
 * Searchs the component in the AUT, which belongs to the given <code>componentIdentifier</code>.
 * @param componentIdentifier the identifier of the component to search for
 * @param retry number of tries to get object
 * @param timeout timeout for retries
 * @throws ComponentNotFoundException if no component is found for the given identifier.
 * @throws IllegalArgumentException if the identifier is null or contains invalid data {@inheritDoc}
 * @return the found component
 */
public static Object findComponent(IComponentIdentifier componentIdentifier,boolean retry,int timeout) throws ComponentNotFoundException, IllegalArgumentException {
  long start=System.currentTimeMillis();
  ReentrantLock lock=hierarchy.getLock();
  try {
    lock.lock();
    return hierarchy.findComponent(componentIdentifier);
  }
 catch (  ComponentNotManagedException cnme) {
    if (retry) {
      if (lock.isHeldByCurrentThread()) {
        lock.unlock();
      }
      while (System.currentTimeMillis() - start < timeout) {
        try {
          lock.lock();
          return hierarchy.findComponent(componentIdentifier);
        }
 catch (        ComponentNotManagedException e) {
          if (lock.isHeldByCurrentThread()) {
            lock.unlock();
          }
          try {
            Thread.sleep(TimingConstantsServer.POLLING_DELAY_FIND_COMPONENT);
          }
 catch (          InterruptedException e1) {
          }
        }
catch (        InvalidDataException ide) {
        }
      }
    }
    throw new ComponentNotFoundException(cnme.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae);
    throw iae;
  }
catch (  InvalidDataException ide) {
    log.error(ide);
    throw new ComponentNotFoundException(ide.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
 finally {
    if (lock.isHeldByCurrentThread()) {
      lock.unlock();
    }
  }
}","/** 
 * Searchs the component in the AUT, which belongs to the given <code>componentIdentifier</code>.
 * @param componentIdentifier the identifier of the component to search for
 * @param retry number of tries to get object
 * @param timeout timeout for retries
 * @throws ComponentNotFoundException if no component is found for the given identifier.
 * @throws IllegalArgumentException if the identifier is null or contains invalid data {@inheritDoc}
 * @return the found component
 */
public static Object findComponent(IComponentIdentifier componentIdentifier,boolean retry,int timeout) throws ComponentNotFoundException, IllegalArgumentException {
  long start=System.currentTimeMillis();
  try {
    lock.lock();
    return hierarchy.findComponent(componentIdentifier);
  }
 catch (  ComponentNotManagedException cnme) {
    if (retry) {
      if (lock.isHeldByCurrentThread()) {
        lock.unlock();
      }
      while (System.currentTimeMillis() - start < timeout) {
        try {
          lock.lock();
          return hierarchy.findComponent(componentIdentifier);
        }
 catch (        ComponentNotManagedException e) {
          if (lock.isHeldByCurrentThread()) {
            lock.unlock();
          }
          try {
            Thread.sleep(TimingConstantsServer.POLLING_DELAY_FIND_COMPONENT);
          }
 catch (          InterruptedException e1) {
          }
        }
catch (        InvalidDataException ide) {
        }
      }
    }
    throw new ComponentNotFoundException(cnme.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae);
    throw iae;
  }
catch (  InvalidDataException ide) {
    log.error(ide);
    throw new ComponentNotFoundException(ide.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
 finally {
    if (lock.isHeldByCurrentThread()) {
      lock.unlock();
    }
  }
}",0.9889415481832544
95795,"/** 
 * Searchs the component in the AUT, which belongs to the given <code>componentIdentifier</code>.
 * @param componentIdentifier the identifier of the component to search for
 * @param retry number of tries to get object
 * @param timeout timeout for retries
 * @throws ComponentNotFoundException if no component is found for the given identifier.
 * @throws IllegalArgumentException if the identifier is null or contains invalid data {@inheritDoc}
 * @return the found component
 */
public static Object findComponent(IComponentIdentifier componentIdentifier,boolean retry,int timeout) throws ComponentNotFoundException, IllegalArgumentException {
  long start=System.currentTimeMillis();
  ReentrantLock lock=hierarchy.getLock();
  try {
    return hierarchy.findComponent(componentIdentifier);
  }
 catch (  ComponentNotManagedException cnme) {
    if (retry) {
      while (System.currentTimeMillis() - start < timeout) {
        try {
          lock.lock();
          return hierarchy.findComponent(componentIdentifier);
        }
 catch (        ComponentNotManagedException e) {
          lock.unlock();
          try {
            Thread.sleep(TimingConstantsServer.POLLING_DELAY_FIND_COMPONENT);
          }
 catch (          InterruptedException e1) {
          }
        }
catch (        InvalidDataException ide) {
        }
      }
    }
    throw new ComponentNotFoundException(cnme.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae);
    throw iae;
  }
catch (  InvalidDataException ide) {
    log.error(ide);
    throw new ComponentNotFoundException(ide.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
 finally {
    if (lock.isHeldByCurrentThread()) {
      lock.unlock();
    }
  }
}","/** 
 * Searchs the component in the AUT, which belongs to the given <code>componentIdentifier</code>.
 * @param componentIdentifier the identifier of the component to search for
 * @param retry number of tries to get object
 * @param timeout timeout for retries
 * @throws ComponentNotFoundException if no component is found for the given identifier.
 * @throws IllegalArgumentException if the identifier is null or contains invalid data {@inheritDoc}
 * @return the found component
 */
public static Object findComponent(IComponentIdentifier componentIdentifier,boolean retry,int timeout) throws ComponentNotFoundException, IllegalArgumentException {
  long start=System.currentTimeMillis();
  ReentrantLock lock=hierarchy.getLock();
  try {
    lock.lock();
    return hierarchy.findComponent(componentIdentifier);
  }
 catch (  ComponentNotManagedException cnme) {
    if (retry) {
      if (lock.isHeldByCurrentThread()) {
        lock.unlock();
      }
      while (System.currentTimeMillis() - start < timeout) {
        try {
          lock.lock();
          return hierarchy.findComponent(componentIdentifier);
        }
 catch (        ComponentNotManagedException e) {
          if (lock.isHeldByCurrentThread()) {
            lock.unlock();
          }
          try {
            Thread.sleep(TimingConstantsServer.POLLING_DELAY_FIND_COMPONENT);
          }
 catch (          InterruptedException e1) {
          }
        }
catch (        InvalidDataException ide) {
        }
      }
    }
    throw new ComponentNotFoundException(cnme.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae);
    throw iae;
  }
catch (  InvalidDataException ide) {
    log.error(ide);
    throw new ComponentNotFoundException(ide.getMessage(),MessageIDs.E_COMPONENT_NOT_FOUND);
  }
 finally {
    if (lock.isHeldByCurrentThread()) {
      lock.unlock();
    }
  }
}",0.9582655826558264
95796,"/** 
 * executes the complete test
 * @throws CommunicationException Error
 * @return boolean true if all testsuites completed successfully or if test execution was successful up to specified mode of no-run option
 */
public boolean executeJob() throws CommunicationException {
  String noRun=m_job.getNoRunOptMode();
  if (AbstractCmdlineClient.isNoRun()) {
    noRun=noRunStartPreparation(noRun);
  }
  WatchdogTimer timer=null;
  if (m_job.getTimeout() > 0) {
    timer=new WatchdogTimer(m_job.getTimeout());
    timer.start();
  }
  IClientTest clientTest=ClientTest.instance();
  if (!prepareAUTAgentConnection(clientTest)) {
    return false;
  }
 else   if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.CAA)) {
    return true;
  }
  clientTest.setRelevantFlag(m_job.isRelevant());
  clientTest.setScreenshotXMLFlag(m_job.isXMLScreenshot());
  prepareDBConnection();
  if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.CDB)) {
    return true;
  }
  loadProject();
  if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.LP)) {
    return true;
  }
  checkTestCompleteness();
  if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.CC)) {
    return true;
  }
  m_idle=true;
  if (m_shutdown) {
    sysOut(Messages.ReceivedShutdownCommand);
    endTestExecution();
  }
  try {
    if (m_rmiBase != null) {
      doClcService();
    }
 else {
      ensureAutIsStarted(m_job.getActualTestSuite(),m_job.getAutConfig());
      if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.SA)) {
        return true;
      }
      doTest(m_job.getTestJob() != null);
    }
  }
 catch (  ToolkitPluginException e1) {
    sysErr(NLS.bind(Messages.ExecutionControllerAUT,Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE));
  }
  if (timer != null) {
    timer.abort();
  }
  return isNoErrorWhileExecution();
}","/** 
 * executes the complete test
 * @throws CommunicationException Error
 * @return boolean true if all testsuites completed successfully or if test execution was successful up to specified mode of no-run option
 */
public boolean executeJob() throws CommunicationException {
  String noRun=m_job.getNoRunOptMode();
  if (AbstractCmdlineClient.isNoRun()) {
    noRun=noRunStartPreparation(noRun);
  }
  WatchdogTimer timer=null;
  if (m_job.getTimeout() > 0) {
    timer=new WatchdogTimer(m_job.getTimeout());
    timer.start();
  }
  IClientTest clientTest=ClientTest.instance();
  if (!prepareAUTAgentConnection(clientTest)) {
    return false;
  }
 else   if (isExecutionFinished(noRun,CAA)) {
    return true;
  }
  clientTest.setRelevantFlag(m_job.isRelevant());
  clientTest.setScreenshotXMLFlag(m_job.isXMLScreenshot());
  prepareDBConnection();
  if (isExecutionFinished(noRun,CDB)) {
    return true;
  }
  loadProject();
  if (isExecutionFinished(noRun,LP)) {
    return true;
  }
  checkTestCompleteness();
  if (isExecutionFinished(noRun,CC)) {
    return true;
  }
  m_idle=true;
  if (m_shutdown) {
    sysOut(Messages.ReceivedShutdownCommand);
    endTestExecution();
  }
  try {
    if (m_rmiBase != null) {
      doClcService();
    }
 else {
      ensureAutIsStarted(m_job.getActualTestSuite(),m_job.getAutConfig());
      if (isExecutionFinished(noRun,SA)) {
        return true;
      }
      doTest(m_job.getTestJob() != null);
    }
  }
 catch (  ToolkitPluginException e1) {
    sysErr(NLS.bind(Messages.ExecutionControllerAUT,Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE));
  }
  if (timer != null) {
    timer.abort();
  }
  return isNoErrorWhileExecution();
}",0.9588418961112688
95797,"/** 
 * @param testSuite testSuite
 * @param locale language valid for testexecution
 * @param monitor the progress monitor to use
 * @param noRunOptMode the value of no-run option argument if it was specified, null otherwise
 */
private void startTestSuite(ITestSuitePO testSuite,Locale locale,IProgressMonitor monitor,String noRunOptMode){
  Validate.notNull(testSuite,""String_Node_Str"");
  ICapPO firstCap=null;
  m_expectedNumberOfSteps=0;
  m_trav=new Traverser(testSuite,locale);
  try {
    monitor.subTask(Messages.StartingTestSuite_resolvingTestStepsToExecute);
    monitor.subTask(Messages.StartingTestSuite_buildingTestExecutionTree);
    Traverser copier=new Traverser(testSuite,locale);
    ResultTreeBuilder resultTreeBuilder=new ResultTreeBuilder(copier);
    copier.addExecStackModificationListener(resultTreeBuilder);
    ICapPO iterNode=copier.next();
    while (iterNode != null) {
      iterNode=copier.next();
      m_expectedNumberOfSteps++;
    }
    Map<String,String> autConfigMap=getConnectedAUTsConfigMap();
    resetMonitoringData(autConfigMap,monitor);
    if (noRunOptMode.equals(TestexecConstants.NoRunSteps.BT.getStepValue())) {
      return;
    }
    TestResultBP.getInstance().setResultTestModel(new TestResult(resultTreeBuilder.getRootNode(),autConfigMap));
    initTestExecutionMessage(autConfigMap,monitor);
    m_resultTreeTracker=new ResultTreeTracker(resultTreeBuilder.getRootNode(),m_externalTestDataBP);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,ClientTestImpl.TEST_SUITE_EXECUTION_RELATIVE_WORK_AMOUNT);
    subMonitor.beginTask(NLS.bind(Messages.StartWorkingWithTestSuite,testSuite.getName()),m_expectedNumberOfSteps);
    m_stepCounter=new StepCounter(subMonitor);
    addTestExecutionListener();
    setStepSpeed(testSuite.getStepDelay());
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_RESULT_TREE_READY));
    monitor.subTask(NLS.bind(Messages.StartingTestSuite,testSuite.getName()));
    firstCap=m_trav.next();
  }
 catch (  JBException e) {
    LOG.error(Messages.IncompleteTestdata,e);
    fireError(e);
  }
  if (firstCap != null) {
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_START));
    processCap(firstCap);
  }
 else {
    endTestExecution();
  }
}","/** 
 * @param testSuite testSuite
 * @param locale language valid for testexecution
 * @param monitor the progress monitor to use
 * @param noRunOptMode the value of no-run option argument if it was specified, null otherwise
 */
private void startTestSuite(ITestSuitePO testSuite,Locale locale,IProgressMonitor monitor,String noRunOptMode){
  Validate.notNull(testSuite,""String_Node_Str"");
  ICapPO firstCap=null;
  m_expectedNumberOfSteps=0;
  m_trav=new Traverser(testSuite,locale);
  try {
    monitor.subTask(Messages.StartingTestSuite_resolvingTestStepsToExecute);
    monitor.subTask(Messages.StartingTestSuite_buildingTestExecutionTree);
    Traverser copier=new Traverser(testSuite,locale);
    ResultTreeBuilder resultTreeBuilder=new ResultTreeBuilder(copier);
    copier.addExecStackModificationListener(resultTreeBuilder);
    ICapPO iterNode=copier.next();
    while (iterNode != null) {
      iterNode=copier.next();
      m_expectedNumberOfSteps++;
    }
    Map<String,String> autConfigMap=getConnectedAUTsConfigMap();
    resetMonitoringData(autConfigMap,monitor);
    if (isExecutionFinished(noRunOptMode,BT)) {
      return;
    }
    TestResultBP.getInstance().setResultTestModel(new TestResult(resultTreeBuilder.getRootNode(),autConfigMap));
    initTestExecutionMessage(autConfigMap,monitor);
    m_resultTreeTracker=new ResultTreeTracker(resultTreeBuilder.getRootNode(),m_externalTestDataBP);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,ClientTestImpl.TEST_SUITE_EXECUTION_RELATIVE_WORK_AMOUNT);
    subMonitor.beginTask(NLS.bind(Messages.StartWorkingWithTestSuite,testSuite.getName()),m_expectedNumberOfSteps);
    m_stepCounter=new StepCounter(subMonitor);
    addTestExecutionListener();
    setStepSpeed(testSuite.getStepDelay());
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_RESULT_TREE_READY));
    monitor.subTask(NLS.bind(Messages.StartingTestSuite,testSuite.getName()));
    firstCap=m_trav.next();
  }
 catch (  JBException e) {
    LOG.error(Messages.IncompleteTestdata,e);
    fireError(e);
  }
  if (firstCap != null) {
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_START));
    processCap(firstCap);
  }
 else {
    endTestExecution();
  }
}",0.984140777753639
95798,"/** 
 * This method executes the given Test Suite
 * @param testSuite the TestSuitePO that will be tested
 * @param locale Locale
 * @param autoScreenshot whether screenshots should be automatically taken in case of test execution errors
 * @param autId The ID of the Running AUT on which the test will take place.
 * @param externalVars a map of externally set variables; may be <code>null</code>
 * @param summary The Test Result Summary for the executed test.  Must not be <code>null</code>.
 * @param monitor the monitor to use
 * @param noRunOptMode The value of no-run option argument if it was specified, null otherwise
 */
public void executeTestSuite(ITestSuitePO testSuite,Locale locale,AutIdentifier autId,boolean autoScreenshot,Map<String,String> externalVars,ITestResultSummaryPO summary,final IProgressMonitor monitor,String noRunOptMode){
  m_stopped=false;
  m_autoScreenshot=autoScreenshot;
  setPaused(false);
  Validate.notNull(testSuite,Messages.TestsuiteMustNotBeNull);
  m_executionLanguage=locale;
  monitor.subTask(NLS.bind(Messages.PreparingTestSuiteExecution,testSuite.getName()));
  m_externalTestDataBP.clearExternalData();
  if (noRunOptMode.equals(TestexecConstants.NoRunSteps.PTE.getStepValue())) {
    return;
  }
  try {
    if (AUTConnection.getInstance().connectToAut(autId,new SubProgressMonitor(monitor,0))) {
      if (noRunOptMode.equals(TestexecConstants.NoRunSteps.CA.getStepValue())) {
        return;
      }
      summary.setAutHostname(AUTConnection.getInstance().getCommunicator().getConnection().getAddress().getCanonicalHostName());
      summary.setAutAgentName(AutAgentConnection.getInstance().getCommunicator().getHostName());
      monitor.subTask(Messages.StartingTestSuite_resolvingPredefinedVariables);
      m_varStore.storeEnvironmentVariables();
      storePredefinedVariables(m_varStore,testSuite);
      storeExternallyDefinedVariables(m_varStore,externalVars);
      if (noRunOptMode.equals(TestexecConstants.NoRunSteps.RPV.getStepValue())) {
        return;
      }
      startTestSuite(testSuite,locale,monitor,noRunOptMode);
      final AtomicBoolean testSuiteFinished=new AtomicBoolean();
      ClientTest.instance().addTestExecutionEventListener(new ITestExecutionEventListener(){
        public void endTestExecution(){
          try {
            AUTConnection.getInstance().close();
          }
 catch (          ConnectionException e) {
          }
          ClientTest.instance().removeTestExecutionEventListener(this);
          testSuiteFinished.set(true);
        }
        public void stateChanged(        TestExecutionEvent event){
        }
      }
);
      while (!testSuiteFinished.get()) {
        TimeUtil.delay(250);
      }
    }
 else {
      handleNoConnectionToAUT(testSuite,autId);
    }
  }
 catch (  ConnectionException e) {
    LOG.error(Messages.UnableToConnectToAUT + StringConstants.DOT,e);
  }
}","/** 
 * This method executes the given Test Suite
 * @param testSuite the TestSuitePO that will be tested
 * @param locale Locale
 * @param autoScreenshot whether screenshots should be automatically taken in case of test execution errors
 * @param autId The ID of the Running AUT on which the test will take place.
 * @param externalVars a map of externally set variables; may be <code>null</code>
 * @param summary The Test Result Summary for the executed test.  Must not be <code>null</code>.
 * @param monitor the monitor to use
 * @param noRunOptMode The value of no-run option argument if it was specified, null otherwise
 */
public void executeTestSuite(ITestSuitePO testSuite,Locale locale,AutIdentifier autId,boolean autoScreenshot,Map<String,String> externalVars,ITestResultSummaryPO summary,final IProgressMonitor monitor,String noRunOptMode){
  m_stopped=false;
  m_autoScreenshot=autoScreenshot;
  setPaused(false);
  Validate.notNull(testSuite,Messages.TestsuiteMustNotBeNull);
  m_executionLanguage=locale;
  monitor.subTask(NLS.bind(Messages.PreparingTestSuiteExecution,testSuite.getName()));
  m_externalTestDataBP.clearExternalData();
  if (isExecutionFinished(noRunOptMode,PTE)) {
    return;
  }
  try {
    if (AUTConnection.getInstance().connectToAut(autId,new SubProgressMonitor(monitor,0))) {
      if (isExecutionFinished(noRunOptMode,CA)) {
        return;
      }
      summary.setAutHostname(AUTConnection.getInstance().getCommunicator().getConnection().getAddress().getCanonicalHostName());
      summary.setAutAgentName(AutAgentConnection.getInstance().getCommunicator().getHostName());
      monitor.subTask(Messages.StartingTestSuite_resolvingPredefinedVariables);
      m_varStore.storeEnvironmentVariables();
      storePredefinedVariables(m_varStore,testSuite);
      storeExternallyDefinedVariables(m_varStore,externalVars);
      if (isExecutionFinished(noRunOptMode,RPV)) {
        return;
      }
      startTestSuite(testSuite,locale,monitor,noRunOptMode);
      final AtomicBoolean testSuiteFinished=new AtomicBoolean();
      ClientTest.instance().addTestExecutionEventListener(new ITestExecutionEventListener(){
        public void endTestExecution(){
          try {
            AUTConnection.getInstance().close();
          }
 catch (          ConnectionException e) {
          }
          ClientTest.instance().removeTestExecutionEventListener(this);
          testSuiteFinished.set(true);
        }
        public void stateChanged(        TestExecutionEvent event){
        }
      }
);
      while (!testSuiteFinished.get()) {
        TimeUtil.delay(250);
      }
    }
 else {
      handleNoConnectionToAUT(testSuite,autId);
    }
  }
 catch (  ConnectionException e) {
    LOG.error(Messages.UnableToConnectToAUT + StringConstants.DOT,e);
  }
}",0.9614775725593668
95799,"/** 
 * parses command line datadir parameter and set them into job object or sets default value for datadir otherwise <code>INVALID_VALUE</code> is set if the default datadir path is invalid 
 * @param cmd CommandLine
 * @param baseDatadirPath the default dataDir path
 */
private void parseDataDirOptions(CommandLine cmd,String baseDatadirPath){
  if (cmd.hasOption(ClientTestStrings.DATA_DIR)) {
    setDataDir(FileUtils.resolveAgainstBasePath(cmd.getOptionValue(ClientTestStrings.DATA_DIR),baseDatadirPath));
  }
 else {
    setDataDir((!StringUtils.isEmpty(baseDatadirPath)) ? baseDatadirPath : String.valueOf(TestexecConstants.INVALID_VALUE));
  }
}","/** 
 * parses command line datadir parameter and set them into job object or sets default value for datadir otherwise <code>INVALID_VALUE</code> is set if the default datadir path is invalid 
 * @param cmd CommandLine
 */
private void parseDataDirOptions(CommandLine cmd){
  String baseDatadirPath=getDefaultDataDirPath();
  if (cmd.hasOption(ClientTestStrings.DATA_DIR)) {
    setDataDir(FileUtils.resolveAgainstBasePath(cmd.getOptionValue(ClientTestStrings.DATA_DIR),baseDatadirPath));
  }
  if (getDataDir() == null) {
    setDataDir((!StringUtils.isEmpty(baseDatadirPath)) ? baseDatadirPath : String.valueOf(TestexecConstants.INVALID_VALUE));
  }
}",0.845565749235474
95800,"/** 
 * {@inheritDoc}
 * @throws IllegalArgumentException if no suitable Database Connection can be found.
 */
public Object unmarshal(HierarchicalStreamReader arg0,UnmarshallingContext arg1) throws IllegalArgumentException {
  JobConfiguration job=new JobConfiguration();
  while (arg0.hasMoreChildren()) {
    arg0.moveDown();
    if (arg0.getNodeName().equals(ClientTestStrings.PROJECT)) {
      job.setProjectName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PROJECT_VERSION)) {
      job.setProjectVersion(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.SERVER)) {
      job.setServer(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PORT)) {
      job.setPort(validateAndParseIntPortNumber(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.RESULTDIR)) {
      job.setResultDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DBURL)) {
      String dbURL=arg0.getValue();
      job.setDb(dbURL);
      DatabaseConnectionInfo connectionInfo=getConnectionInfo(dbURL);
      job.setDbscheme(connectionInfo);
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_SCHEME)) {
      job.setDbConnectionName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_USER)) {
      job.setDbuser(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_PW)) {
      job.setDbpw(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.LANGUAGE)) {
      job.setLanguage(LocaleUtil.convertStrToLocale(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_CONFIG)) {
      job.setAutConfigName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_ID)) {
      job.setAutId(new AutIdentifier(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DATA_DIR)) {
      job.setDataDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTSUITE)) {
      job.setTestSuiteName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTJOB)) {
      job.setTestJobName(arg0.getValue());
    }
 else {
      String defaultDataDirPath=getDefaultDataDirPath();
      job.setDataDir((!StringUtils.isEmpty(defaultDataDirPath)) ? defaultDataDirPath : String.valueOf(TestexecConstants.INVALID_VALUE));
    }
    arg0.moveUp();
  }
  return job;
}","/** 
 * {@inheritDoc}
 * @throws IllegalArgumentException if no suitable Database Connection can be found.
 */
public Object unmarshal(HierarchicalStreamReader arg0,UnmarshallingContext arg1) throws IllegalArgumentException {
  JobConfiguration job=new JobConfiguration();
  while (arg0.hasMoreChildren()) {
    arg0.moveDown();
    if (arg0.getNodeName().equals(ClientTestStrings.PROJECT)) {
      job.setProjectName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PROJECT_VERSION)) {
      job.setProjectVersion(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.SERVER)) {
      job.setServer(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.PORT)) {
      job.setPort(validateAndParseIntPortNumber(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.RESULTDIR)) {
      job.setResultDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DBURL)) {
      String dbURL=arg0.getValue();
      job.setDb(dbURL);
      DatabaseConnectionInfo connectionInfo=getConnectionInfo(dbURL);
      job.setDbscheme(connectionInfo);
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_SCHEME)) {
      job.setDbConnectionName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_USER)) {
      job.setDbuser(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DB_PW)) {
      job.setDbpw(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.LANGUAGE)) {
      job.setLanguage(LocaleUtil.convertStrToLocale(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_CONFIG)) {
      job.setAutConfigName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.AUT_ID)) {
      job.setAutId(new AutIdentifier(arg0.getValue()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.DATA_DIR)) {
      job.setDataDir(FileUtils.resolveAgainstBasePath(arg0.getValue(),getDefaultDataDirPath()));
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTSUITE)) {
      job.setTestSuiteName(arg0.getValue());
    }
 else     if (arg0.getNodeName().equals(ClientTestStrings.TESTJOB)) {
      job.setTestJobName(arg0.getValue());
    }
    arg0.moveUp();
  }
  return job;
}",0.9593114241001564
95801,"/** 
 * parses command line parameter and set them into job object
 * @param cmd CommandLine
 */
public void parseJobOptions(CommandLine cmd){
  String baseDatadirPath=getDefaultDataDirPath();
  if (cmd.hasOption(ClientTestStrings.PROJECT)) {
    setProjectName(cmd.getOptionValue(ClientTestStrings.PROJECT));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT_VERSION)) {
    String[] numbers=cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION).split(""String_Node_Str"");
    if (numbers.length == 2) {
      try {
        setProjectMajor(Integer.parseInt(numbers[0]));
        setProjectMinor(Integer.parseInt(numbers[1]));
      }
 catch (      NumberFormatException nfe) {
      }
    }
  }
  if (cmd.hasOption(ClientTestStrings.SERVER)) {
    setServer(cmd.getOptionValue(ClientTestStrings.SERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PORT)) {
    setPort(validateAndParseIntPortNumber(cmd.getOptionValue(ClientTestStrings.PORT)));
  }
  parseDBOptions(cmd);
  parseResultDirOptions(cmd);
  parseDataDirOptions(cmd,baseDatadirPath);
  if (cmd.hasOption(ClientTestStrings.AUT_CONFIG)) {
    setAutConfigName(cmd.getOptionValue(ClientTestStrings.AUT_CONFIG));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_ID)) {
    String autIdString=cmd.getOptionValue(ClientTestStrings.AUT_ID);
    if (autIdString != null) {
      setAutId(new AutIdentifier(autIdString));
    }
  }
  if (cmd.hasOption(ClientTestStrings.LANGUAGE)) {
    setLanguage(LocaleUtil.convertStrToLocale(cmd.getOptionValue(ClientTestStrings.LANGUAGE)));
  }
  if (cmd.hasOption(ClientTestStrings.TESTSUITE)) {
    String tsName=cmd.getOptionValue(ClientTestStrings.TESTSUITE);
    List<String> tsNamesList=new ArrayList<String>();
    tsNamesList.add(tsName);
    setTestSuiteNames(tsNamesList);
  }
  if (cmd.hasOption(ClientTestStrings.TESTJOB)) {
    setTestJobName(cmd.getOptionValue(ClientTestStrings.TESTJOB));
  }
  if (cmd.hasOption(ClientTestStrings.AUTO_SCREENSHOT)) {
    setAutoScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.TEST_EXECUTION_RELEVANT)) {
    setRelevant(false);
  }
  if (cmd.hasOption(ClientTestStrings.NO_XML_SCREENSHOT)) {
    setXMLScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.TIMEOUT)) {
    try {
      setTimeout(Integer.parseInt(cmd.getOptionValue(ClientTestStrings.TIMEOUT)));
    }
 catch (    NumberFormatException e) {
      setTimeout(TestexecConstants.INVALID_VALUE);
    }
  }
}","/** 
 * parses command line parameter and set them into job object
 * @param cmd CommandLine
 */
public void parseJobOptions(CommandLine cmd){
  if (cmd.hasOption(ClientTestStrings.PROJECT)) {
    setProjectName(cmd.getOptionValue(ClientTestStrings.PROJECT));
  }
  if (cmd.hasOption(ClientTestStrings.PROJECT_VERSION)) {
    String[] numbers=cmd.getOptionValue(ClientTestStrings.PROJECT_VERSION).split(""String_Node_Str"");
    if (numbers.length == 2) {
      try {
        setProjectMajor(Integer.parseInt(numbers[0]));
        setProjectMinor(Integer.parseInt(numbers[1]));
      }
 catch (      NumberFormatException nfe) {
      }
    }
  }
  if (cmd.hasOption(ClientTestStrings.SERVER)) {
    setServer(cmd.getOptionValue(ClientTestStrings.SERVER));
  }
  if (cmd.hasOption(ClientTestStrings.PORT)) {
    setPort(validateAndParseIntPortNumber(cmd.getOptionValue(ClientTestStrings.PORT)));
  }
  parseDBOptions(cmd);
  parseResultDirOptions(cmd);
  parseDataDirOptions(cmd);
  if (cmd.hasOption(ClientTestStrings.AUT_CONFIG)) {
    setAutConfigName(cmd.getOptionValue(ClientTestStrings.AUT_CONFIG));
  }
  if (cmd.hasOption(ClientTestStrings.AUT_ID)) {
    String autIdString=cmd.getOptionValue(ClientTestStrings.AUT_ID);
    if (autIdString != null) {
      setAutId(new AutIdentifier(autIdString));
    }
  }
  if (cmd.hasOption(ClientTestStrings.LANGUAGE)) {
    setLanguage(LocaleUtil.convertStrToLocale(cmd.getOptionValue(ClientTestStrings.LANGUAGE)));
  }
  if (cmd.hasOption(ClientTestStrings.TESTSUITE)) {
    String tsName=cmd.getOptionValue(ClientTestStrings.TESTSUITE);
    List<String> tsNamesList=new ArrayList<String>();
    tsNamesList.add(tsName);
    setTestSuiteNames(tsNamesList);
  }
  if (cmd.hasOption(ClientTestStrings.TESTJOB)) {
    setTestJobName(cmd.getOptionValue(ClientTestStrings.TESTJOB));
  }
  if (cmd.hasOption(ClientTestStrings.AUTO_SCREENSHOT)) {
    setAutoScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.TEST_EXECUTION_RELEVANT)) {
    setRelevant(false);
  }
  if (cmd.hasOption(ClientTestStrings.NO_XML_SCREENSHOT)) {
    setXMLScreenshot(false);
  }
  if (cmd.hasOption(ClientTestStrings.TIMEOUT)) {
    try {
      setTimeout(Integer.parseInt(cmd.getOptionValue(ClientTestStrings.TIMEOUT)));
    }
 catch (    NumberFormatException e) {
      setTimeout(TestexecConstants.INVALID_VALUE);
    }
  }
}",0.986198243412798
95802,"/** 
 * checks if the given path is absolute and otherwise resolves it to the absolute against the base path
 * @param basePath the base path
 * @param path a path given by user
 * @return absolute path (the initial one or the resolved against the base path one)
 */
public static String resolveAgainstBasePath(String path,String basePath){
  File baseDir=new File(basePath);
  File fpath=new File(path);
  if (!fpath.isAbsolute()) {
    fpath=new File(baseDir,path);
  }
  return fpath.toString();
}","/** 
 * checks if the given path is absolute and otherwise resolves it to the absolute against the base path
 * @param basePath the base path
 * @param path a path given by user
 * @return absolute path (the initial one or the resolved against the base path one)
 */
public static String resolveAgainstBasePath(String path,String basePath){
  if (path == null || basePath == null) {
    return null;
  }
  File baseDir=new File(basePath);
  File fpath=new File(path);
  if (!fpath.isAbsolute()) {
    fpath=new File(baseDir,path);
  }
  return fpath.toString();
}",0.940733772342427
95803,"/** 
 * executes the complete test
 * @throws CommunicationException Error
 * @return boolean true if all testsuites completed successfully or if test execution was successful up to specified mode of no-run option
 */
public boolean executeJob() throws CommunicationException {
  String noRun=m_job.getNoRunOptMode();
  if (AbstractCmdlineClient.isNoRun()) {
    noRun=noRunStartPreparation(noRun);
  }
  WatchdogTimer timer=null;
  if (m_job.getTimeout() > 0) {
    timer=new WatchdogTimer(m_job.getTimeout());
    timer.start();
  }
  IClientTest clientTest=ClientTest.instance();
  if (!prepareAUTAgentConnection(clientTest)) {
    return false;
  }
 else   if (isExecutionFinished(noRun,CAA)) {
    return true;
  }
  clientTest.setRelevantFlag(m_job.isRelevant());
  clientTest.setScreenshotXMLFlag(m_job.isXMLScreenshot());
  prepareDBConnection();
  if (isExecutionFinished(noRun,CDB)) {
    return true;
  }
  loadProject();
  if (isExecutionFinished(noRun,LP)) {
    return true;
  }
  checkTestCompleteness();
  if (isExecutionFinished(noRun,CC)) {
    return true;
  }
  m_idle=true;
  if (m_shutdown) {
    sysOut(Messages.ReceivedShutdownCommand);
    endTestExecution();
  }
  try {
    if (m_rmiBase != null) {
      doClcService();
    }
 else {
      ensureAutIsStarted(m_job.getActualTestSuite(),m_job.getAutConfig());
      if (isExecutionFinished(noRun,SA)) {
        return true;
      }
      doTest(m_job.getTestJob() != null);
    }
  }
 catch (  ToolkitPluginException e1) {
    sysErr(NLS.bind(Messages.ExecutionControllerAUT,Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE));
  }
  if (timer != null) {
    timer.abort();
  }
  return isNoErrorWhileExecution();
}","/** 
 * executes the complete test
 * @throws CommunicationException Error
 * @return boolean true if all testsuites completed successfully or if test execution was successful up to specified mode of no-run option
 */
public boolean executeJob() throws CommunicationException {
  String noRun=m_job.getNoRunOptMode();
  if (AbstractCmdlineClient.isNoRun()) {
    noRun=noRunStartPreparation(noRun);
  }
  WatchdogTimer timer=null;
  if (m_job.getTimeout() > 0) {
    timer=new WatchdogTimer(m_job.getTimeout());
    timer.start();
  }
  IClientTest clientTest=ClientTest.instance();
  if (!prepareAUTAgentConnection(clientTest)) {
    return false;
  }
 else   if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.CAA)) {
    return true;
  }
  clientTest.setRelevantFlag(m_job.isRelevant());
  clientTest.setScreenshotXMLFlag(m_job.isXMLScreenshot());
  prepareDBConnection();
  if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.CDB)) {
    return true;
  }
  loadProject();
  if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.LP)) {
    return true;
  }
  checkTestCompleteness();
  if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.CC)) {
    return true;
  }
  m_idle=true;
  if (m_shutdown) {
    sysOut(Messages.ReceivedShutdownCommand);
    endTestExecution();
  }
  try {
    if (m_rmiBase != null) {
      doClcService();
    }
 else {
      ensureAutIsStarted(m_job.getActualTestSuite(),m_job.getAutConfig());
      if (isExecutionFinished(noRun,TestexecConstants.NoRunSteps.SA)) {
        return true;
      }
      doTest(m_job.getTestJob() != null);
    }
  }
 catch (  ToolkitPluginException e1) {
    sysErr(NLS.bind(Messages.ExecutionControllerAUT,Messages.ErrorMessageAUT_TOOLKIT_NOT_AVAILABLE));
  }
  if (timer != null) {
    timer.abort();
  }
  return isNoErrorWhileExecution();
}",0.9588418961112688
95804,"/** 
 * @param testSuite testSuite
 * @param locale language valid for testexecution
 * @param monitor the progress monitor to use
 * @param noRunOptMode the value of no-run option argument if it was specified, null otherwise
 */
private void startTestSuite(ITestSuitePO testSuite,Locale locale,IProgressMonitor monitor,String noRunOptMode){
  Validate.notNull(testSuite,""String_Node_Str"");
  ICapPO firstCap=null;
  m_expectedNumberOfSteps=0;
  m_trav=new Traverser(testSuite,locale);
  try {
    monitor.subTask(Messages.StartingTestSuite_resolvingTestStepsToExecute);
    monitor.subTask(Messages.StartingTestSuite_buildingTestExecutionTree);
    Traverser copier=new Traverser(testSuite,locale);
    ResultTreeBuilder resultTreeBuilder=new ResultTreeBuilder(copier);
    copier.addExecStackModificationListener(resultTreeBuilder);
    ICapPO iterNode=copier.next();
    while (iterNode != null) {
      iterNode=copier.next();
      m_expectedNumberOfSteps++;
    }
    Map<String,String> autConfigMap=getConnectedAUTsConfigMap();
    resetMonitoringData(autConfigMap,monitor);
    if (isExecutionFinished(noRunOptMode,BT)) {
      return;
    }
    TestResultBP.getInstance().setResultTestModel(new TestResult(resultTreeBuilder.getRootNode(),autConfigMap));
    initTestExecutionMessage(autConfigMap,monitor);
    m_resultTreeTracker=new ResultTreeTracker(resultTreeBuilder.getRootNode(),m_externalTestDataBP);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,ClientTestImpl.TEST_SUITE_EXECUTION_RELATIVE_WORK_AMOUNT);
    subMonitor.beginTask(NLS.bind(Messages.StartWorkingWithTestSuite,testSuite.getName()),m_expectedNumberOfSteps);
    m_stepCounter=new StepCounter(subMonitor);
    addTestExecutionListener();
    setStepSpeed(testSuite.getStepDelay());
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_RESULT_TREE_READY));
    monitor.subTask(NLS.bind(Messages.StartingTestSuite,testSuite.getName()));
    firstCap=m_trav.next();
  }
 catch (  JBException e) {
    LOG.error(Messages.IncompleteTestdata,e);
    fireError(e);
  }
  if (firstCap != null) {
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_START));
    processCap(firstCap);
  }
 else {
    endTestExecution();
  }
}","/** 
 * @param testSuite testSuite
 * @param locale language valid for testexecution
 * @param monitor the progress monitor to use
 * @param noRunOptMode the value of no-run option argument if it was specified, null otherwise
 */
private void startTestSuite(ITestSuitePO testSuite,Locale locale,IProgressMonitor monitor,String noRunOptMode){
  Validate.notNull(testSuite,""String_Node_Str"");
  ICapPO firstCap=null;
  m_expectedNumberOfSteps=0;
  m_trav=new Traverser(testSuite,locale);
  try {
    monitor.subTask(Messages.StartingTestSuite_resolvingTestStepsToExecute);
    monitor.subTask(Messages.StartingTestSuite_buildingTestExecutionTree);
    Traverser copier=new Traverser(testSuite,locale);
    ResultTreeBuilder resultTreeBuilder=new ResultTreeBuilder(copier);
    copier.addExecStackModificationListener(resultTreeBuilder);
    ICapPO iterNode=copier.next();
    while (iterNode != null) {
      iterNode=copier.next();
      m_expectedNumberOfSteps++;
    }
    Map<String,String> autConfigMap=getConnectedAUTsConfigMap();
    resetMonitoringData(autConfigMap,monitor);
    if (noRunOptMode.equals(TestexecConstants.NoRunSteps.BT.getStepValue())) {
      return;
    }
    TestResultBP.getInstance().setResultTestModel(new TestResult(resultTreeBuilder.getRootNode(),autConfigMap));
    initTestExecutionMessage(autConfigMap,monitor);
    m_resultTreeTracker=new ResultTreeTracker(resultTreeBuilder.getRootNode(),m_externalTestDataBP);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,ClientTestImpl.TEST_SUITE_EXECUTION_RELATIVE_WORK_AMOUNT);
    subMonitor.beginTask(NLS.bind(Messages.StartWorkingWithTestSuite,testSuite.getName()),m_expectedNumberOfSteps);
    m_stepCounter=new StepCounter(subMonitor);
    addTestExecutionListener();
    setStepSpeed(testSuite.getStepDelay());
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_RESULT_TREE_READY));
    monitor.subTask(NLS.bind(Messages.StartingTestSuite,testSuite.getName()));
    firstCap=m_trav.next();
  }
 catch (  JBException e) {
    LOG.error(Messages.IncompleteTestdata,e);
    fireError(e);
  }
  if (firstCap != null) {
    ClientTest.instance().fireTestExecutionChanged(new TestExecutionEvent(State.TEST_EXEC_START));
    processCap(firstCap);
  }
 else {
    endTestExecution();
  }
}",0.9819682815555072
95805,"/** 
 * This method executes the given Test Suite
 * @param testSuite the TestSuitePO that will be tested
 * @param locale Locale
 * @param autoScreenshot whether screenshots should be automatically taken in case of test execution errors
 * @param autId The ID of the Running AUT on which the test will take place.
 * @param externalVars a map of externally set variables; may be <code>null</code>
 * @param summary The Test Result Summary for the executed test.  Must not be <code>null</code>.
 * @param monitor the monitor to use
 * @param noRunOptMode The value of no-run option argument if it was specified, null otherwise
 */
public void executeTestSuite(ITestSuitePO testSuite,Locale locale,AutIdentifier autId,boolean autoScreenshot,Map<String,String> externalVars,ITestResultSummaryPO summary,final IProgressMonitor monitor,String noRunOptMode){
  m_stopped=false;
  m_autoScreenshot=autoScreenshot;
  setPaused(false);
  Validate.notNull(testSuite,Messages.TestsuiteMustNotBeNull);
  m_executionLanguage=locale;
  monitor.subTask(NLS.bind(Messages.PreparingTestSuiteExecution,testSuite.getName()));
  m_externalTestDataBP.clearExternalData();
  if (isExecutionFinished(noRunOptMode,PTE)) {
    return;
  }
  try {
    if (AUTConnection.getInstance().connectToAut(autId,new SubProgressMonitor(monitor,0))) {
      if (isExecutionFinished(noRunOptMode,CA)) {
        return;
      }
      summary.setAutHostname(AUTConnection.getInstance().getCommunicator().getConnection().getAddress().getCanonicalHostName());
      summary.setAutAgentName(AutAgentConnection.getInstance().getCommunicator().getHostName());
      monitor.subTask(Messages.StartingTestSuite_resolvingPredefinedVariables);
      m_varStore.storeEnvironmentVariables();
      storePredefinedVariables(m_varStore,testSuite);
      storeExternallyDefinedVariables(m_varStore,externalVars);
      if (isExecutionFinished(noRunOptMode,RPV)) {
        return;
      }
      startTestSuite(testSuite,locale,monitor,noRunOptMode);
      final AtomicBoolean testSuiteFinished=new AtomicBoolean();
      ClientTest.instance().addTestExecutionEventListener(new ITestExecutionEventListener(){
        public void endTestExecution(){
          try {
            AUTConnection.getInstance().close();
          }
 catch (          ConnectionException e) {
          }
          ClientTest.instance().removeTestExecutionEventListener(this);
          testSuiteFinished.set(true);
        }
        public void stateChanged(        TestExecutionEvent event){
        }
      }
);
      while (!testSuiteFinished.get()) {
        TimeUtil.delay(250);
      }
    }
 else {
      handleNoConnectionToAUT(testSuite,autId);
    }
  }
 catch (  ConnectionException e) {
    LOG.error(Messages.UnableToConnectToAUT + StringConstants.DOT,e);
  }
}","/** 
 * This method executes the given Test Suite
 * @param testSuite the TestSuitePO that will be tested
 * @param locale Locale
 * @param autoScreenshot whether screenshots should be automatically taken in case of test execution errors
 * @param autId The ID of the Running AUT on which the test will take place.
 * @param externalVars a map of externally set variables; may be <code>null</code>
 * @param summary The Test Result Summary for the executed test.  Must not be <code>null</code>.
 * @param monitor the monitor to use
 * @param noRunOptMode The value of no-run option argument if it was specified, null otherwise
 */
public void executeTestSuite(ITestSuitePO testSuite,Locale locale,AutIdentifier autId,boolean autoScreenshot,Map<String,String> externalVars,ITestResultSummaryPO summary,final IProgressMonitor monitor,String noRunOptMode){
  m_stopped=false;
  m_autoScreenshot=autoScreenshot;
  setPaused(false);
  Validate.notNull(testSuite,Messages.TestsuiteMustNotBeNull);
  m_executionLanguage=locale;
  monitor.subTask(NLS.bind(Messages.PreparingTestSuiteExecution,testSuite.getName()));
  m_externalTestDataBP.clearExternalData();
  if (noRunOptMode.equals(TestexecConstants.NoRunSteps.PTE.getStepValue())) {
    return;
  }
  try {
    if (AUTConnection.getInstance().connectToAut(autId,new SubProgressMonitor(monitor,0))) {
      if (noRunOptMode.equals(TestexecConstants.NoRunSteps.CA.getStepValue())) {
        return;
      }
      summary.setAutHostname(AUTConnection.getInstance().getCommunicator().getConnection().getAddress().getCanonicalHostName());
      summary.setAutAgentName(AutAgentConnection.getInstance().getCommunicator().getHostName());
      monitor.subTask(Messages.StartingTestSuite_resolvingPredefinedVariables);
      m_varStore.storeEnvironmentVariables();
      storePredefinedVariables(m_varStore,testSuite);
      storeExternallyDefinedVariables(m_varStore,externalVars);
      if (noRunOptMode.equals(TestexecConstants.NoRunSteps.RPV.getStepValue())) {
        return;
      }
      startTestSuite(testSuite,locale,monitor,noRunOptMode);
      final AtomicBoolean testSuiteFinished=new AtomicBoolean();
      ClientTest.instance().addTestExecutionEventListener(new ITestExecutionEventListener(){
        public void endTestExecution(){
          try {
            AUTConnection.getInstance().close();
          }
 catch (          ConnectionException e) {
          }
          ClientTest.instance().removeTestExecutionEventListener(this);
          testSuiteFinished.set(true);
        }
        public void stateChanged(        TestExecutionEvent event){
        }
      }
);
      while (!testSuiteFinished.get()) {
        TimeUtil.delay(250);
      }
    }
 else {
      handleNoConnectionToAUT(testSuite,autId);
    }
  }
 catch (  ConnectionException e) {
    LOG.error(Messages.UnableToConnectToAUT + StringConstants.DOT,e);
  }
}",0.7331574318381706
95806,"/** 
 * @param s Session to use
 * @param key If of Project to preload
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void preloadData(EntityManager s,IProjectPO key) throws JBException {
  Set<Long> projectIds=new HashSet<Long>(17);
  projectIds.add(key.getId());
  findReusedProjects(projectIds,key.getProjectProperties().getUsedProjects());
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<ISpecTestCasePO> testCases=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<IExecTestCasePO> testCaseRefs=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  Map<String,ISpecTestCasePO> sTc=new HashMap<String,ISpecTestCasePO>();
  for (  ISpecTestCasePO testCase : testCases) {
    sTc.put(testCase.getGuid(),testCase);
  }
  for (  IExecTestCasePO testCaseRef : testCaseRefs) {
    ISpecTestCasePO spec=sTc.get(testCaseRef.getSpecTestCaseGuid());
    if (spec != null) {
      testCaseRef.setCachedSpecTestCase(spec);
    }
  }
}","/** 
 * @param s Session to use
 * @param key If of Project to preload
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void preloadData(EntityManager s,IProjectPO key) throws JBException {
  Set<Long> projectIds=new HashSet<Long>(17);
  projectIds.add(key.getId());
  findReusedProjects(projectIds,key.getProjectProperties().getUsedProjects());
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDistinctDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<ISpecTestCasePO> testCases=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<IExecTestCasePO> testCaseRefs=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  Map<String,ISpecTestCasePO> sTc=new HashMap<String,ISpecTestCasePO>();
  for (  ISpecTestCasePO testCase : testCases) {
    sTc.put(testCase.getGuid(),testCase);
  }
  for (  IExecTestCasePO testCaseRef : testCaseRefs) {
    ISpecTestCasePO spec=sTc.get(testCaseRef.getSpecTestCaseGuid());
    if (spec != null) {
      testCaseRef.setCachedSpecTestCase(spec);
    }
  }
}",0.9811433702484286
95807,"/** 
 * @param s Session to use
 * @param key If of Project to preload
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void preloadData(EntityManager s,IProjectPO key) throws JBException {
  Set<Long> projectIds=new HashSet<Long>(17);
  projectIds.add(key.getId());
  findReusedProjects(projectIds,key.getProjectProperties().getUsedProjects());
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<ISpecTestCasePO> testCases=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<IExecTestCasePO> testCaseRefs=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  Map<String,ISpecTestCasePO> sTc=new HashMap<String,ISpecTestCasePO>();
  for (  ISpecTestCasePO testCase : testCases) {
    sTc.put(testCase.getGuid(),testCase);
  }
  for (  IExecTestCasePO testCaseRef : testCaseRefs) {
    ISpecTestCasePO spec=sTc.get(testCaseRef.getSpecTestCaseGuid());
    if (spec != null) {
      testCaseRef.setCachedSpecTestCase(spec);
    }
  }
}","/** 
 * @param s Session to use
 * @param key If of Project to preload
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void preloadData(EntityManager s,IProjectPO key) throws JBException {
  Set<Long> projectIds=new HashSet<Long>(17);
  projectIds.add(key.getId());
  findReusedProjects(projectIds,key.getProjectProperties().getUsedProjects());
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<ISpecTestCasePO> testCases=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  List<IExecTestCasePO> testCaseRefs=preloadDataForClass(s,projectIds,""String_Node_Str"");
  preloadDataForClass(s,projectIds,""String_Node_Str"");
  Map<String,ISpecTestCasePO> sTc=new HashMap<String,ISpecTestCasePO>();
  for (  ISpecTestCasePO testCase : testCases) {
    sTc.put(testCase.getGuid(),testCase);
  }
  for (  IExecTestCasePO testCaseRef : testCaseRefs) {
    ISpecTestCasePO spec=sTc.get(testCaseRef.getSpecTestCaseGuid());
    if (spec != null) {
      testCaseRef.setCachedSpecTestCase(spec);
    }
  }
}",0.9834983498349836
95808,"@Override public void onChanged(Change<? extends Stage> change){
  change.next();
  for (  final Stage stage : change.getRemoved()) {
    hierarchy.removeComponentFromHierarchy(stage);
  }
  for (  final Stage stage : change.getAddedSubList()) {
    stage.setOnShown(new EventHandler<WindowEvent>(){
      @Override public void handle(      WindowEvent event){
        hierarchy.createHierarchyFrom(stage);
        stageResizeSync.register(stage);
        stage.setOnShown(null);
      }
    }
);
  }
}","@Override public void onChanged(Change<? extends Stage> change){
  change.next();
  for (  final Stage stage : change.getRemoved()) {
    hierarchy.removeComponentFromHierarchy(stage);
  }
  for (  final Stage stage : change.getAddedSubList()) {
    stage.addEventFilter(WindowEvent.WINDOW_SHOWN,new EventHandler<WindowEvent>(){
      @Override public void handle(      WindowEvent event){
        hierarchy.createHierarchyFrom(stage);
        stageResizeSync.register(stage);
        stage.removeEventFilter(WindowEvent.WINDOW_SHOWN,this);
      }
    }
);
  }
}",0.8976525821596244
95809,"@Override public void handle(WindowEvent event){
  hierarchy.createHierarchyFrom(stage);
  stageResizeSync.register(stage);
  stage.setOnShown(null);
}","@Override public void handle(WindowEvent event){
  hierarchy.createHierarchyFrom(stage);
  stageResizeSync.register(stage);
  stage.removeEventFilter(WindowEvent.WINDOW_SHOWN,this);
}",0.8502994011976048
95810,"/** 
 * Enables or disables the confirmer. If the confirmer is enabled, the JavaFX Filter is added to the currently focused stage so that the confirmer starts storing events of the configured class of events. If it is disabled, the listener is removed from the AWT event queue.
 * @param enabled <code>true</code> or <code>false</code>.
 */
public void setEnabled(boolean enabled){
  m_enabled=enabled;
  m_eventList.clear();
  if (m_enabled) {
    final long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      final ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null) {
          m_sceneGraphs.remove(w);
          continue;
        }
        final Window win=w.get();
        final long mask=masks[i];
        final RobotEventConfirmerJavaFXImpl me=this;
        EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
          @Override public Void call() throws Exception {
            win.addEventFilter(JavaFXEventConverter.awtToFX(mask),new WeakEventHandler<>(me));
            return null;
          }
        }
);
      }
    }
  }
 else {
    long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null) {
          m_sceneGraphs.remove(w);
          continue;
        }
        final Window win=w.get();
        final long mask=masks[i];
        final RobotEventConfirmerJavaFXImpl me=this;
        EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
          @Override public Void call() throws Exception {
            win.removeEventFilter(JavaFXEventConverter.awtToFX(mask),new WeakEventHandler<>(me));
            return null;
          }
        }
);
      }
    }
  }
}","/** 
 * Enables or disables the confirmer. If the confirmer is enabled, the JavaFX Filter is added to the currently focused stage so that the confirmer starts storing events of the configured class of events. If it is disabled, the listener is removed from the AWT event queue.
 * @param enabled <code>true</code> or <code>false</code>.
 */
public void setEnabled(boolean enabled){
  m_enabled=enabled;
  m_eventList.clear();
  if (m_enabled) {
    final long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      final ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null || !(w.getValue().isShowing())) {
          m_sceneGraphs.remove(w);
          continue;
        }
        final Window win=w.get();
        final long mask=masks[i];
        final RobotEventConfirmerJavaFXImpl me=this;
        EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
          @Override public Void call() throws Exception {
            win.addEventFilter(JavaFXEventConverter.awtToFX(mask),new WeakEventHandler<>(me));
            return null;
          }
        }
);
      }
    }
  }
 else {
    long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null || !(w.getValue().isShowing())) {
          m_sceneGraphs.remove(w);
          continue;
        }
        final Window win=w.get();
        final long mask=masks[i];
        final RobotEventConfirmerJavaFXImpl me=this;
        EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
          @Override public Void call() throws Exception {
            win.removeEventFilter(JavaFXEventConverter.awtToFX(mask),new WeakEventHandler<>(me));
            return null;
          }
        }
);
      }
    }
  }
}",0.9836497890295358
95811,"/** 
 * @return true if init has been successful
 */
private boolean initPauseTestExecutionState(){
  ICommandService cmdService=(ICommandService)Plugin.getActivePart().getSite().getService(ICommandService.class);
  if (cmdService != null) {
    final Command command=cmdService.getCommand(RCPCommandIDs.PAUSE_TEST_SUITE);
    if (command != null) {
      final Display display=Plugin.getDisplay();
      ITestExecutionEventListener l=new ITestExecutionEventListener(){
        public void endTestExecution(){
          display.syncExec(new Runnable(){
            public void run(){
              State state=command.getState(RegistryToggleState.STATE_ID);
              state.setValue(false);
            }
          }
);
          ClientTest.instance().removeTestExecutionEventListener(this);
        }
        public void stateChanged(        final TestExecutionEvent tee){
          display.syncExec(new Runnable(){
            public void run(){
              State state=command.getState(RegistryToggleState.STATE_ID);
              boolean newToggleStateValue=tee.getState() == org.eclipse.jubula.client.core.businessprocess.TestExecutionEvent.State.TEST_EXEC_PAUSED;
              state.setValue(newToggleStateValue);
            }
          }
);
        }
      }
;
      ClientTest.instance().addTestExecutionEventListener(l);
      return true;
    }
  }
  return false;
}","/** 
 * @param event the execution event
 * @return true if init has been successful
 */
private boolean initPauseTestExecutionState(ExecutionEvent event){
  ICommandService cmdService=(ICommandService)HandlerUtil.getActiveWorkbenchWindow(event).getService(ICommandService.class);
  if (cmdService != null) {
    final Command command=cmdService.getCommand(RCPCommandIDs.PAUSE_TEST_SUITE);
    if (command != null) {
      final Display display=Plugin.getDisplay();
      ITestExecutionEventListener l=new ITestExecutionEventListener(){
        public void endTestExecution(){
          display.syncExec(new Runnable(){
            public void run(){
              State state=command.getState(RegistryToggleState.STATE_ID);
              state.setValue(false);
            }
          }
);
          ClientTest.instance().removeTestExecutionEventListener(this);
        }
        public void stateChanged(        final TestExecutionEvent tee){
          display.syncExec(new Runnable(){
            public void run(){
              State state=command.getState(RegistryToggleState.STATE_ID);
              boolean newToggleStateValue=tee.getState() == org.eclipse.jubula.client.core.businessprocess.TestExecutionEvent.State.TEST_EXEC_PAUSED;
              state.setValue(newToggleStateValue);
            }
          }
);
        }
      }
;
      ClientTest.instance().addTestExecutionEventListener(l);
      return true;
    }
  }
  return false;
}",0.9615520282186948
95812,"/** 
 * init the GUI test execution part
 * @return whether initialisation has been successful
 */
protected boolean initTestExecution(){
  return initTestExecutionRelevantFlag() && initPauseTestExecutionState();
}","/** 
 * init the GUI test execution part
 * @param event the execution event
 * @return whether initialization has been successful
 */
protected boolean initTestExecution(ExecutionEvent event){
  return initTestExecutionRelevantFlag() && initPauseTestExecutionState(event);
}",0.8711656441717791
95813,"public void run(){
  if (prepareTestExecution() && initTestExecution()) {
    prepareOk.set(true);
  }
}","public void run(){
  if (prepareTestExecution() && initTestExecution(event)) {
    prepareOk.set(true);
  }
}",0.976525821596244
95814,"/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event) throws ExecutionException {
  Object testJobToStartObj=null;
  ITestJobPO testJobToStart=null;
  testJobToStartObj=event.getObjectParameterForExecution(TEST_JOB_TO_START);
  if (testJobToStartObj instanceof ITestJobPO) {
    testJobToStart=(ITestJobPO)testJobToStartObj;
    final ITestJobPO finalTestJob=testJobToStart;
    final boolean autoScreenshots=Plugin.getDefault().getPreferenceStore().getBoolean(Constants.AUTO_SCREENSHOT_KEY);
    final String jobName=Messages.UIJobStartTestJob;
    Job startTestJobJob=new Job(jobName){
      protected IStatus run(      IProgressMonitor monitor){
        monitor.beginTask(jobName,IProgressMonitor.UNKNOWN);
        final AtomicBoolean prepareOk=new AtomicBoolean(false);
        Plugin.getDisplay().syncExec(new Runnable(){
          public void run(){
            if (prepareTestExecution() && initTestExecution()) {
              prepareOk.set(true);
            }
          }
        }
);
        if (prepareOk.get()) {
          ClientTest.instance().startTestJob(finalTestJob,WorkingLanguageBP.getInstance().getWorkingLanguage(),autoScreenshots);
        }
        monitor.done();
        return Status.OK_STATUS;
      }
    }
;
    startTestJobJob.setSystem(true);
    JobUtils.executeJob(startTestJobJob,null);
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object executeImpl(final ExecutionEvent event) throws ExecutionException {
  Object testJobToStartObj=null;
  ITestJobPO testJobToStart=null;
  testJobToStartObj=event.getObjectParameterForExecution(TEST_JOB_TO_START);
  if (testJobToStartObj instanceof ITestJobPO) {
    testJobToStart=(ITestJobPO)testJobToStartObj;
    final ITestJobPO finalTestJob=testJobToStart;
    final boolean autoScreenshots=Plugin.getDefault().getPreferenceStore().getBoolean(Constants.AUTO_SCREENSHOT_KEY);
    final String jobName=Messages.UIJobStartTestJob;
    Job startTestJobJob=new Job(jobName){
      protected IStatus run(      IProgressMonitor monitor){
        monitor.beginTask(jobName,IProgressMonitor.UNKNOWN);
        final AtomicBoolean prepareOk=new AtomicBoolean(false);
        Plugin.getDisplay().syncExec(new Runnable(){
          public void run(){
            if (prepareTestExecution() && initTestExecution(event)) {
              prepareOk.set(true);
            }
          }
        }
);
        if (prepareOk.get()) {
          ClientTest.instance().startTestJob(finalTestJob,WorkingLanguageBP.getInstance().getWorkingLanguage(),autoScreenshots);
        }
        monitor.done();
        return Status.OK_STATUS;
      }
    }
;
    startTestJobJob.setSystem(true);
    JobUtils.executeJob(startTestJobJob,null);
  }
  return null;
}",0.9959780621572212
95815,"/** 
 * {@inheritDoc}
 */
public Object executeImpl(ExecutionEvent event){
  Object testSuiteToStartObj=null;
  Object runningAutObj=null;
  ITestSuitePO testSuiteToStart=null;
  AutIdentifier runningAut=null;
  try {
    testSuiteToStartObj=event.getObjectParameterForExecution(TEST_SUITE_TO_START);
    runningAutObj=event.getObjectParameterForExecution(RUNNING_AUT);
  }
 catch (  ExecutionException ee) {
  }
  State lastStartedTestSuiteState=event.getCommand().getState(LAST_STARTED_TEST_SUITE);
  State lastTestedRunningAutState=event.getCommand().getState(LAST_TESTED_RUNNING_AUT);
  if (testSuiteToStartObj instanceof ITestSuitePO && runningAutObj instanceof AutIdentifier) {
    testSuiteToStart=(ITestSuitePO)testSuiteToStartObj;
    runningAut=(AutIdentifier)runningAutObj;
  }
 else {
    if (lastStartedTestSuiteState != null && lastTestedRunningAutState != null) {
      Object testSuiteStateValue=lastStartedTestSuiteState.getValue();
      Object runningAutStateValue=lastTestedRunningAutState.getValue();
      if (testSuiteStateValue instanceof String && runningAutStateValue instanceof AutIdentifier) {
        String testSuiteGUIDtoStart=(String)testSuiteStateValue;
        List<ITestSuitePO> listOfTS=TestSuiteBP.getListOfTestSuites();
        for (        ITestSuitePO ts : listOfTS) {
          if (testSuiteGUIDtoStart.equals(ts.getGuid())) {
            testSuiteToStart=ts;
            break;
          }
        }
        runningAut=(AutIdentifier)runningAutStateValue;
      }
    }
  }
  if (testSuiteToStart != null && runningAut != null && initTestExecution()) {
    final boolean autoScreenshots=Plugin.getDefault().getPreferenceStore().getBoolean(Constants.AUTO_SCREENSHOT_KEY);
    ChooseTestSuiteBP.getInstance().runTestSuite(testSuiteToStart,runningAut,autoScreenshots);
    if (lastStartedTestSuiteState != null && lastTestedRunningAutState != null) {
      lastStartedTestSuiteState.setValue(testSuiteToStart.getGuid());
      lastTestedRunningAutState.setValue(runningAut);
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object executeImpl(final ExecutionEvent event){
  Object testSuiteToStartObj=null;
  Object runningAutObj=null;
  ITestSuitePO testSuiteToStart=null;
  AutIdentifier runningAut=null;
  try {
    testSuiteToStartObj=event.getObjectParameterForExecution(TEST_SUITE_TO_START);
    runningAutObj=event.getObjectParameterForExecution(RUNNING_AUT);
  }
 catch (  ExecutionException ee) {
  }
  State lastStartedTestSuiteState=event.getCommand().getState(LAST_STARTED_TEST_SUITE);
  State lastTestedRunningAutState=event.getCommand().getState(LAST_TESTED_RUNNING_AUT);
  if (testSuiteToStartObj instanceof ITestSuitePO && runningAutObj instanceof AutIdentifier) {
    testSuiteToStart=(ITestSuitePO)testSuiteToStartObj;
    runningAut=(AutIdentifier)runningAutObj;
  }
 else {
    if (lastStartedTestSuiteState != null && lastTestedRunningAutState != null) {
      Object testSuiteStateValue=lastStartedTestSuiteState.getValue();
      Object runningAutStateValue=lastTestedRunningAutState.getValue();
      if (testSuiteStateValue instanceof String && runningAutStateValue instanceof AutIdentifier) {
        String testSuiteGUIDtoStart=(String)testSuiteStateValue;
        List<ITestSuitePO> listOfTS=TestSuiteBP.getListOfTestSuites();
        for (        ITestSuitePO ts : listOfTS) {
          if (testSuiteGUIDtoStart.equals(ts.getGuid())) {
            testSuiteToStart=ts;
            break;
          }
        }
        runningAut=(AutIdentifier)runningAutStateValue;
      }
    }
  }
  if (testSuiteToStart != null && runningAut != null && initTestExecution(event)) {
    final boolean autoScreenshots=Plugin.getDefault().getPreferenceStore().getBoolean(Constants.AUTO_SCREENSHOT_KEY);
    ChooseTestSuiteBP.getInstance().runTestSuite(testSuiteToStart,runningAut,autoScreenshots);
    if (lastStartedTestSuiteState != null && lastTestedRunningAutState != null) {
      lastStartedTestSuiteState.setValue(testSuiteToStart.getGuid());
      lastTestedRunningAutState.setValue(runningAut);
    }
  }
  return null;
}",0.9973111708628696
95816,"/** 
 * Checks whether a node is a descendant of a node
 * @param candidate the possible descendant
 * @param node the node
 * @return whether the candidate is a descendant of the other node
 */
private static boolean isDescendant(Node candidate,Node node){
  if (node instanceof Parent) {
    List<Node> children=((Parent)node).getChildrenUnmodifiable();
    if (children.contains(candidate)) {
      return true;
    }
    for (    Node child : children) {
      if (isDescendant(candidate,child)) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Checks whether a node is a descendant of a node
 * @param candidate the possible descendant
 * @param node the node
 * @return whether the candidate is a descendant of the other node
 */
private static boolean isDescendant(Node candidate,Node node){
  if (candidate == null) {
    return false;
  }
 else   if (candidate == node) {
    return true;
  }
  return isDescendant(candidate.getParent(),node);
}",0.5829042224510813
95817,"/** 
 * Filters out all parent in a list of matches
 * @param matches the matches
 * @return the filtered list
 */
private static List<Node> filterMatches(List<Node> matches){
  List<Node> filteredMatches=new ArrayList<Node>();
  checkMatches:   for (  Node match : matches) {
    if (match instanceof Parent) {
      for (      Node otherMatch : matches) {
        if (!otherMatch.equals(match)) {
          if (isDescendant(otherMatch,match)) {
            continue checkMatches;
          }
        }
      }
    }
    filteredMatches.add(match);
  }
  return filteredMatches;
}","/** 
 * Filters out all parent in a list of matches
 * @param matches the matches
 * @return the filtered list
 */
private static Node filterMatches(List<Node> matches){
  Node youngesCommonAncestor=findFirstCommonAncestor(matches);
  return topMostDescendant((Parent)youngesCommonAncestor,matches);
}",0.4058956916099773
95818,"/** 
 * Returns the node under the given point
 * @param pos the point
 * @return the component
 */
public static Node getComponentByPos(Point2D pos){
  List<? extends Node> comps=getAssignableFrom(Node.class);
  List<Node> matches=new ArrayList<Node>();
  for (  Node n : comps) {
    Set supportetTypes=AUTServerConfiguration.getInstance().getSupportedTypes();
    for (    Object object : supportetTypes) {
      if (((ComponentClass)object).getName().equals(n.getClass().getName()) && NodeBounds.checkIfContains(pos,n)) {
        matches.add(n);
      }
    }
  }
  if (matches.size() == 0) {
    return null;
  }
  if (matches.size() == 1) {
    return matches.get(0);
  }
  matches=filterMatches(matches);
  if (matches.size() == 1) {
    return matches.get(0);
  }
  return guessBestPick(matches);
}","/** 
 * Returns the node under the given point
 * @param pos the point
 * @return the component
 */
public static Node getComponentByPos(Point2D pos){
  List<? extends Node> comps=getAssignableFrom(Node.class);
  List<Node> matches=new ArrayList<Node>();
  for (  Node n : comps) {
    if (n.getScene() == null) {
      continue;
    }
    Set supportetTypes=AUTServerConfiguration.getInstance().getSupportedTypes();
    for (    Object object : supportetTypes) {
      if (((ComponentClass)object).getName().equals(n.getClass().getName()) && NodeBounds.checkIfContains(pos,n)) {
        matches.add(n);
      }
    }
  }
  if (matches.size() == 0) {
    return null;
  }
  if (matches.size() == 1) {
    return matches.get(0);
  }
  return filterMatches(matches);
}",0.8969465648854962
95819,"/** 
 * Checks if the given point with coordinates relative to the scene is in the given Node.
 * @param point the Point
 * @param n the Node
 * @return true if the Point is in the Node, false if not.
 */
public static boolean checkIfContains(Point2D point,Node n){
  Point2D nodePos=n.localToScreen(0,0);
  if (nodePos == null) {
    return false;
  }
  BoundingBox box=new BoundingBox(nodePos.getX(),nodePos.getY(),n.getBoundsInParent().getWidth(),n.getBoundsInParent().getHeight());
  return box.contains(point);
}","/** 
 * Must be called from FX Thread. Checks if the given point with coordinates relative to the scene is in the given Node.
 * @param point the Point
 * @param n the Node
 * @return true if the Point is in the Node, false if not.
 */
public static boolean checkIfContains(Point2D point,Node n) throws IllegalStateException {
  EventThreadQueuerJavaFXImpl.checkEventThread();
  if (n.getScene() == null) {
    return false;
  }
  Point2D nodePos=n.localToScreen(0,0);
  if (nodePos == null) {
    return false;
  }
  BoundingBox box=new BoundingBox(nodePos.getX(),nodePos.getY(),n.getBoundsInParent().getWidth(),n.getBoundsInParent().getHeight());
  return box.contains(point);
}",0.8638262322472848
95820,"/** 
 * Adds a handler to the stage
 * @param handler the handler
 */
private void addToolkitEventListener(AbstractFXAUTEventHandler handler){
  List<? extends Stage> stages=ComponentHandler.getAssignableFromType(Stage.class);
  for (  final Stage stage : stages) {
    handler.addHandler(stage);
  }
}","/** 
 * Adds a handler to the stage
 * @param handler the handler
 */
private void addToolkitEventListener(AbstractFXAUTEventHandler handler){
  List<? extends Stage> stages=ComponentHandler.getAssignableFromType(Stage.class);
  for (  final Stage stage : stages) {
    handler.addHandler(stage);
  }
  CurrentStages.addStagesListener(handler);
}",0.9320987654320988
95821,"/** 
 * removes a handler from the stage
 * @param handler the handler
 */
private void removeToolkitEventListener(AbstractFXAUTEventHandler handler){
  List<? extends Stage> stages=ComponentHandler.getAssignableFromType(Stage.class);
  for (  Stage stage : stages) {
    handler.removeHandler(stage);
  }
}","/** 
 * removes a handler from the stage
 * @param handler the handler
 */
private void removeToolkitEventListener(AbstractFXAUTEventHandler handler){
  List<? extends Stage> stages=ComponentHandler.getAssignableFromType(Stage.class);
  for (  Stage stage : stages) {
    handler.removeHandler(stage);
  }
  CurrentStages.removeStagesListener(handler);
}",0.928895612708018
95822,"@Override protected IMenuItemComponent newMenuItemAdapter(Object component){
  return new MenuItemAdapter((MenuItem)component);
}","@Override protected IMenuItemComponent newMenuItemAdapter(Object component){
  return new MenuItemAdapter<MenuItem>((MenuItem)component);
}",0.9626865671641792
95823,"/** 
 * Enables or disables the confirmer. If the confirmer is enabled, the JavaFX Filter is added to the currently focused stage so that the confirmer starts storing events of the configured class of events. If it is disabled, the listener is removed from the AWT event queue.
 * @param enabled <code>true</code> or <code>false</code>.
 */
public void setEnabled(boolean enabled){
  m_enabled=enabled;
  m_eventList.clear();
  if (m_enabled) {
    long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null) {
          m_sceneGraphs.remove(w);
          continue;
        }
        w.getValue().addEventFilter(JavaFXEventConverter.awtToFX(masks[i]),this);
      }
    }
  }
 else {
    long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null) {
          m_sceneGraphs.remove(w);
          continue;
        }
        w.getValue().removeEventFilter(JavaFXEventConverter.awtToFX(masks[i]),this);
      }
    }
    m_eventList.clear();
  }
}","/** 
 * Enables or disables the confirmer. If the confirmer is enabled, the JavaFX Filter is added to the currently focused stage so that the confirmer starts storing events of the configured class of events. If it is disabled, the listener is removed from the AWT event queue.
 * @param enabled <code>true</code> or <code>false</code>.
 */
public void setEnabled(boolean enabled){
  m_enabled=enabled;
  m_eventList.clear();
  if (m_enabled) {
    final long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      final ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null) {
          m_sceneGraphs.remove(w);
          continue;
        }
        final Window win=w.get();
        final long mask=masks[i];
        final RobotEventConfirmerJavaFXImpl me=this;
        EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
          @Override public Void call() throws Exception {
            win.addEventFilter(JavaFXEventConverter.awtToFX(mask),new WeakEventHandler<>(me));
            return null;
          }
        }
);
      }
    }
  }
 else {
    long[] masks=m_options.getEventMask();
    for (int i=0; i < masks.length; i++) {
      for (      ReadOnlyObjectProperty<? extends Window> w : m_sceneGraphs) {
        if (w.getValue() == null) {
          m_sceneGraphs.remove(w);
          continue;
        }
        final Window win=w.get();
        final long mask=masks[i];
        final RobotEventConfirmerJavaFXImpl me=this;
        EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
          @Override public Void call() throws Exception {
            win.removeEventFilter(JavaFXEventConverter.awtToFX(mask),new WeakEventHandler<>(me));
            return null;
          }
        }
);
      }
    }
  }
}",0.7521922702176032
95824,"/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part of the component (e.g. tree node, table cell, etc) rather than the overall component itself. May be <code>null</code>.
 * @param xPos xPos in component
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute
 * @param yAbsolute true if y-position should be absolute
 * @param clickOptions The click options
 * @throws StepExecutionException If the click delay is interrupted or the event confirmation receives a timeout.
 */
private void moveImpl(final Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,final ClickOptions clickOptions) throws StepExecutionException {
  Rectangle bounds=getComponentBounds(graphicsComponent,clickOptions);
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    IRobotEventConfirmer confirmer=null;
    if (clickOptions.isConfirmClick()) {
      InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
      confirmer=m_interceptor.intercept(options);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      if (graphicsComponent instanceof Stage) {
        Stage s=(Stage)graphicsComponent;
        Node root=s.getScene().getRoot();
        startpoint=(root != null) ? getLocation(root,null) : new Point(Rounding.round(s.getWidth() / 2),Rounding.round(s.getHeight() / 2));
      }
 else {
        Node node=(Node)graphicsComponent;
        Node root=node.getScene().getRoot();
        Node c=(root != null) ? root : node;
        startpoint=getLocation(c,null);
      }
    }
    final Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,clickOptions.getStepMovement(),clickOptions.getFirstHorizontal());
    Point currP=new Point(0,0);
    for (int i=0; i < mouseMove.length; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      currP.x=mouseMove[i].x;
      currP.y=mouseMove[i].y;
      if (!currP.equals(MouseInfo.getPointerInfo().getLocation())) {
        mouseMoveFallback(currP);
      }
    }
    if (confirmer != null) {
      confirmMove(confirmer,graphicsComponent);
    }
  }
}","/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part of the component (e.g. tree node, table cell, etc) rather than the overall component itself. May be <code>null</code>.
 * @param xPos xPos in component
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute
 * @param yAbsolute true if y-position should be absolute
 * @param clickOptions The click options
 * @throws StepExecutionException If the click delay is interrupted or the event confirmation receives a timeout.
 */
private void moveImpl(final Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,final ClickOptions clickOptions) throws StepExecutionException {
  Rectangle bounds=getComponentBounds(graphicsComponent,clickOptions);
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      if (graphicsComponent instanceof Stage) {
        Stage s=(Stage)graphicsComponent;
        Node root=s.getScene().getRoot();
        startpoint=(root != null) ? getLocation(root,null) : new Point(Rounding.round(s.getWidth() / 2),Rounding.round(s.getHeight() / 2));
      }
 else {
        Node node=(Node)graphicsComponent;
        Node root=node.getScene().getRoot();
        Node c=(root != null) ? root : node;
        startpoint=getLocation(c,null);
      }
    }
    IRobotEventConfirmer confirmer=null;
    InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
    if (DragAndDropHelper.getInstance().isDragMode()) {
      confirmer=m_interceptor.intercept(options);
    }
    final Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,clickOptions.getStepMovement(),clickOptions.getFirstHorizontal());
    Point currP=new Point(0,0);
    for (int i=0; i < mouseMove.length - 1; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      currP.x=mouseMove[i].x;
      currP.y=mouseMove[i].y;
      if (!currP.equals(MouseInfo.getPointerInfo().getLocation())) {
        mouseMoveFallback(currP);
      }
    }
    if (!DragAndDropHelper.getInstance().isDragMode()) {
      confirmer=m_interceptor.intercept(options);
    }
    m_robot.mouseMove(mouseMove[mouseMove.length - 1].x,mouseMove[mouseMove.length - 1].y);
    currP.x=mouseMove[mouseMove.length - 1].x;
    currP.y=mouseMove[mouseMove.length - 1].y;
    if (!currP.equals(MouseInfo.getPointerInfo().getLocation())) {
      mouseMoveFallback(currP);
    }
    if (confirmer != null) {
      confirmMove(confirmer,graphicsComponent);
    }
  }
}",0.7195266272189349
95825,"@Override public void cleanUp(){
  HighlightNode.clean();
}","@Override public void cleanUp(){
  lowlightCurrentNode();
}",0.8305084745762712
95826,"/** 
 * Highlights the current Node
 */
public void highlightCurrentNode(){
  if (m_currentNode != null) {
    HighlightNode.drawHighlight(m_currentNode);
  }
}","/** 
 * Highlights the current Node
 */
public void highlightCurrentNode(){
  if (m_currentNode != null) {
    EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
      @Override public Void call() throws Exception {
        HighlightNode.drawHighlight(m_currentNode);
        return null;
      }
    }
);
  }
}",0.6374501992031872
95827,"/** 
 * Lowlights the current Node
 */
public void lowlightCurrentNode(){
  if (m_currentNode != null) {
    HighlightNode.removeHighlight(m_currentNode);
  }
}","/** 
 * Lowlights the current Node
 */
public void lowlightCurrentNode(){
  if (m_currentNode != null) {
    EventThreadQueuerJavaFXImpl.invokeAndWait(""String_Node_Str"",new Callable<Void>(){
      @Override public Void call() throws Exception {
        HighlightNode.removeHighlight(m_currentNode);
        return null;
      }
    }
);
  }
}",0.6374501992031872
95828,"/** 
 * @return true if successfull; false otherwise
 */
private static boolean connectToDB(){
  Job connectToDBJob=new Job(Messages.ConnectingToDatabaseJob){
    protected IStatus run(    IProgressMonitor monitor){
      Integer message=0;
      try {
        instance(user,pw,dburl,monitor);
        user=null;
        pw=null;
        if (instance.m_newDbSchemeInstalled) {
          instance.m_newDbSchemeInstalled=false;
          DatabaseStateDispatcher.notifyListener(new DatabaseStateEvent(DatabaseState.DB_SCHEME_CREATED));
        }
        return Status.OK_STATUS;
      }
 catch (      PMDatabaseConfException e) {
        if (e.getErrorId().equals(MessageIDs.E_INVALID_DB_VERSION)) {
          message=MessageIDs.E_INVALID_DB_VERSION;
        }
 else         if (e.getErrorId().equals(MessageIDs.E_NOT_CHECKABLE_DB_VERSION)) {
          message=MessageIDs.E_NOT_CHECKABLE_DB_VERSION;
        }
 else         if (e.getErrorId().equals(MessageIDs.E_NO_DB_SCHEME)) {
          message=MessageIDs.E_NO_DB_SCHEME;
        }
 else         if (e.getErrorId().equals(MessageIDs.E_ERROR_IN_SCHEMA_CONFIG)) {
          message=MessageIDs.E_ERROR_IN_SCHEMA_CONFIG;
        }
 else {
          message=MessageIDs.E_UNEXPECTED_EXCEPTION;
        }
        return new Status(IStatus.ERROR,Activator.PLUGIN_ID,message.toString(),e);
      }
catch (      JBException e) {
        if (e.getErrorId().equals(MessageIDs.E_NO_DB_CONNECTION)) {
          message=MessageIDs.E_NO_DB_CONNECTION;
        }
        if (e.getErrorId().equals(MessageIDs.E_DB_IN_USE)) {
          message=MessageIDs.E_DB_IN_USE;
        }
        return new Status(IStatus.ERROR,Activator.PLUGIN_ID,message.toString(),e);
      }
    }
  }
;
  final AtomicBoolean connectionGained=new AtomicBoolean();
  connectToDBJob.addJobChangeListener(new JobChangeListener(){
    /** 
 * {@inheritDoc} 
 */
    public void done(    IJobChangeEvent event){
      connectionGained.set(event.getResult().isOK());
    }
  }
);
  connectToDBJob.setUser(true);
  connectToDBJob.schedule();
  try {
    connectToDBJob.join();
  }
 catch (  InterruptedException e) {
    log.error(e.getLocalizedMessage(),e);
    connectionGained.set(false);
  }
  return connectionGained.get();
}","/** 
 * @return true if successful; false otherwise
 */
private static boolean connectToDB(){
  Job connectToDBJob=new Job(Messages.ConnectingToDatabaseJob){
    protected IStatus run(    IProgressMonitor monitor){
      Integer message=0;
      try {
        instance(user,pw,dburl,monitor);
        user=null;
        pw=null;
        if (instance.m_newDbSchemeInstalled) {
          instance.m_newDbSchemeInstalled=false;
          DatabaseStateDispatcher.notifyListener(new DatabaseStateEvent(DatabaseState.DB_SCHEME_CREATED));
        }
        return Status.OK_STATUS;
      }
 catch (      PMDatabaseConfException e) {
        if (e.getErrorId().equals(MessageIDs.E_INVALID_DB_VERSION)) {
          message=MessageIDs.E_INVALID_DB_VERSION;
        }
 else         if (e.getErrorId().equals(MessageIDs.E_NOT_CHECKABLE_DB_VERSION)) {
          message=MessageIDs.E_NOT_CHECKABLE_DB_VERSION;
        }
 else         if (e.getErrorId().equals(MessageIDs.E_NO_DB_SCHEME)) {
          message=MessageIDs.E_NO_DB_SCHEME;
        }
 else         if (e.getErrorId().equals(MessageIDs.E_ERROR_IN_SCHEMA_CONFIG)) {
          message=MessageIDs.E_ERROR_IN_SCHEMA_CONFIG;
        }
 else {
          message=MessageIDs.E_UNEXPECTED_EXCEPTION;
        }
        return new Status(IStatus.ERROR,Activator.PLUGIN_ID,message.toString(),e);
      }
catch (      JBException e) {
        if (e.getErrorId().equals(MessageIDs.E_NO_DB_CONNECTION)) {
          message=MessageIDs.E_NO_DB_CONNECTION;
        }
        if (e.getErrorId().equals(MessageIDs.E_DB_IN_USE)) {
          message=MessageIDs.E_DB_IN_USE;
        }
        return new Status(IStatus.ERROR,Activator.PLUGIN_ID,message.toString(),e);
      }
    }
  }
;
  final AtomicBoolean connectionGained=new AtomicBoolean();
  connectToDBJob.addJobChangeListener(new JobChangeListener(){
    /** 
 * {@inheritDoc} 
 */
    public void done(    IJobChangeEvent event){
      connectionGained.set(event.getResult().isOK());
    }
  }
);
  connectToDBJob.setUser(true);
  connectToDBJob.schedule();
  try {
    connectToDBJob.join();
  }
 catch (  InterruptedException e) {
    log.error(e.getLocalizedMessage(),e);
    connectionGained.set(false);
  }
  return connectionGained.get();
}",0.9997758350145708
95829,"/** 
 * clears the content of client
 * @param alsoProjectIndependent whether also project independent editors should be closed such as the testresultviewer
 */
public static void clearClient(final boolean alsoProjectIndependent){
  final DataEventDispatcher ded=DataEventDispatcher.getInstance();
  TestExecution.getInstance().stopExecution();
  GeneralStorage gs=GeneralStorage.getInstance();
  if (gs != null && Persistor.instance() != null) {
    IProjectPO currProj=gs.getProject();
    if (currProj != null) {
      gs.setProject(null);
    }
    gs.reset();
  }
  Plugin.getDisplay().syncExec(new Runnable(){
    public void run(){
      final ProblemsBP problemsBP=ProblemsBP.getInstance();
      problemsBP.clearOldProblems();
      problemsBP.cleanupProblems();
      TestExecutionContributor.getInstance().getClientTest().resetToTesting();
      ded.fireRecordModeStateChanged(RecordModeState.notRunning);
      ded.fireOMStateChanged(OMState.notRunning);
      ded.fireProjectStateChanged(ProjectState.closed);
      Plugin.closeAllOpenedJubulaEditors(alsoProjectIndependent);
      ded.fireTestresultChanged(TestresultState.Refresh);
      setTreeViewerInputNull(Constants.TESTRE_ID);
      for (      TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
        tcb.getTreeViewer().setInput(null);
      }
      setTreeViewerInputNull(Constants.TS_BROWSER_ID);
      setTreeViewerInputNull(Constants.COMPNAMEBROWSER_ID);
      clearAnalyzeResultPage();
    }
  }
);
  ded.fireProjectLoadedListener(new NullProgressMonitor());
}","/** 
 * clears the content of client
 * @param alsoProjectIndependent whether also project independent editors should be closed such as the testresultviewer
 */
public static void clearClient(final boolean alsoProjectIndependent){
  final DataEventDispatcher ded=DataEventDispatcher.getInstance();
  TestExecution.getInstance().stopExecution();
  GeneralStorage gs=GeneralStorage.getInstance();
  if (gs != null && Persistor.instance() != null) {
    IProjectPO currProj=gs.getProject();
    if (currProj != null) {
      gs.setProject(null);
    }
    gs.reset();
  }
  Plugin.getDisplay().syncExec(new Runnable(){
    public void run(){
      final ProblemsBP problemsBP=ProblemsBP.getInstance();
      problemsBP.clearOldProblems();
      problemsBP.cleanupProblems();
      TestExecutionContributor.getInstance().getClientTest().resetToTesting();
      ded.fireRecordModeStateChanged(RecordModeState.notRunning);
      ded.fireOMStateChanged(OMState.notRunning);
      ded.fireProjectStateChanged(ProjectState.closed);
      Plugin.closeAllOpenedJubulaEditors(alsoProjectIndependent);
      ded.fireTestresultChanged(TestresultState.Clear);
      setTreeViewerInputNull(Constants.TESTRE_ID);
      for (      TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
        tcb.getTreeViewer().setInput(null);
      }
      setTreeViewerInputNull(Constants.TS_BROWSER_ID);
      setTreeViewerInputNull(Constants.COMPNAMEBROWSER_ID);
      clearAnalyzeResultPage();
    }
  }
);
  ded.fireProjectLoadedListener(new NullProgressMonitor());
}",0.9961513790891596
95830,"public void run(){
  final ProblemsBP problemsBP=ProblemsBP.getInstance();
  problemsBP.clearOldProblems();
  problemsBP.cleanupProblems();
  TestExecutionContributor.getInstance().getClientTest().resetToTesting();
  ded.fireRecordModeStateChanged(RecordModeState.notRunning);
  ded.fireOMStateChanged(OMState.notRunning);
  ded.fireProjectStateChanged(ProjectState.closed);
  Plugin.closeAllOpenedJubulaEditors(alsoProjectIndependent);
  ded.fireTestresultChanged(TestresultState.Refresh);
  setTreeViewerInputNull(Constants.TESTRE_ID);
  for (  TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
    tcb.getTreeViewer().setInput(null);
  }
  setTreeViewerInputNull(Constants.TS_BROWSER_ID);
  setTreeViewerInputNull(Constants.COMPNAMEBROWSER_ID);
  clearAnalyzeResultPage();
}","public void run(){
  final ProblemsBP problemsBP=ProblemsBP.getInstance();
  problemsBP.clearOldProblems();
  problemsBP.cleanupProblems();
  TestExecutionContributor.getInstance().getClientTest().resetToTesting();
  ded.fireRecordModeStateChanged(RecordModeState.notRunning);
  ded.fireOMStateChanged(OMState.notRunning);
  ded.fireProjectStateChanged(ProjectState.closed);
  Plugin.closeAllOpenedJubulaEditors(alsoProjectIndependent);
  ded.fireTestresultChanged(TestresultState.Clear);
  setTreeViewerInputNull(Constants.TESTRE_ID);
  for (  TestCaseBrowser tcb : MultipleTCBTracker.getInstance().getOpenTCBs()) {
    tcb.getTreeViewer().setInput(null);
  }
  setTreeViewerInputNull(Constants.TS_BROWSER_ID);
  setTreeViewerInputNull(Constants.COMPNAMEBROWSER_ID);
  clearAnalyzeResultPage();
}",0.9924812030075189
95831,"/** 
 * Returns the IEditorPart for the given node or null if no editor is opend for the given node
 * @param po the persistent object of the wanted editor
 * @return the IEditorPart or null if no editor found
 */
public static IEditorPart getEditorByPO(IPersistentObject po){
  IEditorReference editorRef=getEditorRefByPO(po);
  if (editorRef != null) {
    return editorRef.getEditor(false);
  }
  return null;
}","/** 
 * Returns the IEditorPart for the given node or null if no editor is opened for the given node
 * @param po the persistent object of the wanted editor
 * @return the IEditorPart or null if no editor found
 */
public static IEditorPart getEditorByPO(IPersistentObject po){
  IEditorReference editorRef=getEditorRefByPO(po);
  if (editorRef != null) {
    return editorRef.getEditor(false);
  }
  return null;
}",0.9987937273823884
95832,"/** 
 * Returns the IEditorReference for the given node or null if no editor is opend for the given node
 * @param po the persistent object of the wanted editor
 * @return the IEditorReference or null if no editor found
 */
public static IEditorReference getEditorRefByPO(IPersistentObject po){
  for (  IEditorReference editorRef : Plugin.getAllEditors()) {
    PersistableEditorInput pei=null;
    try {
      pei=(PersistableEditorInput)editorRef.getEditorInput().getAdapter(PersistableEditorInput.class);
    }
 catch (    PartInitException e) {
    }
    if (pei != null && pei.getNode().equals(po)) {
      return editorRef;
    }
  }
  return null;
}","/** 
 * Returns the IEditorReference for the given node or null if no editor is opened for the given node
 * @param po the persistent object of the wanted editor
 * @return the IEditorReference or null if no editor found
 */
public static IEditorReference getEditorRefByPO(IPersistentObject po){
  for (  IEditorReference editorRef : Plugin.getAllEditors()) {
    PersistableEditorInput pei=null;
    try {
      pei=(PersistableEditorInput)editorRef.getEditorInput().getAdapter(PersistableEditorInput.class);
    }
 catch (    PartInitException e) {
    }
    if (pei != null && pei.getNode().equals(po)) {
      return editorRef;
    }
  }
  return null;
}",0.9992395437262356
95833,"/** 
 * {@inheritDoc} 
 */
public boolean testImpl(Object receiver,String property,Object[] args){
  ITestResultSummaryPO summary=(ITestResultSummaryPO)receiver;
  if (property.equals(HAS_MONITORING_DATA_PROP)) {
    return summary.isReportWritten();
  }
  final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
  if (property.equals(HAS_TEST_RESULT_DETAILS_PROP)) {
    return TestResultPM.hasTestResultDetails(masterSession,summary.getId());
  }
 else   if (property.equals(HAS_PENDING_ALM_REPORT_PROP)) {
    return hasPendingALMReport(summary,masterSession);
  }
  return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean testImpl(Object receiver,String property,Object[] args){
  final GeneralStorage instance=GeneralStorage.getInstance();
  if (instance != null) {
    final EntityManager masterSession=instance.getMasterSession();
    if (masterSession.isOpen()) {
      ITestResultSummaryPO summary=(ITestResultSummaryPO)receiver;
      if (property.equals(HAS_MONITORING_DATA_PROP)) {
        return summary.isReportWritten();
      }
      if (property.equals(HAS_TEST_RESULT_DETAILS_PROP)) {
        return TestResultPM.hasTestResultDetails(masterSession,summary.getId());
      }
 else       if (property.equals(HAS_PENDING_ALM_REPORT_PROP)) {
        return hasPendingALMReport(summary,masterSession);
      }
    }
  }
  return false;
}",0.7271407837445574
95834,"/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  m_headerMenu=new Menu(parent);
  GridLayout layout=new GridLayout(4,false);
  parent.setLayout(layout);
  m_filter=new TestresultSummaryFilter();
  createSearchFilter(parent);
  m_tableViewer=new TableViewer(parent,SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER| SWT.FULL_SELECTION| SWT.MULTI| SWT.VIRTUAL);
  addDetailsColumn(m_tableViewer);
  addDateColumn(m_tableViewer);
  addCommentTitleColumn(m_tableViewer);
  addTestrunIdColumn(m_tableViewer);
  addTestRelevantColumn(m_tableViewer);
  addTestJobStartTimeColumn(m_tableViewer);
  addTestJobColumn(m_tableViewer);
  addStatusDecoratorColumn(m_tableViewer);
  addAlmStatusDecoratorColumn(m_tableViewer);
  addTsStatusColumn(m_tableViewer);
  addTestsuiteColumn(m_tableViewer);
  addProjectNameColumn(m_tableViewer);
  addAutIdColumn(m_tableViewer);
  addAutNameColumn(m_tableViewer);
  addAutConfColumn(m_tableViewer);
  addLanguageColumn(m_tableViewer);
  addCmdParamColumn(m_tableViewer);
  addAutOSColumn(m_tableViewer);
  addAutHostnameColumn(m_tableViewer);
  addAutAgentHostnameColumn(m_tableViewer);
  addToolkitColumn(m_tableViewer);
  addStartTimeColumn(m_tableViewer);
  addEndTimeColumn(m_tableViewer);
  addDurationColumn(m_tableViewer);
  addExpecCapsColumn(m_tableViewer);
  addExecCapsColumn(m_tableViewer);
  addEventhandlerCapsColumn(m_tableViewer);
  addFailedCapsColumn(m_tableViewer);
  addMonitoringIdColumn(m_tableViewer);
  addMonitoringValueColumn(m_tableViewer);
  addMonitoringReportColumn(m_tableViewer);
  getSite().setSelectionProvider(m_tableViewer);
  m_tableViewer.setContentProvider(new TestresultSummaryContentProvider());
  m_tableViewer.getTable().setLinesVisible(true);
  m_tableViewer.getTable().setHeaderVisible(true);
  m_tableViewer.setUseHashlookup(true);
  addContextMenu(m_tableViewer,m_headerMenu);
  setTableViewerLayout();
  m_tableViewer.addFilter(m_filter);
  PlatformUI.getWorkbench().getHelpSystem().setHelp(m_tableViewer.getControl(),ContextHelpIds.TESTRESULT_SUMMARY_VIEW);
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addTestresultListener(this,true);
  ded.addTestresultSummaryEventListener(this);
  DatabaseStateDispatcher.addDatabaseStateListener(this);
  addDoubleClickListener(m_tableViewer);
  loadViewInput();
  restoreViewStatus();
}","/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  m_headerMenu=new Menu(parent);
  GridLayout layout=new GridLayout(4,false);
  parent.setLayout(layout);
  m_filter=new TestresultSummaryFilter();
  createSearchFilter(parent);
  m_tableViewer=new TableViewer(parent,SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER| SWT.FULL_SELECTION| SWT.MULTI| SWT.VIRTUAL);
  addDetailsColumn(m_tableViewer);
  addDateColumn(m_tableViewer);
  addCommentTitleColumn(m_tableViewer);
  addTestrunIdColumn(m_tableViewer);
  addTestRelevantColumn(m_tableViewer);
  addTestJobStartTimeColumn(m_tableViewer);
  addTestJobColumn(m_tableViewer);
  addStatusDecoratorColumn(m_tableViewer);
  addAlmStatusDecoratorColumn(m_tableViewer);
  addTsStatusColumn(m_tableViewer);
  addTestsuiteColumn(m_tableViewer);
  addProjectNameColumn(m_tableViewer);
  addAutIdColumn(m_tableViewer);
  addAutNameColumn(m_tableViewer);
  addAutConfColumn(m_tableViewer);
  addLanguageColumn(m_tableViewer);
  addCmdParamColumn(m_tableViewer);
  addAutOSColumn(m_tableViewer);
  addAutHostnameColumn(m_tableViewer);
  addAutAgentHostnameColumn(m_tableViewer);
  addToolkitColumn(m_tableViewer);
  addStartTimeColumn(m_tableViewer);
  addEndTimeColumn(m_tableViewer);
  addDurationColumn(m_tableViewer);
  addExpecCapsColumn(m_tableViewer);
  addExecCapsColumn(m_tableViewer);
  addEventhandlerCapsColumn(m_tableViewer);
  addFailedCapsColumn(m_tableViewer);
  addMonitoringIdColumn(m_tableViewer);
  addMonitoringValueColumn(m_tableViewer);
  addMonitoringReportColumn(m_tableViewer);
  getSite().setSelectionProvider(m_tableViewer);
  m_tableViewer.setContentProvider(new ArrayContentProvider());
  m_tableViewer.getTable().setLinesVisible(true);
  m_tableViewer.getTable().setHeaderVisible(true);
  m_tableViewer.setUseHashlookup(true);
  addContextMenu(m_tableViewer,m_headerMenu);
  setTableViewerLayout();
  m_tableViewer.addFilter(m_filter);
  PlatformUI.getWorkbench().getHelpSystem().setHelp(m_tableViewer.getControl(),ContextHelpIds.TESTRESULT_SUMMARY_VIEW);
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addTestresultListener(this,true);
  ded.addTestresultSummaryEventListener(this);
  DatabaseStateDispatcher.addDatabaseStateListener(this);
  addDoubleClickListener(m_tableViewer);
  loadViewInput();
  restoreViewStatus();
}",0.9957228400342172
95835,"/** 
 * {@inheritDoc} 
 */
public void handleTestresultChanged(TestresultState state){
  if (state == TestresultState.Clear) {
    clear();
  }
 else   if (state == TestresultState.Refresh) {
    loadViewInput();
  }
}","/** 
 * {@inheritDoc} 
 */
public void handleTestresultChanged(TestresultState state){
switch (state) {
case Clear:
    clear();
  break;
case Refresh:
loadViewInput();
break;
default :
break;
}
}",0.7294685990338164
95836,"/** 
 * Clears the view (table).
 */
public void clear(){
  m_tableViewer.getTable().getDisplay().syncExec(new Runnable(){
    public void run(){
      m_tableViewer.setSelection(StructuredSelection.EMPTY);
      m_tableViewer.setInput(null);
      m_tableViewer.refresh();
    }
  }
);
}","/** 
 * Clears the view (table).
 */
public void clear(){
  m_tableViewer.getControl().getDisplay().syncExec(new Runnable(){
    public void run(){
      m_tableViewer.setSelection(StructuredSelection.EMPTY);
      m_tableViewer.setInput(ArrayUtils.EMPTY_OBJECT_ARRAY);
      m_tableViewer.refresh(true);
    }
  }
);
}",0.9192751235584844
95837,"/** 
 * Performs special processing when this page's Restore Defaults button has been pressed. Sets the contents of the nameEntry field to be the default
 */
protected void performDefaults(){
  m_minimize.setSelection(m_store.getDefaultBoolean(Constants.MINIMIZEONSUITESTART_KEY));
  m_treeScroll.setSelection(m_store.getDefaultBoolean(Constants.TREEAUTOSCROLL_KEY));
  m_askStopAUT.setSelection(m_store.getDefaultBoolean(Constants.ASKSTOPAUT_KEY));
  m_showOrigName.setSelection(m_store.getDefaultBoolean(Constants.SHOWORIGINALNAME_KEY));
  m_capInfoCheckbox.setSelection(m_store.getDefaultBoolean(Constants.SHOWCAPINFO_KEY));
  m_showTransientChildrenCheckBox.setSelection(m_store.getDefaultBoolean(Constants.SHOW_TRANSIENT_CHILDREN_KEY));
  m_loadDefaultProjectCheckBox.setSelection(m_store.getDefaultBoolean(Constants.PERFORM_AUTO_PROJECT_LOAD_KEY));
  m_perspChangeValue=m_store.getDefaultInt(Constants.PERSP_CHANGE_KEY);
  m_rememberValue=m_store.getDefaultBoolean(Constants.REMEMBER_KEY);
  setRadioSelection();
  m_dataDirIsWorkspaceValue=m_store.getDefaultBoolean(Constants.DATADIR_WS_KEY);
  setDataDirFields();
  m_dataDirPathTextfield.setText(m_store.getDefaultString(Constants.DATADIR_PATH_KEY));
  validatePage();
}","/** 
 * Performs special processing when this page's Restore Defaults button has been pressed. Sets the contents of the nameEntry field to be the default
 */
protected void performDefaults(){
  m_minimize.setSelection(m_store.getDefaultBoolean(Constants.MINIMIZEONSUITESTART_KEY));
  m_treeScroll.setSelection(m_store.getDefaultBoolean(Constants.TREEAUTOSCROLL_KEY));
  m_askStopAUT.setSelection(m_store.getDefaultBoolean(Constants.ASKSTOPAUT_KEY));
  m_showOrigName.setSelection(m_store.getDefaultBoolean(Constants.SHOWORIGINALNAME_KEY));
  m_capInfoCheckbox.setSelection(m_store.getDefaultBoolean(Constants.SHOWCAPINFO_KEY));
  m_showTransientChildrenCheckBox.setSelection(m_store.getDefaultBoolean(Constants.SHOW_TRANSIENT_CHILDREN_KEY));
  m_compNamesContentAssistTime.setText(m_store.getDefaultString(Constants.MILLIS_TO_OPEN_COMP_NAMES_CONTENT_PROPOSAL));
  m_loadDefaultProjectCheckBox.setSelection(m_store.getDefaultBoolean(Constants.PERFORM_AUTO_PROJECT_LOAD_KEY));
  m_perspChangeValue=m_store.getDefaultInt(Constants.PERSP_CHANGE_KEY);
  m_rememberValue=m_store.getDefaultBoolean(Constants.REMEMBER_KEY);
  setRadioSelection();
  m_dataDirIsWorkspaceValue=m_store.getDefaultBoolean(Constants.DATADIR_WS_KEY);
  setDataDirFields();
  m_dataDirPathTextfield.setText(m_store.getDefaultString(Constants.DATADIR_PATH_KEY));
  validatePage();
}",0.9534522885958108
95838,"/** 
 * Constructs a text field. When pressing STRG+SPACE a list pops up.
 * @param compMapper The Component Name mapper to use.
 * @param composite The parent composite.
 * @param style The style of the text field.
 */
public CompNamePopUpTextField(IComponentNameMapper compMapper,Composite composite,int style){
  super(composite,style);
  KeyStroke ks=null;
  try {
    ks=KeyStroke.getInstance(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  m_labelProvider=new LabelProvider(){
    public Image getImage(    Object element){
      CompNamesProposal p=(CompNamesProposal)element;
      char type=p.getLabel().charAt(0);
switch (type) {
case 'G':
        return IconConstants.GLOBAL_NAME_IMAGE;
case 'L':
      return IconConstants.LOCAL_NAME_IMAGE;
case 'A':
    return IconConstants.AUT_COMP_NAME_IMAGE;
default :
  return null;
}
}
public String getText(Object element){
CompNamesProposal p=(CompNamesProposal)element;
return p.getLabel().substring(1);
}
public boolean isLabelProperty(Object element,String property){
return false;
}
}
;
m_popupListener=new IContentProposalListener2Implementation();
m_contentProposalProvider=new CompNamesProposalProvider(compMapper);
enableContentProposal(m_contentProposalProvider,ks);
int delay=Plugin.getDefault().getPreferenceStore().getInt(Constants.MILLIS_TO_OPEN_COMP_NAMES_CONTENT_PROPOSAL);
final DelayableTimer contentProposalTimer=new DelayableTimer(delay,new Runnable(){
public void run(){
openContentProposals();
}
}
);
addKeyListener(new KeyListener(){
public void keyReleased(KeyEvent e){
if (!getText().equals(StringConstants.EMPTY) && triggerCharWasTyped(e)) {
contentProposalTimer.schedule();
}
}
public void keyPressed(KeyEvent e){
contentProposalTimer.cancel();
}
}
);
}","/** 
 * Constructs a text field. When pressing STRG+SPACE a list pops up.
 * @param compMapper The Component Name mapper to use.
 * @param composite The parent composite.
 * @param style The style of the text field.
 */
public CompNamePopUpTextField(IComponentNameMapper compMapper,Composite composite,int style){
  super(composite,style);
  KeyStroke ks=null;
  try {
    ks=KeyStroke.getInstance(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  m_labelProvider=new LabelProvider(){
    public Image getImage(    Object element){
      CompNamesProposal p=(CompNamesProposal)element;
      char type=p.getLabel().charAt(0);
switch (type) {
case 'G':
        return IconConstants.GLOBAL_NAME_IMAGE;
case 'L':
      return IconConstants.LOCAL_NAME_IMAGE;
case 'A':
    return IconConstants.AUT_COMP_NAME_IMAGE;
default :
  return null;
}
}
public String getText(Object element){
CompNamesProposal p=(CompNamesProposal)element;
return p.getLabel().substring(1);
}
public boolean isLabelProperty(Object element,String property){
return false;
}
}
;
m_popupListener=new IContentProposalListener2Implementation();
m_contentProposalProvider=new CompNamesProposalProvider(compMapper);
enableContentProposal(m_contentProposalProvider,ks);
int delay=Plugin.getDefault().getPreferenceStore().getInt(Constants.MILLIS_TO_OPEN_COMP_NAMES_CONTENT_PROPOSAL);
final DelayableTimer contentProposalTimer=new DelayableTimer(delay,new Runnable(){
public void run(){
Display.getDefault().syncExec(new Runnable(){
public void run(){
  openContentProposals();
}
}
);
}
}
);
addKeyListener(new KeyListener(){
public void keyReleased(KeyEvent e){
if (!getText().equals(StringConstants.EMPTY) && triggerCharWasTyped(e)) {
contentProposalTimer.schedule();
}
}
public void keyPressed(KeyEvent e){
contentProposalTimer.cancel();
}
}
);
}",0.9674523007856342
95839,"/** 
 * Opens the proposals for the component name
 */
private void openContentProposals(){
  Display display=Workbench.getInstance().getDisplay();
  Event ctrlEvent=new Event();
  ctrlEvent.type=SWT.KeyDown;
  ctrlEvent.keyCode=SWT.CTRL;
  display.post(ctrlEvent);
  Event spaceEvent=new Event();
  spaceEvent.type=SWT.KeyDown;
  spaceEvent.character=SWT.SPACE;
  display.post(spaceEvent);
  try {
    Thread.sleep(10);
  }
 catch (  InterruptedException ie) {
  }
  ctrlEvent.type=SWT.KeyUp;
  display.post(ctrlEvent);
  spaceEvent.type=SWT.KeyUp;
  display.post(spaceEvent);
}","/** 
 * Opens the proposals for the component name
 */
private void openContentProposals(){
  if (m_contentProposalAdapter.isProposalPopupOpen()) {
    return;
  }
  Event triggerEvent=new Event();
  triggerEvent.character=SWT.SPACE;
  triggerEvent.doit=true;
  triggerEvent.keyCode=SWT.SPACE;
  triggerEvent.stateMask=SWT.MOD1;
  triggerEvent.type=SWT.KeyDown;
  triggerEvent.widget=this;
  notifyListeners(SWT.KeyDown,triggerEvent);
}",0.2699507389162561
95840,"/** 
 * Opens the proposals for the component name
 */
private void openContentProposals(){
  if (m_contentProposalAdapter.isProposalPopupOpen()) {
    return;
  }
  Event triggerEvent=new Event();
  triggerEvent.character=SWT.SPACE;
  triggerEvent.doit=true;
  triggerEvent.keyCode=SWT.SPACE;
  triggerEvent.stateMask=SWT.CTRL;
  triggerEvent.type=SWT.KeyDown;
  triggerEvent.widget=this;
  notifyListeners(SWT.KeyDown,triggerEvent);
}","/** 
 * Opens the proposals for the component name
 */
private void openContentProposals(){
  if (!isDisposed()) {
    if (m_contentProposalAdapter.isProposalPopupOpen()) {
      return;
    }
    Event triggerEvent=new Event();
    triggerEvent.character=SWT.SPACE;
    triggerEvent.doit=true;
    triggerEvent.keyCode=SWT.SPACE;
    triggerEvent.stateMask=SWT.CTRL;
    triggerEvent.type=SWT.KeyDown;
    triggerEvent.widget=this;
    notifyListeners(SWT.KeyDown,triggerEvent);
  }
}",0.9467969598262758
95841,"/** 
 * {@inheritDoc}
 */
protected void extendOptions(Options options,boolean req){
  options.addOption(createOption(ClientTestStrings.SERVER,false,ClientTestStrings.HOSTNAME,Messages.ClientServerOpt,req));
  options.addOption(createOption(ClientTestStrings.PORT,false,ClientTestStrings.PORT_NUMBER,Messages.ClientPortOpt,req));
  options.addOption(createOption(ClientTestStrings.PROJECT,true,ClientTestStrings.PROJECT_NAME,Messages.ClientProjectOpt,req));
  options.addOption(createOption(ClientTestStrings.PROJECT_VERSION,true,ClientTestStrings.PROJECT_VERSION_EX,Messages.ClientProjectVersionOpt,req));
  options.addOption(createOption(ClientTestStrings.LANGUAGE,true,ClientTestStrings.LANGUAGE,Messages.ClientLanguageOpt,req));
  options.addOption(createOption(ClientTestStrings.RESULTDIR,true,ClientTestStrings.RESULTDIR,Messages.ClientResultdirOpt,req));
  OptionGroup autOptionGroup=new OptionGroup();
  autOptionGroup.setRequired(false);
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_CONFIG,true,ClientTestStrings.AUT_CONFIG,Messages.ClientAutconfigOpt,req));
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_ID,true,ClientTestStrings.AUT_ID,Messages.ClientAutIdOpt,req));
  options.addOptionGroup(autOptionGroup);
  OptionGroup testExecutionGroup=new OptionGroup();
  testExecutionGroup.setRequired(req);
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTJOB,true,ClientTestStrings.TESTJOB,Messages.ClientTestJobOpt,req));
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTSUITE,true,ClientTestStrings.TESTSUITE,Messages.ClientTestSuiteOpt,req));
  options.addOptionGroup(testExecutionGroup);
  options.addOption(createOption(ClientTestStrings.DATA_DIR,true,ClientTestStrings.DATA_DIR_EX,Messages.ClientDataFile,req));
  options.addOption(createOption(ClientStrings.NORUN,false,StringConstants.EMPTY,Messages.ClientNoRunOpt,false));
  options.addOption(createOption(ClientTestStrings.AUTO_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientAutoScreenshot,false));
  options.addOption(createOption(ClientTestStrings.NO_XML_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientNoXmlScreenshot,false));
  options.addOption(createOption(ClientTestStrings.TEST_EXECUTION_RELEVANT,false,StringConstants.EMPTY,Messages.ClientRelevantFlag,false));
  options.addOption(createOption(ClientTestStrings.TIMEOUT,true,ClientTestStrings.TIMEOUT,Messages.ClientTimeout,false));
  options.addOption(createOption(ClientTestStrings.STARTSERVER,true,ClientTestStrings.PORT_NUMBER,Messages.ClientStartServerOpt,false));
}","/** 
 * {@inheritDoc}
 */
protected void extendOptions(Options options,boolean req){
  options.addOption(createOption(ClientTestStrings.SERVER,true,ClientTestStrings.HOSTNAME,Messages.ClientServerOpt,false));
  options.addOption(createOption(ClientTestStrings.PORT,true,ClientTestStrings.PORT_NUMBER,Messages.ClientPortOpt,false));
  options.addOption(createOption(ClientTestStrings.PROJECT,true,ClientTestStrings.PROJECT_NAME,Messages.ClientProjectOpt,req));
  options.addOption(createOption(ClientTestStrings.PROJECT_VERSION,true,ClientTestStrings.PROJECT_VERSION_EX,Messages.ClientProjectVersionOpt,req));
  options.addOption(createOption(ClientTestStrings.LANGUAGE,true,ClientTestStrings.LANGUAGE,Messages.ClientLanguageOpt,req));
  options.addOption(createOption(ClientTestStrings.RESULTDIR,true,ClientTestStrings.RESULTDIR,Messages.ClientResultdirOpt,req));
  OptionGroup autOptionGroup=new OptionGroup();
  autOptionGroup.setRequired(false);
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_CONFIG,true,ClientTestStrings.AUT_CONFIG,Messages.ClientAutconfigOpt,req));
  autOptionGroup.addOption(createOption(ClientTestStrings.AUT_ID,true,ClientTestStrings.AUT_ID,Messages.ClientAutIdOpt,req));
  options.addOptionGroup(autOptionGroup);
  OptionGroup testExecutionGroup=new OptionGroup();
  testExecutionGroup.setRequired(req);
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTJOB,true,ClientTestStrings.TESTJOB,Messages.ClientTestJobOpt,req));
  testExecutionGroup.addOption(createOption(ClientTestStrings.TESTSUITE,true,ClientTestStrings.TESTSUITE,Messages.ClientTestSuiteOpt,req));
  options.addOptionGroup(testExecutionGroup);
  options.addOption(createOption(ClientTestStrings.DATA_DIR,true,ClientTestStrings.DATA_DIR_EX,Messages.ClientDataFile,req));
  options.addOption(createOption(ClientStrings.NORUN,false,StringConstants.EMPTY,Messages.ClientNoRunOpt,false));
  options.addOption(createOption(ClientTestStrings.AUTO_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientAutoScreenshot,false));
  options.addOption(createOption(ClientTestStrings.NO_XML_SCREENSHOT,false,StringConstants.EMPTY,Messages.ClientNoXmlScreenshot,false));
  options.addOption(createOption(ClientTestStrings.TEST_EXECUTION_RELEVANT,false,StringConstants.EMPTY,Messages.ClientRelevantFlag,false));
  options.addOption(createOption(ClientTestStrings.TIMEOUT,true,ClientTestStrings.TIMEOUT,Messages.ClientTimeout,false));
  options.addOption(createOption(ClientTestStrings.STARTSERVER,true,ClientTestStrings.PORT_NUMBER,Messages.ClientStartServerOpt,false));
}",0.9941770186335404
95842,"/** 
 * A synchronized method for sending messages. If an IO error occurs, the error handlers will be notified with sendFailed, shutDown AND an IOException will be thrown. In case of a serialization error the error handler will be notified with sendFailed(). The header is filled with the message length 
 * @param header - the header for the message, must not be null
 * @param message - the message to send, must not be null
 * @throws IOException - if the message could not send due to an IOException
 * @throws IllegalArgumentException - if the given message is null
 */
public synchronized void send(MessageHeader header,String message) throws IOException, IllegalArgumentException {
  Validate.notNull(header,""String_Node_Str"");
  Validate.notNull(message,""String_Node_Str"");
  MessageWriter writer=null;
  try {
    header.setMessageLength(message.length());
    String serializedHeader=m_headerSerializer.serialize(header);
    writer=new MessageWriter(new OutputStreamWriter(m_outputStream,IO_STREAM_ENCODING));
    writer.write(MessageHeader.HEADER_START);
    writer.write(StringConstants.EMPTY + serializedHeader.length());
    writer.newLine();
    writer.write(serializedHeader);
    writer.write(message);
    writer.flush();
    if (getLogger().isInfoEnabled()) {
      getLogger().info(""String_Node_Str"" + m_socket.getRemoteSocketAddress() + ""String_Node_Str""+ serializedHeader);
    }
    if (getLogger().isDebugEnabled()) {
      getLogger().debug(""String_Node_Str"" + message);
    }
  }
 catch (  IOException ioe) {
    getLogger().error(""String_Node_Str"",ioe);
    fireSendFailed(message,header);
    fireShutDown();
    throw ioe;
  }
catch (  SerialisationException se) {
    getLogger().error(""String_Node_Str"" + header.toString() + ""String_Node_Str"",se);
    fireSendFailed(message,header);
  }
 finally {
    if (writer != null) {
      writer.close();
    }
  }
}","/** 
 * A synchronized method for sending messages. If an IO error occurs, the error handlers will be notified with sendFailed, shutDown AND an IOException will be thrown. In case of a serialization error the error handler will be notified with sendFailed(). The header is filled with the message length 
 * @param header - the header for the message, must not be null
 * @param message - the message to send, must not be null
 * @throws IOException - if the message could not send due to an IOException
 * @throws IllegalArgumentException - if the given message is null
 */
public synchronized void send(MessageHeader header,String message) throws IOException, IllegalArgumentException {
  Validate.notNull(header,""String_Node_Str"");
  Validate.notNull(message,""String_Node_Str"");
  try {
    header.setMessageLength(message.length());
    String serializedHeader=m_headerSerializer.serialize(header);
    MessageWriter writer=new MessageWriter(new OutputStreamWriter(m_outputStream,IO_STREAM_ENCODING));
    writer.write(MessageHeader.HEADER_START);
    writer.write(StringConstants.EMPTY + serializedHeader.length());
    writer.newLine();
    writer.write(serializedHeader);
    writer.write(message);
    writer.flush();
    if (getLogger().isInfoEnabled()) {
      getLogger().info(""String_Node_Str"" + m_socket.getRemoteSocketAddress() + ""String_Node_Str""+ serializedHeader);
    }
    if (getLogger().isDebugEnabled()) {
      getLogger().debug(""String_Node_Str"" + message);
    }
  }
 catch (  IOException ioe) {
    getLogger().error(""String_Node_Str"",ioe);
    fireSendFailed(message,header);
    fireShutDown();
    throw ioe;
  }
catch (  SerialisationException se) {
    getLogger().error(""String_Node_Str"" + header.toString() + ""String_Node_Str"",se);
    fireSendFailed(message,header);
  }
}",0.9107142857142856
95843,"/** 
 * {@inheritDoc} 
 */
public void createPartControlImpl(Composite parent){
  super.createPartControlImpl(parent);
  m_eventHandlerTreeViewer.setContentProvider(new EventHandlerContentProvider());
  m_eventHandlerTreeViewer.getControl().setMenu(createContextMenu());
  addDoubleClickListener(CommandIDs.OPEN_SPECIFICATION_COMMAND_ID,m_eventHandlerTreeViewer);
  ActionListener actionListener=new ActionListener();
  getTreeViewer().addSelectionChangedListener(actionListener);
  getEventHandlerTreeViewer().addSelectionChangedListener(actionListener);
  if (!Plugin.getDefault().anyDirtyStar()) {
    checkAndRemoveUnusedTestData();
  }
  m_currentTreeViewer=getMainTreeViewer();
}","/** 
 * {@inheritDoc} 
 */
public void createPartControlImpl(Composite parent){
  super.createPartControlImpl(parent);
  m_eventHandlerTreeViewer.setContentProvider(new EventHandlerContentProvider());
  m_eventHandlerTreeViewer.getControl().setMenu(createContextMenu());
  addDoubleClickListener(CommandIDs.OPEN_SPECIFICATION_COMMAND_ID,m_eventHandlerTreeViewer);
  ActionListener actionListener=new ActionListener();
  getTreeViewer().addSelectionChangedListener(actionListener);
  getEventHandlerTreeViewer().addSelectionChangedListener(actionListener);
  if (!Plugin.getDefault().anyDirtyStar()) {
    checkAndRemoveUnusedTestData();
  }
  m_currentTreeViewer=getMainTreeViewer();
  m_selectionProviderDelegate=new SelectionProviderIntermediate();
  m_selectionProviderDelegate.setSelectionProviderDelegate(m_currentTreeViewer);
  getSite().setSelectionProvider(m_selectionProviderDelegate);
}",0.866540164452878
95844,"/** 
 * {@inheritDoc} 
 */
public void focusGained(FocusEvent e){
  Tree tree=(Tree)e.getSource();
  if (getMainTreeViewer().getTree() == tree) {
    m_currentTreeViewer=getMainTreeViewer();
  }
 else   if (getEventHandlerTreeViewer().getTree() == tree) {
    m_currentTreeViewer=getEventHandlerTreeViewer();
  }
}","/** 
 * {@inheritDoc} 
 */
public void focusGained(FocusEvent e){
  Tree tree=(Tree)e.getSource();
  if (getMainTreeViewer().getTree() == tree) {
    m_currentTreeViewer=getMainTreeViewer();
  }
 else   if (getEventHandlerTreeViewer().getTree() == tree) {
    m_currentTreeViewer=getEventHandlerTreeViewer();
  }
  m_selectionProviderDelegate.setSelectionProviderDelegate(m_currentTreeViewer);
}",0.8857545839210155
95845,"/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  buildTree(parent);
  Plugin.getHelpSystem().setHelp(m_treeViewer.getControl(),ContextHelpIds.JB_PROPERTIES_VIEW);
  final DataEventDispatcher dispatcher=DataEventDispatcher.getInstance();
  dispatcher.addDataChangedListener(this,true);
  dispatcher.addParamChangedListener(this,true);
  dispatcher.addPartClosedListener(this,true);
  dispatcher.addLanguageChangedListener(this,true);
  m_treeViewer.getControl().addHelpListener(m_helpListener);
}","/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  buildTree(parent);
  Plugin.getHelpSystem().setHelp(m_treeViewer.getControl(),ContextHelpIds.JB_PROPERTIES_VIEW);
  final DataEventDispatcher dispatcher=DataEventDispatcher.getInstance();
  dispatcher.addDataChangedListener(this,true);
  dispatcher.addParamChangedListener(this,true);
  dispatcher.addPartClosedListener(this,true);
  dispatcher.addLanguageChangedListener(this,true);
  m_treeViewer.getControl().addHelpListener(m_helpListener);
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(this);
}",0.9264836138175376
95846,"/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  m_cutTreeItemAction=new CutTreeItemActionTCBrowser();
  m_pasteTreeItemAction=new PasteTreeItemActionTCBrowser();
  super.createPartControl(parent);
  getViewSite().getActionBars().getToolBarManager().add(CommandHelper.createContributionItem(RCPCommandIDs.SET_MAIN_VIEW_INSTANCE,null,null,CommandContributionItem.STYLE_PUSH));
  getViewSite().getActionBars().getToolBarManager().add(CommandHelper.createContributionItem(RCPCommandIDs.COLLAPSE_ALL,null,null,CommandContributionItem.STYLE_PUSH));
  ColumnViewerToolTipSupport.enableFor(getTreeViewer());
  getTreeViewer().setContentProvider(new TestCaseBrowserContentProvider());
  DecoratingCellLabelProvider lp=new DecoratingCellLabelProvider(new TestCaseBrowserLabelProvider(),Plugin.getDefault().getWorkbench().getDecoratorManager().getLabelDecorator());
  getTreeViewer().setLabelProvider(lp);
  int ops=DND.DROP_MOVE;
  Transfer[] transfers=new Transfer[]{LocalSelectionTransfer.getInstance()};
  getTreeViewer().addDragSupport(ops,transfers,new TreeViewerContainerDragSourceListener(getTreeViewer()));
  getTreeViewer().addDropSupport(ops,transfers,new TestSpecDropTargetListener(this));
  registerContextMenu();
  Plugin.getHelpSystem().setHelp(getTreeViewer().getControl(),ContextHelpIds.TEST_SPEC_VIEW);
  configureActionBars();
  if (GeneralStorage.getInstance().getProject() != null) {
    handleProjectLoaded();
  }
  MultipleTCBTracker.getInstance().addTCB(this);
}","/** 
 * {@inheritDoc}
 */
public void createPartControl(Composite parent){
  m_cutTreeItemAction=new CutTreeItemActionTCBrowser();
  m_pasteTreeItemAction=new PasteTreeItemActionTCBrowser();
  super.createPartControl(parent);
  getViewSite().getActionBars().getToolBarManager().add(CommandHelper.createContributionItem(RCPCommandIDs.SET_MAIN_VIEW_INSTANCE,null,null,CommandContributionItem.STYLE_PUSH));
  getViewSite().getActionBars().getToolBarManager().add(CommandHelper.createContributionItem(RCPCommandIDs.COLLAPSE_ALL,null,null,CommandContributionItem.STYLE_PUSH));
  ColumnViewerToolTipSupport.enableFor(getTreeViewer());
  getTreeViewer().setContentProvider(new TestCaseBrowserContentProvider());
  DecoratingCellLabelProvider lp=new DecoratingCellLabelProvider(new TestCaseBrowserLabelProvider(),Plugin.getDefault().getWorkbench().getDecoratorManager().getLabelDecorator());
  getTreeViewer().setLabelProvider(lp);
  int ops=DND.DROP_MOVE;
  Transfer[] transfers=new Transfer[]{LocalSelectionTransfer.getInstance()};
  getTreeViewer().addDragSupport(ops,transfers,new TreeViewerContainerDragSourceListener(getTreeViewer()));
  getTreeViewer().addDropSupport(ops,transfers,new TestSpecDropTargetListener(this));
  registerContextMenu();
  Plugin.getHelpSystem().setHelp(getTreeViewer().getControl(),ContextHelpIds.TEST_SPEC_VIEW);
  configureActionBars();
  if (GeneralStorage.getInstance().getProject() != null) {
    handleProjectLoaded();
  }
  MultipleTCBTracker.getInstance().addTCB(this);
  getSite().setSelectionProvider(getTreeViewer());
}",0.9833278849297156
95847,"/** 
 * fill result node
 * @param keyword ITestResultPO
 * @param resultNode ITestResultPO
 */
private void fillNode(ITestResultPO keyword,TestResultNode resultNode){
  INodePO node=resultNode.getNode();
  keyword.setKeywordName(node.getName());
  keyword.setInternalKeywordGuid(node.getGuid());
  keyword.setKeywordComment(node.getComment());
  keyword.setTaskId(node.getTaskId());
  keyword.setInternalKeywordStatus(resultNode.getStatus());
  keyword.setKeywordStatus(resultNode.getStatusString());
  if (resultNode.getTimeStamp() != null) {
    keyword.setTimestamp(resultNode.getTimeStamp());
  }
  if (resultNode.getParent() != null) {
    keyword.setInternalParentKeywordID(resultNode.getParent().getNode().getId());
  }
  if (node instanceof IParameterInterfacePO) {
    addParameterListToResult(keyword,resultNode,(IParameterInterfacePO)node);
  }
  keyword.setKeywordType(resultNode.getTypeOfNode());
  if (node instanceof ICapPO) {
    keyword.setInternalKeywordType(TYPE_TEST_STEP);
    ICapPO cap=(ICapPO)node;
    String compNameGuid=cap.getComponentName();
    keyword.setInternalComponentNameGuid(compNameGuid);
    keyword.setComponentName(StringUtils.defaultString(resultNode.getComponentName()));
    keyword.setInternalComponentType(cap.getComponentType());
    keyword.setComponentType(CompSystemI18n.getString(cap.getComponentType()));
    keyword.setInternalActionName(cap.getActionName());
    keyword.setActionName(CompSystemI18n.getString(cap.getActionName()));
    addErrorDetails(keyword,resultNode);
    keyword.setNoOfSimilarComponents(resultNode.getNoOfSimilarComponents());
    keyword.setOmHeuristicEquivalence(resultNode.getOmHeuristicEquivalence());
  }
 else   if (node instanceof ITestCasePO) {
    keyword.setInternalKeywordType(TYPE_TEST_CASE);
  }
 else   if (node instanceof ITestSuitePO) {
    keyword.setInternalKeywordType(TYPE_TEST_SUITE);
  }
}","/** 
 * fill result node
 * @param keyword ITestResultPO
 * @param resultNode ITestResultPO
 */
private void fillNode(ITestResultPO keyword,TestResultNode resultNode){
  INodePO node=resultNode.getNode();
  keyword.setKeywordName(node.getName());
  keyword.setInternalKeywordGuid(node.getGuid());
  keyword.setKeywordComment(node.getComment());
  keyword.setTaskId(resultNode.getTaskId());
  keyword.setInternalKeywordStatus(resultNode.getStatus());
  keyword.setKeywordStatus(resultNode.getStatusString());
  if (resultNode.getTimeStamp() != null) {
    keyword.setTimestamp(resultNode.getTimeStamp());
  }
  if (resultNode.getParent() != null) {
    keyword.setInternalParentKeywordID(resultNode.getParent().getNode().getId());
  }
  if (node instanceof IParameterInterfacePO) {
    addParameterListToResult(keyword,resultNode,(IParameterInterfacePO)node);
  }
  keyword.setKeywordType(resultNode.getTypeOfNode());
  if (node instanceof ICapPO) {
    keyword.setInternalKeywordType(TYPE_TEST_STEP);
    ICapPO cap=(ICapPO)node;
    String compNameGuid=cap.getComponentName();
    keyword.setInternalComponentNameGuid(compNameGuid);
    keyword.setComponentName(StringUtils.defaultString(resultNode.getComponentName()));
    keyword.setInternalComponentType(cap.getComponentType());
    keyword.setComponentType(CompSystemI18n.getString(cap.getComponentType()));
    keyword.setInternalActionName(cap.getActionName());
    keyword.setActionName(CompSystemI18n.getString(cap.getActionName()));
    addErrorDetails(keyword,resultNode);
    keyword.setNoOfSimilarComponents(resultNode.getNoOfSimilarComponents());
    keyword.setOmHeuristicEquivalence(resultNode.getOmHeuristicEquivalence());
  }
 else   if (node instanceof ITestCasePO) {
    keyword.setInternalKeywordType(TYPE_TEST_CASE);
  }
 else   if (node instanceof ITestSuitePO) {
    keyword.setInternalKeywordType(TYPE_TEST_SUITE);
  }
}",0.9978869519281564
95848,"/** 
 * Fix for MS Windows for keys that also appear on the numpad. Turns NumLock off if it is on. First method called of a two-part fix.
 * @param keyCode keycode to check
 * @return <code>True</code>, if the NumLock status was toggled. Otherwise<code>false</code>. Basically, a value of true indicates that  second part of this fix must also be used.
 */
private boolean hackWindowsNumpadKeys1(int keyCode){
  boolean isNumpadKey=false;
  for (int i=0; i < NUMPAD_KEYCODES.length; ++i) {
    if (NUMPAD_KEYCODES[i] == keyCode) {
      isNumpadKey=true;
      break;
    }
  }
  boolean wasNumLockToggled=false;
  if (isNumpadKey) {
    try {
      m_robot.keyPress(KeyEvent.VK_NUM_LOCK);
      m_robot.keyRelease(KeyEvent.VK_NUM_LOCK);
      m_robot.keyPress(KeyEvent.VK_NUM_LOCK);
      m_robot.keyRelease(KeyEvent.VK_NUM_LOCK);
      if (Toolkit.getDefaultToolkit().getLockingKeyState(KeyEvent.VK_NUM_LOCK)) {
        Toolkit.getDefaultToolkit().setLockingKeyState(KeyEvent.VK_NUM_LOCK,false);
        wasNumLockToggled=true;
      }
    }
 catch (    UnsupportedOperationException usoe) {
      log.info(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return wasNumLockToggled;
}","/** 
 * Fix for MS Windows for keys that also appear on the numpad. Turns NumLock off if it is on. First method called of a two-part fix.
 * @param keyCode keycode to check
 * @return <code>True</code>, if the NumLock status was toggled. Otherwise<code>false</code>. Basically, a value of true indicates that  second part of this fix must also be used.
 */
private boolean hackWindowsNumpadKeys1(int keyCode){
  if (!EnvironmentUtils.isWindowsOS()) {
    return false;
  }
  boolean isNumpadKey=false;
  for (int i=0; i < NUMPAD_KEYCODES.length; ++i) {
    if (NUMPAD_KEYCODES[i] == keyCode) {
      isNumpadKey=true;
      break;
    }
  }
  boolean wasNumLockToggled=false;
  if (isNumpadKey) {
    try {
      m_robot.keyPress(KeyEvent.VK_NUM_LOCK);
      m_robot.keyRelease(KeyEvent.VK_NUM_LOCK);
      m_robot.keyPress(KeyEvent.VK_NUM_LOCK);
      m_robot.keyRelease(KeyEvent.VK_NUM_LOCK);
      final Toolkit defaultToolkit=Toolkit.getDefaultToolkit();
      if (defaultToolkit.getLockingKeyState(KeyEvent.VK_NUM_LOCK)) {
        defaultToolkit.setLockingKeyState(KeyEvent.VK_NUM_LOCK,false);
        wasNumLockToggled=true;
      }
    }
 catch (    UnsupportedOperationException usoe) {
      log.info(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return wasNumLockToggled;
}",0.9398465886152604
95849,"/** 
 * Adds elements to the given cmds List.
 * @param autServerClasspath the server classpath
 * @param cmds the 1st part of the cmd array
 * @param parameters The parameters for starting the AUT.
 */
protected void createAutServerClasspath(StringBuffer autServerClasspath,List cmds,Map parameters){
  if (AutStarter.getInstance().getAutCommunicator() != null) {
    cmds.add(String.valueOf(AutStarter.getInstance().getAutCommunicator().getLocalPort()));
  }
 else {
    cmds.add(""String_Node_Str"");
  }
  String autMain=getAUTMainClass(parameters);
  if (autMain == null) {
    return;
  }
  cmds.add(autMain);
  autServerClasspath.append(PATH_SEPARATOR).append(getRcBundleClassPath());
  cmds.add(autServerClasspath.toString());
  cmds.add(getServerClassName());
}","/** 
 * Adds elements to the given cmds List.
 * @param autServerClasspath the server classpath
 * @param cmds the 1st part of the cmd array
 * @param parameters The parameters for starting the AUT.
 */
protected void createAutServerClasspath(StringBuffer autServerClasspath,List cmds,Map parameters){
  final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
  if (autCommunicator != null) {
    cmds.add(String.valueOf(autCommunicator.getLocalPort()));
  }
 else {
    cmds.add(""String_Node_Str"");
  }
  String autMain=getAUTMainClass(parameters);
  if (autMain == null) {
    return;
  }
  cmds.add(autMain);
  autServerClasspath.append(PATH_SEPARATOR).append(getRcBundleClassPath());
  cmds.add(autServerClasspath.toString());
  cmds.add(getServerClassName());
}",0.9230769230769232
95850,"/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map parameters,String autServerClasspath){
  String env=(String)parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    if (AutStarter.getInstance().getAutCommunicator() != null) {
      serverPort=String.valueOf(AutStarter.getInstance().getAutCommunicator().getLocalPort());
    }
    env+=ENV_SEPARATOR + ""String_Node_Str"" + serverPort;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + autServerClasspath;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + getServerClassName();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}","/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map parameters,String autServerClasspath){
  String env=(String)parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
    if (autCommunicator != null) {
      serverPort=String.valueOf(autCommunicator.getLocalPort());
    }
    env+=ENV_SEPARATOR + ""String_Node_Str"" + serverPort;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + autServerClasspath;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + getServerClassName();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}",0.9557650471356056
95851,"/** 
 * Stops the Running AUT with the given ID.
 * @param autId The ID of the Running AUT to stop.
 */
public void stopAUT(AutIdentifier autId){
  fireAndSetAutState(false);
  if (TestExecution.getInstance().getStartedTestSuite() != null && TestExecution.getInstance().getStartedTestSuite().isStarted()) {
    stopTestSuiteAction();
  }
  getClientTest().stopAut(autId);
}","/** 
 * Stops the Running AUT with the given ID.
 * @param autId The ID of the Running AUT to stop.
 */
public void stopAUT(AutIdentifier autId){
  fireAndSetAutState(false);
  final ITestSuitePO startedTestSuite=TestExecution.getInstance().getStartedTestSuite();
  if (startedTestSuite != null && startedTestSuite.isStarted()) {
    stopTestSuiteAction();
  }
  getClientTest().stopAut(autId);
}",0.7438231469440832
95852,"/** 
 * Send a message through this communicator and expect a response of type command. ICommand.request will be called at the other site. If a response was received the corresponding data will be set to the command object via setData(). If the response was received during the given timeout, command.response will be called. Otherwise command.timeout will be called. This method will not block.
 * @param message -the Message to send, must not be null otherwise an CommunicationException is thrown.
 * @param command -the expected command, must not be null or a CommunicationException is thrown. If the command arrives in good time, the method execute() of the given instance will be called. If the commands arrives to late timeout() will be called.
 * @param timeout -max milliseconds to wait for a response. Only values greater  than zero are valid. For values less or equals to zero the configured default timeout will be used. If the timeout expires, the method timeout() in command will be called.
 * @throws CommunicationException if any error/exception occurs. A CommnunicationException is also thrown if this communicator is not connected, e.g. run() was not called, or exceptions at creation time were ignored
 */
public void request(Message message,ICommand command,int timeout) throws CommunicationException {
  checkConnectionState(""String_Node_Str"");
  if (message == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
  if (command == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_NO_RECEIVING_COMMAND);
  }
  int timeoutToUse=m_requestTimeout;
  if (timeout <= 0) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    timeoutToUse=timeout;
  }
  MessageIdentifier messageIdentifier=new MessageIdentifier(m_connection.getNextSequenceNumber());
  try {
    message.setMessageId(messageIdentifier);
    String messageToSend=m_serializer.serialize(message);
    AwaitingCommand awaitingCommand=new AwaitingCommand(command,timeoutToUse);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.put(messageIdentifier,awaitingCommand);
    }
    m_connection.send(new MessageHeader(MessageHeader.REQUEST,message),messageToSend);
    awaitingCommand.start();
  }
 catch (  SerialisationException se) {
    log.error(se.getLocalizedMessage(),se);
    throw new CommunicationException(""String_Node_Str"" + se.getMessage(),MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
catch (  IOException ioe) {
    log.error(ioe.getLocalizedMessage(),ioe);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    throw new CommunicationException(""String_Node_Str"" + ioe.getMessage(),MessageIDs.E_MESSAGE_REQUEST);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae.getLocalizedMessage(),iae);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    log.debug(iae.getLocalizedMessage(),iae);
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
}","/** 
 * Send a message through this communicator and expect a response of type command. ICommand.request will be called at the other site. If a response was received the corresponding data will be set to the command object via setData(). If the response was received during the given timeout, command.response will be called. Otherwise command.timeout will be called. This method will not block.
 * @param message -the Message to send, must not be null otherwise an CommunicationException is thrown.
 * @param command -the expected command, must not be null or a CommunicationException is thrown. If the command arrives in good time, the method execute() of the given instance will be called. If the commands arrives to late timeout() will be called.
 * @param timeout -max milliseconds to wait for a response. Only values greater  than zero are valid. For values less or equals to zero the configured default timeout will be used. If the timeout expires, the method timeout() in command will be called.
 * @throws CommunicationException if any error/exception occurs. A CommnunicationException is also thrown if this communicator is not connected, e.g. run() was not called, or exceptions at creation time were ignored
 */
public void request(Message message,ICommand command,int timeout) throws CommunicationException {
  checkConnectionState(""String_Node_Str"");
  if (message == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
  if (command == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_NO_RECEIVING_COMMAND);
  }
  MessageIdentifier messageIdentifier=new MessageIdentifier(m_connection.getNextSequenceNumber());
  try {
    message.setMessageId(messageIdentifier);
    String messageToSend=m_serializer.serialize(message);
    AwaitingCommand awaitingCommand=new AwaitingCommand(command,DEFAULT_REQUEST_TIMEOUT * THOUSAND);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.put(messageIdentifier,awaitingCommand);
    }
    m_connection.send(new MessageHeader(MessageHeader.REQUEST,message),messageToSend);
    awaitingCommand.start();
  }
 catch (  SerialisationException se) {
    log.error(se.getLocalizedMessage(),se);
    throw new CommunicationException(""String_Node_Str"" + se.getMessage(),MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
catch (  IOException ioe) {
    log.error(ioe.getLocalizedMessage(),ioe);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    throw new CommunicationException(""String_Node_Str"" + ioe.getMessage(),MessageIDs.E_MESSAGE_REQUEST);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae.getLocalizedMessage(),iae);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    log.debug(iae.getLocalizedMessage(),iae);
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
}",0.8821926590799808
95853,"/** 
 * Removes the given errorHandler. 
 * @param errorHandler - the listener to remove, null oblects are ignored
 */
public void removeErrorHandler(IErrorHandler errorHandler){
  if (errorHandler != null) {
synchronized (m_errorHandlers) {
      m_errorHandlers.remove(errorHandler);
    }
  }
}","/** 
 * Removes the given errorHandler. 
 * @param errorHandler - the listener to remove, null objects are ignored
 */
public void removeErrorHandler(IErrorHandler errorHandler){
  if (errorHandler != null) {
synchronized (m_errorHandlers) {
      m_errorHandlers.remove(errorHandler);
    }
  }
}",0.9966329966329966
95854,"/** 
 * Adds elements to the given cmds List.
 * @param autServerClasspath the server classpath
 * @param cmds the 1st part of the cmd array
 * @param parameters The parameters for starting the AUT.
 */
protected void createAutServerClasspath(StringBuffer autServerClasspath,List cmds,Map parameters){
  final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
  if (autCommunicator != null) {
    cmds.add(String.valueOf(autCommunicator.getLocalPort()));
  }
 else {
    cmds.add(""String_Node_Str"");
  }
  String autMain=getAUTMainClass(parameters);
  if (autMain == null) {
    return;
  }
  cmds.add(autMain);
  autServerClasspath.append(PATH_SEPARATOR).append(getRcBundleClassPath());
  cmds.add(autServerClasspath.toString());
  cmds.add(getServerClassName());
}","/** 
 * Adds elements to the given cmds List.
 * @param autServerClasspath the server classpath
 * @param cmds the 1st part of the cmd array
 * @param parameters The parameters for starting the AUT.
 */
protected void createAutServerClasspath(StringBuffer autServerClasspath,List cmds,Map parameters){
  if (AutStarter.getInstance().getAutCommunicator() != null) {
    cmds.add(String.valueOf(AutStarter.getInstance().getAutCommunicator().getLocalPort()));
  }
 else {
    cmds.add(""String_Node_Str"");
  }
  String autMain=getAUTMainClass(parameters);
  if (autMain == null) {
    return;
  }
  cmds.add(autMain);
  autServerClasspath.append(PATH_SEPARATOR).append(getRcBundleClassPath());
  cmds.add(autServerClasspath.toString());
  cmds.add(getServerClassName());
}",0.9230769230769232
95855,"/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map parameters,String autServerClasspath){
  String env=(String)parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
    if (autCommunicator != null) {
      serverPort=String.valueOf(autCommunicator.getLocalPort());
    }
    env+=ENV_SEPARATOR + ""String_Node_Str"" + serverPort;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + autServerClasspath;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + getServerClassName();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}","/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map parameters,String autServerClasspath){
  String env=(String)parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    if (AutStarter.getInstance().getAutCommunicator() != null) {
      serverPort=String.valueOf(AutStarter.getInstance().getAutCommunicator().getLocalPort());
    }
    env+=ENV_SEPARATOR + ""String_Node_Str"" + serverPort;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + autServerClasspath;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + getServerClassName();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}",0.934010152284264
95856,"/** 
 * Stops the Running AUT with the given ID.
 * @param autId The ID of the Running AUT to stop.
 */
public void stopAUT(AutIdentifier autId){
  fireAndSetAutState(false);
  final ITestSuitePO startedTestSuite=TestExecution.getInstance().getStartedTestSuite();
  if (startedTestSuite != null && startedTestSuite.isStarted()) {
    stopTestSuiteAction();
  }
  getClientTest().stopAut(autId);
}","/** 
 * Stops the Running AUT with the given ID.
 * @param autId The ID of the Running AUT to stop.
 */
public void stopAUT(AutIdentifier autId){
  fireAndSetAutState(false);
  if (TestExecution.getInstance().getStartedTestSuite() != null && TestExecution.getInstance().getStartedTestSuite().isStarted()) {
    stopTestSuiteAction();
  }
  getClientTest().stopAut(autId);
}",0.8322496749024707
95857,"/** 
 * Send a message through this communicator and expect a response of type command. ICommand.request will be called at the other site. If a response was received the corresponding data will be set to the command object via setData(). If the response was received during the given timeout, command.response will be called. Otherwise command.timeout will be called. This method will not block.
 * @param message -the Message to send, must not be null otherwise an CommunicationException is thrown.
 * @param command -the expected command, must not be null or a CommunicationException is thrown. If the command arrives in good time, the method execute() of the given instance will be called. If the commands arrives to late timeout() will be called.
 * @param timeout -max milliseconds to wait for a response. Only values greater  than zero are valid. For values less or equals to zero the configured default timeout will be used. If the timeout expires, the method timeout() in command will be called.
 * @throws CommunicationException if any error/exception occurs. A CommnunicationException is also thrown if this communicator is not connected, e.g. run() was not called, or exceptions at creation time were ignored
 */
public void request(Message message,ICommand command,int timeout) throws CommunicationException {
  checkConnectionState(""String_Node_Str"");
  if (message == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
  if (command == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_NO_RECEIVING_COMMAND);
  }
  MessageIdentifier messageIdentifier=new MessageIdentifier(m_connection.getNextSequenceNumber());
  try {
    message.setMessageId(messageIdentifier);
    String messageToSend=m_serializer.serialize(message);
    AwaitingCommand awaitingCommand=new AwaitingCommand(command,DEFAULT_REQUEST_TIMEOUT * THOUSAND);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.put(messageIdentifier,awaitingCommand);
    }
    m_connection.send(new MessageHeader(MessageHeader.REQUEST,message),messageToSend);
    awaitingCommand.start();
  }
 catch (  SerialisationException se) {
    log.error(se.getLocalizedMessage(),se);
    throw new CommunicationException(""String_Node_Str"" + se.getMessage(),MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
catch (  IOException ioe) {
    log.error(ioe.getLocalizedMessage(),ioe);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    throw new CommunicationException(""String_Node_Str"" + ioe.getMessage(),MessageIDs.E_MESSAGE_REQUEST);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae.getLocalizedMessage(),iae);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    log.debug(iae.getLocalizedMessage(),iae);
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
}","/** 
 * Send a message through this communicator and expect a response of type command. ICommand.request will be called at the other site. If a response was received the corresponding data will be set to the command object via setData(). If the response was received during the given timeout, command.response will be called. Otherwise command.timeout will be called. This method will not block.
 * @param message -the Message to send, must not be null otherwise an CommunicationException is thrown.
 * @param command -the expected command, must not be null or a CommunicationException is thrown. If the command arrives in good time, the method execute() of the given instance will be called. If the commands arrives to late timeout() will be called.
 * @param timeout -max milliseconds to wait for a response. Only values greater  than zero are valid. For values less or equals to zero the configured default timeout will be used. If the timeout expires, the method timeout() in command will be called.
 * @throws CommunicationException if any error/exception occurs. A CommnunicationException is also thrown if this communicator is not connected, e.g. run() was not called, or exceptions at creation time were ignored
 */
public void request(Message message,ICommand command,int timeout) throws CommunicationException {
  checkConnectionState(""String_Node_Str"");
  if (message == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
  if (command == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_NO_RECEIVING_COMMAND);
  }
  int timeoutToUse=m_requestTimeout;
  if (timeout <= 0) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    timeoutToUse=timeout;
  }
  MessageIdentifier messageIdentifier=new MessageIdentifier(m_connection.getNextSequenceNumber());
  try {
    message.setMessageId(messageIdentifier);
    String messageToSend=m_serializer.serialize(message);
    AwaitingCommand awaitingCommand=new AwaitingCommand(command,timeoutToUse);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.put(messageIdentifier,awaitingCommand);
    }
    m_connection.send(new MessageHeader(MessageHeader.REQUEST,message),messageToSend);
    awaitingCommand.start();
  }
 catch (  SerialisationException se) {
    log.error(se.getLocalizedMessage(),se);
    throw new CommunicationException(""String_Node_Str"" + se.getMessage(),MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
catch (  IOException ioe) {
    log.error(ioe.getLocalizedMessage(),ioe);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    throw new CommunicationException(""String_Node_Str"" + ioe.getMessage(),MessageIDs.E_MESSAGE_REQUEST);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae.getLocalizedMessage(),iae);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    log.debug(iae.getLocalizedMessage(),iae);
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
}",0.9681038627985254
95858,"/** 
 * Removes the given errorHandler. 
 * @param errorHandler - the listener to remove, null objects are ignored
 */
public void removeErrorHandler(IErrorHandler errorHandler){
  if (errorHandler != null) {
synchronized (m_errorHandlers) {
      m_errorHandlers.remove(errorHandler);
    }
  }
}","/** 
 * Removes the given errorHandler. 
 * @param errorHandler - the listener to remove, null oblects are ignored
 */
public void removeErrorHandler(IErrorHandler errorHandler){
  if (errorHandler != null) {
synchronized (m_errorHandlers) {
      m_errorHandlers.remove(errorHandler);
    }
  }
}",0.9966329966329966
95859,"/** 
 * Adds elements to the given cmds List.
 * @param autServerClasspath the server classpath
 * @param cmds the 1st part of the cmd array
 * @param parameters The parameters for starting the AUT.
 */
protected void createAutServerClasspath(StringBuffer autServerClasspath,List cmds,Map parameters){
  if (AutStarter.getInstance().getAutCommunicator() != null) {
    cmds.add(String.valueOf(AutStarter.getInstance().getAutCommunicator().getLocalPort()));
  }
 else {
    cmds.add(""String_Node_Str"");
  }
  String autMain=getAUTMainClass(parameters);
  if (autMain == null) {
    return;
  }
  cmds.add(autMain);
  autServerClasspath.append(PATH_SEPARATOR).append(getRcBundleClassPath());
  cmds.add(autServerClasspath.toString());
  cmds.add(getServerClassName());
}","/** 
 * Adds elements to the given cmds List.
 * @param autServerClasspath the server classpath
 * @param cmds the 1st part of the cmd array
 * @param parameters The parameters for starting the AUT.
 */
protected void createAutServerClasspath(StringBuffer autServerClasspath,List cmds,Map parameters){
  final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
  if (autCommunicator != null) {
    cmds.add(String.valueOf(autCommunicator.getLocalPort()));
  }
 else {
    cmds.add(""String_Node_Str"");
  }
  String autMain=getAUTMainClass(parameters);
  if (autMain == null) {
    return;
  }
  cmds.add(autMain);
  autServerClasspath.append(PATH_SEPARATOR).append(getRcBundleClassPath());
  cmds.add(autServerClasspath.toString());
  cmds.add(getServerClassName());
}",0.9230769230769232
95860,"/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map parameters,String autServerClasspath){
  String env=(String)parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    if (AutStarter.getInstance().getAutCommunicator() != null) {
      serverPort=String.valueOf(AutStarter.getInstance().getAutCommunicator().getLocalPort());
    }
    env+=ENV_SEPARATOR + ""String_Node_Str"" + serverPort;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + autServerClasspath;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + getServerClassName();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}","/** 
 * Sets -javaagent, JRE arguments and the arguments for  the AutServer as environment variables.
 * @param parameters The parameters for starting the AUT
 * @param autServerClasspath The classpath of the AUT Server
 */
protected void setEnv(Map parameters,String autServerClasspath){
  String env=(String)parameters.get(AutConfigConstants.ENVIRONMENT);
  if (env == null) {
    env=StringConstants.EMPTY;
  }
 else {
    env+=ENV_SEPARATOR;
  }
  env+=setJavaOptions(parameters);
  if (isRunningFromExecutable(parameters)) {
    String serverPort=""String_Node_Str"";
    final Communicator autCommunicator=AutStarter.getInstance().getAutCommunicator();
    if (autCommunicator != null) {
      serverPort=String.valueOf(autCommunicator.getLocalPort());
    }
    env+=ENV_SEPARATOR + ""String_Node_Str"" + serverPort;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + autServerClasspath;
    env+=ENV_SEPARATOR + ""String_Node_Str"" + getServerClassName();
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_HOST + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_HOST);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_AGENT_PORT + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_AGENT_PORT);
    env+=ENV_SEPARATOR + AutConfigConstants.AUT_NAME + ""String_Node_Str""+ parameters.get(AutConfigConstants.AUT_NAME);
  }
  parameters.put(AutConfigConstants.ENVIRONMENT,env);
}",0.9557650471356056
95861,"/** 
 * Stops the Running AUT with the given ID.
 * @param autId The ID of the Running AUT to stop.
 */
public void stopAUT(AutIdentifier autId){
  fireAndSetAutState(false);
  if (TestExecution.getInstance().getStartedTestSuite() != null && TestExecution.getInstance().getStartedTestSuite().isStarted()) {
    stopTestSuiteAction();
  }
  getClientTest().stopAut(autId);
}","/** 
 * Stops the Running AUT with the given ID.
 * @param autId The ID of the Running AUT to stop.
 */
public void stopAUT(AutIdentifier autId){
  fireAndSetAutState(false);
  final ITestSuitePO startedTestSuite=TestExecution.getInstance().getStartedTestSuite();
  if (startedTestSuite != null && startedTestSuite.isStarted()) {
    stopTestSuiteAction();
  }
  getClientTest().stopAut(autId);
}",0.7438231469440832
95862,"/** 
 * Send a message through this communicator and expect a response of type command. ICommand.request will be called at the other site. If a response was received the corresponding data will be set to the command object via setData(). If the response was received during the given timeout, command.response will be called. Otherwise command.timeout will be called. This method will not block.
 * @param message -the Message to send, must not be null otherwise an CommunicationException is thrown.
 * @param command -the expected command, must not be null or a CommunicationException is thrown. If the command arrives in good time, the method execute() of the given instance will be called. If the commands arrives to late timeout() will be called.
 * @param timeout -max milliseconds to wait for a response. Only values greater  than zero are valid. For values less or equals to zero the configured default timeout will be used. If the timeout expires, the method timeout() in command will be called.
 * @throws CommunicationException if any error/exception occurs. A CommnunicationException is also thrown if this communicator is not connected, e.g. run() was not called, or exceptions at creation time were ignored
 */
public void request(Message message,ICommand command,int timeout) throws CommunicationException {
  checkConnectionState(""String_Node_Str"");
  if (message == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
  if (command == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_NO_RECEIVING_COMMAND);
  }
  int timeoutToUse=m_requestTimeout;
  if (timeout <= 0) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    timeoutToUse=timeout;
  }
  MessageIdentifier messageIdentifier=new MessageIdentifier(m_connection.getNextSequenceNumber());
  try {
    message.setMessageId(messageIdentifier);
    String messageToSend=m_serializer.serialize(message);
    AwaitingCommand awaitingCommand=new AwaitingCommand(command,timeoutToUse);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.put(messageIdentifier,awaitingCommand);
    }
    m_connection.send(new MessageHeader(MessageHeader.REQUEST,message),messageToSend);
    awaitingCommand.start();
  }
 catch (  SerialisationException se) {
    log.error(se.getLocalizedMessage(),se);
    throw new CommunicationException(""String_Node_Str"" + se.getMessage(),MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
catch (  IOException ioe) {
    log.error(ioe.getLocalizedMessage(),ioe);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    throw new CommunicationException(""String_Node_Str"" + ioe.getMessage(),MessageIDs.E_MESSAGE_REQUEST);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae.getLocalizedMessage(),iae);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    log.debug(iae.getLocalizedMessage(),iae);
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
}","/** 
 * Send a message through this communicator and expect a response of type command. ICommand.request will be called at the other site. If a response was received the corresponding data will be set to the command object via setData(). If the response was received during the given timeout, command.response will be called. Otherwise command.timeout will be called. This method will not block.
 * @param message -the Message to send, must not be null otherwise an CommunicationException is thrown.
 * @param command -the expected command, must not be null or a CommunicationException is thrown. If the command arrives in good time, the method execute() of the given instance will be called. If the commands arrives to late timeout() will be called.
 * @param timeout -max milliseconds to wait for a response. Only values greater  than zero are valid. For values less or equals to zero the configured default timeout will be used. If the timeout expires, the method timeout() in command will be called.
 * @throws CommunicationException if any error/exception occurs. A CommnunicationException is also thrown if this communicator is not connected, e.g. run() was not called, or exceptions at creation time were ignored
 */
public void request(Message message,ICommand command,int timeout) throws CommunicationException {
  checkConnectionState(""String_Node_Str"");
  if (message == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
  if (command == null) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_NO_RECEIVING_COMMAND);
  }
  int timeoutToUse=DEFAULT_REQUEST_TIMEOUT;
  if (timeout <= 0) {
    log.debug(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    timeoutToUse=timeout;
  }
  MessageIdentifier messageIdentifier=new MessageIdentifier(m_connection.getNextSequenceNumber());
  try {
    message.setMessageId(messageIdentifier);
    String messageToSend=m_serializer.serialize(message);
    AwaitingCommand awaitingCommand=new AwaitingCommand(command,timeoutToUse);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.put(messageIdentifier,awaitingCommand);
    }
    m_connection.send(new MessageHeader(MessageHeader.REQUEST,message),messageToSend);
    awaitingCommand.start();
  }
 catch (  SerialisationException se) {
    log.error(se.getLocalizedMessage(),se);
    throw new CommunicationException(""String_Node_Str"" + se.getMessage(),MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
catch (  IOException ioe) {
    log.error(ioe.getLocalizedMessage(),ioe);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    throw new CommunicationException(""String_Node_Str"" + ioe.getMessage(),MessageIDs.E_MESSAGE_REQUEST);
  }
catch (  IllegalArgumentException iae) {
    log.error(iae.getLocalizedMessage(),iae);
synchronized (m_awaitingCommands) {
      m_awaitingCommands.remove(messageIdentifier);
    }
    log.debug(iae.getLocalizedMessage(),iae);
    throw new CommunicationException(""String_Node_Str"",MessageIDs.E_MESSAGE_NOT_TO_REQUEST);
  }
}",0.9941997178241104
95863,"/** 
 * Removes the given errorHandler. 
 * @param errorHandler - the listener to remove, null oblects are ignored
 */
public void removeErrorHandler(IErrorHandler errorHandler){
  if (errorHandler != null) {
synchronized (m_errorHandlers) {
      m_errorHandlers.remove(errorHandler);
    }
  }
}","/** 
 * Removes the given errorHandler. 
 * @param errorHandler - the listener to remove, null objects are ignored
 */
public void removeErrorHandler(IErrorHandler errorHandler){
  if (errorHandler != null) {
synchronized (m_errorHandlers) {
      m_errorHandlers.remove(errorHandler);
    }
  }
}",0.9966329966329966
95864,"/** 
 * create the necessary environment
 * @param autAgent The AUT Agent monitored by the created object.
 */
public DesktopIntegration(final AutAgent autAgent){
  m_isSystraySupported=SystemTray.isSupported();
  if (m_isSystraySupported) {
    SystemTray tray=SystemTray.getSystemTray();
    URL imageURL;
    if (EnvironmentUtils.isMacOS()) {
      imageURL=this.getClass().getClassLoader().getResource(""String_Node_Str"");
    }
 else {
      imageURL=this.getClass().getClassLoader().getResource(""String_Node_Str"");
    }
    Image image=Toolkit.getDefaultToolkit().getImage(imageURL);
    ActionListener exitListener=new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        System.exit(0);
      }
    }
;
    PopupMenu popup=new PopupMenu();
    final CheckboxMenuItem strictModeItem=new CheckboxMenuItem(""String_Node_Str"");
    autAgent.addPropertyChangeListener(AutAgent.PROP_KILL_DUPLICATE_AUTS,new PropertyChangeListener(){
      @SuppressWarnings(""String_Node_Str"") public void propertyChange(      PropertyChangeEvent evt){
        Object newValue=evt.getNewValue();
        if (newValue instanceof Boolean) {
          boolean isKillDuplicateAuts=((Boolean)newValue).booleanValue();
          strictModeItem.setState(isKillDuplicateAuts);
        }
 else {
          LOG.error(""String_Node_Str"" + Boolean.class.getName());
        }
      }
    }
);
    boolean isKillDuplicateAuts=autAgent.isKillDuplicateAuts();
    strictModeItem.setState(isKillDuplicateAuts);
    strictModeItem.addItemListener(new ItemListener(){
      public void itemStateChanged(      ItemEvent e){
        autAgent.setKillDuplicateAuts(e.getStateChange() == ItemEvent.SELECTED);
      }
    }
);
    MenuItem defaultItem=new MenuItem(""String_Node_Str"");
    defaultItem.addActionListener(exitListener);
    popup.add(strictModeItem);
    popup.addSeparator();
    popup.add(defaultItem);
    m_trayIcon=new TrayIcon(image,""String_Node_Str"",popup);
    m_trayIcon.setImageAutoSize(true);
    try {
      tray.add(m_trayIcon);
    }
 catch (    AWTException e) {
      m_isSystraySupported=false;
    }
  }
}","/** 
 * create the necessary environment
 * @param autAgent The AUT Agent monitored by the created object.
 */
public DesktopIntegration(final AutAgent autAgent){
  m_isSystraySupported=SystemTray.isSupported();
  if (m_isSystraySupported) {
    SystemTray tray=SystemTray.getSystemTray();
    URL imageURL;
    final ClassLoader classLoader=this.getClass().getClassLoader();
    if (EnvironmentUtils.isMacOS()) {
      imageURL=classLoader.getResource(""String_Node_Str"");
    }
 else {
      imageURL=classLoader.getResource(""String_Node_Str"");
    }
    Image image=Toolkit.getDefaultToolkit().getImage(imageURL);
    ActionListener exitListener=new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        System.exit(0);
      }
    }
;
    PopupMenu popup=new PopupMenu();
    final CheckboxMenuItem strictModeItem=new CheckboxMenuItem(""String_Node_Str"");
    autAgent.addPropertyChangeListener(AutAgent.PROP_KILL_DUPLICATE_AUTS,new PropertyChangeListener(){
      @SuppressWarnings(""String_Node_Str"") public void propertyChange(      PropertyChangeEvent evt){
        Object newValue=evt.getNewValue();
        if (newValue instanceof Boolean) {
          boolean isKillDuplicateAuts=((Boolean)newValue).booleanValue();
          strictModeItem.setState(isKillDuplicateAuts);
        }
 else {
          LOG.error(""String_Node_Str"" + Boolean.class.getName());
        }
      }
    }
);
    boolean isKillDuplicateAuts=autAgent.isKillDuplicateAuts();
    strictModeItem.setState(isKillDuplicateAuts);
    strictModeItem.addItemListener(new ItemListener(){
      public void itemStateChanged(      ItemEvent e){
        autAgent.setKillDuplicateAuts(e.getStateChange() == ItemEvent.SELECTED);
      }
    }
);
    MenuItem defaultItem=new MenuItem(""String_Node_Str"");
    defaultItem.addActionListener(exitListener);
    popup.add(strictModeItem);
    popup.addSeparator();
    popup.add(defaultItem);
    m_trayIcon=new TrayIcon(image,""String_Node_Str"",popup);
    m_trayIcon.setImageAutoSize(true);
    try {
      tray.add(m_trayIcon);
    }
 catch (    AWTException e) {
      m_isSystraySupported=false;
    }
  }
}",0.9639681796911558
95865,"/** 
 * constructor Jframe
 */
public ChooseCheckModeDialog(){
  super();
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  createPart();
}","/** 
 * constructor Jframe
 */
public ChooseCheckModeDialog(){
  super();
  createPart();
}",0.3364140480591497
95866,"/** 
 * constructor Jframe
 */
public ObservationConsole(){
  super();
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  UnsupportedLookAndFeelException e) {
    e.printStackTrace();
  }
  createPart();
}","/** 
 * constructor Jframe
 */
public ObservationConsole(){
  super();
  createPart();
}",0.3289719626168224
95867,"/** 
 * Overides Object.equals() Compares this TestDataPO object to the given object to equality.
 * @param obj the object to compare.
 * @return true or false{@inheritDoc}
 */
public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj instanceof TestDataPO) {
    TestDataPO otherTestData=(TestDataPO)obj;
    return getMap().equals(otherTestData.getMap());
  }
  return false;
}","/** 
 * Overrides Object.equals() Compares this TestDataPO object to the given object to equality.
 * @param obj the object to compare.
 * @return true or false{@inheritDoc}
 */
public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj instanceof TestDataPO) {
    TestDataPO otherTestData=(TestDataPO)obj;
    return getMap().equals(otherTestData.getMap());
  }
  return false;
}",0.9987760097919216
95868,"/** 
 * because of Persistence (JPA / EclipseLink)-Bug HHH-1280 we can't use refresh<br> therefore we use evict to remove the old object from master session and reload the object<br> please attend, that in this case the Java-IDs of the old and the reloaded object are different<br> refreshs the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(original);
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}","/** 
 * Refreshes the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(masterSession.merge(getWorkVersion()));
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}",0.8084862385321101
95869,"/** 
 * @param repoLabel repoLabel
 * @param taskId the taskId
 * @param comments the comment entries
 * @param monitor the monitor to use
 * @return true if succeeded; false otherwise
 */
public static boolean createComment(String repoLabel,String taskId,List<CommentEntry> comments,IProgressMonitor monitor){
  boolean succeeded=false;
  TaskRepository repo=getRepositoryByLabel(repoLabel);
  try {
    TaskData taskData=getTaskDataByID(repo,taskId,monitor);
    if (taskData == null) {
      return succeeded;
    }
    ITask task=getTaskByID(repo,taskId,monitor);
    if (task != null) {
      ITaskDataManager taskDataManager=TasksUi.getTaskDataManager();
      ITaskDataWorkingCopy taskWorkingCopy=taskDataManager.createWorkingCopy(task,taskData);
      TaskDataModel taskModel=new TaskDataModel(repo,task,taskWorkingCopy);
      String connectorKind=repo.getConnectorKind();
      AbstractRepositoryConnector connector=TasksUi.getRepositoryConnector(connectorKind);
      AbstractTaskDataHandler taskDataHandler=connector.getTaskDataHandler();
      TaskAttribute rootData=taskModel.getTaskData().getRoot();
      CONNECTOR handle=determineConnectorHandling(connectorKind);
      TaskAttribute change=null;
switch (handle) {
case HP_ALM:
        change=hpAlmHandling(comments,rootData);
      break;
case DEFAULT:
default :
    change=defaultHandling(comments,rootData);
  break;
}
if (change == null) {
return succeeded;
}
taskModel.attributeChanged(change);
RepositoryResponse response=taskDataHandler.postTaskData(taskModel.getTaskRepository(),taskModel.getTaskData(),taskModel.getChangedOldAttributes(),monitor);
succeeded=RepositoryResponse.ResponseKind.TASK_UPDATED.equals(response.getReposonseKind());
}
}
 catch (CoreException e) {
LOG.error(e.getLocalizedMessage(),e);
}
return succeeded;
}","/** 
 * @param repoLabel repoLabel
 * @param taskId the taskId
 * @param comments the comment entries
 * @param monitor the monitor to use
 * @return true if succeeded; false otherwise
 */
public static boolean createComment(String repoLabel,String taskId,List<CommentEntry> comments,IProgressMonitor monitor){
  boolean succeeded=false;
  TaskRepository repo=getRepositoryByLabel(repoLabel);
  try {
    TaskData taskData=getTaskDataByID(repo,taskId,monitor);
    if (taskData == null) {
      return succeeded;
    }
    ITask task=getTaskByID(repo,taskData.getTaskId(),monitor);
    if (task != null) {
      ITaskDataManager taskDataManager=TasksUi.getTaskDataManager();
      ITaskDataWorkingCopy taskWorkingCopy=taskDataManager.createWorkingCopy(task,taskData);
      TaskDataModel taskModel=new TaskDataModel(repo,task,taskWorkingCopy);
      String connectorKind=repo.getConnectorKind();
      AbstractRepositoryConnector connector=TasksUi.getRepositoryConnector(connectorKind);
      AbstractTaskDataHandler taskDataHandler=connector.getTaskDataHandler();
      TaskAttribute rootData=taskModel.getTaskData().getRoot();
      CONNECTOR handle=determineConnectorHandling(connectorKind);
      TaskAttribute change=null;
switch (handle) {
case HP_ALM:
        change=hpAlmHandling(comments,rootData);
      break;
case DEFAULT:
default :
    change=defaultHandling(comments,rootData);
  break;
}
if (change == null) {
return succeeded;
}
taskModel.attributeChanged(change);
RepositoryResponse response=taskDataHandler.postTaskData(taskModel.getTaskRepository(),taskModel.getTaskData(),taskModel.getChangedOldAttributes(),monitor);
succeeded=RepositoryResponse.ResponseKind.TASK_UPDATED.equals(response.getReposonseKind());
}
}
 catch (CoreException e) {
LOG.error(e.getLocalizedMessage(),e);
}
return succeeded;
}",0.996138996138996
95870,"/** 
 * {@inheritDoc} 
 */
public boolean operate(ITreeTraverserContext<TestResultNode> ctx,TestResultNode parent,TestResultNode resultNode,boolean alreadyVisited){
  m_nodeCount++;
  boolean didNodePass=CommentEntry.hasPassed(resultNode.getStatus());
  INodePO node=resultNode.getNode();
  String taskIdforNode=NodePropertyTester.getTaskIdforNode(node);
  boolean hasTaskId=taskIdforNode != null;
  boolean writeCommentForNode=hasTaskId && (m_reportSuccess && didNodePass) || (m_reportFailure && !didNodePass);
  if (writeCommentForNode) {
    CommentEntry c=new CommentEntry(resultNode,m_dashboardURL,m_summaryIdString,m_nodeCount);
    List<CommentEntry> comments=m_taskIdToComment.get(taskIdforNode);
    if (comments != null) {
      comments.add(c);
    }
 else {
      List<CommentEntry> cs=new LinkedList<CommentEntry>();
      cs.add(c);
      m_taskIdToComment.put(taskIdforNode,cs);
    }
  }
  return true;
}","/** 
 * {@inheritDoc} 
 */
public boolean operate(ITreeTraverserContext<TestResultNode> ctx,TestResultNode parent,TestResultNode resultNode,boolean alreadyVisited){
  m_nodeCount++;
  boolean didNodePass=CommentEntry.hasPassed(resultNode.getStatus());
  INodePO node=resultNode.getNode();
  String taskIdforNode=NodePropertyTester.getTaskIdforNode(node);
  boolean hasTaskId=taskIdforNode != null;
  boolean writeCommentForNode=hasTaskId && ((m_reportSuccess && didNodePass) || (m_reportFailure && !didNodePass));
  if (writeCommentForNode) {
    CommentEntry c=new CommentEntry(resultNode,m_dashboardURL,m_summaryIdString,m_nodeCount);
    List<CommentEntry> comments=m_taskIdToComment.get(taskIdforNode);
    if (comments != null) {
      comments.add(c);
    }
 else {
      List<CommentEntry> cs=new LinkedList<CommentEntry>();
      cs.add(c);
      m_taskIdToComment.put(taskIdforNode,cs);
    }
  }
  return true;
}",0.998914223669924
95871,"/** 
 * @param commentEntries the commentEntries to add
 * @param attr the attribute to modify
 * @return a flag indicating the success of attribute handling
 */
private static TaskAttribute hpAlmHandling(List<CommentEntry> commentEntries,TaskAttribute attr){
  Properties almProps=Activator.getDefault().getAlmAccessProperties();
  String hpTaskKindKeyPrefix=CONNECTOR.HP_ALM.toString() + StringConstants.DOT + TaskAttribute.TASK_KIND;
  String req=hpTaskKindKeyPrefix + ""String_Node_Str"";
  String hpTaskKindReq=almProps.getProperty(req);
  String def=hpTaskKindKeyPrefix + ""String_Node_Str"";
  String hpTaskKindDefect=almProps.getProperty(def);
  String taskKindValue=attr.getMappedAttribute(TaskAttribute.TASK_KIND).getValue();
  String attrName=null;
  if (hpTaskKindReq.equals(taskKindValue)) {
    attrName=almProps.getProperty(req + ""String_Node_Str"");
  }
 else   if (hpTaskKindDefect.equals(taskKindValue)) {
    attrName=almProps.getProperty(def + ""String_Node_Str"");
  }
  if (attrName != null) {
    TaskAttribute commentAttribute=attr.getMappedAttribute(attrName);
    String oldComment=commentAttribute.getValue();
    String newComment=StringConstants.EMPTY;
    for (    CommentEntry c : commentEntries) {
      newComment=newComment + ""String_Node_Str"" + c.getDashboardURL()+ ""String_Node_Str""+ c.toString()+ ""String_Node_Str"";
    }
    commentAttribute.setValue(oldComment + newComment);
    return commentAttribute;
  }
  return null;
}","/** 
 * @param commentEntries the commentEntries to add
 * @param attr the attribute to modify
 * @return a flag indicating the success of attribute handling
 */
private static TaskAttribute hpAlmHandling(List<CommentEntry> commentEntries,TaskAttribute attr){
  Properties almProps=Activator.getDefault().getAlmAccessProperties();
  String hpTaskKindKeyPrefix=CONNECTOR.HP_ALM.toString() + StringConstants.DOT + TaskAttribute.TASK_KIND;
  String req=hpTaskKindKeyPrefix + ""String_Node_Str"";
  String hpTaskKindReq=almProps.getProperty(req);
  String def=hpTaskKindKeyPrefix + ""String_Node_Str"";
  String hpTaskKindDefect=almProps.getProperty(def);
  String taskKindValue=attr.getMappedAttribute(TaskAttribute.TASK_KIND).getValue();
  String attrName=null;
  if (hpTaskKindReq.equals(taskKindValue)) {
    attrName=almProps.getProperty(req + ""String_Node_Str"");
  }
 else   if (hpTaskKindDefect.equals(taskKindValue)) {
    attrName=almProps.getProperty(def + ""String_Node_Str"");
  }
  if (attrName != null) {
    TaskAttribute commentAttribute=attr.getMappedAttribute(attrName);
    String oldComment=commentAttribute.getValue();
    String newComment=StringConstants.EMPTY;
    for (    CommentEntry c : commentEntries) {
      newComment=newComment + ""String_Node_Str"" + c.toString()+ ""String_Node_Str""+ c.getDashboardURL();
    }
    commentAttribute.setValue(oldComment + newComment);
    return commentAttribute;
  }
  return null;
}",0.9706390328151986
95872,"/** 
 * Constructor
 * @param resultNode the node
 * @param dashboardURL the URL
 * @param summaryId the id
 * @param nodeCount the node count
 */
public CommentEntry(TestResultNode resultNode,String dashboardURL,String summaryId,Long nodeCount){
  m_dashboardURL=dashboardURL;
  m_summaryId=summaryId;
  m_nodeCount=nodeCount;
  Date executionTime=resultNode.getTimeStamp();
  if (executionTime != null) {
    m_timestamp=executionTime.toString();
  }
 else {
    m_timestamp=Messages.NotAvailable;
  }
  m_nodeType=resultNode.getTypeOfNode();
  m_nodeNameAndParams=getName(resultNode) + StringConstants.SPACE + StringUtils.abbreviate(resultNode.getParameterDescription(),MAX_DATA_STRING_LENGTH);
  if (hasPassed(resultNode.getStatus())) {
    m_status=Messages.StatusPassed;
  }
 else {
    m_status=Messages.StatusFailed;
  }
}","/** 
 * Constructor
 * @param resultNode the node
 * @param dashboardURL the URL
 * @param summaryId the id
 * @param nodeCount the node count
 */
public CommentEntry(TestResultNode resultNode,String dashboardURL,String summaryId,Long nodeCount){
  m_dashboardURL=dashboardURL;
  m_summaryId=summaryId;
  m_nodeCount=nodeCount;
  Date executionTime=resultNode.getTimeStamp();
  if (executionTime != null) {
    m_timestamp=executionTime.toString();
  }
 else {
    m_timestamp=Messages.NotAvailable;
  }
  m_nodeType=resultNode.getTypeOfNode();
  String paramDescription=StringUtils.abbreviate(resultNode.getParameterDescription(),MAX_DATA_STRING_LENGTH);
  m_nodeNameAndParams=getName(resultNode);
  if (!StringUtils.isBlank(paramDescription)) {
    m_nodeNameAndParams+=StringConstants.SPACE + paramDescription;
  }
  if (hasPassed(resultNode.getStatus())) {
    m_status=Messages.StatusPassed;
  }
 else {
    m_status=Messages.StatusFailed;
  }
}",0.7314606741573034
95873,"/** 
 * {@inheritDoc} 
 */
public void handleTestresultSummaryChanged(final ITestResultSummaryPO summary,DataState state){
  if (state != DataState.Added) {
    return;
  }
  IProjectPO project=GeneralStorage.getInstance().getProject();
  m_projProps=project.getProjectProperties();
  final boolean reportSuccess=m_projProps.getIsReportOnSuccess();
  final boolean reportFailure=m_projProps.getIsReportOnFailure();
  final String almRepositoryName=m_projProps.getALMRepositoryName();
  if (!StringUtils.isBlank(almRepositoryName) && (reportSuccess || reportFailure)) {
    Job reportToALMOperation=new Job(NLS.bind(Messages.ReportToALMJob,almRepositoryName)){
      protected IStatus run(      IProgressMonitor monitor){
        getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTest,almRepositoryName));
        IStatus connectionStatus=ALMAccess.testConnection(almRepositoryName);
        if (connectionStatus.isOK()) {
          getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTestSucceeded,almRepositoryName));
          return processResultTree(monitor,reportSuccess,reportFailure,summary);
        }
        getConsole().writeErrorLine(NLS.bind(Messages.TaskRepositoryConnectionTestFailed,connectionStatus.getMessage()));
        return connectionStatus;
      }
    }
;
    reportToALMOperation.schedule();
  }
}","/** 
 * {@inheritDoc} 
 */
public void handleTestresultSummaryChanged(final ITestResultSummaryPO summary,DataState state){
  if (state != DataState.Added) {
    return;
  }
  IProjectPO project=GeneralStorage.getInstance().getProject();
  m_projProps=project.getProjectProperties();
  final boolean reportSuccess=m_projProps.getIsReportOnSuccess();
  final boolean reportFailure=m_projProps.getIsReportOnFailure();
  final String almRepositoryName=m_projProps.getALMRepositoryName();
  if (!StringUtils.isBlank(almRepositoryName) && (reportSuccess || reportFailure)) {
    Job reportToALMOperation=new Job(NLS.bind(Messages.ReportToALMJobName,almRepositoryName)){
      protected IStatus run(      IProgressMonitor monitor){
        getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTest,almRepositoryName));
        IStatus connectionStatus=ALMAccess.testConnection(almRepositoryName);
        if (connectionStatus.isOK()) {
          getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTestSucceeded,almRepositoryName));
          return processResultTree(monitor,reportSuccess,reportFailure,summary);
        }
        getConsole().writeErrorLine(NLS.bind(Messages.TaskRepositoryConnectionTestFailed,connectionStatus.getMessage()));
        return connectionStatus;
      }
    }
;
    reportToALMOperation.schedule();
  }
}",0.9985218033998522
95874,"/** 
 * method to find all classes in a given jar
 * @param resource The url to the jar file
 * @param pkgname The package name for classes found inside the base directory
 * @return The classes
 */
private static List findClassesInJar(URL resource,String pkgname){
  String relPath=pkgname.replace('.','/');
  String path=resource.getPath().replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
  List classes=new ArrayList();
  try {
    JarFile jarFile=new JarFile(path);
    Enumeration entries=jarFile.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=(JarEntry)entries.nextElement();
      String entryName=entry.getName();
      String className=null;
      if (entryName.endsWith(""String_Node_Str"") && entryName.startsWith(relPath)) {
        className=entryName.replace('/','.').replace('\\','.').replaceAll(""String_Node_Str"",""String_Node_Str"");
        if (className != null) {
          try {
            classes.add(Class.forName(className));
          }
 catch (          ClassNotFoundException cnfe) {
            log.error(cnfe.getLocalizedMessage(),cnfe);
          }
        }
      }
    }
  }
 catch (  IOException ioe) {
    log.warn(ioe.getLocalizedMessage(),ioe);
  }
  return classes;
}","/** 
 * method to find all classes in a given jar
 * @param resource The url to the jar file
 * @param pkgname The package name for classes found inside the base directory
 * @return The classes
 */
private static List findClassesInJar(URL resource,String pkgname){
  String relPath=pkgname.replace('.','/');
  String path=resource.getPath().replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
  try {
    path=URLDecoder.decode(path,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException uee) {
    log.error(uee.getLocalizedMessage(),uee);
  }
  List classes=new ArrayList();
  try {
    JarFile jarFile=new JarFile(path);
    Enumeration entries=jarFile.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=(JarEntry)entries.nextElement();
      String entryName=entry.getName();
      String className=null;
      if (entryName.endsWith(""String_Node_Str"") && entryName.startsWith(relPath)) {
        className=entryName.replace('/','.').replace('\\','.').replaceAll(""String_Node_Str"",""String_Node_Str"");
        if (className != null) {
          try {
            classes.add(Class.forName(className));
          }
 catch (          ClassNotFoundException cnfe) {
            log.error(cnfe.getLocalizedMessage(),cnfe);
          }
        }
      }
    }
  }
 catch (  IOException ioe) {
    log.warn(ioe.getLocalizedMessage(),ioe);
  }
  return classes;
}",0.9410898379970544
95875,"/** 
 * delete a project
 * @param proj project to delete
 * @param isActProject flag to label the actual project
 * @throws PMAlreadyLockedException if project is already locked in db
 * @throws PMDirtyVersionException if project to delete is modified in the meantime
 * @throws JBException if a session cannot closed
 * @throws PMExtProjDeletedException if a project (but not the current) was deleted by another user
 * @throws ProjectDeletedException if the current project was deleted by another user
 * @throws InterruptedException if the operation was canceled
 */
public static void deleteProject(IProjectPO proj,boolean isActProject) throws PMDirtyVersionException, PMAlreadyLockedException, PMExtProjDeletedException, ProjectDeletedException, JBException, InterruptedException {
  Validate.notNull(proj,""String_Node_Str"");
  EntityManager deleteSess=null;
  IProjectPO p=null;
  final Long projId=proj.getId();
  try {
    if (isActProject) {
      EntityManager s=GeneralStorage.getInstance().getMasterSession();
      IProjectPO currProj=s.find(NodeMaker.getProjectPOClass(),projId,LockModeType.READ);
      if (currProj == null) {
        throw new ProjectDeletedException(Messages.ProjectWasDeleted,MessageIDs.E_CURRENT_PROJ_DEL);
      }
    }
  }
 catch (  PersistenceException e) {
    handleDBExceptionForMasterSession(proj,e);
  }
  try {
    deleteSess=Persistor.instance().openSession();
    EntityTransaction tx=Persistor.instance().getTransaction(deleteSess);
    p=deleteSess.find(NodeMaker.getProjectPOClass(),projId);
    if (p == null) {
      if (isActProject) {
        throw new ProjectDeletedException(""String_Node_Str"",MessageIDs.E_CURRENT_PROJ_DEL);
      }
      throw new PMExtProjDeletedException(Messages.ProjectWasDeleted + StringConstants.DOT,MessageIDs.E_DELETED_OBJECT);
    }
    Persistor.instance().lockPO(deleteSess,p);
    deleteProjectIndependentDBObjects(deleteSess,p);
    List<ISpecPersistable> specObjList=new ArrayList<ISpecPersistable>(p.getSpecObjCont().getSpecObjList());
    List<IExecPersistable> execObjList=new ArrayList<IExecPersistable>(p.getExecObjCont().getExecObjList());
    for (    ISpecPersistable po : specObjList) {
      PersistenceUtil.removeChildNodes(po,deleteSess);
      p.getSpecObjCont().removeSpecObject(po);
      Persistor.instance().deletePO(deleteSess,po);
    }
    for (    IExecPersistable po : execObjList) {
      PersistenceUtil.removeChildNodes(po,deleteSess);
      p.getExecObjCont().removeExecObject(po);
      Persistor.instance().deletePO(deleteSess,po);
    }
    deleteSess.flush();
    Persistor.instance().deletePO(deleteSess,p);
    CompNamePM.deleteCompNames(deleteSess,projId);
    Persistor.instance().commitTransaction(deleteSess,tx);
    tx=null;
  }
 catch (  PersistenceException e) {
    handleDBExceptionForAnySession(p,e,deleteSess);
  }
 finally {
    Persistor.instance().dropSession(deleteSess);
  }
  ProjectNameBP.getInstance().checkAndDeleteName(proj.getGuid());
}","/** 
 * delete a project
 * @param proj project to delete
 * @param isActProject flag to label the actual project
 * @throws PMAlreadyLockedException if project is already locked in db
 * @throws PMDirtyVersionException if project to delete is modified in the meantime
 * @throws JBException if a session cannot closed
 * @throws PMExtProjDeletedException if a project (but not the current) was deleted by another user
 * @throws ProjectDeletedException if the current project was deleted by another user
 * @throws InterruptedException if the operation was canceled
 */
public static void deleteProject(IProjectPO proj,boolean isActProject) throws PMDirtyVersionException, PMAlreadyLockedException, PMExtProjDeletedException, ProjectDeletedException, JBException, InterruptedException {
  Validate.notNull(proj,""String_Node_Str"");
  EntityManager deleteSess=null;
  IProjectPO p=null;
  final Long projId=proj.getId();
  try {
    if (isActProject) {
      EntityManager s=GeneralStorage.getInstance().getMasterSession();
      IProjectPO currProj=s.find(NodeMaker.getProjectPOClass(),projId);
      if (currProj == null) {
        throw new ProjectDeletedException(Messages.ProjectWasDeleted,MessageIDs.E_CURRENT_PROJ_DEL);
      }
    }
  }
 catch (  PersistenceException e) {
    handleDBExceptionForMasterSession(proj,e);
  }
  try {
    deleteSess=Persistor.instance().openSession();
    EntityTransaction tx=Persistor.instance().getTransaction(deleteSess);
    p=deleteSess.find(NodeMaker.getProjectPOClass(),projId);
    if (p == null) {
      if (isActProject) {
        throw new ProjectDeletedException(""String_Node_Str"",MessageIDs.E_CURRENT_PROJ_DEL);
      }
      throw new PMExtProjDeletedException(Messages.ProjectWasDeleted + StringConstants.DOT,MessageIDs.E_DELETED_OBJECT);
    }
    Persistor.instance().lockPO(deleteSess,p);
    deleteProjectIndependentDBObjects(deleteSess,p);
    List<ISpecPersistable> specObjList=new ArrayList<ISpecPersistable>(p.getSpecObjCont().getSpecObjList());
    List<IExecPersistable> execObjList=new ArrayList<IExecPersistable>(p.getExecObjCont().getExecObjList());
    for (    ISpecPersistable po : specObjList) {
      PersistenceUtil.removeChildNodes(po,deleteSess);
      p.getSpecObjCont().removeSpecObject(po);
      Persistor.instance().deletePO(deleteSess,po);
    }
    for (    IExecPersistable po : execObjList) {
      PersistenceUtil.removeChildNodes(po,deleteSess);
      p.getExecObjCont().removeExecObject(po);
      Persistor.instance().deletePO(deleteSess,po);
    }
    deleteSess.flush();
    Persistor.instance().deletePO(deleteSess,p);
    CompNamePM.deleteCompNames(deleteSess,projId);
    Persistor.instance().commitTransaction(deleteSess,tx);
    tx=null;
  }
 catch (  PersistenceException e) {
    handleDBExceptionForAnySession(p,e,deleteSess);
  }
 finally {
    Persistor.instance().dropSession(deleteSess);
  }
  ProjectNameBP.getInstance().checkAndDeleteName(proj.getGuid());
}",0.996969696969697
95876,"/** 
 * @param monitor the monitor to use
 * @param taskIdToComment the comment mapping
 * @return status
 */
private IStatus reportToALM(IProgressMonitor monitor,Map<String,List<CommentEntry>> taskIdToComment){
  String repoLabel=m_projProps.getALMRepositoryName();
  Set<String> taskIds=taskIdToComment.keySet();
  int taskAmount=taskIds.size();
  String out=NLS.bind(Messages.ReportToALMJob,repoLabel);
  monitor.beginTask(out,taskAmount);
  IProgressConsole c=getConsole();
  c.writeLine(out);
  for (  String taskId : taskIds) {
    c.writeLine(NLS.bind(Messages.ReportingTask,taskId));
    boolean succeeded=ALMAccess.createComment(repoLabel,taskId,taskIdToComment.get(taskId),monitor);
    if (!succeeded) {
      c.writeErrorLine(NLS.bind(Messages.ReportingTaskFailed,taskId));
    }
    monitor.worked(1);
  }
  c.writeLine(Messages.ReportToALMJobDone);
  monitor.done();
  return Status.OK_STATUS;
}","/** 
 * @param monitor the monitor to use
 * @param taskIdToComment the comment mapping
 * @return status
 */
private IStatus reportToALM(IProgressMonitor monitor,Map<String,List<CommentEntry>> taskIdToComment){
  String repoLabel=m_projProps.getALMRepositoryName();
  Set<String> taskIds=taskIdToComment.keySet();
  int taskAmount=taskIds.size();
  IProgressConsole c=getConsole();
  if (taskAmount > 0) {
    String out=NLS.bind(Messages.ReportToALMJob,taskAmount,repoLabel);
    monitor.beginTask(out,taskAmount);
    c.writeLine(out);
    int successCount=0;
    int overallCommentCount=0;
    for (    String taskId : taskIds) {
      List<CommentEntry> comments=taskIdToComment.get(taskId);
      int commentAmount=comments.size();
      if (commentAmount > 1) {
        c.writeLine(NLS.bind(Messages.ReportingResults,commentAmount,taskId));
      }
 else {
        c.writeLine(NLS.bind(Messages.ReportingResult,taskId));
      }
      boolean succeeded=ALMAccess.createComment(repoLabel,taskId,comments,monitor);
      if (!succeeded) {
        c.writeErrorLine(NLS.bind(Messages.ReportingTaskFailed,taskId));
      }
 else {
        successCount++;
        overallCommentCount+=commentAmount;
      }
      monitor.worked(1);
    }
    c.writeLine(NLS.bind(Messages.ReportToALMJobDone,new Integer[]{overallCommentCount,successCount,taskAmount}));
    monitor.done();
  }
 else {
    c.writeLine(Messages.NothingToReport);
  }
  return Status.OK_STATUS;
}",0.4934626739772248
95877,"/** 
 * Write the information from the Object to its corresponding XML element.
 * @param xml The XML element to be filled
 * @param po The persistent object which contains the information
 */
private void fillRefTestCase(RefTestCase xml,IExecTestCasePO po){
  fillNode(xml,po);
  checkForCancel();
  String execName=po.getRealName();
  if (execName == null) {
    execName=StringConstants.EMPTY;
  }
  if (po.getSpecTestCase() != null) {
    String specName=po.getSpecTestCase().getName();
    if (execName.equals(specName)) {
      xml.setName(null);
    }
 else {
      xml.setName(execName);
    }
  }
 else {
    xml.setName(execName);
  }
  xml.setTestcaseGuid(po.getSpecTestCaseGuid());
  if (po.getProjectGuid() != null) {
    xml.setProjectGuid(po.getProjectGuid());
  }
  xml.setHasOwnTestdata(!po.getHasReferencedTD());
  xml.setDatafile(po.getDataFile());
  if (po.getReferencedDataCube() != null) {
    xml.setReferencedTestData(po.getReferencedDataCube().getName());
  }
  if (!po.getHasReferencedTD()) {
    final ITDManager dataManager=po.getDataManager();
    if (dataManager != null) {
      TestData xmlTD=xml.addNewTestdata();
      if (po.getReferencedDataCube() == null) {
        fillTestData(xmlTD,dataManager);
      }
    }
  }
  for (  ICompNamesPairPO name : po.getCompNamesPairs()) {
    CompNames xmlNames=xml.addNewOverriddenNames();
    xmlNames.setOriginalName(name.getFirstName());
    xmlNames.setNewName(name.getSecondName());
    xmlNames.setPropagated(name.isPropagated());
    xmlNames.setType((name.getType() == null) ? StringConstants.EMPTY : name.getType());
  }
}","/** 
 * Write the information from the Object to its corresponding XML element.
 * @param xml The XML element to be filled
 * @param po The persistent object which contains the information
 */
private void fillRefTestCase(RefTestCase xml,IExecTestCasePO po){
  fillNode(xml,po);
  checkForCancel();
  String execName=po.getRealName();
  if (execName == null) {
    execName=StringConstants.EMPTY;
  }
  if (po.getSpecTestCase() != null) {
    String specName=po.getSpecTestCase().getName();
    if (execName.equals(specName)) {
      xml.setName(null);
    }
 else {
      xml.setName(execName);
    }
  }
 else {
    xml.setName(execName);
  }
  xml.setTestcaseGuid(po.getSpecTestCaseGuid());
  if (po.getProjectGuid() != null) {
    xml.setProjectGuid(po.getProjectGuid());
  }
  xml.setHasOwnTestdata(!po.getHasReferencedTD());
  xml.setDatafile(po.getDataFile());
  if (po.getReferencedDataCube() != null) {
    xml.setReferencedTestData(po.getReferencedDataCube().getName());
  }
  if (!po.getHasReferencedTD()) {
    final ITDManager dataManager=po.getDataManager();
    if (dataManager != null) {
      TestData xmlTD=xml.addNewTestdata();
      if (po.getReferencedDataCube() == null) {
        fillTestData(xmlTD,dataManager);
      }
    }
  }
  for (  ICompNamesPairPO name : po.getCompNamesPairs()) {
    CompNames xmlNames=xml.addNewOverriddenNames();
    xmlNames.setOriginalName(name.getFirstName());
    xmlNames.setNewName(name.getSecondName());
    xmlNames.setPropagated(name.isPropagated());
  }
}",0.9715017611271214
95878,"/** 
 * Shared method for setting values into ExecTCs and their subclasses.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param xml Abstraction of the XML element (see Apache XML Beans)
 * @param exec TC to be initialized
 * @param assignNewGuid <code>true</code> if nodes are being assignednew GUIDs. Otherwise <code>false</code>.
 */
private void fillExecTestCase(IProjectPO proj,RefTestCase xml,IExecTestCasePO exec,boolean assignNewGuid){
  exec.setName(xml.getName());
  exec.setComment(xml.getComment());
  exec.setGenerated(xml.getGenerated());
  exec.setTaskId(xml.getTaskId());
  if (xml.isSetActive()) {
    exec.setActive(xml.getActive());
  }
 else {
    exec.setActive(true);
  }
  exec.setDataFile(xml.getDatafile());
  if (xml.getReferencedTestData() != null) {
    String referencedDataName=xml.getReferencedTestData();
    for (    IParameterInterfacePO testDataCube : TestDataCubeBP.getAllTestDataCubesFor(proj)) {
      if (referencedDataName.equals(testDataCube.getName())) {
        exec.setReferencedDataCube(testDataCube);
        break;
      }
    }
  }
  if (xml.getHasOwnTestdata()) {
    exec.setDataManager(createTDManager(exec,xml.getTestdata(),assignNewGuid));
  }
  for (  CompNames overriddenXml : xml.getOverriddenNamesList()) {
    final ICompNamesPairPO compName=PoMaker.createCompNamesPairPO(overriddenXml.getOriginalName(),overriddenXml.getNewName(),overriddenXml.getType());
    compName.setPropagated(overriddenXml.getPropagated());
    exec.addCompNamesPair(compName);
  }
  m_monitor.worked(1);
}","/** 
 * Shared method for setting values into ExecTCs and their subclasses.
 * @param proj The IProjectPO which is currently build. The instance isneeded by some objects to verify that their data confirms to project specification (for instance languages).
 * @param xml Abstraction of the XML element (see Apache XML Beans)
 * @param exec TC to be initialized
 * @param assignNewGuid <code>true</code> if nodes are being assignednew GUIDs. Otherwise <code>false</code>.
 */
private void fillExecTestCase(IProjectPO proj,RefTestCase xml,IExecTestCasePO exec,boolean assignNewGuid){
  exec.setName(xml.getName());
  exec.setComment(xml.getComment());
  exec.setGenerated(xml.getGenerated());
  exec.setTaskId(xml.getTaskId());
  if (xml.isSetActive()) {
    exec.setActive(xml.getActive());
  }
 else {
    exec.setActive(true);
  }
  exec.setDataFile(xml.getDatafile());
  if (xml.getReferencedTestData() != null) {
    String referencedDataName=xml.getReferencedTestData();
    for (    IParameterInterfacePO testDataCube : TestDataCubeBP.getAllTestDataCubesFor(proj)) {
      if (referencedDataName.equals(testDataCube.getName())) {
        exec.setReferencedDataCube(testDataCube);
        break;
      }
    }
  }
  if (xml.getHasOwnTestdata()) {
    exec.setDataManager(createTDManager(exec,xml.getTestdata(),assignNewGuid));
  }
  for (  CompNames overriddenXml : xml.getOverriddenNamesList()) {
    final ICompNamesPairPO compName=PoMaker.createCompNamesPairPO(overriddenXml.getOriginalName(),overriddenXml.getNewName(),null);
    compName.setPropagated(overriddenXml.getPropagated());
    exec.addCompNamesPair(compName);
  }
  m_monitor.worked(1);
}",0.9372937293729372
95879,"/** 
 * @param type the current type to setFIXME Clemens: make private, when persisting in DB
 */
public abstract void setType(String type);","/** 
 * @param type the current type to set
 */
public abstract void setType(String type);",0.782608695652174
95880,"/** 
 * {@inheritDoc}
 */
public boolean isTrue(AWTEvent event){
  if (event.getID() == WindowEvent.WINDOW_LOST_FOCUS) {
    String name=null;
    if (event.getSource() instanceof Frame) {
      Frame frame=(Frame)event.getSource();
      name=frame.getTitle();
    }
 else     if (event.getSource() instanceof Dialog) {
      Dialog dialog=(Dialog)event.getSource();
      name=dialog.getTitle();
    }
 else {
      return false;
    }
    return MatchUtil.getInstance().match(name,m_title,m_operator);
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
public boolean isTrue(AWTEvent event){
  if (event.getID() == WindowEvent.WINDOW_LOST_FOCUS) {
    if (event.getSource() instanceof Window) {
      Window window=(Window)event.getSource();
      if (!window.isVisible()) {
        String name=null;
        if (window instanceof Frame) {
          Frame frame=(Frame)window;
          name=frame.getTitle();
        }
 else         if (window instanceof Dialog) {
          Dialog dialog=(Dialog)window;
          name=dialog.getTitle();
        }
 else {
          return false;
        }
        return MatchUtil.getInstance().match(name,m_title,m_operator);
      }
    }
  }
  return false;
}",0.6265664160401002
95881,"/** 
 * {@inheritDoc}
 */
public void addTrackedChange(String optionalComment){
  final boolean isTrackingChanges=GeneralStorage.getInstance().getProject().getIsTrackingActivated();
  if (isTrackingChanges) {
    final long timestamp=new Date().getTime();
    int maxTrackedChangesPerNode=30;
    final long maxDurationOfTrackedChangesInMS=1000L * 60 * 60* 24* 80;
    if (maxTrackedChangesPerNode >= 0) {
      while (m_trackedChangesMap.size() >= maxTrackedChangesPerNode) {
        int removeCount=m_trackedChangesMap.size() - maxTrackedChangesPerNode;
        while (removeCount > 0) {
          m_trackedChangesMap.remove(getTrackedChanges().firstKey());
        }
      }
    }
    if (maxDurationOfTrackedChangesInMS >= 0) {
      SortedMap<Long,String> changes=getTrackedChanges();
      while (changes.size() > 0 && timestamp - changes.firstKey() > maxDurationOfTrackedChangesInMS) {
        m_trackedChangesMap.remove(changes.firstKey());
      }
    }
    String systemPropertyName=GeneralStorage.getInstance().getProject().getProjectProperties().getTrackChangesSignature();
    StringBuffer comment=new StringBuffer(System.getProperty(systemPropertyName,""String_Node_Str""));
    if (optionalComment != null) {
      comment.append(""String_Node_Str"");
      comment.append(optionalComment);
    }
    m_trackedChangesMap.put(timestamp,comment.toString());
  }
}","/** 
 * {@inheritDoc}
 */
public void addTrackedChange(String optionalComment){
  final IProjectPO project=GeneralStorage.getInstance().getProject();
  boolean isTrackingChanges=false;
  if (project != null) {
    isTrackingChanges=project.getIsTrackingActivated();
  }
  if (isTrackingChanges) {
    final long timestamp=new Date().getTime();
    int maxTrackedChangesPerNode=30;
    final long maxDurationOfTrackedChangesInMS=1000L * 60 * 60* 24* 80;
    if (maxTrackedChangesPerNode >= 0) {
      while (m_trackedChangesMap.size() >= maxTrackedChangesPerNode) {
        int removeCount=m_trackedChangesMap.size() - maxTrackedChangesPerNode;
        while (removeCount > 0) {
          m_trackedChangesMap.remove(getTrackedChanges().firstKey());
        }
      }
    }
    if (maxDurationOfTrackedChangesInMS >= 0) {
      SortedMap<Long,String> changes=getTrackedChanges();
      while (changes.size() > 0 && timestamp - changes.firstKey() > maxDurationOfTrackedChangesInMS) {
        m_trackedChangesMap.remove(changes.firstKey());
      }
    }
    String systemPropertyName=GeneralStorage.getInstance().getProject().getProjectProperties().getTrackChangesSignature();
    StringBuffer comment=new StringBuffer(System.getProperty(systemPropertyName,""String_Node_Str""));
    if (optionalComment != null) {
      comment.append(""String_Node_Str"");
      comment.append(optionalComment);
    }
    m_trackedChangesMap.put(timestamp,comment.toString());
  }
}",0.951271186440678
95882,"/** 
 * @throws WorkbenchException {@inheritDoc}
 */
public void postWindowRestore() throws WorkbenchException {
  super.postWindowRestore();
  Plugin.showStatusLine((IWorkbenchPart)null);
}","/** 
 * {@inheritDoc}
 */
public void postWindowRestore() throws WorkbenchException {
  super.postWindowRestore();
  Plugin.showStatusLine((IWorkbenchPart)null);
}",0.923512747875354
95883,"/** 
 * add a permanent listener to update the main window title
 */
protected void addMainWindowTitleUpdater(){
  ApplicationWindowTitleUpdater updater=new ApplicationWindowTitleUpdater();
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addProjectLoadedListener(updater,true);
  ded.addDataChangedListener(updater,true);
  DatabaseStateDispatcher.addDatabaseStateListener(updater);
}","/** 
 * add a permanent listener to update the main window title
 */
protected void addMainWindowTitleUpdater(){
  m_updater=new ApplicationWindowTitleUpdater();
  DataEventDispatcher ded=DataEventDispatcher.getInstance();
  ded.addProjectLoadedListener(m_updater,true);
  ded.addDataChangedListener(m_updater,true);
  DatabaseStateDispatcher.addDatabaseStateListener(m_updater);
}",0.951530612244898
95884,"/** 
 * @param repoLabel the repository to test the connection for
 * @return a status reflecting the current connection state
 */
public static IStatus testConnection(String repoLabel){
  TaskRepository repository=getRepositoryByLabel(repoLabel);
  if (repository == null) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryNotFound,repoLabel));
  }
  if (repository.isOffline()) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryOffline,repoLabel));
  }
  boolean savePassword=repository.getSavePassword(AuthenticationType.REPOSITORY);
  if (!savePassword) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryNoCredentialsStored,repoLabel));
  }
  AbstractRepositoryConnector connector=TasksUi.getRepositoryConnector(repository.getConnectorKind());
  if (connector == null) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryNoCredentialsStored,repoLabel));
  }
  try {
    connector.updateRepositoryConfiguration(repository,new NullProgressMonitor());
  }
 catch (  CoreException e) {
    return new Status(IStatus.ERROR,Activator.ID,e.getLocalizedMessage());
  }
  IStatus repoStatus=repository.getStatus();
  if (repoStatus != null) {
    return repoStatus;
  }
  return Status.OK_STATUS;
}","/** 
 * @param repoLabel the repository to test the connection for
 * @return a status reflecting the current connection state
 */
public static IStatus testConnection(String repoLabel){
  TaskRepository repository=getRepositoryByLabel(repoLabel);
  if (repository == null) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryNotFound,repoLabel));
  }
  if (repository.isOffline()) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryOffline,repoLabel));
  }
  boolean savePassword=repository.getSavePassword(AuthenticationType.REPOSITORY);
  if (!savePassword) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryNoCredentialsStored,repoLabel));
  }
  AbstractRepositoryConnector connector=TasksUi.getRepositoryConnector(repository.getConnectorKind());
  if (connector == null) {
    return new Status(IStatus.ERROR,Activator.ID,NLS.bind(Messages.TaskRepositoryNoCredentialsStored,repoLabel));
  }
  try {
    connector.updateRepositoryConfiguration(repository,new NullProgressMonitor());
  }
 catch (  CoreException e) {
    return new Status(IStatus.ERROR,Activator.ID,e.getLocalizedMessage().replace(""String_Node_Str"",""String_Node_Str""));
  }
  IStatus repoStatus=repository.getStatus();
  if (repoStatus != null) {
    return repoStatus;
  }
  return Status.OK_STATUS;
}",0.9832775919732442
95885,"/** 
 * For Persistence (JPA / EclipseLink) only Sets the value of the taskId property.
 * @param taskId the new value of the taskId property
 */
public void setTaskId(String taskId){
  m_taskId=taskId;
}","/** 
 * For Persistence (JPA / EclipseLink) only Sets the value of the taskId property. If the length of the trimmed new taskId string is zero, the taskId property is set to null.
 * @param taskId the new value of the taskId property
 */
public void setTaskId(String taskId){
  String newTaskId=taskId;
  if (newTaskId != null) {
    newTaskId=newTaskId.trim();
    if (newTaskId.length() == 0) {
      newTaskId=null;
    }
  }
  m_taskId=newTaskId;
}",0.6189024390243902
95886,"protected IStatus run(IProgressMonitor monitor){
  getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTest,almRepositoryName));
  IStatus connectionStatus=ALMAccess.testConnection(almRepositoryName);
  if (connectionStatus.isOK()) {
    getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTestSucceeded,almRepositoryName));
    return processResultTree(monitor,reportSuccess,reportFailure);
  }
  getConsole().writeErrorLine(NLS.bind(Messages.TaskRepositoryConnectionTestFailed,connectionStatus.getMessage()));
  return connectionStatus;
}","protected IStatus run(IProgressMonitor monitor){
  getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTest,almRepositoryName));
  IStatus connectionStatus=ALMAccess.testConnection(almRepositoryName);
  if (connectionStatus.isOK()) {
    getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTestSucceeded,almRepositoryName));
    return processResultTree(monitor,reportSuccess,reportFailure,summary);
  }
  getConsole().writeErrorLine(NLS.bind(Messages.TaskRepositoryConnectionTestFailed,connectionStatus.getMessage()));
  return connectionStatus;
}",0.9929824561403509
95887,"/** 
 * process the result tree
 * @param reportFailure reportFailure
 * @param reportSuccess reportSuccess
 * @param monitor monitor
 * @return status
 */
private IStatus processResultTree(IProgressMonitor monitor,boolean reportSuccess,boolean reportFailure){
  Map<String,String> taskIdToComment=new HashMap<String,String>();
  TestResult resultTestModel=TestResultBP.getInstance().getResultTestModel();
  TestResultNode rootResultNode=resultTestModel.getRootResultNode();
  ITreeNodeOperation<TestResultNode> operation=new ReportOperation(taskIdToComment,reportFailure,reportSuccess,m_projProps.getDashboardURL(),m_summary.getId().toString());
  TestResultNodeTraverser traverser=new TestResultNodeTraverser(rootResultNode,operation);
  traverser.traverse();
  return reportToALM(monitor,taskIdToComment);
}","/** 
 * process the result tree
 * @param reportFailure reportFailure
 * @param reportSuccess reportSuccess
 * @param monitor monitor
 * @param summary the summary the result tree belongs to
 * @return status
 */
private IStatus processResultTree(IProgressMonitor monitor,boolean reportSuccess,boolean reportFailure,ITestResultSummaryPO summary){
  Map<String,String> taskIdToComment=new HashMap<String,String>();
  TestResult resultTestModel=TestResultBP.getInstance().getResultTestModel();
  TestResultNode rootResultNode=resultTestModel.getRootResultNode();
  ITreeNodeOperation<TestResultNode> operation=new ReportOperation(taskIdToComment,reportFailure,reportSuccess,m_projProps.getDashboardURL(),summary.getId().toString());
  TestResultNodeTraverser traverser=new TestResultNodeTraverser(rootResultNode,operation);
  traverser.traverse();
  return reportToALM(monitor,taskIdToComment);
}",0.9483568075117372
95888,"/** 
 * {@inheritDoc} 
 */
public void handleTestresultSummaryChanged(ITestResultSummaryPO summary,DataState state){
  if (state != DataState.Added) {
    return;
  }
  IProjectPO project=GeneralStorage.getInstance().getProject();
  m_projProps=project.getProjectProperties();
  final boolean reportSuccess=m_projProps.getIsReportOnSuccess();
  final boolean reportFailure=m_projProps.getIsReportOnFailure();
  final String almRepositoryName=m_projProps.getALMRepositoryName();
  if (!StringUtils.isBlank(almRepositoryName) && (reportSuccess || reportFailure)) {
    Job reportToALMOperation=new Job(NLS.bind(Messages.ReportToALMJob,almRepositoryName)){
      protected IStatus run(      IProgressMonitor monitor){
        getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTest,almRepositoryName));
        IStatus connectionStatus=ALMAccess.testConnection(almRepositoryName);
        if (connectionStatus.isOK()) {
          getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTestSucceeded,almRepositoryName));
          return processResultTree(monitor,reportSuccess,reportFailure);
        }
        getConsole().writeErrorLine(NLS.bind(Messages.TaskRepositoryConnectionTestFailed,connectionStatus.getMessage()));
        return connectionStatus;
      }
    }
;
    reportToALMOperation.schedule();
  }
}","/** 
 * {@inheritDoc} 
 */
public void handleTestresultSummaryChanged(final ITestResultSummaryPO summary,DataState state){
  if (state != DataState.Added) {
    return;
  }
  IProjectPO project=GeneralStorage.getInstance().getProject();
  m_projProps=project.getProjectProperties();
  final boolean reportSuccess=m_projProps.getIsReportOnSuccess();
  final boolean reportFailure=m_projProps.getIsReportOnFailure();
  final String almRepositoryName=m_projProps.getALMRepositoryName();
  if (!StringUtils.isBlank(almRepositoryName) && (reportSuccess || reportFailure)) {
    Job reportToALMOperation=new Job(NLS.bind(Messages.ReportToALMJob,almRepositoryName)){
      protected IStatus run(      IProgressMonitor monitor){
        getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTest,almRepositoryName));
        IStatus connectionStatus=ALMAccess.testConnection(almRepositoryName);
        if (connectionStatus.isOK()) {
          getConsole().writeLine(NLS.bind(Messages.TaskRepositoryConnectionTestSucceeded,almRepositoryName));
          return processResultTree(monitor,reportSuccess,reportFailure,summary);
        }
        getConsole().writeErrorLine(NLS.bind(Messages.TaskRepositoryConnectionTestFailed,connectionStatus.getMessage()));
        return connectionStatus;
      }
    }
;
    reportToALMOperation.schedule();
  }
}",0.9947916666666666
95889,"/** 
 * Adds a new CAP to the given workVersion SpecTestCase at the given position and, if successful, sets the given editor dirty.
 * @param specTcGUI the GUI SpecTestCase for the NewCapDialog
 * @param workTC the workversion of the SpecTestCase
 * @param position the position to add
 * @param tse the editor.
 */
private void addCap(ISpecTestCasePO specTcGUI,ISpecTestCasePO workTC,Integer position,AbstractTestCaseEditor tse){
  final NewCAPDialog dialog=new NewCAPDialog(getActiveShell(),specTcGUI,tse.getEditorHelper().getEditSupport().getCompMapper());
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  dialog.open();
  if (dialog.getReturnCode() != Window.OK) {
    return;
  }
  final String componentType=dialog.getComponentType();
  final String capName=dialog.getCapName();
  final String action=dialog.getActionName();
  final String componentName=dialog.getComponentName();
  final ICapPO cap=CapBP.createCapWithDefaultParams(capName,componentName,componentType,action);
  final IWritableComponentNameMapper compMapper=tse.getEditorHelper().getEditSupport().getCompMapper();
  CompSystem compSystem=ComponentBuilder.getInstance().getCompSystem();
  Component comp=compSystem.findComponent(componentType);
  try {
    cap.setComponentName(null);
    if (comp instanceof ConcreteComponent && !((ConcreteComponent)comp).hasDefaultMapping()) {
      ComponentNamesBP.getInstance().setCompName(cap,componentName,CompNameCreationContext.STEP,compMapper);
    }
    workTC.addNode(position,cap);
    tse.getEditorHelper().setDirty(true);
    DataEventDispatcher.getInstance().fireDataChangedListener(cap,DataState.Added,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException e) {
    ErrorHandlingUtil.createMessageDialog(e,e.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,tse);
  }
}","/** 
 * Adds a new CAP to the given workVersion SpecTestCase at the given position and, if successful, sets the given editor dirty.
 * @param specTcGUI the GUI SpecTestCase for the NewCapDialog
 * @param workTC the workversion of the SpecTestCase
 * @param position the position to add
 * @param tse the editor.
 */
private void addCap(ISpecTestCasePO specTcGUI,ISpecTestCasePO workTC,Integer position,AbstractTestCaseEditor tse){
  final NewCAPDialog dialog=new NewCAPDialog(getActiveShell(),specTcGUI,tse.getEditorHelper().getEditSupport().getCompMapper());
  dialog.create();
  DialogUtils.setWidgetNameForModalDialog(dialog);
  dialog.open();
  if (dialog.getReturnCode() != Window.OK) {
    return;
  }
  final String componentType=dialog.getComponentType();
  final String capName=dialog.getCapName();
  final String action=dialog.getActionName();
  final String componentName=dialog.getComponentName();
  final ICapPO cap=CapBP.createCapWithDefaultParams(capName,componentName,componentType,action);
  final IWritableComponentNameMapper compMapper=tse.getEditorHelper().getEditSupport().getCompMapper();
  CompSystem compSystem=ComponentBuilder.getInstance().getCompSystem();
  Component comp=compSystem.findComponent(componentType);
  try {
    cap.setComponentName(null);
    boolean hasDefaultMapping=false;
    if (comp.isConcrete()) {
      hasDefaultMapping=((ConcreteComponent)comp).hasDefaultMapping();
    }
    if (!hasDefaultMapping) {
      ComponentNamesBP.getInstance().setCompName(cap,componentName,CompNameCreationContext.STEP,compMapper);
    }
    workTC.addNode(position,cap);
    tse.getEditorHelper().setDirty(true);
    DataEventDispatcher.getInstance().fireDataChangedListener(cap,DataState.Added,UpdateState.onlyInEditor);
  }
 catch (  IncompatibleTypeException e) {
    ErrorHandlingUtil.createMessageDialog(e,e.getErrorMessageParams(),null);
  }
catch (  PMException pme) {
    PMExceptionHandler.handlePMExceptionForEditor(pme,tse);
  }
}",0.9441571871768356
95890,"/** 
 * Creates the m_text field to enter the password.
 * @param area The composite. 
 */
private void createPasswordTextField(Composite area){
  new Label(area,SWT.NONE).setLayoutData(new GridData(GridData.FILL,GridData.CENTER,false,false,HORIZONTAL_SPAN + 1,1));
  m_pwdLabel=new Label(area,SWT.NONE);
  m_pwdLabel.setText(Messages.DBLoginDialogPwdLabel);
  m_pwdLabel.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  m_pwdText=new Text(area,SWT.PASSWORD | SWT.BORDER);
  m_pwdText.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  GridData gridData=newGridData();
  LayoutUtil.addToolTipAndMaxWidth(gridData,m_pwdText);
  m_pwdText.setLayoutData(gridData);
  LayoutUtil.setMaxChar(m_pwdText);
  if (!StringUtils.isEmpty(m_userText.getText())) {
    m_pwdText.setFocus();
  }
  m_pwdText.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      if (modifyPasswordFieldAction()) {
        modifyUsernameFieldAction();
      }
    }
  }
);
}","/** 
 * Creates the m_text field to enter the password.
 * @param area The composite. 
 */
private void createPasswordTextField(Composite area){
  new Label(area,SWT.NONE).setLayoutData(new GridData(GridData.FILL,GridData.CENTER,false,false,HORIZONTAL_SPAN + 1,1));
  m_pwdLabel=new Label(area,SWT.NONE);
  m_pwdLabel.setText(Messages.DBLoginDialogPwdLabel);
  m_pwdLabel.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  m_pwdText=new Text(area,SWT.PASSWORD | SWT.BORDER);
  m_pwdText.setData(SwtAUTHierarchyConstants.WIDGET_NAME,""String_Node_Str"");
  GridData gridData=newGridData();
  m_pwdText.setLayoutData(gridData);
  LayoutUtil.setMaxChar(m_pwdText);
  if (!StringUtils.isEmpty(m_userText.getText())) {
    m_pwdText.setFocus();
  }
  m_pwdText.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      if (modifyPasswordFieldAction()) {
        modifyUsernameFieldAction();
      }
    }
  }
);
}",0.9715736040609138
95891,"/** 
 * {@inheritDoc}
 */
public TestErrorEvent execute() throws JBException {
  IParamDescriptionPO desc=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
  try {
    ITDManager tdManager=m_externalTestDataBP.getExternalCheckedTDManager(m_currentCap);
    ITestDataPO date=tdManager.getCell(0,desc);
    String runLocal=this.getValueForParam(date,m_currentCap,desc);
    if (Boolean.valueOf(runLocal)) {
      desc=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
      date=tdManager.getCell(0,desc);
      String cmd=this.getValueForParam(date,m_currentCap,desc);
      desc=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
      date=tdManager.getCell(0,desc);
      int timeout=Integer.parseInt(this.getValueForParam(date,m_currentCap,desc));
      desc=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
      date=tdManager.getCell(0,desc);
      int expectedExitCode=Integer.parseInt(this.getValueForParam(date,m_currentCap,desc));
      File dataDir=ExternalTestDataBP.getDataDir();
      MonitorTask mt=new ExternalCommandExecutor().executeCommand(dataDir,cmd,timeout);
      if (!mt.wasCmdValid()) {
        return EventFactory.createActionError(TestErrorEvent.NO_SUCH_COMMAND);
      }
      if (mt.hasTimeoutOccurred()) {
        return EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT);
      }
      int actualExitValue=mt.getExitCode();
      if (actualExitValue != expectedExitCode) {
        return EventFactory.createVerifyFailed(String.valueOf(expectedExitCode),String.valueOf(actualExitValue));
      }
    }
  }
 catch (  IllegalArgumentException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
catch (  InvalidDataException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public TestErrorEvent execute() throws JBException {
  IParamDescriptionPO desc=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
  try {
    ITDManager tdManager=m_externalTestDataBP.getExternalCheckedTDManager(m_currentCap);
    ITestDataPO date=tdManager.getCell(0,desc);
    String runLocal=this.getValueForParam(date,m_currentCap,desc);
    if (Boolean.valueOf(runLocal)) {
      desc=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
      date=tdManager.getCell(0,desc);
      String cmd=this.getValueForParam(date,m_currentCap,desc);
      desc=m_currentCap.getParameterForUniqueId(COMP_SYSTEM_TIMEOUT);
      date=tdManager.getCell(0,desc);
      int timeout=Integer.parseInt(this.getValueForParam(date,m_currentCap,desc));
      desc=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
      date=tdManager.getCell(0,desc);
      int expectedExitCode=Integer.parseInt(this.getValueForParam(date,m_currentCap,desc));
      File dataDir=ExternalTestDataBP.getDataDir();
      MonitorTask mt=new ExternalCommandExecutor().executeCommand(dataDir,cmd,timeout);
      if (!mt.wasCmdValid()) {
        return EventFactory.createActionError(TestErrorEvent.NO_SUCH_COMMAND);
      }
      if (mt.hasTimeoutOccurred()) {
        return EventFactory.createActionError(TestErrorEvent.CONFIRMATION_TIMEOUT);
      }
      int actualExitValue=mt.getExitCode();
      if (actualExitValue != expectedExitCode) {
        return EventFactory.createVerifyFailed(String.valueOf(expectedExitCode),String.valueOf(actualExitValue));
      }
    }
  }
 catch (  IllegalArgumentException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
catch (  InvalidDataException e) {
    throw new JBException(""String_Node_Str"",e,MessageIDs.E_STEP_EXEC);
  }
  return null;
}",0.991223258365332
95892,"/** 
 * Calculates the request timeout. Important if an action has a higher timeout than the standard request timeout.
 * @param messageCap the MessageCap
 * @return the calculated timeout.
 */
private int calculateRequestTimeout(MessageCap messageCap){
  List<Integer> timeOuts=new ArrayList<Integer>();
  IParamDescriptionPO desc1=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  desc1=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  int timeout=0;
  for (  int index : timeOuts) {
    if (index > -1) {
      final MessageParam param=(MessageParam)messageCap.getMessageParams().get(index);
      final String paramTimeOut=param.getValue();
      timeout+=Integer.parseInt(paramTimeOut);
    }
  }
  boolean isShowText=messageCap.getMethod().equals(""String_Node_Str"");
  if (isShowText) {
    int showTextTimeout=calculateShowTextTimeout(messageCap);
    if (showTextTimeout != -1) {
      timeout+=showTextTimeout;
    }
  }
  return m_requestTimeout + timeout;
}","/** 
 * Calculates the request timeout. Important if an action has a higher timeout than the standard request timeout.
 * @param messageCap the MessageCap
 * @return the calculated timeout.
 */
private int calculateRequestTimeout(MessageCap messageCap){
  List<Integer> timeOuts=new ArrayList<Integer>();
  IParamDescriptionPO desc1=m_currentCap.getParameterForUniqueId(COMP_SYSTEM_TIMEOUT);
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  desc1=m_currentCap.getParameterForUniqueId(""String_Node_Str"");
  timeOuts.add(m_currentCap.getParameterList().indexOf(desc1));
  int timeout=0;
  for (  int index : timeOuts) {
    if (index > -1) {
      final MessageParam param=(MessageParam)messageCap.getMessageParams().get(index);
      final String paramTimeOut=param.getValue();
      timeout+=Integer.parseInt(paramTimeOut);
    }
  }
  boolean isShowText=messageCap.getMethod().equals(""String_Node_Str"");
  if (isShowText) {
    int showTextTimeout=calculateShowTextTimeout(messageCap);
    if (showTextTimeout != -1) {
      timeout+=showTextTimeout;
    }
  }
  return m_requestTimeout + timeout;
}",0.985663082437276
95893,"/** 
 * Processes the post execution of an action
 * @param msg the CAPTestResponseMessage.
 */
private void processPostExecution(CAPTestResponseMessage msg){
  m_varStore.store(LAST_ACTION_RETURN,msg.getReturnValue());
  final String cmdClassName=msg.getMessageCap().getPostExecutionCommand();
  if (cmdClassName != null && cmdClassName.length() > 0 && !m_currentCap.getMetaAction().isClientAction()) {
    TestErrorEvent errorEvent=executePostExecCommand(cmdClassName);
    if (msg.getTestErrorEvent() == null && errorEvent != null) {
      msg.setTestErrorEvent(errorEvent);
    }
  }
}","/** 
 * Processes the post execution of an action
 * @param msg the CAPTestResponseMessage.
 */
private void processPostExecution(CAPTestResponseMessage msg){
  m_varStore.store(LAST_ACTION_RETURN,msg.getReturnValue());
  final String cmdClassName=msg.getMessageCap().getPostExecutionCommand();
  if (cmdClassName != null && cmdClassName.length() > 0 && !m_currentCap.getMetaAction().isClientAction()) {
    TestErrorEvent errorEvent=executePostExecCommand(m_postExecCmdFactory.createCommand(cmdClassName));
    if (msg.getTestErrorEvent() == null && errorEvent != null) {
      msg.setTestErrorEvent(errorEvent);
    }
  }
}",0.970345963756178
95894,"/** 
 * Fires an event if test fails
 * @param e JBException
 */
private void fireError(Exception e){
  ClientTestFactory.getClientTest().fireTestExecutionChanged(new TestExecutionEvent(TestExecutionEvent.TEST_EXEC_FAILED,e));
  endTestExecution();
}","/** 
 * Fires an event if test fails
 * @param e Exception
 */
private void fireError(Exception e){
  ClientTestFactory.getClientTest().fireTestExecutionChanged(new TestExecutionEvent(TestExecutionEvent.TEST_EXEC_FAILED,e));
  endTestExecution();
}",0.9959839357429718
95895,"/** 
 * Handles the client-actions
 * @param cap the cap to execute
 * @param capTestMessage the CAPTestMessage.
 * @return a response if the result of testing the CAP is determined entirely by the client. Returns <code>null</code> if the CAP message should be sent to the server.
 */
private CAPTestResponseMessage clientExecutionHandling(ICapPO cap,CAPTestMessage capTestMessage){
  Action action=cap.getMetaAction();
  if (!action.isClientAction()) {
    return null;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(Messages.ExecutingClientAction + StringConstants.COLON + StringConstants.SPACE+ action.getPostExecutionCommand());
  }
  final String postExecCommandClass=action.getPostExecutionCommand();
  final IPostExecutionCommand command=m_postExecCmdFactory.createCommand(postExecCommandClass);
  try {
    TestErrorEvent errorEvent=command.execute();
    if (errorEvent != null) {
      CAPTestResponseMessage response=new CAPTestResponseMessage();
      response.setTestErrorEvent(errorEvent);
      response.setMessageCap(capTestMessage.getMessageCap());
      return response;
    }
  }
 catch (  JBException e) {
  }
  return null;
}","/** 
 * Handles the client-actions
 * @param cap the cap to execute
 * @param capTestMessage the CAPTestMessage.
 * @return a response if the result of testing the CAP is determined entirely by the client. Returns <code>null</code> if the CAP message should be sent to the server.
 */
private CAPTestResponseMessage clientExecutionHandling(ICapPO cap,CAPTestMessage capTestMessage){
  Action action=cap.getMetaAction();
  if (!action.isClientAction()) {
    return null;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(Messages.ExecutingClientAction + StringConstants.COLON + StringConstants.SPACE+ action.getPostExecutionCommand());
  }
  final String postExecCommandClass=action.getPostExecutionCommand();
  final IPostExecutionCommand command=m_postExecCmdFactory.createCommand(postExecCommandClass);
  TestErrorEvent errorEvent=executePostExecCommand(command);
  if (errorEvent != null) {
    CAPTestResponseMessage response=new CAPTestResponseMessage();
    response.setTestErrorEvent(errorEvent);
    response.setMessageCap(capTestMessage.getMessageCap());
    return response;
  }
  return null;
}",0.9489115948467348
95896,"/** 
 * Loads, instantiates and executes the given IPostExecutionCommand class
 * @param cmdClassName the IPostExecutionCommand to execute.
 * @return a TestErrorEvent representing an error that occurred during  execution, or <code>null</code> if no such error occurs. 
 */
private TestErrorEvent executePostExecCommand(String cmdClassName){
  final IPostExecutionCommand cmd=m_postExecCmdFactory.createCommand(cmdClassName);
  if (cmd instanceof AbstractPostExecutionCommand) {
    AbstractPostExecutionCommand aCmd=(AbstractPostExecutionCommand)cmd;
    aCmd.setCurrentCap(m_currentCap);
    aCmd.setExternalTestDataBP(m_externalTestDataBP);
    aCmd.setLocale(getLocale());
    aCmd.setTraverser(m_trav);
  }
  try {
    return cmd.execute();
  }
 catch (  JBException e) {
    StringBuilder msg=new StringBuilder();
    msg.append(Messages.ErrorExecutingCommand);
    msg.append(StringConstants.COLON);
    msg.append(StringConstants.SPACE);
    msg.append(cmdClassName);
    msg.append(StringConstants.SPACE);
    msg.append(StringConstants.DOT);
    msg.append(StringConstants.SPACE);
    msg.append(Messages.Exception);
    msg.append(StringConstants.COLON);
    msg.append(StringConstants.SPACE);
    msg.append(String.valueOf(e));
    LOG.error(msg.toString());
    fireError(e);
    return null;
  }
}","/** 
 * Loads, instantiates and executes the given IPostExecutionCommand class
 * @param cmd the IPostExecutionCommand to execute.
 * @return a TestErrorEvent representing an error that occurred duringexecution, or <code>null</code> if no such error occurs.
 */
private TestErrorEvent executePostExecCommand(IPostExecutionCommand cmd){
  if (cmd instanceof AbstractPostExecutionCommand) {
    AbstractPostExecutionCommand aCmd=(AbstractPostExecutionCommand)cmd;
    aCmd.setCurrentCap(m_currentCap);
    aCmd.setExternalTestDataBP(m_externalTestDataBP);
    aCmd.setLocale(getLocale());
    aCmd.setTraverser(m_trav);
  }
  try {
    return cmd.execute();
  }
 catch (  JBException e) {
    LOG.error(NLS.bind(Messages.ErrorExecutingCommand,cmd.getClass().getName(),e.getLocalizedMessage()));
    fireError(e);
    return null;
  }
}",0.6940298507462687
95897,"/** 
 * @param logicalName guid of the logical name for which to find the technical name
 * @param aut AUT information
 * @param comp component
 * @return a ComponentIdentifier or null
 */
private IComponentIdentifier getTechnicalName(String logicalName,IAUTMainPO aut,Component comp){
  IObjectMappingPO om=aut.getObjMap();
  IComponentIdentifier technicalName;
  try {
    technicalName=om.getTechnicalName(logicalName);
  }
 catch (  LogicComponentNotManagedException e) {
    technicalName=null;
  }
  if (technicalName == null && comp instanceof ConcreteComponent) {
    ConcreteComponent cc=((ConcreteComponent)comp);
    if (cc.hasDefaultMapping() && cc.getComponentClass() != null) {
      Set realizers=cc.getAllRealizers();
      for (Iterator iterator=realizers.iterator(); iterator.hasNext(); ) {
        ConcreteComponent concreteComponent=(ConcreteComponent)iterator.next();
        if (aut.getToolkit().equals(concreteComponent.getToolkitDesriptor().getToolkitID())) {
          technicalName=new ComponentIdentifier();
          technicalName.setComponentClassName(concreteComponent.getComponentClass());
          break;
        }
      }
    }
  }
  return technicalName;
}","/** 
 * @param logicalName guid of the logical name for which to find the technical name
 * @param aut AUT information
 * @param comp component
 * @return a ComponentIdentifier or null
 */
private IComponentIdentifier getTechnicalName(String logicalName,IAUTMainPO aut,Component comp){
  IObjectMappingPO om=aut.getObjMap();
  IComponentIdentifier technicalName;
  try {
    technicalName=om.getTechnicalName(logicalName);
  }
 catch (  LogicComponentNotManagedException e) {
    technicalName=null;
  }
  if (technicalName == null && comp instanceof ConcreteComponent) {
    ConcreteComponent cc=((ConcreteComponent)comp);
    if (cc.hasDefaultMapping() && cc.getComponentClass() != null) {
      Set realizers=cc.getAllRealizers();
      String toolkit=aut.getToolkit();
      ToolkitPluginDescriptor tpd=null;
      while (!StringUtils.isEmpty(toolkit)) {
        for (Iterator iterator=realizers.iterator(); iterator.hasNext(); ) {
          ConcreteComponent concreteComponent=(ConcreteComponent)iterator.next();
          if (toolkit.equals(concreteComponent.getToolkitDesriptor().getToolkitID()) && concreteComponent.getComponentClass() != null) {
            technicalName=new ComponentIdentifier();
            technicalName.setComponentClassName(concreteComponent.getComponentClass());
            return technicalName;
          }
        }
        try {
          tpd=ToolkitSupportBP.getToolkitDescriptor(toolkit);
          toolkit=tpd.getIncludes();
        }
 catch (        ToolkitPluginException e) {
          LOG.error(""String_Node_Str"",e);
          return null;
        }
      }
    }
  }
  return technicalName;
}",0.8323903818953324
95898,"/** 
 * @param toolkitId the id of the toolkit
 * @return the {@link ToolkitPluginDescriptor} of the toolkit with the given id.
 */
private static ToolkitPluginDescriptor getToolkitDescriptor(String toolkitId) throws ToolkitPluginException {
  if (toolkitId == null) {
    final String msg=Messages.ToolkitNameIsNull + StringConstants.EXCLAMATION_MARK;
    log.error(msg);
    throwToolkitPluginException(msg,null);
  }
  for (  ToolkitPluginDescriptor descr : toolkitProvider.keySet()) {
    if (toolkitId.equals(descr.getToolkitID())) {
      return descr;
    }
  }
  final String msg=Messages.NoToolkitPluginDescriptorFound + StringConstants.COLON + StringConstants.SPACE+ String.valueOf(toolkitId);
  log.error(msg);
  throwToolkitPluginException(msg,null);
  return null;
}","/** 
 * @param toolkitId the id of the toolkit
 * @return the {@link ToolkitPluginDescriptor} of the toolkit with the given id.
 */
public static ToolkitPluginDescriptor getToolkitDescriptor(String toolkitId) throws ToolkitPluginException {
  if (toolkitId == null) {
    final String msg=Messages.ToolkitNameIsNull + StringConstants.EXCLAMATION_MARK;
    log.error(msg);
    throwToolkitPluginException(msg,null);
  }
  for (  ToolkitPluginDescriptor descr : toolkitProvider.keySet()) {
    if (toolkitId.equals(descr.getToolkitID())) {
      return descr;
    }
  }
  final String msg=Messages.NoToolkitPluginDescriptorFound + StringConstants.COLON + StringConstants.SPACE+ String.valueOf(toolkitId);
  log.error(msg);
  throwToolkitPluginException(msg,null);
  return null;
}",0.9929351316634554
95899,"/** 
 * {@inheritDoc}
 */
public Message execute(){
  ObjectMappingEventDispatcher.clearObjMapTransient();
  fireAutStateChanged();
  m_wasExecuted=true;
  return null;
}","/** 
 * {@inheritDoc}
 */
public Message execute(){
  fireAutStateChanged();
  m_wasExecuted=true;
  return null;
}",0.8070175438596491
95900,"/** 
 * Query the AUTServer for all supported components. <code>listener.componentInfo()</code> will be called when the answer receives.
 * @param command the command to execute as a callback
 * @throws CommunicationException if an error occurs while communicating with the AUT.
 */
private void getAllComponentsFromAUT(AUTStartedCommand command) throws CommunicationException {
  LOG.info(Messages.GettingAllComponentsFromAUT);
  try {
    SendAUTListOfSupportedComponentsMessage message=MessageFactory.getSendAUTListOfSupportedComponentsMessage();
    CompSystem compSystem=ComponentBuilder.getInstance().getCompSystem();
    IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
    String autToolkitId=connectedAut.getToolkit();
    List<Component> components=compSystem.getComponents(autToolkitId,true);
    components.retainAll(compSystem.getConcreteComponents());
    message.setComponents(components);
    Profile profile=new Profile();
    IObjectMappingProfilePO profilePo=connectedAut.getObjMap().getProfile();
    profile.setNameFactor(profilePo.getNameFactor());
    profile.setPathFactor(profilePo.getPathFactor());
    profile.setContextFactor(profilePo.getContextFactor());
    profile.setThreshold(profilePo.getThreshold());
    message.setProfile(profile);
    int timeoutToUse=AUTStateCommand.AUT_COMPONENT_RETRIEVAL_TIMEOUT;
    request(message,command,timeoutToUse);
    long startTime=System.currentTimeMillis();
    while (System.currentTimeMillis() <= startTime + timeoutToUse && !command.wasExecuted() && isConnected()) {
      TimeUtil.delay(500);
    }
    if (!command.wasExecuted() && isConnected()) {
      IAUTInfoListener listener=command.getListener();
      if (listener != null) {
        listener.error(IAUTInfoListener.ERROR_COMMUNICATION);
      }
      throw new CommunicationException(Messages.CouldNotRequestComponentsFromAUT,IAUTInfoListener.ERROR_COMMUNICATION);
    }
    if (ObjectMappingEventDispatcher.getObjMapTransient().getMappings().isEmpty()) {
      LOG.warn(Messages.NoDefaultObjectMappingsCouldBeFoundForTheAUT);
    }
  }
 catch (  UnknownMessageException ume) {
    ClientTestFactory.getClientTest().fireAUTServerStateChanged(new AUTServerEvent(ume.getErrorId()));
  }
}","/** 
 * Query the AUTServer for all supported components. <code>listener.componentInfo()</code> will be called when the answer receives.
 * @param command the command to execute as a callback
 * @throws CommunicationException if an error occurs while communicating with the AUT.
 */
private void getAllComponentsFromAUT(AUTStartedCommand command) throws CommunicationException {
  LOG.info(Messages.GettingAllComponentsFromAUT);
  try {
    SendAUTListOfSupportedComponentsMessage message=MessageFactory.getSendAUTListOfSupportedComponentsMessage();
    CompSystem compSystem=ComponentBuilder.getInstance().getCompSystem();
    IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
    String autToolkitId=connectedAut.getToolkit();
    List<Component> components=compSystem.getComponents(autToolkitId,true);
    components.retainAll(compSystem.getConcreteComponents());
    message.setComponents(components);
    Profile profile=new Profile();
    IObjectMappingProfilePO profilePo=connectedAut.getObjMap().getProfile();
    profile.setNameFactor(profilePo.getNameFactor());
    profile.setPathFactor(profilePo.getPathFactor());
    profile.setContextFactor(profilePo.getContextFactor());
    profile.setThreshold(profilePo.getThreshold());
    message.setProfile(profile);
    int timeoutToUse=AUTStateCommand.AUT_COMPONENT_RETRIEVAL_TIMEOUT;
    request(message,command,timeoutToUse);
    long startTime=System.currentTimeMillis();
    while (System.currentTimeMillis() <= startTime + timeoutToUse && !command.wasExecuted() && isConnected()) {
      TimeUtil.delay(500);
    }
    if (!command.wasExecuted() && isConnected()) {
      IAUTInfoListener listener=command.getListener();
      if (listener != null) {
        listener.error(IAUTInfoListener.ERROR_COMMUNICATION);
      }
      throw new CommunicationException(Messages.CouldNotRequestComponentsFromAUT,IAUTInfoListener.ERROR_COMMUNICATION);
    }
  }
 catch (  UnknownMessageException ume) {
    ClientTestFactory.getClientTest().fireAUTServerStateChanged(new AUTServerEvent(ume.getErrorId()));
  }
}",0.8982894128525196
95901,"public void run(){
  if (getEditorHelper().requestEditableState() != JBEditorHelper.EditableState.OK) {
    return;
  }
  if (!ObjectMappingEventDispatcher.getObjMapTransient().existTechnicalName(ci) && !hasDefaultMapping) {
    String capComponentName=m_objectMappingManager.addMapping(recordAut,ci,newCap.getComponentName());
    newCap.setComponentName(capComponentName);
  }
  getTreeViewer().refresh(false);
  getTreeViewer().setSelection(new StructuredSelection(newCap),true);
  getEditorHelper().setDirty(true);
}","public void run(){
  if (getEditorHelper().requestEditableState() != JBEditorHelper.EditableState.OK) {
    return;
  }
  if (!hasDefaultMapping) {
    String capComponentName=m_objectMappingManager.addMapping(recordAut,ci,newCap.getComponentName());
    newCap.setComponentName(capComponentName);
  }
  getTreeViewer().refresh(false);
  getTreeViewer().setSelection(new StructuredSelection(newCap),true);
  getEditorHelper().setDirty(true);
}",0.2990654205607476
95902,"/** 
 * {@inheritDoc}
 */
public void capRecorded(final ICapPO newCap,final IComponentIdentifier ci,final boolean hasDefaultMapping){
  if (newCap == null) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_TEST_STEP_NOT_CREATED);
  }
 else {
    final IAUTMainPO recordAut=TestExecution.getInstance().getConnectedAut();
    Plugin.getDisplay().syncExec(new Runnable(){
      public void run(){
        if (getEditorHelper().requestEditableState() != JBEditorHelper.EditableState.OK) {
          return;
        }
        if (!ObjectMappingEventDispatcher.getObjMapTransient().existTechnicalName(ci) && !hasDefaultMapping) {
          String capComponentName=m_objectMappingManager.addMapping(recordAut,ci,newCap.getComponentName());
          newCap.setComponentName(capComponentName);
        }
        getTreeViewer().refresh(false);
        getTreeViewer().setSelection(new StructuredSelection(newCap),true);
        getEditorHelper().setDirty(true);
      }
    }
);
  }
}","/** 
 * {@inheritDoc}
 */
public void capRecorded(final ICapPO newCap,final IComponentIdentifier ci,final boolean hasDefaultMapping){
  if (newCap == null) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_TEST_STEP_NOT_CREATED);
  }
 else {
    final IAUTMainPO recordAut=TestExecution.getInstance().getConnectedAut();
    Plugin.getDisplay().syncExec(new Runnable(){
      public void run(){
        if (getEditorHelper().requestEditableState() != JBEditorHelper.EditableState.OK) {
          return;
        }
        if (!hasDefaultMapping) {
          String capComponentName=m_objectMappingManager.addMapping(recordAut,ci,newCap.getComponentName());
          newCap.setComponentName(capComponentName);
        }
        getTreeViewer().refresh(false);
        getTreeViewer().setSelection(new StructuredSelection(newCap),true);
        getEditorHelper().setDirty(true);
      }
    }
);
  }
}",0.9592376919004764
95903,"/** 
 * Toggles the combobox dropdown list by clicking on the combo box.
 */
protected void toggleDropdownList(){
  Rectangle r=findArrowIconArea();
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + r + ""String_Node_Str""+ getRealComponent());
  }
  getRobot().click(getRealComponent(),r,ClickOptions.create().setScrollToVisible(false).setConfirmClick(false));
}","/** 
 * Toggles the combobox dropdown list by clicking on the combo box.
 */
protected void toggleDropdownList(){
  Rectangle r=findArrowIconArea();
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + r + ""String_Node_Str""+ getRealComponent());
  }
  getRobot().click(getRealComponent(),r,ClickOptions.create().setScrollToVisible(true).setConfirmClick(false));
}",0.9425901201602136
95904,"/** 
 * @param po The persistent object that was added
 */
private void handleDataAdded(IPersistentObject po){
  if (po instanceof ISpecTestCasePO) {
    return;
  }
  getTreeViewer().refresh();
  getTreeViewer().expandToLevel(getTreeViewer().getAutoExpandLevel());
  getTreeViewer().setSelection(new StructuredSelection(po),true);
}","/** 
 * @param po The persistent object that was added
 */
private void handleDataAdded(IPersistentObject po){
  if (po instanceof ISpecTestCasePO || po instanceof IComponentNamePO) {
    return;
  }
  getTreeViewer().refresh();
  getTreeViewer().expandToLevel(getTreeViewer().getAutoExpandLevel());
  getTreeViewer().setSelection(new StructuredSelection(po),true);
}",0.9514285714285714
95905,"/** 
 * @param nodesToDelete the nodes to delete
 * @return a list of abstract cmd handles for node deletion
 */
protected List<AbstractCmdHandle> getDeleteCommands(List<INodePO> nodesToDelete){
  IEditorReference[] editors=Plugin.getActivePage().getEditorReferences();
  List<AbstractCmdHandle> cmds=new ArrayList<AbstractCmdHandle>(nodesToDelete.size());
  for (  INodePO node : nodesToDelete) {
    AbstractCmdHandle cmd=null;
    if (node instanceof ITestSuitePO) {
      ITestSuitePO testSuite=(ITestSuitePO)node;
      List<IRefTestSuitePO> refTs=NodePM.getInternalRefTestSuites(testSuite.getGuid(),testSuite.getParentProjectId());
      if (refTs.size() > 0) {
        ErrorHandlingUtil.createMessageDialog(MessageIDs.I_REUSED_TS);
        return ListUtils.EMPTY_LIST;
      }
      closeEditors(testSuite,editors);
      cmd=new DeleteExecHandle(testSuite);
    }
 else     if (node instanceof ITestJobPO) {
      ITestJobPO testjob=(ITestJobPO)node;
      closeEditors(testjob,editors);
      cmd=new DeleteExecHandle(testjob);
    }
 else     if (node instanceof ICategoryPO) {
      ICategoryPO category=(ICategoryPO)node;
      cmd=new DeleteCatHandle(category);
    }
    cmds.add(cmd);
  }
  return cmds;
}","/** 
 * @param nodesToDelete the nodes to delete
 * @return a list of abstract cmd handles for node deletion
 */
protected List<AbstractCmdHandle> getDeleteCommands(List<INodePO> nodesToDelete){
  List<AbstractCmdHandle> cmds=new ArrayList<AbstractCmdHandle>(nodesToDelete.size());
  for (  INodePO node : nodesToDelete) {
    AbstractCmdHandle cmd=null;
    if (node instanceof ITestSuitePO) {
      ITestSuitePO testSuite=(ITestSuitePO)node;
      List<IRefTestSuitePO> refTs=NodePM.getInternalRefTestSuites(testSuite.getGuid(),testSuite.getParentProjectId());
      if (refTs.size() > 0) {
        ErrorHandlingUtil.createMessageDialog(MessageIDs.I_REUSED_TS);
        return ListUtils.EMPTY_LIST;
      }
      closeOpenEditor(testSuite);
      cmd=new DeleteExecHandle(testSuite);
    }
 else     if (node instanceof ITestJobPO) {
      ITestJobPO testjob=(ITestJobPO)node;
      closeOpenEditor(testjob);
      cmd=new DeleteExecHandle(testjob);
    }
 else     if (node instanceof ICategoryPO) {
      ICategoryPO category=(ICategoryPO)node;
      cmd=new DeleteCatHandle(category);
    }
    cmds.add(cmd);
  }
  return cmds;
}",0.948619957537155
95906,"/** 
 * Resets this singleton: Closes the communicator removes the listeners.<br> <b>Note: </b><br> This method is used by the Restart-AUT-Action only to avoid errors while reconnecting with the AUTServer.<br> This is necessary because the disconnect from the AUTServer is implemented badly which will be corrected in a future version!
 */
public synchronized void reset(){
  if (getCommunicator() != null) {
    getCommunicator().clearListeners();
  }
  getCommunicator().close();
  instance=null;
}","/** 
 * Resets this singleton: Closes the communicator removes the listeners.<br> <b>Note: </b><br> This method is used by the Restart-AUT-Action only to avoid errors while reconnecting with the AUTServer.<br> This is necessary because the disconnect from the AUTServer is implemented badly which will be corrected in a future version!
 */
public synchronized void reset(){
  Communicator communicator=getCommunicator();
  if (communicator != null) {
    communicator.interruptAllTimeouts();
    communicator.clearListeners();
    communicator.close();
  }
  instance=null;
}",0.7851162790697674
95907,"public void selectionChanged(SelectionChangedEvent event){
  boolean pageComplete=false;
  ISpecTestCasePO specTC=null;
  if (tctc.hasValidSelection()) {
    IStructuredSelection selection=(IStructuredSelection)event.getSelection();
    pageComplete=true;
    specTC=(ISpecTestCasePO)selection.getFirstElement();
  }
  setChoosenTestCase(specTC);
  setPageComplete(pageComplete);
}","public void selectionChanged(SelectionChangedEvent event){
  boolean pageComplete=false;
  ISpecTestCasePO specTC=null;
  if (tctc.hasValidSelection()) {
    IStructuredSelection selection=(IStructuredSelection)event.getSelection();
    pageComplete=true;
    specTC=(ISpecTestCasePO)selection.getFirstElement();
    if (specTC == null) {
      pageComplete=false;
    }
  }
  setChoosenTestCase(specTC);
  setPageComplete(pageComplete);
}",0.9292682926829268
95908,"/** 
 * {@inheritDoc}
 */
public void createControl(Composite parent){
  final TestCaseTreeComposite tctc;
  if (m_parentTestCase != null) {
    tctc=new TestCaseTreeComposite(parent,SWT.SINGLE,m_parentTestCase);
  }
 else {
    tctc=new TestCaseTreeComposite(parent,SWT.SINGLE,m_setOfParentTestCases);
  }
  tctc.getTreeViewer().addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      boolean pageComplete=false;
      ISpecTestCasePO specTC=null;
      if (tctc.hasValidSelection()) {
        IStructuredSelection selection=(IStructuredSelection)event.getSelection();
        pageComplete=true;
        specTC=(ISpecTestCasePO)selection.getFirstElement();
      }
      setChoosenTestCase(specTC);
      setPageComplete(pageComplete);
    }
  }
);
  setControl(tctc);
}","/** 
 * {@inheritDoc}
 */
public void createControl(Composite parent){
  final TestCaseTreeComposite tctc;
  if (m_parentTestCase != null) {
    tctc=new TestCaseTreeComposite(parent,SWT.SINGLE,m_parentTestCase);
  }
 else {
    tctc=new TestCaseTreeComposite(parent,SWT.SINGLE,m_setOfParentTestCases);
  }
  tctc.getTreeViewer().addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      boolean pageComplete=false;
      ISpecTestCasePO specTC=null;
      if (tctc.hasValidSelection()) {
        IStructuredSelection selection=(IStructuredSelection)event.getSelection();
        pageComplete=true;
        specTC=(ISpecTestCasePO)selection.getFirstElement();
        if (specTC == null) {
          pageComplete=false;
        }
      }
      setChoosenTestCase(specTC);
      setPageComplete(pageComplete);
    }
  }
);
  setControl(tctc);
}",0.9604072398190046
95909,"@Override protected int getTerminationTimeout(){
  return 0;
}","@Override protected int getTerminationTimeout(){
  return NO_TIMEOUT__FORCE_RESTART;
}",0.8243243243243243
95910,"/** 
 * {@inheritDoc}
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IComponent.class)) {
    IComponent returnvalue=null;
    if (objectToAdapt instanceof Button) {
      returnvalue=new ButtonAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Menu) {
      returnvalue=new MenuAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof MenuItem) {
      returnvalue=new MenuItemAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Tree) {
      returnvalue=new TreeAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Table) {
      returnvalue=new TableAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof List) {
      returnvalue=new ListAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Text) {
      returnvalue=new TextComponentAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof StyledText) {
      returnvalue=new StyledTextAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Combo) {
      returnvalue=new ComboAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof CCombo) {
      returnvalue=new CComboAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Label) {
      returnvalue=new LabelAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof CLabel) {
      returnvalue=new CLabelAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof TabFolder) {
      returnvalue=new TabFolderAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof CTabFolder) {
      returnvalue=new CTabFolderAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Link) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Spinner) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Slider) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Scale) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof ToolItem) {
      returnvalue=new ToolItemAdapter(objectToAdapt);
    }
    return returnvalue;
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public Object getAdapter(Class targetedClass,Object objectToAdapt){
  if (targetedClass.isAssignableFrom(IComponent.class)) {
    IComponent returnvalue=null;
    if (objectToAdapt instanceof Button) {
      returnvalue=new ButtonAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Menu) {
      returnvalue=new MenuAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof MenuItem) {
      returnvalue=new MenuItemAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Tree) {
      returnvalue=new TreeAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Table) {
      returnvalue=new TableAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof List) {
      returnvalue=new ListAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Text) {
      returnvalue=new TextComponentAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof StyledText) {
      returnvalue=new StyledTextAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Combo) {
      returnvalue=new ComboAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof CCombo) {
      returnvalue=new CComboAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Label) {
      returnvalue=new LabelAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof CLabel) {
      returnvalue=new CLabelAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof TabFolder) {
      returnvalue=new TabFolderAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof CTabFolder) {
      returnvalue=new CTabFolderAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Link) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Spinner) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Slider) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof Scale) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof DateTime) {
      returnvalue=new ControlAdapter(objectToAdapt);
    }
 else     if (objectToAdapt instanceof ToolItem) {
      returnvalue=new ToolItemAdapter(objectToAdapt);
    }
    return returnvalue;
  }
  return null;
}",0.9763948497854076
95911,"/** 
 * Executes actions after the drop.
 * @param node the dropped node. 
 * @param targetEditor The editor to which the item has been dropped/pasted.
 */
private static void postDropAction(INodePO node,AbstractTestCaseEditor targetEditor){
  targetEditor.setFocus();
  if (node != null) {
    targetEditor.getTreeViewer().setSelection(new StructuredSelection(node));
  }
  targetEditor.getTreeViewer().refresh();
  targetEditor.getEditorHelper().setDirty(true);
  LocalSelectionTransfer.getInstance().setSelection(null);
}","/** 
 * Executes actions after the drop.
 * @param node the dropped node. 
 * @param targetEditor The editor to which the item has been dropped/pasted.
 */
private static void postDropAction(INodePO node,AbstractTestCaseEditor targetEditor){
  targetEditor.setFocus();
  targetEditor.getEditorHelper().setDirty(true);
  LocalSelectionTransfer.getInstance().setSelection(null);
}",0.6208425720620843
95912,"/** 
 * Executes actions after the drop.
 * @param node the dropped node. 
 * @param targetEditor The editor to which the item has been dropped/pasted.
 */
private static void postDropAction(INodePO node,TestJobEditor targetEditor){
  targetEditor.setFocus();
  if (node != null) {
    targetEditor.getTreeViewer().setSelection(new StructuredSelection(node));
  }
  targetEditor.getTreeViewer().refresh();
  targetEditor.getEditorHelper().setDirty(true);
  LocalSelectionTransfer.getInstance().setSelection(null);
}","/** 
 * Executes actions after the drop.
 * @param node the dropped node. 
 * @param targetEditor The editor to which the item has been dropped/pasted.
 */
private static void postDropAction(INodePO node,TestJobEditor targetEditor){
  targetEditor.setFocus();
  targetEditor.getEditorHelper().setDirty(true);
  LocalSelectionTransfer.getInstance().setSelection(null);
}",0.6131221719457014
95913,"/** 
 * @param selectionChangedListenerList the selectionChangedListenerList to set
 */
public void setSelectionChangedListenerList(List<ISelectionChangedListener> selectionChangedListenerList){
  m_selectionChangedListenerList=selectionChangedListenerList;
}","/** 
 * @param selectionChangedListenerList the selectionChangedListenerList to set
 */
protected void setSelectionChangedListenerList(List<ISelectionChangedListener> selectionChangedListenerList){
  m_selectionChangedListenerList=selectionChangedListenerList;
}",0.9750479846449136
95914,"/** 
 * @param parentComposite the parentComposite to set
 */
public void setParentComposite(Composite parentComposite){
  m_parentComposite=parentComposite;
}","/** 
 * @param parentComposite the parentComposite to set
 */
protected void setParentComposite(Composite parentComposite){
  m_parentComposite=parentComposite;
}",0.9657320872274144
95915,"/** 
 * @param pasteTreeItemAction the pasteTreeItemAction to set
 */
public void setPasteTreeItemAction(PasteTreeItemActionTCEditor pasteTreeItemAction){
  m_pasteTreeItemAction=pasteTreeItemAction;
}","/** 
 * @param pasteTreeItemAction the pasteTreeItemAction to set
 */
protected void setPasteTreeItemAction(PasteTreeItemActionTCEditor pasteTreeItemAction){
  m_pasteTreeItemAction=pasteTreeItemAction;
}",0.9679012345679012
95916,"/** 
 * @return the topTreeViewer
 */
public TreeViewer getMainTreeViewer(){
  return m_mainTreeViewer;
}","/** 
 * @return the topTreeViewer
 */
protected TreeViewer getMainTreeViewer(){
  return m_mainTreeViewer;
}",0.9483568075117372
95917,"/** 
 * @return the selectionChangedListenerList
 */
public List<ISelectionChangedListener> getSelectionChangedListenerList(){
  return m_selectionChangedListenerList;
}","/** 
 * @return the selectionChangedListenerList
 */
protected List<ISelectionChangedListener> getSelectionChangedListenerList(){
  return m_selectionChangedListenerList;
}",0.967741935483871
95918,"/** 
 * @return the control
 */
public Control getControl(){
  return m_control;
}","/** 
 * @return the control
 */
private Control getControl(){
  return m_control;
}",0.9454545454545454
95919,"/** 
 * Sets the current selection for this selection provider.
 * @param selection the new selection
 */
protected void setSelectionImpl(ISelection selection){
  getMainTreeViewer().setSelection(selection);
}","/** 
 * Sets the current selection for this selection provider.
 * @param selection the new selection
 */
protected void setSelectionImpl(ISelection selection){
  UINodeBP.setFocusAndSelection(selection,getMainTreeViewer());
}",0.8551724137931035
95920,"/** 
 * @return the cutTreeItemAction
 */
public CutTreeItemActionGDEditor getCutTreeItemAction(){
  return m_cutTreeItemAction;
}","/** 
 * @return the cutTreeItemAction
 */
protected CutTreeItemActionGDEditor getCutTreeItemAction(){
  return m_cutTreeItemAction;
}",0.9581749049429658
95921,"/** 
 * @param mainTreeViewer the mainTreeViewer to set
 */
public void setMainTreeViewer(TreeViewer mainTreeViewer){
  m_mainTreeViewer=mainTreeViewer;
}","/** 
 * @param mainTreeViewer the mainTreeViewer to set
 */
protected void setMainTreeViewer(TreeViewer mainTreeViewer){
  m_mainTreeViewer=mainTreeViewer;
}",0.964630225080386
95922,"/** 
 * @param cutTreeItemAction the cutTreeItemAction to set
 */
public void setCutTreeItemAction(CutTreeItemActionGDEditor cutTreeItemAction){
  m_cutTreeItemAction=cutTreeItemAction;
}","/** 
 * @param cutTreeItemAction the cutTreeItemAction to set
 */
protected void setCutTreeItemAction(CutTreeItemActionGDEditor cutTreeItemAction){
  m_cutTreeItemAction=cutTreeItemAction;
}",0.9708222811671088
95923,"/** 
 * @return the pasteTreeItemAction
 */
public PasteTreeItemActionTCEditor getPasteTreeItemAction(){
  return m_pasteTreeItemAction;
}","/** 
 * @return the pasteTreeItemAction
 */
protected PasteTreeItemActionTCEditor getPasteTreeItemAction(){
  return m_pasteTreeItemAction;
}",0.9605734767025088
95924,"/** 
 * @param editorHelper the editorHelper to set
 */
public void setEditorHelper(JBEditorHelper editorHelper){
  m_editorHelper=editorHelper;
}","/** 
 * @param editorHelper the editorHelper to set
 */
protected void setEditorHelper(JBEditorHelper editorHelper){
  m_editorHelper=editorHelper;
}",0.9627118644067796
95925,"/** 
 * @param control the control to set
 */
public void setControl(Control control){
  m_control=control;
}","/** 
 * @param control the control to set
 */
protected void setControl(Control control){
  m_control=control;
}",0.9502262443438914
95926,"/** 
 * Refreshes the viewer and updates the expansion state and selection based on the added node.
 * @param addedNode The node that has been added.
 */
protected void handleNodeAdded(INodePO addedNode){
  getTreeViewer().refresh();
  getTreeViewer().setSelection(new StructuredSelection(addedNode));
}","/** 
 * Refreshes the viewer and updates the expansion state and selection based on the added node.
 * @param addedNode The node that has been added.
 */
private void handleNodeAdded(INodePO addedNode){
  refresh();
  setSelection(new StructuredSelection(addedNode));
}",0.7202797202797203
95927,"/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState){
  if (po instanceof INodePO) {
    INodePO changedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
    boolean isVisibleInEditor=editorNode.indexOf(changedNode) > -1;
    if (editorNode instanceof ISpecTestCasePO) {
      isVisibleInEditor|=((ISpecTestCasePO)editorNode).getAllEventEventExecTC().contains(po);
    }
switch (dataState) {
case Added:
      if (isVisibleInEditor) {
        handleNodeAdded(changedNode);
      }
    break;
case Deleted:
  if (!(po instanceof IProjectPO)) {
    refresh();
  }
break;
case Renamed:
renameGUINode(po);
break;
case StructureModified:
if (isVisibleInEditor) {
getEditorHelper().setDirty(true);
}
if (!handleStructureModified(po)) {
return;
}
break;
case ReuseChanged:
break;
default :
Assert.notReached();
}
if (isVisibleInEditor) {
runLocalChecks();
}
getEditorHelper().handleDataChanged(po,dataState);
}
}","/** 
 * {@inheritDoc}
 */
public void handleDataChanged(IPersistentObject po,DataState dataState){
  if (po instanceof INodePO) {
    INodePO changedNode=(INodePO)po;
    INodePO editorNode=(INodePO)getEditorHelper().getEditSupport().getWorkVersion();
    boolean isVisibleInEditor=editorNode.indexOf(changedNode) > -1;
    if (editorNode instanceof ISpecTestCasePO) {
      isVisibleInEditor|=((ISpecTestCasePO)editorNode).getAllEventEventExecTC().contains(po);
    }
switch (dataState) {
case Added:
      if (isVisibleInEditor) {
        handleNodeAdded(changedNode);
      }
    break;
case Deleted:
  if (!(po instanceof IProjectPO)) {
    refresh();
  }
break;
case Renamed:
createPartName();
break;
case StructureModified:
if (isVisibleInEditor) {
getEditorHelper().setDirty(true);
}
if (!handleStructureModified(po)) {
return;
}
break;
case ReuseChanged:
break;
default :
Assert.notReached();
}
if (isVisibleInEditor) {
runLocalChecks();
}
getEditorHelper().handleDataChanged(po,dataState);
}
}",0.9875311720698254
95928,"/** 
 * Refreshes the tree viewer.
 */
protected void refresh(){
  getTreeViewer().refresh();
}","/** 
 * Refreshes the tree viewer.
 */
protected void refresh(){
  getTreeViewer().refresh(true);
}",0.979381443298969
95929,"/** 
 * @param root the root of the TreeViewer.
 */
protected void initTopTreeViewer(INodePO root){
  try {
    getMainTreeViewer().getTree().setRedraw(false);
    getMainTreeViewer().setInput(null);
    getMainTreeViewer().setInput(new INodePO[]{root});
  }
  finally {
    getMainTreeViewer().getTree().setRedraw(true);
    getMainTreeViewer().expandAll();
    getMainTreeViewer().setSelection(new StructuredSelection(root));
  }
}","/** 
 * @param root the root of the TreeViewer.
 */
protected void initTopTreeViewer(INodePO root){
  try {
    getMainTreeViewer().getTree().setRedraw(false);
    getMainTreeViewer().setInput(null);
    getMainTreeViewer().setInput(new INodePO[]{root});
  }
  finally {
    getMainTreeViewer().getTree().setRedraw(true);
    getMainTreeViewer().expandAll();
    setSelection(new StructuredSelection(root));
  }
}",0.9763593380614656
95930,"/** 
 * {@inheritDoc} 
 */
public void createPartControlImpl(Composite parent){
  super.createPartControlImpl(parent);
  m_eventHandlerTreeViewer.setContentProvider(new EventHandlerContentProvider());
  m_eventHandlerTreeViewer.getControl().setMenu(createContextMenu());
  addDoubleClickListener(CommandIDs.OPEN_SPECIFICATION_COMMAND_ID,m_eventHandlerTreeViewer);
  ActionListener actionListener=new ActionListener();
  getTreeViewer().addSelectionChangedListener(actionListener);
  getEventHandlerTreeViewer().addSelectionChangedListener(actionListener);
  if (!Plugin.getDefault().anyDirtyStar()) {
    checkAndRemoveUnusedTestData();
  }
}","/** 
 * {@inheritDoc} 
 */
public void createPartControlImpl(Composite parent){
  super.createPartControlImpl(parent);
  m_eventHandlerTreeViewer.setContentProvider(new EventHandlerContentProvider());
  m_eventHandlerTreeViewer.getControl().setMenu(createContextMenu());
  addDoubleClickListener(CommandIDs.OPEN_SPECIFICATION_COMMAND_ID,m_eventHandlerTreeViewer);
  ActionListener actionListener=new ActionListener();
  getTreeViewer().addSelectionChangedListener(actionListener);
  getEventHandlerTreeViewer().addSelectionChangedListener(actionListener);
  if (!Plugin.getDefault().anyDirtyStar()) {
    checkAndRemoveUnusedTestData();
  }
  m_currentTreeViewer=getMainTreeViewer();
}",0.9675960813865864
95931,"/** 
 * {@inheritDoc} 
 */
public void focusGained(FocusEvent e){
  Tree tree=(Tree)e.getSource();
  if (getMainTreeViewer().getTree() == tree) {
    m_currentTreeViewer=getMainTreeViewer();
  }
 else   if (m_eventHandlerTreeViewer.getTree() == tree) {
    m_currentTreeViewer=m_eventHandlerTreeViewer;
  }
  m_currentTreeViewer.setSelection(m_currentTreeViewer.getSelection(),true);
}","/** 
 * {@inheritDoc} 
 */
public void focusGained(FocusEvent e){
  Tree tree=(Tree)e.getSource();
  if (getMainTreeViewer().getTree() == tree) {
    m_currentTreeViewer=getMainTreeViewer();
  }
 else   if (getEventHandlerTreeViewer().getTree() == tree) {
    m_currentTreeViewer=getEventHandlerTreeViewer();
  }
}",0.6781115879828327
95932,"@Override protected void refresh(){
  super.refresh();
  getEventHandlerTreeViewer().refresh();
}","@Override protected void refresh(){
  super.refresh();
  getEventHandlerTreeViewer().refresh(true);
}",0.9797979797979798
95933,"/** 
 * {@inheritDoc} 
 */
public void setSelectionImpl(ISelection selection){
  if (selection instanceof StructuredSelection) {
    StructuredSelection ss=(StructuredSelection)selection;
    Object firstElement=ss.getFirstElement();
    if (firstElement instanceof IEventExecTestCasePO) {
      getEventHandlerTreeViewer().getTree().setFocus();
      getEventHandlerTreeViewer().setSelection(selection);
    }
 else {
      super.setSelectionImpl(selection);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void setSelectionImpl(ISelection selection){
  if (selection instanceof StructuredSelection) {
    StructuredSelection ss=(StructuredSelection)selection;
    Object firstElement=ss.getFirstElement();
    if (firstElement instanceof IEventExecTestCasePO) {
      UINodeBP.setFocusAndSelection(ss,getEventHandlerTreeViewer());
    }
 else {
      super.setSelectionImpl(selection);
    }
  }
}",0.875
95934,"/** 
 * Creates the EventHandler part of the editor
 * @param parent Composite
 */
private void createEventHandlerPart(Composite parent){
  Composite headLineComposite=new Composite(parent,SWT.NONE);
  GridLayout layout=new GridLayout(1,true);
  layout.marginWidth=0;
  layout.marginHeight=0;
  layout.marginBottom=0;
  layout.marginTop=0;
  headLineComposite.setLayout(layout);
  Label headLine=new Label(headLineComposite,SWT.NONE);
  headLine.setText(Messages.TestCaseEditorEHAreaHeadline);
  ControlDecorator.decorateInfo(headLine,""String_Node_Str"",false);
  GridData ehTvGridData=new GridData();
  ehTvGridData.grabExcessHorizontalSpace=true;
  ehTvGridData.grabExcessVerticalSpace=true;
  ehTvGridData.horizontalAlignment=SWT.FILL;
  ehTvGridData.verticalAlignment=SWT.FILL;
  ehTvGridData.verticalSpan=100;
  GridLayout ehTvLayout=new GridLayout(1,true);
  ehTvLayout.marginWidth=0;
  ehTvLayout.marginHeight=0;
  ehTvLayout.marginBottom=0;
  ehTvLayout.marginTop=0;
  m_eventHandlerTreeViewer=new TreeViewer(headLineComposite);
  m_eventHandlerTreeViewer.getTree().setLayout(ehTvLayout);
  m_eventHandlerTreeViewer.getTree().setLayoutData(ehTvGridData);
  ColumnViewerToolTipSupport.enableFor(m_eventHandlerTreeViewer);
  DecoratingCellLabelProvider lp=new DecoratingCellLabelProvider(new TooltipLabelProvider(),Plugin.getDefault().getWorkbench().getDecoratorManager().getLabelDecorator());
  m_eventHandlerTreeViewer.setLabelProvider(lp);
  m_eventHandlerTreeViewer.setComparer(new UIIdentitiyElementComparer());
  m_eventHandlerTreeViewer.setUseHashlookup(true);
  m_eventHandlerTreeViewer.getTree().addListener(SWT.MouseDown,new MouseDownListener());
  firePropertyChange(IWorkbenchPartConstants.PROP_INPUT);
}","/** 
 * Creates the EventHandler part of the editor
 * @param parent Composite
 */
private void createEventHandlerPart(Composite parent){
  Composite headLineComposite=new Composite(parent,SWT.NONE);
  GridLayout layout=new GridLayout(1,true);
  layout.marginWidth=0;
  layout.marginHeight=0;
  layout.marginBottom=0;
  layout.marginTop=0;
  headLineComposite.setLayout(layout);
  Label headLine=new Label(headLineComposite,SWT.NONE);
  headLine.setText(Messages.TestCaseEditorEHAreaHeadline);
  ControlDecorator.decorateInfo(headLine,""String_Node_Str"",false);
  GridData ehTvGridData=new GridData();
  ehTvGridData.grabExcessHorizontalSpace=true;
  ehTvGridData.grabExcessVerticalSpace=true;
  ehTvGridData.horizontalAlignment=SWT.FILL;
  ehTvGridData.verticalAlignment=SWT.FILL;
  ehTvGridData.verticalSpan=100;
  GridLayout ehTvLayout=new GridLayout(1,true);
  ehTvLayout.marginWidth=0;
  ehTvLayout.marginHeight=0;
  ehTvLayout.marginBottom=0;
  ehTvLayout.marginTop=0;
  m_eventHandlerTreeViewer=new TreeViewer(headLineComposite);
  m_eventHandlerTreeViewer.getTree().setLayout(ehTvLayout);
  m_eventHandlerTreeViewer.getTree().setLayoutData(ehTvGridData);
  ColumnViewerToolTipSupport.enableFor(m_eventHandlerTreeViewer);
  DecoratingCellLabelProvider lp=new DecoratingCellLabelProvider(new TooltipLabelProvider(),Plugin.getDefault().getWorkbench().getDecoratorManager().getLabelDecorator());
  m_eventHandlerTreeViewer.setLabelProvider(lp);
  m_eventHandlerTreeViewer.setComparer(new UIIdentitiyElementComparer());
  m_eventHandlerTreeViewer.setUseHashlookup(true);
  firePropertyChange(IWorkbenchPartConstants.PROP_INPUT);
}",0.9734566060244556
95935,"/** 
 * Adds the given eventHandlerInput to the given eventHandlerOwner  as an eventHandler.
 * @param eventHandlerInput the ISpecTestCasePO to be the EventHandler
 * @param evHandlerOwner the ISpecTestCasePO to own the EventHandler
 */
public void addEventHandler(ISpecTestCasePO eventHandlerInput,ISpecTestCasePO evHandlerOwner){
  final EditSupport editSupport=getEditorHelper().getEditSupport();
  ISpecTestCasePO workSpecTcPO=(ISpecTestCasePO)editSupport.getWorkVersion();
  ISpecTestCasePO eventHandlerInputPO=eventHandlerInput;
  IEventExecTestCasePO eventHandlerPO=null;
  try {
    ISpecTestCasePO eventHandlerWorkV=(ISpecTestCasePO)editSupport.createWorkVersion(eventHandlerInputPO);
    eventHandlerPO=NodeMaker.createEventExecTestCasePO(eventHandlerWorkV,workSpecTcPO);
    final int status=openAddEventHandlerDlg(evHandlerOwner,eventHandlerPO);
    if (Window.OK == status) {
      editSupport.lockWorkVersion();
      TestCaseBP.addEventHandler(editSupport,workSpecTcPO,eventHandlerPO);
      getEditorHelper().setDirty(true);
      getEventHandlerTreeViewer().refresh();
      DataEventDispatcher.getInstance().fireDataChangedListener(eventHandlerPO,DataState.Added,UpdateState.onlyInEditor);
    }
  }
 catch (  InvalidDataException e) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_DOUBLE_EVENT,null,new String[]{NLS.bind(Messages.TestCaseEditorDoubleEventTypeErrorDetail,new Object[]{evHandlerOwner.getName(),I18n.getString(eventHandlerPO.getEventType())})});
  }
catch (  PMException e) {
    PMExceptionHandler.handlePMExceptionForMasterSession(e);
  }
}","/** 
 * Adds the given eventHandlerInput to the given eventHandlerOwner  as an eventHandler.
 * @param eventHandlerInput the ISpecTestCasePO to be the EventHandler
 * @param evHandlerOwner the ISpecTestCasePO to own the EventHandler
 */
public void addEventHandler(ISpecTestCasePO eventHandlerInput,ISpecTestCasePO evHandlerOwner){
  final EditSupport editSupport=getEditorHelper().getEditSupport();
  ISpecTestCasePO workSpecTcPO=(ISpecTestCasePO)editSupport.getWorkVersion();
  ISpecTestCasePO eventHandlerInputPO=eventHandlerInput;
  IEventExecTestCasePO eventHandlerPO=null;
  try {
    ISpecTestCasePO eventHandlerWorkV=(ISpecTestCasePO)editSupport.createWorkVersion(eventHandlerInputPO);
    eventHandlerPO=NodeMaker.createEventExecTestCasePO(eventHandlerWorkV,workSpecTcPO);
    final int status=openAddEventHandlerDlg(evHandlerOwner,eventHandlerPO);
    if (Window.OK == status) {
      editSupport.lockWorkVersion();
      TestCaseBP.addEventHandler(editSupport,workSpecTcPO,eventHandlerPO);
      getEditorHelper().setDirty(true);
      DataEventDispatcher.getInstance().fireDataChangedListener(eventHandlerPO,DataState.Added,UpdateState.onlyInEditor);
    }
  }
 catch (  InvalidDataException e) {
    ErrorHandlingUtil.createMessageDialog(MessageIDs.E_DOUBLE_EVENT,null,new String[]{NLS.bind(Messages.TestCaseEditorDoubleEventTypeErrorDetail,new Object[]{evHandlerOwner.getName(),I18n.getString(eventHandlerPO.getEventType())})});
  }
catch (  PMException e) {
    PMExceptionHandler.handlePMExceptionForMasterSession(e);
  }
}",0.9855907780979828
95936,"@Override protected void refresh(){
  super.refresh();
  getEventHandlerTreeViewer().refresh(true);
}","@Override public void refresh(){
  super.refresh();
  getEventHandlerTreeViewer().refresh(true);
}",0.9447236180904522
95937,"/** 
 * {@inheritDoc}
 */
public void addPages(){
  super.addPages();
  Set<INodePO> specSet=new HashSet<INodePO>();
  for (Iterator iterator=m_setOfExecsToReplace.iterator(); iterator.hasNext(); ) {
    IExecTestCasePO exec=(IExecTestCasePO)iterator.next();
    specSet.add(exec.getParentNode());
  }
  m_choosePage=new ChooseTestCasePage(specSet,CHOOSE_PAGE_ID);
  addPage(m_choosePage);
}","/** 
 * {@inheritDoc}
 */
public void addPages(){
  super.addPages();
  Set<INodePO> specSet=new HashSet<INodePO>();
  for (Iterator iterator=m_setOfExecsToReplace.iterator(); iterator.hasNext(); ) {
    IExecTestCasePO exec=(IExecTestCasePO)iterator.next();
    if (ISpecTestCasePO.class.isAssignableFrom(exec.getParentNode().getClass())) {
      specSet.add(exec.getParentNode());
    }
  }
  m_choosePage=new ChooseTestCasePage(specSet,CHOOSE_PAGE_ID);
  addPage(m_choosePage);
}",0.865979381443299
95938,"/** 
 * Gets the index of the specific menu entry with the name
 * @param menu the menu in which all items are stored
 * @param name the name of the item we want the index from
 * @param operator the operator for the matching
 * @return the index for the specific menu entry
 */
protected int getIndexForName(IMenuComponent menu,String name,String operator){
  IMenuItemComponent[] subElements=menu.getItems();
  int downcount=0;
  for (int j=0; j < subElements.length; j++) {
    IMenuItemComponent tempMenu=(IMenuItemComponent)subElements[j];
    if (tempMenu.isSeparator()) {
      downcount++;
    }
    if (tempMenu.isShowing() && MatchUtil.getInstance().match(tempMenu.getText(),name,operator)) {
      return j - downcount;
    }
  }
  return Integer.MAX_VALUE;
}","/** 
 * Gets the index of the specific menu entry with the name
 * @param menu the menu in which all items are stored
 * @param name the name of the item we want the index from
 * @param operator the operator for the matching
 * @return the index for the specific menu entry
 */
protected int getIndexForName(IMenuComponent menu,String name,String operator){
  IMenuItemComponent[] subElements=menu.getItems();
  int ignoreElementCount=0;
  for (int j=0; j < subElements.length; j++) {
    IMenuItemComponent tempMenu=(IMenuItemComponent)subElements[j];
    if (!tempMenu.isShowing() || (tempMenu.isSeparator() && tempMenu.isShowing())) {
      ignoreElementCount++;
    }
    if (tempMenu.isShowing() && MatchUtil.getInstance().match(tempMenu.getText(),name,operator)) {
      return j - ignoreElementCount;
    }
  }
  return Integer.MAX_VALUE;
}",0.9221260815822002
95939,"/** 
 * Tries to select a menu item in a menu defined by a Text-Path
 * @param namePath the menu item to select
 * @param operator operator used for matching
 */
public void selectMenuItem(String namePath,final String operator){
  String[] menuItems=MenuUtilBase.splitPath(namePath);
  if (menuItems.length == 0) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError());
  }
  IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItems,operator);
  if (item == null) {
    try {
      closeMenu(getAndCheckMenu(),menuItems,operator);
    }
 catch (    StepExecutionException see) {
      getLog().info(""String_Node_Str"");
    }
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
  }
  item.selectMenuItem();
}","/** 
 * Tries to select a menu item in a menu defined by a Text-Path
 * @param namePath the menu item to select
 * @param operator operator used for matching
 */
public void selectMenuItem(String namePath,final String operator){
  String[] menuItems=MenuUtilBase.splitPath(namePath);
  if (menuItems.length == 0) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError());
  }
  IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItems,operator);
  if (item == null || item.getRealComponent() == null) {
    try {
      closeMenu(getAndCheckMenu(),menuItems,operator);
    }
 catch (    StepExecutionException see) {
      getLog().info(""String_Node_Str"");
    }
    throwMenuItemNotFound();
  }
  item.selectMenuItem();
}",0.8726355611601513
95940,"/** 
 * {@inheritDoc} 
 */
public void partOpened(IWorkbenchPartReference partRef){
  if (Constants.TC_BROWSER_ID.equals(partRef.getId())) {
    m_tcb.add(partRef);
    if (getOpenTCBs().size() > 0) {
      setMainTCB(getOpenTCBs().get(0));
    }
    fireStateChanged();
  }
}","/** 
 * {@inheritDoc} 
 */
public void partOpened(IWorkbenchPartReference partRef){
  if (partRef.getId().startsWith(Constants.TC_BROWSER_ID)) {
    m_tcb.add(partRef);
    if (getOpenTCBs().size() > 0) {
      setMainTCB(getOpenTCBs().get(0));
    }
    fireStateChanged();
  }
}",0.9100719424460432
95941,"/** 
 * {@inheritDoc} 
 */
public void partClosed(IWorkbenchPartReference partRef){
  if (Constants.TC_BROWSER_ID.equals(partRef.getId())) {
    m_tcb.remove(partRef);
    setMainTCB(getOpenTCBs().size() > 0 ? getOpenTCBs().get(0) : null);
    fireStateChanged();
  }
}","/** 
 * {@inheritDoc} 
 */
public void partClosed(IWorkbenchPartReference partRef){
  if (partRef.getId().startsWith(Constants.TC_BROWSER_ID)) {
    m_tcb.remove(partRef);
    setMainTCB(getOpenTCBs().size() > 0 ? getOpenTCBs().get(0) : null);
    fireStateChanged();
  }
}",0.9077490774907748
95942,"/** 
 * because of Persistence (JPA / EclipseLink)-Bug HHH-1280 we can't use refresh<br> therefore we use evict to remove the old object from master session and reload the object<br> please attend, that in this case the Java-IDs of the old and the reloaded object are different<br> refreshs the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(getWorkVersion());
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}","/** 
 * because of Persistence (JPA / EclipseLink)-Bug HHH-1280 we can't use refresh<br> therefore we use evict to remove the old object from master session and reload the object<br> please attend, that in this case the Java-IDs of the old and the reloaded object are different<br> refreshs the original versions, which were possibly modified in editor
 * @throws ProjectDeletedException if the project was deleted in another instance
 */
private void refreshOriginalVersions() throws ProjectDeletedException {
  try {
    final EntityManager masterSession=GeneralStorage.getInstance().getMasterSession();
    IPersistentObject original=getOriginal();
    if (original != null) {
      masterSession.refresh(original);
      GeneralStorage.getInstance().fireDataModified(original);
    }
  }
 catch (  PersistenceException e) {
    log.error(Messages.RefreshOfOriginalVersionFailed + StringConstants.DOT,e);
    GeneralStorage.getInstance().reloadMasterSession(new NullProgressMonitor());
  }
}",0.9879759519038076
95943,"/** 
 * {@inheritDoc}
 */
public Message execute(){
  log.info(""String_Node_Str"" + getClass().getName() + ""String_Node_Str"");
  List componentIds=new ArrayList();
  AUTServerConfiguration.getInstance().setProfile(m_message.getProfile());
  for (Iterator it=m_message.getComponents().iterator(); it.hasNext(); ) {
    Component component=(Component)it.next();
    if (!component.isConcrete()) {
      continue;
    }
    ConcreteComponent concrete=(ConcreteComponent)component;
    try {
      AUTServerConfiguration.getInstance().registerComponent(concrete);
      if (concrete.hasDefaultMapping()) {
        componentIds=addComponentID(componentIds,concrete);
      }
    }
 catch (    UnsupportedComponentException e) {
      log.error(""String_Node_Str"",e);
    }
catch (    IllegalArgumentException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"" + getClass().getName() + ""String_Node_Str"");
  return new AUTStartStateMessage(componentIds);
}","/** 
 * {@inheritDoc}
 */
public Message execute(){
  log.info(""String_Node_Str"" + getClass().getName() + ""String_Node_Str"");
  List componentIds=new ArrayList();
  AUTServerConfiguration.getInstance().setProfile(m_message.getProfile());
  for (Iterator it=m_message.getComponents().iterator(); it.hasNext(); ) {
    Component component=(Component)it.next();
    if (!component.isConcrete()) {
      continue;
    }
    ConcreteComponent concrete=(ConcreteComponent)component;
    try {
      String testerClass=concrete.getTesterClass();
      String componentClass=concrete.getComponentClass();
      if (!(StringUtils.isEmpty(testerClass) && StringUtils.isEmpty(componentClass))) {
        AUTServerConfiguration.getInstance().registerComponent(concrete);
      }
      if (concrete.hasDefaultMapping()) {
        componentIds=addComponentID(componentIds,concrete);
      }
    }
 catch (    UnsupportedComponentException e) {
      log.error(""String_Node_Str"",e);
    }
catch (    IllegalArgumentException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"" + getClass().getName() + ""String_Node_Str"");
  return new AUTStartStateMessage(componentIds);
}",0.9039704524469068
95944,"/** 
 * checks if any of the node has ReferencedDataCubes
 * @param selectionList the list to be checked
 * @return returns <code>true</code> if there is one PO with a refDataCube 
 */
private boolean hasRefDataCube(List<INodePO> selectionList){
  for (  INodePO selNode : selectionList) {
    List<INodePO> specTcs=new ArrayList<INodePO>();
    addCatChildren(selNode,specTcs);
    for (    INodePO spec : specTcs) {
      if (spec instanceof ISpecTestCasePO) {
        ISpecTestCasePO specTestCasePo=(ISpecTestCasePO)spec;
        if (specTestCasePo.getReferencedDataCube() != null) {
          return true;
        }
        Iterator<INodePO> execTcs=specTestCasePo.getNodeListIterator();
        while (execTcs.hasNext()) {
          INodePO exec=execTcs.next();
          IExecTestCasePO execTestCasePo=(IExecTestCasePO)exec;
          if (execTestCasePo.getReferencedDataCube() != null) {
            return true;
          }
        }
      }
    }
  }
  return false;
}","/** 
 * checks if any of the node has ReferencedDataCubes
 * @param selectionList the list to be checked
 * @return returns <code>true</code> if there is one PO with a refDataCube 
 */
private boolean hasRefDataCube(List<INodePO> selectionList){
  for (  INodePO selNode : selectionList) {
    List<INodePO> specTcs=new ArrayList<INodePO>();
    addCatChildren(selNode,specTcs);
    for (    INodePO spec : specTcs) {
      if (spec instanceof ISpecTestCasePO) {
        ISpecTestCasePO specTestCasePo=(ISpecTestCasePO)spec;
        if (specTestCasePo.getReferencedDataCube() != null) {
          return true;
        }
        Iterator<INodePO> execTcs=specTestCasePo.getNodeListIterator();
        while (execTcs.hasNext()) {
          INodePO exec=execTcs.next();
          if (exec instanceof IExecTestCasePO) {
            IExecTestCasePO execTestCasePo=(IExecTestCasePO)exec;
            if (execTestCasePo.getReferencedDataCube() != null) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}",0.9658922392486406
95945,"/** 
 * Checks if the specified menu item is enabled.
 * @param menuItem the menu item to verify against
 * @param enabled is the specified menu item enabled?
 */
public void verifyEnabledByIndexpath(int[] menuItem,boolean enabled){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem);
  checkIsNull(item);
  try {
    Verifier.equals(enabled,item.isEnabled());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem);
  }
}","/** 
 * Checks if the specified menu item is enabled.
 * @param menuItem the menu item to verify against
 * @param enabled is the specified menu item enabled?
 */
public void verifyEnabledByIndexpath(int[] menuItem,boolean enabled){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem);
  try {
    checkIsNull(item);
    Verifier.equals(enabled,item.isEnabled());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem);
  }
}",0.9816326530612244
95946,"/** 
 * Checks if the specified menu item is enabled.
 * @param menuItem the menu item to verify against
 * @param operator operator used for matching
 * @param enabled is the specified menu item enabled?
 */
public void verifyEnabled(String[] menuItem,String operator,boolean enabled){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem,operator);
  checkIsNull(item);
  try {
    Verifier.equals(enabled,item.isEnabled());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem,operator);
  }
}","/** 
 * Checks if the specified menu item is enabled.
 * @param menuItem the menu item to verify against
 * @param operator operator used for matching
 * @param enabled is the specified menu item enabled?
 */
public void verifyEnabled(String[] menuItem,String operator,boolean enabled){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem,operator);
  try {
    checkIsNull(item);
    Verifier.equals(enabled,item.isEnabled());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem,operator);
  }
}",0.9839857651245552
95947,"/** 
 * Checks if the specified menu item is selected.
 * @param menuItem the menu item to verify against
 * @param operator operator used for matching
 * @param selected is the specified menu item selected?
 */
public void verifySelected(String[] menuItem,String operator,boolean selected){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem,operator);
  checkIsNull(item);
  try {
    Verifier.equals(selected,item.isSelected());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem,operator);
  }
}","/** 
 * Checks if the specified menu item is selected.
 * @param menuItem the menu item to verify against
 * @param operator operator used for matching
 * @param selected is the specified menu item selected?
 */
public void verifySelected(String[] menuItem,String operator,boolean selected){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem,operator);
  try {
    checkIsNull(item);
    Verifier.equals(selected,item.isSelected());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem,operator);
  }
}",0.984182776801406
95948,"/** 
 * Checks if the specified menu item is selected.
 * @param menuItem the menu item to verify against
 * @param selected is the specified menu item selected?
 */
public void verifySelectedByIndexpath(int[] menuItem,boolean selected){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem);
  checkIsNull(item);
  try {
    Verifier.equals(selected,item.isSelected());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem);
  }
}","/** 
 * Checks if the specified menu item is selected.
 * @param menuItem the menu item to verify against
 * @param selected is the specified menu item selected?
 */
public void verifySelectedByIndexpath(int[] menuItem,boolean selected){
  checkPathLength(menuItem.length);
  final IMenuItemComponent item=navigateToMenuItem(getAndCheckMenu(),menuItem);
  try {
    checkIsNull(item);
    Verifier.equals(selected,item.isSelected());
  }
  finally {
    closeMenu(getAndCheckMenu(),menuItem);
  }
}",0.9818913480885312
95949,"/** 
 * executes the right update
 * @param event int
 * @param obj Obbject
 */
private void switchEvent(int event,Object obj){
switch (event) {
case IObjectMappingObserver.EVENT_STEP_RECORDED:
    IAUTMainPO aut=(IAUTMainPO)obj;
  if (getAut() == aut) {
    cleanupNames();
  }
break;
case IObjectMappingObserver.EVENT_COMPONENT_MAPPED:
IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
if (getAut().equals(connectedAut)) {
IComponentIdentifier[] comp=(IComponentIdentifier[])obj;
createNewTechnicalNames(comp);
}
break;
default :
}
}","/** 
 * executes the right update
 * @param event int
 * @param obj Object
 */
private void switchEvent(int event,Object obj){
switch (event) {
case IObjectMappingObserver.EVENT_STEP_RECORDED:
    IAUTMainPO aut=(IAUTMainPO)obj;
  if (getAut() == aut) {
    cleanupNames();
  }
break;
case IObjectMappingObserver.EVENT_COMPONENT_MAPPED:
IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
if (getAut().equals(connectedAut)) {
IComponentIdentifier[] comp=(IComponentIdentifier[])obj;
createNewTechnicalNames(comp);
}
break;
default :
}
}",0.9990999099909992
95950,"/** 
 * {@inheritDoc}
 */
public void dispose(){
  getEditorSite().getActionBars().setGlobalActionHandler(ActionFactory.REFRESH.getId(),null);
  IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
  if (AUTModeChangedCommand.getAutMode() == ChangeAUTModeMessage.OBJECT_MAPPING && connectedAut != null && connectedAut.equals(getAut())) {
    TestExecutionContributor.getInstance().getClientTest().resetToTesting();
    DataEventDispatcher.getInstance().fireOMStateChanged(OMState.notRunning);
  }
  ObjectMappingEventDispatcher.removeObserver(this);
  getSite().setSelectionProvider(null);
  GuiEventDispatcher.getInstance().removeEditorDirtyStateListener(this);
  m_treeViewerUpdater=null;
  if (m_editorHelper != null) {
    m_editorHelper.dispose();
  }
  super.dispose();
}","/** 
 * {@inheritDoc}
 */
public void dispose(){
  ObjectMappingEventDispatcher.removeObserver(this);
  getEditorSite().getActionBars().setGlobalActionHandler(ActionFactory.REFRESH.getId(),null);
  IAUTMainPO connectedAut=TestExecution.getInstance().getConnectedAut();
  if (AUTModeChangedCommand.getAutMode() == ChangeAUTModeMessage.OBJECT_MAPPING && connectedAut != null && connectedAut.equals(getAut())) {
    TestExecutionContributor.getInstance().getClientTest().resetToTesting();
    DataEventDispatcher.getInstance().fireOMStateChanged(OMState.notRunning);
  }
  getSite().setSelectionProvider(null);
  GuiEventDispatcher.getInstance().removeEditorDirtyStateListener(this);
  m_treeViewerUpdater=null;
  if (m_editorHelper != null) {
    m_editorHelper.dispose();
  }
  super.dispose();
}",0.9333333333333332
95951,"/** 
 * {@inheritDoc}
 */
protected Object setEditorToReplaceMode(Object editor,boolean replace){
  if (replace) {
    getRobot().clickAtCurrentPosition(editor,3,InputConstants.MOUSE_BUTTON_LEFT);
  }
 else {
    getRobot().clickAtCurrentPosition(editor,2,InputConstants.MOUSE_BUTTON_LEFT);
  }
  return editor;
}","/** 
 * {@inheritDoc}
 */
protected Object setEditorToReplaceMode(Object editor,boolean replace){
  if (replace) {
    ITextComponentAdapter textEditor=null;
    if (editor instanceof Text) {
      textEditor=new TextComponentAdapter(editor);
    }
    if (editor instanceof StyledText) {
      textEditor=new StyledTextAdapter(editor);
    }
    if (EnvironmentUtils.isMacOS()) {
      getRobot().clickAtCurrentPosition(editor,3,InputConstants.MOUSE_BUTTON_LEFT);
    }
 else {
      getRobot().keyStroke(getRobot().getSystemModifierSpec() + ""String_Node_Str"");
    }
    if (textEditor != null) {
      if (!textEditor.getSelectionText().equals(textEditor.getText())) {
        textEditor.selectAll();
      }
    }
  }
 else {
    getRobot().clickAtCurrentPosition(editor,2,InputConstants.MOUSE_BUTTON_LEFT);
  }
  return editor;
}",0.5457715780296426
95952,"/** 
 * Must be called to initialize the registration of adapters
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
public static void initRegistration(){
  Class[] adapterFactories=findClassesOfType(ADAPTER_PACKAGE_NAME,IAdapterFactory.class);
  for (int i=0; i < adapterFactories.length; i++) {
    try {
      IAdapterFactory factory=(IAdapterFactory)adapterFactories[i].newInstance();
      getInstance().registerFactory(factory);
    }
 catch (    IllegalAccessException e) {
      log.error(e.getLocalizedMessage(),e);
    }
catch (    InstantiationException e) {
      log.error(e.getLocalizedMessage(),e);
    }
  }
}","/** 
 * Use this method outside of eclipse environments. Must be called to initialize the registration of adapters. This method directly calls   {@link AdapterFactoryRegistry#initRegistration(IUrlLocator)} withthe  {@link DefaultUrlLocator}.
 */
public static void initRegistration(){
  initRegistration(new DefaultUrlLocator());
}",0.2453987730061349
95953,"/** 
 * Investigate a package of subclasses of a specific superclass
 * @param packageName name of the package
 * @param superclass parent class for found classes
 * @return found classes
 */
private static Class[] findClassesOfType(String packageName,Class superclass){
  try {
    Class[] allClasses=getClasses(packageName);
    List assignableClasses=new ArrayList();
    for (int i=0; i < allClasses.length; i++) {
      if (superclass.isAssignableFrom(allClasses[i]) && superclass != allClasses[i]) {
        assignableClasses.add(allClasses[i]);
      }
    }
    return castListToClassArray(assignableClasses);
  }
 catch (  ClassNotFoundException e) {
    return new Class[0];
  }
catch (  IOException e) {
    return new Class[0];
  }
}","/** 
 * Investigate a package of subclasses of a specific superclass
 * @param urlLocator The URL location converter needed in eclipse environments.
 * @param packageName name of the package
 * @param superclass parent class for found classes
 * @return found classes
 */
private static Class[] findClassesOfType(IUrlLocator urlLocator,String packageName,Class superclass){
  try {
    Class[] allClasses=getClasses(urlLocator,packageName);
    List assignableClasses=new ArrayList();
    for (int i=0; i < allClasses.length; i++) {
      if (superclass.isAssignableFrom(allClasses[i]) && superclass != allClasses[i]) {
        assignableClasses.add(allClasses[i]);
      }
    }
    return castListToClassArray(assignableClasses);
  }
 catch (  ClassNotFoundException e) {
    return new Class[0];
  }
catch (  IOException e) {
    return new Class[0];
  }
}",0.928927680798005
95954,"/** 
 * Scans all classes accessible from the context class loader which belong to the given package and subpackages.
 * @param packageName The base package
 * @return The classes
 * @throws ClassNotFoundException
 * @throws IOException
 */
private static Class[] getClasses(String packageName) throws ClassNotFoundException, IOException {
  ClassLoader classLoader=AdapterFactoryRegistry.class.getClassLoader();
  String path=packageName.replace('.','/');
  Enumeration resources=classLoader.getResources(path);
  List dirs=new ArrayList();
  while (resources.hasMoreElements()) {
    URL resource=(URL)resources.nextElement();
    dirs.add(resource);
  }
  List classes=new ArrayList();
  for (int i=0; i < dirs.size(); i++) {
    if (dirs.get(i).toString().startsWith(""String_Node_Str"")) {
      classes.addAll(findClassesInJar((URL)dirs.get(i),packageName));
    }
 else {
      classes.addAll(findClasses((URL)dirs.get(i),packageName));
    }
  }
  return castListToClassArray(classes);
}","/** 
 * Scans all classes accessible from the context class loader which belong to the given package and sub packages.
 * @param urlLocator The URL location converter needed in eclipse environments.
 * @param packageName The base package
 * @return The classes
 * @throws ClassNotFoundException
 * @throws IOException
 */
private static Class[] getClasses(IUrlLocator urlLocator,String packageName) throws ClassNotFoundException, IOException {
  ClassLoader classLoader=AdapterFactoryRegistry.class.getClassLoader();
  String path=packageName.replace('.','/');
  Enumeration resources=classLoader.getResources(path);
  List dirs=new ArrayList();
  while (resources.hasMoreElements()) {
    URL resource=(URL)resources.nextElement();
    try {
      resource=urlLocator.convertUrl(resource);
      dirs.add(resource);
    }
 catch (    IOException e) {
      log.error(e.getLocalizedMessage(),e);
    }
  }
  List classes=new ArrayList();
  for (int i=0; i < dirs.size(); i++) {
    if (dirs.get(i).toString().startsWith(""String_Node_Str"")) {
      classes.addAll(findClassesInJar((URL)dirs.get(i),packageName));
    }
 else {
      classes.addAll(findClasses((URL)dirs.get(i),packageName));
    }
  }
  return castListToClassArray(classes);
}",0.8715883668903803
95955,"/** 
 * Sign off adapter factory from all its supported classes
 * @param factory adapter factory that should be signed off
 */
public void signOffFactory(IAdapterFactory factory){
  Class[] supportedClasses=factory.getSupportedClasses();
  for (int i=0; i < supportedClasses.length; i++) {
    Collection registeredFactories=(Collection)m_registrationMap.get(supportedClasses[i]);
    if (registeredFactories == null) {
      return;
    }
    registeredFactories.remove(factory);
    m_registrationMap.put(supportedClasses[i],registeredFactories);
  }
}","/** 
 * Sign off adapter factory from all its supported classes
 * @param factory adapter factory that should be signed off
 */
public void signOffFactory(IAdapterFactory factory){
  Class[] supportedClasses=factory.getSupportedClasses();
  for (int i=0; i < supportedClasses.length; i++) {
    final Class supportedClass=supportedClasses[i];
    Collection registeredFactories=(Collection)m_registrationMap.get(supportedClass);
    if (registeredFactories == null) {
      return;
    }
    registeredFactories.remove(factory);
    m_registrationMap.remove(supportedClass);
  }
}",0.8951541850220265
95956,"/** 
 * {@inheritDoc}
 */
public void stateChanged(TestExecutionEvent event){
  if (event.getException() != null && event.getException() instanceof JBException) {
    String errorMsg=I18n.getString(event.getException().getMessage(),true);
    AbstractCmdlineClient.printlnConsoleError(errorMsg);
  }
switch (event.getState()) {
case TestExecutionEvent.TEST_EXEC_RESULT_TREE_READY:
    TestExecution.getInstance().getTrav().addExecStackModificationListener(m_progress);
  break;
case TestExecutionEvent.TEST_EXEC_START:
case TestExecutionEvent.TEST_EXEC_RESTART:
break;
case TestExecutionEvent.TEST_EXEC_FINISHED:
AbstractCmdlineClient.printConsoleLn(Messages.ExecutionControllerTestSuiteEnd,true);
m_job.getNextTestSuite();
m_clcServiceImpl.tsDone(isNoErrorWhileExecution() ? 0 : 1);
break;
case TestExecutionEvent.TEST_EXEC_PAUSED:
TestExecution.getInstance().pauseExecution(PauseMode.UNPAUSE);
break;
case TestExecutionEvent.TEST_EXEC_ERROR:
case TestExecutionEvent.TEST_EXEC_FAILED:
case TestExecutionEvent.TEST_EXEC_STOP:
m_job.getNextTestSuite();
break;
default :
break;
}
}","/** 
 * {@inheritDoc}
 */
public void stateChanged(TestExecutionEvent event){
  if (event.getException() != null && event.getException() instanceof JBException) {
    String errorMsg=I18n.getString(event.getException().getMessage(),true);
    AbstractCmdlineClient.printlnConsoleError(errorMsg);
    stopProcessing();
  }
switch (event.getState()) {
case TestExecutionEvent.TEST_EXEC_RESULT_TREE_READY:
    TestExecution.getInstance().getTrav().addExecStackModificationListener(m_progress);
  break;
case TestExecutionEvent.TEST_EXEC_START:
case TestExecutionEvent.TEST_EXEC_RESTART:
break;
case TestExecutionEvent.TEST_EXEC_FINISHED:
AbstractCmdlineClient.printConsoleLn(Messages.ExecutionControllerTestSuiteEnd,true);
m_job.getNextTestSuite();
m_clcServiceImpl.tsDone(isNoErrorWhileExecution() ? 0 : 1);
break;
case TestExecutionEvent.TEST_EXEC_PAUSED:
TestExecution.getInstance().pauseExecution(PauseMode.UNPAUSE);
break;
case TestExecutionEvent.TEST_EXEC_ERROR:
case TestExecutionEvent.TEST_EXEC_FAILED:
case TestExecutionEvent.TEST_EXEC_STOP:
m_job.getNextTestSuite();
break;
default :
break;
}
}",0.989908256880734
95957,"/** 
 * cleanup of connection
 */
protected void shutdown(){
  try {
    if (!AutAgentConnection.getInstance().isConnected()) {
      printlnConsoleError(Messages.ConnectionToAutUnexpectedly);
    }
  }
 catch (  ConnectionException e) {
    log.info(Messages.ConnectionToAutUnexpectedly,e);
  }
  IAUTConfigPO startedConfig=m_job.getAutConfig();
  if (startedConfig != null) {
    try {
      AutIdentifier startedAutId=new AutIdentifier(startedConfig.getConfigMap().get(AutConfigConstants.AUT_ID));
      if (AutAgentConnection.getInstance().isConnected()) {
        ClientTestFactory.getClientTest().stopAut(startedAutId);
      }
    }
 catch (    ConnectionException e) {
      log.info(Messages.ErrorWhileShuttingDownStopping,e);
    }
  }
  try {
    while (AutAgentConnection.getInstance().isConnected()) {
      ClientTestFactory.getClientTest().disconnectFromAutAgent();
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException e) {
      }
    }
  }
 catch (  ConnectionException e) {
    log.info(Messages.ErrorWhileShuttingDownDisconnecting,e);
  }
  if (LockManager.isRunning()) {
    LockManager.instance().dispose();
  }
}","/** 
 * cleanup of connection
 */
protected void shutdown(){
  try {
    if (!AutAgentConnection.getInstance().isConnected()) {
      printlnConsoleError(Messages.ConnectionToAutUnexpectedly);
    }
  }
 catch (  ConnectionException e) {
    log.info(Messages.ConnectionToAutUnexpectedly,e);
  }
  IAUTConfigPO startedConfig=m_job.getAutConfig();
  if (startedConfig != null) {
    try {
      AutIdentifier startedAutId=new AutIdentifier(startedConfig.getConfigMap().get(AutConfigConstants.AUT_ID));
      if (AutAgentConnection.getInstance().isConnected()) {
        ClientTestFactory.getClientTest().stopAut(startedAutId);
      }
    }
 catch (    ConnectionException e) {
      log.info(Messages.ErrorWhileShuttingDownStopping,e);
    }
  }
  try {
    while (AutAgentConnection.getInstance().isConnected()) {
      ClientTestFactory.getClientTest().disconnectFromAutAgent();
      TimeUtil.delay(200);
    }
  }
 catch (  ConnectionException e) {
    log.info(Messages.ErrorWhileShuttingDownDisconnecting,e);
  }
  if (LockManager.isRunning()) {
    LockManager.instance().dispose();
  }
}",0.9477413640389726
95958,"/** 
 * Set the component name of a tool bar. Calls   {@link #setComponentName(Widget,String)}with appending the suffix tool bar to the finalPartId.
 * @param partToolbar The part of the tool bar.
 * @param finalPartId The ID for the part of the tool bar.
 */
public static void setToolbarComponentName(Widget partToolbar,String finalPartId){
  RcpSwtComponentNamer.setToolbarComponentName(partToolbar,finalPartId + TOOLBAR_ID_SUFFIX);
}","/** 
 * Set the component name of a tool bar. Calls   {@link #setComponentName(Widget,String)}with appending the suffix tool bar to the finalPartId.
 * @param partToolbar The part of the tool bar.
 * @param finalPartId The ID for the part of the tool bar.
 */
public static void setToolbarComponentName(Widget partToolbar,String finalPartId){
  setComponentName(partToolbar,finalPartId + TOOLBAR_ID_SUFFIX);
}",0.9598108747044918
95959,"/** 
 * Gets the implementation class. 
 * @param response The response message.
 * @return the implementation class or null if an error occurs.
 */
protected Object getImplClass(CAPTestResponseMessage response){
  Object implClass=null;
  IComponentIdentifier ci=m_capTestMessage.getMessageCap().getCi();
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + (ci == null ? ""String_Node_Str"" : ci.getComponentClassName()));
  }
  try {
    Validate.notNull(ci);
    int timeout=500;
    boolean isWaitForComponent=m_capTestMessage.getMessageCap().getMethod().equals(""String_Node_Str"");
    if (isWaitForComponent) {
      MessageParam timeoutParam=(MessageParam)m_capTestMessage.getMessageCap().getMessageParams().get(0);
      try {
        timeout=Integer.parseInt(timeoutParam.getValue());
      }
 catch (      NumberFormatException e) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    Object component=findComponent(ci,timeout);
    implClass=AUTServerConfiguration.getInstance().prepareImplementationClass(component,component.getClass());
    if (isWaitForComponent) {
      MessageParam delayParam=(MessageParam)m_capTestMessage.getMessageCap().getMessageParams().get(1);
      try {
        int delay=Integer.parseInt(delayParam.getValue());
        TimeUtil.delay(delay);
      }
 catch (      IllegalArgumentException iae) {
        handleInvalidInput(""String_Node_Str"" + CompSystemI18n.getString(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalArgumentException e) {
    handleComponentNotFound(response,e);
  }
catch (  ComponentNotFoundException e) {
    MessageCap cap=m_capTestMessage.getMessageCap();
    if (""String_Node_Str"".equals(cap.getMethod())) {
      MessageParam isVisibleParam=(MessageParam)cap.getMessageParams().get(0);
      handleComponentDoesNotExist(response,Boolean.valueOf(isVisibleParam.getValue()).booleanValue());
    }
 else {
      handleComponentNotFound(response,e);
    }
  }
catch (  UnsupportedComponentException buce) {
    LOG.error(buce.getLocalizedMessage(),buce);
    response.setTestErrorEvent(EventFactory.createConfigErrorEvent());
  }
catch (  Throwable e) {
    if (LOG.isErrorEnabled()) {
      LOG.error(e.getLocalizedMessage(),e);
    }
    response.setTestErrorEvent(EventFactory.createImplClassErrorEvent());
  }
  return implClass;
}","/** 
 * Gets the implementation class. 
 * @param response The response message.
 * @return the implementation class or null if an error occurs.
 */
protected Object getImplClass(CAPTestResponseMessage response){
  Object implClass=null;
  final MessageCap messageCap=m_capTestMessage.getMessageCap();
  IComponentIdentifier ci=messageCap.getCi();
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + (ci == null ? ""String_Node_Str"" : ci.getComponentClassName()));
  }
  try {
    Validate.notNull(ci);
    int timeout=500;
    boolean isWaitForComponent=WidgetTester.RC_METHOD_NAME_WAIT_FOR_COMPONENT.equals(messageCap.getMethod());
    if (isWaitForComponent) {
      MessageParam timeoutParam=(MessageParam)messageCap.getMessageParams().get(0);
      try {
        timeout=Integer.parseInt(timeoutParam.getValue());
      }
 catch (      NumberFormatException e) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    Object component=findComponent(ci,timeout);
    implClass=AUTServerConfiguration.getInstance().prepareImplementationClass(component,component.getClass());
    if (isWaitForComponent) {
      MessageParam delayParam=(MessageParam)messageCap.getMessageParams().get(1);
      try {
        int delay=Integer.parseInt(delayParam.getValue());
        TimeUtil.delay(delay);
      }
 catch (      IllegalArgumentException iae) {
        handleInvalidInput(""String_Node_Str"" + CompSystemI18n.getString(""String_Node_Str"") + ""String_Node_Str"");
      }
    }
  }
 catch (  IllegalArgumentException e) {
    handleComponentNotFound(response,e);
  }
catch (  ComponentNotFoundException e) {
    if (WidgetTester.RC_METHOD_NAME_CHECK_EXISTENCE.equals(messageCap.getMethod())) {
      MessageParam isVisibleParam=(MessageParam)messageCap.getMessageParams().get(0);
      handleComponentDoesNotExist(response,Boolean.valueOf(isVisibleParam.getValue()).booleanValue());
    }
 else {
      handleComponentNotFound(response,e);
    }
  }
catch (  UnsupportedComponentException buce) {
    LOG.error(buce.getLocalizedMessage(),buce);
    response.setTestErrorEvent(EventFactory.createConfigErrorEvent());
  }
catch (  Throwable e) {
    if (LOG.isErrorEnabled()) {
      LOG.error(e.getLocalizedMessage(),e);
    }
    response.setTestErrorEvent(EventFactory.createImplClassErrorEvent());
  }
  return implClass;
}",0.905307855626327
95960,"/** 
 * Expands or collapses the passed tree node. If the node is already  expanded or collapsed, respectively, nothing happens.  {@inheritDoc}
 */
public boolean operate(final Object treeNode) throws StepExecutionException {
  if (isCollapse()) {
    getContext().collapseNode(treeNode);
  }
 else {
    getContext().expandNode(treeNode);
  }
  return true;
}","/** 
 * Expands or collapses the passed tree node. If the node is already  expanded or collapsed, respectively, nothing happens.  {@inheritDoc}
 */
public boolean operate(final Object treeNode) throws StepExecutionException {
  final AbstractTreeOperationContext context=getContext();
  if (context.getNumberOfChildren(treeNode) > 0) {
    if (isCollapse()) {
      context.collapseNode(treeNode);
    }
 else {
      context.expandNode(treeNode);
    }
  }
  return true;
}",0.7769784172661871
95961,"/** 
 * Imports a choosed project from a file.
 * @param elements What to import ? 0 = all >0 = elements
 * @param fileURLs The URLs of the files to import.
 * @param openProject Flag indicating whether the imported project should be  immediately opened after import.
 */
public void importProject(final int elements,final List<URL> fileURLs,final boolean openProject){
  try {
    if (fileURLs == null) {
      return;
    }
    AbstractRunnableWithProgress<IProjectPO> importProjectRunnable=new AbstractRunnableWithProgress<IProjectPO>(){
      public void run(      IProgressMonitor monitor) throws InterruptedException {
        monitor.setTaskName(Messages.ImportFileBPWaitWhileImporting);
        try {
          setResult(FileStorageBP.importProject(elements,fileURLs,monitor,Plugin.getDefault(),openProject));
        }
 catch (        PMException pme) {
          PMExceptionHandler.handlePMExceptionForMasterSession(pme);
        }
catch (        ProjectDeletedException gdpde) {
          PMExceptionHandler.handleGDProjectDeletedException();
        }
      }
    }
;
    PlatformUI.getWorkbench().getProgressService().busyCursorWhile(importProjectRunnable);
    final IProjectPO projectToOpen=importProjectRunnable.getResult();
    if (projectToOpen != null) {
      OpenProjectOperation openOp=new OpenProjectHandler.OpenProjectOperation(projectToOpen);
      try {
        PlatformUI.getWorkbench().getProgressService().busyCursorWhile(openOp);
      }
 catch (      InvocationTargetException ite) {
        log.error(Messages.ErrorOccurredDuringImport,ite.getCause());
        openOp.handleOperationException();
      }
catch (      InterruptedException e) {
        openOp.handleOperationException();
      }
    }
  }
 catch (  InvocationTargetException ite) {
    log.error(Messages.ErrorOccurredDuringImport,ite.getCause());
  }
catch (  InterruptedException e) {
    showCancelImport(Plugin.getDefault());
  }
 finally {
    Plugin.stopLongRunning();
  }
}","/** 
 * Imports a choosed project from a file.
 * @param elements What to import ? 0 = all >0 = elements
 * @param fileURLs The URLs of the files to import.
 * @param openProject Flag indicating whether the imported project should be  immediately opened after import.
 */
public void importProject(final int elements,final List<URL> fileURLs,final boolean openProject){
  try {
    if (fileURLs == null) {
      return;
    }
    AbstractRunnableWithProgress<IProjectPO> importProjectRunnable=new AbstractRunnableWithProgress<IProjectPO>(){
      public void run(      IProgressMonitor monitor) throws InterruptedException {
        monitor.setTaskName(Messages.ImportFileBPWaitWhileImporting);
        try {
          setResult(FileStorageBP.importProject(elements,fileURLs,monitor,Plugin.getDefault(),openProject));
          Persistor.instance().updateDbStatistics();
        }
 catch (        PMException pme) {
          PMExceptionHandler.handlePMExceptionForMasterSession(pme);
        }
catch (        ProjectDeletedException gdpde) {
          PMExceptionHandler.handleGDProjectDeletedException();
        }
      }
    }
;
    PlatformUI.getWorkbench().getProgressService().busyCursorWhile(importProjectRunnable);
    final IProjectPO projectToOpen=importProjectRunnable.getResult();
    if (projectToOpen != null) {
      OpenProjectOperation openOp=new OpenProjectHandler.OpenProjectOperation(projectToOpen);
      try {
        PlatformUI.getWorkbench().getProgressService().busyCursorWhile(openOp);
      }
 catch (      InvocationTargetException ite) {
        log.error(Messages.ErrorOccurredDuringImport,ite.getCause());
        openOp.handleOperationException();
      }
catch (      InterruptedException e) {
        openOp.handleOperationException();
      }
    }
  }
 catch (  InvocationTargetException ite) {
    log.error(Messages.ErrorOccurredDuringImport,ite.getCause());
  }
catch (  InterruptedException e) {
    showCancelImport(Plugin.getDefault());
  }
 finally {
    Plugin.stopLongRunning();
  }
}",0.9867731469927626
95962,"/** 
 * {@inheritDoc} 
 */
public void setSelection(ISelection selection){
  ISelection newSelection=getMainTreeViewer().getSelection();
  if (selection instanceof StructuredSelection) {
    Object firstElement=((StructuredSelection)selection).getFirstElement();
    if (firstElement instanceof INodePO) {
      INodePO node=(INodePO)firstElement;
      final IPersistentObject editorRoot=getWorkVersion();
      if (editorRoot.getId().equals(node.getId())) {
        newSelection=new StructuredSelection(editorRoot);
      }
 else {
        Iterator<? extends INodePO> nodeListIterator=getIteratorForNode(node);
        while (nodeListIterator.hasNext()) {
          INodePO child=nodeListIterator.next();
          if (node.getId().equals(child.getId())) {
            newSelection=new StructuredSelection(child);
            break;
          }
        }
      }
    }
  }
  setSelectionImpl(newSelection);
}","/** 
 * {@inheritDoc} 
 */
public void setSelection(ISelection selection){
  ISelection newSelection=getMainTreeViewer().getSelection();
  if (selection instanceof StructuredSelection) {
    Object firstElement=((StructuredSelection)selection).getFirstElement();
    if (firstElement instanceof INodePO) {
      INodePO node=(INodePO)firstElement;
      final IPersistentObject editorRoot=getWorkVersion();
      if (editorRoot.getId().equals(node.getId())) {
        newSelection=new StructuredSelection(editorRoot);
      }
 else {
        Iterator<? extends INodePO> nodeListIterator=getIteratorForNode(node);
        while (nodeListIterator.hasNext()) {
          INodePO child=nodeListIterator.next();
          if (node.getGuid().equals(child.getGuid())) {
            newSelection=new StructuredSelection(child);
            break;
          }
        }
      }
    }
  }
  setSelectionImpl(newSelection);
}",0.9956140350877192
95963,"/** 
 * @param objectToAdapt 
 * @return -
 */
public IComponentAdapter getAdapter(Object objectToAdapt){
  Class adapteeclass=objectToAdapt.getClass();
  IUIAdapterFactory factory=(IUIAdapterFactory)m_registrationMap.get(adapteeclass);
  Class superclass=adapteeclass;
  while (factory == null && superclass != Object.class) {
    factory=(IUIAdapterFactory)m_registrationMap.get(superclass);
    superclass=superclass.getSuperclass();
  }
  return factory.getAdapter(objectToAdapt);
}","/** 
 * @param objectToAdapt 
 * @return -
 */
public IComponentAdapter getAdapter(Object objectToAdapt){
  Class adapteeclass=objectToAdapt.getClass();
  IUIAdapterFactory factory=(IUIAdapterFactory)m_registrationMap.get(adapteeclass);
  Class superclass=adapteeclass;
  while (factory == null && superclass != Object.class) {
    factory=(IUIAdapterFactory)m_registrationMap.get(superclass);
    superclass=superclass.getSuperclass();
  }
  if (factory != null) {
    return factory.getAdapter(objectToAdapt);
  }
  return null;
}",0.9410609037328096
95964,"/** 
 * Use this to handle the Highlighting after a Click.
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 */
protected void highlightClicked(final Object implClass,final Color highlightColor){
  Timer timer=new Timer(REPAINT_DELAY,new ActionListener(){
    public void actionPerformed(    ActionEvent e){
synchronized (getComponentLock()) {
        if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
          Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
          ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
          setHighLighted(true);
        }
      }
    }
  }
);
  timer.setRepeats(false);
  timer.start();
}","/** 
 * Use this to handle the Highlighting after a Click.
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 */
protected void highlightClicked(final Object implClass,final Color highlightColor){
  Timer timer=new Timer(REPAINT_DELAY,new ActionListener(){
    public void actionPerformed(    ActionEvent e){
synchronized (getComponentLock()) {
        if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
          try {
            AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
            TesterUtil.highLight(getCurrentComponent(),highlightColor);
          }
 catch (          IllegalArgumentException iae) {
            log.error(""String_Node_Str"",iae);
          }
catch (          UnsupportedComponentException uce) {
          }
        }
      }
    }
  }
);
  timer.setRepeats(false);
  timer.start();
}",0.6334797462176671
95965,"/** 
 * Handles the High-/Lowlighting.<br> When High-/LowLighting afer a click use highlightClicked.
 * @param source Component
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 * @see AbstractGDAutSwingEventListener#highlightClicked(Object,Color)
 */
protected void highlight(Component source,final Object implClass,final Color highlightColor){
  Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(source);
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent() != source) {
      ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class},new Object[]{getCurrentComponent()});
      setHighLighted(false);
    }
    setCurrentComponent(source);
    Window windowAncestor=SwingUtilities.getWindowAncestor(getCurrentComponent());
    if (windowAncestor != null && windowAncestor.getFocusOwner() != null) {
      ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      setHighLighted(true);
    }
  }
}","/** 
 * Handles the High-/Lowlighting.<br> When High-/LowLighting afer a click use highlightClicked.
 * @param source Component
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 * @see AbstractGDAutSwingEventListener#highlightClicked(Object,Color)
 */
protected void highlight(Component source,final Object implClass,final Color highlightColor){
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent() != source) {
      TesterUtil.lowLight(getCurrentComponent());
      setHighLighted(false);
    }
    setCurrentComponent(source);
    Window windowAncestor=SwingUtilities.getWindowAncestor(getCurrentComponent());
    if (windowAncestor != null && windowAncestor.getFocusOwner() != null) {
      try {
        AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
        TesterUtil.highLight(getCurrentComponent(),highlightColor);
        setHighLighted(true);
      }
 catch (      IllegalArgumentException e) {
        log.error(""String_Node_Str"",e);
      }
catch (      UnsupportedComponentException e) {
      }
    }
  }
}",0.4654032613486117
95966,"public void actionPerformed(ActionEvent e){
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
      Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
      ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      setHighLighted(true);
    }
  }
}","public void actionPerformed(ActionEvent e){
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
      try {
        AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
        TesterUtil.highLight(getCurrentComponent(),highlightColor);
      }
 catch (      IllegalArgumentException iae) {
        log.error(""String_Node_Str"",iae);
      }
catch (      UnsupportedComponentException uce) {
      }
    }
  }
}",0.5445935280189423
95967,"/** 
 * This method is called by the AUTServer AFTER this instance is removed as AWTEventListener for cleaning up purpose. <br> low lights the last hight lighted component.
 */
public void cleanUp(){
synchronized (m_componentLock) {
    if (getCurrentComponent() != null) {
      try {
        Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
        if (adapter != null) {
          ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class},new Object[]{m_currentComponent});
          setHighLighted(false);
        }
      }
 catch (      IllegalArgumentException iae) {
        log.error(iae);
      }
    }
  }
}","/** 
 * This method is called by the AUTServer AFTER this instance is removed as AWTEventListener for cleaning up purpose. <br> low lights the last hight lighted component.
 */
public void cleanUp(){
synchronized (m_componentLock) {
    if (getCurrentComponent() != null) {
      try {
        AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
        TesterUtil.lowLight(m_currentComponent);
      }
 catch (      IllegalArgumentException iae) {
        log.error(iae);
      }
catch (      UnsupportedComponentException uce) {
        log.warn(uce);
      }
    }
  }
}",0.6160919540229886
95968,"/** 
 * highlights a component
 * @param compId Component
 * @return boolean succsessful?
 */
public boolean highlightComponent(IComponentIdentifier compId){
  final Color highlightColor=null;
  Component component=null;
  try {
    if (getCurrentComponent() != null) {
      Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
      if (adapter != null) {
        ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class},new Object[]{getCurrentComponent()});
        setHighLighted(false);
      }
    }
    component=ComponentHandler.findComponent(compId,false,0);
    if (component != null) {
      setCurrentComponent(component);
      if (getCurrentComponent() != null && getCurrentComponent().isShowing() && getCurrentComponent().isVisible()) {
        Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
        ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
        setHighLighted(true);
        return true;
      }
    }
 else {
      return false;
    }
  }
 catch (  ComponentNotFoundException e) {
    log.warn(e);
  }
catch (  IllegalArgumentException e) {
    log.warn(e);
  }
  return false;
}","/** 
 * highlights a component
 * @param compId Component
 * @return boolean succsessful?
 */
public boolean highlightComponent(IComponentIdentifier compId){
  final Color highlightColor=null;
  Component component=null;
  try {
    if (getCurrentComponent() != null) {
      AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
      TesterUtil.lowLight(getCurrentComponent());
      setHighLighted(false);
    }
    component=ComponentHandler.findComponent(compId,false,0);
    if (component != null) {
      setCurrentComponent(component);
      if (getCurrentComponent() != null && getCurrentComponent().isShowing() && getCurrentComponent().isVisible()) {
        AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
        TesterUtil.highLight(getCurrentComponent(),highlightColor);
        setHighLighted(true);
        return true;
      }
    }
 else {
      return false;
    }
  }
 catch (  ComponentNotFoundException e) {
    log.warn(e);
  }
catch (  IllegalArgumentException e) {
    log.warn(e);
  }
catch (  UnsupportedComponentException uce) {
    log.warn(uce);
  }
  return false;
}",0.6329214826624153
95969,"/** 
 * repaints the border
 */
public void update(){
  final Color highlightColor=null;
  if (getCurrentComponent() != null) {
    try {
      Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
      if (adapter != null) {
        ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      }
    }
 catch (    IllegalArgumentException e) {
      log.error(""String_Node_Str"",e);
    }
  }
}","/** 
 * repaints the border
 */
public void update(){
  final Color highlightColor=null;
  if (getCurrentComponent() != null) {
    try {
      AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
      TesterUtil.highLight(getCurrentComponent(),highlightColor);
    }
 catch (    IllegalArgumentException e) {
      log.error(""String_Node_Str"",e);
    }
catch (    UnsupportedComponentException e) {
    }
  }
}",0.4004065040650406
95970,"/** 
 * Update internal db statistics after mass changes in the db. This is often needed to help the query optimizer doing the right things.
 */
public void updateDbStatistics(){
  String cmd=dbConnectionInfo.getStatisticsCommand();
  if (cmd != null) {
    EntityManager em=openSession();
    try {
      Query q=em.createNativeQuery(cmd);
      EntityTransaction tx=getTransaction(em);
      q.executeUpdate();
      commitTransaction(em,tx);
    }
 catch (    Exception e) {
      System.out.println(e.getMessage());
    }
 finally {
      dropSession(em);
    }
  }
}","/** 
 * Update internal db statistics after mass changes in the db. This is often needed to help the query optimizer doing the right things.
 */
public void updateDbStatistics(){
  String cmd=dbConnectionInfo.getStatisticsCommand();
  if (cmd != null) {
    EntityManager em=openSession();
    try {
      Query q=em.createNativeQuery(cmd);
      EntityTransaction tx=getTransaction(em);
      q.executeUpdate();
      commitTransaction(em,tx);
    }
 catch (    Throwable t) {
      log.error(""String_Node_Str"",t);
    }
 finally {
      dropSession(em);
    }
  }
}",0.9279437609841829
95971,"/** 
 * {@inheritDoc}
 */
protected void startTasks() throws ExceptionInInitializerError, InvocationTargetException, NoSuchMethodException {
  String edtNameRegEx=EnvironmentUtils.getProcessEnvironment().getProperty(EDT_NAME_REGEX_KEY);
  if (edtNameRegEx == null) {
    edtNameRegEx=System.getProperty(EDT_NAME_REGEX_KEY);
  }
  if (edtNameRegEx != null) {
    try {
      Pattern.compile(edtNameRegEx);
    }
 catch (    PatternSyntaxException pse) {
      throw new InvocationTargetException(pse,""String_Node_Str"" + EDT_NAME_REGEX_KEY + ""String_Node_Str"");
    }
    final String accessibleEdtNameRegEx=edtNameRegEx;
    Thread addListenersThread=new Thread(""String_Node_Str""){
      public void run(){
        boolean isThreadFound=false;
        ThreadGroup rootThreadGroup=Thread.currentThread().getThreadGroup();
        while (rootThreadGroup.getParent() != null) {
          rootThreadGroup=rootThreadGroup.getParent();
        }
        while (!isThreadFound) {
          Thread[] activeThreads=getActiveThreads();
          for (int i=0; i < activeThreads.length; i++) {
            if (activeThreads[i].getName().matches(accessibleEdtNameRegEx)) {
              isThreadFound=true;
              break;
            }
          }
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
          }
        }
        addToolKitEventListenerToAUT();
      }
    }
;
    addListenersThread.setDaemon(true);
    addListenersThread.start();
  }
 else {
    startToolkitThread();
    addToolKitEventListenerToAUT();
  }
  AUTServer.getInstance().invokeAUT();
  GUIAdapterFactoryRegistry.getInstance().registerFactory(new SwingAdapterFactory());
}","/** 
 * {@inheritDoc}
 */
protected void startTasks() throws ExceptionInInitializerError, InvocationTargetException, NoSuchMethodException {
  String edtNameRegEx=EnvironmentUtils.getProcessEnvironment().getProperty(EDT_NAME_REGEX_KEY);
  if (edtNameRegEx == null) {
    edtNameRegEx=System.getProperty(EDT_NAME_REGEX_KEY);
  }
  if (edtNameRegEx != null) {
    try {
      Pattern.compile(edtNameRegEx);
    }
 catch (    PatternSyntaxException pse) {
      throw new InvocationTargetException(pse,""String_Node_Str"" + EDT_NAME_REGEX_KEY + ""String_Node_Str"");
    }
    final String accessibleEdtNameRegEx=edtNameRegEx;
    Thread addListenersThread=new Thread(""String_Node_Str""){
      public void run(){
        boolean isThreadFound=false;
        ThreadGroup rootThreadGroup=Thread.currentThread().getThreadGroup();
        while (rootThreadGroup.getParent() != null) {
          rootThreadGroup=rootThreadGroup.getParent();
        }
        while (!isThreadFound) {
          Thread[] activeThreads=getActiveThreads();
          for (int i=0; i < activeThreads.length; i++) {
            if (activeThreads[i].getName().matches(accessibleEdtNameRegEx)) {
              isThreadFound=true;
              break;
            }
          }
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
          }
        }
        addToolKitEventListenerToAUT();
      }
    }
;
    addListenersThread.setDaemon(true);
    addListenersThread.start();
  }
 else {
    startToolkitThread();
    addToolKitEventListenerToAUT();
  }
  GUIAdapterFactoryRegistry.getInstance().registerFactory(new SwingAdapterFactory());
  AUTServer.getInstance().invokeAUT();
}",0.9770453207769276
95972,"/** 
 * Reopens the Editor with the changed node
 * @param node the changed node of this editor.
 * @throws PMException if the node can not be loaded
 */
public void reOpenEditor(IPersistentObject node) throws PMException {
  getEditorHelper().setDirty(false);
  getEditorHelper().getEditSupport().reloadEditSession();
  ((PersistableEditorInput)getEditorInput()).refreshNode();
  try {
    init(getEditorSite(),getEditorInput());
    setInitialInput();
  }
 catch (  PartInitException e) {
    getSite().getPage().closeEditor(this,false);
  }
}","/** 
 * Reopens the Editor with the changed node
 * @param node the changed node of this editor.
 * @throws PMException if the node can not be loaded
 */
public void reOpenEditor(IPersistentObject node) throws PMException {
  ISelection previousSelection=getSelection();
  getEditorHelper().setDirty(false);
  getEditorHelper().getEditSupport().reloadEditSession();
  ((PersistableEditorInput)getEditorInput()).refreshNode();
  try {
    init(getEditorSite(),getEditorInput());
    setInitialInput();
    setSelection(previousSelection);
  }
 catch (  PartInitException e) {
    getSite().getPage().closeEditor(this,false);
  }
}",0.9284497444633732
95973,"/** 
 * Performs the given <code>operation</code> within the context of the receiver's editor. The operation is ""wrapped"" between a request for an editable state and a reset of editable state (if the editor is not marked as dirty by the end of the operation. The operation is executed in the same thread in which this method is called. 
 * @param operation The operation to perform.
 */
public void doEditorOperation(IEditorOperation operation){
  if (requestEditableState() == EditableState.OK) {
    try {
      operation.run(getEditSupport().getWorkVersion());
    }
  finally {
      if (!m_editor.isDirty()) {
        try {
          resetEditableState();
          getEditSupport().reloadEditSession();
        }
 catch (        PMException e) {
          PMExceptionHandler.handlePMExceptionForEditor(e,m_editor);
        }
      }
    }
  }
}","/** 
 * Performs the given <code>operation</code> within the context of the receiver's editor. The operation is ""wrapped"" between a request for an editable state and a reset of editable state (if the editor is not marked as dirty by the end of the operation. The operation is executed in the same thread in which this method is called. 
 * @param operation The operation to perform.
 */
public void doEditorOperation(IEditorOperation operation){
  if (requestEditableState() == EditableState.OK) {
    try {
      operation.run(getEditSupport().getWorkVersion());
    }
  finally {
      final IJBEditor editor=m_editor;
      if (!editor.isDirty()) {
        try {
          editor.reOpenEditor(getEditSupport().getOriginal());
        }
 catch (        PMException e) {
          PMExceptionHandler.handlePMExceptionForEditor(e,editor);
        }
      }
    }
  }
}",0.9231664726426076
95974,"/** 
 * Searchs for the component in the AUT with the given <code>componentIdentifier</code>.
 * @param componentIdentifier the identifier created in object mapping mode
 * @throws IllegalArgumentException if the given identifer is null or <br>the hierarchy is not valid: empty or containing null elements
 * @throws InvalidDataException if the hierarchy in the componentIdentifier does not consist of strings
 * @throws ComponentNotManagedException if no component could be found for the identifier
 * @return the instance of the component of the AUT 
 */
public Component findComponent(IComponentIdentifier componentIdentifier) throws IllegalArgumentException, ComponentNotManagedException, InvalidDataException {
  Component comp=(Component)findBP.findComponent(componentIdentifier,ComponentHandler.getAutHierarchy());
  if (comp != null && comp.isShowing()) {
    Window window=SwingUtilities.getWindowAncestor(comp);
    if (window != null && window.isShowing()) {
      window.toFront();
    }
    return comp;
  }
  throw new ComponentNotManagedException(""String_Node_Str"" + componentIdentifier.toString() + ""String_Node_Str"",MessageIDs.E_COMPONENT_NOT_MANAGED);
}","/** 
 * Searchs for the component in the AUT with the given <code>componentIdentifier</code>.
 * @param componentIdentifier the identifier created in object mapping mode
 * @throws IllegalArgumentException if the given identifer is null or <br>the hierarchy is not valid: empty or containing null elements
 * @throws InvalidDataException if the hierarchy in the componentIdentifier does not consist of strings
 * @throws ComponentNotManagedException if no component could be found for the identifier
 * @return the instance of the component of the AUT 
 */
public Component findComponent(IComponentIdentifier componentIdentifier) throws IllegalArgumentException, ComponentNotManagedException, InvalidDataException {
  Component comp=(Component)findBP.findComponent(componentIdentifier,ComponentHandler.getAutHierarchy());
  if (comp != null && comp.isShowing()) {
    Window window=SwingUtilities.getWindowAncestor(comp);
    if (window != null && window.isShowing() && !window.isActive()) {
      window.toFront();
    }
    return comp;
  }
  throw new ComponentNotManagedException(""String_Node_Str"" + componentIdentifier.toString() + ""String_Node_Str"",MessageIDs.E_COMPONENT_NOT_MANAGED);
}",0.9906937394247038
95975,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public Object execute(ExecutionEvent event){
  TestCaseBrowser tcb=MultipleTCBTracker.getInstance().getMainTCB();
  if (!(tcb.getSelection() instanceof IStructuredSelection)) {
    return null;
  }
  IStructuredSelection sel=(IStructuredSelection)tcb.getSelection();
  List<INodePO> selectionList=sel.toList();
  if (!closeRelatedEditors(selectionList)) {
    return null;
  }
  ProblemSet moveProblems=getMoveProblem(selectionList);
  if (moveProblems.getProblems().isEmpty()) {
    Set<IReusedProjectPO> reusedProjects=GeneralStorage.getInstance().getProject().getUsedProjects();
    List<String> projectNamesList=new ArrayList<String>();
    for (    IReusedProjectPO project : reusedProjects) {
      projectNamesList.add(project.getName());
    }
    String[] projectNames=projectNamesList.toArray(new String[projectNamesList.size()]);
    ReusedProjectSelectionDialog dialog=new ReusedProjectSelectionDialog(Plugin.getShell(),projectNames,Messages.MoveTestCaseDialogShellTitle,Messages.MoveTestCaseDialogMessage,IconConstants.MOVE_TC_DIALOG_STRING,Messages.MoveTestCaseDialogShellTitle);
    dialog.setHelpAvailable(true);
    dialog.create();
    DialogUtils.setWidgetNameForModalDialog(dialog);
    Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.TESTCASE_MOVE_EXTERNAL);
    dialog.open();
    if (dialog.getReturnCode() == Window.OK) {
      String selectedName=dialog.getSelectedName();
      IReusedProjectPO selectedProject=null;
      for (      IReusedProjectPO project : reusedProjects) {
        if (selectedName.equals(project.getName())) {
          selectedProject=project;
          break;
        }
      }
      doMove(tcb,selectionList,selectedProject);
    }
  }
 else {
    showProblems(moveProblems);
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public Object execute(ExecutionEvent event){
  TestCaseBrowser tcb=MultipleTCBTracker.getInstance().getMainTCB();
  if (!(tcb.getSelection() instanceof IStructuredSelection)) {
    return null;
  }
  IStructuredSelection sel=(IStructuredSelection)tcb.getSelection();
  List<INodePO> selectionList=sel.toList();
  List<INodePO> nodesToMove=new ArrayList<INodePO>();
  for (  INodePO node : selectionList) {
    MultipleNodePM.collectAffectedNodes(nodesToMove,node);
  }
  if (!closeRelatedEditors(nodesToMove)) {
    return null;
  }
  ProblemSet moveProblems=getMoveProblem(nodesToMove);
  if (moveProblems.getProblems().isEmpty()) {
    Set<IReusedProjectPO> reusedProjects=GeneralStorage.getInstance().getProject().getUsedProjects();
    List<String> projectNamesList=new ArrayList<String>();
    for (    IReusedProjectPO project : reusedProjects) {
      projectNamesList.add(project.getName());
    }
    String[] projectNames=projectNamesList.toArray(new String[projectNamesList.size()]);
    ReusedProjectSelectionDialog dialog=new ReusedProjectSelectionDialog(Plugin.getShell(),projectNames,Messages.MoveTestCaseDialogShellTitle,Messages.MoveTestCaseDialogMessage,IconConstants.MOVE_TC_DIALOG_STRING,Messages.MoveTestCaseDialogShellTitle);
    dialog.setHelpAvailable(true);
    dialog.create();
    DialogUtils.setWidgetNameForModalDialog(dialog);
    Plugin.getHelpSystem().setHelp(dialog.getShell(),ContextHelpIds.TESTCASE_MOVE_EXTERNAL);
    dialog.open();
    if (dialog.getReturnCode() == Window.OK) {
      String selectedName=dialog.getSelectedName();
      IReusedProjectPO selectedProject=null;
      for (      IReusedProjectPO project : reusedProjects) {
        if (selectedName.equals(project.getName())) {
          selectedProject=project;
          break;
        }
      }
      doMove(tcb,selectionList,selectedProject);
    }
  }
 else {
    showProblems(moveProblems);
  }
  return null;
}",0.9453781512605042
95976,"/** 
 * Indicates whether there is a problem with moving the given selection. If there is a problem, it is described by the return value.
 * @param selectionList The elements that are to be moved
 * @param problems All problems with moving the given nodes.
 */
private void getMoveProblem(List<INodePO> selectionList,ProblemSet problems){
  for (  INodePO node : selectionList) {
    if (node instanceof IExecTestCasePO) {
      ISpecTestCasePO refTestCase=((IExecTestCasePO)node).getSpecTestCase();
      if (refTestCase != null) {
        Long curProjectId=GeneralStorage.getInstance().getProject().getId();
        if (refTestCase.getParentProjectId().equals(curProjectId)) {
          problems.addProblem(node);
        }
      }
    }
 else {
      getMoveProblem(node.getUnmodifiableNodeList(),problems);
    }
  }
}","/** 
 * Indicates whether there is a problem with moving the given selection.
 * @param selectionList The elements that are to be moved
 * @param problems All problems with moving the given nodes.
 */
private void getMoveProblem(List<INodePO> selectionList,ProblemSet problems){
  Long cProjId=GeneralStorage.getInstance().getProject().getId();
  for (  INodePO node : selectionList) {
    if (node instanceof IExecTestCasePO) {
      ISpecTestCasePO refTestCase=((IExecTestCasePO)node).getSpecTestCase();
      if (!problems.getNodesToMove().contains(refTestCase) && cProjId.equals(refTestCase.getParentProjectId())) {
        problems.getProblems().add(refTestCase);
      }
    }
 else {
      getMoveProblem(node.getUnmodifiableNodeList(),problems);
    }
  }
}",0.6603654694391935
95977,"/** 
 * @return List of valid problems.
 */
public List<MoveProblem> getProblems(){
  return m_problems;
}","/** 
 * @return List of valid problems.
 */
public Set<INodePO> getProblems(){
  return m_problems;
}",0.9178743961352656
95978,"/** 
 * {@inheritDoc}
 */
public void setEnabled(boolean enabled){
  IProjectPO currentProject=GeneralStorage.getInstance().getProject();
  boolean projectAvailable=currentProject == null ? false : !currentProject.getUsedProjects().isEmpty();
  super.setEnabled(enabled && projectAvailable);
}","/** 
 * {@inheritDoc} 
 */
public void setEnabled(boolean enabled){
  IProjectPO currentProject=GeneralStorage.getInstance().getProject();
  boolean projectAvailable=currentProject == null ? false : !currentProject.getUsedProjects().isEmpty();
  super.setEnabled(enabled && projectAvailable);
}",0.9982964224872232
95979,"/** 
 * Displays the problems for a proposed move operation.
 * @param moveProblems Valid problems with the proposed move operation.
 */
private void showProblems(ProblemSet moveProblems){
  StringBuilder sb=new StringBuilder();
  for (  MoveProblem moveProblem : moveProblems.getProblems()) {
    sb.append(moveProblem.getCause().getName());
    sb.append(StringConstants.NEWLINE);
  }
  ErrorHandlingUtil.createMessageDialog(MessageIDs.I_CANNOT_MOVE_TC,null,new String[]{NLS.bind(Messages.InfoDetailCannotMoveTc,sb.toString())});
}","/** 
 * Displays the problems for a proposed move operation.
 * @param moveProblems Valid problems with the proposed move operation.
 */
private void showProblems(ProblemSet moveProblems){
  StringBuilder sb=new StringBuilder();
  for (  INodePO moveProblem : moveProblems.getProblems()) {
    sb.append(moveProblem.getName());
    sb.append(StringConstants.NEWLINE);
  }
  ErrorHandlingUtil.createMessageDialog(MessageIDs.I_CANNOT_MOVE_TC,null,new String[]{NLS.bind(Messages.InfoDetailCannotMoveTc,sb.toString())});
}",0.972407231208373
95980,"/** 
 * @param selectionList All nodes that are to be moved.
 * @param newParent The new parent for the nodes.
 * @param extProject where selected nodes moved to
 * @return The commands necessary to move the given nodes.
 */
private List<MultipleNodePM.AbstractCmdHandle> createCommands(List<INodePO> selectionList,ISpecObjContPO newParent,IProjectPO extProject) throws JBException {
  List<MultipleNodePM.AbstractCmdHandle> commands=new ArrayList<MultipleNodePM.AbstractCmdHandle>();
  CompNameUsageMap usageMap=new CompNameUsageMap();
  final String projGuid=GeneralStorage.getInstance().getProject().getGuid();
  final Long projId=GeneralStorage.getInstance().getProject().getId();
  for (  INodePO selNode : selectionList) {
    commands.add(new MultipleNodePM.MoveNodeHandle(selNode,selNode.getParentNode(),newParent));
    List<INodePO> specTcs=new ArrayList<INodePO>();
    List<ISpecTestCasePO> specTcPOs=new ArrayList<ISpecTestCasePO>();
    addCatChildren(selNode,specTcs);
    for (    INodePO spec : specTcs) {
      ISpecTestCasePO specTestCasePo=(ISpecTestCasePO)spec;
      specTcPOs.add(specTestCasePo);
      CollectComponentNameUsersOp op=new CollectComponentNameUsersOp(projGuid,projId);
      TreeTraverser trav=new TreeTraverser(specTestCasePo,op,true,2);
      trav.traverse();
      usageMap.addAll(op.getUsageMap());
      for (      IExecTestCasePO execTc : NodePM.getInternalExecTestCases(specTestCasePo.getGuid(),specTestCasePo.getParentProjectId())) {
        commands.add(new MultipleNodePM.UpdateTestCaseRefHandle(execTc,specTestCasePo));
      }
    }
    commands.add(new MultipleNodePM.UpdateParamNamesHandle(specTcPOs,extProject));
  }
  commands.add(new MultipleNodePM.TransferCompNameHandle(usageMap,GeneralStorage.getInstance().getProject().getId(),extProject));
  return commands;
}","/** 
 * @param selectionList All nodes that are to be moved.
 * @param newParent The new parent for the nodes.
 * @param extProject where selected nodes moved to
 * @return The commands necessary to move the given nodes.
 */
private List<MultipleNodePM.AbstractCmdHandle> createCommands(List<INodePO> selectionList,ISpecObjContPO newParent,IProjectPO extProject) throws JBException {
  List<MultipleNodePM.AbstractCmdHandle> commands=new ArrayList<MultipleNodePM.AbstractCmdHandle>();
  CompNameUsageMap usageMap=new CompNameUsageMap();
  final IProjectPO currenProject=GeneralStorage.getInstance().getProject();
  final String projGuid=currenProject.getGuid();
  final Long projId=currenProject.getId();
  for (  INodePO selNode : selectionList) {
    commands.add(new MultipleNodePM.MoveNodeHandle(selNode,selNode.getParentNode(),newParent));
    List<INodePO> specTcs=new ArrayList<INodePO>();
    List<ISpecTestCasePO> specTcPOs=new ArrayList<ISpecTestCasePO>();
    addCatChildren(selNode,specTcs);
    for (    INodePO spec : specTcs) {
      ISpecTestCasePO specTestCasePo=(ISpecTestCasePO)spec;
      specTcPOs.add(specTestCasePo);
      CollectComponentNameUsersOp op=new CollectComponentNameUsersOp(projGuid,projId);
      new TreeTraverser(specTestCasePo,op,true,2).traverse();
      usageMap.addAll(op.getUsageMap());
      for (      IExecTestCasePO execTc : NodePM.getInternalExecTestCases(specTestCasePo.getGuid(),specTestCasePo.getParentProjectId())) {
        commands.add(new MultipleNodePM.UpdateTestCaseRefHandle(execTc,specTestCasePo));
      }
    }
    commands.add(new MultipleNodePM.UpdateParamNamesHandle(specTcPOs,extProject));
  }
  commands.add(new MultipleNodePM.TransferCompNameHandle(usageMap,projId,extProject));
  return commands;
}",0.9124372559955382
95981,"/** 
 * Constructor
 * @param nodesToMove The nodes that are to be moved.
 */
public ProblemSet(List<INodePO> nodesToMove){
  m_nodesToMove=new ArrayList<INodePO>();
  for (  INodePO node : nodesToMove) {
    addCatChildren(node,m_nodesToMove);
  }
}","/** 
 * Constructor
 * @param nodesToMove The nodes that are to be moved.
 */
public ProblemSet(List<INodePO> nodesToMove){
  setNodesToMove(new ArrayList<INodePO>());
  for (  INodePO node : nodesToMove) {
    addCatChildren(node,getNodesToMove());
  }
}",0.8831683168316832
95982,"/** 
 * Deletes all selected items unless an error occurs.
 * @param selection The selected items to delete.
 */
private void deleteSelection(IStructuredSelection selection){
  Set<INodePO> set=new HashSet<INodePO>(selection.toList());
  Set<INodePO> topNodesToDelete=new HashSet<INodePO>();
  for (  INodePO node : set) {
    if (!containsParent(set,node)) {
      topNodesToDelete.add(node);
    }
  }
  List<INodePO> nodesToDelete=new ArrayList<INodePO>();
  for (  INodePO node : topNodesToDelete) {
    collectNodesToDelete(nodesToDelete,node);
  }
  Collections.reverse(nodesToDelete);
  List<AbstractCmdHandle> cmds=getDeleteCommands(nodesToDelete);
  if (!cmds.isEmpty()) {
    try {
      MultipleNodePM.getInstance().executeCommands(cmds);
      List<DataChangedEvent> eventList=new ArrayList<DataChangedEvent>();
      for (      INodePO node : topNodesToDelete) {
        eventList.add(new DataChangedEvent(node,DataState.Deleted,UpdateState.all));
      }
      DataEventDispatcher.getInstance().fireDataChangedListener(eventList.toArray(new DataChangedEvent[0]));
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleGDProjectDeletedException();
    }
  }
}","/** 
 * Deletes all selected items unless an error occurs.
 * @param selection The selected items to delete.
 */
private void deleteSelection(IStructuredSelection selection){
  Set<INodePO> set=new HashSet<INodePO>(selection.toList());
  Set<INodePO> topNodesToDelete=new HashSet<INodePO>();
  for (  INodePO node : set) {
    if (!containsParent(set,node)) {
      topNodesToDelete.add(node);
    }
  }
  List<INodePO> nodesToDelete=new ArrayList<INodePO>();
  for (  INodePO node : topNodesToDelete) {
    MultipleNodePM.collectAffectedNodes(nodesToDelete,node);
  }
  Collections.reverse(nodesToDelete);
  List<AbstractCmdHandle> cmds=getDeleteCommands(nodesToDelete);
  if (!cmds.isEmpty()) {
    try {
      MultipleNodePM.getInstance().executeCommands(cmds);
      List<DataChangedEvent> eventList=new ArrayList<DataChangedEvent>();
      for (      INodePO node : topNodesToDelete) {
        eventList.add(new DataChangedEvent(node,DataState.Deleted,UpdateState.all));
      }
      DataEventDispatcher.getInstance().fireDataChangedListener(eventList.toArray(new DataChangedEvent[0]));
    }
 catch (    PMException e) {
      PMExceptionHandler.handlePMExceptionForMasterSession(e);
    }
catch (    ProjectDeletedException e) {
      PMExceptionHandler.handleGDProjectDeletedException();
    }
  }
}",0.9788542868127644
95983,"/** 
 * Selects a value from the list of the combobox
 * @param valueList the item(s) which should be (not)selected.
 * @param separator The separator if <code>text</code> is an enumeration of values. Not supported by this implementation class
 * @param operator if regular expressions are used
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 */
private void gdSelectValue(String valueList,String separator,String operator,final String searchType){
  String[] values=split(valueList,separator);
  getCBAdapter().select(values,operator,searchType);
}","/** 
 * Selects a value from the list of the combobox
 * @param value The value to select
 * @param operator if regular expressions are used
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 */
public void gdSelectValue(String value,String operator,final String searchType){
  getCBAdapter().select(value,operator,searchType);
}",0.7222808870116156
95984,"/** 
 * Selects the specified item in the combobox.
 * @param values the values which should be (not) selected
 * @param operator if regular expressions are used
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @throws StepExecutionException if an error occurs during selecting the item
 * @throws IllegalArgumentException if <code>component</code> or <code>text</code> are null
 */
public void select(final String[] values,String operator,String searchType) throws StepExecutionException, IllegalArgumentException ;","/** 
 * Selects the specified item in the combobox.
 * @param value the value which should be selected
 * @param operator if regular expressions are used
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @throws StepExecutionException if an error occurs during selecting the item
 * @throws IllegalArgumentException if <code>component</code> or <code>text</code> are null
 */
public void select(final String value,String operator,String searchType) throws StepExecutionException, IllegalArgumentException ;",0.9899543378995432
95985,"/** 
 * Selects the specified item in the combobox.
 * @param values the values which should be (not) selected
 * @param operator if regular expressions are used
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @throws StepExecutionException if an error occurs during selecting the item
 * @throws IllegalArgumentException if <code>component</code> or <code>text</code> are null
 */
public void select(final String[] values,String operator,String searchType) throws StepExecutionException, IllegalArgumentException {
  try {
    for (int i=0; i < values.length; i++) {
      String text=values[i];
      Validate.notNull(text,""String_Node_Str"");
    }
    JListAdapter list=new JListAdapter(findJList());
    Integer[] indices=list.findIndicesOfValues(values,operator,searchType);
    Arrays.sort(indices);
    if (indices.length == 0) {
      throw new StepExecutionException(""String_Node_Str"" + Arrays.asList(values).toString() + ""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
    }
    list.clickOnIndex(indices[0],ClickOptions.create().setClickCount(1),getMaxWidth());
  }
 catch (  StepExecutionException e) {
    m_comboBox.hidePopup();
    throw e;
  }
catch (  IllegalArgumentException e) {
    m_comboBox.hidePopup();
    throw e;
  }
}","/** 
 * Selects the specified item in the combobox.
 * @param value the value which should be selected
 * @param operator if regular expressions are used
 * @param searchType Determines where the search begins (""relative"" or ""absolute"")
 * @throws StepExecutionException if an error occurs during selecting the item
 * @throws IllegalArgumentException if <code>component</code> or <code>text</code> are null
 */
public void select(final String value,String operator,String searchType) throws StepExecutionException, IllegalArgumentException {
  try {
    Validate.notNull(value,""String_Node_Str"");
    JListAdapter list=new JListAdapter(findJList());
    Integer[] indices=list.findIndicesOfValues(new String[]{value},operator,searchType);
    Arrays.sort(indices);
    if (indices.length == 0) {
      throw new StepExecutionException(""String_Node_Str"" + value + ""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.NOT_FOUND));
    }
    list.clickOnIndex(indices[0],ClickOptions.create().setClickCount(1),getMaxWidth());
  }
 catch (  StepExecutionException e) {
    m_comboBox.hidePopup();
    throw e;
  }
catch (  IllegalArgumentException e) {
    m_comboBox.hidePopup();
    throw e;
  }
}",0.9337038507344184
95986,"/** 
 * {@inheritDoc}
 */
public boolean containsValue(String value,String operator){
  Integer[] indices=null;
  if (operator.equals(MatchUtil.NOT_EQUALS)) {
    indices=findIndicesOfValues(new String[]{value},MatchUtil.EQUALS,CompSystemConstants.SEARCH_TYPE_ABSOLUTE);
    return indices.length == 0;
  }
  indices=findIndicesOfValues(new String[]{value},operator,CompSystemConstants.SEARCH_TYPE_ABSOLUTE);
  return indices.length > 0;
}","/** 
 * {@inheritDoc}
 */
public boolean containsValue(String value,String operator){
  Integer[] indices=null;
  if (operator.equals(MatchUtil.NOT_EQUALS)) {
    indices=findIndicesOfValue(value,MatchUtil.EQUALS,CompSystemConstants.SEARCH_TYPE_ABSOLUTE);
    return indices.length == 0;
  }
  indices=findIndicesOfValue(value,operator,CompSystemConstants.SEARCH_TYPE_ABSOLUTE);
  return indices.length > 0;
}",0.964622641509434
95987,"/** 
 * Use this to handle the Highlighting after a Click.
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 */
protected void highlightClicked(final Object implClass,final Color highlightColor){
  Timer timer=new Timer(REPAINT_DELAY,new ActionListener(){
    public void actionPerformed(    ActionEvent e){
synchronized (getComponentLock()) {
        if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
          ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
          setHighLighted(true);
        }
      }
    }
  }
);
  timer.setRepeats(false);
  timer.start();
}","/** 
 * Use this to handle the Highlighting after a Click.
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 */
protected void highlightClicked(final Object implClass,final Color highlightColor){
  Timer timer=new Timer(REPAINT_DELAY,new ActionListener(){
    public void actionPerformed(    ActionEvent e){
synchronized (getComponentLock()) {
        if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
          Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
          ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
          setHighLighted(true);
        }
      }
    }
  }
);
  timer.setRepeats(false);
  timer.start();
}",0.9372972972972972
95988,"/** 
 * Handles the High-/Lowlighting.<br> When High-/LowLighting afer a click use highlightClicked.
 * @param source Component
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 * @see AbstractGDAutSwingEventListener#highlightClicked(Object,Color)
 */
protected void highlight(Component source,final Object implClass,final Color highlightColor){
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent() != source) {
      ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class},new Object[]{getCurrentComponent()});
      setHighLighted(false);
    }
    setCurrentComponent(source);
    Window windowAncestor=SwingUtilities.getWindowAncestor(getCurrentComponent());
    if (windowAncestor != null && windowAncestor.getFocusOwner() != null) {
      ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      setHighLighted(true);
    }
  }
}","/** 
 * Handles the High-/Lowlighting.<br> When High-/LowLighting afer a click use highlightClicked.
 * @param source Component
 * @param implClass IImplementationClass
 * @param highlightColor highlight clolor
 * @see AbstractGDAutSwingEventListener#highlightClicked(Object,Color)
 */
protected void highlight(Component source,final Object implClass,final Color highlightColor){
  Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(source);
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent() != source) {
      ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class},new Object[]{getCurrentComponent()});
      setHighLighted(false);
    }
    setCurrentComponent(source);
    Window windowAncestor=SwingUtilities.getWindowAncestor(getCurrentComponent());
    if (windowAncestor != null && windowAncestor.getFocusOwner() != null) {
      ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      setHighLighted(true);
    }
  }
}",0.9493258949325896
95989,"public void actionPerformed(ActionEvent e){
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
      ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      setHighLighted(true);
    }
  }
}","public void actionPerformed(ActionEvent e){
synchronized (getComponentLock()) {
    if (getCurrentComponent() != null && getCurrentComponent().isShowing() && SwingUtilities.getWindowAncestor(getCurrentComponent()) != null && SwingUtilities.getWindowAncestor(getCurrentComponent()).getFocusOwner() != null) {
      Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
      ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      setHighLighted(true);
    }
  }
}",0.8978102189781022
95990,"/** 
 * This method is called by the AUTServer AFTER this instance is removed as AWTEventListener for cleaning up purpose. <br> low lights the last hight lighted component.
 */
public void cleanUp(){
synchronized (m_componentLock) {
    if (getCurrentComponent() != null) {
      Object implClass;
      try {
        implClass=AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(m_currentComponent));
        if (implClass != null) {
          ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class},new Object[]{m_currentComponent});
          setHighLighted(false);
        }
      }
 catch (      UnsupportedComponentException uce) {
        log.warn(uce);
      }
catch (      IllegalArgumentException iae) {
        log.error(iae);
      }
    }
  }
}","/** 
 * This method is called by the AUTServer AFTER this instance is removed as AWTEventListener for cleaning up purpose. <br> low lights the last hight lighted component.
 */
public void cleanUp(){
synchronized (m_componentLock) {
    if (getCurrentComponent() != null) {
      try {
        Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
        if (adapter != null) {
          ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class},new Object[]{m_currentComponent});
          setHighLighted(false);
        }
      }
 catch (      IllegalArgumentException iae) {
        log.error(iae);
      }
    }
  }
}",0.7176391683433937
95991,"/** 
 * highlights a component
 * @param compId Component
 * @return boolean succsessful?
 */
public boolean highlightComponent(IComponentIdentifier compId){
  Object implClass;
  final Color highlightColor=null;
  Component component=null;
  try {
    if (getCurrentComponent() != null) {
      implClass=AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
      if (implClass != null) {
        ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class},new Object[]{getCurrentComponent()});
        setHighLighted(false);
      }
    }
    component=ComponentHandler.findComponent(compId,false,0);
    if (component != null) {
      setCurrentComponent(component);
      if (getCurrentComponent() != null && getCurrentComponent().isShowing() && getCurrentComponent().isVisible()) {
        implClass=AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
        ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
        setHighLighted(true);
        return true;
      }
    }
 else {
      return false;
    }
  }
 catch (  ComponentNotFoundException e) {
    log.warn(e);
  }
catch (  IllegalArgumentException e) {
    log.warn(e);
  }
catch (  UnsupportedComponentException uce) {
    log.warn(uce);
  }
  return false;
}","/** 
 * highlights a component
 * @param compId Component
 * @return boolean succsessful?
 */
public boolean highlightComponent(IComponentIdentifier compId){
  final Color highlightColor=null;
  Component component=null;
  try {
    if (getCurrentComponent() != null) {
      Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
      if (adapter != null) {
        ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class},new Object[]{getCurrentComponent()});
        setHighLighted(false);
      }
    }
    component=ComponentHandler.findComponent(compId,false,0);
    if (component != null) {
      setCurrentComponent(component);
      if (getCurrentComponent() != null && getCurrentComponent().isShowing() && getCurrentComponent().isVisible()) {
        Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
        ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
        setHighLighted(true);
        return true;
      }
    }
 else {
      return false;
    }
  }
 catch (  ComponentNotFoundException e) {
    log.warn(e);
  }
catch (  IllegalArgumentException e) {
    log.warn(e);
  }
  return false;
}",0.7232499093217265
95992,"/** 
 * repaints the border
 */
public void update(){
  Object implClass;
  final Color highlightColor=null;
  if (getCurrentComponent() != null) {
    try {
      implClass=AUTServerConfiguration.getInstance().getImplementationClass(getComponentClass(getCurrentComponent()));
      if (implClass != null) {
        ReflectionBP.invokeMethod(""String_Node_Str"",implClass,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      }
    }
 catch (    UnsupportedComponentException e) {
    }
catch (    IllegalArgumentException e) {
      log.error(""String_Node_Str"",e);
    }
  }
}","/** 
 * repaints the border
 */
public void update(){
  final Color highlightColor=null;
  if (getCurrentComponent() != null) {
    try {
      Object adapter=GUIAdapterFactoryRegistry.getInstance().getAdapter(getCurrentComponent());
      if (adapter != null) {
        ReflectionBP.invokeMethod(""String_Node_Str"",adapter,new Class[]{Component.class,Color.class},new Object[]{getCurrentComponent(),highlightColor});
      }
    }
 catch (    IllegalArgumentException e) {
      log.error(""String_Node_Str"",e);
    }
  }
}",0.5651793525809273
95993,"public Object run(){
  return getRenderedText(renderer);
}","public void run(){
  HIGHLIGHTER.lowLight(comp);
}",0.4444444444444444
95994,"/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part  of the component (e.g. tree node, table cell, etc)   rather than the overall component itself. May be   <code>null</code>.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions The click options 
 * @throws StepExecutionException If the click delay is interrupted or the  event confirmation receives a timeout. 
 */
private void moveImpl(Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible()) {
    ensureComponentVisible((Component)graphicsComponent,constraints);
    m_eventFlusher.flush();
  }
  Component component=(Component)graphicsComponent;
  Rectangle bounds=null;
  bounds=new Rectangle(getLocation(component,new Point(0,0)));
  bounds.width=component.getWidth();
  bounds.height=component.getHeight();
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    IRobotEventConfirmer confirmer=null;
    if (clickOptions.isConfirmClick()) {
      InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
      confirmer=m_interceptor.intercept(options);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      Component root=SwingUtilities.getRoot(component);
      Component c=(root != null) ? root : component;
      startpoint=getLocation(c,null);
    }
    Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,clickOptions.getStepMovement());
    for (int i=0; i < mouseMove.length; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      m_eventFlusher.flush();
    }
    if (confirmer != null) {
      confirmer.waitToConfirm(component,new MouseMovedAwtEventMatcher());
    }
  }
}","/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part  of the component (e.g. tree node, table cell, etc)   rather than the overall component itself. May be   <code>null</code>.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions The click options 
 * @throws StepExecutionException If the click delay is interrupted or the  event confirmation receives a timeout. 
 */
private void moveImpl(Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible()) {
    ensureComponentVisible((Component)graphicsComponent,constraints);
    m_eventFlusher.flush();
  }
  Component component=(Component)graphicsComponent;
  Rectangle bounds=null;
  bounds=new Rectangle(getLocation(component,new Point(0,0)));
  bounds.width=component.getWidth();
  bounds.height=component.getHeight();
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    IRobotEventConfirmer confirmer=null;
    if (clickOptions.isConfirmClick()) {
      InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
      confirmer=m_interceptor.intercept(options);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      Component root=SwingUtilities.getRoot(component);
      Component c=(root != null) ? root : component;
      startpoint=getLocation(c,null);
    }
    Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,clickOptions.getStepMovement(),clickOptions.getFirstHorizontal());
    for (int i=0; i < mouseMove.length; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      m_eventFlusher.flush();
    }
    if (confirmer != null) {
      confirmer.waitToConfirm(component,new MouseMovedAwtEventMatcher());
    }
  }
}",0.9933463796477496
95995,"/** 
 * Clicks on a menu item
 * @param robot the robot
 * @param item the menu item
 */
public static void clickMenuItem(IRobot robot,JMenuItem item){
  if (!item.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED).setStepMovement(false));
}","/** 
 * Clicks on a menu item
 * @param robot the robot
 * @param item the menu item
 */
public static void clickMenuItem(IRobot robot,JMenuItem item){
  if (!item.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  if (item.getParent() instanceof JPopupMenu && ((JPopupMenu)item.getParent()).getInvoker().getParent() instanceof JMenuBar) {
    robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED).setFirstHorizontal(true));
  }
 else {
    robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED));
  }
}",0.7474931631722881
95996,"/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component into which the mouse will be moved.
 * @param constraints The rectangle to move to, relative to the location ofthe given component. May be <code>null</code>. If <code>null</code>, the mouse will be moved to the center of the given component.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions Contains mouse movement strategy information.
 * @throws StepExecutionException If the click delay is interupted or the event confirmation receives a timeout.
 */
private void moveImpl(final Widget graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible() && graphicsComponent instanceof Control) {
    ensureComponentVisible((Control)graphicsComponent,constraints);
  }
  Rectangle bounds=getBounds(graphicsComponent);
  if (constraints != null) {
    if (graphicsComponent instanceof Control) {
      Point convertedLocation=convertLocation(constraints,(Control)graphicsComponent);
      bounds.x=convertedLocation.x;
      bounds.y=convertedLocation.y;
    }
 else {
      bounds.x+=constraints.x;
      bounds.y+=constraints.y;
    }
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point pointToGo=SwtPointUtil.calculatePointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(pointToGo)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + pointToGo);
    }
    Point initialPoint=(Point)m_queuer.invokeAndWait(""String_Node_Str"",new IRunnable(){
      public Object run() throws StepExecutionException {
        Display d=m_autServer.getAutDisplay();
        return d.getCursorLocation();
      }
    }
);
    if (pointToGo != null && (pointToGo.x < 0 || pointToGo.y < 0)) {
      throw new RobotException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.CLICKPOINT_OFFSCREEN,new String[]{String.valueOf(pointToGo.x),String.valueOf(pointToGo.y)}));
    }
    java.awt.Point[] path=MouseMovementStrategy.getMovementPath(new java.awt.Point(initialPoint.x,initialPoint.y),new java.awt.Point(pointToGo.x,pointToGo.y),clickOptions.getStepMovement());
    for (int i=0; i < path.length; i++) {
      m_robot.mouseMove(path[i].x,path[i].y);
    }
    logAndCorrectMousePosition(pointToGo);
  }
}","/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component into which the mouse will be moved.
 * @param constraints The rectangle to move to, relative to the location ofthe given component. May be <code>null</code>. If <code>null</code>, the mouse will be moved to the center of the given component.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions Contains mouse movement strategy information.
 * @throws StepExecutionException If the click delay is interupted or the event confirmation receives a timeout.
 */
private void moveImpl(final Widget graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible() && graphicsComponent instanceof Control) {
    ensureComponentVisible((Control)graphicsComponent,constraints);
  }
  Rectangle bounds=getBounds(graphicsComponent);
  if (constraints != null) {
    if (graphicsComponent instanceof Control) {
      Point convertedLocation=convertLocation(constraints,(Control)graphicsComponent);
      bounds.x=convertedLocation.x;
      bounds.y=convertedLocation.y;
    }
 else {
      bounds.x+=constraints.x;
      bounds.y+=constraints.y;
    }
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point pointToGo=SwtPointUtil.calculatePointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(pointToGo)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + pointToGo);
    }
    Point initialPoint=(Point)m_queuer.invokeAndWait(""String_Node_Str"",new IRunnable(){
      public Object run() throws StepExecutionException {
        Display d=m_autServer.getAutDisplay();
        return d.getCursorLocation();
      }
    }
);
    if (pointToGo != null && (pointToGo.x < 0 || pointToGo.y < 0)) {
      throw new RobotException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.CLICKPOINT_OFFSCREEN,new String[]{String.valueOf(pointToGo.x),String.valueOf(pointToGo.y)}));
    }
    java.awt.Point[] path=MouseMovementStrategy.getMovementPath(new java.awt.Point(initialPoint.x,initialPoint.y),new java.awt.Point(pointToGo.x,pointToGo.y),clickOptions.getStepMovement(),clickOptions.getFirstHorizontal());
    for (int i=0; i < path.length; i++) {
      m_robot.mouseMove(path[i].x,path[i].y);
    }
    logAndCorrectMousePosition(pointToGo);
  }
}",0.993587325537533
95997,"/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part  of the component (e.g. tree node, table cell, etc)   rather than the overall component itself. May be   <code>null</code>.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions The click options 
 * @throws StepExecutionException If the click delay is interrupted or the  event confirmation receives a timeout. 
 */
private void moveImpl(Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible()) {
    ensureComponentVisible((Component)graphicsComponent,constraints);
    m_eventFlusher.flush();
  }
  Component component=(Component)graphicsComponent;
  Rectangle bounds=null;
  bounds=new Rectangle(getLocation(component,new Point(0,0)));
  bounds.width=component.getWidth();
  bounds.height=component.getHeight();
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    IRobotEventConfirmer confirmer=null;
    if (clickOptions.isConfirmClick()) {
      InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
      confirmer=m_interceptor.intercept(options);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      Component root=SwingUtilities.getRoot(component);
      Component c=(root != null) ? root : component;
      startpoint=getLocation(c,null);
    }
    Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,true);
    for (int i=0; i < mouseMove.length; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      m_eventFlusher.flush();
    }
    if (confirmer != null) {
      confirmer.waitToConfirm(component,new MouseMovedAwtEventMatcher());
    }
  }
}","/** 
 * Implementation of the mouse move. The mouse is moved into the graphics component.
 * @param graphicsComponent The component to move to
 * @param constraints The more specific constraints. Use this, for example when you want the click point to be relative to a part  of the component (e.g. tree node, table cell, etc)   rather than the overall component itself. May be   <code>null</code>.
 * @param xPos xPos in component           
 * @param yPos yPos in component
 * @param xAbsolute true if x-position should be absolute  
 * @param yAbsolute true if y-position should be absolute  
 * @param clickOptions The click options 
 * @throws StepExecutionException If the click delay is interrupted or the  event confirmation receives a timeout. 
 */
private void moveImpl(Object graphicsComponent,final Rectangle constraints,final int xPos,final boolean xAbsolute,final int yPos,final boolean yAbsolute,ClickOptions clickOptions) throws StepExecutionException {
  if (clickOptions.isScrollToVisible()) {
    ensureComponentVisible((Component)graphicsComponent,constraints);
    m_eventFlusher.flush();
  }
  Component component=(Component)graphicsComponent;
  Rectangle bounds=null;
  bounds=new Rectangle(getLocation(component,new Point(0,0)));
  bounds.width=component.getWidth();
  bounds.height=component.getHeight();
  if (constraints != null) {
    bounds.x+=constraints.x;
    bounds.y+=constraints.y;
    bounds.height=constraints.height;
    bounds.width=constraints.width;
  }
  Point p=PointUtil.calculateAwtPointToGo(xPos,xAbsolute,yPos,yAbsolute,bounds);
  if (isMouseMoveRequired(p)) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + p);
    }
    IRobotEventConfirmer confirmer=null;
    if (clickOptions.isConfirmClick()) {
      InterceptorOptions options=new InterceptorOptions(new long[]{AWTEvent.MOUSE_MOTION_EVENT_MASK});
      confirmer=m_interceptor.intercept(options);
    }
    Point startpoint=m_mouseMotionTracker.getLastMousePointOnScreen();
    if (startpoint == null) {
      Component root=SwingUtilities.getRoot(component);
      Component c=(root != null) ? root : component;
      startpoint=getLocation(c,null);
    }
    Point[] mouseMove=MouseMovementStrategy.getMovementPath(startpoint,p,clickOptions.getStepMovement());
    for (int i=0; i < mouseMove.length; i++) {
      m_robot.mouseMove(mouseMove[i].x,mouseMove[i].y);
      m_eventFlusher.flush();
    }
    if (confirmer != null) {
      confirmer.waitToConfirm(component,new MouseMovedAwtEventMatcher());
    }
  }
}",0.9932673267326732
95998,"/** 
 * Clicks on a menu item
 * @param robot the robot
 * @param item the menu item
 */
public static void clickMenuItem(IRobot robot,JMenuItem item){
  if (!item.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED));
}","/** 
 * Clicks on a menu item
 * @param robot the robot
 * @param item the menu item
 */
public static void clickMenuItem(IRobot robot,JMenuItem item){
  if (!item.isEnabled()) {
    throw new StepExecutionException(""String_Node_Str"",EventFactory.createActionError(TestErrorEvent.MENU_ITEM_NOT_ENABLED));
  }
  robot.click(item,null,ClickOptions.create().setClickType(ClickOptions.ClickType.RELEASED).setStepMovement(false));
}",0.9723225030084236
95999,"/** 
 * {@inheritDoc}
 */
public void decorate(Object element,IDecoration decoration){
  if (element instanceof TestResultNode) {
    TestResultNode testResult=(TestResultNode)element;
    StringBuilder paramValueBuilder=new StringBuilder();
    for (    TestResultParameter parameter : testResult.getParameters()) {
      paramValueBuilder.append(StringUtils.defaultString(parameter.getValue())).append(SEPARATOR);
    }
    if (paramValueBuilder.length() > 0) {
      int builderLength=paramValueBuilder.length();
      paramValueBuilder.delete(builderLength - SEPARATOR_LEN,builderLength);
      paramValueBuilder.insert(0,""String_Node_Str"");
      paramValueBuilder.append(""String_Node_Str"");
      decoration.addSuffix(paramValueBuilder.toString());
    }
  }
}","/** 
 * {@inheritDoc}
 */
public void decorate(Object element,IDecoration decoration){
  if (element instanceof TestResultNode) {
    TestResultNode testResult=(TestResultNode)element;
    StringBuilder paramValueBuilder=new StringBuilder();
    List<TestResultParameter> parameters=testResult.getParameters();
    for (int index=0; index < parameters.size(); index++) {
      TestResultParameter parameter=parameters.get(index);
      paramValueBuilder.append(StringUtils.defaultString(parameter.getValue())).append(SEPARATOR);
    }
    if (paramValueBuilder.length() > 0) {
      int builderLength=paramValueBuilder.length();
      paramValueBuilder.delete(builderLength - SEPARATOR_LEN,builderLength);
      paramValueBuilder.insert(0,""String_Node_Str"");
      paramValueBuilder.append(""String_Node_Str"");
      decoration.addSuffix(paramValueBuilder.toString());
    }
  }
}",0.8924012158054712
96000,"/** 
 * Tries to click in the cell under the mouse position. If the mouse is not over a cell, the current selected cell will be clicked on. If there is no selected cell, the middle of the table is used to click on.
 * @param count Number of clicks
 * @param button The mouse button
 */
public void gdClick(int count,int button){
  ITableAdapter adapter=getTableAdapter();
  Cell cell=null;
  if (isMouseOverCell()) {
    cell=getCellAtMousePosition();
  }
 else   if (adapter.hasCellSelection()) {
    cell=adapter.getSelectedCell();
  }
  if (cell != null) {
    Rectangle cellRect=adapter.scrollCellToVisible(cell.getRow(),cell.getCol());
    getRobot().click(getRealTable(),cellRect,ClickOptions.create().setClickCount(count).setMouseButton(button));
  }
 else {
    super.gdClick(count,button);
  }
}","/** 
 * Tries to click in the cell under the mouse position. If the mouse is not over a cell, the current selected cell will be clicked on. If there is no selected cell, the middle of the table is used to click on.
 * @param count Number of clicks
 * @param button The mouse button
 */
public void gdClick(int count,int button){
  ITableAdapter adapter=getTableAdapter();
  Cell cell=null;
  if (isMouseOverCell()) {
    cell=getCellAtMousePosition();
  }
 else   if (adapter.hasCellSelection()) {
    cell=adapter.getSelectedCell();
  }
  if (cell != null) {
    Rectangle cellRect=adapter.scrollCellToVisible(cell.getRow(),cell.getCol());
    Object robotSpecifcRectangle=getSpecificRectangle(cellRect);
    getRobot().click(getRealTable(),robotSpecifcRectangle,ClickOptions.create().setClickCount(count).setMouseButton(button));
  }
 else {
    super.gdClick(count,button);
  }
}",0.9454329774614472
