record_number,buggy_code,fixed_code,code_similarity
186001,"private ASTNode getFirst(BlockStatement statements,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statements) ? statements.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}","private ASTNode getFirst(BlockStatement statements,List<MethodNode> methods){
  Statement firstStatement=hasScriptStatements(statements) ? statements.getStatements().get(0) : null;
  MethodNode firstMethod=hasScriptMethods(methods) ? methods.get(0) : null;
  if (firstMethod == null && (firstStatement == null || (firstStatement.getStart() == 0 && firstStatement.getLength() == 0))) {
    firstStatement=createSyntheticAfterImports();
  }
  int statementStart=firstStatement != null ? firstStatement.getStart() : Integer.MAX_VALUE;
  int methodStart=firstMethod != null ? firstMethod.getStart() : Integer.MAX_VALUE;
  return statementStart <= methodStart ? firstStatement : firstMethod;
}",0.847571189279732
186002,"protected void importDef(AST importNode){
  boolean isStatic=importNode.getType() == STATIC_IMPORT;
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST node=importNode.getFirstChild();
  if (isType(ANNOTATIONS,node)) {
    processAnnotations(annotations,node);
    node=node.getNextSibling();
  }
  String alias=null;
  if (isType(LITERAL_as,node)) {
    node=node.getFirstChild();
    AST aliasNode=node.getNextSibling();
    alias=identifier(aliasNode);
  }
  if (node == null) {
    if (isStatic) {
      addStaticImport(ClassHelper.OBJECT_TYPE,""String_Node_Str"",null,annotations);
    }
 else {
      addImport(ClassHelper.OBJECT_TYPE,""String_Node_Str"",null,annotations);
    }
    return;
  }
  if (node.getNumberOfChildren() == 0) {
    String name=identifier(node);
    ClassNode type=ClassHelper.make(name);
    configureAST(type,importNode);
    addImport(type,name,alias,annotations);
    return;
  }
  AST packageNode=node.getFirstChild();
  String packageName=qualifiedName(packageNode);
  AST nameNode=packageNode.getNextSibling();
  if (isType(STAR,nameNode)) {
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticStarImport(type,packageName,annotations);
      ASTNode imp=(ASTNode)output.getStaticStarImports().get(packageName);
      configureAST(imp,importNode);
    }
 else {
      addStarImport(packageName,annotations);
      ASTNode imp=(ASTNode)output.getStarImports().get(output.getStarImports().size() - 1);
      configureAST(imp,importNode);
    }
    if (alias != null)     throw new GroovyBugError(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    String name=identifier(nameNode);
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticImport(type,name,alias,annotations);
      ASTNode imp=(ASTNode)output.getStaticImports().get(alias == null ? name : alias);
      configureAST(imp,importNode);
    }
 else {
      ClassNode type=ClassHelper.make(packageName + ""String_Node_Str"" + name);
      configureAST(type,nameNode);
      addImport(type,name,alias,annotations);
    }
  }
}","protected void importDef(AST importNode){
  boolean isStatic=importNode.getType() == STATIC_IMPORT;
  List<AnnotationNode> annotations=new ArrayList<AnnotationNode>();
  AST node=importNode.getFirstChild();
  if (isType(ANNOTATIONS,node)) {
    processAnnotations(annotations,node);
    node=node.getNextSibling();
  }
  String alias=null;
  if (isType(LITERAL_as,node)) {
    node=node.getFirstChild();
    AST aliasNode=node.getNextSibling();
    alias=identifier(aliasNode);
  }
  if (node == null) {
    if (isStatic) {
      addStaticImport(ClassHelper.OBJECT_TYPE,""String_Node_Str"",null,annotations);
    }
 else {
      addImport(ClassHelper.OBJECT_TYPE,""String_Node_Str"",null,annotations);
    }
    return;
  }
  if (node.getNumberOfChildren() == 0) {
    String name=identifier(node);
    ClassNode type=ClassHelper.make(name);
    configureAST(type,importNode);
    addImport(type,name,alias,annotations);
    return;
  }
  AST packageNode=node.getFirstChild();
  String packageName=qualifiedName(packageNode);
  AST nameNode=packageNode.getNextSibling();
  if (isType(STAR,nameNode)) {
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticStarImport(type,packageName,annotations);
      ASTNode imp=(ASTNode)output.getStaticStarImports().get(packageName);
      configureAST(imp,importNode);
    }
 else {
      addStarImport(packageName,annotations);
      ASTNode imp=(ASTNode)output.getStarImports().get(output.getStarImports().size() - 1);
      configureAST(imp,importNode);
    }
    if (alias != null)     throw new GroovyBugError(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    String name=identifier(nameNode);
    if (isStatic) {
      ClassNode type=ClassHelper.make(packageName);
      configureAST(type,importNode);
      addStaticImport(type,name,alias,annotations);
      ASTNode imp=(ASTNode)output.getStaticImports().get(alias == null ? name : alias);
      configureAST(imp,importNode);
    }
 else {
      ClassNode type=ClassHelper.make(packageName + ""String_Node_Str"" + name);
      configureAST(type,nameNode);
      addImport(type,name,alias,annotations);
      ImportNode imp=output.getImport(alias == null ? name : alias);
      configureAST(imp,importNode);
    }
  }
}",0.9764942914707858
186003,"/** 
 * Try to get the source locations for type declarations to be as correct as possible
 */
private void fixupSourceLocationsForTypeDeclaration(GroovyTypeDeclaration typeDeclaration,ClassNode classNode){
  typeDeclaration.sourceStart=Math.max(classNode.getNameStart(),classNode.getStart());
  typeDeclaration.sourceEnd=Math.max(classNode.getNameEnd(),classNode.getStart());
  int line=classNode.getLineNumber();
  Javadoc doc=findJavadoc(line);
  typeDeclaration.javadoc=doc;
  typeDeclaration.declarationSourceStart=doc == null ? classNode.getStart() : doc.sourceStart;
  typeDeclaration.declarationSourceEnd=classNode.getEnd() - 1;
  typeDeclaration.bodyStart=Math.max(classNode.getNameEnd(),classNode.getStart());
  typeDeclaration.bodyEnd=classNode.getEnd() - 1;
  typeDeclaration.modifiersSourceStart=classNode.getStart();
}","/** 
 * Try to get the source locations for type declarations to be as correct as possible
 */
private void fixupSourceLocationsForTypeDeclaration(GroovyTypeDeclaration typeDeclaration,ClassNode classNode){
  typeDeclaration.sourceStart=Math.max(classNode.getNameStart(),classNode.getStart());
  typeDeclaration.sourceEnd=Math.max(classNode.getNameEnd(),classNode.getStart());
  int line=classNode.getLineNumber();
  Javadoc doc=findJavadoc(line);
  if (doc != null) {
    if (imports != null && imports.length > 0) {
      if (doc.sourceStart < imports[imports.length - 1].sourceStart) {
        doc=null;
      }
    }
 else     if (currentPackage != null) {
      if (doc.sourceStart < currentPackage.sourceStart) {
        doc=null;
      }
    }
  }
  typeDeclaration.javadoc=doc;
  typeDeclaration.declarationSourceStart=doc == null ? classNode.getStart() : doc.sourceStart;
  typeDeclaration.declarationSourceEnd=classNode.getEnd() - 1;
  typeDeclaration.bodyStart=Math.max(classNode.getNameEnd(),classNode.getStart());
  typeDeclaration.bodyEnd=classNode.getEnd() - 1;
  typeDeclaration.modifiersSourceStart=classNode.getStart();
}",0.8442415017757483
186004,"protected boolean containsSuggestion(IGroovySuggestion suggestion){
  boolean isContained=false;
  if (suggestion instanceof GroovyPropertySuggestion) {
    String name=suggestion.getName();
    for (    IGroovySuggestion existingSugg : suggestions) {
      if (existingSugg instanceof GroovyPropertySuggestion && existingSugg.getName().equals(name)) {
        isContained=true;
        break;
      }
    }
  }
 else   if (suggestion instanceof GroovyMethodSuggestion) {
    String name=suggestion.getName();
    for (    IGroovySuggestion existingSugg : suggestions) {
      if (existingSugg instanceof GroovyMethodSuggestion && existingSugg.getName().equals(name)) {
        List<MethodParameter> existingParameters=((GroovyMethodSuggestion)existingSugg).getParameters();
        List<MethodParameter> parameters=((GroovyMethodSuggestion)suggestion).getParameters();
        if (existingParameters != null) {
          if (existingParameters.equals(parameters)) {
            isContained=true;
            break;
          }
        }
 else         if (parameters != null) {
          if (parameters.equals(existingParameters)) {
            isContained=true;
            break;
          }
        }
 else {
          isContained=true;
          break;
        }
      }
    }
  }
  return isContained;
}","protected boolean containsSuggestion(IGroovySuggestion suggestion){
  boolean isContained=false;
  if (suggestion instanceof GroovyPropertySuggestion) {
    String name=suggestion.getName();
    for (    IGroovySuggestion existingSugg : suggestions) {
      if (existingSugg instanceof GroovyPropertySuggestion && existingSugg.getName().equals(name)) {
        isContained=true;
        break;
      }
    }
  }
 else   if (suggestion instanceof GroovyMethodSuggestion) {
    String name=suggestion.getName();
    GroovyMethodSuggestion methodSuggestion=(GroovyMethodSuggestion)suggestion;
    for (    IGroovySuggestion existingSugg : suggestions) {
      if (existingSugg instanceof GroovyMethodSuggestion && existingSugg.getName().equals(name)) {
        GroovyMethodSuggestion existingMethodSuggestion=(GroovyMethodSuggestion)existingSugg;
        List<MethodParameter> existingParameters=existingMethodSuggestion.getParameters();
        List<MethodParameter> parameters=methodSuggestion.getParameters();
        if (existingParameters != null) {
          if (parameters != null && parameters.size() == existingParameters.size()) {
            boolean same=true;
            for (int i=0; i < parameters.size(); i++) {
              String existingType=existingParameters.get(i).getType();
              String type=parameters.get(i).getType();
              if (type != null) {
                if (!type.equals(existingType)) {
                  same=false;
                  break;
                }
              }
 else               if (existingType != null) {
                same=false;
                break;
              }
            }
            if (same) {
              isContained=true;
              break;
            }
          }
        }
 else         if (parameters == null) {
          isContained=true;
          break;
        }
      }
    }
  }
  return isContained;
}",0.6866043613707166
186005,"protected IStatus checkJavaType(String value){
  return JavaConventions.validateJavaTypeName(value,JavaCore.VERSION_1_3,JavaCore.VERSION_1_3);
}","protected IStatus checkJavaType(String value){
  return JavaConventions.validateIdentifier(value,JavaCore.VERSION_1_3,JavaCore.VERSION_1_3);
}",0.9370629370629372
186006,"public ValueStatus checkValidity(Object value){
  if (value instanceof String) {
    String name=(String)value;
    IStatus status=JavaConventions.validateJavaTypeName(name,JavaCore.VERSION_1_3,JavaCore.VERSION_1_3);
    if (status.getSeverity() != IStatus.ERROR) {
      try {
        IType type=getActualType(name);
        if (type != null) {
          return ValueStatus.getValidStatus(value);
        }
 else {
          return ValueStatus.getErrorStatus(value,THE_SPECIFIED_JAVA_TYPES_DO_NOT_EXIST + name);
        }
      }
 catch (      JavaModelException e) {
        Activator.logError(e);
      }
    }
 else {
      return ValueStatus.getErrorStatus(value,status.getMessage());
    }
  }
  return ValueStatus.getErrorStatus(value,INVALID_JAVA);
}","public ValueStatus checkValidity(Object value){
  if (value instanceof String) {
    String name=(String)value;
    IStatus status=JavaConventions.validateJavaTypeName(name,JavaCore.VERSION_1_3,JavaCore.VERSION_1_3);
    if (status.getSeverity() != IStatus.ERROR) {
      try {
        IType type=getActualType(name);
        if (type != null) {
          return ValueStatus.getValidStatus(value);
        }
 else {
          return ValueStatus.getErrorStatus(value,THE_SPECIFIED_JAVA_TYPES_DO_NOT_EXIST + name);
        }
      }
 catch (      JavaModelException e) {
        Activator.logError(e);
      }
    }
 else {
      return ValueStatus.getErrorStatus(value,INVALID_JAVA);
    }
  }
  return ValueStatus.getErrorStatus(value,INVALID_JAVA);
}",0.979456593770709
186007,"protected Shell getShell(){
  Display display=Display.getCurrent();
  if (display == null) {
    display=Display.getDefault();
  }
  Shell shell=display.getActiveShell();
  if (shell == null || shell.isDisposed()) {
    for (    Shell shll : display.getShells()) {
      if (shll != null && !shll.isDisposed()) {
        shell=shll;
        break;
      }
    }
  }
  return shell;
}","protected Shell getShell(){
  Display display=Display.getCurrent();
  if (display == null) {
    display=Display.getDefault();
  }
  if (display == null) {
    return null;
  }
  Shell shell=display.getActiveShell();
  if (shell == null || shell.isDisposed()) {
    for (    Shell shll : display.getShells()) {
      if (shll != null && !shll.isDisposed()) {
        shell=shll;
        break;
      }
    }
  }
  return shell;
}",0.9433497536945812
186008,"public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (!interestingElement(enclosingElement)) {
    return VisitStatus.CANCEL_MEMBER;
  }
  if (node instanceof ImportNode) {
    node=((ImportNode)node).getType();
    if (node == null) {
      return VisitStatus.CONTINUE;
    }
  }
  if (node instanceof ConstantExpression && doTest(node)) {
    ConstantExpression expression=(ConstantExpression)node;
    descriptor=createDescriptor(expression,result);
    return VisitStatus.STOP_VISIT;
  }
  return VisitStatus.CONTINUE;
}","public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (!interestingElement(enclosingElement)) {
    return VisitStatus.CANCEL_MEMBER;
  }
  if (node instanceof ImportNode) {
    node=((ImportNode)node).getType();
    if (node == null) {
      return VisitStatus.CONTINUE;
    }
  }
  if (isValidNode(node) && doTest(node)) {
    Expression expression=(Expression)node;
    descriptor=createDescriptor(expression,result);
    return VisitStatus.STOP_VISIT;
  }
  return VisitStatus.CONTINUE;
}",0.9403383793410508
186009,"protected SuggestionDescriptor createDescriptor(ConstantExpression suggestionNode,TypeLookupResult result){
  ClassNode declaringTypeNode=result.declaringType;
  ClassNode suggestionTypeNode=result.type;
  VariableScope scope=result.scope;
  String declaringTypeName=declaringTypeNode.getName();
  String suggestionType=suggestionTypeNode.getName();
  Object suggestionName=suggestionNode.getValue();
  String name=suggestionName instanceof String ? (String)suggestionName : null;
  boolean isStatic=false;
  String javaDoc=null;
  boolean useNamedArguments=false;
  List<MethodParameter> parameters=null;
  boolean isMethod=isMethod(scope);
  boolean isActive=true;
  return isMethod ? new SuggestionDescriptor(declaringTypeName,isStatic,name,javaDoc,suggestionType,useNamedArguments,parameters,isActive) : new SuggestionDescriptor(declaringTypeName,isStatic,name,javaDoc,suggestionType,isActive);
}","protected SuggestionDescriptor createDescriptor(Expression suggestionNode,TypeLookupResult result){
  ClassNode declaringTypeNode=result.declaringType;
  ClassNode suggestionTypeNode=result.type;
  VariableScope scope=result.scope;
  String declaringTypeName=declaringTypeNode.getName();
  String suggestionType=suggestionTypeNode.getName();
  Object suggestionName=suggestionNode instanceof ConstantExpression ? ((ConstantExpression)suggestionNode).getValue() : suggestionNode.getText();
  String name=suggestionName instanceof String ? (String)suggestionName : null;
  boolean isStatic=false;
  String javaDoc=null;
  boolean useNamedArguments=false;
  List<MethodParameter> parameters=null;
  boolean isMethod=isMethod(scope);
  boolean isActive=true;
  return isMethod ? new SuggestionDescriptor(declaringTypeName,isStatic,name,javaDoc,suggestionType,useNamedArguments,parameters,isActive) : new SuggestionDescriptor(declaringTypeName,isStatic,name,javaDoc,suggestionType,isActive);
}",0.9449152542372882
186010,"protected ColumnTypes getColumnType(TreeColumn column){
  String columnName=column.getText();
  for (  ColumnTypes type : ColumnTypes.values()) {
    if (type.equals(columnName)) {
      return type;
    }
  }
  return null;
}","protected ColumnTypes getColumnType(TreeColumn column){
  String columnName=column.getText();
  for (  ColumnTypes type : ColumnTypes.values()) {
    if (type.getName().equals(columnName)) {
      return type;
    }
  }
  return null;
}",0.9783549783549784
186011,"protected String constructName(){
  if (suggestion == null) {
    return null;
  }
  StringBuffer buffer=new StringBuffer();
  String name=suggestion.getName();
  buffer.append(name);
  buffer.append(EMPTY_SPACE);
  buffer.append(COLON);
  buffer.append(EMPTY_SPACE);
  String typeName=suggestion.getType();
  buffer.append(typeName);
  List<MethodParameter> methodArguments=suggestion.getParameters();
  if (methodArguments != null) {
    buffer.append(OPEN_PAR);
    int size=methodArguments.size();
    for (    MethodParameter argument : methodArguments) {
      buffer.append(argument.getType());
      buffer.append(EMPTY_SPACE);
      buffer.append(argument.getName());
      if (--size > 0) {
        buffer.append(COMMA);
        buffer.append(EMPTY_SPACE);
      }
    }
    buffer.append(CLOSE_PAR);
  }
  return buffer.toString();
}","protected String constructName(){
  if (suggestion == null) {
    return null;
  }
  StringBuffer buffer=new StringBuffer();
  String name=suggestion.getName();
  buffer.append(name);
  String typeName=suggestion.getType();
  if (typeName != null && typeName.length() > 0) {
    buffer.append(EMPTY_SPACE);
    buffer.append(COLON);
    buffer.append(EMPTY_SPACE);
    buffer.append(typeName);
  }
  List<MethodParameter> parameters=suggestion.getParameters();
  if (parameters != null) {
    buffer.append(OPEN_PAR);
    int size=parameters.size();
    for (    MethodParameter param : parameters) {
      String paramType=param.getType();
      if (paramType != null && paramType.length() > 0) {
        buffer.append(paramType);
        buffer.append(EMPTY_SPACE);
      }
      buffer.append(param.getName());
      if (--size > 0) {
        buffer.append(COMMA);
        buffer.append(EMPTY_SPACE);
      }
    }
    buffer.append(CLOSE_PAR);
  }
  return buffer.toString();
}",0.6597260273972603
186012,"protected String constructName(){
  if (property == null) {
    return null;
  }
  StringBuffer buffer=new StringBuffer();
  String name=property.getName();
  buffer.append(name);
  buffer.append(EMPTY_SPACE);
  buffer.append(COLON);
  buffer.append(EMPTY_SPACE);
  String type=property.getType();
  buffer.append(type);
  return buffer.toString();
}","protected String constructName(){
  if (property == null) {
    return null;
  }
  StringBuffer buffer=new StringBuffer();
  String name=property.getName();
  buffer.append(name);
  String type=property.getType();
  if (type != null && type.length() > 0) {
    buffer.append(EMPTY_SPACE);
    buffer.append(COLON);
    buffer.append(EMPTY_SPACE);
    buffer.append(type);
  }
  return buffer.toString();
}",0.7072847682119205
186013,"public ValidatedValueSelectionListener(IDialogueControlDescriptor descriptor,Object initialValue){
  invalidValues.put(descriptor,new SetValue(initialValue,null));
}","public ValidatedValueSelectionListener(IDialogueControlDescriptor descriptor,Object initialValue){
  if (descriptor != null) {
    invalidValues.put(descriptor,new SetValue(initialValue,null));
  }
}",0.9065934065934066
186014,"protected void createFieldAreas(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),suggestionName);
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.NAME,suggestionName){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.DECLARING_TYPE,getOffsetLabelLocation(),declaringTypeName,getJavaProject()){
    protected IValueCheckingRule getCachedValidationRule(){
      return new JavaValidTypeRule(getJavaProject());
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  declaringTypeControl.setEnabled(true);
  declaringTypeControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.DECLARING_TYPE,declaringTypeName){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        declaringTypeName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl suggestionTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),suggestionType,getJavaProject());
  suggestionTypeControl.createControlArea(parent);
  suggestionTypeControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.TYPE,suggestionType){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionType=(String)selection;
      }
    }
  }
);
  ButtonDialogueControl isStaticButton=new ButtonDialogueControl(ControlTypes.IS_STATIC,SWT.CHECK,isStatic);
  isStaticButton.createControlArea(parent);
  isStaticButton.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof Boolean) {
        isStatic=((Boolean)selection).booleanValue();
      }
    }
  }
);
  ControlTypes defaultSuggestionTypeButton=isMethod ? ControlTypes.METHOD : ControlTypes.PROPERTY;
  RadioSelectionDialogueControl radioSelection=new RadioSelectionDialogueControl(new IDialogueControlDescriptor[]{ControlTypes.PROPERTY,ControlTypes.METHOD},defaultSuggestionTypeButton);
  radioSelection.createControlArea(parent);
  table=new MethodArgumentTable(getJavaProject(),initialParameters,useNamedArguments);
  table.createControlArea(parent);
  if (!isMethod) {
    table.setEnabled(false);
  }
  table.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (event.getControlDescriptor() == ControlTypes.USE_NAMED_ARGUMENTS && selection instanceof Boolean) {
        useNamedArguments=((Boolean)selection).booleanValue();
      }
    }
  }
);
  radioSelection.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      IDialogueControlDescriptor descriptor=event.getControlDescriptor();
      if (descriptor == ControlTypes.PROPERTY) {
        table.setEnabled(false);
        isMethod=false;
      }
 else       if (descriptor == ControlTypes.METHOD) {
        table.setEnabled(true);
        isMethod=true;
      }
    }
  }
);
}","protected void createFieldAreas(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),suggestionName);
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.NAME,suggestionName){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.DECLARING_TYPE,getOffsetLabelLocation(),declaringTypeName,getJavaProject()){
    protected IValueCheckingRule getCachedValidationRule(){
      return new JavaValidTypeRule(getJavaProject());
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  declaringTypeControl.setEnabled(true);
  declaringTypeControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.DECLARING_TYPE,declaringTypeName){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        declaringTypeName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl suggestionTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),suggestionType,getJavaProject()){
    protected ValueStatus isControlValueValid(    String value){
      if (value == null || value.length() == 0) {
        return ValueStatus.getValidStatus(value);
      }
      return super.isControlValueValid(value);
    }
  }
;
  suggestionTypeControl.createControlArea(parent);
  suggestionTypeControl.addSelectionListener(new ValidatedValueSelectionListener(){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionType=(String)selection;
      }
    }
  }
);
  ButtonDialogueControl isStaticButton=new ButtonDialogueControl(ControlTypes.IS_STATIC,SWT.CHECK,isStatic);
  isStaticButton.createControlArea(parent);
  isStaticButton.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof Boolean) {
        isStatic=((Boolean)selection).booleanValue();
      }
    }
  }
);
  ControlTypes defaultSuggestionTypeButton=isMethod ? ControlTypes.METHOD : ControlTypes.PROPERTY;
  RadioSelectionDialogueControl radioSelection=new RadioSelectionDialogueControl(new IDialogueControlDescriptor[]{ControlTypes.PROPERTY,ControlTypes.METHOD},defaultSuggestionTypeButton);
  radioSelection.createControlArea(parent);
  table=new MethodParameterTable(getJavaProject(),initialParameters,useNamedArguments);
  table.createControlArea(parent);
  if (!isMethod) {
    table.setEnabled(false);
  }
  table.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (event.getControlDescriptor() == ControlTypes.USE_NAMED_ARGUMENTS && selection instanceof Boolean) {
        useNamedArguments=((Boolean)selection).booleanValue();
      }
    }
  }
);
  radioSelection.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      IDialogueControlDescriptor descriptor=event.getControlDescriptor();
      if (descriptor == ControlTypes.PROPERTY) {
        table.setEnabled(false);
        isMethod=false;
      }
 else       if (descriptor == ControlTypes.METHOD) {
        table.setEnabled(true);
        isMethod=true;
      }
    }
  }
);
}",0.9626231277830252
186015,"protected void createCommandArea(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),name){
    protected ValueStatus isControlValueValid(    Control control){
      ValueStatus status=super.isControlValueValid(control);
      if (!status.isError()) {
        status=new DuplicateParameterRule(existingParameters).checkValidity(status.getValue());
      }
      return status;
    }
  }
;
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.NAME,name){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        name=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),type,javaProject){
    protected ValueStatus isControlValueValid(    String value){
      if (value == null || value.length() == 0) {
        return ValueStatus.getValidStatus(value);
      }
      return super.isControlValueValid(value);
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  declaringTypeControl.addSelectionListener(new ValidatedValueSelectionListener(){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        type=(String)selection;
      }
    }
  }
);
}","protected void createCommandArea(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),name){
    protected ValueStatus isControlValueValid(    Control control){
      ValueStatus status=super.isControlValueValid(control);
      if (!status.isError()) {
        status=new DuplicateParameterRule(existingParameters).checkValidity(status.getValue());
      }
      return status;
    }
  }
;
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.NAME,name){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        name=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl typeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),type,javaProject){
    protected ValueStatus isControlValueValid(    String value){
      if (value == null || value.length() == 0) {
        return ValueStatus.getValidStatus(value);
      }
      return super.isControlValueValid(value);
    }
  }
;
  typeControl.createControlArea(parent);
  typeControl.addSelectionListener(new ValidatedValueSelectionListener(){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        type=(String)selection;
      }
    }
  }
);
}",0.9890692282212652
186016,"public IJavaCompletionProposal[] getAssists(IInvocationContext context,IProblemLocation[] locations) throws CoreException {
  List<IJavaCompletionProposal> proposalList=new ArrayList<IJavaCompletionProposal>();
  IJavaCompletionProposal javaProposal=new InferencingSuggestionsQuickAssistProposal(context).convertToJavaCompletionProposal();
  proposalList.add(javaProposal);
  return proposalList.toArray(new IJavaCompletionProposal[]{});
}","public IJavaCompletionProposal[] getAssists(IInvocationContext context,IProblemLocation[] locations) throws CoreException {
  List<IJavaCompletionProposal> proposalList=new ArrayList<IJavaCompletionProposal>();
  IJavaCompletionProposal javaProposal=new AddSuggestionsQuickAssistProposal(context).convertToJavaCompletionProposal();
  proposalList.add(javaProposal);
  return proposalList.toArray(new IJavaCompletionProposal[]{});
}",0.9839080459770116
186017,"protected boolean allTypesExist(Type type,StringBuffer source,List<String> nonExistantTypes) throws JavaModelException {
  String typeName=getTypeName(type,source);
  IType actualType=getActualType(typeName);
  if (actualType != null) {
    if (type instanceof ParameterizedType) {
      List<?> parameterisedNodes=((ParameterizedType)type).typeArguments();
      if (parameterisedNodes != null) {
        boolean allParamsValid=true;
        for (        Object node : parameterisedNodes) {
          if (!(node instanceof Type) || !allTypesExist((Type)node,source,nonExistantTypes)) {
            allParamsValid=false;
            break;
          }
        }
        return allParamsValid;
      }
    }
    return true;
  }
 else {
    if (nonExistantTypes != null && !nonExistantTypes.contains(typeName)) {
      nonExistantTypes.add(typeName);
    }
  }
  return false;
}","protected boolean allTypesExist(Type type,StringBuffer source,List<String> nonExistantTypes) throws JavaModelException {
  String typeName=getTypeName(type,source);
  IType actualType=getActualType(typeName);
  if (actualType != null) {
    if (type instanceof ParameterizedType) {
      List<?> parameterisedNodes=((ParameterizedType)type).typeArguments();
      if (parameterisedNodes != null) {
        boolean allParamsValid=true;
        for (        Object node : parameterisedNodes) {
          if (!(node instanceof Type) || !allTypesExist((Type)node,source,nonExistantTypes)) {
            allParamsValid=false;
            break;
          }
        }
        return allParamsValid;
      }
    }
    return true;
  }
 else   if (type instanceof PrimitiveType || type instanceof ArrayType) {
    return true;
  }
 else {
    if (nonExistantTypes != null && !nonExistantTypes.contains(typeName)) {
      nonExistantTypes.add(typeName);
    }
  }
  return false;
}",0.9486208761492698
186018,"public List<IContributionElement> getContributions(GroovyDSLDContext pattern,BindingSet matches){
  List<IContributionElement> currentContributions=new ArrayList<IContributionElement>();
  List<GroovySuggestionDeclaringType> superTypes=new DeclaringTypeSuperTypeMatcher(file.getProject()).getAllSuperTypes(pattern);
  if (superTypes != null) {
    for (    GroovySuggestionDeclaringType declaringType : superTypes) {
      List<IGroovySuggestion> suggestions=declaringType.getSuggestions();
      if (suggestions != null) {
        for (        IGroovySuggestion suggestion : suggestions) {
          if (!suggestion.isActive()) {
            continue;
          }
          if (suggestion instanceof GroovyPropertySuggestion) {
            GroovyPropertySuggestion prop=(GroovyPropertySuggestion)suggestion;
            currentContributions.add(new PropertyContributionElement(prop.getName(),prop.getType(),prop.getDeclaringType().getName(),prop.isStatic(),DEFAULT_PROVIDER,prop.getJavaDoc(),false,DEFAULT_RELEVANCE_MULTIPLIER));
          }
 else           if (suggestion instanceof GroovyMethodSuggestion) {
            GroovyMethodSuggestion method=(GroovyMethodSuggestion)suggestion;
            ParameterContribution[] paramContribution=null;
            List<MethodParameter> parameters=method.getParameters();
            if (parameters != null) {
              paramContribution=new ParameterContribution[method.getParameters().size()];
              int i=0;
              for (              MethodParameter parameter : parameters) {
                if (i < paramContribution.length) {
                  paramContribution[i++]=new ParameterContribution(parameter.getName(),parameter.getType());
                }
              }
            }
            currentContributions.add(new MethodContributionElement(method.getName(),paramContribution,method.getType(),method.getDeclaringType().getName(),method.isStatic(),DEFAULT_PROVIDER,method.getJavaDoc(),method.useNamedArguments(),false,DEFAULT_RELEVANCE_MULTIPLIER));
          }
        }
      }
      return currentContributions;
    }
  }
  return null;
}","public List<IContributionElement> getContributions(GroovyDSLDContext pattern,BindingSet matches){
  List<IContributionElement> currentContributions=new ArrayList<IContributionElement>();
  List<GroovySuggestionDeclaringType> superTypes=new DeclaringTypeSuperTypeMatcher(file.getProject()).getAllSuperTypes(pattern);
  if (superTypes != null) {
    for (    GroovySuggestionDeclaringType declaringType : superTypes) {
      List<IGroovySuggestion> suggestions=declaringType.getSuggestions();
      if (suggestions != null) {
        for (        IGroovySuggestion suggestion : suggestions) {
          if (suggestion.isActive()) {
            if (suggestion instanceof GroovyPropertySuggestion) {
              GroovyPropertySuggestion prop=(GroovyPropertySuggestion)suggestion;
              currentContributions.add(new PropertyContributionElement(prop.getName(),prop.getType(),prop.getDeclaringType().getName(),prop.isStatic(),DEFAULT_PROVIDER,prop.getJavaDoc(),false,DEFAULT_RELEVANCE_MULTIPLIER));
            }
 else             if (suggestion instanceof GroovyMethodSuggestion) {
              GroovyMethodSuggestion method=(GroovyMethodSuggestion)suggestion;
              ParameterContribution[] paramContribution=null;
              List<MethodParameter> parameters=method.getParameters();
              if (parameters != null) {
                paramContribution=new ParameterContribution[method.getParameters().size()];
                int i=0;
                for (                MethodParameter parameter : parameters) {
                  if (i < paramContribution.length) {
                    paramContribution[i++]=new ParameterContribution(parameter.getName(),parameter.getType());
                  }
                }
              }
              currentContributions.add(new MethodContributionElement(method.getName(),paramContribution,method.getType(),method.getDeclaringType().getName(),method.isStatic(),DEFAULT_PROVIDER,method.getJavaDoc(),method.useNamedArguments(),false,DEFAULT_RELEVANCE_MULTIPLIER));
            }
          }
        }
      }
    }
    return currentContributions;
  }
  return null;
}",0.9113566893957208
186019,"protected void handleSelectionButtonEnablement(List<Object> selectedObjects){
  if (projects == null || projects.isEmpty()) {
    selectionButtons.get(ButtonTypes.ADD).setEnabled(false);
    selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
    selectionButtons.get(ButtonTypes.REMOVE).setEnabled(false);
  }
 else   if (selectedObjects == null || selectedObjects.isEmpty()) {
    selectionButtons.get(ButtonTypes.ADD).setEnabled(true);
    selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
    selectionButtons.get(ButtonTypes.REMOVE).setEnabled(false);
  }
 else   if (selectedObjects.size() == 1) {
    Object selectedObj=selectedObjects.get(0);
    if (selectedObj instanceof GroovySuggestionDeclaringType) {
      selectionButtons.get(ButtonTypes.ADD).setEnabled(true);
      selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
      selectionButtons.get(ButtonTypes.REMOVE).setEnabled(true);
    }
 else     if (selectedObj instanceof IGroovySuggestion) {
      selectionButtons.get(ButtonTypes.ADD).setEnabled(false);
      selectionButtons.get(ButtonTypes.EDIT).setEnabled(true);
      selectionButtons.get(ButtonTypes.REMOVE).setEnabled(true);
    }
  }
 else {
    selectionButtons.get(ButtonTypes.ADD).setEnabled(false);
    selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
    selectionButtons.get(ButtonTypes.REMOVE).setEnabled(true);
  }
}","protected void handleSelectionButtonEnablement(List<Object> selectedObjects){
  if (projects == null || projects.isEmpty()) {
    selectionButtons.get(ButtonTypes.ADD).setEnabled(false);
    selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
    selectionButtons.get(ButtonTypes.REMOVE).setEnabled(false);
  }
 else   if (selectedObjects == null || selectedObjects.isEmpty()) {
    selectionButtons.get(ButtonTypes.ADD).setEnabled(true);
    selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
    selectionButtons.get(ButtonTypes.REMOVE).setEnabled(false);
  }
 else   if (selectedObjects.size() == 1) {
    Object selectedObj=selectedObjects.get(0);
    if (selectedObj instanceof GroovySuggestionDeclaringType) {
      selectionButtons.get(ButtonTypes.ADD).setEnabled(true);
      selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
      selectionButtons.get(ButtonTypes.REMOVE).setEnabled(true);
    }
 else     if (selectedObj instanceof IGroovySuggestion) {
      selectionButtons.get(ButtonTypes.ADD).setEnabled(true);
      selectionButtons.get(ButtonTypes.EDIT).setEnabled(true);
      selectionButtons.get(ButtonTypes.REMOVE).setEnabled(true);
    }
  }
 else {
    selectionButtons.get(ButtonTypes.ADD).setEnabled(false);
    selectionButtons.get(ButtonTypes.EDIT).setEnabled(false);
    selectionButtons.get(ButtonTypes.REMOVE).setEnabled(true);
  }
}",0.9974701843151428
186020,"/** 
 * Dialogue can only be opened on ONE selection or no selections. It will not be opened on multiple selections.
 */
protected void editSuggestion(){
  if (getSelections().size() > 1) {
    return;
  }
 else {
    if (getSelections().size() == 1) {
      Object selectedObj=getSelections().get(0);
      if (selectedObj instanceof IGroovySuggestion) {
        IGroovySuggestion suggestion=(IGroovySuggestion)selectedObj;
        InferencingContributionDialogue dialogue=new InferencingContributionDialogue(getShell(),suggestion,getSelectedProject());
        if (dialogue.open() == Window.OK) {
          SuggestionDescriptor descriptor=dialogue.getSuggestionChange();
          GroovySuggestionDeclaringType declaringType=suggestion.getDeclaringType();
          IGroovySuggestion replacedSuggestion=declaringType.replaceSuggestion(descriptor,suggestion);
          refresh();
          setCheckState(replacedSuggestion);
        }
      }
    }
  }
}","/** 
 * Dialogue can only be opened on ONE selection or no selections. It will not be opened on multiple selections.
 */
protected void editSuggestion(){
  if (getSelections().size() > 1) {
    return;
  }
 else {
    if (getSelections().size() == 1) {
      Object selectedObj=getSelections().get(0);
      if (selectedObj instanceof IGroovySuggestion) {
        IGroovySuggestion existingSuggestion=(IGroovySuggestion)selectedObj;
        InferencingContributionDialogue dialogue=new InferencingContributionDialogue(getShell(),existingSuggestion,getSelectedProject());
        IGroovySuggestion editedSuggestion=null;
        if (dialogue.open() == Window.OK) {
          SuggestionDescriptor descriptor=dialogue.getSuggestionChange();
          GroovySuggestionDeclaringType declaringType=existingSuggestion.getDeclaringType();
          if (!declaringType.getName().equals(descriptor.getDeclaringTypeName())) {
            declaringType.removeSuggestion(existingSuggestion);
            ProjectSuggestions projectSuggestions=InferencingSuggestionsManager.getInstance().getSuggestions(getSelectedProject());
            if (declaringType.getSuggestions().isEmpty()) {
              projectSuggestions.removeDeclaringType(declaringType);
            }
            editedSuggestion=projectSuggestions.addSuggestion(descriptor);
          }
 else {
            editedSuggestion=declaringType.replaceSuggestion(descriptor,existingSuggestion);
          }
          refresh();
          setCheckState(editedSuggestion);
        }
      }
    }
  }
}",0.7391130643228127
186021,"protected void handleRemove(){
  List<Object> selections=getSelections();
  for (  Object obj : selections) {
    if (obj instanceof GroovySuggestionDeclaringType) {
      InferencingSuggestionsManager.getInstance().getSuggestions(getSelectedProject()).removeDeclaringType((GroovySuggestionDeclaringType)obj);
    }
 else     if (obj instanceof IGroovySuggestion) {
      IGroovySuggestion suggestion=(IGroovySuggestion)obj;
      GroovySuggestionDeclaringType containingType=suggestion.getDeclaringType();
      containingType.removeSuggestion(suggestion);
      if (containingType.getSuggestions().isEmpty()) {
        InferencingSuggestionsManager.getInstance().getSuggestions(getSelectedProject()).removeDeclaringType(containingType);
      }
    }
  }
  refresh();
}","protected void handleRemove(){
  List<Object> selections=getSelections();
  for (  Object obj : selections) {
    if (obj instanceof GroovySuggestionDeclaringType) {
      InferencingSuggestionsManager.getInstance().getSuggestions(getSelectedProject()).removeDeclaringType((GroovySuggestionDeclaringType)obj);
    }
 else     if (obj instanceof IGroovySuggestion) {
      IGroovySuggestion suggestion=(IGroovySuggestion)obj;
      GroovySuggestionDeclaringType declaringType=suggestion.getDeclaringType();
      declaringType.removeSuggestion(suggestion);
      if (declaringType.getSuggestions().isEmpty()) {
        InferencingSuggestionsManager.getInstance().getSuggestions(getSelectedProject()).removeDeclaringType(declaringType);
      }
    }
  }
  refresh();
}",0.9661898569570871
186022,"public void handleSelection(ControlSelectionEvent event){
  handleRequiredValue(event);
  notifyValidValueSet(event.getControlDescriptor(),event.getSelectionData());
}","public void handleSelection(ControlSelectionEvent event){
  handleValidatedValue(event);
  notifyValidValueSet(event.getControlDescriptor(),event.getSelectionData());
}",0.9671641791044776
186023,"protected void createFieldAreas(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),suggestionName);
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.NAME,suggestionName){
    protected void handleRequiredValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.DECLARING_TYPE,getOffsetLabelLocation(),declaringTypeName,getJavaProject()){
    protected IValueCheckingRule getCachedValidationRule(){
      return new JavaValidTypeRule(getJavaProject());
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  if (editDeclaringType) {
    declaringTypeControl.setEnabled(true);
    declaringTypeControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.DECLARING_TYPE,declaringTypeName){
      protected void handleRequiredValue(      ControlSelectionEvent event){
        Object selection=event.getSelectionData();
        if (selection instanceof String) {
          declaringTypeName=(String)selection;
        }
      }
    }
);
  }
 else {
    declaringTypeControl.setEnabled(false);
  }
  JavaTypeBrowsingControl suggestionTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),suggestionType,getJavaProject());
  suggestionTypeControl.createControlArea(parent);
  suggestionTypeControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.TYPE,suggestionType){
    protected void handleRequiredValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionType=(String)selection;
      }
    }
  }
);
  ButtonDialogueControl isStaticButton=new ButtonDialogueControl(ControlTypes.IS_STATIC,SWT.CHECK,isStatic);
  isStaticButton.createControlArea(parent);
  isStaticButton.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof Boolean) {
        isStatic=((Boolean)selection).booleanValue();
      }
    }
  }
);
  ControlTypes defaultSuggestionTypeButton=isMethod ? ControlTypes.METHOD : ControlTypes.PROPERTY;
  RadioSelectionDialogueControl radioSelection=new RadioSelectionDialogueControl(new IDialogueControlDescriptor[]{ControlTypes.PROPERTY,ControlTypes.METHOD},defaultSuggestionTypeButton);
  radioSelection.createControlArea(parent);
  table=new MethodArgumentTable(getJavaProject(),initialParameters,useNamedArguments);
  table.createControlArea(parent);
  if (!isMethod) {
    table.setEnabled(false);
  }
  table.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (event.getControlDescriptor() == ControlTypes.USE_NAMED_ARGUMENTS && selection instanceof Boolean) {
        useNamedArguments=((Boolean)selection).booleanValue();
      }
    }
  }
);
  radioSelection.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      IDialogueControlDescriptor descriptor=event.getControlDescriptor();
      if (descriptor == ControlTypes.PROPERTY) {
        table.setEnabled(false);
        isMethod=false;
      }
 else       if (descriptor == ControlTypes.METHOD) {
        table.setEnabled(true);
        isMethod=true;
      }
    }
  }
);
}","protected void createFieldAreas(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),suggestionName);
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.NAME,suggestionName){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.DECLARING_TYPE,getOffsetLabelLocation(),declaringTypeName,getJavaProject()){
    protected IValueCheckingRule getCachedValidationRule(){
      return new JavaValidTypeRule(getJavaProject());
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  declaringTypeControl.setEnabled(true);
  declaringTypeControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.DECLARING_TYPE,declaringTypeName){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        declaringTypeName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl suggestionTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),suggestionType,getJavaProject());
  suggestionTypeControl.createControlArea(parent);
  suggestionTypeControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.TYPE,suggestionType){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionType=(String)selection;
      }
    }
  }
);
  ButtonDialogueControl isStaticButton=new ButtonDialogueControl(ControlTypes.IS_STATIC,SWT.CHECK,isStatic);
  isStaticButton.createControlArea(parent);
  isStaticButton.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof Boolean) {
        isStatic=((Boolean)selection).booleanValue();
      }
    }
  }
);
  ControlTypes defaultSuggestionTypeButton=isMethod ? ControlTypes.METHOD : ControlTypes.PROPERTY;
  RadioSelectionDialogueControl radioSelection=new RadioSelectionDialogueControl(new IDialogueControlDescriptor[]{ControlTypes.PROPERTY,ControlTypes.METHOD},defaultSuggestionTypeButton);
  radioSelection.createControlArea(parent);
  table=new MethodArgumentTable(getJavaProject(),initialParameters,useNamedArguments);
  table.createControlArea(parent);
  if (!isMethod) {
    table.setEnabled(false);
  }
  table.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (event.getControlDescriptor() == ControlTypes.USE_NAMED_ARGUMENTS && selection instanceof Boolean) {
        useNamedArguments=((Boolean)selection).booleanValue();
      }
    }
  }
);
  radioSelection.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      IDialogueControlDescriptor descriptor=event.getControlDescriptor();
      if (descriptor == ControlTypes.PROPERTY) {
        table.setEnabled(false);
        isMethod=false;
      }
 else       if (descriptor == ControlTypes.METHOD) {
        table.setEnabled(true);
        isMethod=true;
      }
    }
  }
);
}",0.9599018003273322
186024,"protected void setSuggestion(IGroovySuggestion suggestion){
  this.currentSuggestion=suggestion;
  if (currentSuggestion != null) {
    editDeclaringType=false;
    isStatic=currentSuggestion.isStatic();
    suggestionName=currentSuggestion.getName();
    declaringTypeName=currentSuggestion.getDeclaringType().getName();
    javaDoc=currentSuggestion.getJavaDoc();
    suggestionType=currentSuggestion.getType();
    isActive=currentSuggestion.isActive();
    if (currentSuggestion instanceof GroovyMethodSuggestion) {
      GroovyMethodSuggestion method=(GroovyMethodSuggestion)currentSuggestion;
      initialParameters=method.getParameters();
      useNamedArguments=method.useNamedArguments();
      isMethod=true;
    }
  }
}","protected void setSuggestion(IGroovySuggestion suggestion){
  this.currentSuggestion=suggestion;
  if (currentSuggestion != null) {
    isStatic=currentSuggestion.isStatic();
    suggestionName=currentSuggestion.getName();
    declaringTypeName=currentSuggestion.getDeclaringType().getName();
    javaDoc=currentSuggestion.getJavaDoc();
    suggestionType=currentSuggestion.getType();
    isActive=currentSuggestion.isActive();
    if (currentSuggestion instanceof GroovyMethodSuggestion) {
      GroovyMethodSuggestion method=(GroovyMethodSuggestion)currentSuggestion;
      initialParameters=method.getParameters();
      useNamedArguments=method.useNamedArguments();
      isMethod=true;
    }
  }
}",0.7257501744591766
186025,"protected InferencingContributionDialogue(Shell parentShell,IProject project,IGroovySuggestion currentSuggestion,GroovySuggestionDeclaringType declaringType,boolean editDeclaringType,boolean isActive){
  super(parentShell,DIALOGUE_DESCRIPTOR);
  this.project=project;
  this.currentSuggestion=currentSuggestion;
  this.declaringTypeName=declaringType != null ? declaringType.getName() : null;
  this.editDeclaringType=editDeclaringType;
  this.isActive=isActive;
}","protected InferencingContributionDialogue(Shell parentShell,IProject project,IGroovySuggestion currentSuggestion,GroovySuggestionDeclaringType declaringType,boolean isActive){
  super(parentShell,DIALOGUE_DESCRIPTOR);
  this.project=project;
  this.currentSuggestion=currentSuggestion;
  this.declaringTypeName=declaringType != null ? declaringType.getName() : null;
  this.isActive=isActive;
}",0.9184149184149184
186026,"protected void editElement(){
  MethodParameter selected=getSelectedElement();
  if (selected != null) {
    MethodArgumentDialogue dialogue=new MethodArgumentDialogue(getShell(),project,selected,parameters);
    if (dialogue.open() == Window.OK) {
      MethodParameter editedParameter=dialogue.getMethodParameter();
      if (editedParameter != null) {
        int selectionIndex=viewer.getTable().getSelectionIndex();
        parameters.remove(selected);
        if (selectionIndex >= 0) {
          parameters.add(selectionIndex,editedParameter);
        }
 else {
          parameters.add(editedParameter);
        }
      }
      refreshTable();
    }
  }
}","protected void editElement(){
  MethodParameter selected=getSelectedElement();
  if (selected != null) {
    MethodParameterDialogue dialogue=new MethodParameterDialogue(getShell(),project,selected,parameters);
    if (dialogue.open() == Window.OK) {
      MethodParameter editedParameter=dialogue.getMethodParameter();
      if (editedParameter != null) {
        int selectionIndex=viewer.getTable().getSelectionIndex();
        parameters.remove(selected);
        if (selectionIndex >= 0) {
          parameters.add(selectionIndex,editedParameter);
        }
 else {
          parameters.add(editedParameter);
        }
      }
      refreshTable();
    }
  }
}",0.9623493975903614
186027,"protected void addElement(){
  MethodArgumentDialogue dialogue=new MethodArgumentDialogue(getShell(),project,null,parameters);
  if (dialogue.open() == Window.OK) {
    MethodParameter parameter=dialogue.getMethodParameter();
    if (parameter != null) {
      int selectionIndex=viewer.getTable().getSelectionIndex();
      if (selectionIndex >= 0) {
        parameters.add(selectionIndex,parameter);
      }
 else {
        parameters.add(parameter);
      }
    }
    refreshTable();
  }
}","protected void addElement(){
  MethodParameterDialogue dialogue=new MethodParameterDialogue(getShell(),project,null,parameters);
  if (dialogue.open() == Window.OK) {
    MethodParameter parameter=dialogue.getMethodParameter();
    if (parameter != null) {
      int selectionIndex=viewer.getTable().getSelectionIndex();
      if (selectionIndex >= 0) {
        parameters.add(selectionIndex,parameter);
      }
 else {
        parameters.add(parameter);
      }
    }
    refreshTable();
  }
}",0.9655172413793104
186028,"protected Type getASTType(String typeToCheck,StringBuffer sourceBuffer){
  sourceBuffer.append(""String_Node_Str"");
  int valueOffset=sourceBuffer.length();
  sourceBuffer.append(typeToCheck).append(""String_Node_Str"");
  sourceBuffer.append(""String_Node_Str"");
  ASTParser parser=ASTParser.newParser(AST.JLS3);
  parser.setSource(sourceBuffer.toString().toCharArray());
  Map<?,?> options=new HashMap<Object,Object>();
  JavaModelUtil.set50ComplianceOptions(options);
  parser.setCompilerOptions(options);
  CompilationUnit cu=(CompilationUnit)parser.createAST(null);
  ASTNode selected=NodeFinder.perform(cu,valueOffset,typeToCheck.length());
  if (selected instanceof Name) {
    selected=selected.getParent();
  }
  if (selected instanceof Type) {
    return (Type)selected;
  }
  return null;
}","protected Type getASTType(String typeToCheck,StringBuffer sourceBuffer){
  sourceBuffer.append(""String_Node_Str"");
  int valueOffset=sourceBuffer.length();
  sourceBuffer.append(typeToCheck).append(""String_Node_Str"");
  sourceBuffer.append(""String_Node_Str"");
  ASTParser parser=ASTParser.newParser(AST.JLS3);
  parser.setSource(sourceBuffer.toString().toCharArray());
  Map<String,String> options=new HashMap<String,String>();
  JavaModelUtil.set50ComplianceOptions(options);
  parser.setCompilerOptions(options);
  CompilationUnit cu=(CompilationUnit)parser.createAST(null);
  ASTNode selected=NodeFinder.perform(cu,valueOffset,typeToCheck.length());
  if (selected instanceof Name) {
    selected=selected.getParent();
  }
  if (selected instanceof Type) {
    return (Type)selected;
  }
  return null;
}",0.9763092269326684
186029,"public JavaValidParameterizedTypeRule(IJavaProject project){
  this.project=project;
}","public JavaValidParameterizedTypeRule(IJavaProject project){
  super(project);
}",0.891566265060241
186030,"public ValueStatus checkValidity(Object value){
  if (!(value instanceof String)) {
    return ValueStatus.getErrorStatus(value);
  }
  String typeToCheck=(String)value;
  if (!typeToCheck.trim().equals(typeToCheck)) {
    return ValueStatus.getErrorStatus(typeToCheck,INVALID_JAVA);
  }
  StringBuffer source=new StringBuffer();
  Type astType=getASTType(typeToCheck,source);
  if (astType != null) {
    try {
      boolean isValid=isParameterisedTypeValid(astType,source);
      if (isValid) {
        return ValueStatus.getValidStatus(value);
      }
    }
 catch (    JavaModelException e) {
      Activator.logError(e);
      return ValueStatus.getErrorStatus(value,e.getLocalizedMessage());
    }
  }
  return ValueStatus.getErrorStatus(value,INVALID_JAVA);
}","public ValueStatus checkValidity(Object value){
  if (!(value instanceof String)) {
    return ValueStatus.getErrorStatus(value);
  }
  String typeToCheck=(String)value;
  StringBuffer source=new StringBuffer();
  Type astType=getASTType(typeToCheck,source);
  List<String> allNonExistantTypes=new ArrayList<String>();
  if (astType != null) {
    try {
      boolean isValid=allTypesExist(astType,source,allNonExistantTypes);
      if (!isValid) {
        String message=composeErrorMessage(allNonExistantTypes);
        return ValueStatus.getErrorStatus(value,message);
      }
 else {
        return ValueStatus.getValidStatus(value);
      }
    }
 catch (    JavaModelException e) {
      Activator.logError(e);
      return ValueStatus.getErrorStatus(value,e.getLocalizedMessage());
    }
  }
  return ValueStatus.getErrorStatus(value,INVALID_JAVA);
}",0.2637091805298829
186031,"protected void createFieldAreas(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),suggestionName);
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.NAME,suggestionName){
    protected void handleRequiredValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.DECLARING_TYPE,getOffsetLabelLocation(),declaringTypeName,getJavaProject()){
    protected ValueStatus isControlValueValid(    String value){
      return new JavaValidTypeRule().checkValidity(value);
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  if (editDeclaringType) {
    declaringTypeControl.setEnabled(true);
    declaringTypeControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.DECLARING_TYPE,declaringTypeName){
      protected void handleRequiredValue(      ControlSelectionEvent event){
        Object selection=event.getSelectionData();
        if (selection instanceof String) {
          declaringTypeName=(String)selection;
        }
      }
    }
);
  }
 else {
    declaringTypeControl.setEnabled(false);
  }
  JavaTypeBrowsingControl suggestionTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),suggestionType,getJavaProject());
  suggestionTypeControl.createControlArea(parent);
  suggestionTypeControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.TYPE,suggestionType){
    protected void handleRequiredValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionType=(String)selection;
      }
    }
  }
);
  ButtonDialogueControl isStaticButton=new ButtonDialogueControl(ControlTypes.IS_STATIC,SWT.CHECK,isStatic);
  isStaticButton.createControlArea(parent);
  isStaticButton.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof Boolean) {
        isStatic=((Boolean)selection).booleanValue();
      }
    }
  }
);
  ControlTypes defaultSuggestionTypeButton=isMethod ? ControlTypes.METHOD : ControlTypes.PROPERTY;
  RadioSelectionDialogueControl radioSelection=new RadioSelectionDialogueControl(new IDialogueControlDescriptor[]{ControlTypes.PROPERTY,ControlTypes.METHOD},defaultSuggestionTypeButton);
  radioSelection.createControlArea(parent);
  table=new MethodArgumentTable(getJavaProject(),initialParameters,useNamedArguments);
  table.createControlArea(parent);
  if (!isMethod) {
    table.setEnabled(false);
  }
  table.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (event.getControlDescriptor() == ControlTypes.USE_NAMED_ARGUMENTS && selection instanceof Boolean) {
        useNamedArguments=((Boolean)selection).booleanValue();
      }
    }
  }
);
  radioSelection.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      IDialogueControlDescriptor descriptor=event.getControlDescriptor();
      if (descriptor == ControlTypes.PROPERTY) {
        table.setEnabled(false);
        isMethod=false;
      }
 else       if (descriptor == ControlTypes.METHOD) {
        table.setEnabled(true);
        isMethod=true;
      }
    }
  }
);
}","protected void createFieldAreas(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),suggestionName);
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.NAME,suggestionName){
    protected void handleRequiredValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionName=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.DECLARING_TYPE,getOffsetLabelLocation(),declaringTypeName,getJavaProject()){
    protected IValueCheckingRule getCachedValidationRule(){
      return new JavaValidTypeRule(getJavaProject());
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  if (editDeclaringType) {
    declaringTypeControl.setEnabled(true);
    declaringTypeControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.DECLARING_TYPE,declaringTypeName){
      protected void handleRequiredValue(      ControlSelectionEvent event){
        Object selection=event.getSelectionData();
        if (selection instanceof String) {
          declaringTypeName=(String)selection;
        }
      }
    }
);
  }
 else {
    declaringTypeControl.setEnabled(false);
  }
  JavaTypeBrowsingControl suggestionTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),suggestionType,getJavaProject());
  suggestionTypeControl.createControlArea(parent);
  suggestionTypeControl.addSelectionListener(new RequiredValueControlSelectionListener(ControlTypes.TYPE,suggestionType){
    protected void handleRequiredValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        suggestionType=(String)selection;
      }
    }
  }
);
  ButtonDialogueControl isStaticButton=new ButtonDialogueControl(ControlTypes.IS_STATIC,SWT.CHECK,isStatic);
  isStaticButton.createControlArea(parent);
  isStaticButton.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof Boolean) {
        isStatic=((Boolean)selection).booleanValue();
      }
    }
  }
);
  ControlTypes defaultSuggestionTypeButton=isMethod ? ControlTypes.METHOD : ControlTypes.PROPERTY;
  RadioSelectionDialogueControl radioSelection=new RadioSelectionDialogueControl(new IDialogueControlDescriptor[]{ControlTypes.PROPERTY,ControlTypes.METHOD},defaultSuggestionTypeButton);
  radioSelection.createControlArea(parent);
  table=new MethodArgumentTable(getJavaProject(),initialParameters,useNamedArguments);
  table.createControlArea(parent);
  if (!isMethod) {
    table.setEnabled(false);
  }
  table.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (event.getControlDescriptor() == ControlTypes.USE_NAMED_ARGUMENTS && selection instanceof Boolean) {
        useNamedArguments=((Boolean)selection).booleanValue();
      }
    }
  }
);
  radioSelection.addSelectionListener(new ControlSelectionListener(){
    public void handleSelection(    ControlSelectionEvent event){
      IDialogueControlDescriptor descriptor=event.getControlDescriptor();
      if (descriptor == ControlTypes.PROPERTY) {
        table.setEnabled(false);
        isMethod=false;
      }
 else       if (descriptor == ControlTypes.METHOD) {
        table.setEnabled(true);
        isMethod=true;
      }
    }
  }
);
}",0.9766881028938906
186032,"/** 
 * Creates a new instance of the suggestion in the specified declaring type.
 * @param type
 * @param isActive whether the suggestion should be active in the declaringtype
 * @return
 */
public IGroovySuggestion createSuggestion(SuggestionDescriptor descriptor){
  IGroovySuggestion suggestion=new SuggestionFactory(descriptor).createSuggestion(this);
  suggestions.add(suggestion);
  return suggestion;
}","/** 
 * Creates a new instance of the suggestion in the specified declaring type. If a suggestion already exists that matches the descriptor, null is returned
 * @param type
 * @param isActive whether the suggestion should be active in the declaringtype
 * @return new created suggestion, or null if the suggestion already exists
 */
public IGroovySuggestion createSuggestion(SuggestionDescriptor descriptor){
  IGroovySuggestion suggestion=new SuggestionFactory(descriptor).createSuggestion(this);
  if (suggestions.contains(suggestion)) {
    return null;
  }
  suggestions.add(suggestion);
  return suggestion;
}",0.8
186033,"/** 
 * Creates a declaring type or returns an existing one.
 * @param declaringTypeName
 * @return
 */
public IGroovySuggestion addSuggestion(SuggestionDescriptor descriptor){
  String declaringTypeName=descriptor.getDeclaringTypeName();
  GroovySuggestionDeclaringType declaringType=suggestions.get(declaringTypeName);
  if (declaringType == null) {
    declaringType=new GroovySuggestionDeclaringType(declaringTypeName);
    suggestions.put(declaringTypeName,declaringType);
  }
  return declaringType.createSuggestion(descriptor);
}","/** 
 * Creates a declaring type or returns an existing one.
 * @param declaringTypeName
 * @return
 */
public IGroovySuggestion addSuggestion(SuggestionDescriptor descriptor){
  String declaringTypeName=descriptor.getDeclaringTypeName();
  GroovySuggestionDeclaringType declaringType=suggestions.get(declaringTypeName);
  if (declaringType == null) {
    declaringType=new GroovySuggestionDeclaringType(declaringTypeName);
  }
  IGroovySuggestion createdSuggestion=declaringType.createSuggestion(descriptor);
  if (createdSuggestion != null && !suggestions.containsKey(declaringType.getName())) {
    suggestions.put(declaringTypeName,declaringType);
  }
  return createdSuggestion;
}",0.76003276003276
186034,"protected void addSuggestion(){
  if (getSelections().size() > 1) {
    return;
  }
 else {
    InferencingContributionDialogue dialogue=null;
    if (getSelections().size() == 1) {
      Object selectedObj=getSelections().get(0);
      if (selectedObj instanceof GroovySuggestionDeclaringType) {
        dialogue=new InferencingContributionDialogue(getShell(),(GroovySuggestionDeclaringType)selectedObj,getSelectedProject());
      }
 else       if (selectedObj instanceof IGroovySuggestion) {
        dialogue=new InferencingContributionDialogue(getShell(),(IGroovySuggestion)selectedObj,getSelectedProject());
      }
    }
 else {
      dialogue=new InferencingContributionDialogue(getShell(),getSelectedProject());
    }
    if (dialogue != null && dialogue.open() == Window.OK) {
      SuggestionDescriptor descriptor=dialogue.getSuggestionChange();
      IProject project=getSelectedProject();
      if (project != null) {
        IGroovySuggestion suggestion=InferencingSuggestionsManager.getInstance().getSuggestions(project).addSuggestion(descriptor);
        if (suggestion != null) {
          refresh();
          setCheckState(suggestion);
        }
      }
    }
  }
}","protected void addSuggestion(){
  if (getSelections().size() > 1) {
    return;
  }
 else {
    InferencingContributionDialogue dialogue=null;
    if (getSelections().size() == 1) {
      Object selectedObj=getSelections().get(0);
      if (selectedObj instanceof GroovySuggestionDeclaringType) {
        dialogue=new InferencingContributionDialogue(getShell(),(GroovySuggestionDeclaringType)selectedObj,getSelectedProject());
      }
 else       if (selectedObj instanceof IGroovySuggestion) {
        dialogue=new InferencingContributionDialogue(getShell(),((IGroovySuggestion)selectedObj).getDeclaringType(),getSelectedProject());
      }
    }
 else {
      dialogue=new InferencingContributionDialogue(getShell(),getSelectedProject());
    }
    if (dialogue != null && dialogue.open() == Window.OK) {
      SuggestionDescriptor descriptor=dialogue.getSuggestionChange();
      IProject project=getSelectedProject();
      if (project != null) {
        IGroovySuggestion suggestion=InferencingSuggestionsManager.getInstance().getSuggestions(project).addSuggestion(descriptor);
        if (suggestion != null) {
          refresh();
          setCheckState(suggestion);
        }
      }
    }
  }
}",0.9912023460410556
186035,"protected void createCommandArea(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),name){
    protected ValueStatus isControlValueValid(    Control control){
      ValueStatus status=super.isControlValueValid(control);
      if (!status.isError()) {
        status=new DuplicateParameterRule(existingParameters).checkValidity(status.getValue());
      }
      return status;
    }
  }
;
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.NAME,name){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        name=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),type,javaProject){
    protected ValueStatus isControlValueValid(    String value){
      if (value == null || value.length() == 0) {
        return ValueStatus.getValidStatus(value);
      }
      return super.isControlValueValid(value);
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  declaringTypeControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.TYPE,type){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        type=(String)selection;
      }
    }
  }
);
}","protected void createCommandArea(Composite parent){
  JavaTextControl nameControl=new JavaTextControl(ControlTypes.NAME,getOffsetLabelLocation(),name){
    protected ValueStatus isControlValueValid(    Control control){
      ValueStatus status=super.isControlValueValid(control);
      if (!status.isError()) {
        status=new DuplicateParameterRule(existingParameters).checkValidity(status.getValue());
      }
      return status;
    }
  }
;
  nameControl.createControlArea(parent);
  nameControl.addSelectionListener(new ValidatedValueSelectionListener(ControlTypes.NAME,name){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        name=(String)selection;
      }
    }
  }
);
  JavaTypeBrowsingControl declaringTypeControl=new JavaTypeBrowsingControl(ControlTypes.TYPE,getOffsetLabelLocation(),type,javaProject){
    protected ValueStatus isControlValueValid(    String value){
      if (value == null || value.length() == 0) {
        return ValueStatus.getValidStatus(value);
      }
      return super.isControlValueValid(value);
    }
  }
;
  declaringTypeControl.createControlArea(parent);
  declaringTypeControl.addSelectionListener(new ValidatedValueSelectionListener(){
    protected void handleValidatedValue(    ControlSelectionEvent event){
      Object selection=event.getSelectionData();
      if (selection instanceof String) {
        type=(String)selection;
      }
    }
  }
);
}",0.9928292046936116
186036,"protected GroovyPropertySuggestion(GroovySuggestionDeclaringType declaringType,String name,String type,boolean isStatic,String javaDoc,boolean isActive){
  this.name=name;
  this.type=type;
  this.isStatic=isStatic;
  this.javaDoc=javaDoc;
  this.declaringType=declaringType;
  this.isActive=isActive;
}","public GroovyPropertySuggestion(GroovySuggestionDeclaringType declaringType,String name,String type,boolean isStatic,String javaDoc,boolean isActive){
  super(declaringType,name,type,isStatic,javaDoc,isActive);
}",0.6601941747572816
186037,"@Override protected String constructName(){
  if (property == null) {
    return null;
  }
  StringBuffer buffer=new StringBuffer();
  String name=property.getName();
  buffer.append(name);
  buffer.append(EMPTY_SPACE);
  buffer.append(COLON);
  buffer.append(EMPTY_SPACE);
  String type=property.getType();
  buffer.append(type);
  return buffer.toString();
}","protected String constructName(){
  if (property == null) {
    return null;
  }
  StringBuffer buffer=new StringBuffer();
  String name=property.getName();
  buffer.append(name);
  buffer.append(EMPTY_SPACE);
  buffer.append(COLON);
  buffer.append(EMPTY_SPACE);
  String type=property.getType();
  buffer.append(type);
  return buffer.toString();
}",0.9859154929577464
186038,"public Set<IGroovySuggestion> getSuggestions(){
  return new HashSet<IGroovySuggestion>(suggestions);
}","public Set<IGroovySuggestion> getSuggestions(){
  return suggestions;
}",0.8160919540229885
186039,"public void removeDeclaringType(GroovySuggestionDeclaringType declaringType){
  suggestions.remove(declaringType);
}","public void removeDeclaringType(GroovySuggestionDeclaringType declaringType){
  suggestions.remove(declaringType.getName());
}",0.9586776859504132
186040,"/** 
 * @return
 */
public List<GroovySuggestionDeclaringType> getDeclaringTypes(){
  return new ArrayList<GroovySuggestionDeclaringType>(suggestions.values());
}","/** 
 * @return
 */
public Collection<GroovySuggestionDeclaringType> getDeclaringTypes(){
  return suggestions.values();
}",0.795774647887324
186041,"/** 
 * Creates a descriptor with the values of the given suggestion, but with the specified state.
 */
public SuggestionDescriptor(IGroovySuggestion suggestion,boolean isActive){
  this.isStatic=suggestion.isStatic();
  this.name=suggestion.getName();
  this.javaDoc=suggestion.getJavaDoc();
  this.suggestionType=suggestion.getType();
  if (suggestion instanceof GroovyMethodSuggestion) {
    GroovyMethodSuggestion methodSuggestion=(GroovyMethodSuggestion)suggestion;
    this.useArgumentNames=methodSuggestion.useNamedArguments();
    this.parameters=methodSuggestion.getMethodArguments();
    this.isMethod=true;
  }
}","/** 
 * Creates a descriptor with the values of the given suggestion, but with the specified state.
 */
public SuggestionDescriptor(IGroovySuggestion suggestion,boolean isActive){
  this.isStatic=suggestion.isStatic();
  this.isActive=isActive;
  this.name=suggestion.getName();
  this.javaDoc=suggestion.getJavaDoc();
  this.suggestionType=suggestion.getType();
  this.declaringTypeName=suggestion.getDeclaringType().getName();
  if (suggestion instanceof GroovyMethodSuggestion) {
    GroovyMethodSuggestion methodSuggestion=(GroovyMethodSuggestion)suggestion;
    this.useArgumentNames=methodSuggestion.useNamedArguments();
    this.parameters=methodSuggestion.getMethodArguments();
    this.isMethod=true;
  }
}",0.9312406576980568
186042,"@Override public GroovySuggestionDeclaringType getDeclaringType(){
  return declaringType;
}","public GroovySuggestionDeclaringType getDeclaringType(){
  return declaringType;
}",0.942528735632184
186043,"protected void createTableViewer(Composite parent){
  viewer=new SuggestionsViewer(getColumns(),ColumnTypes.SUGGESTIONS);
  viewer.createControls(parent);
  final CheckboxTreeViewer treeViewer=viewer.getTreeViewer();
  treeViewer.addCheckStateListener(new ICheckStateListener(){
    public void checkStateChanged(    CheckStateChangedEvent event){
      Object obj=event.getElement();
      boolean checkState=event.getChecked();
      handleCheckStateChange(obj,checkState);
    }
  }
);
  treeViewer.addTreeListener(new ITreeViewerListener(){
    @Override public void treeExpanded(    TreeExpansionEvent event){
      setCheckState(event.getElement());
    }
    @Override public void treeCollapsed(    TreeExpansionEvent event){
    }
  }
);
  treeViewer.setLabelProvider(new ViewerLabelProvider());
  treeViewer.setContentProvider(new ViewerContentProvider());
  treeViewer.setComparator(new SuggestionViewerSorter());
  setViewerListeners(treeViewer);
  refreshViewerInput(getSelectedProject());
  expandAll();
}","protected void createTableViewer(Composite parent){
  viewer=new SuggestionsViewer(getColumns(),ColumnTypes.SUGGESTIONS);
  viewer.createControls(parent);
  final CheckboxTreeViewer treeViewer=viewer.getTreeViewer();
  treeViewer.addCheckStateListener(new ICheckStateListener(){
    public void checkStateChanged(    CheckStateChangedEvent event){
      Object obj=event.getElement();
      boolean checkState=event.getChecked();
      handleCheckStateChange(obj,checkState);
    }
  }
);
  treeViewer.addTreeListener(new ITreeViewerListener(){
    public void treeExpanded(    TreeExpansionEvent event){
      setCheckState(event.getElement());
    }
    public void treeCollapsed(    TreeExpansionEvent event){
    }
  }
);
  treeViewer.setLabelProvider(new ViewerLabelProvider());
  treeViewer.setContentProvider(new ViewerContentProvider());
  treeViewer.setComparator(new SuggestionViewerSorter());
  setViewerListeners(treeViewer);
  refreshViewerInput(getSelectedProject());
  expandAll();
}",0.9900793650793652
186044,"@Override public void treeExpanded(TreeExpansionEvent event){
  setCheckState(event.getElement());
}","public void treeExpanded(TreeExpansionEvent event){
  setCheckState(event.getElement());
}",0.9473684210526316
186045,"@Override public void treeCollapsed(TreeExpansionEvent event){
}","public void treeCollapsed(TreeExpansionEvent event){
}",0.9152542372881356
186046,"private ICompletionProposal[][] guessParameters(char[][] parameterNames) throws JavaModelException {
  int count=parameterNames.length;
  fPositions=new Position[count];
  fChoices=new ICompletionProposal[count][];
  String[] parameterTypes=getParameterTypes();
  ParameterGuesser guesser=new ParameterGuesser(getEnclosingElement());
  IJavaElement[][] assignableElements=getAssignableElements();
  for (int i=count - 1; i >= 0; i--) {
    String paramName=new String(parameterNames[i]);
    Position position=new Position(0,0);
    ICompletionProposal[] argumentProposals=guesser.parameterProposals(parameterTypes[i],paramName,position,assignableElements[i],fFillBestGuess);
    if (argumentProposals.length == 0)     argumentProposals=new ICompletionProposal[]{new JavaCompletionProposal(paramName,0,paramName.length(),null,paramName,0)};
    fPositions[i]=position;
    fChoices[i]=argumentProposals;
  }
  return fChoices;
}","private ICompletionProposal[][] guessParameters(char[][] parameterNames) throws JavaModelException {
  int count=parameterNames.length;
  fPositions=new Position[count];
  fChoices=new ICompletionProposal[count][];
  String[] parameterTypes=getParameterTypes();
  ParameterGuesser guesser=new ParameterGuesser(getEnclosingElement());
  IJavaElement[][] assignableElements=getAssignableElements();
  for (int i=count - 1; i >= 0; i--) {
    String paramName=new String(parameterNames[i]);
    Position position=new Position(0,0);
    ICompletionProposal[] argumentProposals=parameterProposals(guesser,parameterTypes[i],paramName,position,assignableElements[i]);
    if (argumentProposals.length == 0)     argumentProposals=new ICompletionProposal[]{new JavaCompletionProposal(paramName,0,paramName.length(),null,paramName,0)};
    fPositions[i]=position;
    fChoices[i]=argumentProposals;
  }
  return fChoices;
}",0.9625203693644758
186047,"/** 
 * Creates an expanded search scope for the given search pattern if required
 * @param scope the initial scope
 * @param pattern the target pattern
 * @param requestor TODO
 * @return an expanded scope if required, or the initial scope if there is no change
 */
IJavaSearchScope expandSearchScope(IJavaSearchScope scope,SearchPattern pattern,SearchRequestor requestor);","/** 
 * Creates an expanded search scope for the given search pattern if required
 * @param scope the initial scope
 * @param pattern the target pattern
 * @param requestor the {@link SearchRequestor} for the given search
 * @return an expanded scope if required, or the initial scope if there is no change
 */
IJavaSearchScope expandSearchScope(IJavaSearchScope scope,SearchPattern pattern,SearchRequestor requestor);",0.9343434343434344
186048,"public String[] createCommandLine(CompilerConfiguration config) throws CompilerException {
  File destinationDir=new File(config.getOutputLocation());
  if (!destinationDir.exists()) {
    destinationDir.mkdirs();
  }
  File[] sourceFiles=recalculateStaleFiles(config);
  if (sourceFiles.length == 0) {
    return new String[0];
  }
  getLogger().info(""String_Node_Str"");
  getLogger().info(""String_Node_Str"" + sourceFiles.length + ""String_Node_Str""+ ""String_Node_Str""+ (sourceFiles.length == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ destinationDir.getAbsolutePath());
  List<String> args=new ArrayList<String>();
  String cp=super.getPathString(config.getClasspathEntries());
  verbose=config.isVerbose();
  if (verbose) {
    getLogger().info(""String_Node_Str"" + cp);
  }
  if (cp.length() > 0) {
    args.add(""String_Node_Str"");
    args.add(cp);
  }
  if (config.getOutputLocation() != null && config.getOutputLocation().length() > 0) {
    args.add(""String_Node_Str"");
    args.add(config.getOutputLocation());
  }
  if (config.isDebug()) {
    if (config.getDebugLevel() != null && config.getDebugLevel().trim().length() > 0) {
      args.add(""String_Node_Str"" + config.getDebugLevel());
    }
 else {
      args.add(""String_Node_Str"");
    }
  }
  if (""String_Node_Str"".equals(config.getProc())) {
    args.add(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(config.getProc())) {
    args.add(""String_Node_Str"");
  }
  if (config.getGeneratedSourcesDirectory() != null) {
    args.add(""String_Node_Str"");
    args.add(config.getGeneratedSourcesDirectory().getAbsolutePath());
  }
  String source=config.getSourceVersion();
  args.add(""String_Node_Str"");
  if (source != null && source.length() > 0) {
    args.add(source);
  }
 else {
    args.add(""String_Node_Str"");
  }
  String target=config.getTargetVersion();
  args.add(""String_Node_Str"");
  if (target != null && target.length() > 0) {
    args.add(target);
  }
 else {
    args.add(""String_Node_Str"");
  }
  if (config.isShowDeprecation()) {
    args.add(""String_Node_Str"");
  }
  if (!config.isShowWarnings()) {
    args.add(""String_Node_Str"");
  }
  if (config.getAnnotationProcessors() != null) {
    StringBuilder procArg=new StringBuilder();
    for (    String proc : config.getAnnotationProcessors()) {
      if (proc != null && proc.trim().length() > 0) {
        procArg.append(proc);
        procArg.append(""String_Node_Str"");
      }
    }
    if (procArg.length() > 0) {
      args.add(""String_Node_Str"");
      procArg.replace(procArg.length() - 1,procArg.length(),""String_Node_Str"");
      args.add(""String_Node_Str"" + procArg.toString() + ""String_Node_Str"");
    }
  }
  if (verbose) {
    args.add(""String_Node_Str"");
  }
  if (verbose) {
    getLogger().info(""String_Node_Str"" + args);
  }
  if (config.getSourceEncoding() != null) {
    args.add(""String_Node_Str"");
    args.add(config.getSourceEncoding());
  }
  for (Iterator argIter=config.getCustomCompilerArguments().entrySet().iterator(); argIter.hasNext(); ) {
    Entry entry=(Entry)argIter.next();
    Object key=entry.getKey();
    if (doesStartWithHyphen(key)) {
      args.add((String)key);
    }
 else     if (key != null) {
      args.add(""String_Node_Str"" + key);
      if (null != entry.getValue()) {
        args.add(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
      }
    }
  }
  args.addAll(composeSourceFiles(sourceFiles));
  return args.toArray(new String[args.size()]);
}","public String[] createCommandLine(CompilerConfiguration config) throws CompilerException {
  File destinationDir=new File(config.getOutputLocation());
  if (!destinationDir.exists()) {
    destinationDir.mkdirs();
  }
  File[] sourceFiles=recalculateStaleFiles(config);
  if (sourceFiles.length == 0) {
    return new String[0];
  }
  getLogger().info(""String_Node_Str"");
  getLogger().info(""String_Node_Str"" + sourceFiles.length + ""String_Node_Str""+ ""String_Node_Str""+ (sourceFiles.length == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ destinationDir.getAbsolutePath());
  List<String> args=new ArrayList<String>();
  String cp=super.getPathString(config.getClasspathEntries());
  verbose=config.isVerbose();
  if (verbose) {
    getLogger().info(""String_Node_Str"" + cp);
  }
  if (cp.length() > 0) {
    args.add(""String_Node_Str"");
    args.add(cp);
  }
  if (config.getOutputLocation() != null && config.getOutputLocation().length() > 0) {
    args.add(""String_Node_Str"");
    args.add(config.getOutputLocation());
  }
  if (config.isDebug()) {
    if (config.getDebugLevel() != null && config.getDebugLevel().trim().length() > 0) {
      args.add(""String_Node_Str"" + config.getDebugLevel());
    }
 else {
      args.add(""String_Node_Str"");
    }
  }
  if (""String_Node_Str"".equals(config.getProc())) {
    args.add(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(config.getProc())) {
    args.add(""String_Node_Str"");
  }
  if (config.getGeneratedSourcesDirectory() != null) {
    args.add(""String_Node_Str"");
    args.add(config.getGeneratedSourcesDirectory().getAbsolutePath());
  }
  String source=config.getSourceVersion();
  args.add(""String_Node_Str"");
  if (source != null && source.length() > 0) {
    args.add(source);
  }
 else {
    args.add(""String_Node_Str"");
  }
  String target=config.getTargetVersion();
  args.add(""String_Node_Str"");
  if (target != null && target.length() > 0) {
    args.add(target);
  }
 else {
    args.add(""String_Node_Str"");
  }
  if (config.isShowDeprecation()) {
    args.add(""String_Node_Str"");
  }
  if (!config.isShowWarnings()) {
    args.add(""String_Node_Str"");
  }
  if (config.getAnnotationProcessors() != null) {
    StringBuilder procArg=new StringBuilder();
    for (    String proc : config.getAnnotationProcessors()) {
      if (proc != null && proc.trim().length() > 0) {
        procArg.append(proc);
        procArg.append(""String_Node_Str"");
      }
    }
    if (procArg.length() > 0) {
      args.add(""String_Node_Str"");
      procArg.replace(procArg.length() - 1,procArg.length(),""String_Node_Str"");
      args.add(""String_Node_Str"" + procArg.toString() + ""String_Node_Str"");
    }
  }
  if (verbose) {
    args.add(""String_Node_Str"");
  }
  if (verbose) {
    getLogger().info(""String_Node_Str"" + args);
  }
  if (config.getSourceEncoding() != null) {
    args.add(""String_Node_Str"");
    args.add(config.getSourceEncoding());
  }
  for (  Entry<Object,Object> entry : (Iterable<Entry<Object,Object>>)config.getCustomCompilerArguments().entrySet()) {
    Object key=entry.getKey();
    if (startsWithHyphen(key)) {
      args.add((String)key);
    }
 else     if (key != null) {
      args.add(""String_Node_Str"" + key);
      if (null != entry.getValue()) {
        args.add(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
      }
    }
  }
  args.addAll(composeSourceFiles(sourceFiles));
  return args.toArray(new String[args.size()]);
}",0.96158290005777
186049,"/** 
 * Parse the output from the compiler into a list of CompilerError objects
 * @param exitCode The exit code of javac.
 * @param input The output of the compiler
 * @return List of CompilerError objects
 * @throws IOException
 */
static List parseModernStream(int exitCode,BufferedReader input) throws IOException {
  List errors=new ArrayList();
  String line;
  StringBuffer buffer;
  while (true) {
    buffer=new StringBuffer();
    do {
      line=input.readLine();
      if (line == null) {
        return errors;
      }
      if ((buffer.length() == 0) && line.startsWith(""String_Node_Str"")) {
        errors.add(new CompilerError(line,true));
      }
 else       if ((buffer.length() == 0) && isNote(line)) {
      }
 else {
        buffer.append(line);
        buffer.append(EOL);
      }
    }
 while (!line.endsWith(""String_Node_Str""));
    errors.add(parseModernError(exitCode,buffer.toString()));
  }
}","/** 
 * Parse the output from the compiler into a list of CompilerError objects
 * @param exitCode The exit code of javac.
 * @param input The output of the compiler
 * @return List of CompilerError objects
 * @throws IOException
 */
List<CompilerError> parseModernStream(int exitCode,BufferedReader input) throws IOException {
  List<CompilerError> errors=new ArrayList<CompilerError>();
  String line;
  StringBuffer buffer;
  while (true) {
    buffer=new StringBuffer();
    do {
      line=input.readLine();
      if (line == null) {
        return errors;
      }
      if ((buffer.length() == 0) && line.startsWith(""String_Node_Str"")) {
        errors.add(new CompilerError(line,true));
      }
 else       if ((buffer.length() == 0) && isNote(line)) {
      }
 else {
        buffer.append(line);
        buffer.append(EOL);
      }
    }
 while (!line.endsWith(""String_Node_Str""));
    errors.add(parseModernError(exitCode,buffer.toString()));
  }
}",0.972310969116081
186050,"public List compile(CompilerConfiguration config) throws CompilerException {
  String[] args=createCommandLine(config);
  if (args.length == 0) {
    getLogger().info(""String_Node_Str"");
    return Collections.emptyList();
  }
  List<CompilerError> messages;
  if (config.isFork()) {
    String executable=config.getExecutable();
    if (StringUtils.isEmpty(executable)) {
      try {
        executable=getJavacExecutable();
      }
 catch (      IOException e) {
        getLogger().warn(""String_Node_Str"");
        executable=""String_Node_Str"";
      }
    }
    String groovyEclipseLocation=getGroovyEclipseBatchLocation();
    messages=compileOutOfProcess(config,executable,groovyEclipseLocation,args);
  }
 else {
    Progress progress=new Progress();
    Main main=new Main(new PrintWriter(System.out),new PrintWriter(System.err),false,null,progress);
    boolean result=main.compile(args);
    messages=formatResult(main,result);
  }
  return messages;
}","@SuppressWarnings(""String_Node_Str"") public List compile(CompilerConfiguration config) throws CompilerException {
  String[] args=createCommandLine(config);
  if (args.length == 0) {
    getLogger().info(""String_Node_Str"");
    return Collections.emptyList();
  }
  List<CompilerError> messages;
  if (config.isFork()) {
    String executable=config.getExecutable();
    if (StringUtils.isEmpty(executable)) {
      try {
        executable=getJavaExecutable();
      }
 catch (      IOException e) {
        getLogger().warn(""String_Node_Str"");
        executable=""String_Node_Str"";
      }
    }
    String groovyEclipseLocation=getGroovyEclipseBatchLocation();
    messages=compileOutOfProcess(config,executable,groovyEclipseLocation,args);
  }
 else {
    Progress progress=new Progress();
    Main main=new Main(new PrintWriter(System.out),new PrintWriter(System.err),false,null,progress);
    boolean result=main.compile(args);
    messages=formatResult(main,result);
  }
  return messages;
}",0.9806122448979592
186051,"private static String getGroovyEclipseBatchLocation() throws CompilerException {
  Class<Main> cls=Main.class;
  ProtectionDomain pDomain=cls.getProtectionDomain();
  CodeSource cSource=pDomain.getCodeSource();
  if (cSource != null) {
    URL loc=cSource.getLocation();
    File file=new File(loc.getPath());
    return file.getPath();
  }
 else {
    throw new CompilerException(""String_Node_Str"");
  }
}","private String getGroovyEclipseBatchLocation() throws CompilerException {
  Class<Main> cls=Main.class;
  ProtectionDomain pDomain=cls.getProtectionDomain();
  CodeSource cSource=pDomain.getCodeSource();
  if (cSource != null) {
    URL loc=cSource.getLocation();
    File file;
    try {
      file=new File(URLDecoder.decode(loc.getPath(),""String_Node_Str""));
    }
 catch (    UnsupportedEncodingException e) {
      getLogger().warn(""String_Node_Str"" + loc,e);
      file=new File(loc.getPath());
    }
    return file.getPath();
  }
 else {
    throw new CompilerException(""String_Node_Str"");
  }
}",0.6600594648166501
186052,"public FindAllReferencesRequestor(AnnotatedNode declaration){
  this.declaration=declaration;
  this.references=new ArrayList<ASTNode>(10);
}","public FindAllReferencesRequestor(AnnotatedNode declaration){
  this.declaration=declaration;
  this.references=new TreeSet<ASTNode>(new Comparator<ASTNode>(){
    public int compare(    ASTNode o1,    ASTNode o2){
      return o1.getStart() - o2.getStart();
    }
  }
);
}",0.6376811594202898
186053,"public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node.getLength() == 0) {
    return VisitStatus.CONTINUE;
  }
  if (node instanceof AnnotatedNode) {
    ASTNode maybeDeclaration=result.declaration;
    if (maybeDeclaration == null) {
      return VisitStatus.CONTINUE;
    }
    if (maybeDeclaration instanceof ClassNode) {
      if (!(node instanceof ClassExpression || node instanceof ClassNode)) {
        return VisitStatus.CONTINUE;
      }
      maybeDeclaration=((ClassNode)maybeDeclaration).redirect();
    }
    if (isEquivalent(maybeDeclaration)) {
      references.add(node);
    }
  }
  return VisitStatus.CONTINUE;
}","public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node.getLength() == 0) {
    return VisitStatus.CONTINUE;
  }
  if (node instanceof AnnotatedNode) {
    ASTNode maybeDeclaration=result.declaration;
    if (maybeDeclaration == null) {
      return VisitStatus.CONTINUE;
    }
    if (maybeDeclaration instanceof ClassNode) {
      if (!(node instanceof ClassExpression || node instanceof ClassNode)) {
        return VisitStatus.CONTINUE;
      }
      maybeDeclaration=((ClassNode)maybeDeclaration).redirect();
    }
    if (maybeDeclaration instanceof PropertyNode && ((PropertyNode)maybeDeclaration).getField() != null) {
      maybeDeclaration=((PropertyNode)maybeDeclaration).getField();
    }
    if (isEquivalent(maybeDeclaration)) {
      references.add(node);
    }
  }
  return VisitStatus.CONTINUE;
}",0.8838999358563181
186054,"private ICompletionProposal createProposal(String fieldName,ContentAssistContext context,IType enclosingType){
  int relevance=Relevance.VERY_HIGH.getRelavance();
  return new NewGroovyFieldCompletionProposal(fieldName,context.completionLocation,context.completionExpression.length(),relevance);
}","private ICompletionProposal createProposal(String fieldName,ContentAssistContext context,IType enclosingType){
  int relevance=Relevance.VERY_HIGH.getRelavance();
  return new NewGroovyFieldCompletionProposal(fieldName,context.completionLocation - context.completionExpression.length(),context.completionExpression.length(),relevance);
}",0.9369085173501576
186055,"protected Image getImageFor(ASTNode node){
  if (node instanceof FieldNode) {
    int mods=((FieldNode)node).getModifiers();
    if (test(mods,Opcodes.ACC_PUBLIC)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PUBLIC);
    }
 else     if (test(mods,Opcodes.ACC_PROTECTED)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PROTECTED);
    }
 else     if (test(mods,Opcodes.ACC_PRIVATE)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PRIVATE);
    }
    return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_DEFAULT);
  }
 else   if (node instanceof PropertyNode) {
    int mods=((PropertyNode)node).getModifiers();
    if (test(mods,Opcodes.ACC_PUBLIC)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PUBLIC);
    }
 else     if (test(mods,Opcodes.ACC_PROTECTED)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PROTECTED);
    }
 else     if (test(mods,Opcodes.ACC_PRIVATE)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PRIVATE);
    }
    return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_DEFAULT);
  }
  return null;
}","/** 
 * Use   {@link ProposalUtils#getImage(CompletionProposal)} instead
 * @param node
 * @return
 */
@Deprecated protected Image getImageFor(ASTNode node){
  if (node instanceof FieldNode) {
    int mods=((FieldNode)node).getModifiers();
    if (test(mods,Opcodes.ACC_PUBLIC)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PUBLIC);
    }
 else     if (test(mods,Opcodes.ACC_PROTECTED)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PROTECTED);
    }
 else     if (test(mods,Opcodes.ACC_PRIVATE)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PRIVATE);
    }
    return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_DEFAULT);
  }
 else   if (node instanceof PropertyNode) {
    int mods=((PropertyNode)node).getModifiers();
    if (test(mods,Opcodes.ACC_PUBLIC)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PUBLIC);
    }
 else     if (test(mods,Opcodes.ACC_PROTECTED)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PROTECTED);
    }
 else     if (test(mods,Opcodes.ACC_PRIVATE)) {
      return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_PRIVATE);
    }
    return JavaPluginImages.get(JavaPluginImages.IMG_FIELD_DEFAULT);
  }
  return null;
}",0.9512918254976704
186056,"public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  return new GroovyJavaFieldCompletionProposal(createProposal(context),getImageFor(field),createDisplayString(field));
}","public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  CompletionProposal proposal=createProposal(context);
  return new GroovyJavaFieldCompletionProposal(proposal,ProposalUtils.getImage(proposal),createDisplayString(field));
}",0.7854545454545454
186057,"public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  return new GroovyJavaFieldCompletionProposal(createProposal(context),getImageFor(property),createDisplayString(property));
}","public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  CompletionProposal proposal=createProposal(context);
  return new GroovyJavaFieldCompletionProposal(proposal,ProposalUtils.getImage(proposal),createDisplayString(property));
}",0.7835420393559929
186058,"public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node instanceof ClassExpression || node instanceof ClassNode || node instanceof ImportNode|| node instanceof AnnotationNode|| node instanceof ConstructorNode) {
    ASTNode noArray;
    if (node instanceof ClassNode) {
      noArray=removeArray((ClassNode)node);
    }
 else     if (node instanceof ConstructorNode) {
      noArray=((ConstructorNode)node).getDeclaringClass();
    }
 else {
      noArray=node;
    }
    ClassNode type;
    if (node instanceof ConstructorNode) {
      type=((ConstructorNode)node).getDeclaringClass();
    }
 else {
      type=result.type;
    }
    if (node instanceof ClassExpression && type == VariableScope.CLASS_CLASS_NODE) {
      type=((ClassExpression)node).getType();
    }
    if (type != null) {
      String qualifiedName=removeArray(type).getName();
      if (qualifiedNameMatches(qualifiedName) && noArray.getEnd() > 0) {
        int start;
        int end;
        if (node instanceof ImportNode) {
          node=((ImportNode)node).getType();
          start=node.getStart();
          end=node.getEnd();
        }
 else         if (node instanceof ClassExpression) {
          start=node.getStart();
          end=start + ((ClassExpression)node).getType().getNameWithoutPackage().length();
        }
 else         if (node instanceof ClassNode) {
          ClassNode classNode=(ClassNode)node;
          if (classNode.getNameEnd() > 0) {
            start=classNode.getNameStart();
            end=classNode.getNameEnd() + 1;
          }
 else {
            classNode=maybeGetComponentType(classNode);
            start=classNode.getStart();
            end=start + classNode.getNameWithoutPackage().length();
          }
        }
 else         if (node instanceof ConstructorNode) {
          start=((ConstructorNode)node).getNameStart();
          end=((ConstructorNode)node).getNameEnd() + 1;
        }
 else {
          start=node.getStart();
          end=node.getEnd();
        }
        SearchMatch match=new SearchMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
        try {
          requestor.acceptSearchMatch(match);
        }
 catch (        CoreException e) {
          Util.log(e,""String_Node_Str"" + enclosingElement);
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}","public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node instanceof ClassExpression || node instanceof ClassNode || node instanceof ImportNode|| node instanceof AnnotationNode|| node instanceof ConstructorNode) {
    ASTNode noArray;
    if (node instanceof ClassNode) {
      noArray=removeArray((ClassNode)node);
    }
 else     if (node instanceof ConstructorNode) {
      noArray=((ConstructorNode)node).getDeclaringClass();
    }
 else {
      noArray=node;
    }
    ClassNode type;
    if (node instanceof ConstructorNode) {
      type=((ConstructorNode)node).getDeclaringClass();
    }
 else {
      type=result.type;
    }
    if (node instanceof ClassExpression && type == VariableScope.CLASS_CLASS_NODE) {
      type=((ClassExpression)node).getType();
    }
    if (type != null) {
      String qualifiedName=removeArray(type).getName();
      if (qualifiedNameMatches(qualifiedName) && noArray.getEnd() > 0) {
        int start;
        int end;
        if (node instanceof ImportNode) {
          node=((ImportNode)node).getType();
          start=node.getStart();
          end=node.getEnd();
        }
 else         if (node instanceof ClassExpression) {
          start=node.getStart();
          end=start + ((ClassExpression)node).getType().getNameWithoutPackage().length();
        }
 else         if (node instanceof ClassNode) {
          ClassNode classNode=(ClassNode)node;
          if (classNode.getNameEnd() > 0) {
            start=classNode.getNameStart();
            end=classNode.getNameEnd() + 1;
          }
 else           if (classNode.redirect() == classNode) {
            start=end=-1;
          }
 else {
            classNode=maybeGetComponentType(classNode);
            start=classNode.getStart();
            end=start + classNode.getNameWithoutPackage().length();
          }
        }
 else         if (node instanceof ConstructorNode) {
          start=((ConstructorNode)node).getNameStart();
          end=((ConstructorNode)node).getNameEnd() + 1;
          if (start == 0 && end == 1) {
            start=end=-1;
          }
        }
 else {
          start=node.getStart();
          end=node.getEnd();
        }
        if (start >= 0 && end >= 0) {
          SearchMatch match=new SearchMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
          try {
            requestor.acceptSearchMatch(match);
          }
 catch (          CoreException e) {
            Util.log(e,""String_Node_Str"" + enclosingElement);
          }
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}",0.953767460161322
186059,"public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node instanceof ClassNode) {
    ClassNode orig=(ClassNode)node;
    ClassNode redirect=orig.redirect();
    if (orig == redirect) {
      if (orig.getNameWithoutPackage().equalsIgnoreCase(simpleName)) {
        boolean matchFound;
switch (typeSuffix) {
case CLASS_SUFFIX:
          matchFound=isClass(orig);
        break;
case CLASS_AND_INTERFACE_SUFFIX:
      matchFound=orig.isInterface() || isClass(orig);
    break;
case CLASS_AND_ENUM_SUFFIX:
  matchFound=orig.isInterface() || orig.isEnum();
break;
case INTERFACE_SUFFIX:
matchFound=orig.isInterface();
break;
case INTERFACE_AND_ANNOTATION_SUFFIX:
matchFound=orig.isInterface() || orig.isAnnotationDefinition();
break;
case ENUM_SUFFIX:
matchFound=orig.isEnum();
break;
case ANNOTATION_TYPE_SUFFIX:
matchFound=orig.isAnnotationDefinition();
break;
default :
matchFound=true;
break;
}
if (matchFound) {
try {
requestor.acceptSearchMatch(new SearchMatch(enclosingElement,SearchMatch.A_ACCURATE,orig.getNameStart(),orig.getNameEnd() - orig.getNameStart(),participant,enclosingElement.getResource()));
}
 catch (CoreException e) {
Util.log(e,""String_Node_Str"");
}
}
}
}
}
return VisitStatus.CONTINUE;
}","public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node instanceof ClassNode) {
    ClassNode orig=(ClassNode)node;
    ClassNode redirect=orig.redirect();
    if (orig == redirect) {
      if (orig.getNameWithoutPackage().equalsIgnoreCase(simpleName)) {
        boolean matchFound;
switch (typeSuffix) {
case CLASS_SUFFIX:
          matchFound=isClass(orig);
        break;
case CLASS_AND_INTERFACE_SUFFIX:
      matchFound=orig.isInterface() || isClass(orig);
    break;
case CLASS_AND_ENUM_SUFFIX:
  matchFound=orig.isInterface() || orig.isEnum();
break;
case INTERFACE_SUFFIX:
matchFound=orig.isInterface();
break;
case INTERFACE_AND_ANNOTATION_SUFFIX:
matchFound=orig.isInterface() || orig.isAnnotationDefinition();
break;
case ENUM_SUFFIX:
matchFound=orig.isEnum();
break;
case ANNOTATION_TYPE_SUFFIX:
matchFound=orig.isAnnotationDefinition();
break;
default :
matchFound=true;
break;
}
if (matchFound) {
try {
requestor.acceptSearchMatch(new SearchMatch(enclosingElement,SearchMatch.A_ACCURATE,orig.getNameStart(),orig.getNameEnd() - orig.getNameStart() + 1,participant,enclosingElement.getResource()));
}
 catch (CoreException e) {
Util.log(e,""String_Node_Str"");
}
}
}
}
}
return VisitStatus.CONTINUE;
}",0.9984202211690364
186060,"private FieldNode findFieldNode(IField field){
  ClassNode clazz=findClassWithName(createName(field.getDeclaringType()));
  return clazz.getField(field.getElementName());
}","private FieldNode findFieldNode(IField field){
  ClassNode clazz=findClassWithName(createName(field.getDeclaringType()));
  FieldNode fieldNode=clazz.getField(field.getElementName());
  if (fieldNode == null) {
    fieldNode=clazz.getField(""String_Node_Str"" + field.getElementName());
  }
  return fieldNode;
}",0.6265560165975104
186061,"public void visitJDT(IMethod method,ITypeRequestor requestor){
  IJavaElement oldEnclosing=enclosingElement;
  ASTNode oldEnclosingNode=enclosingDeclarationNode;
  enclosingElement=method;
  MethodNode methodNode=findMethodNode(method);
  enclosingDeclarationNode=methodNode;
  this.requestor=requestor;
  scopes.push(new VariableScope(scopes.peek(),methodNode));
  try {
    visitConstructorOrMethod(methodNode,method.isConstructor());
  }
 catch (  VisitCompleted vc) {
    if (rethrowVisitComplete) {
      throw vc;
    }
  }
catch (  JavaModelException e) {
    Util.log(e,""String_Node_Str"" + method.getElementName() + ""String_Node_Str""+ method.getParent().getElementName());
  }
 finally {
    enclosingElement=oldEnclosing;
    enclosingDeclarationNode=oldEnclosingNode;
    scopes.pop();
  }
}","public void visitJDT(IMethod method,ITypeRequestor requestor){
  IJavaElement oldEnclosing=enclosingElement;
  ASTNode oldEnclosingNode=enclosingDeclarationNode;
  enclosingElement=method;
  MethodNode methodNode=findMethodNode(method);
  if (methodNode == null) {
    return;
  }
  enclosingDeclarationNode=methodNode;
  this.requestor=requestor;
  scopes.push(new VariableScope(scopes.peek(),methodNode));
  try {
    visitConstructorOrMethod(methodNode,method.isConstructor());
  }
 catch (  VisitCompleted vc) {
    if (rethrowVisitComplete) {
      throw vc;
    }
  }
catch (  JavaModelException e) {
    Util.log(e,""String_Node_Str"" + method.getElementName() + ""String_Node_Str""+ method.getParent().getElementName());
  }
 finally {
    enclosingElement=oldEnclosing;
    enclosingDeclarationNode=oldEnclosingNode;
    scopes.pop();
  }
}",0.9732685297691372
186062,"private MethodNode findMethodNode(IMethod method){
  ClassNode clazz=findClassWithName(createName(method.getDeclaringType()));
  try {
    if (method.isConstructor()) {
      List<ConstructorNode> constructors=clazz.getDeclaredConstructors();
      for (      ConstructorNode constructorNode : constructors) {
        String[] jdtParamTypes=method.getParameterTypes() == null ? new String[0] : method.getParameterTypes();
        Parameter[] groovyParams=constructorNode.getParameters() == null ? new Parameter[0] : constructorNode.getParameters();
        if (groovyParams != null && groovyParams.length > 0 && groovyParams[0].getName().startsWith(""String_Node_Str"")) {
          Parameter[] newGroovyParams=new Parameter[groovyParams.length - 1];
          System.arraycopy(groovyParams,1,newGroovyParams,0,newGroovyParams.length);
          groovyParams=newGroovyParams;
        }
        if (groovyParams.length != jdtParamTypes.length) {
          continue;
        }
        for (int i=0; i < groovyParams.length; i++) {
          String groovyClassType=groovyParams[i].getType().getName();
          if (!groovyClassType.startsWith(""String_Node_Str"")) {
            groovyClassType=Signature.createTypeSignature(groovyClassType,false);
          }
          if (!groovyClassType.equals(jdtParamTypes[i])) {
            continue;
          }
        }
        return constructorNode;
      }
    }
 else {
      List<MethodNode> methods=clazz.getMethods(method.getElementName());
      for (      MethodNode methodNode : methods) {
        String[] jdtParamTypes=method.getParameterTypes() == null ? new String[0] : method.getParameterTypes();
        Parameter[] groovyParams=methodNode.getParameters() == null ? new Parameter[0] : methodNode.getParameters();
        if (groovyParams.length != jdtParamTypes.length) {
          continue;
        }
        for (int i=0; i < groovyParams.length; i++) {
          String groovyClassType=groovyParams[i].getType().getName();
          if (!groovyClassType.startsWith(""String_Node_Str"")) {
            groovyClassType=Signature.createTypeSignature(groovyClassType,false);
          }
          if (!groovyClassType.equals(jdtParamTypes[i])) {
            continue;
          }
        }
        return methodNode;
      }
    }
  }
 catch (  JavaModelException e) {
    Util.log(e,""String_Node_Str"" + method.getElementName() + ""String_Node_Str""+ clazz.getName());
  }
  throw new IllegalArgumentException(""String_Node_Str"" + method.getElementName() + ""String_Node_Str""+ clazz.getName());
}","private MethodNode findMethodNode(IMethod method){
  ClassNode clazz=findClassWithName(createName(method.getDeclaringType()));
  try {
    if (method.isConstructor()) {
      List<ConstructorNode> constructors=clazz.getDeclaredConstructors();
      for (      ConstructorNode constructorNode : constructors) {
        String[] jdtParamTypes=method.getParameterTypes() == null ? new String[0] : method.getParameterTypes();
        Parameter[] groovyParams=constructorNode.getParameters() == null ? new Parameter[0] : constructorNode.getParameters();
        if (groovyParams != null && groovyParams.length > 0 && groovyParams[0].getName().startsWith(""String_Node_Str"")) {
          Parameter[] newGroovyParams=new Parameter[groovyParams.length - 1];
          System.arraycopy(groovyParams,1,newGroovyParams,0,newGroovyParams.length);
          groovyParams=newGroovyParams;
        }
        if (groovyParams.length != jdtParamTypes.length) {
          continue;
        }
        for (int i=0; i < groovyParams.length; i++) {
          String groovyClassType=groovyParams[i].getType().getName();
          if (!groovyClassType.startsWith(""String_Node_Str"")) {
            groovyClassType=Signature.createTypeSignature(groovyClassType,false);
          }
          if (!groovyClassType.equals(jdtParamTypes[i])) {
            continue;
          }
        }
        return constructorNode;
      }
    }
 else {
      List<MethodNode> methods=clazz.getMethods(method.getElementName());
      for (      MethodNode methodNode : methods) {
        String[] jdtParamTypes=method.getParameterTypes() == null ? new String[0] : method.getParameterTypes();
        Parameter[] groovyParams=methodNode.getParameters() == null ? new Parameter[0] : methodNode.getParameters();
        if (groovyParams.length != jdtParamTypes.length) {
          continue;
        }
        for (int i=0; i < groovyParams.length; i++) {
          String groovyClassType=groovyParams[i].getType().getName();
          if (!groovyClassType.startsWith(""String_Node_Str"")) {
            groovyClassType=Signature.createTypeSignature(groovyClassType,false);
          }
          if (!groovyClassType.equals(jdtParamTypes[i])) {
            continue;
          }
        }
        return methodNode;
      }
    }
  }
 catch (  JavaModelException e) {
    Util.log(e,""String_Node_Str"" + method.getElementName() + ""String_Node_Str""+ clazz.getName());
  }
  return null;
}",0.9745031118249348
186063,"public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node instanceof ClassExpression || node instanceof ClassNode || node instanceof ImportNode|| node instanceof AnnotationNode) {
    ASTNode noArray;
    if (node instanceof ClassNode) {
      noArray=removeArray((ClassNode)node);
    }
 else {
      noArray=node;
    }
    ClassNode type=result.type;
    if (node instanceof ClassExpression && type == VariableScope.CLASS_CLASS_NODE) {
      type=((ClassExpression)node).getType();
    }
    if (type != null) {
      String qualifiedName=removeArray(type).getName();
      if (qualifiedNameMatches(qualifiedName) && noArray.getEnd() > 0) {
        int start;
        int end;
        if (node instanceof ImportNode) {
          node=((ImportNode)node).getType();
          start=node.getStart();
          end=node.getEnd();
        }
 else         if (node instanceof ClassExpression) {
          start=node.getStart();
          end=start + ((ClassExpression)node).getType().getNameWithoutPackage().length();
        }
 else         if (node instanceof ClassNode) {
          node=maybeGetComponentType((ClassNode)node);
          start=node.getStart();
          end=start + ((ClassNode)node).getNameWithoutPackage().length();
        }
 else {
          start=node.getStart();
          end=node.getEnd();
        }
        SearchMatch match=new SearchMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
        try {
          requestor.acceptSearchMatch(match);
        }
 catch (        CoreException e) {
          Util.log(e,""String_Node_Str"" + enclosingElement);
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}","public VisitStatus acceptASTNode(ASTNode node,TypeLookupResult result,IJavaElement enclosingElement){
  if (node instanceof ClassExpression || node instanceof ClassNode || node instanceof ImportNode|| node instanceof AnnotationNode|| node instanceof ConstructorNode) {
    ASTNode noArray;
    if (node instanceof ClassNode) {
      noArray=removeArray((ClassNode)node);
    }
 else     if (node instanceof ConstructorNode) {
      noArray=((ConstructorNode)node).getDeclaringClass();
    }
 else {
      noArray=node;
    }
    ClassNode type;
    if (node instanceof ConstructorNode) {
      type=((ConstructorNode)node).getDeclaringClass();
    }
 else {
      type=result.type;
    }
    if (node instanceof ClassExpression && type == VariableScope.CLASS_CLASS_NODE) {
      type=((ClassExpression)node).getType();
    }
    if (type != null) {
      String qualifiedName=removeArray(type).getName();
      if (qualifiedNameMatches(qualifiedName) && noArray.getEnd() > 0) {
        int start;
        int end;
        if (node instanceof ImportNode) {
          node=((ImportNode)node).getType();
          start=node.getStart();
          end=node.getEnd();
        }
 else         if (node instanceof ClassExpression) {
          start=node.getStart();
          end=start + ((ClassExpression)node).getType().getNameWithoutPackage().length();
        }
 else         if (node instanceof ClassNode) {
          node=maybeGetComponentType((ClassNode)node);
          start=node.getStart();
          end=start + ((ClassNode)node).getNameWithoutPackage().length();
        }
 else         if (node instanceof ConstructorNode) {
          start=((ConstructorNode)node).getNameStart();
          end=((ConstructorNode)node).getNameEnd() + 1;
        }
 else {
          start=node.getStart();
          end=node.getEnd();
        }
        SearchMatch match=new SearchMatch(enclosingElement,getAccuracy(result.confidence),start,end - start,participant,enclosingElement.getResource());
        try {
          requestor.acceptSearchMatch(match);
        }
 catch (        CoreException e) {
          Util.log(e,""String_Node_Str"" + enclosingElement);
        }
      }
    }
  }
  return VisitStatus.CONTINUE;
}",0.8719758064516129
186064,"public RenameDispatcherMock(IGroovyDocumentProvider docProvider,UserSelection selection,IGroovyFileProvider fileProvider){
  super(docProvider,selection);
  this.fileProvider=fileProvider;
}","public RenameDispatcherMock(IGroovyDocumentProvider docProvider,UserSelection selection,IGroovyFileProvider fileProvider){
  super(docProvider,selection);
}",0.9017341040462428
186065,"/** 
 * FIXADE RC1 I am concerned that this takes a long time since we are doing a lookup for each method any way to cache? FIXADE RC1 cannot find parameters with type parameters.
 * @throws JavaModelException 
 */
protected char[][] getParameterNames(ICompilationUnit unit,MethodNode method){
  try {
    IType type=unit.getJavaProject().findType(method.getDeclaringClass().getName(),new NullProgressMonitor());
    if (type != null && type.exists()) {
      Parameter[] params=method.getParameters();
      String[] parameterTypeSignatures=new String[params == null ? 0 : params.length];
      boolean doResolved=type.isBinary();
      for (int i=0; i < parameterTypeSignatures.length; i++) {
        if (doResolved) {
          parameterTypeSignatures[i]=ProposalUtils.createTypeSignatureStr(params[i].getType());
        }
 else {
          parameterTypeSignatures[i]=ProposalUtils.createUnresolvedTypeSignatureStr(params[i].getType());
        }
      }
      IMethod jdtMethod=type.getMethod(method.getName(),parameterTypeSignatures);
      if (jdtMethod != null && jdtMethod.exists()) {
        String[] paramNames=jdtMethod.getParameterNames();
        char[][] paramNamesChar=new char[paramNames.length][];
        for (int i=0; i < paramNames.length; i++) {
          paramNamesChar[i]=paramNames[i].toCharArray();
        }
        return paramNamesChar;
      }
    }
  }
 catch (  JavaModelException e) {
    GroovyCore.logException(""String_Node_Str"" + method.getName(),e);
  }
  return null;
}","/** 
 * FIXADE RC1 I am concerned that this takes a long time since we are doing a lookup for each method any way to cache? FIXADE RC1 cannot find parameters names with type parameters.
 * @throws JavaModelException 
 */
protected char[][] getParameterNames(ICompilationUnit unit,MethodNode method){
  try {
    IType type=unit.getJavaProject().findType(method.getDeclaringClass().getName(),new NullProgressMonitor());
    if (type != null && type.exists()) {
      Parameter[] params=method.getParameters();
      String[] parameterTypeSignatures=new String[params == null ? 0 : params.length];
      boolean doResolved=type.isBinary();
      for (int i=0; i < parameterTypeSignatures.length; i++) {
        if (doResolved) {
          parameterTypeSignatures[i]=ProposalUtils.createTypeSignatureStr(params[i].getType());
        }
 else {
          parameterTypeSignatures[i]=ProposalUtils.createUnresolvedTypeSignatureStr(params[i].getType());
        }
      }
      IMethod jdtMethod=type.getMethod(method.getName(),parameterTypeSignatures);
      if (jdtMethod != null && jdtMethod.exists()) {
        String[] paramNames=jdtMethod.getParameterNames();
        char[][] paramNamesChar=new char[paramNames.length][];
        for (int i=0; i < paramNames.length; i++) {
          paramNamesChar[i]=paramNames[i].toCharArray();
        }
        return paramNamesChar;
      }
    }
  }
 catch (  JavaModelException e) {
    GroovyCore.logException(""String_Node_Str"" + method.getName(),e);
  }
  return null;
}",0.9980132450331126
186066,"/** 
 * @param node
 */
private void internalVisitConstructorOrMethod(MethodNode node){
  if (!doTest(node)) {
    return;
  }
  currentDeclaration=node;
  internalVisitParameters(node.getParameters(),node);
  if (node.getExceptions() != null) {
    for (    ClassNode excep : node.getExceptions()) {
      if (doTest(excep)) {
        createContext(null,node,EXCEPTIONS);
      }
    }
  }
  blockStack.push(node);
  visitAnnotations(node);
  blockStack.pop();
  Statement code=node.getCode();
  visitClassCodeContainer(code);
  if (completionOffset < node.getCode().getStart()) {
    createContext(null,node,PARAMETER);
  }
  createContext(node.getCode(),node.getCode(),expressionScriptOrStatement(node));
}","/** 
 * @param node
 */
private void internalVisitConstructorOrMethod(MethodNode node){
  if (!doTest(node)) {
    return;
  }
  if (!(node.getName().equals(""String_Node_Str"") && (node.getParameters() == null || node.getParameters().length == 0))) {
    currentDeclaration=node;
  }
  internalVisitParameters(node.getParameters(),node);
  if (node.getExceptions() != null) {
    for (    ClassNode excep : node.getExceptions()) {
      if (doTest(excep)) {
        createContext(null,node,EXCEPTIONS);
      }
    }
  }
  blockStack.push(node);
  visitAnnotations(node);
  blockStack.pop();
  Statement code=node.getCode();
  visitClassCodeContainer(code);
  if (completionOffset < node.getCode().getStart()) {
    createContext(null,node,PARAMETER);
  }
  createContext(node.getCode(),node.getCode(),expressionScriptOrStatement(node));
}",0.9153199741435036
186067,"public static Test suite() throws Exception {
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(DefaultGroovyMethodCompletionTests.class);
  suite.addTestSuite(LocalVariableCompletionTests.class);
  suite.addTestSuite(InferencingCompletionTests.class);
  suite.addTestSuite(FieldCompletionTests.class);
  suite.addTestSuite(TypeCompletionTests.class);
  suite.addTestSuite(GroovyLikeCompletionTests.class);
  suite.addTestSuite(OtherCompletionTests.class);
  return suite;
}","public static Test suite() throws Exception {
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(DefaultGroovyMethodCompletionTests.class);
  suite.addTestSuite(LocalVariableCompletionTests.class);
  suite.addTestSuite(InferencingCompletionTests.class);
  suite.addTestSuite(FieldCompletionTests.class);
  suite.addTestSuite(MethodCompletionTests.class);
  suite.addTestSuite(TypeCompletionTests.class);
  suite.addTestSuite(GroovyLikeCompletionTests.class);
  suite.addTestSuite(OtherCompletionTests.class);
  return suite;
}",0.9511961722488038
186068,"public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  GroovyCompletionProposal proposal=new GroovyCompletionProposal(CompletionProposal.METHOD_REF,context.completionLocation);
  proposal.setCompletion(completionName());
  proposal.setDeclarationSignature(ProposalUtils.createTypeSignature(method.getDeclaringClass()));
  proposal.setName(method.getName().toCharArray());
  proposal.setParameterNames(removeFirst(createParameterNames(method)));
  proposal.setParameterTypeNames(removeFirst(createParameterTypeNames(method)));
  proposal.setReplaceRange(context.completionLocation - context.completionExpression.length(),context.completionLocation - context.completionExpression.length());
  proposal.setFlags(method.getModifiers() & ~Opcodes.ACC_STATIC);
  proposal.setAdditionalFlags(CompletionFlags.Default);
  char[] methodSignature=ProposalUtils.createMethodSignature(method,1);
  proposal.setKey(methodSignature);
  proposal.setSignature(methodSignature);
  proposal.setRelevance(getRelevance(proposal.getName()));
  return new GroovyJavaMethodProposal(proposal,javaContext);
}","public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  GroovyCompletionProposal proposal=new GroovyCompletionProposal(CompletionProposal.METHOD_REF,context.completionLocation);
  proposal.setCompletion(completionName());
  proposal.setDeclarationSignature(ProposalUtils.createTypeSignature(method.getDeclaringClass()));
  proposal.setName(method.getName().toCharArray());
  proposal.setParameterNames(removeFirst(createParameterNames(method)));
  proposal.setParameterTypeNames(removeFirst(createParameterTypeNames(method)));
  proposal.setReplaceRange(context.completionLocation - context.completionExpression.length(),context.completionLocation - context.completionExpression.length());
  proposal.setFlags(method.getModifiers() & ~Opcodes.ACC_STATIC);
  proposal.setAdditionalFlags(CompletionFlags.Default);
  char[] methodSignature=ProposalUtils.createMethodSignature(method,1);
  proposal.setKey(methodSignature);
  proposal.setSignature(methodSignature);
  proposal.setRelevance(getRelevance(proposal.getName()));
  return new GroovyJavaMethodCompletionProposal(proposal,javaContext);
}",0.995697074010327
186069,"public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  return new JavaCompletionProposal(field.getName(),context.completionLocation - context.completionExpression.length(),field.getName().length(),getImageFor(field),createDisplayString(field),getRelevance(field.getName().toCharArray()));
}","public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  return new GroovyJavaFieldCompletionProposal(createProposal(context),getImageFor(field),createDisplayString(field));
}",0.6884176182707994
186070,"public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  GroovyCompletionProposal proposal=new GroovyCompletionProposal(CompletionProposal.METHOD_REF,context.completionLocation);
  proposal.setCompletion(completionName());
  proposal.setDeclarationSignature(ProposalUtils.createTypeSignature(method.getDeclaringClass()));
  proposal.setName(method.getName().toCharArray());
  char[][] parameterTypeNames=createParameterTypeNames(method);
  proposal.setParameterTypeNames(parameterTypeNames);
  proposal.setParameterNames(createParameterNames(method,parameterTypeNames));
  proposal.setReplaceRange(context.completionLocation - context.completionExpression.length(),context.completionLocation - context.completionExpression.length());
  proposal.setFlags(method.getModifiers());
  proposal.setAdditionalFlags(CompletionFlags.Default);
  char[] methodSignature=ProposalUtils.createMethodSignature(method);
  proposal.setKey(methodSignature);
  proposal.setSignature(methodSignature);
  proposal.setRelevance(getRelevance(proposal.getName()));
  return new GroovyJavaMethodProposal(proposal,javaContext);
}","public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  GroovyCompletionProposal proposal=new GroovyCompletionProposal(CompletionProposal.METHOD_REF,context.completionLocation);
  proposal.setCompletion(completionName());
  proposal.setDeclarationSignature(ProposalUtils.createTypeSignature(method.getDeclaringClass()));
  proposal.setName(method.getName().toCharArray());
  char[][] parameterTypeNames=createParameterTypeNames(method);
  proposal.setParameterTypeNames(parameterTypeNames);
  proposal.setParameterNames(createParameterNames(method,parameterTypeNames));
  proposal.setReplaceRange(context.completionLocation - context.completionExpression.length(),context.completionLocation - context.completionExpression.length());
  proposal.setFlags(method.getModifiers());
  proposal.setAdditionalFlags(CompletionFlags.Default);
  char[] methodSignature=ProposalUtils.createMethodSignature(method);
  proposal.setKey(methodSignature);
  proposal.setSignature(methodSignature);
  proposal.setRelevance(getRelevance(proposal.getName()));
  return new GroovyJavaMethodCompletionProposal(proposal,javaContext);
}",0.995766299745978
186071,"public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  return new JavaCompletionProposal(property.getName(),context.completionLocation - context.completionExpression.length(),property.getName().length(),getImageFor(property),createDisplayString(property),2000);
}","public IJavaCompletionProposal createJavaProposal(ContentAssistContext context,JavaContentAssistInvocationContext javaContext){
  return new GroovyJavaFieldCompletionProposal(createProposal(context),getImageFor(property),createDisplayString(property));
}",0.7331081081081081
186072,"public void methodNameClash(MethodBinding currentMethod,MethodBinding inheritedMethod){
  this.handle(IProblem.MethodNameClash,new String[]{new String(currentMethod.selector),typesAsString(currentMethod.isVarargs(),currentMethod.parameters,false),new String(currentMethod.declaringClass.readableName()),typesAsString(inheritedMethod.isVarargs(),inheritedMethod.parameters,false),new String(inheritedMethod.declaringClass.readableName())},new String[]{new String(currentMethod.selector),typesAsString(currentMethod.isVarargs(),currentMethod.parameters,true),new String(currentMethod.declaringClass.shortReadableName()),typesAsString(inheritedMethod.isVarargs(),inheritedMethod.parameters,true),new String(inheritedMethod.declaringClass.shortReadableName())},currentMethod.sourceStart(),currentMethod.sourceEnd());
}","public void methodNameClash(MethodBinding currentMethod,MethodBinding inheritedMethod){
  if (currentMethod.declaringClass instanceof SourceTypeBinding) {
    SourceTypeBinding stb=(SourceTypeBinding)currentMethod.declaringClass;
    if (stb.scope != null && !stb.scope.shouldReport(IProblem.MethodNameClash)) {
      return;
    }
  }
  this.handle(IProblem.MethodNameClash,new String[]{new String(currentMethod.selector),typesAsString(currentMethod.isVarargs(),currentMethod.parameters,false),new String(currentMethod.declaringClass.readableName()),typesAsString(inheritedMethod.isVarargs(),inheritedMethod.parameters,false),new String(inheritedMethod.declaringClass.readableName())},new String[]{new String(currentMethod.selector),typesAsString(currentMethod.isVarargs(),currentMethod.parameters,true),new String(currentMethod.declaringClass.shortReadableName()),typesAsString(inheritedMethod.isVarargs(),inheritedMethod.parameters,true),new String(inheritedMethod.declaringClass.shortReadableName())},currentMethod.sourceStart(),currentMethod.sourceEnd());
}",0.8678038379530917
186073,"public void incompatibleReturnType(MethodBinding currentMethod,MethodBinding inheritedMethod){
  StringBuffer methodSignature=new StringBuffer();
  methodSignature.append(inheritedMethod.declaringClass.readableName()).append('.').append(inheritedMethod.readableName());
  StringBuffer shortSignature=new StringBuffer();
  shortSignature.append(inheritedMethod.declaringClass.shortReadableName()).append('.').append(inheritedMethod.shortReadableName());
  int id;
  final ReferenceBinding declaringClass=currentMethod.declaringClass;
  if (declaringClass.isInterface() && !inheritedMethod.isPublic()) {
    id=IProblem.IncompatibleReturnTypeForNonInheritedInterfaceMethod;
  }
 else {
    id=IProblem.IncompatibleReturnType;
  }
  AbstractMethodDeclaration method=currentMethod.sourceMethod();
  int sourceStart=0;
  int sourceEnd=0;
  if (method == null) {
    if (declaringClass instanceof SourceTypeBinding) {
      SourceTypeBinding sourceTypeBinding=(SourceTypeBinding)declaringClass;
      sourceStart=sourceTypeBinding.sourceStart();
      sourceEnd=sourceTypeBinding.sourceEnd();
    }
  }
 else   if (method.isConstructor()) {
    sourceStart=method.sourceStart;
    sourceEnd=method.sourceEnd;
  }
 else {
    TypeReference returnType=((MethodDeclaration)method).returnType;
    sourceStart=returnType.sourceStart;
    if (returnType instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference typeReference=(ParameterizedSingleTypeReference)returnType;
      TypeReference[] typeArguments=typeReference.typeArguments;
      if (typeArguments[typeArguments.length - 1].sourceEnd > typeReference.sourceEnd) {
        sourceEnd=retrieveClosingAngleBracketPosition(typeReference.sourceEnd);
      }
 else {
        sourceEnd=returnType.sourceEnd;
      }
    }
 else     if (returnType instanceof ParameterizedQualifiedTypeReference) {
      ParameterizedQualifiedTypeReference typeReference=(ParameterizedQualifiedTypeReference)returnType;
      sourceEnd=retrieveClosingAngleBracketPosition(typeReference.sourceEnd);
    }
 else {
      sourceEnd=returnType.sourceEnd;
    }
  }
  this.handle(id,new String[]{methodSignature.toString()},new String[]{shortSignature.toString()},sourceStart,sourceEnd);
}","public void incompatibleReturnType(MethodBinding currentMethod,MethodBinding inheritedMethod){
  if (currentMethod.declaringClass instanceof SourceTypeBinding) {
    SourceTypeBinding stb=(SourceTypeBinding)currentMethod.declaringClass;
    if (stb.scope != null && !stb.scope.shouldReport(IProblem.IncompatibleReturnType)) {
      return;
    }
  }
  StringBuffer methodSignature=new StringBuffer();
  methodSignature.append(inheritedMethod.declaringClass.readableName()).append('.').append(inheritedMethod.readableName());
  StringBuffer shortSignature=new StringBuffer();
  shortSignature.append(inheritedMethod.declaringClass.shortReadableName()).append('.').append(inheritedMethod.shortReadableName());
  int id;
  final ReferenceBinding declaringClass=currentMethod.declaringClass;
  if (declaringClass.isInterface() && !inheritedMethod.isPublic()) {
    id=IProblem.IncompatibleReturnTypeForNonInheritedInterfaceMethod;
  }
 else {
    id=IProblem.IncompatibleReturnType;
  }
  AbstractMethodDeclaration method=currentMethod.sourceMethod();
  int sourceStart=0;
  int sourceEnd=0;
  if (method == null) {
    if (declaringClass instanceof SourceTypeBinding) {
      SourceTypeBinding sourceTypeBinding=(SourceTypeBinding)declaringClass;
      sourceStart=sourceTypeBinding.sourceStart();
      sourceEnd=sourceTypeBinding.sourceEnd();
    }
  }
 else   if (method.isConstructor()) {
    sourceStart=method.sourceStart;
    sourceEnd=method.sourceEnd;
  }
 else {
    TypeReference returnType=((MethodDeclaration)method).returnType;
    sourceStart=returnType.sourceStart;
    if (returnType instanceof ParameterizedSingleTypeReference) {
      ParameterizedSingleTypeReference typeReference=(ParameterizedSingleTypeReference)returnType;
      TypeReference[] typeArguments=typeReference.typeArguments;
      if (typeArguments[typeArguments.length - 1].sourceEnd > typeReference.sourceEnd) {
        sourceEnd=retrieveClosingAngleBracketPosition(typeReference.sourceEnd);
      }
 else {
        sourceEnd=returnType.sourceEnd;
      }
    }
 else     if (returnType instanceof ParameterizedQualifiedTypeReference) {
      ParameterizedQualifiedTypeReference typeReference=(ParameterizedQualifiedTypeReference)returnType;
      sourceEnd=retrieveClosingAngleBracketPosition(typeReference.sourceEnd);
    }
 else {
      sourceEnd=returnType.sourceEnd;
    }
  }
  this.handle(id,new String[]{methodSignature.toString()},new String[]{shortSignature.toString()},sourceStart,sourceEnd);
}",0.9460545800719272
186074,"/** 
 * Resolve the supertypes for the types contained in the given openables (ICompilationUnits and/or IClassFiles). Inform the requestor of the resolved supertypes for each supplied source type using: connect(ISourceType suppliedType, IGenericType superclass, IGenericType[] superinterfaces) Also inform the requestor of the supertypes of each additional requested super type which is also a source type instead of a binary type.
 * @param openables
 * @param localTypes
 * @param monitor
 */
public void resolve(Openable[] openables,HashSet localTypes,IProgressMonitor monitor){
  try {
    int openablesLength=openables.length;
    CompilationUnitDeclaration[] parsedUnits=new CompilationUnitDeclaration[openablesLength];
    boolean[] hasLocalType=new boolean[openablesLength];
    org.eclipse.jdt.core.ICompilationUnit[] cus=new org.eclipse.jdt.core.ICompilationUnit[openablesLength];
    int unitsIndex=0;
    CompilationUnitDeclaration focusUnit=null;
    ReferenceBinding focusBinaryBinding=null;
    IType focus=this.builder.getType();
    Openable focusOpenable=null;
    if (focus != null) {
      if (focus.isBinary()) {
        focusOpenable=(Openable)focus.getClassFile();
      }
 else {
        focusOpenable=(Openable)focus.getCompilationUnit();
      }
    }
    Parser parser=new Parser(this.lookupEnvironment.problemReporter,true);
    for (int i=0; i < openablesLength; i++) {
      Openable openable=openables[i];
      if (openable instanceof org.eclipse.jdt.core.ICompilationUnit) {
        org.eclipse.jdt.core.ICompilationUnit cu=(org.eclipse.jdt.core.ICompilationUnit)openable;
        boolean containsLocalType=false;
        if (localTypes == null) {
          containsLocalType=true;
        }
 else {
          IPath path=cu.getPath();
          containsLocalType=localTypes.contains(path.toString());
        }
        CompilationUnitDeclaration parsedUnit=null;
        if (cu.isOpen()) {
          CompilationResult result=new CompilationResult(((ICompilationUnit)cu).getFileName(),i,openablesLength,this.options.maxProblemsPerUnit);
          SourceTypeElementInfo[] typeInfos=null;
          try {
            IType[] topLevelTypes=cu.getTypes();
            int topLevelLength=topLevelTypes.length;
            if (topLevelLength == 0)             continue;
            typeInfos=new SourceTypeElementInfo[topLevelLength];
            for (int j=0; j < topLevelLength; j++) {
              IType topLevelType=topLevelTypes[j];
              typeInfos[j]=(SourceTypeElementInfo)((JavaElement)topLevelType).getElementInfo();
            }
          }
 catch (          JavaModelException e) {
          }
          int flags=!containsLocalType ? SourceTypeConverter.MEMBER_TYPE : SourceTypeConverter.FIELD_AND_METHOD | SourceTypeConverter.MEMBER_TYPE | SourceTypeConverter.LOCAL_TYPE;
          parsedUnit=SourceTypeConverter.buildCompilationUnit(typeInfos,flags,this.lookupEnvironment.problemReporter,result);
          if (containsLocalType)           parsedUnit.bits|=ASTNode.HasAllMethodBodies;
        }
 else {
          IFile file=(IFile)cu.getResource();
          ICompilationUnit sourceUnit=this.builder.createCompilationUnitFromPath(openable,file);
          CompilationResult unitResult=new CompilationResult(sourceUnit,i,openablesLength,this.options.maxProblemsPerUnit);
          parsedUnit=parser.dietParse(sourceUnit,unitResult);
        }
        if (parsedUnit != null) {
          hasLocalType[unitsIndex]=containsLocalType;
          cus[unitsIndex]=cu;
          parsedUnits[unitsIndex++]=parsedUnit;
          try {
            this.lookupEnvironment.buildTypeBindings(parsedUnit,null);
            if (openable.equals(focusOpenable)) {
              focusUnit=parsedUnit;
            }
          }
 catch (          AbortCompilation e) {
          }
        }
      }
 else {
        ClassFile classFile=(ClassFile)openable;
        IBinaryType binaryType=(IBinaryType)JavaModelManager.getJavaModelManager().getInfo(classFile.getType());
        if (binaryType == null) {
          if (classFile.getPackageFragmentRoot().isArchive()) {
            binaryType=this.builder.createInfoFromClassFileInJar(classFile);
          }
 else {
            IResource file=classFile.resource();
            binaryType=this.builder.createInfoFromClassFile(classFile,file);
          }
        }
        if (binaryType != null) {
          try {
            BinaryTypeBinding binaryTypeBinding=this.lookupEnvironment.cacheBinaryType(binaryType,false,null);
            remember(binaryType,binaryTypeBinding);
            if (openable.equals(focusOpenable)) {
              focusBinaryBinding=binaryTypeBinding;
            }
          }
 catch (          AbortCompilation e) {
          }
        }
      }
    }
    TypeDeclaration focusLocalType=null;
    if (focus != null && focusBinaryBinding == null && focusUnit != null && ((Member)focus).getOuterMostLocalContext() != null) {
      focusLocalType=new ASTNodeFinder(focusUnit).findType(focus);
    }
    for (int i=0; i <= this.typeIndex; i++) {
      IGenericType suppliedType=this.typeModels[i];
      if (suppliedType != null && suppliedType.isBinaryType()) {
        CompilationUnitDeclaration previousUnitBeingCompleted=this.lookupEnvironment.unitBeingCompleted;
        try {
          if (previousUnitBeingCompleted == null) {
            this.lookupEnvironment.unitBeingCompleted=FakeUnit;
          }
          ReferenceBinding typeBinding=this.typeBindings[i];
          typeBinding.superclass();
          typeBinding.superInterfaces();
        }
 catch (        AbortCompilation e) {
        }
 finally {
          this.lookupEnvironment.unitBeingCompleted=previousUnitBeingCompleted;
        }
      }
    }
    for (int i=0; i < unitsIndex; i++) {
      CompilationUnitDeclaration parsedUnit=parsedUnits[i];
      if (parsedUnit != null) {
        try {
          boolean containsLocalType=hasLocalType[i];
          if (containsLocalType) {
            parser.getMethodBodies(parsedUnit);
          }
          this.lookupEnvironment.completeTypeBindings(parsedUnit,containsLocalType);
        }
 catch (        AbortCompilation e) {
          hasLocalType[i]=false;
        }
      }
      worked(monitor,1);
    }
    for (int i=0; i < unitsIndex; i++) {
      CompilationUnitDeclaration parsedUnit=parsedUnits[i];
      if (parsedUnit != null) {
        boolean containsLocalType=hasLocalType[i];
        if (containsLocalType) {
          parsedUnit.scope.faultInTypes();
          parsedUnit.resolve();
        }
        rememberAllTypes(parsedUnit,cus[i],containsLocalType);
      }
    }
    if (focusBinaryBinding == null && focus != null && focus.isBinary()) {
      char[] fullyQualifiedName=focus.getFullyQualifiedName().toCharArray();
      focusBinaryBinding=this.lookupEnvironment.getCachedType(CharOperation.splitOn('.',fullyQualifiedName));
      if (focusBinaryBinding == null)       return;
    }
    reportHierarchy(focus,focusLocalType,focusBinaryBinding);
  }
 catch (  ClassCastException e) {
  }
catch (  AbortCompilation e) {
    if (TypeHierarchy.DEBUG)     e.printStackTrace();
  }
 finally {
    reset();
  }
}","/** 
 * Resolve the supertypes for the types contained in the given openables (ICompilationUnits and/or IClassFiles). Inform the requestor of the resolved supertypes for each supplied source type using: connect(ISourceType suppliedType, IGenericType superclass, IGenericType[] superinterfaces) Also inform the requestor of the supertypes of each additional requested super type which is also a source type instead of a binary type.
 * @param openables
 * @param localTypes
 * @param monitor
 */
public void resolve(Openable[] openables,HashSet localTypes,IProgressMonitor monitor){
  try {
    int openablesLength=openables.length;
    CompilationUnitDeclaration[] parsedUnits=new CompilationUnitDeclaration[openablesLength];
    boolean[] hasLocalType=new boolean[openablesLength];
    org.eclipse.jdt.core.ICompilationUnit[] cus=new org.eclipse.jdt.core.ICompilationUnit[openablesLength];
    int unitsIndex=0;
    CompilationUnitDeclaration focusUnit=null;
    ReferenceBinding focusBinaryBinding=null;
    IType focus=this.builder.getType();
    Openable focusOpenable=null;
    if (focus != null) {
      if (focus.isBinary()) {
        focusOpenable=(Openable)focus.getClassFile();
      }
 else {
        focusOpenable=(Openable)focus.getCompilationUnit();
      }
    }
    Parser parser=LanguageSupportFactory.getParser(this.lookupEnvironment.globalOptions,this.lookupEnvironment.problemReporter,true,1);
    for (int i=0; i < openablesLength; i++) {
      Openable openable=openables[i];
      if (openable instanceof org.eclipse.jdt.core.ICompilationUnit) {
        org.eclipse.jdt.core.ICompilationUnit cu=(org.eclipse.jdt.core.ICompilationUnit)openable;
        boolean containsLocalType=false;
        if (localTypes == null) {
          containsLocalType=true;
        }
 else {
          IPath path=cu.getPath();
          containsLocalType=localTypes.contains(path.toString());
        }
        CompilationUnitDeclaration parsedUnit=null;
        if (cu.isOpen()) {
          CompilationResult result=new CompilationResult(((ICompilationUnit)cu).getFileName(),i,openablesLength,this.options.maxProblemsPerUnit);
          SourceTypeElementInfo[] typeInfos=null;
          try {
            IType[] topLevelTypes=cu.getTypes();
            int topLevelLength=topLevelTypes.length;
            if (topLevelLength == 0)             continue;
            typeInfos=new SourceTypeElementInfo[topLevelLength];
            for (int j=0; j < topLevelLength; j++) {
              IType topLevelType=topLevelTypes[j];
              typeInfos[j]=(SourceTypeElementInfo)((JavaElement)topLevelType).getElementInfo();
            }
          }
 catch (          JavaModelException e) {
          }
          int flags=!containsLocalType ? SourceTypeConverter.MEMBER_TYPE : SourceTypeConverter.FIELD_AND_METHOD | SourceTypeConverter.MEMBER_TYPE | SourceTypeConverter.LOCAL_TYPE;
          parsedUnit=SourceTypeConverter.buildCompilationUnit(typeInfos,flags,this.lookupEnvironment.problemReporter,result);
          if (containsLocalType)           parsedUnit.bits|=ASTNode.HasAllMethodBodies;
        }
 else {
          IFile file=(IFile)cu.getResource();
          ICompilationUnit sourceUnit=this.builder.createCompilationUnitFromPath(openable,file);
          CompilationResult unitResult=new CompilationResult(sourceUnit,i,openablesLength,this.options.maxProblemsPerUnit);
          parsedUnit=parser.dietParse(sourceUnit,unitResult);
        }
        if (parsedUnit != null) {
          hasLocalType[unitsIndex]=containsLocalType;
          cus[unitsIndex]=cu;
          parsedUnits[unitsIndex++]=parsedUnit;
          try {
            this.lookupEnvironment.buildTypeBindings(parsedUnit,null);
            if (openable.equals(focusOpenable)) {
              focusUnit=parsedUnit;
            }
          }
 catch (          AbortCompilation e) {
          }
        }
      }
 else {
        ClassFile classFile=(ClassFile)openable;
        IBinaryType binaryType=(IBinaryType)JavaModelManager.getJavaModelManager().getInfo(classFile.getType());
        if (binaryType == null) {
          if (classFile.getPackageFragmentRoot().isArchive()) {
            binaryType=this.builder.createInfoFromClassFileInJar(classFile);
          }
 else {
            IResource file=classFile.resource();
            binaryType=this.builder.createInfoFromClassFile(classFile,file);
          }
        }
        if (binaryType != null) {
          try {
            BinaryTypeBinding binaryTypeBinding=this.lookupEnvironment.cacheBinaryType(binaryType,false,null);
            remember(binaryType,binaryTypeBinding);
            if (openable.equals(focusOpenable)) {
              focusBinaryBinding=binaryTypeBinding;
            }
          }
 catch (          AbortCompilation e) {
          }
        }
      }
    }
    TypeDeclaration focusLocalType=null;
    if (focus != null && focusBinaryBinding == null && focusUnit != null && ((Member)focus).getOuterMostLocalContext() != null) {
      focusLocalType=new ASTNodeFinder(focusUnit).findType(focus);
    }
    for (int i=0; i <= this.typeIndex; i++) {
      IGenericType suppliedType=this.typeModels[i];
      if (suppliedType != null && suppliedType.isBinaryType()) {
        CompilationUnitDeclaration previousUnitBeingCompleted=this.lookupEnvironment.unitBeingCompleted;
        try {
          if (previousUnitBeingCompleted == null) {
            this.lookupEnvironment.unitBeingCompleted=FakeUnit;
          }
          ReferenceBinding typeBinding=this.typeBindings[i];
          typeBinding.superclass();
          typeBinding.superInterfaces();
        }
 catch (        AbortCompilation e) {
        }
 finally {
          this.lookupEnvironment.unitBeingCompleted=previousUnitBeingCompleted;
        }
      }
    }
    for (int i=0; i < unitsIndex; i++) {
      CompilationUnitDeclaration parsedUnit=parsedUnits[i];
      if (parsedUnit != null) {
        try {
          boolean containsLocalType=hasLocalType[i];
          if (containsLocalType) {
            parser.getMethodBodies(parsedUnit);
          }
          this.lookupEnvironment.completeTypeBindings(parsedUnit,containsLocalType);
        }
 catch (        AbortCompilation e) {
          hasLocalType[i]=false;
        }
      }
      worked(monitor,1);
    }
    for (int i=0; i < unitsIndex; i++) {
      CompilationUnitDeclaration parsedUnit=parsedUnits[i];
      if (parsedUnit != null) {
        boolean containsLocalType=hasLocalType[i];
        if (containsLocalType) {
          parsedUnit.scope.faultInTypes();
          parsedUnit.resolve();
        }
        rememberAllTypes(parsedUnit,cus[i],containsLocalType);
      }
    }
    if (focusBinaryBinding == null && focus != null && focus.isBinary()) {
      char[] fullyQualifiedName=focus.getFullyQualifiedName().toCharArray();
      focusBinaryBinding=this.lookupEnvironment.getCachedType(CharOperation.splitOn('.',fullyQualifiedName));
      if (focusBinaryBinding == null)       return;
    }
    reportHierarchy(focus,focusLocalType,focusBinaryBinding);
  }
 catch (  ClassCastException e) {
  }
catch (  AbortCompilation e) {
    if (TypeHierarchy.DEBUG)     e.printStackTrace();
  }
 finally {
    reset();
  }
}",0.9949189113941672
186075,"public MultiplexingSourceElementRequestorParser(ProblemReporter problemReporter,ISourceElementRequestor requestor,IProblemFactory problemFactory,CompilerOptions options,boolean reportLocalDeclarations,boolean optimizeStringLiterals){
  super(requestor,problemFactory,options,reportLocalDeclarations,optimizeStringLiterals);
  this.groovyRequestor=requestor;
  this.notifier=new SourceElementNotifier(requestor,reportLocalDeclarations);
}","public MultiplexingSourceElementRequestorParser(ProblemReporter problemReporter,ISourceElementRequestor requestor,IProblemFactory problemFactory,CompilerOptions options,boolean reportLocalDeclarations,boolean optimizeStringLiterals){
  super(requestor,problemFactory,options,reportLocalDeclarations,optimizeStringLiterals);
  this.groovyRequestor=requestor;
  this.notifier=new SourceElementNotifier(requestor,reportLocalDeclarations);
  this.parser=new GroovyParser(this.options,problemReporter);
}",0.9337606837606838
186076,"@Override public boolean shouldReport(int problem){
  if (problem == IProblem.SuperclassMustBeAClass) {
    return false;
  }
  return true;
}","@Override public boolean shouldReport(int problem){
  if (problem == IProblem.SuperclassMustBeAClass) {
    return false;
  }
  if (problem == IProblem.IncompatibleReturnType) {
    return false;
  }
  if (problem == IProblem.AbstractMethodMustBeImplemented) {
    return false;
  }
  if (problem == IProblem.MethodNameClash) {
    return false;
  }
  return true;
}",0.5039370078740157
186077,"private Neo4jTemplate neo4jTemplate(Neo4jConnectionCallback connection){
  GraphDatabaseService graphDatabaseService=connection.graphDatabaseService();
  Neo4jTemplate neo4jTemplate=new Neo4jTemplate(graphDatabaseService);
  return neo4jTemplate;
}","private Neo4jTemplate neo4jTemplate(Neo4jConnectionCallback connection){
  GraphDatabaseService graphDatabaseService=connection.graphDatabaseService();
  return new Neo4jTemplate(graphDatabaseService);
}",0.8691796008869179
186078,"private Long incrementAndSetValue(final byte[] key,final byte[] field,final long value,byte[] elementToUpdate){
  try {
    long longValue=incrementValue(value,elementToUpdate);
    hset(key,field,Long.toString(value).getBytes(""String_Node_Str""));
    return longValue;
  }
 catch (  UnsupportedEncodingException e) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
catch (  NumberFormatException e) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}","private Long incrementAndSetValue(final byte[] key,final byte[] field,final long value,byte[] elementToUpdate){
  try {
    long longValue=incrementValue(value,elementToUpdate);
    hset(key,field,Long.toString(longValue).getBytes(""String_Node_Str""));
    return longValue;
  }
 catch (  UnsupportedEncodingException e) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
catch (  NumberFormatException e) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}",0.9939148073022313
186079,"public Node getNeoNode(){
  return graphDb.getReferenceNode().getSingleRelationship(RelTypes.NEO_NODE,Direction.OUTGOING).getEndNode();
}","public Node getNeoNode(){
  Iterable<Node> allNodes=GlobalGraphOperations.at(graphDb).getAllNodes();
  for (  Node node : allNodes) {
    if (""String_Node_Str"".equals(node.getProperty(""String_Node_Str""))) {
      return node;
    }
  }
  return null;
}",0.2056555269922879
186080,"public Node getNeoNode(){
  return graphDb.getReferenceNode().getSingleRelationship(RelTypes.NEO_NODE,Direction.OUTGOING).getEndNode();
}","public Node getNeoNode(){
  Iterable<Node> allNodes=GlobalGraphOperations.at(graphDb).getAllNodes();
  for (  Node node : allNodes) {
    if (""String_Node_Str"".equals(node.getProperty(""String_Node_Str""))) {
      return node;
    }
  }
  return null;
}",0.2056555269922879
186081,"void processInjectAnnotation(Class<?> clazz,Object testInstance,Object injectionObject){
  if (isTargetSet(testInstance)) {
    Field[] fields=clazz.getDeclaredFields();
    for (    Field field : fields) {
      Annotation injectAnnotation=field.getAnnotation(Inject.class);
      Annotation connectionManagerAnnotation=field.getAnnotation(ConnectionManager.class);
      Annotation byContainerAnnotation=field.getAnnotation(ByContainer.class);
      if (isInjectedAndNotExternallyManaged(injectAnnotation,byContainerAnnotation,connectionManagerAnnotation)) {
        Annotation namedAnnotation=field.getAnnotation(Named.class);
        if (isNamedAnnotationNotPresent(namedAnnotation) || isIdentifierValueInNamedAnnotation(namedAnnotation)) {
          if (field.getType().isInstance(injectionObject)) {
            new FieldSetter(testInstance,field).set(injectionObject);
          }
        }
      }
    }
  }
}","void processInjectAnnotation(Class<?> clazz,Object testInstance,Object injectionObject){
  if (isTargetSet(testInstance)) {
    Set<Field> fields=new HashSet<Field>();
    fields.addAll(getFieldsWithAnnotation(clazz,Inject.class));
    fields.addAll(getFieldsWithAnnotation(clazz,ConnectionManager.class));
    fields.addAll(getFieldsWithAnnotation(clazz,ByContainer.class));
    for (    Field field : fields) {
      Annotation injectAnnotation=field.getAnnotation(Inject.class);
      Annotation connectionManagerAnnotation=field.getAnnotation(ConnectionManager.class);
      Annotation byContainerAnnotation=field.getAnnotation(ByContainer.class);
      if (isInjectedAndNotExternallyManaged(injectAnnotation,byContainerAnnotation,connectionManagerAnnotation)) {
        Annotation namedAnnotation=field.getAnnotation(Named.class);
        if (isNamedAnnotationNotPresent(namedAnnotation) || isIdentifierValueInNamedAnnotation(namedAnnotation)) {
          if (field.getType().isInstance(injectionObject)) {
            new FieldSetter(testInstance,field).set(injectionObject);
          }
        }
      }
    }
  }
}",0.884313725490196
186082,"public Long del(final String... keys){
  byte[][] arrayOfFields=with(keys).convert(toByteArray()).toArray(new byte[keys.length][]);
  return this.del(arrayOfFields);
}","@Override public Long del(String key){
  return this.del(key.getBytes());
}",0.4462809917355372
186083,"@Override public Long lpushx(String key,String string){
  return this.lpushx(toByteArray().convert(key),toByteArray().convert(string));
}","@Override public Long lpushx(String key,String... values){
  long lastSize=this.listDatatypeOperations.llen(key.getBytes());
  for (  String value : values) {
    lastSize=this.lpushx(key,value);
  }
  return lastSize;
}",0.3977591036414565
186084,"@Override public Boolean setbit(String key,long offset,boolean value){
  return this.setbit(toByteArray().convert(key),offset,toBooleanByteArray().convert(value));
}","@Override public Boolean setbit(String key,long offset,String value){
  return this.setbit(key.getBytes(),offset,value.getBytes());
}",0.7449664429530202
186085,"@Override public Long rpushx(String key,String string){
  return this.rpushx(toByteArray().convert(key),toByteArray().convert(string));
}","@Override public Long rpushx(String key,String... values){
  long lastSize=this.listDatatypeOperations.llen(key.getBytes());
  for (  String value : values) {
    lastSize=this.rpushx(key,value);
  }
  return lastSize;
}",0.3977591036414565
186086,"public Long move(final byte[] key,final int dbIndex){
  return this.move(key,dbIndex);
}","@Override public Long move(String key,int dbIndex){
  return this.move(key.getBytes(),dbIndex);
}",0.7783783783783784
186087,"/** 
 * Remove the first count occurrences of the value element from the list. If count is zero all the elements are removed. If count is negative elements are removed from tail to head, instead to go from head to tail that is the normal behaviour. So for example LREM with count -2 and hello as value to remove against the list (a,b,c,hello,x,hello,hello) will have the list (a,b,c,hello,x). The number of removed elements is returned as an integer, see below for more information about the returned value. Note that non existing keys are considered like empty lists by LREM, so LREM against non existing keys will always return 0. <p> Time complexity: O(N) (with N being the length of the list)
 * @param key
 * @param count
 * @param value
 * @return Integer Reply, specifically: The number of removed elements ifthe operation succeeded
 */
public Long lrem(final byte[] key,final int count,final byte[] value){
  ByteBuffer wrappedKey=wrap(key);
  ByteBuffer wrappedValue=wrap(value);
  long numberOfElementsRemoved=0;
  if (count < 0) {
    numberOfElementsRemoved=removeLastElements(count,wrappedKey,wrappedValue);
  }
 else {
    if (count == 0) {
      numberOfElementsRemoved=removeAllElements(wrappedKey,wrappedValue);
    }
 else {
      numberOfElementsRemoved=removeFirstElements(count,wrappedKey,wrappedValue);
    }
  }
  return numberOfElementsRemoved;
}","/** 
 * Remove the first count occurrences of the value element from the list. If count is zero all the elements are removed. If count is negative elements are removed from tail to head, instead to go from head to tail that is the normal behaviour. So for example LREM with count -2 and hello as value to remove against the list (a,b,c,hello,x,hello,hello) will have the list (a,b,c,hello,x). The number of removed elements is returned as an integer, see below for more information about the returned value. Note that non existing keys are considered like empty lists by LREM, so LREM against non existing keys will always return 0. <p> Time complexity: O(N) (with N being the length of the list)
 * @param key
 * @param count
 * @param value
 * @return Integer Reply, specifically: The number of removed elements ifthe operation succeeded
 */
public Long lrem(final byte[] key,final long count,final byte[] value){
  ByteBuffer wrappedKey=wrap(key);
  ByteBuffer wrappedValue=wrap(value);
  long numberOfElementsRemoved=0;
  if (count < 0) {
    numberOfElementsRemoved=removeLastElements((int)count,wrappedKey,wrappedValue);
  }
 else {
    if (count == 0) {
      numberOfElementsRemoved=removeAllElements(wrappedKey,wrappedValue);
    }
 else {
      numberOfElementsRemoved=removeFirstElements((int)count,wrappedKey,wrappedValue);
    }
  }
  return numberOfElementsRemoved;
}",0.9938204289349328
186088,"/** 
 * Return the specified element of the list stored at the specified key. 0 is the first element, 1 the second and so on. Negative indexes are supported, for example -1 is the last element, -2 the penultimate and so on. <p> If the value stored at key is not of list type an error is returned. If the index is out of range a 'nil' reply is returned. <p> Note that even if the average time complexity is O(n) asking for the first or the last element of the list is O(1). <p>
 * @param key
 * @param index
 * @return Bulk reply, specifically the requested element
 */
public byte[] lindex(final byte[] key,final int index){
  ByteBuffer elementAtIndex=this.blockingMultimap.getElement(wrap(key),index);
  return elementAtIndex == null ? null : elementAtIndex.array();
}","/** 
 * Return the specified element of the list stored at the specified key. 0 is the first element, 1 the second and so on. Negative indexes are supported, for example -1 is the last element, -2 the penultimate and so on. <p> If the value stored at key is not of list type an error is returned. If the index is out of range a 'nil' reply is returned. <p> Note that even if the average time complexity is O(n) asking for the first or the last element of the list is O(1). <p>
 * @param key
 * @param index
 * @return Bulk reply, specifically the requested element
 */
public byte[] lindex(final byte[] key,final long index){
  ByteBuffer elementAtIndex=this.blockingMultimap.getElement(wrap(key),(int)index);
  return elementAtIndex == null ? null : elementAtIndex.array();
}",0.9922380336351876
186089,"/** 
 * Trim an existing list so that it will contain only the specified range of elements specified. Start and end are zero-based indexes. 0 is the first element of the list (the list head), 1 the next element and so on. <p> For example LTRIM foobar 0 2 will modify the list stored at foobar key so that only the first three elements of the list will remain. <p> start and end can also be negative numbers indicating offsets from the end of the list. For example -1 is the last element of the list, -2 the penultimate element and so on. <p> Indexes out of range will not produce an error: if start is over the end of the list, or start > end, an empty list is left as value. If end over the end of the list Redis will threat it just like the last element of the list. <p> Hint: the obvious use of LTRIM is together with LPUSH/RPUSH. For example: <p>  {@code lpush(""mylist"", ""someelement""); ltrim(""mylist"", 0, 99); * }<p> The above two commands will push elements in the list taking care that the list will not grow without limits. This is very useful when using Redis to store logs for example. It is important to note that when used in this way LTRIM is an O(1) operation because in the average case just one element is removed from the tail of the list. <p>
 * @param key
 * @param start
 * @param end
 * @return Status code reply
 */
public String ltrim(final byte[] key,final int start,final int end){
  ByteBuffer wrappedKey=wrap(key);
  List<ByteBuffer> elements=new LinkedList<ByteBuffer>(this.blockingMultimap.elements(wrappedKey));
  int calculatedStart=RangeUtils.calculateStart(start,elements.size());
  int calculatedEnd=RangeUtils.calculateEnd(end,elements.size());
  try {
    List<ByteBuffer> sublist=elements.subList(calculatedStart,calculatedEnd);
    this.blockingMultimap.replaceValues(wrappedKey,sublist);
  }
 catch (  IndexOutOfBoundsException e) {
    return KO;
  }
catch (  IllegalArgumentException e) {
    return KO;
  }
  return OK;
}","/** 
 * Trim an existing list so that it will contain only the specified range of elements specified. Start and end are zero-based indexes. 0 is the first element of the list (the list head), 1 the next element and so on. <p> For example LTRIM foobar 0 2 will modify the list stored at foobar key so that only the first three elements of the list will remain. <p> start and end can also be negative numbers indicating offsets from the end of the list. For example -1 is the last element of the list, -2 the penultimate element and so on. <p> Indexes out of range will not produce an error: if start is over the end of the list, or start > end, an empty list is left as value. If end over the end of the list Redis will threat it just like the last element of the list. <p> Hint: the obvious use of LTRIM is together with LPUSH/RPUSH. For example: <p>  {@code lpush(""mylist"", ""someelement""); ltrim(""mylist"", 0, 99); * }<p> The above two commands will push elements in the list taking care that the list will not grow without limits. This is very useful when using Redis to store logs for example. It is important to note that when used in this way LTRIM is an O(1) operation because in the average case just one element is removed from the tail of the list. <p>
 * @param key
 * @param start
 * @param end
 * @return Status code reply
 */
public String ltrim(final byte[] key,final long start,final long end){
  ByteBuffer wrappedKey=wrap(key);
  List<ByteBuffer> elements=new LinkedList<ByteBuffer>(this.blockingMultimap.elements(wrappedKey));
  int calculatedStart=RangeUtils.calculateStart((int)start,elements.size());
  int calculatedEnd=RangeUtils.calculateEnd((int)end,elements.size());
  try {
    List<ByteBuffer> sublist=elements.subList(calculatedStart,calculatedEnd);
    this.blockingMultimap.replaceValues(wrappedKey,sublist);
  }
 catch (  IndexOutOfBoundsException e) {
    return KO;
  }
catch (  IllegalArgumentException e) {
    return KO;
  }
  return OK;
}",0.9939055358049772
186090,"/** 
 * Return the specified elements of the list stored at the specified key. Start and end are zero-based indexes. 0 is the first element of the list (the list head), 1 the next element and so on. <p> For example LRANGE foobar 0 2 will return the first three elements of the list. <p> start and end can also be negative numbers indicating offsets from the end of the list. For example -1 is the last element of the list, -2 the penultimate element and so on. <p> <b>Consistency with range functions in various programming languages</b> <p> Note that if you have a list of numbers from 0 to 100, LRANGE 0 10 will return 11 elements, that is, rightmost item is included. This may or may not be consistent with behavior of range-related functions in your programming language of choice (think Ruby's Range.new, Array#slice or Python's range() function). <p> LRANGE behavior is consistent with one of Tcl. <p> <b>Out-of-range indexes</b> <p> Indexes out of range will not produce an error: if start is over the end of the list, or start > end, an empty list is returned. If end is over the end of the list Redis will threat it just like the last element of the list. <p>
 * @param key
 * @param start
 * @param end
 * @return Multi bulk reply, specifically a list of elements in thespecified range.
 */
public List<byte[]> lrange(final byte[] key,final int start,final int end){
  List<ByteBuffer> elements=new LinkedList<ByteBuffer>(this.blockingMultimap.elements(wrap(key)));
  int calculatedStart=RangeUtils.calculateStart(start,elements.size());
  int calculatedEnd=RangeUtils.calculateEnd(end,elements.size());
  try {
    List<ByteBuffer> subList=elements.subList(calculatedStart,calculatedEnd);
    return convert(subList,new ByteBuffer2ByteArrayConverter());
  }
 catch (  IndexOutOfBoundsException e) {
    return Collections.EMPTY_LIST;
  }
}","/** 
 * Return the specified elements of the list stored at the specified key. Start and end are zero-based indexes. 0 is the first element of the list (the list head), 1 the next element and so on. <p> For example LRANGE foobar 0 2 will return the first three elements of the list. <p> start and end can also be negative numbers indicating offsets from the end of the list. For example -1 is the last element of the list, -2 the penultimate element and so on. <p> <b>Consistency with range functions in various programming languages</b> <p> Note that if you have a list of numbers from 0 to 100, LRANGE 0 10 will return 11 elements, that is, rightmost item is included. This may or may not be consistent with behavior of range-related functions in your programming language of choice (think Ruby's Range.new, Array#slice or Python's range() function). <p> LRANGE behavior is consistent with one of Tcl. <p> <b>Out-of-range indexes</b> <p> Indexes out of range will not produce an error: if start is over the end of the list, or start > end, an empty list is returned. If end is over the end of the list Redis will threat it just like the last element of the list. <p>
 * @param key
 * @param start
 * @param end
 * @return Multi bulk reply, specifically a list of elements in thespecified range.
 */
public List<byte[]> lrange(final byte[] key,final long start,final long end){
  List<ByteBuffer> elements=new LinkedList<ByteBuffer>(this.blockingMultimap.elements(wrap(key)));
  int calculatedStart=RangeUtils.calculateStart((int)start,elements.size());
  int calculatedEnd=RangeUtils.calculateEnd((int)end,elements.size());
  try {
    List<ByteBuffer> subList=elements.subList(calculatedStart,calculatedEnd);
    return convert(subList,new ByteBuffer2ByteArrayConverter());
  }
 catch (  IndexOutOfBoundsException e) {
    return Collections.EMPTY_LIST;
  }
}",0.9935344827586208
186091,"public EmbeddedJedis(){
  hashDatatypeOperations=new HashDatatypeOperations();
  listDatatypeOperations=new ListDatatypeOperations();
  setDatatypeOperations=new SetDatatypeOperations();
  sortsetDatatypeOperations=new SortsetDatatypeOperations();
  stringDatatypeOperations=new StringDatatypeOperations();
  pubSubServerOperations=new PubSubServerOperations();
  connectionServerOperations=new ConnectionServerOperations();
  scriptingServerOperations=new ScriptingServerOperations();
  transactionServerOperations=new TransactionServerOperations();
  keysServerOperations=KeysServerOperations.createKeysServerOperations(hashDatatypeOperations,listDatatypeOperations,setDatatypeOperations,sortsetDatatypeOperations,stringDatatypeOperations);
}","public EmbeddedJedis(){
  hashDatatypeOperations=new HashDatatypeOperations();
  listDatatypeOperations=new ListDatatypeOperations();
  setDatatypeOperations=new SetDatatypeOperations();
  sortsetDatatypeOperations=new SortsetDatatypeOperations();
  stringDatatypeOperations=new StringDatatypeOperations();
  pubSubServerOperations=new PubSubServerOperations();
  connectionServerOperations=new ConnectionServerOperations();
  scriptingServerOperations=new ScriptingServerOperations();
  transactionServerOperations=new TransactionServerOperations(this);
  keysServerOperations=KeysServerOperations.createKeysServerOperations(hashDatatypeOperations,listDatatypeOperations,setDatatypeOperations,sortsetDatatypeOperations,stringDatatypeOperations);
}",0.9973190348525468
186092,"private void insertIndexes(DB mongoDb,String collectionName,DBObject collection){
  DBCollection indexedCollection=mongoDb.getCollection(collectionName);
  BasicDBList indexes=(BasicDBList)collection.get(INDEXES);
  for (  Object object : indexes) {
    DBObject index=(DBObject)object;
    DBObject indexKeys=(DBObject)index.get(INDEX);
    if (index.containsField(INDEX_OPTIONS)) {
      DBObject indexOptions=(DBObject)index.get(INDEX_OPTIONS);
      indexedCollection.createIndex(indexKeys,indexOptions);
    }
 else {
      indexedCollection.createIndex(indexKeys);
    }
  }
}","private void insertIndexes(DB mongoDb,String collectionName,DBObject collection){
  DBCollection indexedCollection=mongoDb.getCollection(collectionName);
  BasicDBList indexes=(BasicDBList)collection.get(INDEXES);
  for (  Object object : indexes) {
    DBObject index=(DBObject)object;
    DBObject indexKeys=(DBObject)index.get(INDEX);
    if (index.containsField(INDEX_OPTIONS)) {
      DBObject indexOptions=(DBObject)index.get(INDEX_OPTIONS);
      indexedCollection.ensureIndex(indexKeys,indexOptions);
    }
 else {
      indexedCollection.ensureIndex(indexKeys);
    }
  }
}",0.986254295532646
186093,"private void verifyIndexCreationCommand(DBObject indexDocument,DBCollection collection){
  final ArgumentCaptor<DBObject> indexCommandCaptor=ArgumentCaptor.forClass(DBObject.class);
  verify(collection,times(1)).createIndex(indexCommandCaptor.capture());
  assertThat(indexCommandCaptor.getValue(),is(indexDocument));
}","private void verifyIndexCreationCommand(DBObject indexDocument,DBCollection collection){
  final ArgumentCaptor<DBObject> indexCommandCaptor=ArgumentCaptor.forClass(DBObject.class);
  verify(collection,times(1)).ensureIndex(indexCommandCaptor.capture());
  assertThat(indexCommandCaptor.getValue(),is(indexDocument));
}",0.9843260188087776
186094,"private void verifyIndexCreationCommandAndOptions(DBObject indexDocument,DBObject indexOptions,DBCollection collection){
  final ArgumentCaptor<DBObject> indexCommandCaptor=ArgumentCaptor.forClass(DBObject.class);
  final ArgumentCaptor<DBObject> indexOptionCommandCaptor=ArgumentCaptor.forClass(DBObject.class);
  verify(collection,times(1)).createIndex(indexCommandCaptor.capture(),indexOptionCommandCaptor.capture());
  assertThat(indexCommandCaptor.getValue(),is(indexDocument));
  assertThat(indexOptionCommandCaptor.getValue(),is(indexOptions));
}","private void verifyIndexCreationCommandAndOptions(DBObject indexDocument,DBObject indexOptions,DBCollection collection){
  final ArgumentCaptor<DBObject> indexCommandCaptor=ArgumentCaptor.forClass(DBObject.class);
  final ArgumentCaptor<DBObject> indexOptionCommandCaptor=ArgumentCaptor.forClass(DBObject.class);
  verify(collection,times(1)).ensureIndex(indexCommandCaptor.capture(),indexOptionCommandCaptor.capture());
  assertThat(indexCommandCaptor.getValue(),is(indexDocument));
  assertThat(indexOptionCommandCaptor.getValue(),is(indexOptions));
}",0.9909584086799276
186095,"@Override public List<byte[]> keys(){
  return new ArrayList<byte[]>(convert(this.hashElements.columnKeySet(),ByteBuffer2ByteArrayConverter.createByteBufferConverter()));
}","@Override public List<byte[]> keys(){
  return new ArrayList<byte[]>(convert(this.hashElements.rowKeySet(),ByteBuffer2ByteArrayConverter.createByteBufferConverter()));
}",0.9794721407624634
186096,"private void writeRelationships(List<Relationship> relationships,XMLStreamWriter writer) throws XMLStreamException {
  for (  Relationship edge : relationships) {
    writer.writeStartElement(GraphMLTokens.EDGE);
    writer.writeAttribute(GraphMLTokens.ID,Long.toString(edge.getId()));
    writer.writeAttribute(GraphMLTokens.SOURCE,Long.toString(edge.getStartNode().getId()));
    writer.writeAttribute(GraphMLTokens.TARGET,Long.toString(edge.getEndNode().getId()));
    writer.writeAttribute(GraphMLTokens.LABEL,edge.getType().name());
    for (    String key : edge.getPropertyKeys()) {
      writer.writeStartElement(GraphMLTokens.DATA);
      writer.writeAttribute(GraphMLTokens.KEY,key);
      Object value=edge.getProperty(key);
      if (null != value) {
        writer.writeCharacters(value.toString());
      }
      writer.writeEndElement();
    }
    writer.writeEndElement();
  }
}","private void writeRelationships(List<Relationship> relationships,XMLStreamWriter writer) throws XMLStreamException {
  for (  Relationship edge : relationships) {
    writer.writeStartElement(GraphMLTokens.EDGE);
    writer.writeAttribute(GraphMLTokens.ID,Long.toString(edge.getId()));
    writer.writeAttribute(GraphMLTokens.SOURCE,Long.toString(edge.getStartNode().getId()));
    writer.writeAttribute(GraphMLTokens.TARGET,Long.toString(edge.getEndNode().getId()));
    writer.writeAttribute(GraphMLTokens.LABEL,edge.getType().name());
    for (    String key : edge.getPropertyKeys()) {
      writer.writeStartElement(GraphMLTokens.DATA);
      writer.writeAttribute(GraphMLTokens.KEY,key);
      Object value=edge.getProperty(key);
      if (null != value) {
        if (TypeCaster.isArray(value)) {
          writeArray(value,writer);
        }
 else {
          writer.writeCharacters(value.toString());
        }
      }
      writer.writeEndElement();
    }
    writer.writeEndElement();
  }
}",0.9319261213720316
186097,"public static Object typeCastValue(String key,String value,Map<String,String> keyTypes){
  String type=keyTypes.get(key);
  if (null == type || type.equals(GraphMLTokens.STRING))   return value;
 else   if (type.equals(GraphMLTokens.FLOAT))   return Float.valueOf(value);
 else   if (type.equals(GraphMLTokens.INT))   return Integer.valueOf(value);
 else   if (type.equals(GraphMLTokens.DOUBLE))   return Double.valueOf(value);
 else   if (type.equals(GraphMLTokens.BOOLEAN))   return Boolean.valueOf(value);
 else   if (type.equals(GraphMLTokens.LONG))   return Long.valueOf(value);
 else   return value;
}","public static Object typeCastValue(String key,String value,Map<String,String> keyTypes){
  String type=keyTypes.get(key);
  if (null == type || type.equals(GraphMLTokens.STRING))   return value;
 else   if (type.equals(GraphMLTokens.FLOAT))   return Float.valueOf(value);
 else   if (type.equals(GraphMLTokens.INT))   return Integer.valueOf(value);
 else   if (type.equals(GraphMLTokens.DOUBLE))   return Double.valueOf(value);
 else   if (type.equals(GraphMLTokens.BOOLEAN))   return Boolean.valueOf(value);
 else   if (type.equals(GraphMLTokens.LONG))   return Long.valueOf(value);
 else   if (type.contains(""String_Node_Str""))   return castToArray(type,value);
 else   return value;
}",0.9381761978361668
186098,"public static String getStringType(final Object object){
  if (object instanceof String) {
    return GraphMLTokens.STRING;
  }
 else   if (object instanceof Integer) {
    return GraphMLTokens.INT;
  }
 else   if (object instanceof Long) {
    return GraphMLTokens.LONG;
  }
 else   if (object instanceof Float) {
    return GraphMLTokens.FLOAT;
  }
 else   if (object instanceof Double) {
    return GraphMLTokens.DOUBLE;
  }
 else   if (object instanceof Boolean) {
    return GraphMLTokens.BOOLEAN;
  }
 else {
    return GraphMLTokens.STRING;
  }
}","public static String getStringType(final Object object){
  if (object instanceof String) {
    return GraphMLTokens.STRING;
  }
 else   if (object instanceof Integer) {
    return GraphMLTokens.INT;
  }
 else   if (object instanceof Long) {
    return GraphMLTokens.LONG;
  }
 else   if (object instanceof Float) {
    return GraphMLTokens.FLOAT;
  }
 else   if (object instanceof Double) {
    return GraphMLTokens.DOUBLE;
  }
 else   if (object instanceof Boolean) {
    return GraphMLTokens.BOOLEAN;
  }
 else   if (isArray(object)) {
    return object.getClass().getSimpleName();
  }
 else {
    return GraphMLTokens.STRING;
  }
}",0.9317607413647851
186099,"@Test @UsingDataSet(locations=""String_Node_Str"",loadStrategy=LoadStrategyEnum.CLEAN_INSERT) public void neo_node_should_be_returned(){
  MatrixManager matrixManager=new MatrixManager(graphDatabaseService);
  Node neo=matrixManager.getNeoNode();
  assertThat((String)neo.getProperty(""String_Node_Str""),is(""String_Node_Str""));
}","@Test public void neo_node_should_be_returned(){
  MatrixManager matrixManager=new MatrixManager(graphDatabaseService);
  Node neo=matrixManager.getNeoNode();
  assertThat((String)neo.getProperty(""String_Node_Str""),is(""String_Node_Str""));
}",0.8480565371024735
186100,"@Test @UsingDataSet(withSelectiveLocations={@Selective(identifier=""String_Node_Str"",locations=""String_Node_Str"")},loadStrategy=LoadStrategyEnum.CLEAN_INSERT) public void should_replicate_data_into_slave_node() throws InterruptedException {
  String theHobbitTitle=masterConnection.hget(""String_Node_Str"",""String_Node_Str"");
  assertThat(theHobbitTitle,is(""String_Node_Str""));
  TimeUnit.SECONDS.sleep(5);
  theHobbitTitle=slaveConnection.hget(""String_Node_Str"",""String_Node_Str"");
  assertThat(theHobbitTitle,is(""String_Node_Str""));
}","@Test @UsingDataSet(withSelectiveLocations={@Selective(identifier=""String_Node_Str"",locations=""String_Node_Str"")},loadStrategy=LoadStrategyEnum.CLEAN_INSERT) public void should_replicate_data_into_slave_node() throws InterruptedException {
  String theHobbitTitle=masterConnection.hget(""String_Node_Str"",""String_Node_Str"");
  assertThat(theHobbitTitle,is(""String_Node_Str""));
  TimeUnit.SECONDS.sleep(5);
  Jedis slaveConnection=new Jedis(""String_Node_Str"",6380);
  theHobbitTitle=slaveConnection.hget(""String_Node_Str"",""String_Node_Str"");
  assertThat(theHobbitTitle,is(""String_Node_Str""));
}",0.9476486246672582
186101,"public MongoOperation(MongoDbConfiguration mongoDbConfiguration){
  try {
    this.mongo=mongoDbConfiguration.getMongo();
    this.mongo.setWriteConcern(WriteConcern.SAFE);
    this.mongoDbConfiguration=mongoDbConfiguration;
    this.setInsertionStrategy(new DefaultInsertionStrategy());
    this.setComparisonStrategy(new DefaultComparisonStrategy());
  }
 catch (  MongoException e) {
    throw new IllegalArgumentException(e);
  }
}","public MongoOperation(MongoDbConfiguration mongoDbConfiguration){
  try {
    this.mongo=mongoDbConfiguration.getMongo();
    this.mongo.setWriteConcern(mongoDbConfiguration.getWriteConcern());
    this.mongoDbConfiguration=mongoDbConfiguration;
    this.setInsertionStrategy(new DefaultInsertionStrategy());
    this.setComparisonStrategy(new DefaultComparisonStrategy());
  }
 catch (  MongoException e) {
    throw new IllegalArgumentException(e);
  }
}",0.9652076318742986
186102,"public MongoDbConfiguration configure(){
  if (this.serverAddresses.isEmpty()) {
    addDefaultSeed();
  }
  MongoClient mongoClient=new MongoClient(this.serverAddresses);
  if (this.enableSharding) {
    enableSharding(mongoClient);
  }
  mongoClient.setWriteConcern(writeConcern);
  mongoDbConfiguration.setMongo(mongoClient);
  return mongoDbConfiguration;
}","public MongoDbConfiguration configure(){
  if (this.serverAddresses.isEmpty()) {
    addDefaultSeed();
  }
  MongoClient mongoClient=new MongoClient(this.serverAddresses);
  if (this.enableSharding) {
    enableSharding(mongoClient);
  }
  mongoDbConfiguration.setWriteConcern(writeConcern);
  mongoDbConfiguration.setMongo(mongoClient);
  return mongoDbConfiguration;
}",0.9712722298221614
186103,"@Test public void insert_opertation_should_add_indexes_into_remote_graph(){
  GraphDatabaseService newEmbeddedDatabase=new GraphDatabaseFactory().newEmbeddedDatabase(DB_PATH);
  WrappingNeoServerBootstrapper graphDb=new WrappingNeoServerBootstrapper((GraphDatabaseAPI)newEmbeddedDatabase);
  graphDb.start();
  RestGraphDatabase graphDatabaseService=new RestGraphDatabase(""String_Node_Str"");
  Neo4jConfiguration neo4jConfiguration=new Neo4jConfiguration();
  neo4jConfiguration.setGraphDatabaseService(graphDatabaseService);
  Neo4jOperation neo4jOperation=new Neo4jOperation(graphDatabaseService);
  neo4jOperation.insert(new ByteArrayInputStream(WELL_FORMED_GRAPH_WITH_MANUAL_INDEX.getBytes()));
  String[] nodeIndexNames=graphDatabaseService.index().nodeIndexNames();
  assertThat(nodeIndexNames,arrayContainingInAnyOrder(""String_Node_Str""));
  newEmbeddedDatabase.shutdown();
}","@Test public void insert_opertation_should_add_indexes_into_remote_graph(){
  GraphDatabaseService newEmbeddedDatabase=new GraphDatabaseFactory().newEmbeddedDatabase(DB_PATH);
  WrappingNeoServerBootstrapper graphDb=new WrappingNeoServerBootstrapper((GraphDatabaseAPI)newEmbeddedDatabase);
  graphDb.start();
  RestGraphDatabase graphDatabaseService=new RestGraphDatabase(""String_Node_Str"");
  Neo4jConfiguration neo4jConfiguration=new Neo4jConfiguration();
  neo4jConfiguration.setGraphDatabaseService(graphDatabaseService);
  Neo4jOperation neo4jOperation=new Neo4jOperation(graphDatabaseService);
  neo4jOperation.insert(new ByteArrayInputStream(WELL_FORMED_GRAPH_WITH_MANUAL_INDEX.getBytes()));
  String[] nodeIndexNames=graphDatabaseService.index().nodeIndexNames();
  assertThat(nodeIndexNames,arrayContainingInAnyOrder(""String_Node_Str""));
  neo4jOperation.deleteAll();
  graphDb.stop();
}",0.9640044994375704
186104,"@Test public void insert_opertation_should_add_data_and_indexes_into_graph(){
  GraphDatabaseService newEmbeddedDatabase=new GraphDatabaseFactory().newEmbeddedDatabase(DB_PATH);
  Neo4jConfiguration neo4jConfiguration=new Neo4jConfiguration();
  neo4jConfiguration.setGraphDatabaseService(newEmbeddedDatabase);
  Neo4jOperation neo4jOperation=new Neo4jOperation(newEmbeddedDatabase);
  neo4jOperation.insert(new ByteArrayInputStream(WELL_FORMED_GRAPH_WITH_MANUAL_INDEX.getBytes()));
  GlobalGraphOperations globalGraphOperations=GlobalGraphOperations.at(newEmbeddedDatabase);
  Iterable<Node> allNodes=globalGraphOperations.getAllNodes();
  Iterable<Relationship> allRelationships=globalGraphOperations.getAllRelationships();
  Node firstNode=selectFirst(allNodes,having(on(Node.class).getProperty(""String_Node_Str""),equalTo(""String_Node_Str"")));
  assertThat(firstNode,notNullValue());
  Node secondNode=selectFirst(allNodes,having(on(Node.class).getProperty(""String_Node_Str""),equalTo(""String_Node_Str"")));
  assertThat(secondNode,notNullValue());
  Node thirdNode=selectFirst(allNodes,having(on(Node.class).getProperty(""String_Node_Str""),equalTo(""String_Node_Str"")));
  assertThat(thirdNode,notNullValue());
  Relationship firstRelationship=selectFirst(allRelationships,having(on(Relationship.class).getProperty(""String_Node_Str""),equalTo(Float.parseFloat(""String_Node_Str""))));
  assertThat(firstRelationship,notNullValue());
  Relationship secondRelationship=selectFirst(allRelationships,having(on(Relationship.class).getProperty(""String_Node_Str""),equalTo(Float.parseFloat(""String_Node_Str""))));
  assertThat(secondRelationship,notNullValue());
  String[] nodeIndexNames=newEmbeddedDatabase.index().nodeIndexNames();
  assertThat(nodeIndexNames,arrayContainingInAnyOrder(""String_Node_Str""));
  newEmbeddedDatabase.shutdown();
}","@Test public void insert_opertation_should_add_data_and_indexes_into_graph(){
  GraphDatabaseService newEmbeddedDatabase=new GraphDatabaseFactory().newEmbeddedDatabase(DB_PATH);
  Neo4jConfiguration neo4jConfiguration=new Neo4jConfiguration();
  neo4jConfiguration.setGraphDatabaseService(newEmbeddedDatabase);
  Neo4jOperation neo4jOperation=new Neo4jOperation(newEmbeddedDatabase);
  neo4jOperation.insert(new ByteArrayInputStream(WELL_FORMED_GRAPH_WITH_MANUAL_INDEX.getBytes()));
  GlobalGraphOperations globalGraphOperations=GlobalGraphOperations.at(newEmbeddedDatabase);
  Iterable<Node> allNodes=globalGraphOperations.getAllNodes();
  Iterable<Relationship> allRelationships=globalGraphOperations.getAllRelationships();
  Node firstNode=selectFirst(allNodes,having(on(Node.class).getProperty(""String_Node_Str""),equalTo(""String_Node_Str"")));
  assertThat(firstNode,notNullValue());
  Node secondNode=selectFirst(allNodes,having(on(Node.class).getProperty(""String_Node_Str""),equalTo(""String_Node_Str"")));
  assertThat(secondNode,notNullValue());
  Node thirdNode=selectFirst(allNodes,having(on(Node.class).getProperty(""String_Node_Str""),equalTo(""String_Node_Str"")));
  assertThat(thirdNode,notNullValue());
  Relationship firstRelationship=selectFirst(allRelationships,having(on(Relationship.class).getProperty(""String_Node_Str""),equalTo(Float.parseFloat(""String_Node_Str""))));
  assertThat(firstRelationship,notNullValue());
  Relationship secondRelationship=selectFirst(allRelationships,having(on(Relationship.class).getProperty(""String_Node_Str""),equalTo(Float.parseFloat(""String_Node_Str""))));
  assertThat(secondRelationship,notNullValue());
  String[] nodeIndexNames=newEmbeddedDatabase.index().nodeIndexNames();
  assertThat(nodeIndexNames,arrayContainingInAnyOrder(""String_Node_Str""));
  neo4jOperation.deleteAll();
  newEmbeddedDatabase.shutdown();
}",0.9918831168831168
186105,"@Override public void run(){
  Process pwd;
  try {
    pwd=startProcess();
    consoleOutput=getConsoleOutput(pwd);
  }
 catch (  IOException e) {
    throw prepareException(e);
  }
 finally {
    processIsReady.countDown();
  }
  try {
    pwd.waitFor();
    if (pwd.exitValue() != 0) {
      throw new IllegalStateException(""String_Node_Str"" + mongodPath + DBPATH_ARGUMENT_NAME+ dbRelativePath+ PORT_ARGUMENT_NAME+ port+ LOGPATH_ARGUMENT_NAME+ logRelativePath+ ""String_Node_Str""+ consoleOutput);
    }
  }
 catch (  InterruptedException ie) {
    throw prepareException(ie);
  }
}","@Override public void run(){
  Process pwd;
  try {
    pwd=startProcess();
    consoleOutput=getConsoleOutput(pwd);
  }
 catch (  IOException e) {
    throw prepareException(e);
  }
 finally {
    processIsReady.countDown();
  }
  try {
    pwd.waitFor();
    if (pwd.exitValue() != 0) {
      LOGGER.info(""String_Node_Str"" + mongodPath + DBPATH_ARGUMENT_NAME+ dbRelativePath+ PORT_ARGUMENT_NAME+ port+ LOGPATH_ARGUMENT_NAME+ logRelativePath+ ""String_Node_Str""+ consoleOutput);
    }
  }
 catch (  InterruptedException ie) {
    throw prepareException(ie);
  }
}",0.9633507853403142
186106,"@Override public void doStart() throws Throwable {
  LOGGER.info(""String_Node_Str"",mongodPath);
  ready=true;
  File dbPath=ensureDbPathDoesNotExitsAndReturnCompositePath();
  if (dbPath.mkdirs()) {
    startMongoDBAsADaemon();
    boolean isServerUp=assertThatConnectionToMongoDbIsPossible(NUM_RETRIES_TO_CHECK_SERVER_UP);
    if (!isServerUp) {
      throw new IllegalStateException(""String_Node_Str"" + this.mongodPath + ""String_Node_Str""+ port);
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + dbPath + ""String_Node_Str"");
  }
  LOGGER.info(""String_Node_Str"",mongodPath);
}","@Override public void doStart() throws Throwable {
  LOGGER.info(""String_Node_Str"",mongodPath);
  ready=true;
  File dbPath=ensureDbPathDoesNotExitsAndReturnCompositePath();
  if (dbPath.mkdirs()) {
    startMongoDBAsADaemon();
    boolean isServerUp=assertThatConnectionToMongoDbIsPossible();
    if (!isServerUp) {
      throw new IllegalStateException(""String_Node_Str"" + this.mongodPath + ""String_Node_Str""+ port);
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + dbPath + ""String_Node_Str"");
  }
  LOGGER.info(""String_Node_Str"",mongodPath);
}",0.9744463373083476
186107,"private boolean assertThatConnectionToMongoDbIsPossible(int retries) throws InterruptedException, UnknownHostException {
  return this.mongoDbLowLevelOps.assertThatConnectionIsPossible(LOCALHOST,port,retries);
}","private boolean assertThatConnectionToMongoDbIsPossible() throws InterruptedException, UnknownHostException {
  return this.mongoDbLowLevelOps.assertThatConnectionIsPossible(LOCALHOST,port);
}",0.9528535980148884
186108,"public boolean assertThatConnectionIsPossible(String host,int port,int retries) throws InterruptedException, UnknownHostException, MongoException {
  int currentRetry=0;
  boolean connectionIsPossible=false;
  Mongo server=null;
  try {
    do {
      TimeUnit.SECONDS.sleep(3);
      server=new Mongo(host,port);
      DB db=server.getDB(""String_Node_Str"");
      try {
        db.getStats();
        connectionIsPossible=true;
      }
 catch (      MongoException e) {
        currentRetry++;
      }
    }
 while (!connectionIsPossible && currentRetry <= retries);
  }
  finally {
    server.close();
  }
  return connectionIsPossible;
}","public boolean assertThatConnectionIsPossible(String host,int port) throws InterruptedException, UnknownHostException, MongoException {
  int currentRetry=0;
  boolean connectionIsPossible=false;
  Mongo server=null;
  try {
    do {
      TimeUnit.SECONDS.sleep(WAIT_TIME);
      server=new Mongo(host,port);
      DB db=server.getDB(""String_Node_Str"");
      try {
        db.getStats();
        connectionIsPossible=true;
      }
 catch (      MongoException e) {
        currentRetry++;
      }
    }
 while (!connectionIsPossible && currentRetry <= MAX_RETRIES);
  }
  finally {
    server.close();
  }
  return connectionIsPossible;
}",0.96875
186109,"@Test public void mongodb_should_start_mongodb_instance_in_Linux() throws Throwable {
  MongoDbLowLevelOps mongoDbChecker=mock(MongoDbLowLevelOps.class);
  when(mongoDbChecker.assertThatConnectionIsPossible(anyString(),anyInt(),anyInt())).thenReturn(true);
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.LINUX_OS);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  when(commandLineExecutor.getConsoleOutput(mockProcess)).thenReturn(Collections.<String>emptyList());
  File targetPath=temporaryFolder.newFolder();
  ManagedMongoDb managedMongoDb=newManagedMongoDbRule().targetPath(targetPath.toString()).mongodPath(MONGODB_LOCATION).appendCommandLineArguments(""String_Node_Str"",""String_Node_Str"").build();
  managedMongoDb.managedMongoDbLifecycleManager.setCommandLineExecutor(commandLineExecutor);
  managedMongoDb.managedMongoDbLifecycleManager.setOperatingSystemResolver(operatingSystemResolver);
  managedMongoDb.managedMongoDbLifecycleManager.setMongoDbLowLevelOps(mongoDbChecker);
  managedMongoDb.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(MONGODB_LOCATION + File.separatorChar + ManagedMongoDbLifecycleManager.MONGODB_BINARY_DIRECTORY+ File.separatorChar+ ManagedMongoDbLifecycleManager.MONGODB_EXECUTABLE_X);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DBPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_DBPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.PORT_ARGUMENT_NAME);
  expectedCommand.add(DBPort.PORT + ""String_Node_Str"");
  expectedCommand.add(ManagedMongoDbLifecycleManager.LOGPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_LOGPATH);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(""String_Node_Str"");
  managedMongoDb.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(targetPath.toString(),expectedCommand);
}","@Test public void mongodb_should_start_mongodb_instance_in_Linux() throws Throwable {
  MongoDbLowLevelOps mongoDbChecker=mock(MongoDbLowLevelOps.class);
  when(mongoDbChecker.assertThatConnectionIsPossible(anyString(),anyInt())).thenReturn(true);
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.LINUX_OS);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  when(commandLineExecutor.getConsoleOutput(mockProcess)).thenReturn(Collections.<String>emptyList());
  File targetPath=temporaryFolder.newFolder();
  ManagedMongoDb managedMongoDb=newManagedMongoDbRule().targetPath(targetPath.toString()).mongodPath(MONGODB_LOCATION).appendCommandLineArguments(""String_Node_Str"",""String_Node_Str"").build();
  managedMongoDb.managedMongoDbLifecycleManager.setCommandLineExecutor(commandLineExecutor);
  managedMongoDb.managedMongoDbLifecycleManager.setOperatingSystemResolver(operatingSystemResolver);
  managedMongoDb.managedMongoDbLifecycleManager.setMongoDbLowLevelOps(mongoDbChecker);
  managedMongoDb.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(MONGODB_LOCATION + File.separatorChar + ManagedMongoDbLifecycleManager.MONGODB_BINARY_DIRECTORY+ File.separatorChar+ ManagedMongoDbLifecycleManager.MONGODB_EXECUTABLE_X);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DBPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_DBPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.PORT_ARGUMENT_NAME);
  expectedCommand.add(DBPort.PORT + ""String_Node_Str"");
  expectedCommand.add(ManagedMongoDbLifecycleManager.LOGPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_LOGPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.NONE_JOURNALING_ENABLED);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(""String_Node_Str"");
  managedMongoDb.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(targetPath.toString(),expectedCommand);
}",0.98014440433213
186110,"@Test public void mongodb_should_start_mongodb_instance_in_Windows() throws Throwable {
  MongoDbLowLevelOps mongoDbChecker=mock(MongoDbLowLevelOps.class);
  when(mongoDbChecker.assertThatConnectionIsPossible(anyString(),anyInt(),anyInt())).thenReturn(true);
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.WINDOWS_7);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  when(commandLineExecutor.getConsoleOutput(mockProcess)).thenReturn(Collections.<String>emptyList());
  File targetPath=temporaryFolder.newFolder();
  ManagedMongoDb managedMongoDb=newManagedMongoDbRule().targetPath(targetPath.toString()).mongodPath(MONGODB_LOCATION).appendCommandLineArguments(""String_Node_Str"",""String_Node_Str"").build();
  managedMongoDb.managedMongoDbLifecycleManager.setCommandLineExecutor(commandLineExecutor);
  managedMongoDb.managedMongoDbLifecycleManager.setOperatingSystemResolver(operatingSystemResolver);
  managedMongoDb.managedMongoDbLifecycleManager.setMongoDbLowLevelOps(mongoDbChecker);
  managedMongoDb.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(MONGODB_LOCATION + File.separatorChar + ManagedMongoDbLifecycleManager.MONGODB_BINARY_DIRECTORY+ File.separatorChar+ ManagedMongoDbLifecycleManager.MONGODB_EXECUTABLE_W);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DBPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_DBPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.PORT_ARGUMENT_NAME);
  expectedCommand.add(DBPort.PORT + ""String_Node_Str"");
  expectedCommand.add(ManagedMongoDbLifecycleManager.LOGPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_LOGPATH);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(""String_Node_Str"");
  managedMongoDb.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(targetPath.toString(),expectedCommand);
}","@Test public void mongodb_should_start_mongodb_instance_in_Windows() throws Throwable {
  MongoDbLowLevelOps mongoDbChecker=mock(MongoDbLowLevelOps.class);
  when(mongoDbChecker.assertThatConnectionIsPossible(anyString(),anyInt())).thenReturn(true);
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.WINDOWS_7);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  when(commandLineExecutor.getConsoleOutput(mockProcess)).thenReturn(Collections.<String>emptyList());
  File targetPath=temporaryFolder.newFolder();
  ManagedMongoDb managedMongoDb=newManagedMongoDbRule().targetPath(targetPath.toString()).mongodPath(MONGODB_LOCATION).appendCommandLineArguments(""String_Node_Str"",""String_Node_Str"").build();
  managedMongoDb.managedMongoDbLifecycleManager.setCommandLineExecutor(commandLineExecutor);
  managedMongoDb.managedMongoDbLifecycleManager.setOperatingSystemResolver(operatingSystemResolver);
  managedMongoDb.managedMongoDbLifecycleManager.setMongoDbLowLevelOps(mongoDbChecker);
  managedMongoDb.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(MONGODB_LOCATION + File.separatorChar + ManagedMongoDbLifecycleManager.MONGODB_BINARY_DIRECTORY+ File.separatorChar+ ManagedMongoDbLifecycleManager.MONGODB_EXECUTABLE_W);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DBPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_DBPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.PORT_ARGUMENT_NAME);
  expectedCommand.add(DBPort.PORT + ""String_Node_Str"");
  expectedCommand.add(ManagedMongoDbLifecycleManager.LOGPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_LOGPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.NONE_JOURNALING_ENABLED);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(""String_Node_Str"");
  managedMongoDb.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(targetPath.toString(),expectedCommand);
}",0.9801712483100496
186111,"@Test public void mongodb_should_start_mongodb_instance_in_Mac() throws Throwable {
  MongoDbLowLevelOps mongoDbChecker=mock(MongoDbLowLevelOps.class);
  when(mongoDbChecker.assertThatConnectionIsPossible(anyString(),anyInt(),anyInt())).thenReturn(true);
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.MAC_OSX);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  when(commandLineExecutor.getConsoleOutput(mockProcess)).thenReturn(Collections.<String>emptyList());
  File targetPath=temporaryFolder.newFolder();
  ManagedMongoDb managedMongoDb=newManagedMongoDbRule().targetPath(targetPath.toString()).mongodPath(MONGODB_LOCATION).appendCommandLineArguments(""String_Node_Str"",""String_Node_Str"").build();
  managedMongoDb.managedMongoDbLifecycleManager.setCommandLineExecutor(commandLineExecutor);
  managedMongoDb.managedMongoDbLifecycleManager.setOperatingSystemResolver(operatingSystemResolver);
  managedMongoDb.managedMongoDbLifecycleManager.setMongoDbLowLevelOps(mongoDbChecker);
  managedMongoDb.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(MONGODB_LOCATION + File.separatorChar + ManagedMongoDbLifecycleManager.MONGODB_BINARY_DIRECTORY+ File.separatorChar+ ManagedMongoDbLifecycleManager.MONGODB_EXECUTABLE_X);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DBPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_DBPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.PORT_ARGUMENT_NAME);
  expectedCommand.add(DBPort.PORT + ""String_Node_Str"");
  expectedCommand.add(ManagedMongoDbLifecycleManager.LOGPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_LOGPATH);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(""String_Node_Str"");
  managedMongoDb.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(targetPath.toString(),expectedCommand);
}","@Test public void mongodb_should_start_mongodb_instance_in_Mac() throws Throwable {
  MongoDbLowLevelOps mongoDbChecker=mock(MongoDbLowLevelOps.class);
  when(mongoDbChecker.assertThatConnectionIsPossible(anyString(),anyInt())).thenReturn(true);
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.MAC_OSX);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  when(commandLineExecutor.getConsoleOutput(mockProcess)).thenReturn(Collections.<String>emptyList());
  File targetPath=temporaryFolder.newFolder();
  ManagedMongoDb managedMongoDb=newManagedMongoDbRule().targetPath(targetPath.toString()).mongodPath(MONGODB_LOCATION).appendCommandLineArguments(""String_Node_Str"",""String_Node_Str"").build();
  managedMongoDb.managedMongoDbLifecycleManager.setCommandLineExecutor(commandLineExecutor);
  managedMongoDb.managedMongoDbLifecycleManager.setOperatingSystemResolver(operatingSystemResolver);
  managedMongoDb.managedMongoDbLifecycleManager.setMongoDbLowLevelOps(mongoDbChecker);
  managedMongoDb.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(MONGODB_LOCATION + File.separatorChar + ManagedMongoDbLifecycleManager.MONGODB_BINARY_DIRECTORY+ File.separatorChar+ ManagedMongoDbLifecycleManager.MONGODB_EXECUTABLE_X);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DBPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_DBPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.PORT_ARGUMENT_NAME);
  expectedCommand.add(DBPort.PORT + ""String_Node_Str"");
  expectedCommand.add(ManagedMongoDbLifecycleManager.LOGPATH_ARGUMENT_NAME);
  expectedCommand.add(ManagedMongoDbLifecycleManager.DEFAULT_MONGO_LOGPATH);
  expectedCommand.add(ManagedMongoDbLifecycleManager.NONE_JOURNALING_ENABLED);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(""String_Node_Str"");
  managedMongoDb.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(targetPath.toString(),expectedCommand);
}",0.9801174875734298
186112,"@Override public void insert(InputStream dataScript){
  InputStreamJsonDataSet dataSet=new InputStreamJsonDataSet(dataScript);
  DataLoader dataLoader=new DataLoader(cassandraConfiguration.getClusterName(),getFullHost());
  dataLoader.load(dataSet);
  keyspace=HFactory.createKeyspace(dataSet.getKeyspace().getName(),cluster);
}","@Override public void insert(InputStream dataScript){
  if (this.insertationStrategy instanceof CassandraInsertationStrategy) {
    insertData(dataScript);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.2357142857142857
186113,"public CassandraOperation(CassandraConfiguration cassandraConfiguration){
  this.cassandraConfiguration=cassandraConfiguration;
  cluster=HFactory.getOrCreateCluster(cassandraConfiguration.getClusterName(),getFullHost());
}","public CassandraOperation(CassandraConfiguration cassandraConfiguration){
  this.cassandraConfiguration=cassandraConfiguration;
  cluster=HFactory.getOrCreateCluster(cassandraConfiguration.getClusterName(),getFullHost());
  setInsertationStrategy(new DefaultCassandraInsertationStrategy());
  setComparisionStrategy(new DefaultCassandraComparisionStrategy());
}",0.7636986301369864
186114,"@Override public boolean databaseIs(InputStream expectedData){
  CassandraAssertion.strictAssertEquals(new InputStreamJsonDataSet(expectedData),cluster,keyspace);
  return true;
}","@Override public boolean databaseIs(InputStream expectedData){
  return compareData(expectedData);
}",0.6379928315412187
186115,"@Override public Statement apply(final Statement base,final FrameworkMethod method,final Object testObject){
  return new Statement(){
    @Override public void evaluate() throws Throwable {
      target=testObject;
      defaultDataSetLocationResolver=new DefaultDataSetLocationResolver(testObject.getClass());
      UsingDataSet usingDataSet=getUsingDataSetAnnotation();
      if (isTestAnnotatedWithDataSet(usingDataSet)) {
        loadDataSet(usingDataSet,method);
      }
      injectAnnotationProcessor.processInjectAnnotation(testObject.getClass(),target,getDatabaseOperation().connectionManager());
      base.evaluate();
      ShouldMatchDataSet shouldMatchDataSet=getShouldMatchDataSetAnnotation();
      if (isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        assertExpectation(shouldMatchDataSet);
      }
    }
    private ShouldMatchDataSet getShouldMatchDataSetAnnotation(){
      ShouldMatchDataSet shouldMatchDataSet=method.getAnnotation(ShouldMatchDataSet.class);
      if (!isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        Class<?> testClass=target.getClass();
        shouldMatchDataSet=testClass.getAnnotation(ShouldMatchDataSet.class);
      }
      return shouldMatchDataSet;
    }
    private UsingDataSet getUsingDataSetAnnotation(){
      UsingDataSet usingDataSet=method.getAnnotation(UsingDataSet.class);
      if (!isTestAnnotatedWithDataSet(usingDataSet)) {
        Class<?> testClass=target.getClass();
        usingDataSet=testClass.getAnnotation(UsingDataSet.class);
      }
      return usingDataSet;
    }
    private void assertExpectation(    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=loadExpectedContentScript(method,shouldMatchDataSet);
      if (isNotEmptyStream(scriptContent)) {
        getDatabaseOperation().databaseIs(scriptContent);
      }
 else {
        final String suffix=EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension();
        final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
        final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
      }
    }
    private InputStream loadExpectedContentScript(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      String location=shouldMatchDataSet.location();
      InputStream scriptContent=null;
      if (isNotEmptyString(location)) {
        scriptContent=loadExpectedResultFromLocationAttribute(location);
      }
 else {
        SelectiveMatcher[] selectiveMatchers=shouldMatchDataSet.withSelectiveMatcher();
        SelectiveMatcher requiredSelectiveMatcher=findSelectiveMatcherByConnectionIdentifier(selectiveMatchers);
        if (isSelectiveMatchersDefined(requiredSelectiveMatcher)) {
          scriptContent=loadExpectedResultFromLocationAttribute(requiredSelectiveMatcher.location());
        }
 else {
          scriptContent=loadExpectedResultFromDefaultLocation(method,shouldMatchDataSet);
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveMatchersDefined(    SelectiveMatcher requiredSelectiveMatcher){
      return requiredSelectiveMatcher != null;
    }
    private SelectiveMatcher findSelectiveMatcherByConnectionIdentifier(    SelectiveMatcher[] selectiveMatchers){
      return selectFirst(selectiveMatchers,having(on(SelectiveMatcher.class).identifier(),equalTo(identifier)).and(having(on(SelectiveMatcher.class).location(),notNullValue())));
    }
    private InputStream loadExpectedResultFromDefaultLocation(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=null;
      String defaultLocation=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(shouldMatchDataSet,method,EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension());
      if (defaultLocation != null) {
        scriptContent=loadExpectedResultFromLocationAttribute(defaultLocation);
      }
      return scriptContent;
    }
    private InputStream loadExpectedResultFromLocationAttribute(    String location) throws IOException {
      InputStream scriptContent;
      scriptContent=IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location);
      return scriptContent;
    }
    private void loadDataSet(    UsingDataSet usingDataSet,    FrameworkMethod method) throws IOException {
      List<InputStream> scriptContent=loadDatasets(usingDataSet,method);
      LoadStrategyEnum loadStrategyEnum=usingDataSet.loadStrategy();
      if (areDatasetsRequired(loadStrategyEnum) && emptyDataset(scriptContent) && notSelectiveAnnotation(usingDataSet.withSelectiveLocations())) {
        final String suffix=""String_Node_Str"" + getWorkingExtension();
        final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
        final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
        throw new IllegalArgumentException(""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
      }
      LoadStrategyOperation loadStrategyOperation=loadStrategyFactory.getLoadStrategyInstance(loadStrategyEnum,getDatabaseOperation());
      loadStrategyOperation.executeScripts(scriptContent.toArray(new InputStream[scriptContent.size()]));
    }
    private boolean notSelectiveAnnotation(    Selective[] withSelectiveLocations){
      return withSelectiveLocations.length == 0;
    }
    private boolean emptyDataset(    List<InputStream> scriptContent){
      return scriptContent.size() == 0;
    }
    private boolean areDatasetsRequired(    LoadStrategyEnum loadStrategyEnum){
      return LoadStrategyEnum.DELETE_ALL != loadStrategyEnum;
    }
    private List<InputStream> loadDatasets(    UsingDataSet usingDataSet,    FrameworkMethod method) throws IOException {
      String[] locations=usingDataSet.locations();
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      scriptContent.addAll(loadGlobalDataSets(usingDataSet,method,locations));
      scriptContent.addAll(loadSelectiveDataSets(usingDataSet));
      return scriptContent;
    }
    private List<InputStream> loadSelectiveDataSets(    UsingDataSet usingDataSet) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isSelectiveLocationsAttributeSpecified(usingDataSet)) {
        Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
        if (selectiveLocations != null && selectiveLocations.length > 0) {
          for (          Selective selective : selectiveLocations) {
            if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
              scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),selective.locations()));
            }
          }
        }
      }
      return scriptContent;
    }
    private List<InputStream> loadGlobalDataSets(    UsingDataSet usingDataSet,    FrameworkMethod method,    String[] locations) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isLocationsAttributeSpecified(locations)) {
        scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),locations));
      }
 else {
        String location=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(usingDataSet,method,""String_Node_Str"" + getWorkingExtension());
        if (location != null) {
          scriptContent.add(IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location));
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveLocationsAttributeSpecified(    UsingDataSet usingDataSet){
      Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
      if (selectiveLocations != null && selectiveLocations.length > 0) {
        for (        Selective selective : selectiveLocations) {
          if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
            return true;
          }
        }
      }
      return false;
    }
    private boolean isNotEmptyStream(    InputStream inputStream){
      return inputStream != null;
    }
    private boolean isNotEmptyString(    String location){
      return location != null && !""String_Node_Str"".equals(location.trim());
    }
    private boolean isLocationsAttributeSpecified(    String[] locations){
      return locations != null && locations.length > 0;
    }
    private boolean isTestAnnotatedWithExpectedDataSet(    ShouldMatchDataSet shouldMatchDataSet){
      return shouldMatchDataSet != null;
    }
    private boolean isTestAnnotatedWithDataSet(    UsingDataSet usingDataSet){
      return usingDataSet != null;
    }
  }
;
}","@Override public Statement apply(final Statement base,final FrameworkMethod method,final Object testObject){
  return new Statement(){
    @Override public void evaluate() throws Throwable {
      target=testObject;
      defaultDataSetLocationResolver=new DefaultDataSetLocationResolver(testObject.getClass());
      UsingDataSet usingDataSet=getUsingDataSetAnnotation();
      if (isTestAnnotatedWithDataSet(usingDataSet)) {
        createCustomInsertationStrategyIfPresent();
        loadDataSet(usingDataSet,method);
      }
      injectAnnotationProcessor.processInjectAnnotation(testObject.getClass(),target,getDatabaseOperation().connectionManager());
      base.evaluate();
      ShouldMatchDataSet shouldMatchDataSet=getShouldMatchDataSetAnnotation();
      if (isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        createCustomComparisionStrategyIfPresent();
        assertExpectation(shouldMatchDataSet);
      }
    }
    private void createCustomComparisionStrategyIfPresent(){
      CustomComparisionStrategy customComparisionStrategy=getCustomComparisionStrategy();
      if (isTestAnnotatedWithCustomComparisionStrategy(customComparisionStrategy)) {
        DatabaseOperation<?> databaseOperation=getDatabaseOperation();
        if (isDatabaseOperationCustomizable(databaseOperation)) {
          Class<? extends ComparisionStrategy<?>> comparisionStrategy=customComparisionStrategy.comparisionStrategy();
          ComparisionStrategy<?> comparisionStrategyObject=org.joor.Reflect.on(comparisionStrategy).create().get();
          overrideComparisionStrategy(databaseOperation,comparisionStrategyObject);
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
    }
    private void createCustomInsertationStrategyIfPresent(){
      CustomInsertationStrategy customInsertationStrategy=getCustomInsertationStrategy();
      if (isTestAnnotatedWithCustomInsertationStrategy(customInsertationStrategy)) {
        DatabaseOperation<?> databaseOperation=getDatabaseOperation();
        if (isDatabaseOperationCustomizable(databaseOperation)) {
          Class<? extends InsertationStrategy<?>> insertationStrategy=customInsertationStrategy.insertationStrategy();
          InsertationStrategy<?> insertationStrategyObject=org.joor.Reflect.on(insertationStrategy).create().get();
          overrideInsertationStrategy(databaseOperation,insertationStrategyObject);
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
    }
    private void overrideComparisionStrategy(    DatabaseOperation<?> databaseOperation,    ComparisionStrategy<?> comparisionStrategyObject){
      AbstractCustomizableDatabaseOperation customizableDatabaseOperation=(AbstractCustomizableDatabaseOperation)databaseOperation;
      customizableDatabaseOperation.setComparisionStrategy(comparisionStrategyObject);
    }
    private void overrideInsertationStrategy(    DatabaseOperation<?> databaseOperation,    InsertationStrategy<?> insertationStrategyObject){
      AbstractCustomizableDatabaseOperation customizableDatabaseOperation=(AbstractCustomizableDatabaseOperation)databaseOperation;
      customizableDatabaseOperation.setInsertationStrategy(insertationStrategyObject);
    }
    private boolean isDatabaseOperationCustomizable(    DatabaseOperation databaseOperation){
      return databaseOperation instanceof AbstractCustomizableDatabaseOperation;
    }
    private ShouldMatchDataSet getShouldMatchDataSetAnnotation(){
      ShouldMatchDataSet shouldMatchDataSet=method.getAnnotation(ShouldMatchDataSet.class);
      if (!isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        Class<?> testClass=target.getClass();
        shouldMatchDataSet=testClass.getAnnotation(ShouldMatchDataSet.class);
      }
      return shouldMatchDataSet;
    }
    private UsingDataSet getUsingDataSetAnnotation(){
      UsingDataSet usingDataSet=method.getAnnotation(UsingDataSet.class);
      if (!isTestAnnotatedWithDataSet(usingDataSet)) {
        Class<?> testClass=target.getClass();
        usingDataSet=testClass.getAnnotation(UsingDataSet.class);
      }
      return usingDataSet;
    }
    private CustomComparisionStrategy getCustomComparisionStrategy(){
      Class<?> testClass=target.getClass();
      return testClass.getAnnotation(com.lordofthejars.nosqlunit.annotation.CustomComparisionStrategy.class);
    }
    private com.lordofthejars.nosqlunit.annotation.CustomInsertationStrategy getCustomInsertationStrategy(){
      Class<?> testClass=target.getClass();
      return testClass.getAnnotation(com.lordofthejars.nosqlunit.annotation.CustomInsertationStrategy.class);
    }
    private void assertExpectation(    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=loadExpectedContentScript(method,shouldMatchDataSet);
      if (isNotEmptyStream(scriptContent)) {
        getDatabaseOperation().databaseIs(scriptContent);
      }
 else {
        final String suffix=EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension();
        final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
        final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
      }
    }
    private InputStream loadExpectedContentScript(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      String location=shouldMatchDataSet.location();
      InputStream scriptContent=null;
      if (isNotEmptyString(location)) {
        scriptContent=loadExpectedResultFromLocationAttribute(location);
      }
 else {
        SelectiveMatcher[] selectiveMatchers=shouldMatchDataSet.withSelectiveMatcher();
        SelectiveMatcher requiredSelectiveMatcher=findSelectiveMatcherByConnectionIdentifier(selectiveMatchers);
        if (isSelectiveMatchersDefined(requiredSelectiveMatcher)) {
          scriptContent=loadExpectedResultFromLocationAttribute(requiredSelectiveMatcher.location());
        }
 else {
          scriptContent=loadExpectedResultFromDefaultLocation(method,shouldMatchDataSet);
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveMatchersDefined(    SelectiveMatcher requiredSelectiveMatcher){
      return requiredSelectiveMatcher != null;
    }
    private SelectiveMatcher findSelectiveMatcherByConnectionIdentifier(    SelectiveMatcher[] selectiveMatchers){
      return selectFirst(selectiveMatchers,having(on(SelectiveMatcher.class).identifier(),equalTo(identifier)).and(having(on(SelectiveMatcher.class).location(),notNullValue())));
    }
    private InputStream loadExpectedResultFromDefaultLocation(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=null;
      String defaultLocation=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(shouldMatchDataSet,method,EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension());
      if (defaultLocation != null) {
        scriptContent=loadExpectedResultFromLocationAttribute(defaultLocation);
      }
      return scriptContent;
    }
    private InputStream loadExpectedResultFromLocationAttribute(    String location) throws IOException {
      InputStream scriptContent;
      scriptContent=IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location);
      return scriptContent;
    }
    private void loadDataSet(    UsingDataSet usingDataSet,    FrameworkMethod method) throws IOException {
      List<InputStream> scriptContent=loadDatasets(usingDataSet,method);
      LoadStrategyEnum loadStrategyEnum=usingDataSet.loadStrategy();
      if (areDatasetsRequired(loadStrategyEnum) && emptyDataset(scriptContent) && notSelectiveAnnotation(usingDataSet.withSelectiveLocations())) {
        final String suffix=""String_Node_Str"" + getWorkingExtension();
        final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
        final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
        throw new IllegalArgumentException(""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
      }
      LoadStrategyOperation loadStrategyOperation=loadStrategyFactory.getLoadStrategyInstance(loadStrategyEnum,getDatabaseOperation());
      loadStrategyOperation.executeScripts(scriptContent.toArray(new InputStream[scriptContent.size()]));
    }
    private boolean notSelectiveAnnotation(    Selective[] withSelectiveLocations){
      return withSelectiveLocations.length == 0;
    }
    private boolean emptyDataset(    List<InputStream> scriptContent){
      return scriptContent.size() == 0;
    }
    private boolean areDatasetsRequired(    LoadStrategyEnum loadStrategyEnum){
      return LoadStrategyEnum.DELETE_ALL != loadStrategyEnum;
    }
    private List<InputStream> loadDatasets(    UsingDataSet usingDataSet,    FrameworkMethod method) throws IOException {
      String[] locations=usingDataSet.locations();
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      scriptContent.addAll(loadGlobalDataSets(usingDataSet,method,locations));
      scriptContent.addAll(loadSelectiveDataSets(usingDataSet));
      return scriptContent;
    }
    private List<InputStream> loadSelectiveDataSets(    UsingDataSet usingDataSet) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isSelectiveLocationsAttributeSpecified(usingDataSet)) {
        Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
        if (selectiveLocations != null && selectiveLocations.length > 0) {
          for (          Selective selective : selectiveLocations) {
            if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
              scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),selective.locations()));
            }
          }
        }
      }
      return scriptContent;
    }
    private List<InputStream> loadGlobalDataSets(    UsingDataSet usingDataSet,    FrameworkMethod method,    String[] locations) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isLocationsAttributeSpecified(locations)) {
        scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),locations));
      }
 else {
        String location=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(usingDataSet,method,""String_Node_Str"" + getWorkingExtension());
        if (location != null) {
          scriptContent.add(IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location));
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveLocationsAttributeSpecified(    UsingDataSet usingDataSet){
      Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
      if (selectiveLocations != null && selectiveLocations.length > 0) {
        for (        Selective selective : selectiveLocations) {
          if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
            return true;
          }
        }
      }
      return false;
    }
    private boolean isNotEmptyStream(    InputStream inputStream){
      return inputStream != null;
    }
    private boolean isNotEmptyString(    String location){
      return location != null && !""String_Node_Str"".equals(location.trim());
    }
    private boolean isLocationsAttributeSpecified(    String[] locations){
      return locations != null && locations.length > 0;
    }
    private boolean isTestAnnotatedWithCustomComparisionStrategy(    CustomComparisionStrategy customComparisionStrategy){
      return customComparisionStrategy != null;
    }
    private boolean isTestAnnotatedWithCustomInsertationStrategy(    CustomInsertationStrategy customInsertationStrategy){
      return customInsertationStrategy != null;
    }
    private boolean isTestAnnotatedWithExpectedDataSet(    ShouldMatchDataSet shouldMatchDataSet){
      return shouldMatchDataSet != null;
    }
    private boolean isTestAnnotatedWithDataSet(    UsingDataSet usingDataSet){
      return usingDataSet != null;
    }
  }
;
}",0.7880950230331497
186116,"@Override public void evaluate() throws Throwable {
  target=testObject;
  defaultDataSetLocationResolver=new DefaultDataSetLocationResolver(testObject.getClass());
  UsingDataSet usingDataSet=getUsingDataSetAnnotation();
  if (isTestAnnotatedWithDataSet(usingDataSet)) {
    loadDataSet(usingDataSet,method);
  }
  injectAnnotationProcessor.processInjectAnnotation(testObject.getClass(),target,getDatabaseOperation().connectionManager());
  base.evaluate();
  ShouldMatchDataSet shouldMatchDataSet=getShouldMatchDataSetAnnotation();
  if (isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
    assertExpectation(shouldMatchDataSet);
  }
}","@Override public void evaluate() throws Throwable {
  target=testObject;
  defaultDataSetLocationResolver=new DefaultDataSetLocationResolver(testObject.getClass());
  UsingDataSet usingDataSet=getUsingDataSetAnnotation();
  if (isTestAnnotatedWithDataSet(usingDataSet)) {
    createCustomInsertationStrategyIfPresent();
    loadDataSet(usingDataSet,method);
  }
  injectAnnotationProcessor.processInjectAnnotation(testObject.getClass(),target,getDatabaseOperation().connectionManager());
  base.evaluate();
  ShouldMatchDataSet shouldMatchDataSet=getShouldMatchDataSetAnnotation();
  if (isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
    createCustomComparisionStrategyIfPresent();
    assertExpectation(shouldMatchDataSet);
  }
}",0.930835734870317
186117,"public List<Book> findAll(){
  LOGGER.debug(""String_Node_Str"" + booksCollection.getName());
  List<Book> books=new ArrayList<Book>();
  DBCursor findAll=booksCollection.find();
  LOGGER.debug(""String_Node_Str"" + findAll.count());
  while (findAll.hasNext()) {
    books.add(DB_OBJECT_BOOK_CONVERTER.convert(findAll.next()));
  }
  return books;
}","public List<Book> findAll(){
  LOGGER.debug(""String_Node_Str"" + booksCollection.getName());
  List<Book> books=new ArrayList<Book>();
  DBCursor findAll=booksCollection.find();
  while (findAll.hasNext()) {
    books.add(DB_OBJECT_BOOK_CONVERTER.convert(findAll.next()));
  }
  return books;
}",0.917057902973396
186118,"@Test @UsingDataSet(locations=""String_Node_Str"",loadStrategy=LoadStrategyEnum.CLEAN_INSERT) public void manager_should_return_all_inserted_books(){
  BookManager bookManager=new BookManager(MongoDbUtil.getCollection(Book.class.getSimpleName()));
  List<Book> books=bookManager.findAll();
  Book expectedBook=new Book(""String_Node_Str"",293);
  assertThat(books,hasSize(1));
  assertThat(expectedBook,isIn(books));
}","@Test @UsingDataSet(locations=""String_Node_Str"",loadStrategy=LoadStrategyEnum.CLEAN_INSERT) public void manager_should_return_all_inserted_books(){
  BookManager bookManager=new BookManager(bookCollection());
  List<Book> books=bookManager.findAll();
  Book expectedBook=new Book(""String_Node_Str"",293);
  assertThat(books,hasSize(1));
  assertThat(expectedBook,isIn(books));
}",0.943109987357775
186119,"@Test @UsingDataSet(loadStrategy=LoadStrategyEnum.DELETE_ALL) public void manager_should_return_empty_list_when_no_books(){
  BookManager bookManager=new BookManager(MongoDbUtil.getCollection(Book.class.getSimpleName()));
  List<Book> books=bookManager.findAll();
  assertThat(books,hasSize(0));
}","@Test @UsingDataSet(loadStrategy=LoadStrategyEnum.DELETE_ALL) public void manager_should_return_empty_list_when_no_books(){
  BookManager bookManager=new BookManager(bookCollection());
  List<Book> books=bookManager.findAll();
  assertThat(books,hasSize(0));
}",0.919210053859964
186120,"private Object readValue(JsonNode element) throws IOException, JsonParseException, JsonMappingException, ClassNotFoundException {
  Object readObject=null;
  JsonNode value=valueNode(element);
  String implementationValue=implementationClass(element);
  if (value.isArray()) {
    readObject=readArray(value,implementationValue);
  }
 else {
    readObject=readObject(value,implementationValue);
  }
  return readObject;
}","private Object readValue(JsonNode element) throws IOException, JsonParseException, JsonMappingException, ClassNotFoundException {
  JsonNode value=valueNode(element);
  String implementationValue=implementationClass(element);
  Object readObject=readElement(value,implementationValue);
  return readObject;
}",0.4767123287671233
186121,"private String keyValue(JsonNode element){
  String keyValue=""String_Node_Str"";
  if (element.has(KeyValueTokens.KEY_TOKEN)) {
    keyValue=element.path(KeyValueTokens.KEY_TOKEN).getTextValue();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + KeyValueTokens.KEY_TOKEN + ""String_Node_Str"");
  }
  return keyValue;
}","private Object keyValue(JsonNode element) throws JsonParseException, JsonMappingException, IOException, ClassNotFoundException {
  Object keyValue;
  if (element.has(KeyValueTokens.KEY_TOKEN)) {
    String implementationKey=implementationKeyClass(element);
    keyValue=readElement(element.path(KeyValueTokens.KEY_TOKEN),implementationKey);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + KeyValueTokens.KEY_TOKEN + ""String_Node_Str"");
  }
  return keyValue;
}",0.2219512195121951
186122,"public Map<String,Object> readValues(InputStream dataStream){
  Map<String,Object> objects=new HashMap<String,Object>();
  try {
    Iterator<JsonNode> elements=dataElements(dataStream);
    objects.putAll(readElements(elements));
  }
 catch (  JsonParseException e) {
    throw new IllegalArgumentException(e);
  }
catch (  JsonMappingException e) {
    throw new IllegalArgumentException(e);
  }
catch (  IOException e) {
    throw new IllegalArgumentException(e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
  return objects;
}","public Map<Object,Object> readValues(InputStream dataStream){
  Map<Object,Object> objects=new HashMap<Object,Object>();
  try {
    Iterator<JsonNode> elements=dataElements(dataStream);
    objects.putAll(readElements(elements));
  }
 catch (  JsonParseException e) {
    throw new IllegalArgumentException(e);
  }
catch (  JsonMappingException e) {
    throw new IllegalArgumentException(e);
  }
catch (  IOException e) {
    throw new IllegalArgumentException(e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
  return objects;
}",0.8614864864864865
186123,"private Map<String,Object> readElements(Iterator<JsonNode> elements) throws IOException, JsonParseException, JsonMappingException, ClassNotFoundException {
  Map<String,Object> objects=new HashMap<String,Object>();
  while (elements.hasNext()) {
    JsonNode element=elements.next();
    String keyValue=keyValue(element);
    Object readValue=readValue(element);
    objects.put(keyValue,readValue);
  }
  return objects;
}","private Map<Object,Object> readElements(Iterator<JsonNode> elements) throws IOException, JsonParseException, JsonMappingException, ClassNotFoundException {
  Map<Object,Object> objects=new HashMap<Object,Object>();
  while (elements.hasNext()) {
    JsonNode element=elements.next();
    Object keyValue=keyValue(element);
    Object readValue=readValue(element);
    objects.put(keyValue,readValue);
  }
  return objects;
}",0.9433962264150944
186124,"@Test public void native_data_should_be_read() throws JsonParseException, IOException, ClassNotFoundException {
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<String,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(SIMPLE_DATA.getBytes()));
  String readElement=(String)elements.get(""String_Node_Str"");
  assertThat(readElement,is(""String_Node_Str""));
}","@Test public void native_data_should_be_read() throws JsonParseException, IOException, ClassNotFoundException {
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<Object,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(SIMPLE_DATA.getBytes()));
  String readElement=(String)elements.get(""String_Node_Str"");
  assertThat(readElement,is(""String_Node_Str""));
}",0.9853300733496332
186125,"@Test public void array_of_objects_should_be_read_and_tranformed_to_instance(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<String,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(ARRAY_OF_OBJECTS_DATA.getBytes()));
  Set<User> readElements=(Set<User>)elements.get(""String_Node_Str"");
  assertThat(readElements,containsInAnyOrder(new User(""String_Node_Str"",""String_Node_Str""),new User(""String_Node_Str"",""String_Node_Str"")));
}","@Test public void array_of_objects_should_be_read_and_tranformed_to_instance(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<Object,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(ARRAY_OF_OBJECTS_DATA.getBytes()));
  Set<User> readElements=(Set<User>)elements.get(""String_Node_Str"");
  assertThat(readElements,containsInAnyOrder(new User(""String_Node_Str"",""String_Node_Str""),new User(""String_Node_Str"",""String_Node_Str"")));
}",0.9876288659793816
186126,"@Test public void native_data_should_be_read_as_integer() throws JsonParseException, IOException, ClassNotFoundException {
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<String,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(SIMPLE_DATA_INTEGER.getBytes()));
  Integer readElement=(Integer)elements.get(""String_Node_Str"");
  assertThat(readElement,is(1));
}","@Test public void native_data_should_be_read_as_integer() throws JsonParseException, IOException, ClassNotFoundException {
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<Object,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(SIMPLE_DATA_INTEGER.getBytes()));
  Integer readElement=(Integer)elements.get(""String_Node_Str"");
  assertThat(readElement,is(1));
}",0.9855072463768116
186127,"@Test public void array_of_elements_should_be_inserted_into_given_implementation_collection(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<String,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(SET_DATA.getBytes()));
  Set<String> readElements=(Set<String>)elements.get(""String_Node_Str"");
  assertThat(readElements,instanceOf(HashSet.class));
  assertThat(readElements,containsInAnyOrder(""String_Node_Str"",""String_Node_Str""));
}","@Test public void array_of_elements_should_be_inserted_into_given_implementation_collection(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<Object,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(SET_DATA.getBytes()));
  Set<String> readElements=(Set<String>)elements.get(""String_Node_Str"");
  assertThat(readElements,instanceOf(HashSet.class));
  assertThat(readElements,containsInAnyOrder(""String_Node_Str"",""String_Node_Str""));
}",0.9877300613496932
186128,"@Test public void array_of_elements_should_be_inserted_into_ArrayList_if_no_implementation_provided(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<String,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(ARRAY_DATA.getBytes()));
  List<String> readElements=(List<String>)elements.get(""String_Node_Str"");
  assertThat(readElements,instanceOf(ArrayList.class));
  assertThat(readElements,containsInAnyOrder(""String_Node_Str"",""String_Node_Str""));
}","@Test public void array_of_elements_should_be_inserted_into_ArrayList_if_no_implementation_provided(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<Object,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(ARRAY_DATA.getBytes()));
  List<String> readElements=(List<String>)elements.get(""String_Node_Str"");
  assertThat(readElements,instanceOf(ArrayList.class));
  assertThat(readElements,containsInAnyOrder(""String_Node_Str"",""String_Node_Str""));
}",0.9880715705765408
186129,"@Test public void object_data_should_be_read_and_transformed_to_instance(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<String,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(OBJECT_DATA.getBytes()));
  User readElement=(User)elements.get(""String_Node_Str"");
  assertThat(readElement,is(new User(""String_Node_Str"",""String_Node_Str"")));
}","@Test public void object_data_should_be_read_and_transformed_to_instance(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<Object,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(OBJECT_DATA.getBytes()));
  User readElement=(User)elements.get(""String_Node_Str"");
  assertThat(readElement,is(new User(""String_Node_Str"",""String_Node_Str"")));
}",0.9848866498740554
186130,"@Test(expected=IllegalArgumentException.class) public void an_exception_should_be_thrown_if_no_implementation_is_provided_in_objects(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<String,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(OBJECT_DATA_WITHOUT_IMPLEMENTATION.getBytes()));
}","@Test(expected=IllegalArgumentException.class) public void an_exception_should_be_thrown_if_no_implementation_is_provided_in_objects(){
  KeyValueObjectMapper keyValueObjectMapper=new KeyValueObjectMapper();
  Map<Object,Object> elements=keyValueObjectMapper.readValues(new ByteArrayInputStream(OBJECT_DATA_WITHOUT_IMPLEMENTATION.getBytes()));
}",0.982608695652174
186131,"private List<String> buildOperationSystemProgramAndArguments(){
  List<String> programAndArguments=new ArrayList<String>();
  programAndArguments.add(getExecutablePath());
  if (isReplicaSetNameSet()) {
    programAndArguments.add(REPLICA_SET_ARGUMENT_NAME);
    programAndArguments.add(this.replicaSetName);
  }
  programAndArguments.add(DBPATH_ARGUMENT_NAME);
  programAndArguments.add(dbRelativePath);
  programAndArguments.add(PORT_ARGUMENT_NAME);
  programAndArguments.add(Integer.toString(port));
  programAndArguments.add(LOGPATH_ARGUMENT_NAME);
  programAndArguments.add(logRelativePath);
  for (  String argument : this.singleCommandArguments) {
    programAndArguments.add(argument);
  }
  for (  String argumentName : this.extraCommandArguments.keySet()) {
    programAndArguments.add(argumentName);
    programAndArguments.add(this.extraCommandArguments.get(argumentName));
  }
  return programAndArguments;
}","private List<String> buildOperationSystemProgramAndArguments(){
  List<String> programAndArguments=new ArrayList<String>();
  programAndArguments.add(getExecutablePath());
  if (isReplicaSetNameSet()) {
    programAndArguments.add(REPLICA_SET_ARGUMENT_NAME);
    programAndArguments.add(this.replicaSetName);
  }
  programAndArguments.add(DBPATH_ARGUMENT_NAME);
  programAndArguments.add(dbRelativePath);
  programAndArguments.add(PORT_ARGUMENT_NAME);
  programAndArguments.add(Integer.toString(port));
  programAndArguments.add(LOGPATH_ARGUMENT_NAME);
  programAndArguments.add(logRelativePath);
  programAndArguments.add(journalingArgument());
  for (  String argument : this.singleCommandArguments) {
    programAndArguments.add(argument);
  }
  for (  String argumentName : this.extraCommandArguments.keySet()) {
    programAndArguments.add(argumentName);
    programAndArguments.add(this.extraCommandArguments.get(argumentName));
  }
  return programAndArguments;
}",0.9740877842411424
186132,"public void removeEmbeddedInstance(String targetPath){
  if (instances.containsKey(targetPath)) {
    this.instances.get(targetPath).remove();
  }
}","public void removeEmbeddedInstance(String targetPath){
  this.instances.remove(targetPath);
}",0.7302904564315352
186133,"public T getDefaultEmbeddedInstance(){
  ThreadLocal<T> currentThreadLocal=with(this.instances).values().first(anything());
  if (currentThreadLocal != null) {
    return currentThreadLocal.get();
  }
  return null;
}","public T getDefaultEmbeddedInstance(){
  T element=with(this.instances).values().first(anything());
  return element;
}",0.6666666666666666
186134,"public void addEmbeddedInstance(T embeddedInstance,String targetPath){
  if (!instances.containsKey(targetPath)) {
    this.instances.put(targetPath,new ThreadLocal<T>());
  }
  ThreadLocal<T> currentThreadLocal=this.instances.get(targetPath);
  currentThreadLocal.set(embeddedInstance);
  this.instances.put(targetPath,currentThreadLocal);
}","public void addEmbeddedInstance(T embeddedInstance,String targetPath){
  this.instances.put(targetPath,embeddedInstance);
}",0.5290322580645161
186135,"public T getEmbeddedByTargetPath(String targetPath){
  if (this.instances.containsKey(targetPath)) {
    return this.instances.get(targetPath).get();
  }
  return null;
}","public T getEmbeddedByTargetPath(String targetPath){
  if (this.instances.containsKey(targetPath)) {
    return this.instances.get(targetPath);
  }
  return null;
}",0.9820359281437124
186136,"private DB getMongoDb(){
  DB db=mongo.getDB(this.mongoDbConfiguration.getDatabaseName());
  if (this.mongoDbConfiguration.isAuthenticateParametersSet()) {
    boolean authenticated=db.authenticate(this.mongoDbConfiguration.getUsername(),this.mongoDbConfiguration.getPassword().toCharArray());
    if (!authenticated) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  return db;
}","private DB getMongoDb(){
  DB db=mongo.getDB(this.mongoDbConfiguration.getDatabaseName());
  if (this.mongoDbConfiguration.isAuthenticateParametersSet() && !db.isAuthenticated()) {
    boolean authenticated=db.authenticate(this.mongoDbConfiguration.getUsername(),this.mongoDbConfiguration.getPassword().toCharArray());
    if (!authenticated) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  return db;
}",0.9700598802395208
186137,"@Override public Statement apply(final Statement base,final FrameworkMethod method,final Object testObject){
  return new Statement(){
    @Override public void evaluate() throws Throwable {
      target=testObject;
      defaultDataSetLocationResolver=new DefaultDataSetLocationResolver(testObject.getClass());
      UsingDataSet usingDataSet=getUsingDataSetAnnotation();
      if (isTestAnnotatedWithDataSet(usingDataSet)) {
        loadDataSet(usingDataSet,method);
      }
      injectAnnotationProcessor.processInjectAnnotation(testObject.getClass(),target,getDatabaseOperation().connectionManager());
      base.evaluate();
      ShouldMatchDataSet shouldMatchDataSet=getShouldMatchDataSetAnnotation();
      if (isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        assertExpectation(shouldMatchDataSet);
      }
    }
    private ShouldMatchDataSet getShouldMatchDataSetAnnotation(){
      ShouldMatchDataSet shouldMatchDataSet=method.getAnnotation(ShouldMatchDataSet.class);
      if (!isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        Class<?> testClass=target.getClass();
        shouldMatchDataSet=testClass.getAnnotation(ShouldMatchDataSet.class);
      }
      return shouldMatchDataSet;
    }
    private UsingDataSet getUsingDataSetAnnotation(){
      UsingDataSet usingDataSet=method.getAnnotation(UsingDataSet.class);
      if (!isTestAnnotatedWithDataSet(usingDataSet)) {
        Class<?> testClass=target.getClass();
        usingDataSet=testClass.getAnnotation(UsingDataSet.class);
      }
      return usingDataSet;
    }
    private void assertExpectation(    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=loadExpectedContentScript(method,shouldMatchDataSet);
      if (isNotEmptyStream(scriptContent)) {
        getDatabaseOperation().databaseIs(scriptContent);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    private InputStream loadExpectedContentScript(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      String location=shouldMatchDataSet.location();
      InputStream scriptContent=null;
      if (isNotEmptyString(location)) {
        scriptContent=loadExpectedResultFromLocationAttribute(location);
      }
 else {
        SelectiveMatcher[] selectiveMatchers=shouldMatchDataSet.withSelectiveMatcher();
        SelectiveMatcher requiredSelectiveMatcher=findSelectiveMatcherByConnectionIdentifier(selectiveMatchers);
        if (isSelectiveMatchersDefined(requiredSelectiveMatcher)) {
          scriptContent=loadExpectedResultFromLocationAttribute(requiredSelectiveMatcher.location());
        }
 else {
          scriptContent=loadExpectedResultFromDefaultLocation(method,shouldMatchDataSet);
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveMatchersDefined(    SelectiveMatcher requiredSelectiveMatcher){
      return requiredSelectiveMatcher != null;
    }
    private SelectiveMatcher findSelectiveMatcherByConnectionIdentifier(    SelectiveMatcher[] selectiveMatchers){
      return selectFirst(selectiveMatchers,having(on(SelectiveMatcher.class).identifier(),equalTo(identifier)).and(having(on(SelectiveMatcher.class).location(),notNullValue())));
    }
    private InputStream loadExpectedResultFromDefaultLocation(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=null;
      String defaultLocation=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(shouldMatchDataSet,method,EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension());
      if (defaultLocation != null) {
        scriptContent=loadExpectedResultFromLocationAttribute(defaultLocation);
      }
      return scriptContent;
    }
    private InputStream loadExpectedResultFromLocationAttribute(    String location) throws IOException {
      InputStream scriptContent;
      scriptContent=IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location);
      return scriptContent;
    }
    private void loadDataSet(    UsingDataSet usingDataSet,    FrameworkMethod method) throws IOException {
      String[] locations=usingDataSet.locations();
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      scriptContent.addAll(loadGlobalDataSets(usingDataSet,method,locations));
      scriptContent.addAll(loadSelectiveDataSets(usingDataSet));
      LoadStrategyEnum loadStrategyEnum=usingDataSet.loadStrategy();
      LoadStrategyOperation loadStrategyOperation=loadStrategyFactory.getLoadStrategyInstance(loadStrategyEnum,getDatabaseOperation());
      loadStrategyOperation.executeScripts(scriptContent.toArray(new InputStream[scriptContent.size()]));
    }
    private List<InputStream> loadSelectiveDataSets(    UsingDataSet usingDataSet) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isSelectiveLocationsAttributeSpecified(usingDataSet)) {
        Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
        if (selectiveLocations != null && selectiveLocations.length > 0) {
          for (          Selective selective : selectiveLocations) {
            if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
              scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),selective.locations()));
            }
          }
        }
      }
      return scriptContent;
    }
    private List<InputStream> loadGlobalDataSets(    UsingDataSet usingDataSet,    FrameworkMethod method,    String[] locations) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isLocationsAttributeSpecified(locations)) {
        scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),locations));
      }
 else {
        String location=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(usingDataSet,method,""String_Node_Str"" + getWorkingExtension());
        if (location != null) {
          scriptContent.add(IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location));
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveLocationsAttributeSpecified(    UsingDataSet usingDataSet){
      Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
      if (selectiveLocations != null && selectiveLocations.length > 0) {
        for (        Selective selective : selectiveLocations) {
          if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
            return true;
          }
        }
      }
      return false;
    }
    private boolean isNotEmptyStream(    InputStream inputStream){
      return inputStream != null;
    }
    private boolean isNotEmptyString(    String location){
      return location != null && !""String_Node_Str"".equals(location.trim());
    }
    private boolean isLocationsAttributeSpecified(    String[] locations){
      return locations != null && locations.length > 0;
    }
    private boolean isTestAnnotatedWithExpectedDataSet(    ShouldMatchDataSet shouldMatchDataSet){
      return shouldMatchDataSet != null;
    }
    private boolean isTestAnnotatedWithDataSet(    UsingDataSet usingDataSet){
      return usingDataSet != null;
    }
  }
;
}","@Override public Statement apply(final Statement base,final FrameworkMethod method,final Object testObject){
  return new Statement(){
    @Override public void evaluate() throws Throwable {
      target=testObject;
      defaultDataSetLocationResolver=new DefaultDataSetLocationResolver(testObject.getClass());
      UsingDataSet usingDataSet=getUsingDataSetAnnotation();
      if (isTestAnnotatedWithDataSet(usingDataSet)) {
        loadDataSet(usingDataSet,method);
      }
      injectAnnotationProcessor.processInjectAnnotation(testObject.getClass(),target,getDatabaseOperation().connectionManager());
      base.evaluate();
      ShouldMatchDataSet shouldMatchDataSet=getShouldMatchDataSetAnnotation();
      if (isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        assertExpectation(shouldMatchDataSet);
      }
    }
    private ShouldMatchDataSet getShouldMatchDataSetAnnotation(){
      ShouldMatchDataSet shouldMatchDataSet=method.getAnnotation(ShouldMatchDataSet.class);
      if (!isTestAnnotatedWithExpectedDataSet(shouldMatchDataSet)) {
        Class<?> testClass=target.getClass();
        shouldMatchDataSet=testClass.getAnnotation(ShouldMatchDataSet.class);
      }
      return shouldMatchDataSet;
    }
    private UsingDataSet getUsingDataSetAnnotation(){
      UsingDataSet usingDataSet=method.getAnnotation(UsingDataSet.class);
      if (!isTestAnnotatedWithDataSet(usingDataSet)) {
        Class<?> testClass=target.getClass();
        usingDataSet=testClass.getAnnotation(UsingDataSet.class);
      }
      return usingDataSet;
    }
    private void assertExpectation(    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=loadExpectedContentScript(method,shouldMatchDataSet);
      if (isNotEmptyStream(scriptContent)) {
        getDatabaseOperation().databaseIs(scriptContent);
      }
 else {
        final String suffix=EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension();
        final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
        final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
      }
    }
    private InputStream loadExpectedContentScript(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      String location=shouldMatchDataSet.location();
      InputStream scriptContent=null;
      if (isNotEmptyString(location)) {
        scriptContent=loadExpectedResultFromLocationAttribute(location);
      }
 else {
        SelectiveMatcher[] selectiveMatchers=shouldMatchDataSet.withSelectiveMatcher();
        SelectiveMatcher requiredSelectiveMatcher=findSelectiveMatcherByConnectionIdentifier(selectiveMatchers);
        if (isSelectiveMatchersDefined(requiredSelectiveMatcher)) {
          scriptContent=loadExpectedResultFromLocationAttribute(requiredSelectiveMatcher.location());
        }
 else {
          scriptContent=loadExpectedResultFromDefaultLocation(method,shouldMatchDataSet);
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveMatchersDefined(    SelectiveMatcher requiredSelectiveMatcher){
      return requiredSelectiveMatcher != null;
    }
    private SelectiveMatcher findSelectiveMatcherByConnectionIdentifier(    SelectiveMatcher[] selectiveMatchers){
      return selectFirst(selectiveMatchers,having(on(SelectiveMatcher.class).identifier(),equalTo(identifier)).and(having(on(SelectiveMatcher.class).location(),notNullValue())));
    }
    private InputStream loadExpectedResultFromDefaultLocation(    final FrameworkMethod method,    ShouldMatchDataSet shouldMatchDataSet) throws IOException {
      InputStream scriptContent=null;
      String defaultLocation=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(shouldMatchDataSet,method,EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension());
      if (defaultLocation != null) {
        scriptContent=loadExpectedResultFromLocationAttribute(defaultLocation);
      }
      return scriptContent;
    }
    private InputStream loadExpectedResultFromLocationAttribute(    String location) throws IOException {
      InputStream scriptContent;
      scriptContent=IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location);
      return scriptContent;
    }
    private void loadDataSet(    UsingDataSet usingDataSet,    FrameworkMethod method) throws IOException {
      List<InputStream> scriptContent=loadDatasets(usingDataSet,method);
      LoadStrategyEnum loadStrategyEnum=usingDataSet.loadStrategy();
      if (areDatasetsRequired(loadStrategyEnum) && emptyDataset(scriptContent)) {
        final String suffix=""String_Node_Str"" + getWorkingExtension();
        final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
        final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
        throw new IllegalArgumentException(""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
      }
      LoadStrategyOperation loadStrategyOperation=loadStrategyFactory.getLoadStrategyInstance(loadStrategyEnum,getDatabaseOperation());
      loadStrategyOperation.executeScripts(scriptContent.toArray(new InputStream[scriptContent.size()]));
    }
    private boolean emptyDataset(    List<InputStream> scriptContent){
      return scriptContent.size() == 0;
    }
    private boolean areDatasetsRequired(    LoadStrategyEnum loadStrategyEnum){
      return LoadStrategyEnum.DELETE_ALL != loadStrategyEnum;
    }
    private List<InputStream> loadDatasets(    UsingDataSet usingDataSet,    FrameworkMethod method) throws IOException {
      String[] locations=usingDataSet.locations();
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      scriptContent.addAll(loadGlobalDataSets(usingDataSet,method,locations));
      scriptContent.addAll(loadSelectiveDataSets(usingDataSet));
      return scriptContent;
    }
    private List<InputStream> loadSelectiveDataSets(    UsingDataSet usingDataSet) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isSelectiveLocationsAttributeSpecified(usingDataSet)) {
        Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
        if (selectiveLocations != null && selectiveLocations.length > 0) {
          for (          Selective selective : selectiveLocations) {
            if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
              scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),selective.locations()));
            }
          }
        }
      }
      return scriptContent;
    }
    private List<InputStream> loadGlobalDataSets(    UsingDataSet usingDataSet,    FrameworkMethod method,    String[] locations) throws IOException {
      List<InputStream> scriptContent=new ArrayList<InputStream>();
      if (isLocationsAttributeSpecified(locations)) {
        scriptContent.addAll(IOUtils.getAllStreamsFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),locations));
      }
 else {
        String location=defaultDataSetLocationResolver.resolveDefaultDataSetLocation(usingDataSet,method,""String_Node_Str"" + getWorkingExtension());
        if (location != null) {
          scriptContent.add(IOUtils.getStreamFromClasspathBaseResource(defaultDataSetLocationResolver.getResourceBase(),location));
        }
      }
      return scriptContent;
    }
    private boolean isSelectiveLocationsAttributeSpecified(    UsingDataSet usingDataSet){
      Selective[] selectiveLocations=usingDataSet.withSelectiveLocations();
      if (selectiveLocations != null && selectiveLocations.length > 0) {
        for (        Selective selective : selectiveLocations) {
          if (identifier.equals(selective.identifier().trim()) && isLocationsAttributeSpecified(selective.locations())) {
            return true;
          }
        }
      }
      return false;
    }
    private boolean isNotEmptyStream(    InputStream inputStream){
      return inputStream != null;
    }
    private boolean isNotEmptyString(    String location){
      return location != null && !""String_Node_Str"".equals(location.trim());
    }
    private boolean isLocationsAttributeSpecified(    String[] locations){
      return locations != null && locations.length > 0;
    }
    private boolean isTestAnnotatedWithExpectedDataSet(    ShouldMatchDataSet shouldMatchDataSet){
      return shouldMatchDataSet != null;
    }
    private boolean isTestAnnotatedWithDataSet(    UsingDataSet usingDataSet){
      return usingDataSet != null;
    }
  }
;
}",0.7548949379178606
186138,"private void loadDataSet(UsingDataSet usingDataSet,FrameworkMethod method) throws IOException {
  String[] locations=usingDataSet.locations();
  List<InputStream> scriptContent=new ArrayList<InputStream>();
  scriptContent.addAll(loadGlobalDataSets(usingDataSet,method,locations));
  scriptContent.addAll(loadSelectiveDataSets(usingDataSet));
  LoadStrategyEnum loadStrategyEnum=usingDataSet.loadStrategy();
  LoadStrategyOperation loadStrategyOperation=loadStrategyFactory.getLoadStrategyInstance(loadStrategyEnum,getDatabaseOperation());
  loadStrategyOperation.executeScripts(scriptContent.toArray(new InputStream[scriptContent.size()]));
}","private void loadDataSet(UsingDataSet usingDataSet,FrameworkMethod method) throws IOException {
  List<InputStream> scriptContent=loadDatasets(usingDataSet,method);
  LoadStrategyEnum loadStrategyEnum=usingDataSet.loadStrategy();
  if (areDatasetsRequired(loadStrategyEnum) && emptyDataset(scriptContent)) {
    final String suffix=""String_Node_Str"" + getWorkingExtension();
    final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
    final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
    throw new IllegalArgumentException(""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
  }
  LoadStrategyOperation loadStrategyOperation=loadStrategyFactory.getLoadStrategyInstance(loadStrategyEnum,getDatabaseOperation());
  loadStrategyOperation.executeScripts(scriptContent.toArray(new InputStream[scriptContent.size()]));
}",0.4528985507246377
186139,"private void assertExpectation(ShouldMatchDataSet shouldMatchDataSet) throws IOException {
  InputStream scriptContent=loadExpectedContentScript(method,shouldMatchDataSet);
  if (isNotEmptyStream(scriptContent)) {
    getDatabaseOperation().databaseIs(scriptContent);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","private void assertExpectation(ShouldMatchDataSet shouldMatchDataSet) throws IOException {
  InputStream scriptContent=loadExpectedContentScript(method,shouldMatchDataSet);
  if (isNotEmptyStream(scriptContent)) {
    getDatabaseOperation().databaseIs(scriptContent);
  }
 else {
    final String suffix=EXPECTED_RESERVED_WORD + ""String_Node_Str"" + getWorkingExtension();
    final String defaultClassLocation=DefaultClasspathLocationBuilder.defaultClassAnnotatedClasspathLocation(method);
    final String defaultMethodLocation=DefaultClasspathLocationBuilder.defaultMethodAnnotatedClasspathLocation(method,defaultClassLocation,suffix);
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + defaultClassLocation + suffix+ ""String_Node_Str""+ defaultMethodLocation);
  }
}",0.6275862068965518
186140,"private static void checkColumns(List<ColumnFamilyModel> expectedColumnFamilies,Keyspace keyspace,KeyspaceDefinition keyspaceDefinition){
  List<ColumnFamilyDefinition> columnFamilyDefinitions=keyspaceDefinition.getCfDefs();
  for (  ColumnFamilyModel expectedColumnFamilyModel : expectedColumnFamilies) {
    ColumnFamilyDefinition columnFamily=checkColumnFamilyName(columnFamilyDefinitions,expectedColumnFamilyModel);
    ColumnType columnType=checkColumnFamilyType(expectedColumnFamilyModel,columnFamily);
    String expectedColumnFamilyName=expectedColumnFamilyModel.getName();
    List<RowModel> expectedRows=expectedColumnFamilyModel.getRows();
    checkNumberOfRowsIntoColumnFamily(keyspace,expectedColumnFamilyName,expectedRows.size());
    if (ColumnType.STANDARD == columnType) {
      for (      RowModel expectedRowModel : expectedRows) {
        checkStandardColumns(keyspace,expectedColumnFamilyName,expectedRowModel);
      }
    }
 else {
      if (ColumnType.SUPER == columnType) {
        for (        RowModel expectedRowModel : expectedRows) {
          List<ColumnModel> expectedColumns=expectedRowModel.getColumns();
          checkNotStandardColumnsInSuperColumns(expectedRowModel,expectedColumns.size());
          checkSuperColumns(keyspace,expectedColumnFamilyName,expectedRowModel);
        }
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
}","private static void checkColumns(List<ColumnFamilyModel> expectedColumnFamilies,Keyspace keyspace,KeyspaceDefinition keyspaceDefinition){
  List<ColumnFamilyDefinition> columnFamilyDefinitions=keyspaceDefinition.getCfDefs();
  for (  ColumnFamilyModel expectedColumnFamilyModel : expectedColumnFamilies) {
    ColumnFamilyDefinition columnFamily=checkColumnFamilyName(columnFamilyDefinitions,expectedColumnFamilyModel);
    ColumnType columnType=checkColumnFamilyType(expectedColumnFamilyModel,columnFamily);
    String expectedColumnFamilyName=expectedColumnFamilyModel.getName();
    List<RowModel> expectedRows=expectedColumnFamilyModel.getRows();
    checkNumberOfRowsIntoColumnFamily(keyspace,expectedColumnFamilyName,expectedRows.size());
    if (ColumnType.STANDARD == columnType) {
      for (      RowModel expectedRowModel : expectedRows) {
        checkStandardColumns(keyspace,expectedColumnFamilyModel,expectedRowModel);
      }
    }
 else {
      if (ColumnType.SUPER == columnType) {
        for (        RowModel expectedRowModel : expectedRows) {
          List<ColumnModel> expectedColumns=expectedRowModel.getColumns();
          checkNotStandardColumnsInSuperColumns(expectedRowModel,expectedColumns.size());
          checkSuperColumns(keyspace,expectedColumnFamilyModel,expectedRowModel);
        }
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
}",0.9936575052854124
186141,"private static void checkSuperColumns(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel) throws Error {
  List<SuperColumnModel> expectedSuperColumns=expectedRowModel.getSuperColumns();
  checkNumberOfSuperColumns(keyspace,expectedColumnFamilyName,expectedRowModel,expectedSuperColumns.size());
  for (  SuperColumnModel expectedSuperColumnModel : expectedSuperColumns) {
    GenericType expectedSuperColumnName=expectedSuperColumnModel.getName();
    SuperColumnQuery<byte[],byte[],byte[],byte[]> createSuperColumnQuery=HFactory.createSuperColumnQuery(keyspace,BytesArraySerializer.get(),BytesArraySerializer.get(),BytesArraySerializer.get(),BytesArraySerializer.get());
    createSuperColumnQuery.setColumnFamily(expectedColumnFamilyName);
    createSuperColumnQuery.setKey(getBytes(expectedRowModel.getKey()));
    createSuperColumnQuery.setSuperName(getBytes(expectedSuperColumnName));
    QueryResult<HSuperColumn<byte[],byte[],byte[]>> supercolumn=createSuperColumnQuery.execute();
    List<ColumnModel> expectedColumns=expectedSuperColumnModel.getColumns();
    HSuperColumn<byte[],byte[],byte[]> hSuperColumn=supercolumn.get();
    checkSuperColumnNameAndKey(expectedSuperColumnName,hSuperColumn);
    List<HColumn<byte[],byte[]>> columns=hSuperColumn.getColumns();
    checkNumberOfColumnsInsideSuperColumn(expectedSuperColumnModel.getName().getValue(),expectedRowModel.getKey().getValue(),expectedColumns.size(),columns.size());
    checkColumnsOfSuperColumn(expectedRowModel,expectedSuperColumnModel,expectedColumns,columns);
  }
}","private static void checkSuperColumns(Keyspace keyspace,ColumnFamilyModel expectedColumnFamilyModel,RowModel expectedRowModel) throws Error {
  String expectedColumnFamilyName=expectedColumnFamilyModel.getName();
  List<SuperColumnModel> expectedSuperColumns=expectedRowModel.getSuperColumns();
  checkNumberOfSuperColumns(keyspace,expectedColumnFamilyName,expectedRowModel,expectedSuperColumns.size());
  for (  SuperColumnModel expectedSuperColumnModel : expectedSuperColumns) {
    GenericType expectedSuperColumnName=expectedSuperColumnModel.getName();
    SuperColumnQuery<byte[],byte[],byte[],byte[]> createSuperColumnQuery=HFactory.createSuperColumnQuery(keyspace,BytesArraySerializer.get(),BytesArraySerializer.get(),BytesArraySerializer.get(),BytesArraySerializer.get());
    createSuperColumnQuery.setColumnFamily(expectedColumnFamilyName);
    createSuperColumnQuery.setKey(getBytes(expectedRowModel.getKey()));
    createSuperColumnQuery.setSuperName(getBytes(expectedSuperColumnName));
    QueryResult<HSuperColumn<byte[],byte[],byte[]>> supercolumn=createSuperColumnQuery.execute();
    List<ColumnModel> expectedColumns=expectedSuperColumnModel.getColumns();
    HSuperColumn<byte[],byte[],byte[]> hSuperColumn=supercolumn.get();
    checkSuperColumnNameAndKey(expectedSuperColumnName,hSuperColumn);
    List<HColumn<byte[],byte[]>> columns=hSuperColumn.getColumns();
    checkNumberOfColumnsInsideSuperColumn(expectedSuperColumnModel.getName().getValue(),expectedRowModel.getKey().getValue(),expectedColumns.size(),columns.size());
    checkColumnsOfSuperColumn(expectedRowModel,expectedSuperColumnModel,expectedColumns,columns);
  }
}",0.9388008698353526
186142,"private static void checkStandardColumns(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel) throws Error {
  checkNumberOfColumns(keyspace,expectedColumnFamilyName,expectedRowModel);
  List<ColumnModel> expectedColumns=expectedRowModel.getColumns();
  for (  ColumnModel expectedColumnModel : expectedColumns) {
    ColumnQuery<byte[],byte[],byte[]> columnQuery=HFactory.createColumnQuery(keyspace,BytesArraySerializer.get(),BytesArraySerializer.get(),BytesArraySerializer.get());
    columnQuery.setColumnFamily(expectedColumnFamilyName).setKey(getBytes(expectedRowModel.getKey())).setName(getBytes(expectedColumnModel.getName()));
    QueryResult<HColumn<byte[],byte[]>> result=columnQuery.execute();
    HColumn<byte[],byte[]> hColumn=result.get();
    checkColumnName(expectedColumnModel,hColumn);
    checkColumnValue(expectedRowModel,hColumn);
  }
}","private static void checkStandardColumns(Keyspace keyspace,ColumnFamilyModel expectedColumnFamilyModel,RowModel expectedRowModel) throws Error {
  String expectedColumnFamilyName=expectedColumnFamilyModel.getName();
  checkNumberOfColumns(keyspace,expectedColumnFamilyName,expectedRowModel);
  List<ColumnModel> expectedColumns=expectedRowModel.getColumns();
  for (  ColumnModel expectedColumnModel : expectedColumns) {
    if (expectedColumnFamilyModel.isCounter()) {
      checkCounterColumn(keyspace,expectedRowModel,expectedColumnFamilyName,expectedColumnModel);
    }
 else {
      checkColumn(keyspace,expectedRowModel,expectedColumnFamilyName,expectedColumnModel);
    }
  }
}",0.4370607028753994
186143,"private void dropKeyspaces(){
  List<KeyspaceDefinition> keyspaces=cluster.describeKeyspaces();
  for (  KeyspaceDefinition keyspaceDefinition : keyspaces) {
    String keyspaceName=keyspaceDefinition.getName();
    if (!INTERNAL_CASSANDRA_KEYSPACE.equals(keyspaceName)) {
      cluster.dropKeyspace(keyspaceName);
    }
  }
  List<KeyspaceDefinition> keyspaces2=cluster.describeKeyspaces();
}","private void dropKeyspaces(){
  List<KeyspaceDefinition> keyspaces=cluster.describeKeyspaces();
  for (  KeyspaceDefinition keyspaceDefinition : keyspaces) {
    String keyspaceName=keyspaceDefinition.getName();
    if (!INTERNAL_CASSANDRA_KEYSPACE.equals(keyspaceName)) {
      cluster.dropKeyspace(keyspaceName,true);
    }
  }
  List<KeyspaceDefinition> keyspaces2=cluster.describeKeyspaces();
}",0.9936788874841972
186144,"private List<String> buildOperationSystemProgramAndArguments(){
  List<String> programAndArguments=new ArrayList<String>();
  programAndArguments.add(getExecutablePath());
  programAndArguments.add(FOREGROUND_ARGUMENT_NAME);
  for (  String argument : this.singleCommandArguments) {
    programAndArguments.add(argument);
  }
  for (  String argumentName : this.extraCommandArguments.keySet()) {
    programAndArguments.add(argumentName);
    programAndArguments.add(this.extraCommandArguments.get(argumentName));
  }
  return programAndArguments;
}","private List<String> buildOperationSystemProgramAndArguments(){
  List<String> programAndArguments=new ArrayList<String>();
  programAndArguments.add(getExecutablePath());
  programAndArguments.add(""String_Node_Str"");
  programAndArguments.add(FOREGROUND_ARGUMENT_NAME);
  for (  String argument : this.singleCommandArguments) {
    programAndArguments.add(argument);
  }
  for (  String argumentName : this.extraCommandArguments.keySet()) {
    programAndArguments.add(argumentName);
    programAndArguments.add(this.extraCommandArguments.get(argumentName));
  }
  return programAndArguments;
}",0.9597902097902098
186145,"private List<String> startCassandraProcess() throws InterruptedException {
  try {
    pwd=startProcess();
    pwd.waitFor();
    if (pwd.exitValue() != 0) {
      List<String> consoleOutput=getConsoleOutput(pwd);
      throw new IllegalStateException(""String_Node_Str"" + cassandraPath + ""String_Node_Str""+ port+ ""String_Node_Str""+ consoleOutput);
    }
    return null;
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"" + cassandraPath + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
}","private List<String> startCassandraProcess() throws InterruptedException {
  try {
    pwd=startProcess();
    pwd.waitFor();
    if (pwd.exitValue() != 0) {
      List<String> consoleOutput=getConsoleOutput(pwd);
      System.out.println(consoleOutput);
    }
    return null;
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"" + cassandraPath + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
}",0.86282722513089
186146,"@Test public void cassandra_should_be_started_in_Linux() throws Throwable {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.LINUX_OS);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_X);
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
  System.clearProperty(""String_Node_Str"");
}","@Test public void cassandra_should_be_started_in_Linux() throws Throwable {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.LINUX_OS);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_X);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
  System.clearProperty(""String_Node_Str"");
}",0.983464566929134
186147,"@Test public void cassandra_should_be_started_in_Windows() throws Throwable {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.WINDOWS_7);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_W);
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
  System.clearProperty(""String_Node_Str"");
}","@Test public void cassandra_should_be_started_in_Windows() throws Throwable {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.WINDOWS_7);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_W);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
  System.clearProperty(""String_Node_Str"");
}",0.983503534956795
186148,"@Test public void cassandra_should_be_started_in_Linux_from_custom_location() throws Throwable {
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.LINUX_OS);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().cassandraPath(""String_Node_Str"").port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_X);
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
}","@Test public void cassandra_should_be_started_in_Linux_from_custom_location() throws Throwable {
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.LINUX_OS);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().cassandraPath(""String_Node_Str"").port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_X);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
}",0.9828150572831424
186149,"@Test public void cassandra_should_be_started_in_MacOsX() throws Throwable {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.MAC_OSX);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_X);
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
  System.clearProperty(""String_Node_Str"");
}","@Test public void cassandra_should_be_started_in_MacOsX() throws Throwable {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  when(operatingSystemResolver.currentOperatingSystem()).thenReturn(OperatingSystem.MAC_OSX);
  CommandLineExecutor commandLineExecutor=mock(CommandLineExecutor.class);
  Process mockProcess=mock(Process.class);
  when(mockProcess.exitValue()).thenReturn(0);
  when(commandLineExecutor.startProcessInDirectoryAndArguments(anyString(),anyList())).thenReturn(mockProcess);
  ManagedCassandra managedCassandra=newManagedCassandraRule().port(9191).build();
  managedCassandra.setCommandLineExecutor(commandLineExecutor);
  managedCassandra.setOperatingSystemResolver(operatingSystemResolver);
  managedCassandra.before();
  List<String> expectedCommand=new ArrayList<String>();
  expectedCommand.add(""String_Node_Str"" + File.separatorChar + ManagedCassandra.CASSANDRA_BINARY_DIRECTORY+ File.separatorChar+ ManagedCassandra.CASSANDRA_EXECUTABLE_X);
  expectedCommand.add(""String_Node_Str"");
  expectedCommand.add(ManagedCassandra.FOREGROUND_ARGUMENT_NAME);
  managedCassandra.after();
  verify(commandLineExecutor).startProcessInDirectoryAndArguments(ManagedCassandra.DEFAULT_CASSANDRA_TARGET_PATH,expectedCommand);
  System.clearProperty(""String_Node_Str"");
}",0.983464566929134
186150,"private void dropStructure(){
  Cluster cluster=HFactory.getOrCreateCluster(""String_Node_Str"",""String_Node_Str"");
  KeyspaceDefinition keyspaceDef=cluster.describeKeyspace(""String_Node_Str"");
  if (keyspaceDef != null) {
    cluster.dropKeyspace(""String_Node_Str"");
  }
}","private void dropStructure(Cluster cluster){
  KeyspaceDefinition keyspaceDef=cluster.describeKeyspace(""String_Node_Str"");
  if (keyspaceDef != null) {
    cluster.dropKeyspace(""String_Node_Str"");
  }
}",0.7906976744186046
186151,"@Test public void cassandra_process_should_be_started(){
  createStructure();
  ColumnFamilyTemplate<String,String> columnFamilyTemplate=columnFamilyTemplate(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Mutator<String> mutator=columnFamilyTemplate.createMutator();
  mutator.insert(""String_Node_Str"",""String_Node_Str"",HFactory.createStringColumn(""String_Node_Str"",""String_Node_Str""));
  ColumnFamilyResult<String,String> res=columnFamilyTemplate.queryColumns(""String_Node_Str"");
  String value=res.getString(""String_Node_Str"");
  assertThat(value,is(""String_Node_Str""));
  dropStructure();
}","@Test public void cassandra_process_should_be_started(){
  try {
    CassandraOperation cassandraOperation=new CassandraOperation(new CassandraConfiguration(""String_Node_Str"",""String_Node_Str"",9160));
    cassandraOperation.insert(new ByteArrayInputStream(INSERT_DATA.getBytes()));
    cassandraOperation.deleteAll();
  }
 catch (  Throwable t) {
    t.printStackTrace();
    Assert.fail();
  }
}",0.202
186152,"private void createStructure(){
  Cluster cluster=HFactory.getOrCreateCluster(""String_Node_Str"",""String_Node_Str"");
  dropStructure();
  ColumnFamilyDefinition cfDef=HFactory.createColumnFamilyDefinition(""String_Node_Str"",""String_Node_Str"",ComparatorType.BYTESTYPE);
  KeyspaceDefinition newKeyspace=HFactory.createKeyspaceDefinition(""String_Node_Str"",ThriftKsDef.DEF_STRATEGY_CLASS,1,Arrays.asList(cfDef));
  cluster.addKeyspace(newKeyspace,true);
}","private void createStructure(Cluster cluster){
  dropStructure(cluster);
  ColumnFamilyDefinition cfDef=HFactory.createColumnFamilyDefinition(""String_Node_Str"",""String_Node_Str"",ComparatorType.BYTESTYPE);
  KeyspaceDefinition keyspaceDef=cluster.describeKeyspace(""String_Node_Str"");
  if (keyspaceDef == null) {
    KeyspaceDefinition newKeyspace=HFactory.createKeyspaceDefinition(""String_Node_Str"",ThriftKsDef.DEF_STRATEGY_CLASS,1,Arrays.asList(cfDef));
    cluster.addKeyspace(newKeyspace,true);
  }
}",0.7387198321091291
186153,"private ColumnFamilyTemplate<String,String> columnFamilyTemplate(String clusterName,String host,String keyspaceName){
  Cluster cluster=HFactory.getOrCreateCluster(clusterName,host);
  Keyspace keyspace=HFactory.createKeyspace(keyspaceName,cluster);
  return new ThriftColumnFamilyTemplate<String,String>(keyspace,""String_Node_Str"",StringSerializer.get(),StringSerializer.get());
}","private ColumnFamilyTemplate<String,String> columnFamilyTemplate(Cluster cluster,String clusterName,String host,String keyspaceName){
  Keyspace keyspace=HFactory.createKeyspace(keyspaceName,cluster);
  return new ThriftColumnFamilyTemplate<String,String>(keyspace,""String_Node_Str"",StringSerializer.get(),StringSerializer.get());
}",0.8387096774193549
186154,"@Override protected int getPort(){
  return PORT;
}","@Override protected int getPort(){
  return port;
}",0.9215686274509804
186155,"@Test public void embedded_cassandra_should_be_configured_with_default_parameters(){
  CassandraConfiguration embeddedConfiguration=newEmbeddedCassandraConfiguration().clusterName(""String_Node_Str"").build();
  assertThat(embeddedConfiguration.getClusterName(),is(""String_Node_Str""));
  assertThat(embeddedConfiguration.getHost(),is(""String_Node_Str""));
  assertThat(embeddedConfiguration.getPort(),is(EmbeddedCassandra.PORT));
}","@Test public void embedded_cassandra_should_be_configured_with_default_parameters(){
  CassandraConfiguration embeddedConfiguration=newEmbeddedCassandraConfiguration().clusterName(""String_Node_Str"").build();
  assertThat(embeddedConfiguration.getClusterName(),is(""String_Node_Str""));
  assertThat(embeddedConfiguration.getHost(),is(""String_Node_Str""));
  assertThat(embeddedConfiguration.getPort(),is(EmbeddedCassandra.DEFAULT_PORT));
}",0.9907407407407408
186156,"@Test public void embedded_parameter_values_should_contain_default_values(){
  CassandraConfiguration embeddedConfiguration=newEmbeddedCassandraConfiguration().clusterName(""String_Node_Str"").build();
  assertThat(embeddedConfiguration.getHost(),is(""String_Node_Str""));
  assertThat(embeddedConfiguration.getPort(),is(EmbeddedCassandra.PORT));
  assertThat(embeddedConfiguration.getClusterName(),is(""String_Node_Str""));
}","@Test public void embedded_parameter_values_should_contain_default_values(){
  CassandraConfiguration embeddedConfiguration=newEmbeddedCassandraConfiguration().clusterName(""String_Node_Str"").build();
  assertThat(embeddedConfiguration.getHost(),is(""String_Node_Str""));
  assertThat(embeddedConfiguration.getPort(),is(EmbeddedCassandra.DEFAULT_PORT));
  assertThat(embeddedConfiguration.getClusterName(),is(""String_Node_Str""));
}",0.9905660377358492
186157,"@Test public void embedded_cassandra_should_be_registered_and_started_with_custom_parameters() throws Throwable {
  EmbeddedCassandra cassandraRule=newEmbeddedCassandraRule().targetPath(""String_Node_Str"").cassandraConfigurationPath(""String_Node_Str"").build();
  cassandraRule.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
  Statement noStatement=new Statement(){
    @Override public void evaluate() throws Throwable {
      assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(true));
    }
  }
;
  Statement decotedStatement=cassandraRule.apply(noStatement,Description.EMPTY);
  decotedStatement.evaluate();
  verify(embeddedCassandraServerHelper).startEmbeddedCassandra(""String_Node_Str"",""String_Node_Str"");
  verify(embeddedCassandraServerHelper).stopEmbeddedCassandra();
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(false));
}","@Test public void embedded_cassandra_should_be_registered_and_started_with_custom_parameters() throws Throwable {
  EmbeddedCassandra cassandraRule=newEmbeddedCassandraRule().targetPath(""String_Node_Str"").cassandraConfigurationPath(""String_Node_Str"").build();
  cassandraRule.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
  Statement noStatement=new Statement(){
    @Override public void evaluate() throws Throwable {
      assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(true));
    }
  }
;
  Statement decotedStatement=cassandraRule.apply(noStatement,Description.EMPTY);
  decotedStatement.evaluate();
  verify(embeddedCassandraServerHelper).startEmbeddedCassandra(""String_Node_Str"",""String_Node_Str"");
  verify(embeddedCassandraServerHelper).stopEmbeddedCassandra();
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(false));
}",0.992079207920792
186158,"@Test public void embedded_cassandra_should_be_registered_and_started_with_default_parameters() throws Throwable {
  EmbeddedCassandra cassandraRule=newEmbeddedCassandraRule().build();
  cassandraRule.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
  Statement noStatement=new Statement(){
    @Override public void evaluate() throws Throwable {
      assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(true));
    }
  }
;
  Statement decotedStatement=cassandraRule.apply(noStatement,Description.EMPTY);
  decotedStatement.evaluate();
  verify(embeddedCassandraServerHelper).startEmbeddedCassandra(EmbeddedCassandra.DEFAULT_CASSANDRA_CONFIGURATION_FILE_LOCATION,EmbeddedCassandra.DEFAULT_CASSANDRA_TARGET_PATH);
  verify(embeddedCassandraServerHelper).stopEmbeddedCassandra();
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(false));
}","@Test public void embedded_cassandra_should_be_registered_and_started_with_default_parameters() throws Throwable {
  EmbeddedCassandra cassandraRule=newEmbeddedCassandraRule().build();
  cassandraRule.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
  Statement noStatement=new Statement(){
    @Override public void evaluate() throws Throwable {
      assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(true));
    }
  }
;
  Statement decotedStatement=cassandraRule.apply(noStatement,Description.EMPTY);
  decotedStatement.evaluate();
  verify(embeddedCassandraServerHelper).startEmbeddedCassandra(EmbeddedCassandra.DEFAULT_CASSANDRA_CONFIGURATION_FILE_LOCATION,EmbeddedCassandra.DEFAULT_CASSANDRA_TARGET_PATH);
  verify(embeddedCassandraServerHelper).stopEmbeddedCassandra();
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(false));
}",0.9920870425321464
186159,"@Test public void simulataneous_cassandra_should_start_only_one_instance() throws Throwable {
  EmbeddedCassandra cassandraRule=newEmbeddedCassandraRule().build();
  cassandraRule.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
  Statement noStatement=new Statement(){
    @Override public void evaluate() throws Throwable {
      EmbeddedCassandra defaultEmbeddedCassandra=newEmbeddedCassandraRule().build();
      defaultEmbeddedCassandra.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
      Statement defaultNoStatement=new Statement(){
        @Override public void evaluate() throws Throwable {
          assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(true));
        }
      }
;
      Statement defaultStatement=defaultEmbeddedCassandra.apply(defaultNoStatement,Description.EMPTY);
      defaultStatement.evaluate();
      assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(true));
    }
  }
;
  Statement decotedStatement=cassandraRule.apply(noStatement,Description.EMPTY);
  decotedStatement.evaluate();
  verify(embeddedCassandraServerHelper).startEmbeddedCassandra(EmbeddedCassandra.DEFAULT_CASSANDRA_CONFIGURATION_FILE_LOCATION,EmbeddedCassandra.DEFAULT_CASSANDRA_TARGET_PATH);
  verify(embeddedCassandraServerHelper).stopEmbeddedCassandra();
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(false));
}","@Test public void simulataneous_cassandra_should_start_only_one_instance() throws Throwable {
  EmbeddedCassandra cassandraRule=newEmbeddedCassandraRule().build();
  cassandraRule.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
  Statement noStatement=new Statement(){
    @Override public void evaluate() throws Throwable {
      EmbeddedCassandra defaultEmbeddedCassandra=newEmbeddedCassandraRule().build();
      defaultEmbeddedCassandra.setEmbeddedCassandraServerHelper(embeddedCassandraServerHelper);
      Statement defaultNoStatement=new Statement(){
        @Override public void evaluate() throws Throwable {
          assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(true));
        }
      }
;
      Statement defaultStatement=defaultEmbeddedCassandra.apply(defaultNoStatement,Description.EMPTY);
      defaultStatement.evaluate();
      assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(true));
    }
  }
;
  Statement decotedStatement=cassandraRule.apply(noStatement,Description.EMPTY);
  decotedStatement.evaluate();
  verify(embeddedCassandraServerHelper).startEmbeddedCassandra(EmbeddedCassandra.DEFAULT_CASSANDRA_CONFIGURATION_FILE_LOCATION,EmbeddedCassandra.DEFAULT_CASSANDRA_TARGET_PATH);
  verify(embeddedCassandraServerHelper).stopEmbeddedCassandra();
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(false));
}",0.9924385633270322
186160,"@Override public void evaluate() throws Throwable {
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.PORT),is(true));
}","@Override public void evaluate() throws Throwable {
  assertThat(ConnectionManagement.getInstance().isConnectionRegistered(EmbeddedCassandra.LOCALHOST,EmbeddedCassandra.DEFAULT_PORT),is(true));
}",0.9790575916230366
186161,"private void dropKeyspaces(){
  Cluster cluster=HFactory.getOrCreateCluster(this.cassandraConfiguration.getClusterName(),new CassandraHostConfigurator(getFullHost()));
  List<KeyspaceDefinition> keyspaces=cluster.describeKeyspaces();
  for (  KeyspaceDefinition keyspaceDefinition : keyspaces) {
    String keyspaceName=keyspaceDefinition.getName();
    if (!INTERNAL_CASSANDRA_KEYSPACE.equals(keyspaceName)) {
      cluster.dropKeyspace(keyspaceName);
    }
  }
}","private void dropKeyspaces(){
  List<KeyspaceDefinition> keyspaces=cluster.describeKeyspaces();
  for (  KeyspaceDefinition keyspaceDefinition : keyspaces) {
    String keyspaceName=keyspaceDefinition.getName();
    if (!INTERNAL_CASSANDRA_KEYSPACE.equals(keyspaceName)) {
      cluster.dropKeyspace(keyspaceName);
    }
  }
  List<KeyspaceDefinition> keyspaces2=cluster.describeKeyspaces();
}",0.7607934655775963
186162,"@Override public void insert(InputStream dataScript){
  InputStreamJsonDataSet dataSet=new InputStreamJsonDataSet(dataScript);
  DataLoader dataLoader=new DataLoader(cassandraConfiguration.getClusterName(),getFullHost());
  dataLoader.load(dataSet);
  cluster=HFactory.getOrCreateCluster(cassandraConfiguration.getClusterName(),getFullHost());
  keyspace=HFactory.createKeyspace(dataSet.getKeyspace().getName(),cluster);
}","@Override public void insert(InputStream dataScript){
  InputStreamJsonDataSet dataSet=new InputStreamJsonDataSet(dataScript);
  DataLoader dataLoader=new DataLoader(cassandraConfiguration.getClusterName(),getFullHost());
  dataLoader.load(dataSet);
  keyspace=HFactory.createKeyspace(dataSet.getKeyspace().getName(),cluster);
}",0.728
186163,"public CassandraOperation(CassandraConfiguration cassandraConfiguration){
  this.cassandraConfiguration=cassandraConfiguration;
}","public CassandraOperation(CassandraConfiguration cassandraConfiguration){
  this.cassandraConfiguration=cassandraConfiguration;
  cluster=HFactory.getOrCreateCluster(cassandraConfiguration.getClusterName(),getFullHost());
}",0.7329545454545454
186164,"@Override protected void doStop(){
  stopCassandra();
}","@Override protected void doStop(){
  try {
    stopCassandra();
  }
  finally {
    ensureTargetPathDoesNotExitsAndReturnCompositePath();
  }
}",0.5555555555555556
186165,"@Override public void run(){
  try {
    startCassandraAsDaemon();
    startupLatch.countDown();
  }
 catch (  InterruptedException e) {
    throw new IllegalStateException(e);
  }
}","@Override public void run(){
  try {
    startCassandraProcess();
    startupLatch.countDown();
  }
 catch (  InterruptedException e) {
    throw new IllegalStateException(e);
  }
}",0.9641873278236914
186166,"private List<String> startCassandraAsDaemon() throws InterruptedException {
  try {
    pwd=startProcess();
    pwd.waitFor();
    if (pwd.exitValue() != 0) {
      List<String> consoleOutput=getConsoleOutput(pwd);
      throw new IllegalStateException(""String_Node_Str"" + cassandraPath + ""String_Node_Str""+ port+ ""String_Node_Str""+ consoleOutput);
    }
    return null;
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"" + cassandraPath + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
}","private void startCassandraAsDaemon() throws AssertionError {
  final CountDownLatch startupLatch=new CountDownLatch(1);
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        startCassandraProcess();
        startupLatch.countDown();
      }
 catch (      InterruptedException e) {
        throw new IllegalStateException(e);
      }
    }
  }
).start();
  try {
    startupLatch.await(10,SECONDS);
  }
 catch (  InterruptedException e) {
    throw new AssertionError(e);
  }
}",0.2349514563106796
186167,"@Override protected void doStart() throws Throwable {
  final CountDownLatch startupLatch=new CountDownLatch(1);
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        startCassandraAsDaemon();
        startupLatch.countDown();
      }
 catch (      InterruptedException e) {
        throw new IllegalStateException(e);
      }
    }
  }
).start();
  try {
    startupLatch.await(10,SECONDS);
  }
 catch (  InterruptedException e) {
    throw new AssertionError(e);
  }
}","@Override protected void doStart() throws Throwable {
  File targetPathDirectory=ensureTargetPathDoesNotExitsAndReturnCompositePath();
  if (targetPathDirectory.mkdirs()) {
    startCassandraAsDaemon();
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + targetPathDirectory + ""String_Node_Str"");
  }
}",0.2769607843137255
186168,"private static void checkColumnValue(RowModel expectedRowModel,HColumn<byte[],byte[]> hColumn) throws Error {
  byte[] expectedColumnName=hColumn.getName();
  byte[] expectedColumnValue=hColumn.getValue();
  if (!areLoadValuesOnExpectedList(expectedRowModel.getColumns(),expectedColumnName,expectedColumnValue)) {
    throw FailureHandler.createFailure(""String_Node_Str"",expectedRowModel.getKey().getValue(),new String(expectedColumnName),new String(expectedColumnValue));
  }
}","private static void checkColumnValue(RowModel expectedRowModel,HColumn<byte[],byte[]> hColumn) throws Error {
  byte[] expectedColumnName=hColumn.getName();
  byte[] expectedColumnValue=hColumn.getValue();
  if (!areLoadValuesOnExpectedList(expectedRowModel.getColumns(),expectedColumnName,expectedColumnValue)) {
    throw FailureHandler.createFailure(""String_Node_Str"",asString(expectedRowModel.getKey()),new String(expectedColumnName),new String(expectedColumnValue));
  }
}",0.9801047120418848
186169,"private static int countNumberOfColumnsByKey(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel){
  QueryResult<Integer> qr=HFactory.createCountQuery(keyspace,StringSerializer.get(),StringSerializer.get()).setColumnFamily(expectedColumnFamilyName).setKey(expectedRowModel.getKey().getValue()).setRange(null,null,1000000000).execute();
  int numberOfColumns=qr.get();
  return numberOfColumns;
}","private static int countNumberOfColumnsByKey(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel){
  QueryResult<Integer> qr=HFactory.createCountQuery(keyspace,GenericTypeSerializer.get(),StringSerializer.get()).setColumnFamily(expectedColumnFamilyName).setKey(expectedRowModel.getKey()).setRange(null,null,1000000000).execute();
  int numberOfColumns=qr.get();
  return numberOfColumns;
}",0.966346153846154
186170,"private static void checkNumberOfSuperColumns(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel,int size) throws Error {
  int countNumberOfSuperColumnsByKey=countNumberOfColumnsByKey(keyspace,expectedColumnFamilyName,expectedRowModel);
  if (countNumberOfSuperColumnsByKey != size) {
    throw FailureHandler.createFailure(""String_Node_Str"",expectedRowModel.getKey().getValue(),size,countNumberOfSuperColumnsByKey);
  }
}","private static void checkNumberOfSuperColumns(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel,int size) throws Error {
  int countNumberOfSuperColumnsByKey=countNumberOfColumnsByKey(keyspace,expectedColumnFamilyName,expectedRowModel);
  if (countNumberOfSuperColumnsByKey != size) {
    throw FailureHandler.createFailure(""String_Node_Str"",asString(expectedRowModel.getKey()),size,countNumberOfSuperColumnsByKey);
  }
}",0.9787709497206704
186171,"private static void checkColumnsOfSuperColumn(RowModel expectedRowModel,SuperColumnModel expectedSuperColumnModel,List<ColumnModel> expectedColumns,List<HColumn<byte[],byte[]>> columns) throws Error {
  for (  HColumn<byte[],byte[]> hColumn : columns) {
    if (!areLoadValuesOnExpectedList(expectedColumns,hColumn.getName(),hColumn.getValue())) {
      throw FailureHandler.createFailure(""String_Node_Str"",expectedRowModel.getKey().getValue(),expectedSuperColumnModel.getName().getValue());
    }
  }
}","private static void checkColumnsOfSuperColumn(RowModel expectedRowModel,SuperColumnModel expectedSuperColumnModel,List<ColumnModel> expectedColumns,List<HColumn<byte[],byte[]>> columns) throws Error {
  for (  HColumn<byte[],byte[]> hColumn : columns) {
    if (!areLoadValuesOnExpectedList(expectedColumns,hColumn.getName(),hColumn.getValue())) {
      throw FailureHandler.createFailure(""String_Node_Str"",asString(expectedRowModel.getKey()),expectedSuperColumnModel.getName().getValue());
    }
  }
}",0.981094527363184
186172,"private static void checkNumberOfColumns(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel) throws Error {
  int numberOfColumns=countNumberOfColumnsByKey(keyspace,expectedColumnFamilyName,expectedRowModel);
  int expectedNumberOfColumns=expectedRowModel.getColumns().size();
  if (numberOfColumns != expectedNumberOfColumns) {
    throw FailureHandler.createFailure(""String_Node_Str"",expectedRowModel.getKey().getValue(),expectedNumberOfColumns,numberOfColumns);
  }
}","private static void checkNumberOfColumns(Keyspace keyspace,String expectedColumnFamilyName,RowModel expectedRowModel) throws Error {
  int numberOfColumns=countNumberOfColumnsByKey(keyspace,expectedColumnFamilyName,expectedRowModel);
  int expectedNumberOfColumns=expectedRowModel.getColumns().size();
  if (numberOfColumns != expectedNumberOfColumns) {
    throw FailureHandler.createFailure(""String_Node_Str"",asString(expectedRowModel.getKey()),expectedNumberOfColumns,numberOfColumns);
  }
}",0.980788675429727
186173,"private static void checkColumnName(ColumnModel expectedColumnModel,HColumn<byte[],byte[]> hColumn) throws Error {
  if (hColumn == null) {
    throw FailureHandler.createFailure(""String_Node_Str"",expectedColumnModel.getName().getValue());
  }
}","private static void checkColumnName(ColumnModel expectedColumnModel,HColumn<byte[],byte[]> hColumn) throws Error {
  if (hColumn == null) {
    throw FailureHandler.createFailure(""String_Node_Str"",asString(expectedColumnModel.getName()));
  }
}",0.9611451942740288
186174,"private static void checkNotStandardColumnsInSuperColumns(RowModel expectedRowModel,int size) throws Error {
  if (size > 0) {
    throw FailureHandler.createFailure(""String_Node_Str"",expectedRowModel.getKey().getValue());
  }
}","private static void checkNotStandardColumnsInSuperColumns(RowModel expectedRowModel,int size) throws Error {
  if (size > 0) {
    throw FailureHandler.createFailure(""String_Node_Str"",asString(expectedRowModel.getKey()));
  }
}",0.9582417582417584
186175,"@Override public Object connectionManager(){
  return keyspace;
}","@Override public Keyspace connectionManager(){
  return keyspace;
}",0.9242424242424242
186176,"@Override public DatabaseOperation getDatabaseOperation(){
  return databaseOperation;
}","@Override public DatabaseOperation<Keyspace> getDatabaseOperation(){
  return databaseOperation;
}",0.946236559139785
186177,Object connectionManager();,T connectionManager();,0.8571428571428571
186178,"private long getStartOfTimeRange(long millisNow){
  return EndedSometimeAgo.fromValue(PreferenceManager.getDefaultSharedPreferences(context).getString(PREF_EVENTS_ENDED,""String_Node_Str"")).endedAt(millisNow);
}","private long getStartOfTimeRange(long millisNow){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  int period=Integer.valueOf(prefs.getString(PREF_EVENTS_START,PREF_EVENTS_START_DEFAULT));
  if (period == PREF_EVENTS_START_TODAY) {
    return new DateTime(millisNow).withTimeAtStartOfDay().getMillis();
  }
 else   if (period == 0) {
    return millisNow;
  }
  return new DateTime(millisNow).minusHours(period).getMillis();
}",0.172876304023845
186179,"private List<CalendarEvent> getTimeFilteredEventList(){
  long millisNow=System.currentTimeMillis();
  Uri.Builder builder=Instances.CONTENT_URI.buildUpon();
  ContentUris.appendId(builder,getStartOfTimeRange(millisNow));
  ContentUris.appendId(builder,getEndOfTimeRange(millisNow));
  Cursor cursor=context.getContentResolver().query(builder.build(),getProjection(),getCalendarSelection(),null,EVENT_SORT_ORDER);
  List<CalendarEvent> eventList=new ArrayList<>();
  if (cursor != null) {
    eventList=cursor2TimeFilteredEventList(cursor);
    cursor.close();
  }
  return eventList;
}","private List<CalendarEvent> getTimeFilteredEventList(){
  long millisNow=System.currentTimeMillis();
  Uri.Builder builder=Instances.CONTENT_URI.buildUpon();
  ContentUris.appendId(builder,getStartOfTimeRange(millisNow));
  ContentUris.appendId(builder,getEndOfTimeRange(millisNow));
  Cursor cursor=context.getContentResolver().query(builder.build(),getProjection(),getCalendarSelection(),null,EVENT_SORT_ORDER);
  List<CalendarEvent> eventList=new ArrayList<>();
  if (cursor != null) {
    eventList=cursorToTimeFilteredEventList(cursor);
    cursor.close();
  }
  return eventList;
}",0.9974424552429668
186180,"public List<CalendarEvent> getEvents(){
  List<CalendarEvent> eventList=getTimeFilteredEventList();
  for (  CalendarEvent event : getPastEventWithColorList()) {
    if (!eventList.contains(event)) {
      eventList.add(event);
    }
  }
  Collections.sort(eventList);
  return eventList;
}","public List<CalendarEvent> getEvents(){
  List<CalendarEvent> eventList=getTimeFilteredEventList();
  Collections.sort(eventList);
  return eventList;
}",0.6877828054298643
186181,"private void setupDayOneEntry(List<CalendarEvent> eventList,CalendarEvent event){
  if (isEqualOrAfterTodayAtMidnight(event.getStartDate())) {
    if (event.daysSpanned() > 1) {
      CalendarEvent clone=event.clone();
      clone.setEndDate(event.getStartDay().plusDays(1));
      clone.setSpansMultipleDays(true);
      clone.setOriginalEvent(event);
      eventList.add(clone);
    }
 else {
      eventList.add(event);
    }
  }
}","private void setupDayOneEntry(List<CalendarEvent> eventList,CalendarEvent event){
  if (isEqualOrAfterStartOfPeriod(event.getStartDate())) {
    if (event.daysSpanned() > 1) {
      CalendarEvent clone=event.clone();
      clone.setEndDate(event.getStartDay().plusDays(1));
      clone.setSpansMultipleDays(true);
      clone.setOriginalEvent(event);
      eventList.add(clone);
    }
 else {
      eventList.add(event);
    }
  }
}",0.9676674364896074
186182,"private List<CalendarEvent> getTimeFilteredEventList(){
  long millisNow=System.currentTimeMillis();
  Uri.Builder builder=Instances.CONTENT_URI.buildUpon();
  ContentUris.appendId(builder,getStartOfTimeRange(millisNow));
  ContentUris.appendId(builder,getEndOfTimeRange(millisNow));
  Cursor cursor=context.getContentResolver().query(builder.build(),getProjection(),getCalendarSelection(),null,EVENT_SORT_ORDER);
  List<CalendarEvent> eventList=new ArrayList<>();
  if (cursor != null) {
    eventList=cursorToTimeFilteredEventList(cursor);
    cursor.close();
  }
  return eventList;
}","private List<CalendarEvent> getTimeFilteredEventList(){
  long millisNow=System.currentTimeMillis();
  Uri.Builder builder=Instances.CONTENT_URI.buildUpon();
  ContentUris.appendId(builder,getStartOfPeriod(millisNow).getMillis());
  ContentUris.appendId(builder,getEndOfPeriod(millisNow).getMillis());
  Cursor cursor=context.getContentResolver().query(builder.build(),getProjection(),getCalendarSelection(),null,EVENT_SORT_ORDER);
  List<CalendarEvent> eventList=new ArrayList<>();
  if (cursor != null) {
    eventList=cursorToTimeFilteredEventList(cursor);
    cursor.close();
  }
  return eventList;
}",0.9513422818791948
186183,"private void createFollowingEntries(List<CalendarEvent> eventList,CalendarEvent event){
  int daysCovered=event.daysSpanned();
  for (int j=1; j < daysCovered; j++) {
    DateTime startDate=event.getStartDay().plusDays(j);
    if (isEqualOrAfterTodayAtMidnight(startDate)) {
      DateTime endDate;
      if (j < daysCovered - 1) {
        endDate=startDate.plusDays(1);
      }
 else {
        endDate=event.getEndDate();
      }
      eventList.add(cloneAsSpanningEvent(event,startDate,endDate));
    }
  }
}","private void createFollowingEntries(List<CalendarEvent> eventList,CalendarEvent event){
  int daysCovered=event.daysSpanned();
  for (int j=1; j < daysCovered; j++) {
    DateTime startDate=event.getStartDay().plusDays(j);
    if (isEqualOrAfterStartOfPeriod(startDate)) {
      DateTime endDate;
      if (j < daysCovered - 1) {
        endDate=startDate.plusDays(1);
      }
 else {
        endDate=event.getEndDate();
      }
      eventList.add(cloneAsSpanningEvent(event,startDate,endDate));
    }
  }
}",0.9724950884086444
186184,"static Intent createOpenCalendarAtDayIntent(Context context,DateTime goToTime){
  Intent launchIntent=createCalendarIntent(Intent.ACTION_VIEW);
  Uri.Builder builder=CalendarContract.CONTENT_URI.buildUpon();
  builder.appendPath(TIME);
  if (goToTime.getMillis() != 0) {
    launchIntent.putExtra(KEY_DETAIL_VIEW,true);
    ContentUris.appendId(builder,goToTime.getMillis());
  }
  launchIntent.setData(builder.build());
  return launchIntent;
}","static Intent createOpenCalendarAtDayIntent(DateTime goToTime){
  Intent launchIntent=createCalendarIntent();
  Uri.Builder builder=CalendarContract.CONTENT_URI.buildUpon();
  builder.appendPath(TIME);
  if (goToTime.getMillis() != 0) {
    launchIntent.putExtra(KEY_DETAIL_VIEW,true);
    ContentUris.appendId(builder,goToTime.getMillis());
  }
  launchIntent.setData(builder.build());
  return launchIntent;
}",0.9602803738317756
186185,"private static Intent createCalendarIntent(String action){
  Intent intent=new Intent(action);
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  return intent;
}","private static Intent createCalendarIntent(){
  Intent intent=new Intent(Intent.ACTION_VIEW);
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  return intent;
}",0.9227557411273486
186186,"public static Intent createOpenCalendarEventIntent(int eventId,DateTime from,DateTime to){
  Intent intent=createCalendarIntent(Intent.ACTION_VIEW);
  intent.setData(ContentUris.withAppendedId(Events.CONTENT_URI,eventId));
  intent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME,from.getMillis());
  intent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME,to.getMillis());
  return intent;
}","public static Intent createOpenCalendarEventIntent(int eventId,DateTime from,DateTime to){
  Intent intent=createCalendarIntent();
  intent.setData(ContentUris.withAppendedId(Events.CONTENT_URI,eventId));
  intent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME,from.getMillis());
  intent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME,to.getMillis());
  return intent;
}",0.9764397905759162
186187,"static PendingIntent createOpenCalendarEventPendingIntent(Context context){
  Intent intent=createCalendarIntent(Intent.ACTION_VIEW);
  return PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
}","static PendingIntent createOpenCalendarEventPendingIntent(Context context){
  Intent intent=createCalendarIntent();
  return PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
}",0.9579439252336448
186188,"public static boolean isIntentAvailable(Context context,Intent intent){
  PackageManager packageManager=context.getPackageManager();
  List<ResolveInfo> list=packageManager.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY);
  return list.size() > 0;
}","private static boolean isIntentAvailable(Context context,Intent intent){
  PackageManager packageManager=context.getPackageManager();
  List<ResolveInfo> list=packageManager.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY);
  return list.size() > 0;
}",0.9792843691148776
186189,"public void configureActionBar(Context context,RemoteViews rv){
  String formattedDate=DateUtils.formatDateTime(context,System.currentTimeMillis(),DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY);
  rv.setTextViewText(R.id.calendar_current_date,formattedDate.toUpperCase(Locale.getDefault()));
  setTextColorRes(context,rv,R.id.calendar_current_date,R.attr.header);
  Intent startConfigIntent=new Intent(context,WidgetConfigurationActivity.class);
  PendingIntent menuPendingIntent=PendingIntent.getActivity(context,0,startConfigIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  rv.setOnClickPendingIntent(R.id.overflow_menu,menuPendingIntent);
  Intent intent=CalendarIntentUtil.createNewEventIntent();
  if (isIntentAvailable(context,intent)) {
    PendingIntent pendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
    rv.setOnClickPendingIntent(R.id.add_event,pendingIntent);
  }
 else {
    rv.setViewVisibility(R.id.add_event,View.GONE);
  }
}","private void configureActionBar(Context context,RemoteViews rv){
  String formattedDate=DateUtils.formatDateTime(context,System.currentTimeMillis(),DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY);
  rv.setTextViewText(R.id.calendar_current_date,formattedDate.toUpperCase(Locale.getDefault()));
  setTextColorRes(context,rv,R.id.calendar_current_date,R.attr.header);
  Intent startConfigIntent=new Intent(context,WidgetConfigurationActivity.class);
  PendingIntent menuPendingIntent=PendingIntent.getActivity(context,0,startConfigIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  rv.setOnClickPendingIntent(R.id.overflow_menu,menuPendingIntent);
  Intent intent=CalendarIntentUtil.createNewEventIntent();
  if (isIntentAvailable(context,intent)) {
    PendingIntent pendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
    rv.setOnClickPendingIntent(R.id.add_event,pendingIntent);
  }
 else {
    rv.setViewVisibility(R.id.add_event,View.GONE);
  }
}",0.994475138121547
186190,"public void configureBackground(Context context,RemoteViews rv){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  if (prefs.getBoolean(PREF_SHOW_HEADER,true)) {
    rv.setViewVisibility(R.id.action_bar,View.VISIBLE);
  }
 else {
    rv.setViewVisibility(R.id.action_bar,View.GONE);
  }
  int color=prefs.getInt(PREF_BACKGROUND_COLOR,PREF_BACKGROUND_COLOR_DEFAULT);
  setColorFilter(rv,R.id.background_image,color);
  setAlpha(rv,R.id.background_image,Color.alpha(color));
}","private void configureBackground(Context context,RemoteViews rv){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  if (prefs.getBoolean(PREF_SHOW_HEADER,true)) {
    rv.setViewVisibility(R.id.action_bar,View.VISIBLE);
  }
 else {
    rv.setViewVisibility(R.id.action_bar,View.GONE);
  }
  int color=prefs.getInt(PREF_BACKGROUND_COLOR,PREF_BACKGROUND_COLOR_DEFAULT);
  setColorFilter(rv,R.id.background_image,color);
  setAlpha(rv,R.id.background_image,Color.alpha(color));
}",0.9891838741396264
186191,"public void configureList(Context context,int widgetId,RemoteViews rv){
  Intent intent=new Intent(context,EventWidgetService.class);
  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,widgetId);
  intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
  rv.setRemoteAdapter(R.id.event_list,intent);
  rv.setEmptyView(R.id.event_list,R.id.empty_event_list);
  rv.setPendingIntentTemplate(R.id.event_list,createOpenCalendarEventPendingIntent(context));
  rv.setOnClickFillInIntent(R.id.empty_event_list,createOpenCalendarAtDayIntent(context,new DateTime()));
  setTextColorRes(context,rv,R.id.empty_event_list,R.attr.eventEntryTitle);
}","private void configureList(Context context,int widgetId,RemoteViews rv){
  Intent intent=new Intent(context,EventWidgetService.class);
  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,widgetId);
  intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
  rv.setRemoteAdapter(R.id.event_list,intent);
  rv.setEmptyView(R.id.event_list,R.id.empty_event_list);
  rv.setPendingIntentTemplate(R.id.event_list,createOpenCalendarEventPendingIntent(context));
  rv.setOnClickFillInIntent(R.id.empty_event_list,createOpenCalendarAtDayIntent(new DateTime()));
  setTextColorRes(context,rv,R.id.empty_event_list,R.attr.eventEntryTitle);
}",0.9280742459396752
186192,"public RemoteViews updateDayHeader(DayHeader dayHeader){
  RemoteViews rv=new RemoteViews(context.getPackageName(),R.layout.day_header);
  rv.setTextViewText(R.id.day_header_title,createDayEntryString(dayHeader));
  setTextSize(context,rv,R.id.day_header_title,R.dimen.day_header_title);
  setTextColorRes(context,rv,R.id.day_header_title,R.attr.dayHeaderTitle);
  setBackgroundColorRes(context,rv,R.id.day_header_separator,R.attr.dayHeaderSeparator);
  setPadding(context,rv,R.id.day_header_title,0,R.dimen.day_header_padding_top,R.dimen.day_header_padding_right,R.dimen.day_header_padding_bottom);
  Intent intent=createOpenCalendarAtDayIntent(context,dayHeader.getStartDate());
  rv.setOnClickFillInIntent(R.id.day_header,intent);
  return rv;
}","public RemoteViews updateDayHeader(DayHeader dayHeader){
  RemoteViews rv=new RemoteViews(context.getPackageName(),R.layout.day_header);
  rv.setTextViewText(R.id.day_header_title,createDayEntryString(dayHeader));
  setTextSize(context,rv,R.id.day_header_title,R.dimen.day_header_title);
  setTextColorRes(context,rv,R.id.day_header_title,R.attr.dayHeaderTitle);
  setBackgroundColorRes(context,rv,R.id.day_header_separator,R.attr.dayHeaderSeparator);
  setPadding(context,rv,R.id.day_header_title,0,R.dimen.day_header_padding_top,R.dimen.day_header_padding_right,R.dimen.day_header_padding_bottom);
  Intent intent=createOpenCalendarAtDayIntent(dayHeader.getStartDate());
  rv.setOnClickFillInIntent(R.id.day_header,intent);
  return rv;
}",0.9946236559139784
186193,"public String createDayEntryString(DayHeader dayEntry){
  Date date=dayEntry.getStartDate().toDate();
  if (dayEntry.isToday()) {
    return createDateString(date,context.getString(R.string.today));
  }
 else   if (dayEntry.isTomorrow()) {
    return createDateString(date,context.getString(R.string.tomorrow));
  }
  return DateUtils.formatDateTime(context,date.getTime(),DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY).toUpperCase(Locale.getDefault());
}","private String createDayEntryString(DayHeader dayEntry){
  Date date=dayEntry.getStartDate().toDate();
  if (dayEntry.isToday()) {
    return createDateString(date,context.getString(R.string.today));
  }
 else   if (dayEntry.isTomorrow()) {
    return createDateString(date,context.getString(R.string.tomorrow));
  }
  return DateUtils.formatDateTime(context,date.getTime(),DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY).toUpperCase(Locale.getDefault());
}",0.9882604055496264
186194,"private String createDateString(Date date,String text){
  return text + COMMA_SPACE + DateUtils.formatDateTime(context,date.getTime(),DateUtils.FORMAT_SHOW_DATE).toUpperCase(Locale.getDefault());
}","protected String createDateString(Date date,String text){
  return text + COMMA_SPACE + DateUtils.formatDateTime(context,date.getTime(),DateUtils.FORMAT_SHOW_DATE).toUpperCase(Locale.getDefault());
}",0.9797979797979798
186195,"public CalendarEvent cloneAsSpanningEvent(CalendarEvent eventEntry,DateTime startDate,DateTime endDate){
  CalendarEvent clone=eventEntry.clone();
  clone.setStartDate(startDate);
  clone.setEndDate(endDate);
  clone.setSpansMultipleDays(true);
  clone.setOriginalEvent(eventEntry);
  return clone;
}","private CalendarEvent cloneAsSpanningEvent(CalendarEvent eventEntry,DateTime startDate,DateTime endDate){
  CalendarEvent clone=eventEntry.clone();
  clone.setStartDate(startDate);
  clone.setEndDate(endDate);
  clone.setSpansMultipleDays(true);
  clone.setOriginalEvent(eventEntry);
  return clone;
}",0.9816971713810316
186196,"public int getEntryColor(Cursor calendarCursor){
  int eventColor=calendarCursor.getInt(6);
  if (eventColor > 0) {
    return eventColor;
  }
  return calendarCursor.getInt(5);
}","private int getEntryColor(Cursor calendarCursor){
  int eventColor=calendarCursor.getInt(6);
  if (eventColor > 0) {
    return eventColor;
  }
  return calendarCursor.getInt(5);
}",0.9749303621169916
186197,"public boolean isEqualOrAfterTodayAtMidnight(DateTime startDate){
  DateMidnight midnight=new DateMidnight();
  return startDate.isEqual(midnight) || startDate.isAfter(midnight);
}","private boolean isEqualOrAfterTodayAtMidnight(DateTime startDate){
  DateMidnight midnight=new DateMidnight();
  return startDate.isEqual(midnight) || startDate.isAfter(midnight);
}",0.9750692520775625
186198,"public String createTimeSpanString(CalendarEvent event){
  String startStr;
  String endStr;
  String separator=SPACE_DASH_SPACE;
  if (event.isPartOfMultiDayEvent() && DateUtil.isMidnight(event.getStartDate()) && !event.isStartOfMultiDayEvent()) {
    startStr=ARROW_SPACE;
    separator=EMPTY_STRING;
  }
 else {
    startStr=createTimeString(event.getStartDate());
  }
  if (prefs.getBoolean(PREF_SHOW_END_TIME,PREF_SHOW_END_TIME_DEFAULT)) {
    if (event.isPartOfMultiDayEvent() && DateUtil.isMidnight(event.getEndDate()) && !event.isEndOfMultiDayEvent()) {
      endStr=SPACE_ARROW;
      separator=EMPTY_STRING;
    }
 else {
      endStr=createTimeString(event.getEndDate());
    }
  }
 else {
    separator=EMPTY_STRING;
    endStr=EMPTY_STRING;
  }
  return startStr + separator + endStr;
}","private String createTimeSpanString(CalendarEvent event){
  String startStr;
  String endStr;
  String separator=SPACE_DASH_SPACE;
  if (event.isPartOfMultiDayEvent() && DateUtil.isMidnight(event.getStartDate()) && !event.isStartOfMultiDayEvent()) {
    startStr=ARROW_SPACE;
    separator=EMPTY_STRING;
  }
 else {
    startStr=createTimeString(event.getStartDate());
  }
  if (prefs.getBoolean(PREF_SHOW_END_TIME,PREF_SHOW_END_TIME_DEFAULT)) {
    if (event.isPartOfMultiDayEvent() && DateUtil.isMidnight(event.getEndDate()) && !event.isEndOfMultiDayEvent()) {
      endStr=SPACE_ARROW;
      separator=EMPTY_STRING;
    }
 else {
      endStr=createTimeString(event.getEndDate());
    }
  }
 else {
    separator=EMPTY_STRING;
    endStr=EMPTY_STRING;
  }
  return startStr + separator + endStr;
}",0.9931207004377736
186199,"public Intent createOnItemClickIntent(CalendarEvent event){
  CalendarEvent originalEvent=event.getOriginalEvent();
  if (originalEvent != null) {
    event=originalEvent;
  }
  return CalendarIntentUtil.createOpenCalendarEventIntent(event.getEventId(),event.getStartDate(),event.getEndDate());
}","private Intent createOnItemClickIntent(CalendarEvent event){
  CalendarEvent originalEvent=event.getOriginalEvent();
  if (originalEvent != null) {
    event=originalEvent;
  }
  return CalendarIntentUtil.createOpenCalendarEventIntent(event.getEventId(),event.getStartDate(),event.getEndDate());
}",0.981450252951096
186200,"public String createTimeString(DateTime time){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  String dateFormat=prefs.getString(PREF_DATE_FORMAT,PREF_DATE_FORMAT_DEFAULT);
  if (DateUtil.hasAmPmClock(Locale.getDefault()) && dateFormat.equals(AUTO) || dateFormat.equals(TWELVE)) {
    return DateUtils.formatDateTime(context,time.toDate().getTime(),DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_12HOUR);
  }
  return DateUtils.formatDateTime(context,time.toDate().getTime(),DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_24HOUR);
}","private String createTimeString(DateTime time){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  String dateFormat=prefs.getString(PREF_DATE_FORMAT,PREF_DATE_FORMAT_DEFAULT);
  if (DateUtil.hasAmPmClock(Locale.getDefault()) && dateFormat.equals(AUTO) || dateFormat.equals(TWELVE)) {
    return DateUtils.formatDateTime(context,time.toDate().getTime(),DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_12HOUR);
  }
  return DateUtils.formatDateTime(context,time.toDate().getTime(),DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_24HOUR);
}",0.9902912621359224
186201,"public Dialog createDialog(View layout){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setTitle(R.string.appearance_background_color_title);
  builder.setView(layout);
  builder.setPositiveButton(android.R.string.ok,new OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(getActivity());
      Editor editor=prefs.edit();
      editor.putInt(PREF_BACKGROUND_COLOR,picker.getColor());
      editor.commit();
    }
  }
);
  return builder.create();
}","private Dialog createDialog(View layout){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setTitle(R.string.appearance_background_color_title);
  builder.setView(layout);
  builder.setPositiveButton(android.R.string.ok,new OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(getActivity());
      Editor editor=prefs.edit();
      editor.putInt(PREF_BACKGROUND_COLOR,picker.getColor());
      editor.commit();
    }
  }
);
  return builder.create();
}",0.9907172995780592
186202,"public void populatePreferenceScreen(Set<String> activeCalendars){
  Cursor cursor=createLoadedCursor();
  if (cursor == null) {
    return;
  }
  for (int i=0; i < cursor.getCount(); i++) {
    cursor.moveToPosition(i);
    CheckBoxPreference checkboxPref=new CheckBoxPreference(getActivity());
    checkboxPref.setTitle(cursor.getString(1));
    checkboxPref.setIcon(createDrawable(cursor.getInt(2)));
    int calendarId=cursor.getInt(0);
    checkboxPref.getExtras().putInt(CALENDAR_ID,calendarId);
    checkboxPref.setChecked(activeCalendars == null || activeCalendars.contains(String.valueOf(calendarId)));
    getPreferenceScreen().addPreference(checkboxPref);
  }
}","private void populatePreferenceScreen(Set<String> activeCalendars){
  Cursor cursor=createLoadedCursor();
  if (cursor == null) {
    return;
  }
  for (int i=0; i < cursor.getCount(); i++) {
    cursor.moveToPosition(i);
    CheckBoxPreference checkboxPref=new CheckBoxPreference(getActivity());
    checkboxPref.setTitle(cursor.getString(1));
    checkboxPref.setIcon(createDrawable(cursor.getInt(2)));
    int calendarId=cursor.getInt(0);
    checkboxPref.getExtras().putInt(CALENDAR_ID,calendarId);
    checkboxPref.setChecked(activeCalendars == null || activeCalendars.contains(String.valueOf(calendarId)));
    getPreferenceScreen().addPreference(checkboxPref);
  }
}",0.99182156133829
186203,"public HashSet<String> getSelectedCalenders(){
  PreferenceScreen preferenceScreen=getPreferenceScreen();
  int prefCount=preferenceScreen.getPreferenceCount();
  HashSet<String> prefValues=new HashSet<String>();
  for (int i=0; i < prefCount; i++) {
    Preference pref=preferenceScreen.getPreference(i);
    if (pref instanceof CheckBoxPreference) {
      CheckBoxPreference checkPref=(CheckBoxPreference)pref;
      if (checkPref.isChecked()) {
        prefValues.add(String.valueOf(checkPref.getExtras().getInt(CALENDAR_ID)));
      }
    }
  }
  return prefValues;
}","private HashSet<String> getSelectedCalenders(){
  PreferenceScreen preferenceScreen=getPreferenceScreen();
  int prefCount=preferenceScreen.getPreferenceCount();
  HashSet<String> prefValues=new HashSet<>();
  for (int i=0; i < prefCount; i++) {
    Preference pref=preferenceScreen.getPreference(i);
    if (pref instanceof CheckBoxPreference) {
      CheckBoxPreference checkPref=(CheckBoxPreference)pref;
      if (checkPref.isChecked()) {
        prefValues.add(String.valueOf(checkPref.getExtras().getInt(CALENDAR_ID)));
      }
    }
  }
  return prefValues;
}",0.6912928759894459
186204,"public BitmapDrawable createDrawable(int color){
  Bitmap bitmap=BitmapFactory.decodeResource(getResources(),R.drawable.prefs_calendar_color);
  BitmapDrawable drawable=new BitmapDrawable(getResources(),bitmap);
  drawable.setColorFilter(new LightingColorFilter(0x0,color));
  return drawable;
}","private Drawable createDrawable(int color){
  Drawable drawable=getResources().getDrawable(R.drawable.prefs_calendar_entry);
  drawable.setColorFilter(new LightingColorFilter(0x0,color));
  return drawable;
}",0.3618290258449304
186205,"public void persistSelectedCalendars(HashSet<String> prefValues){
  SharedPreferences prefs=getPreferenceManager().getSharedPreferences();
  Editor editor=prefs.edit();
  editor.putStringSet(PREF_ACTIVE_CALENDARS,prefValues);
  editor.commit();
}","private void persistSelectedCalendars(HashSet<String> prefValues){
  SharedPreferences prefs=getPreferenceManager().getSharedPreferences();
  Editor editor=prefs.edit();
  editor.putStringSet(PREF_ACTIVE_CALENDARS,prefValues);
  editor.commit();
}",0.977687626774848
186206,"public int getViewTypeCount(){
  int result=0;
  for (int i=0; i < eventProviders.size(); i++) {
    IEventProvider<?> eventProvider=eventProviders.get(i);
    result+=eventProvider.getViewTypeCount();
  }
  return result;
}","public int getViewTypeCount(){
  int result=0;
  for (int i=0; i < eventProviders.size(); i++) {
    IEventVisualizer<?> eventProvider=eventProviders.get(i);
    result+=eventProvider.getViewTypeCount();
  }
  return result;
}",0.9688888888888888
186207,"public void onDataSetChanged(){
  eventEntries.clear();
  ArrayList<EventEntry> eventEntries=new ArrayList<EventEntry>();
  for (int i=0; i < eventProviders.size(); i++) {
    eventEntries.addAll(eventProviders.get(i).getEventEntries());
  }
  updateEntryList(eventEntries);
}","public void onDataSetChanged(){
  eventEntries.clear();
  ArrayList<EventEntry> events=new ArrayList<EventEntry>();
  for (int i=0; i < eventProviders.size(); i++) {
    events.addAll(eventProviders.get(i).getEventEntries());
  }
  updateEntryList(events);
}",0.9662921348314608
186208,"public void updateEntryList(ArrayList<EventEntry> eventList){
  if (!eventList.isEmpty()) {
    DayHeader curDayBucket=new DayHeader(eventList.get(0).getStartDate());
    eventEntries.add(curDayBucket);
    for (    EventEntry event : eventList) {
      if (!event.isSameDay(curDayBucket.getStartDate())) {
        curDayBucket=new DayHeader(event.getStartDate());
        eventEntries.add(curDayBucket);
      }
      eventEntries.add(event);
    }
  }
}","public void updateEntryList(ArrayList<EventEntry> eventList){
  if (!eventList.isEmpty()) {
    EventEntry entry=eventList.get(0);
    DayHeader curDayBucket=new DayHeader(DateUtil.getStartDateInUTC(entry));
    eventEntries.add(curDayBucket);
    for (    EventEntry event : eventList) {
      long startDateInUTC=DateUtil.getStartDateInUTC(event);
      if (!DateUtil.isSameDay(startDateInUTC,curDayBucket.getStartDate())) {
        curDayBucket=new DayHeader(startDateInUTC);
        eventEntries.add(curDayBucket);
      }
      eventEntries.add(event);
    }
  }
}",0.806640625
186209,"public RemoteViews getViewAt(int position){
  EventEntry entry=eventEntries.get(position);
  if (entry instanceof DayHeader) {
    return updateDayHeader((DayHeader)entry);
  }
  for (int i=0; i < eventProviders.size(); i++) {
    IEventProvider<?> eventProvider=eventProviders.get(i);
    if (entry.getClass().isAssignableFrom(eventProvider.getSupportedEventEntryType())) {
      return eventProvider.getRemoteView(entry);
    }
  }
  return null;
}","public RemoteViews getViewAt(int position){
  EventEntry entry=eventEntries.get(position);
  if (entry instanceof DayHeader) {
    return updateDayHeader((DayHeader)entry);
  }
  for (int i=0; i < eventProviders.size(); i++) {
    IEventVisualizer<?> eventProvider=eventProviders.get(i);
    if (entry.getClass().isAssignableFrom(eventProvider.getSupportedEventEntryType())) {
      return eventProvider.getRemoteView(entry);
    }
  }
  return null;
}",0.984478935698448
186210,"public EventRemoteViewsFactory(Context context){
  this.context=context;
  eventProviders=new ArrayList<IEventProvider<?>>();
  eventProviders.add(new CalendarEventProvider(context));
  eventEntries=new ArrayList<EventEntry>();
  prefs=PreferenceManager.getDefaultSharedPreferences(context);
}","public EventRemoteViewsFactory(Context context){
  this.context=context;
  eventProviders=new ArrayList<IEventVisualizer<?>>();
  eventProviders.add(new CalendarEventVisualizer(context));
  eventEntries=new ArrayList<EventEntry>();
  prefs=PreferenceManager.getDefaultSharedPreferences(context);
}",0.952542372881356
186211,"public void createFollowingEntries(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  int daysCovered=eventEntry.daysCovered();
  for (int j=1; j < daysCovered; j++) {
    long startDate=DateUtil.toMidnight(eventEntry.getStartDate() + DateUtils.DAY_IN_MILLIS * j);
    if (startDate >= DateUtil.toMidnight(System.currentTimeMillis())) {
      long endDate;
      if (j == daysCovered - 1) {
        endDate=eventEntry.getEndDate();
      }
 else {
        endDate=startDate + DateUtils.DAY_IN_MILLIS;
      }
      eventList.add(cloneAsSpanningEvent(eventEntry,startDate,endDate));
    }
  }
}","public void createFollowingEntries(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  int daysCovered=eventEntry.daysSpanned();
  for (int j=1; j < daysCovered; j++) {
    long startDate=DateUtil.toMidnight(eventEntry.getStartDate() + DateUtils.DAY_IN_MILLIS * j);
    if (startDate >= DateUtil.toMidnight(System.currentTimeMillis())) {
      long endDate;
      if (j == daysCovered - 1) {
        endDate=eventEntry.getEndDate();
      }
 else {
        endDate=startDate + DateUtils.DAY_IN_MILLIS;
      }
      eventList.add(cloneAsSpanningEvent(eventEntry,startDate,endDate));
    }
  }
}",0.9917491749174916
186212,"public void setupDayOneEntry(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  long today=DateUtil.toMidnight(System.currentTimeMillis());
  int daysCovered=eventEntry.daysCovered();
  if (eventEntry.getStartDate() >= today) {
    if (daysCovered > 1) {
      CalendarEntry clone=eventEntry.clone();
      clone.setEndDate(today + DateUtils.DAY_IN_MILLIS);
      clone.setSpansMultipleDays(true);
      clone.setOriginalEvent(eventEntry);
      eventList.add(clone);
    }
 else {
      eventList.add(eventEntry);
    }
  }
}","public void setupDayOneEntry(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  long today=DateUtil.toMidnight(System.currentTimeMillis());
  int daysSpanned=eventEntry.daysSpanned();
  if (eventEntry.getStartDate() >= today) {
    if (daysSpanned > 1) {
      CalendarEntry clone=eventEntry.clone();
      clone.setEndDate(DateUtil.toMidnight(eventEntry.getStartDate()) + DateUtils.DAY_IN_MILLIS);
      clone.setSpansMultipleDays(true);
      clone.setOriginalEvent(eventEntry);
      eventList.add(clone);
    }
 else {
      eventList.add(eventEntry);
    }
  }
}",0.8990169794459338
186213,"public void createFollowingEntries(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  int daysCovered=eventEntry.daysSpanned();
  for (int j=1; j < daysCovered; j++) {
    long startDate=DateUtil.toMidnight(eventEntry.getStartDate() + DateUtils.DAY_IN_MILLIS * j);
    if (startDate >= DateUtil.toMidnight(System.currentTimeMillis())) {
      long endDate;
      if (j == daysCovered - 1) {
        endDate=eventEntry.getEndDate();
      }
 else {
        endDate=startDate + DateUtils.DAY_IN_MILLIS;
      }
      eventList.add(cloneAsSpanningEvent(eventEntry,startDate,endDate));
    }
  }
}","public void createFollowingEntries(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  int daysCovered=eventEntry.daysSpanned();
  for (int j=1; j < daysCovered; j++) {
    long startDate=DateUtil.toUtcMidnight(eventEntry.getStartDate()) + DateUtils.DAY_IN_MILLIS * j;
    if (startDate >= DateUtil.toUtcMidnight(System.currentTimeMillis())) {
      long endDate;
      if (j == daysCovered - 1) {
        endDate=eventEntry.getEndDate();
      }
 else {
        endDate=startDate + DateUtils.DAY_IN_MILLIS;
      }
      eventList.add(cloneAsSpanningEvent(eventEntry,startDate,endDate));
    }
  }
}",0.993431855500821
186214,"public void setupDayOneEntry(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  long today=DateUtil.toMidnight(System.currentTimeMillis());
  int daysSpanned=eventEntry.daysSpanned();
  long startInUTC=DateUtil.getStartDateInUTC(eventEntry);
  if (startInUTC >= today) {
    if (daysSpanned > 1) {
      CalendarEntry clone=eventEntry.clone();
      clone.setEndDate(DateUtil.toMidnight(eventEntry.getStartDate()) + DateUtils.DAY_IN_MILLIS);
      clone.setSpansMultipleDays(true);
      clone.setOriginalEvent(eventEntry);
      eventList.add(clone);
    }
 else {
      eventList.add(eventEntry);
    }
  }
}","public void setupDayOneEntry(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  long today=DateUtil.toMidnight(System.currentTimeMillis());
  int daysSpanned=eventEntry.daysSpanned();
  if (DateUtil.getStartDateInUTC(eventEntry) >= today) {
    if (daysSpanned > 1) {
      CalendarEntry clone=eventEntry.clone();
      clone.setEndDate(DateUtil.toMidnight(eventEntry.getStartDate()) + DateUtils.DAY_IN_MILLIS);
      clone.setSpansMultipleDays(true);
      clone.setOriginalEvent(eventEntry);
      eventList.add(clone);
    }
 else {
      eventList.add(eventEntry);
    }
  }
}",0.9161184210526316
186215,"public boolean isTomorrow(){
  return startDate.toDateMidnight().isEqual(new DateTime().plusDays(1));
}","public boolean isTomorrow(){
  return isSameDay(new DateTime().plusDays(1));
}",0.8066298342541437
186216,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preferences_calendars);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preferences_calendars);
  SharedPreferences prefs=getPreferenceManager().getSharedPreferences();
  initialActiveCalendars=prefs.getStringSet(ICalendarPreferences.PREF_ACTIVE_CALENDARS,null);
  populatePreferenceScreen(initialActiveCalendars);
}",0.5891181988742964
186217,"static Intent createOpenCalendarAtDayIntent(Context context,long goToTime){
  Intent launchIntent=createOpenCalendarIntent();
  Uri.Builder builder=CalendarContract.CONTENT_URI.buildUpon();
  builder.appendPath(""String_Node_Str"");
  if (goToTime != 0) {
    launchIntent.putExtra(KEY_DETAIL_VIEW,true);
    ContentUris.appendId(builder,goToTime);
  }
  launchIntent.setData(builder.build());
  return launchIntent;
}","static Intent createOpenCalendarAtDayIntent(Context context,long goToTime){
  Intent launchIntent=createOpenCalendarIntent();
  Uri.Builder builder=CalendarContract.CONTENT_URI.buildUpon();
  builder.appendPath(TIME);
  if (goToTime != 0) {
    launchIntent.putExtra(KEY_DETAIL_VIEW,true);
    ContentUris.appendId(builder,goToTime);
  }
  launchIntent.setData(builder.build());
  return launchIntent;
}",0.9743589743589745
186218,"static Intent createOpenCalendarEventIntent(int eventId){
  Intent intent=createOpenCalendarIntent();
  intent.setData(ContentUris.withAppendedId(Events.CONTENT_URI,eventId));
  return intent;
}","static Intent createOpenCalendarEventIntent(int eventId,long from,long to){
  Intent intent=createOpenCalendarIntent();
  intent.setData(ContentUris.withAppendedId(Events.CONTENT_URI,eventId));
  intent.putExtra(BEGIN_TIME,from);
  intent.putExtra(END_TIME,to);
  return intent;
}",0.8059071729957806
186219,"public static void initiDateFormatter(){
  dayDateFormatter=new SimpleDateFormat(""String_Node_Str"");
  dayStringFormatter=new SimpleDateFormat(""String_Node_Str"");
  timeFormatter=new SimpleDateFormat(""String_Node_Str"");
}","public static void initiDateFormatter(){
  dayDateFormatter=new SimpleDateFormat(DAY_DATE_FORMAT);
  dayStringFormatter=new SimpleDateFormat(DAY_STRING_FORMAT);
  timeFormatter=new SimpleDateFormat(TIME_FORMAT);
}",0.5898617511520737
186220,"public RemoteViews updateEventEntry(String packageName,EventEntry event){
  RemoteViews rv=new RemoteViews(packageName,getEventEntryLayout());
  Intent intent=CalendarIntentUtil.createOpenCalendarEventIntent(event.getEventId());
  rv.setOnClickFillInIntent(R.id.event_entry_text_layout,intent);
  rv.setOnClickFillInIntent(R.id.event_entry_color,intent);
  rv.setOnClickFillInIntent(R.id.event_entry_title,intent);
  rv.setTextViewText(R.id.event_entry_title,event.getTitle());
  if (event.isAllDay()) {
    rv.setViewVisibility(R.id.event_entry_date,View.GONE);
  }
 else {
    rv.setViewVisibility(R.id.event_entry_date,View.VISIBLE);
    rv.setOnClickFillInIntent(R.id.event_entry_date,intent);
    rv.setTextViewText(R.id.event_entry_date,createTimeString(event.getStartDate()) + SPACED_DASH + createTimeString(event.getEndDate()));
  }
  if (event.isAlarmActive() && prefs.getBoolean(PREF_INDICATE_ALERTS,true)) {
    rv.setViewVisibility(R.id.event_entry_indicator_alarm,View.VISIBLE);
  }
 else {
    rv.setViewVisibility(R.id.event_entry_indicator_alarm,View.GONE);
  }
  if (event.isRecurring() && prefs.getBoolean(PREF_INDICATE_RECURRING,false)) {
    rv.setViewVisibility(R.id.event_entry_indicator_recurring,View.VISIBLE);
  }
 else {
    rv.setViewVisibility(R.id.event_entry_indicator_recurring,View.GONE);
  }
  rv.setInt(R.id.event_entry_color,METHOD_SET_BACKGROUND_COLOR,event.getColor());
  return rv;
}","public RemoteViews updateEventEntry(String packageName,EventEntry event){
  RemoteViews rv=new RemoteViews(packageName,getEventEntryLayout());
  Intent intent=CalendarIntentUtil.createOpenCalendarEventIntent(event.getEventId(),event.getStartDate(),event.getEndDate());
  rv.setOnClickFillInIntent(R.id.event_entry_text_layout,intent);
  rv.setOnClickFillInIntent(R.id.event_entry_color,intent);
  rv.setOnClickFillInIntent(R.id.event_entry_title,intent);
  rv.setTextViewText(R.id.event_entry_title,event.getTitle());
  if (event.isAllDay()) {
    rv.setViewVisibility(R.id.event_entry_date,View.GONE);
  }
 else {
    rv.setViewVisibility(R.id.event_entry_date,View.VISIBLE);
    rv.setOnClickFillInIntent(R.id.event_entry_date,intent);
    rv.setTextViewText(R.id.event_entry_date,createTimeString(event.getStartDate()) + SPACED_DASH + createTimeString(event.getEndDate()));
  }
  if (event.isAlarmActive() && prefs.getBoolean(PREF_INDICATE_ALERTS,true)) {
    rv.setViewVisibility(R.id.event_entry_indicator_alarm,View.VISIBLE);
  }
 else {
    rv.setViewVisibility(R.id.event_entry_indicator_alarm,View.GONE);
  }
  if (event.isRecurring() && prefs.getBoolean(PREF_INDICATE_RECURRING,false)) {
    rv.setViewVisibility(R.id.event_entry_indicator_recurring,View.VISIBLE);
  }
 else {
    rv.setViewVisibility(R.id.event_entry_indicator_recurring,View.GONE);
  }
  rv.setInt(R.id.event_entry_color,METHOD_SET_BACKGROUND_COLOR,event.getColor());
  return rv;
}",0.986120749479528
186221,"public CalendarEntry cloneAsSpanningEvent(CalendarEntry eventEntry,long startDate,long endDate){
  CalendarEntry spanningEvent=eventEntry.clone();
  spanningEvent.setStartDate(startDate);
  spanningEvent.setEndDate(endDate);
  spanningEvent.setSpansMultipleDays(true);
  return spanningEvent;
}","public CalendarEntry cloneAsSpanningEvent(CalendarEntry eventEntry,long startDate,long endDate){
  CalendarEntry clone=eventEntry.clone();
  clone.setStartDate(startDate);
  clone.setEndDate(endDate);
  clone.setSpansMultipleDays(true);
  clone.setOriginalEvent(eventEntry);
  return clone;
}",0.6757679180887372
186222,"public void setupDayOneEntry(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  long today=DateUtil.toMidnight(System.currentTimeMillis());
  int daysCovered=eventEntry.daysCovered();
  if (eventEntry.getStartDate() >= today) {
    if (daysCovered > 1) {
      CalendarEntry clone=eventEntry.clone();
      clone.setEndDate(today + DateUtils.DAY_IN_MILLIS);
      clone.setSpansMultipleDays(true);
      eventList.add(clone);
    }
 else {
      eventList.add(eventEntry);
    }
  }
}","public void setupDayOneEntry(ArrayList<CalendarEntry> eventList,CalendarEntry eventEntry){
  long today=DateUtil.toMidnight(System.currentTimeMillis());
  int daysCovered=eventEntry.daysCovered();
  if (eventEntry.getStartDate() >= today) {
    if (daysCovered > 1) {
      CalendarEntry clone=eventEntry.clone();
      clone.setEndDate(today + DateUtils.DAY_IN_MILLIS);
      clone.setSpansMultipleDays(true);
      clone.setOriginalEvent(eventEntry);
      eventList.add(clone);
    }
 else {
      eventList.add(eventEntry);
    }
  }
}",0.9594594594594594
186223,"public Intent createOnItemClickIntent(CalendarEntry event){
  return CalendarIntentUtil.createOpenCalendarEventIntent(event.getEventId(),event.getStartDate(),event.getEndDate());
}","public Intent createOnItemClickIntent(CalendarEntry event){
  CalendarEntry originalEvent=event.getOriginalEvent();
  if (originalEvent != null) {
    event=originalEvent;
  }
  return CalendarIntentUtil.createOpenCalendarEventIntent(event.getEventId(),event.getStartDate(),event.getEndDate());
}",0.7563025210084033
186224,"private Option<View> setupView(final View view){
  AdView adView;
  try {
    adView=(AdView)view;
  }
 catch (  ClassCastException err) {
    adView=null;
    Crashlytics.logException(err);
  }
  if (adView != null) {
    final AdRequest adRequest=new AdRequest.Builder().addTestDevice(AdRequest.DEVICE_ID_EMULATOR).build();
    adView.loadAd(adRequest);
    return Option.some(adView);
  }
  return Option.none();
}","private Option<View> setupView(final View view){
  AdView adView;
  try {
    adView=(AdView)view;
  }
 catch (  ClassCastException err) {
    adView=null;
    Crashlytics.logException(err);
  }
  if (adView != null) {
    final AdRequest adRequest=new AdRequest.Builder().addTestDevice(AdRequest.DEVICE_ID_EMULATOR).build();
    try {
      adView.loadAd(adRequest);
    }
 catch (    OutOfMemoryError err) {
      return Option.none();
    }
    return Option.some(adView);
  }
  return Option.none();
}",0.7982646420824295
186225,"/** 
 * Workaround for Android KitKat where the we might take the place of a default app for http/https which we really fucking don't want to be.
 * @return whether the Url has been handled by this
 */
private boolean handleUnknownUrl(){
  if (Build.VERSION.SDK_INT != Build.VERSION_CODES.KITKAT) {
    return false;
  }
  Ln.i(""String_Node_Str"");
  final Intent intent=Intent.createChooser(getIntent(),null);
  intent.setAction(Intent.ACTION_VIEW);
  getPackageManager().clearPackagePreferredActivities(getPackageName());
  try {
    startActivity(intent);
    finish();
  }
 catch (  ActivityNotFoundException err) {
    return false;
  }
  return true;
}","/** 
 * Workaround for Android KitKat where the we might take the place of a default app for http/https which we really fucking don't want to be.
 * @return whether the Url has been handled by this
 */
private boolean handleUnknownUrl(){
  if (Build.VERSION.SDK_INT != Build.VERSION_CODES.KITKAT) {
    return false;
  }
  Ln.i(""String_Node_Str"");
  final Intent intent=Intent.createChooser(getIntent(),null);
  intent.setAction(Intent.ACTION_VIEW);
  try {
    startActivity(intent);
    finish();
  }
 catch (  ActivityNotFoundException err) {
    return false;
  }
  return true;
}",0.9411764705882352
186226,"@Override protected void onSaveInstanceState(Bundle outState){
  mIsPostSaveInstanceState=true;
  super.onSaveInstanceState(outState);
  outState.putParcelable(MEDIA_STATE_TAG,mMediaState);
}","@Override protected void onSaveInstanceState(Bundle outState){
  super.onSaveInstanceState(outState);
  outState.putParcelable(MEDIA_STATE_TAG,mMediaState);
}",0.9054441260744984
186227,"public boolean isPurchasable(){
  return purchaseUrl != null;
}","public boolean isPurchasable(){
  if (purchaseUrl != null) {
    final String lowerUrl=purchaseUrl.toLowerCase();
    return lowerUrl.startsWith(""String_Node_Str"") || lowerUrl.startsWith(""String_Node_Str"");
  }
  return false;
}",0.3848797250859107
186228,"public String getPurchaseUrl(){
  return purchaseUrl;
}","public String getPurchaseUrl(){
  return purchaseUrl.toLowerCase();
}",0.8870967741935484
186229,"private void startPurchase(){
  Uri uri=Uri.parse(mTrack.getPurchaseUrl().toLowerCase());
  final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
  startActivity(intent);
  mTrackerProvider.get().sendEvent(ANALYTICS_TAG,""String_Node_Str"",uri.toString(),mTrack.getId());
}","private void startPurchase(){
  Uri uri=Uri.parse(mTrack.getPurchaseUrl());
  final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
  startActivity(intent);
  mTrackerProvider.get().sendEvent(ANALYTICS_TAG,""String_Node_Str"",uri.toString(),mTrack.getId());
}",0.9736842105263158
186230,"public SpecifierTree EXPORT_SPECIFIER(){
  return b.<SpecifierTree>nonterminal(Kind.EXPORT_SPECIFIER).is(b.firstOf(f.exportSpecifier(IDENTIFIER_REFERENCE(),b.token(EcmaScriptLexer.AS),IDENTIFIER_NAME()),f.exportSpecifier(IDENTIFIER_REFERENCE())));
}","public SpecifierTree EXPORT_SPECIFIER(){
  return b.<SpecifierTree>nonterminal(Kind.EXPORT_SPECIFIER).is(b.firstOf(f.exportSpecifier(f.identifierReference(b.token(JavaScriptKeyword.DEFAULT)),b.token(EcmaScriptLexer.AS),IDENTIFIER_NAME()),f.exportSpecifier(f.identifierReference(b.token(JavaScriptKeyword.DEFAULT))),f.exportSpecifier(IDENTIFIER_REFERENCE(),b.token(EcmaScriptLexer.AS),IDENTIFIER_NAME()),f.exportSpecifier(IDENTIFIER_REFERENCE())));
}",0.7134670487106017
186231,"public VueElement VUE_ELEMENT(){
  return b.<VueElement>nonterminal().is(b.firstOf(f.vueElement(b.token(EcmaScriptLexer.VUE_TEMPLATE_SECTION)),f.vueElement(b.token(EcmaScriptLexer.VUE_STYLE_SECTION)),f.scriptVueElement(b.token(EcmaScriptLexer.SCRIPT_TAG),b.optional(b.token(EcmaScriptLexer.SHEBANG)),b.optional(MODULE_BODY()),b.token(EcmaScriptLexer.SCRIPT_TAG_CLOSE))));
}","public VueElement VUE_ELEMENT(){
  return b.<VueElement>nonterminal().is(b.firstOf(f.vueElement(b.token(EcmaScriptLexer.VUE_TEMPLATE_SECTION)),f.vueElement(b.token(EcmaScriptLexer.VUE_STYLE_SECTION)),f.scriptVueElement(VUE_SCRIPT_TAG(),b.optional(b.token(EcmaScriptLexer.SHEBANG)),b.optional(MODULE_BODY()),b.token(EcmaScriptLexer.SCRIPT_TAG_CLOSE))));
}",0.9601100412654744
186232,"public ScriptVueElement scriptVueElement(InternalSyntaxToken scriptOpenTag,Optional<InternalSyntaxToken> shebangToken,Optional<ModuleTree> items,InternalSyntaxToken scriptCloseTag){
  return new ScriptVueElement(shebangToken.orNull(),items.orNull());
}","public ScriptVueElement scriptVueElement(VueScriptTag scriptOpenTag,Optional<InternalSyntaxToken> shebangToken,Optional<ModuleTree> items,InternalSyntaxToken scriptCloseTag){
  return new ScriptVueElement(shebangToken.orNull(),items.orNull());
}",0.937625754527163
186233,"@Test public void vue_file() throws Exception {
  final String styleWithCss=""String_Node_Str"";
  final String componentTemplate=""String_Node_Str"";
  final String componentTemplateWithScript=""String_Node_Str"";
  assertThat(EcmaScriptLexer.VUE_SCRIPT).matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(componentTemplateWithScript + ""String_Node_Str"" + styleWithCss).matches(componentTemplate + ""String_Node_Str"" + styleWithCss).matches(componentTemplate + styleWithCss + ""String_Node_Str"").matches(""String_Node_Str"" + componentTemplate + styleWithCss).matches(""String_Node_Str"" + styleWithCss + componentTemplate).matches(styleWithCss + ""String_Node_Str"" + componentTemplate).matches(styleWithCss + componentTemplate + ""String_Node_Str"");
}","@Test public void vue_file() throws Exception {
  final String styleWithCss=""String_Node_Str"";
  final String componentTemplate=""String_Node_Str"";
  final String componentTemplateWithScript=""String_Node_Str"";
  assertThat(EcmaScriptLexer.VUE_SCRIPT).matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(""String_Node_Str"").matches(componentTemplateWithScript + ""String_Node_Str"" + styleWithCss).matches(componentTemplate + ""String_Node_Str"" + styleWithCss).matches(componentTemplate + styleWithCss + ""String_Node_Str"").matches(""String_Node_Str"" + componentTemplate + styleWithCss).matches(""String_Node_Str"" + styleWithCss + componentTemplate).matches(styleWithCss + ""String_Node_Str"" + componentTemplate).matches(styleWithCss + componentTemplate + ""String_Node_Str"");
}",0.9869375907111756
186234,"public ExpressionTree ASSIGNMENT_EXPRESSION(){
  return b.<ExpressionTree>nonterminal(EcmaScriptLexer.ASSIGNMENT_EXPRESSION).is(b.firstOf(f.assignmentWithArrayDestructuring(ARRAY_ASSIGNMENT_PATTERN(),b.token(JavaScriptPunctuator.EQU),ASSIGNMENT_EXPRESSION()),f.assignmentExpression(b.firstOf(OBJECT_ASSIGNMENT_PATTERN(),LEFT_HAND_SIDE_EXPRESSION()),b.firstOf(b.token(JavaScriptPunctuator.EQU),b.token(JavaScriptPunctuator.STAR_EQU),b.token(JavaScriptPunctuator.EXP_EQU),b.token(JavaScriptPunctuator.DIV_EQU),b.token(JavaScriptPunctuator.MOD_EQU),b.token(JavaScriptPunctuator.PLUS_EQU),b.token(JavaScriptPunctuator.MINUS_EQU),b.token(JavaScriptPunctuator.SL_EQU),b.token(JavaScriptPunctuator.SR_EQU),b.token(JavaScriptPunctuator.SR_EQU2),b.token(JavaScriptPunctuator.AND_EQU),b.token(JavaScriptPunctuator.XOR_EQU),b.token(JavaScriptPunctuator.OR_EQU)),ASSIGNMENT_EXPRESSION()),YIELD_EXPRESSION(),ARROW_FUNCTION(),CONDITIONAL_EXPRESSION_NOT_ES6_ASSIGNMENT_EXPRESSION()));
}","public ExpressionTree ASSIGNMENT_EXPRESSION(){
  return b.<ExpressionTree>nonterminal(EcmaScriptLexer.ASSIGNMENT_EXPRESSION).is(b.firstOf(f.assignmentWithArrayDestructuring(ARRAY_ASSIGNMENT_PATTERN(),b.token(JavaScriptPunctuator.EQU),ASSIGNMENT_EXPRESSION()),f.assignmentExpression(b.firstOf(OBJECT_ASSIGNMENT_PATTERN(),LEFT_HAND_SIDE_EXPRESSION()),ASSIGNMENT_TOKEN(),ASSIGNMENT_EXPRESSION()),YIELD_EXPRESSION(),ARROW_FUNCTION(),CONDITIONAL_EXPRESSION()));
}",0.6172148355493352
186235,"public ExpressionTree CONDITIONAL_EXPRESSION(){
  return b.<ExpressionTree>nonterminal(Kind.CONDITIONAL_EXPRESSION).is(f.optionalConditionalExpression(CONDITIONAL_OR_EXPRESSION(),b.optional(f.conditionalExpressionTail(b.token(JavaScriptPunctuator.QUERY),ASSIGNMENT_EXPRESSION(),b.token(JavaScriptPunctuator.COLON),ASSIGNMENT_EXPRESSION()))));
}","public ExpressionTree CONDITIONAL_EXPRESSION(){
  return b.<ExpressionTree>nonterminal(Kind.CONDITIONAL_EXPRESSION).is(f.optionalConditionalExpression(CONDITIONAL_OR_EXPRESSION(),b.optional(CONDITIONAL_EXPRESSION_TAIL())));
}",0.6924428822495606
186236,"@Override public void startOfFile(ScriptTree scriptTree){
  ignoredList.clear();
}","@Override protected void startOfFile(ScriptTree scriptTree){
  ignoredList.clear();
}",0.934131736526946
186237,"@Override public void startOfFile(ScriptTree scriptTree){
  alwaysTrueConditions.clear();
  fileLoops=FileLoops.create(scriptTree);
}","@Override protected void startOfFile(ScriptTree scriptTree){
  alwaysTrueConditions.clear();
  fileLoops=FileLoops.create(scriptTree);
}",0.9591078066914498
186238,"public void startOfFile(ScriptTree scriptTree){
}","/** 
 * Override this method to perform actions before any analysis is performed
 * @param scriptTree the scriptTree that is going to be analyzed
 */
protected void startOfFile(ScriptTree scriptTree){
}",0.3585657370517928
186239,"@Override public void visitNode(Tree tree){
  if (tree.is(Kind.SCRIPT)) {
    checks.forEach(seCheck -> seCheck.startOfFile((ScriptTree)tree));
    return;
  }
  FunctionTree functionTree=(FunctionTree)tree;
  if (functionTree.body().is(Kind.BLOCK)) {
    ControlFlowGraph cfg=ControlFlowGraph.build((BlockTree)functionTree.body());
    Scope functionScope=getContext().getSymbolModel().getScope(functionTree);
    new SymbolicExecution(functionScope,cfg,checks).visitCfg(ProgramState.emptyState());
  }
}","@Override public void visitNode(Tree tree){
  if (tree.is(Kind.SCRIPT)) {
    checks.forEach(seCheck -> seCheck.cleanupAndStartFileAnalysis((ScriptTree)tree));
    return;
  }
  FunctionTree functionTree=(FunctionTree)tree;
  if (functionTree.body().is(Kind.BLOCK)) {
    ControlFlowGraph cfg=ControlFlowGraph.build((BlockTree)functionTree.body());
    Scope functionScope=getContext().getSymbolModel().getScope(functionTree);
    new SymbolicExecution(functionScope,cfg,checks).visitCfg(ProgramState.emptyState());
  }
}",0.9707602339181286
186240,"@Override public void endOfExecution(Scope functionScope){
  for (  Entry<Tree,Optional<String>> entry : hasIssue.entrySet()) {
    if (entry.getValue().isPresent()) {
      addIssue(entry.getKey(),entry.getValue().get());
    }
  }
}","@Override public void endOfExecution(Scope functionScope){
  for (  Entry<Tree,Optional<String>> entry : hasIssue.entrySet()) {
    Optional<String> value=entry.getValue();
    if (value.isPresent()) {
      addIssue(entry.getKey(),value.get());
    }
  }
}",0.8716904276985743
186241,"private static boolean isUpdateOnOneWithAssign(ExpressionTree update){
  if (update.is(PLUS_ASSIGNMENT,Tree.Kind.MINUS_ASSIGNMENT)) {
    ExpressionTree rightExpression=((AssignmentExpressionTree)update).expression();
    return rightExpression.is(Tree.Kind.NUMERIC_LITERAL) && ""String_Node_Str"".equals(((LiteralTree)rightExpression).value());
  }
  return false;
}","private static boolean isUpdateOnOneWithAssign(ExpressionTree update){
  if (update.is(PLUS_ASSIGNMENT,MINUS_ASSIGNMENT)) {
    ExpressionTree rightExpression=((AssignmentExpressionTree)update).expression();
    return rightExpression.is(NUMERIC_LITERAL) && ""String_Node_Str"".equals(((LiteralTree)rightExpression).value());
  }
  return false;
}",0.971830985915493
186242,"private static void counters(ExpressionTree update,Set<String> counters){
  ExpressionTree counter=null;
  if (update.is(Tree.Kind.COMMA_OPERATOR)) {
    BinaryExpressionTree commaExpressions=(BinaryExpressionTree)update;
    counters(commaExpressions.leftOperand(),counters);
    counters(commaExpressions.rightOperand(),counters);
  }
 else   if (update.is(KindSet.INC_DEC_KINDS)) {
    counter=((UnaryExpressionTree)update).expression();
  }
 else   if (update.is(PLUS_ASSIGNMENT,Kind.MINUS_ASSIGNMENT)) {
    counter=((AssignmentExpressionTree)update).variable();
  }
  if (counter != null && counter.is(Kind.IDENTIFIER_REFERENCE)) {
    counters.add(((IdentifierTree)counter).name());
  }
}","private static void counters(ExpressionTree update,Set<String> counters){
  ExpressionTree counter=null;
  if (update.is(COMMA_OPERATOR)) {
    BinaryExpressionTree commaExpressions=(BinaryExpressionTree)update;
    counters(commaExpressions.leftOperand(),counters);
    counters(commaExpressions.rightOperand(),counters);
  }
 else   if (update.is(INC_DEC_KINDS)) {
    counter=((UnaryExpressionTree)update).expression();
  }
 else   if (update.is(PLUS_ASSIGNMENT,MINUS_ASSIGNMENT)) {
    counter=((AssignmentExpressionTree)update).variable();
  }
  if (counter != null && counter.is(IDENTIFIER_REFERENCE)) {
    counters.add(((IdentifierTree)counter).name());
  }
}",0.9794419970631424
186243,"private static boolean isTrivialIteratorException(ForStatementTree forStatement){
  ExpressionTree condition=forStatement.condition();
  if (condition != null && condition.is(Tree.Kind.NOT_EQUAL_TO)) {
    ExpressionTree update=forStatement.update();
    Tree init=forStatement.init();
    if (init != null && update != null) {
      return checkForTrivialIteratorException(init,condition,update);
    }
  }
  return false;
}","private static boolean isTrivialIteratorException(ForStatementTree forStatement){
  ExpressionTree condition=forStatement.condition();
  if (condition != null && condition.is(NOT_EQUAL_TO)) {
    ExpressionTree update=forStatement.update();
    Tree init=forStatement.init();
    if (init != null && update != null) {
      return checkForTrivialIteratorException(init,condition,update);
    }
  }
  return false;
}",0.988095238095238
186244,"private static Integer getInteger(ExpressionTree expression){
  if (expression.is(Tree.Kind.NUMERIC_LITERAL)) {
    LiteralTree literal=(LiteralTree)expression;
    Integer decoded;
    try {
      decoded=Integer.decode(literal.value());
      return decoded;
    }
 catch (    NumberFormatException e) {
      return null;
    }
  }
  return null;
}","private static Integer getInteger(ExpressionTree expression){
  if (expression.is(NUMERIC_LITERAL)) {
    LiteralTree literal=(LiteralTree)expression;
    Integer decoded;
    try {
      decoded=Integer.decode(literal.value());
      return decoded;
    }
 catch (    NumberFormatException e) {
      return null;
    }
  }
  return null;
}",0.9855491329479767
186245,"private static boolean isNontrivialConditionException(ForStatementTree forStatement){
  ExpressionTree condition=forStatement.condition();
  ExpressionTree update=forStatement.update();
  if (update != null && condition != null && condition.is(Kind.EQUAL_TO,Kind.NOT_EQUAL_TO,Kind.STRICT_EQUAL_TO,Kind.STRICT_NOT_EQUAL_TO)) {
    Set<String> counters=new HashSet<>();
    counters(update,counters);
    ExpressionTree leftOperand=((BinaryExpressionTree)condition).leftOperand();
    return !leftOperand.is(Kind.IDENTIFIER_REFERENCE) || !counters.contains(((IdentifierTree)leftOperand).name());
  }
  return false;
}","private static boolean isNontrivialConditionException(ForStatementTree forStatement){
  ExpressionTree condition=forStatement.condition();
  ExpressionTree update=forStatement.update();
  if (update != null && condition != null && condition.is(EQUAL_TO,NOT_EQUAL_TO,STRICT_EQUAL_TO,STRICT_NOT_EQUAL_TO)) {
    Set<String> counters=new HashSet<>();
    counters(update,counters);
    ExpressionTree leftOperand=((BinaryExpressionTree)condition).leftOperand();
    return !leftOperand.is(IDENTIFIER_REFERENCE) || !counters.contains(((IdentifierTree)leftOperand).name());
  }
  return false;
}",0.979253112033195
186246,"private static boolean isUpdateIncDec(ExpressionTree update){
  boolean result=false;
  if (update.is(Tree.Kind.COMMA_OPERATOR)) {
    BinaryExpressionTree commaExpressions=(BinaryExpressionTree)update;
    result=isUpdateIncDec(commaExpressions.leftOperand()) && isUpdateIncDec(commaExpressions.rightOperand());
  }
 else   if (update.is(KindSet.INC_DEC_KINDS) || update.is(PLUS_ASSIGNMENT,MINUS_ASSIGNMENT)) {
    result=true;
  }
  return result;
}","private static boolean isUpdateIncDec(ExpressionTree update){
  boolean result=false;
  if (update.is(COMMA_OPERATOR)) {
    BinaryExpressionTree commaExpressions=(BinaryExpressionTree)update;
    result=isUpdateIncDec(commaExpressions.leftOperand()) && isUpdateIncDec(commaExpressions.rightOperand());
  }
 else   if (update.is(INC_DEC_KINDS) || update.is(PLUS_ASSIGNMENT,MINUS_ASSIGNMENT)) {
    result=true;
  }
  return result;
}",0.9796380090497736
186247,"@Nullable private static Integer getValue(Tree tree){
  Integer result=null;
  if (tree.is(Tree.Kind.NOT_EQUAL_TO)) {
    result=getInteger(((BinaryExpressionTree)tree).rightOperand());
  }
 else   if (isOneVarDeclaration(tree)) {
    BindingElementTree variable=((VariableDeclarationTree)tree).variables().get(0);
    if (variable.is(Tree.Kind.INITIALIZED_BINDING_ELEMENT)) {
      result=getInteger(((InitializedBindingElementTree)variable).right());
    }
  }
 else   if (tree.is(Tree.Kind.ASSIGNMENT)) {
    result=getInteger(((AssignmentExpressionTree)tree).expression());
  }
  return result;
}","@Nullable private static Integer getValue(Tree tree){
  Integer result=null;
  if (tree.is(NOT_EQUAL_TO)) {
    result=getInteger(((BinaryExpressionTree)tree).rightOperand());
  }
 else   if (isOneVarDeclaration(tree)) {
    BindingElementTree variable=((VariableDeclarationTree)tree).variables().get(0);
    if (variable.is(INITIALIZED_BINDING_ELEMENT)) {
      result=getInteger(((InitializedBindingElementTree)variable).right());
    }
  }
 else   if (tree.is(ASSIGNMENT)) {
    result=getInteger(((AssignmentExpressionTree)tree).expression());
  }
  return result;
}",0.9743589743589745
186248,"private static boolean isOneVarDeclaration(Tree tree){
  return tree.is(Tree.Kind.VAR_DECLARATION) && ((VariableDeclarationTree)tree).variables().size() == 1;
}","private static boolean isOneVarDeclaration(Tree tree){
  return tree.is(VAR_DECLARATION) && ((VariableDeclarationTree)tree).variables().size() == 1;
}",0.967741935483871
186249,"private static int checkForUpdateByOne(ExpressionTree update){
  if (update.is(Tree.Kind.POSTFIX_INCREMENT,Tree.Kind.PREFIX_INCREMENT) || (update.is(PLUS_ASSIGNMENT) && isUpdateOnOneWithAssign(update))) {
    return +1;
  }
  if (update.is(Tree.Kind.POSTFIX_DECREMENT,Tree.Kind.PREFIX_DECREMENT) || (update.is(Tree.Kind.MINUS_ASSIGNMENT) && isUpdateOnOneWithAssign(update))) {
    return -1;
  }
  return 0;
}","private static int checkForUpdateByOne(ExpressionTree update){
  if (update.is(POSTFIX_INCREMENT,PREFIX_INCREMENT) || (update.is(PLUS_ASSIGNMENT) && isUpdateOnOneWithAssign(update))) {
    return +1;
  }
  if (update.is(POSTFIX_DECREMENT,PREFIX_DECREMENT) || (update.is(MINUS_ASSIGNMENT) && isUpdateOnOneWithAssign(update))) {
    return -1;
  }
  return 0;
}",0.9348958333333334
186250,"private static boolean isEquality(ExpressionTree condition){
  return condition.is(Tree.Kind.EQUAL_TO,Tree.Kind.NOT_EQUAL_TO);
}","private static boolean isEquality(ExpressionTree condition){
  return condition.is(EQUAL_TO,NOT_EQUAL_TO);
}",0.9152542372881356
186251,"private static int consumeEscapeSequence(int i,int len,String value,StringBuilder escapeSequence,StringBuilder result){
  while (escapeSequence.length() != len && i < value.length()) {
    i++;
    escapeSequence.append(value.charAt(i));
  }
  if (escapeSequence.length() == len) {
    result.append((char)Integer.parseInt(escapeSequence.toString(),16));
    escapeSequence.setLength(0);
  }
  i++;
  return i;
}","private static int consumeEscapeSequence(int i,int len,String value,StringBuilder escapeSequence,StringBuilder result){
  int ii=i;
  while (escapeSequence.length() != len && ii < value.length()) {
    ii++;
    escapeSequence.append(value.charAt(ii));
  }
  if (escapeSequence.length() == len) {
    result.append((char)Integer.parseInt(escapeSequence.toString(),16));
    escapeSequence.setLength(0);
  }
  ii++;
  return ii;
}",0.9797859690844232
186252,"private void buildUsagesAndLivenesses(ControlFlowGraph cfg,Usages usages,Set<BlockLiveness> livenesses){
  livenessPerBlock=new HashMap<>();
  for (  CfgBlock block : cfg.blocks()) {
    BlockLiveness blockLiveness=new BlockLiveness(block,usages);
    livenessPerBlock.put(block,blockLiveness);
    livenesses.add(blockLiveness);
  }
  Deque<CfgBlock> queue=new ArrayDeque(cfg.blocks());
  while (!queue.isEmpty()) {
    CfgBlock block=queue.pop();
    BlockLiveness blockLiveness=livenessPerBlock.get(block);
    boolean changed=blockLiveness.updateLiveInAndOut(livenessPerBlock);
    if (changed) {
      block.predecessors().forEach(queue::push);
    }
  }
}","private void buildUsagesAndLivenesses(ControlFlowGraph cfg,Usages usages,Set<BlockLiveness> livenesses){
  livenessPerBlock=new HashMap<>();
  for (  CfgBlock block : cfg.blocks()) {
    BlockLiveness blockLiveness=new BlockLiveness(block,usages);
    livenessPerBlock.put(block,blockLiveness);
    livenesses.add(blockLiveness);
  }
  Deque<CfgBlock> queue=new ArrayDeque<>(cfg.blocks());
  while (!queue.isEmpty()) {
    CfgBlock block=queue.pop();
    BlockLiveness blockLiveness=livenessPerBlock.get(block);
    boolean changed=blockLiveness.updateLiveInAndOut(livenessPerBlock);
    if (changed) {
      block.predecessors().forEach(queue::push);
    }
  }
}",0.9984894259818732
186253,"public GlobalVariableNames(@Nullable Settings settings){
  ImmutableSet.Builder<String> namesBuilder=ImmutableSet.builder();
  namesBuilder.addAll(globalsFromEnvironment(""String_Node_Str"").get());
  if (settings != null) {
    namesBuilder.add(settings.getStringArray(GLOBALS_PROPERTY_KEY));
    for (    String environmentName : settings.getStringArray(ENVIRONMENTS_PROPERTY_KEY)) {
      Optional<Set<String>> namesFromCurrentEnvironment=globalsFromEnvironment(environmentName);
      if (namesFromCurrentEnvironment.isPresent()) {
        namesBuilder.addAll(namesFromCurrentEnvironment.get());
      }
 else {
        LOGGER.warn(ENVIRONMENTS_PROPERTY_KEY + ""String_Node_Str"" + environmentName);
      }
    }
  }
  this.names=namesBuilder.build();
}","public GlobalVariableNames(@Nullable Settings settings){
  ImmutableSet.Builder<String> namesBuilder=ImmutableSet.builder();
  if (globalsFromEnvironment(""String_Node_Str"").isPresent()) {
    namesBuilder.addAll(globalsFromEnvironment(""String_Node_Str"").get());
  }
  if (settings != null) {
    namesBuilder.add(settings.getStringArray(GLOBALS_PROPERTY_KEY));
    for (    String environmentName : settings.getStringArray(ENVIRONMENTS_PROPERTY_KEY)) {
      Optional<Set<String>> namesFromCurrentEnvironment=globalsFromEnvironment(environmentName);
      if (namesFromCurrentEnvironment.isPresent()) {
        namesBuilder.addAll(namesFromCurrentEnvironment.get());
      }
 else {
        LOGGER.warn(ENVIRONMENTS_PROPERTY_KEY + ""String_Node_Str"" + environmentName);
      }
    }
  }
  this.names=namesBuilder.build();
}",0.9562460367786936
186254,"@Override public void visitFunctionDeclaration(FunctionDeclarationTree tree){
  IdentifierTree name=tree.name();
  Preconditions.checkState(name.symbol() != null,""String_Node_Str"",name.name(),((JavaScriptTree)tree).getLine());
  name.symbol().addType(FunctionType.create(tree));
  super.visitFunctionDeclaration(tree);
}","@Override public void visitFunctionDeclaration(FunctionDeclarationTree tree){
  IdentifierTree name=tree.name();
  String nameName=name.name();
  Preconditions.checkState(name.symbol() != null,""String_Node_Str"",nameName,((JavaScriptTree)tree).getLine());
  name.symbol().addType(FunctionType.create(tree));
  super.visitFunctionDeclaration(tree);
}",0.937125748502994
186255,"/** 
 * Parse the given string and return the first descendant of the given kind.
 * @param s                  the string to parse
 * @param descendantToReturn the node kind to seek in the generated tree
 * @return the node found for the given kind, null if not found.
 */
protected <T extends Tree>T parse(String s,Kind descendantToReturn) throws Exception {
  Tree node=p.parse(s);
  checkFullFidelity(node,s);
  return (T)getFirstDescendant((JavaScriptTree)node,descendantToReturn);
}","/** 
 * Parse the given string and return the first descendant of the given kind.
 * @param s                  the string to parse
 * @param descendantToReturn the node kind to seek in the generated tree
 * @return the node found for the given kind, null if not found.
 */
@SuppressWarnings(""String_Node_Str"") protected <T extends Tree>T parse(String s,Kind descendantToReturn) throws Exception {
  Tree node=p.parse(s);
  checkFullFidelity(node,s);
  return (T)getFirstDescendant((JavaScriptTree)node,descendantToReturn);
}",0.963402571711177
186256,"public void visitCommaOperatorExpression(Tree expression){
  if (expression == null) {
    return;
  }
  if (expression.is(Kind.COMMA_OPERATOR)) {
    visitCommaOperatorExpression(((BinaryExpressionTree)expression).leftOperand());
    visitCommaOperatorExpression(((BinaryExpressionTree)expression).rightOperand());
  }
 else   if (expression instanceof AssignmentExpressionTree) {
    super.visitAssignmentExpression((AssignmentExpressionTree)expression);
  }
 else {
    scan(expression);
  }
}","public void visitCommaOperatorExpression(@Nullable Tree expression){
  if (expression == null) {
    return;
  }
  if (expression.is(Kind.COMMA_OPERATOR)) {
    visitCommaOperatorExpression(((BinaryExpressionTree)expression).leftOperand());
    visitCommaOperatorExpression(((BinaryExpressionTree)expression).rightOperand());
  }
 else   if (expression instanceof AssignmentExpressionTree) {
    super.visitAssignmentExpression((AssignmentExpressionTree)expression);
  }
 else {
    scan(expression);
  }
}",0.9900199600798404
186257,"private void except(Tree tree){
  if (tree != null && tree.is(Tree.Kind.EMPTY_STATEMENT)) {
    exceptedStatements.add((EmptyStatementTree)tree);
  }
}","private void except(Tree tree){
  if (tree.is(Tree.Kind.EMPTY_STATEMENT)) {
    exceptedStatements.add((EmptyStatementTree)tree);
  }
}",0.944055944055944
186258,"private static List<ExpressionTree> updatedExpressions(ExpressionTree expression){
  if (expression == null) {
    return ImmutableList.<ExpressionTree>of();
  }
  UpdateVisitor visitor=new UpdateVisitor();
  expression.accept(visitor);
  return visitor.updatedExpressions;
}","private static List<ExpressionTree> updatedExpressions(@Nullable ExpressionTree expression){
  if (expression == null) {
    return ImmutableList.<ExpressionTree>of();
  }
  UpdateVisitor visitor=new UpdateVisitor();
  expression.accept(visitor);
  return visitor.updatedExpressions;
}",0.9821428571428572
186259,"private void increaseNumberOfJumpInScopes(SyntaxToken jump,IdentifierTree label){
  for (  JumpTarget jumpTarget : jumpTargets) {
    String labelName=label == null ? null : label.name();
    jumpTarget.jumps.add(jump);
    if (Objects.equal(labelName,jumpTarget.label)) {
      break;
    }
  }
}","private void increaseNumberOfJumpInScopes(SyntaxToken jump,@Nullable IdentifierTree label){
  for (  JumpTarget jumpTarget : jumpTargets) {
    String labelName=label == null ? null : label.name();
    jumpTarget.jumps.add(jump);
    if (Objects.equal(labelName,jumpTarget.label)) {
      break;
    }
  }
}",0.9834437086092715
186260,"public JsCfgBranchingBlock(Tree branchingTree,JsCfgBlock trueSuccessor,JsCfgBlock falseSuccessor){
  Preconditions.checkArgument(branchingTree != null,""String_Node_Str"");
  Preconditions.checkArgument(trueSuccessor != null && falseSuccessor != null,""String_Node_Str"");
  this.trueSuccessor=trueSuccessor;
  this.falseSuccessor=falseSuccessor;
  this.branchingTree=branchingTree;
}","public JsCfgBranchingBlock(Tree branchingTree,JsCfgBlock trueSuccessor,JsCfgBlock falseSuccessor){
  this.trueSuccessor=trueSuccessor;
  this.falseSuccessor=falseSuccessor;
  this.branchingTree=branchingTree;
}",0.3898305084745763
186261,"private ProgramState executeInitializedBinding(InitializedBindingElementTree initializedBindingElementTree,ProgramState programState){
  ProgramState newProgramState=programState;
  if (((JavaScriptTree)initializedBindingElementTree).getParent().is(Kind.OBJECT_BINDING_PATTERN,Kind.ARRAY_BINDING_PATTERN)) {
    newProgramState=programState.removeLastValue();
  }
 else {
    BindingElementTree variable=initializedBindingElementTree.left();
    if (variable.is(Kind.BINDING_IDENTIFIER)) {
      newProgramState=assignment(programState,variable);
    }
    newProgramState=newProgramState.clearStack(initializedBindingElementTree);
  }
  return newProgramState;
}","private ProgramState executeInitializedBinding(InitializedBindingElementTree initializedBindingElementTree,ProgramState programState){
  ProgramState newProgramState=programState;
  if (((JavaScriptTree)initializedBindingElementTree).getParent().is(Kind.OBJECT_BINDING_PATTERN,Kind.ARRAY_BINDING_PATTERN,Kind.BINDING_PROPERTY)) {
    newProgramState=programState.removeLastValue();
  }
 else {
    BindingElementTree variable=initializedBindingElementTree.left();
    if (variable.is(Kind.BINDING_IDENTIFIER)) {
      newProgramState=assignment(programState,variable);
    }
    newProgramState=newProgramState.clearStack(initializedBindingElementTree);
  }
  return newProgramState;
}",0.983679525222552
186262,"public ExpressionTree EXPONENTIATION_EXPRESSION(){
  return b.<ExpressionTree>nonterminal().is(f.newExponentiation(b.zeroOrMore(f.newTuple31(UNARY_EXPRESSION(),b.token(JavaScriptPunctuator.EXP))),UNARY_EXPRESSION()));
}","public ExpressionTree EXPONENTIATION_EXPRESSION(){
  return b.<ExpressionTree>nonterminal().is(f.newExponentiation(UNARY_EXPRESSION(),b.zeroOrMore(f.newTuple31(b.token(JavaScriptPunctuator.EXP),UNARY_EXPRESSION()))));
}",0.7534246575342466
186263,"public ExpressionTree newExponentiation(Optional<List<Tuple<ExpressionTree,InternalSyntaxToken>>> operatorAndOperands,ExpressionTree expression){
  if (!operatorAndOperands.isPresent()) {
    return expression;
  }
  ExpressionTree result=expression;
  for (  Tuple<ExpressionTree,InternalSyntaxToken> t : Lists.reverse(operatorAndOperands.get())) {
    result=new BinaryExpressionTreeImpl(getBinaryOperator(t.second),t.first,t.second(),result);
  }
  return result;
}","public ExpressionTree newExponentiation(ExpressionTree expression,Optional<List<Tuple<InternalSyntaxToken,ExpressionTree>>> operatorAndOperands){
  if (!operatorAndOperands.isPresent()) {
    return expression;
  }
  List<Tuple<InternalSyntaxToken,ExpressionTree>> list=operatorAndOperands.get();
  ExpressionTree result=list.get(list.size() - 1).second;
  for (int i=list.size() - 1; i > 0; i--) {
    result=new BinaryExpressionTreeImpl(Kind.EXPONENT,list.get(i - 1).second,list.get(i).first,result);
  }
  return new BinaryExpressionTreeImpl(Kind.EXPONENT,expression,list.get(0).first,result);
}",0.5328330206378987
186264,"public int endLine(){
  return lastToken.line();
}","public int endLine(){
  return lastToken.line() + lastTokenLinesNumber - 1;
}",0.7874015748031497
186265,"public int endLineOffset(){
  return lastToken.column() + lastToken.text().length();
}","public int endLineOffset(){
  if (lastTokenLinesNumber == 1) {
    return lastToken.column() + lastToken.text().length();
  }
 else {
    return lastTokenLastLineLength;
  }
}",0.6590038314176245
186266,"private void checkJQueryProperty(ExpressionTree expressionTree,List<String> deprecated,String parentheses){
  if (expressionTree.is(Tree.Kind.DOT_MEMBER_EXPRESSION)) {
    ExpressionTree object=((DotMemberExpressionTreeImpl)expressionTree).object();
    ExpressionTree property=((DotMemberExpressionTreeImpl)expressionTree).property();
    if (isJQueryObject(object) && propertyIsDeprecated(property,deprecated)) {
      getContext().addIssue(this,expressionTree,String.format(MESSAGE,((IdentifierTree)property).name() + parentheses));
    }
  }
}","private void checkJQueryProperty(ExpressionTree expressionTree,List<String> deprecated,String parentheses){
  if (expressionTree.is(Tree.Kind.DOT_MEMBER_EXPRESSION)) {
    ExpressionTree object=((DotMemberExpressionTreeImpl)expressionTree).object();
    ExpressionTree property=((DotMemberExpressionTreeImpl)expressionTree).property();
    if (isJQueryObject(object) && propertyIsDeprecated(property,deprecated)) {
      getContext().addIssue(this,property,String.format(MESSAGE,((IdentifierTree)property).name() + parentheses));
    }
  }
}",0.9797794117647058
186267,"private void checkSelectorProperty(ExpressionTree expressionTree,List<String> deprecated,String parentheses){
  if (expressionTree.is(Tree.Kind.DOT_MEMBER_EXPRESSION)) {
    ExpressionTree object=((DotMemberExpressionTreeImpl)expressionTree).object();
    ExpressionTree property=((DotMemberExpressionTreeImpl)expressionTree).property();
    if (isMultiLevelSelector(object) && propertyIsDeprecated(property,deprecated)) {
      getContext().addIssue(this,expressionTree,String.format(MESSAGE,((IdentifierTree)property).name() + parentheses));
    }
  }
}","private void checkSelectorProperty(ExpressionTree expressionTree,List<String> deprecated,String parentheses){
  if (expressionTree.is(Tree.Kind.DOT_MEMBER_EXPRESSION)) {
    ExpressionTree object=((DotMemberExpressionTreeImpl)expressionTree).object();
    ExpressionTree property=((DotMemberExpressionTreeImpl)expressionTree).property();
    if (isMultiLevelSelector(object) && propertyIsDeprecated(property,deprecated)) {
      getContext().addIssue(this,property,String.format(MESSAGE,((IdentifierTree)property).name() + parentheses));
    }
  }
}",0.980072463768116
186268,"@Test public void test(){
  DeprecatedJQueryAPICheck check=new DeprecatedJQueryAPICheck();
  SourceFile file=scanFile(""String_Node_Str"",check);
  CheckMessagesVerifier.verify(file.getCheckMessages()).next().atLine(1).withMessage(""String_Node_Str"").next().atLine(3).withMessage(""String_Node_Str"").next().atLine(5).withMessage(""String_Node_Str"").next().atLine(7).withMessage(""String_Node_Str"").next().atLine(9).withMessage(""String_Node_Str"").next().atLine(11).withMessage(""String_Node_Str"").noMore();
}","@Test public void test(){
  DeprecatedJQueryAPICheck check=new DeprecatedJQueryAPICheck();
  SourceFile file=scanFile(""String_Node_Str"",check);
  CheckMessagesVerifier.verify(file.getCheckMessages()).next().atLine(1).withMessage(""String_Node_Str"").next().atLine(3).withMessage(""String_Node_Str"").next().atLine(5).withMessage(""String_Node_Str"").next().atLine(7).withMessage(""String_Node_Str"").next().atLine(9).withMessage(""String_Node_Str"").next().atLine(11).withMessage(""String_Node_Str"").next().atLine(17).withMessage(""String_Node_Str"").noMore();
}",0.9532888465204956
186269,"public FileLinesVisitor(FileLinesContextFactory fileLinesContextFactory,FileSystem fileSystem){
  this.fileLinesContextFactory=fileLinesContextFactory;
  this.fileSystem=fileSystem;
}","public FileLinesVisitor(FileLinesContextFactory fileLinesContextFactory,FileSystem fileSystem,PathResolver pathResolver){
  this.fileLinesContextFactory=fileLinesContextFactory;
  this.fileSystem=fileSystem;
  this.pathResolver=pathResolver;
}",0.8591549295774648
186270,"@Override public void leaveFile(AstNode astNode){
  InputFile inputFile=fileSystem.inputFile(fileSystem.predicates().is(getContext().getFile()));
  if (inputFile != null) {
    FileLinesContext fileLinesContext=fileLinesContextFactory.createFor(inputFile);
    int fileLength=getContext().peekSourceCode().getInt(EcmaScriptMetric.LINES);
    for (int line=1; line <= fileLength; line++) {
      fileLinesContext.setIntValue(CoreMetrics.NCLOC_DATA_KEY,line,linesOfCode.contains(line) ? 1 : 0);
      fileLinesContext.setIntValue(CoreMetrics.COMMENT_LINES_DATA_KEY,line,linesOfComments.contains(line) ? 1 : 0);
    }
    fileLinesContext.save();
  }
 else {
    LOG.warn(""String_Node_Str"",getContext().getFile().getName());
  }
  linesOfCode.clear();
  linesOfComments.clear();
}","@Override public void leaveFile(AstNode astNode){
  FileLinesContext fileLinesContext=fileLinesContextFactory.createFor(File.create(pathResolver.relativePath(fileSystem.baseDir(),getContext().getFile().getAbsoluteFile())));
  if (fileLinesContext != null) {
    int fileLength=getContext().peekSourceCode().getInt(EcmaScriptMetric.LINES);
    for (int line=1; line <= fileLength; line++) {
      fileLinesContext.setIntValue(CoreMetrics.NCLOC_DATA_KEY,line,linesOfCode.contains(line) ? 1 : 0);
      fileLinesContext.setIntValue(CoreMetrics.COMMENT_LINES_DATA_KEY,line,linesOfComments.contains(line) ? 1 : 0);
    }
    fileLinesContext.save();
  }
 else {
    LOG.warn(""String_Node_Str"",getContext().getFile().getName());
  }
  linesOfCode.clear();
  linesOfComments.clear();
}",0.7755627009646302
186271,"@Test public void test() throws Exception {
  FileLinesContextFactory fileLinesContextFactory=mock(FileLinesContextFactory.class);
  FileLinesContext fileLinesContext=mock(FileLinesContext.class);
  when(fileLinesContextFactory.createFor(any(InputFile.class))).thenReturn(fileLinesContext);
  File file=TestUtils.getResource(""String_Node_Str"");
  FileLinesVisitor visitor=new FileLinesVisitor(fileLinesContextFactory,newFileSystem(file));
  JavaScriptAstScanner.scanSingleFile(file,visitor);
  verify(fileLinesContext,times(3)).setIntValue(eq(CoreMetrics.NCLOC_DATA_KEY),anyInt(),eq(1));
  verify(fileLinesContext,times(1)).setIntValue(eq(CoreMetrics.COMMENT_LINES_DATA_KEY),anyInt(),eq(1));
}","@Test public void test() throws Exception {
  FileLinesContextFactory fileLinesContextFactory=mock(FileLinesContextFactory.class);
  FileLinesContext fileLinesContext=mock(FileLinesContext.class);
  when(fileLinesContextFactory.createFor(any(Resource.class))).thenReturn(fileLinesContext);
  File file=TestUtils.getResource(""String_Node_Str"");
  FileLinesVisitor visitor=new FileLinesVisitor(fileLinesContextFactory,newFileSystem(file),new PathResolver());
  JavaScriptAstScanner.scanSingleFile(file,visitor);
  verify(fileLinesContext,times(3)).setIntValue(eq(CoreMetrics.NCLOC_DATA_KEY),anyInt(),eq(1));
  verify(fileLinesContext,times(1)).setIntValue(eq(CoreMetrics.COMMENT_LINES_DATA_KEY),anyInt(),eq(1));
}",0.9772079772079773
186272,"private FileSystem newFileSystem(File file){
  DefaultFileSystem fs=new DefaultFileSystem();
  fs.add(new DefaultInputFile(file.getName()).setAbsolutePath(file.getAbsolutePath()).setType(InputFile.Type.MAIN));
  return fs;
}","private FileSystem newFileSystem(File file) throws URISyntaxException {
  DefaultFileSystem fs=new DefaultFileSystem();
  fs.setBaseDir(TestUtils.getResource(""String_Node_Str""));
  fs.add(new DefaultInputFile(file.getName()).setAbsolutePath(file.getAbsolutePath()).setType(InputFile.Type.MAIN));
  return fs;
}",0.8389513108614233
186273,"public JavaScriptSquidSensor(RulesProfile profile,FileLinesContextFactory fileLinesContextFactory,ResourcePerspectives resourcePerspectives,FileSystem fileSystem,NoSonarFilter noSonarFilter){
  this.annotationCheckFactory=AnnotationCheckFactory.create(profile,CheckList.REPOSITORY_KEY,CheckList.getChecks());
  this.fileLinesContextFactory=fileLinesContextFactory;
  this.resourcePerspectives=resourcePerspectives;
  this.fileSystem=fileSystem;
  this.noSonarFilter=noSonarFilter;
  this.mainFilePredicate=fileSystem.predicates().and(fileSystem.predicates().hasType(InputFile.Type.MAIN),fileSystem.predicates().hasLanguage(JavaScript.KEY));
}","public JavaScriptSquidSensor(RulesProfile profile,FileLinesContextFactory fileLinesContextFactory,ResourcePerspectives resourcePerspectives,FileSystem fileSystem,NoSonarFilter noSonarFilter,PathResolver pathResolver){
  this.annotationCheckFactory=AnnotationCheckFactory.create(profile,CheckList.REPOSITORY_KEY,CheckList.getChecks());
  this.fileLinesContextFactory=fileLinesContextFactory;
  this.resourcePerspectives=resourcePerspectives;
  this.fileSystem=fileSystem;
  this.noSonarFilter=noSonarFilter;
  this.pathResolver=pathResolver;
  this.mainFilePredicate=fileSystem.predicates().and(fileSystem.predicates().hasType(InputFile.Type.MAIN),fileSystem.predicates().hasLanguage(JavaScript.KEY));
}",0.9553571428571428
186274,"@Override public void analyse(Project project,SensorContext context){
  this.context=context;
  List<CodeVisitor> astNodeVisitors=Lists.newArrayList();
  List<JavaScriptFileScanner> treeVisitors=Lists.newArrayList();
  Collection<CodeVisitor> squidChecks=annotationCheckFactory.getChecks();
  for (  CodeVisitor visitor : squidChecks) {
    if (visitor instanceof JavaScriptFileScanner) {
      treeVisitors.add((JavaScriptFileScanner)visitor);
    }
 else {
      astNodeVisitors.add(visitor);
    }
  }
  astNodeVisitors.add(new VisitorsBridge(treeVisitors));
  astNodeVisitors.add(new FileLinesVisitor(fileLinesContextFactory,fileSystem));
  scanner=JavaScriptAstScanner.create(createConfiguration(),astNodeVisitors.toArray(new SquidAstVisitor[astNodeVisitors.size()]));
  scanner.scanFiles(Lists.newArrayList(fileSystem.files(mainFilePredicate)));
  Collection<SourceCode> squidSourceFiles=scanner.getIndex().search(new QueryByType(SourceFile.class));
  save(squidSourceFiles);
}","@Override public void analyse(Project project,SensorContext context){
  this.context=context;
  List<CodeVisitor> astNodeVisitors=Lists.newArrayList();
  List<JavaScriptFileScanner> treeVisitors=Lists.newArrayList();
  Collection<CodeVisitor> squidChecks=annotationCheckFactory.getChecks();
  for (  CodeVisitor visitor : squidChecks) {
    if (visitor instanceof JavaScriptFileScanner) {
      treeVisitors.add((JavaScriptFileScanner)visitor);
    }
 else {
      astNodeVisitors.add(visitor);
    }
  }
  astNodeVisitors.add(new VisitorsBridge(treeVisitors));
  astNodeVisitors.add(new FileLinesVisitor(fileLinesContextFactory,fileSystem,pathResolver));
  scanner=JavaScriptAstScanner.create(createConfiguration(),astNodeVisitors.toArray(new SquidAstVisitor[astNodeVisitors.size()]));
  scanner.scanFiles(Lists.newArrayList(fileSystem.files(mainFilePredicate)));
  Collection<SourceCode> squidSourceFiles=scanner.getIndex().search(new QueryByType(SourceFile.class));
  save(squidSourceFiles);
}",0.9934310257705912
186275,"private void save(Collection<SourceCode> squidSourceFiles){
  for (  SourceCode squidSourceFile : squidSourceFiles) {
    SourceFile squidFile=(SourceFile)squidSourceFile;
    InputFile inputFile=fileSystem.inputFile(fileSystem.predicates().hasAbsolutePath(squidFile.getKey()));
    if (inputFile != null) {
      File sonarFile=File.create(inputFile.relativePath());
      noSonarFilter.addResource(sonarFile,squidFile.getNoSonarTagLines());
      saveClassComplexity(sonarFile,squidFile);
      saveFilesComplexityDistribution(sonarFile,squidFile);
      saveFunctionsComplexityAndDistribution(sonarFile,squidFile);
      saveMeasures(sonarFile,squidFile);
      saveIssues(sonarFile,squidFile);
    }
 else {
      LOG.warn(""String_Node_Str"",squidFile.getKey());
    }
  }
}","private void save(Collection<SourceCode> squidSourceFiles){
  for (  SourceCode squidSourceFile : squidSourceFiles) {
    SourceFile squidFile=(SourceFile)squidSourceFile;
    File sonarFile=context.getResource(File.create(pathResolver.relativePath(fileSystem.baseDir(),new java.io.File(squidFile.getKey()))));
    if (sonarFile != null) {
      noSonarFilter.addResource(sonarFile,squidFile.getNoSonarTagLines());
      saveClassComplexity(sonarFile,squidFile);
      saveFilesComplexityDistribution(sonarFile,squidFile);
      saveFunctionsComplexityAndDistribution(sonarFile,squidFile);
      saveMeasures(sonarFile,squidFile);
      saveIssues(sonarFile,squidFile);
    }
 else {
      LOG.warn(""String_Node_Str"",squidFile.getKey());
    }
  }
}",0.8047182175622543
186276,"@Test public void test_to_string(){
  JavaScriptSquidSensor sensor=new JavaScriptSquidSensor(mock(RulesProfile.class),fileLinesContextFactory,mock(ResourcePerspectives.class),new DefaultFileSystem(),new NoSonarFilter(mock(SensorContext.class)));
  assertThat(sensor.toString()).isNotNull();
}","@Test public void test_to_string(){
  JavaScriptSquidSensor sensor=new JavaScriptSquidSensor(mock(RulesProfile.class),fileLinesContextFactory,mock(ResourcePerspectives.class),new DefaultFileSystem(),new NoSonarFilter(mock(SensorContext.class)),new PathResolver());
  assertThat(sensor.toString()).isNotNull();
}",0.9684908789386402
186277,"@Test public void should_execute_if_js_files(){
  DefaultFileSystem localFS=new DefaultFileSystem();
  JavaScriptSquidSensor sensor=new JavaScriptSquidSensor(mock(RulesProfile.class),fileLinesContextFactory,mock(ResourcePerspectives.class),localFS,new NoSonarFilter(mock(SensorContext.class)));
  assertThat(sensor.shouldExecuteOnProject(project)).isFalse();
  localFS.add(new DefaultInputFile(""String_Node_Str"").setType(InputFile.Type.MAIN).setLanguage(JavaScript.KEY));
  assertThat(sensor.shouldExecuteOnProject(project)).isTrue();
}","@Test public void should_execute_if_js_files(){
  DefaultFileSystem localFS=new DefaultFileSystem();
  JavaScriptSquidSensor sensor=new JavaScriptSquidSensor(mock(RulesProfile.class),fileLinesContextFactory,mock(ResourcePerspectives.class),localFS,new NoSonarFilter(mock(SensorContext.class)),new PathResolver());
  assertThat(sensor.shouldExecuteOnProject(project)).isFalse();
  localFS.add(new DefaultInputFile(""String_Node_Str"").setType(InputFile.Type.MAIN).setLanguage(JavaScript.KEY));
  assertThat(sensor.shouldExecuteOnProject(project)).isTrue();
}",0.9825847846012832
186278,"@Test public void should_analyse(){
  fileSystem.add(new DefaultInputFile(""String_Node_Str"").setAbsolutePath(TestUtils.getResource(""String_Node_Str"").getAbsolutePath()).setType(InputFile.Type.MAIN).setLanguage(JavaScript.KEY));
  SensorContext context=mock(SensorContext.class);
  JavaScriptSquidSensor sensor=new JavaScriptSquidSensor(mock(RulesProfile.class),fileLinesContextFactory,mock(ResourcePerspectives.class),fileSystem,new NoSonarFilter(mock(SensorContext.class)));
  sensor.analyse(project,context);
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.LINES),eq(32.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.NCLOC),eq(18.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.CLASSES),eq(1.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.FUNCTIONS),eq(2.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.ACCESSORS),eq(2.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.STATEMENTS),eq(8.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.COMPLEXITY),eq(3.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.COMPLEXITY_IN_CLASSES),eq(0.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.COMMENT_LINES),eq(2.0));
}","@Test public void should_analyse(){
  fileSystem.setBaseDir(TestUtils.getResource(""String_Node_Str""));
  fileSystem.add(new DefaultInputFile(""String_Node_Str"").setAbsolutePath(TestUtils.getResource(""String_Node_Str"").getAbsolutePath()).setType(InputFile.Type.MAIN).setLanguage(JavaScript.KEY));
  SensorContext context=mock(SensorContext.class);
  when(context.getResource(any(Resource.class))).thenReturn(File.create((new PathResolver()).relativePath(fileSystem.baseDir(),TestUtils.getResource(""String_Node_Str""))));
  JavaScriptSquidSensor sensor=new JavaScriptSquidSensor(mock(RulesProfile.class),fileLinesContextFactory,mock(ResourcePerspectives.class),fileSystem,new NoSonarFilter(mock(SensorContext.class)),new PathResolver());
  sensor.analyse(project,context);
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.LINES),eq(32.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.NCLOC),eq(18.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.CLASSES),eq(1.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.FUNCTIONS),eq(2.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.ACCESSORS),eq(2.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.STATEMENTS),eq(8.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.COMPLEXITY),eq(3.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.COMPLEXITY_IN_CLASSES),eq(0.0));
  verify(context).saveMeasure(any(Resource.class),eq(CoreMetrics.COMMENT_LINES),eq(2.0));
}",0.8680701754385964
186279,"@Override public SeparatedList<ExpressionTree> parameters(){
  return parameters();
}","@Override public SeparatedList<ExpressionTree> parameters(){
  return parameters;
}",0.988095238095238
186280,"@Override public SeparatedList<ExpressionTree> parameters(){
  return parameters();
}","@Override public SeparatedList<ExpressionTree> parameters(){
  return parameters;
}",0.988095238095238
186281,"@Override public SeparatedList<ExpressionTree> parameters(){
  return parameters();
}","@Override public SeparatedList<ExpressionTree> parameters(){
  return parameters;
}",0.988095238095238
186282,"private void saveClassComplexity(org.sonar.api.resources.File sonarFile,SourceFile squidFile){
  Collection<SourceCode> classes=scanner.getIndex().search(new QueryByParent(squidFile),new QueryByType(SourceClass.class));
  double complexityInClasses=0;
  for (  SourceCode squidClass : classes) {
    double classComplexity=squidClass.getDouble(EcmaScriptMetric.COMPLEXITY);
    complexityInClasses+=classComplexity;
  }
  context.saveMeasure(sonarFile,CoreMetrics.COMPLEXITY_IN_CLASSES,complexityInClasses);
}","private void saveClassComplexity(org.sonar.api.resources.File sonarFile,SourceFile squidFile){
  double complexityInClasses=0;
  Set<SourceCode> children=squidFile.getChildren();
  if (children != null) {
    for (    SourceCode sourceCode : squidFile.getChildren()) {
      if (sourceCode.isType(SourceClass.class)) {
        complexityInClasses+=sourceCode.getDouble(EcmaScriptMetric.COMPLEXITY);
      }
    }
  }
  context.saveMeasure(sonarFile,CoreMetrics.COMPLEXITY_IN_CLASSES,complexityInClasses);
}",0.5793103448275863
186283,"public Map<String,CoverageMeasuresBuilder> parse(List<String> lines){
  final Map<String,FileData> files=Maps.newHashMap();
  FileData fileData=new FileData();
  for (  String line : lines) {
    if (line.startsWith(SF)) {
      String filePath=line.substring(SF.length());
      try {
        filePath=LCOVSensor.getIOFile(moduleBaseDir,filePath).getCanonicalPath();
      }
 catch (      IOException e) {
        filePath=""String_Node_Str"";
      }
      fileData=files.get(filePath);
      if (fileData == null) {
        fileData=new FileData();
        files.put(filePath,fileData);
      }
    }
 else     if (line.startsWith(DA)) {
      String execution=line.substring(DA.length());
      String executionCount=execution.substring(execution.indexOf(',') + 1);
      String lineNumber=execution.substring(0,execution.indexOf(','));
      fileData.addLine(Integer.valueOf(lineNumber),Integer.valueOf(executionCount));
    }
 else     if (line.startsWith(BRDA)) {
      String[] tokens=line.substring(BRDA.length()).trim().split(""String_Node_Str"");
      String lineNumber=tokens[0];
      String branchNumber=tokens[2];
      String taken=tokens[3];
      fileData.addBranch(Integer.valueOf(lineNumber),branchNumber,""String_Node_Str"".equals(taken) ? 0 : Integer.valueOf(taken));
    }
  }
  Map<String,CoverageMeasuresBuilder> coveredFiles=Maps.newHashMap();
  for (  Map.Entry<String,FileData> e : files.entrySet()) {
    coveredFiles.put(e.getKey(),e.getValue().convert());
  }
  return coveredFiles;
}","public Map<String,CoverageMeasuresBuilder> parse(List<String> lines){
  final Map<String,FileData> files=Maps.newHashMap();
  FileData fileData=new FileData();
  for (  String line : lines) {
    if (line.startsWith(SF)) {
      String filePath=line.substring(SF.length());
      try {
        filePath=LCOVSensor.getIOFile(moduleBaseDir,filePath).getCanonicalPath();
      }
 catch (      IOException e) {
        filePath=""String_Node_Str"";
        LOG.error(""String_Node_Str"",filePath,e);
      }
      fileData=files.get(filePath);
      if (fileData == null) {
        fileData=new FileData();
        files.put(filePath,fileData);
      }
    }
 else     if (line.startsWith(DA)) {
      String execution=line.substring(DA.length());
      String executionCount=execution.substring(execution.indexOf(',') + 1);
      String lineNumber=execution.substring(0,execution.indexOf(','));
      fileData.addLine(Integer.valueOf(lineNumber),Integer.valueOf(executionCount));
    }
 else     if (line.startsWith(BRDA)) {
      String[] tokens=line.substring(BRDA.length()).trim().split(""String_Node_Str"");
      String lineNumber=tokens[0];
      String branchNumber=tokens[2];
      String taken=tokens[3];
      fileData.addBranch(Integer.valueOf(lineNumber),branchNumber,""String_Node_Str"".equals(taken) ? 0 : Integer.valueOf(taken));
    }
  }
  Map<String,CoverageMeasuresBuilder> coveredFiles=Maps.newHashMap();
  for (  Map.Entry<String,FileData> e : files.entrySet()) {
    coveredFiles.put(e.getKey(),e.getValue().convert());
  }
  return coveredFiles;
}",0.9840338872596938
186284,"public JavaScriptCommonRulesEngine(){
  super(JavaScript.KEY);
}","/** 
 * Batch side
 */
public JavaScriptCommonRulesEngine(RulesProfile profile,ProjectFileSystem fs){
  super(JavaScript.KEY,profile,fs);
}",0.6305418719211823
186285,"private static void executeCommandForPid(String pid,String command) throws AttachNotSupportedException, IOException, UnsupportedEncodingException {
  VirtualMachine vm=VirtualMachine.attach(pid);
  HotSpotVirtualMachine hvm=(HotSpotVirtualMachine)vm;
  try (InputStream in=hvm.executeJCmd(command)){
    byte b[]=new byte[256];
    int n;
    do {
      n=in.read(b);
      if (n > 0) {
        String s=new String(b,0,n,""String_Node_Str"");
        System.out.print(s);
      }
    }
 while (n > 0);
  }
   vm.detach();
}","private static void executeCommandForPid(String pid,String command) throws AttachNotSupportedException, IOException, UnsupportedEncodingException {
  VirtualMachine vm=VirtualMachine.attach(pid);
  HotSpotVirtualMachine hvm=(HotSpotVirtualMachine)vm;
  String lines[]=command.split(""String_Node_Str"");
  for (  String line : lines) {
    try (InputStream in=hvm.executeJCmd(line)){
      byte b[]=new byte[256];
      int n;
      do {
        n=in.read(b);
        if (n > 0) {
          String s=new String(b,0,n,""String_Node_Str"");
          System.out.print(s);
        }
      }
 while (n > 0);
    }
   }
  vm.detach();
}",0.8832752613240418
186286,"/** 
 * Create a MulticastSocket bound to the specified socket address. <p> Or, if the address is <code>null</code>, create an unbound socket. <p> <p>If there is a security manager, its <code>checkListen</code> method is first called with the SocketAddress port as its argument to ensure the operation is allowed. This could result in a SecurityException. <p> When the socket is created the  {@link DatagramSocket#setReuseAddress(boolean)} method iscalled to enable the SO_REUSEADDR socket option.
 * @param bindaddr Socket address to bind to, or <code>null</code> foran unbound socket.
 * @exception IOException if an I/O exception occurswhile creating the MulticastSocket
 * @exception SecurityException  if a security manager exists and its<code>checkListen</code> method doesn't allow the operation.
 * @see SecurityManager#checkListen
 * @see java.net.DatagramSocket#setReuseAddress(boolean)
 * @since 1.4
 */
public MulticastSocket(SocketAddress bindaddr) throws IOException {
  super((SocketAddress)null);
  setReuseAddress(true);
  if (bindaddr != null) {
    bind(bindaddr);
  }
}","/** 
 * Create a MulticastSocket bound to the specified socket address. <p> Or, if the address is <code>null</code>, create an unbound socket. <p> <p>If there is a security manager, its <code>checkListen</code> method is first called with the SocketAddress port as its argument to ensure the operation is allowed. This could result in a SecurityException. <p> When the socket is created the  {@link DatagramSocket#setReuseAddress(boolean)} method iscalled to enable the SO_REUSEADDR socket option.
 * @param bindaddr Socket address to bind to, or <code>null</code> foran unbound socket.
 * @exception IOException if an I/O exception occurswhile creating the MulticastSocket
 * @exception SecurityException  if a security manager exists and its<code>checkListen</code> method doesn't allow the operation.
 * @see SecurityManager#checkListen
 * @see java.net.DatagramSocket#setReuseAddress(boolean)
 * @since 1.4
 */
public MulticastSocket(SocketAddress bindaddr) throws IOException {
  super((SocketAddress)null);
  setReuseAddress(true);
  if (bindaddr != null) {
    bind(bindaddr);
  }
  NetworkInterface defaultInterface=NetworkInterface.getDefault();
  if (defaultInterface != null) {
    setNetworkInterface(defaultInterface);
  }
}",0.9363714531384352
186287,"protected void close(){
  if (fd != null || fd1 != null) {
    datagramSocketClose();
    fd=null;
    fd1=null;
  }
}","protected void close(){
  if (fd != null || fd1 != null) {
    datagramSocketClose();
    ResourceManager.afterUdpClose();
    fd=null;
    fd1=null;
  }
}",0.8644688644688645
186288,"/** 
 * Initializes an APRep object.
 * @param encoding a single DER-encoded value.
 * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
 * @exception IOException if an I/O error occurs while reading encoded data.
 * @exception KrbApErrException if the value read from the DER-encoded datastream does not match the pre-defined value.
 */
private void init(DerValue encoding) throws Asn1Exception, KrbApErrException, IOException {
  if (((encoding.getTag() & (byte)(0x1F)) != Krb5.KRB_AP_REP) || (encoding.isApplication() != true) || (encoding.isConstructed() != true))   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  DerValue der=encoding.getData().getDerValue();
  if (der.getTag() != DerValue.tag_Sequence)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  DerValue subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x00)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  pvno=subDer.getData().getBigInteger().intValue();
  if (pvno != Krb5.PVNO)   throw new KrbApErrException(Krb5.KRB_AP_ERR_BADVERSION);
  subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x01)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  msgType=subDer.getData().getBigInteger().intValue();
  if (msgType != Krb5.KRB_AP_REP)   throw new KrbApErrException(Krb5.KRB_AP_ERR_MSG_TYPE);
  encPart=EncryptedData.parse(der.getData(),(byte)0x02,false);
  if (der.getData().available() > 0)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
}","/** 
 * Initializes an APRep object.
 * @param encoding a single DER-encoded value.
 * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
 * @exception IOException if an I/O error occurs while reading encoded data.
 * @exception KrbApErrException if the value read from the DER-encoded datastream does not match the pre-defined value.
 */
private void init(DerValue encoding) throws Asn1Exception, KrbApErrException, IOException {
  if (((encoding.getTag() & (byte)(0x1F)) != Krb5.KRB_AP_REP) || (encoding.isApplication() != true) || (encoding.isConstructed() != true)) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  DerValue der=encoding.getData().getDerValue();
  if (der.getTag() != DerValue.tag_Sequence) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  DerValue subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x00) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  pvno=subDer.getData().getBigInteger().intValue();
  if (pvno != Krb5.PVNO) {
    throw new KrbApErrException(Krb5.KRB_AP_ERR_BADVERSION);
  }
  subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x01) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  msgType=subDer.getData().getBigInteger().intValue();
  if (msgType != Krb5.KRB_AP_REP) {
    throw new KrbApErrException(Krb5.KRB_AP_ERR_MSG_TYPE);
  }
  encPart=EncryptedData.parse(der.getData(),(byte)0x02,false);
  if (der.getData().available() > 0) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
}",0.9815668202764976
186289,"/** 
 * Examines the user agent string whether it is a browser.
 * @param userAgent String of an user agent
 * @param builder Builder for an user agent information
 */
private static void examineAsBrowser(final UserAgent.Builder builder,final Data data){
  Matcher matcher;
  VersionNumber version;
  for (  final Entry<BrowserPattern,Browser> entry : data.getPatternBrowserMap().entrySet()) {
    matcher=entry.getKey().getPattern().matcher(builder.getUserAgentString());
    if (matcher.find()) {
      entry.getValue().copyTo(builder);
      version=VersionParser.parseVersion(matcher.groupCount() > 0 ? matcher.group(1) : ""String_Node_Str"");
      builder.setVersionNumber(version);
      break;
    }
  }
}","/** 
 * Examines the user agent string whether it is a browser.
 * @param userAgent String of an user agent
 * @param builder Builder for an user agent information
 */
private static void examineAsBrowser(final UserAgent.Builder builder,final Data data){
  Matcher matcher;
  VersionNumber version=VersionNumber.UNKNOWN;
  for (  final Entry<BrowserPattern,Browser> entry : data.getPatternBrowserMap().entrySet()) {
    matcher=entry.getKey().getPattern().matcher(builder.getUserAgentString());
    if (matcher.find()) {
      entry.getValue().copyTo(builder);
      if (matcher.groupCount() > ZERO_MATCHING_GROUPS) {
        version=VersionParser.parseVersion(matcher.group(1) != null ? matcher.group(1) : ""String_Node_Str"");
      }
      builder.setVersionNumber(version);
      break;
    }
  }
}",0.9265387160820648
186290,"private Drawable getScaledDrawableForMimetype(FileHolder holder,Context context){
  Drawable d=getDrawableForMimetype(holder,context);
  if (d == null) {
    return new BitmapDrawable(context.getResources(),BitmapFactory.decodeResource(context.getResources(),R.drawable.ic_launcher_sdcard));
  }
 else {
    int size=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,48,context.getResources().getDisplayMetrics());
    return ImageUtils.resizeDrawable(d,size,size);
  }
}","private Drawable getScaledDrawableForMimetype(FileHolder holder,Context context){
  Drawable d=getDrawableForMimetype(holder,context);
  if (d == null) {
    return new BitmapDrawable(context.getResources(),BitmapFactory.decodeResource(context.getResources(),R.drawable.ic_launcher_file));
  }
 else {
    int size=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,48,context.getResources().getDisplayMetrics());
    return ImageUtils.resizeDrawable(d,size,size);
  }
}",0.9895615866388308
186291,"@Override public void run(){
  if (bitmap != null && mContext != null && !cancel) {
    thumb.imageView.setImageBitmap(bitmap);
    thumb.holder.setIcon(new BitmapDrawable(bitmap));
  }
}","@Override public void run(){
  if (bitmap != null && mContext != null && !cancel) {
    thumb.imageView.setImageBitmap(bitmap);
    thumb.holder.setIcon(new BitmapDrawable(bitmap));
  }
  thumb=null;
}",0.963917525773196
186292,"public void run(){
  running=true;
  init();
  if (files != null) {
    for (    File currentFile : files) {
      if (cancelled) {
        Log.v(TAG,""String_Node_Str"");
        return;
      }
      progress++;
      updateProgress(progress,totalCount);
      if (currentFile.getName().equalsIgnoreCase(FileUtils.NOMEDIA_FILE_NAME))       noMedia=true;
      if (!displayHidden && currentFile.isHidden()) {
        continue;
      }
      if (currentFile.isDirectory()) {
        if (currentFile.getAbsolutePath().equals(mSdCardPath)) {
          listSdCard.add(new FileHolder(currentFile,mMimeTypes.getMimeType(currentFile.getName()),sdIcon,context));
        }
 else {
          if (!mWriteableOnly || currentFile.canWrite())           listDir.add(new FileHolder(currentFile,mMimeTypes.getMimeType(currentFile.getName()),folderIcon,context));
        }
      }
 else {
        String fileName=currentFile.getName();
        String mimetype=mMimeTypes.getMimeType(fileName);
        String filetype=FileUtils.getExtension(fileName);
        boolean ext_allow=filetype.equalsIgnoreCase(mFilterFiletype) || mFilterFiletype == ""String_Node_Str"";
        boolean mime_allow=mFilterMimetype != null && (mimetype.contentEquals(mFilterMimetype) || mFilterMimetype.contentEquals(""String_Node_Str"") || mFilterFiletype == null);
        if (!mDirectoriesOnly && (ext_allow || mime_allow)) {
          listFile.add(new FileHolder(currentFile,mimetype,context));
        }
      }
    }
  }
  Log.v(TAG,""String_Node_Str"");
  int sortBy=PreferenceActivity.getSortBy(context);
  boolean ascending=PreferenceActivity.getAscending(context);
  Collections.sort(listSdCard);
  Collections.sort(listDir,Comparators.getForDirectory(sortBy,ascending));
  Collections.sort(listFile,Comparators.getForFile(sortBy,ascending));
  if (!cancelled) {
    Log.v(TAG,""String_Node_Str"");
    DirectoryContents contents=new DirectoryContents();
    contents.listDir=listDir;
    contents.listFile=listFile;
    contents.listSdCard=listSdCard;
    contents.noMedia=noMedia;
    Message msg=handler.obtainMessage(MESSAGE_SHOW_DIRECTORY_CONTENTS);
    msg.obj=contents;
    msg.sendToTarget();
  }
  running=false;
}","public void run(){
  running=true;
  init();
  if (files != null) {
    for (    File currentFile : files) {
      if (cancelled) {
        Log.v(TAG,""String_Node_Str"");
        return;
      }
      progress++;
      updateProgress(progress,totalCount);
      if (currentFile.getName().equalsIgnoreCase(FileUtils.NOMEDIA_FILE_NAME))       noMedia=true;
      if (!displayHidden && currentFile.isHidden()) {
        continue;
      }
      if (currentFile.isDirectory()) {
        if (currentFile.getAbsolutePath().equals(mSdCardPath)) {
          listSdCard.add(new FileHolder(currentFile,mMimeTypes.getMimeType(currentFile.getName()),sdIcon,context));
        }
 else {
          if (!mWriteableOnly || currentFile.canWrite())           listDir.add(new FileHolder(currentFile,mMimeTypes.getMimeType(currentFile.getName()),folderIcon,context));
        }
      }
 else {
        String fileName=currentFile.getName();
        String mimetype=mMimeTypes.getMimeType(fileName);
        String filetype=FileUtils.getExtension(fileName);
        boolean ext_allow=filetype.equalsIgnoreCase(mFilterFiletype) || mFilterFiletype == ""String_Node_Str"";
        boolean mime_allow=mFilterMimetype != null && (mimetype.contentEquals(mFilterMimetype) || mFilterMimetype.contentEquals(""String_Node_Str"") || mFilterFiletype == null);
        if (!mDirectoriesOnly && (ext_allow || mime_allow)) {
          listFile.add(new FileHolder(currentFile,mimetype,context));
        }
      }
    }
  }
  Log.v(TAG,""String_Node_Str"");
  int sortBy=PreferenceActivity.getSortBy(context);
  boolean ascending=PreferenceActivity.getAscending(context);
  if (!cancelled) {
    Collections.sort(listSdCard);
    Collections.sort(listDir,Comparators.getForDirectory(sortBy,ascending));
    Collections.sort(listFile,Comparators.getForFile(sortBy,ascending));
  }
  if (!cancelled) {
    Log.v(TAG,""String_Node_Str"");
    DirectoryContents contents=new DirectoryContents();
    contents.listDir=listDir;
    contents.listFile=listFile;
    contents.listSdCard=listSdCard;
    contents.noMedia=noMedia;
    Message msg=handler.obtainMessage(MESSAGE_SHOW_DIRECTORY_CONTENTS);
    msg.obj=contents;
    msg.sendToTarget();
  }
  running=false;
}",0.9931756141947224
186293,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mDistribution.setFirst(MENU_DISTRIBUTION_START,DIALOG_DISTRIBUTION_START);
  if (mDistribution.showEulaOrNewVersion()) {
    return;
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH)   HomeIconHelper.activity_actionbar_setHomeButtonEnabled(this);
  setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
  File data=resolveIntentData();
  mFragment=(SimpleFileListFragment)getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG);
  if (mFragment == null) {
    mFragment=new SimpleFileListFragment();
    Bundle args=new Bundle();
    if (data == null)     args.putString(FileManagerIntents.EXTRA_DIR_PATH,Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) ? Environment.getExternalStorageDirectory().getAbsolutePath() : ""String_Node_Str"");
 else     args.putString(FileManagerIntents.EXTRA_DIR_PATH,data.toString());
    mFragment.setArguments(args);
    getSupportFragmentManager().beginTransaction().add(android.R.id.content,mFragment,FRAGMENT_TAG).commit();
  }
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mDistribution.setFirst(MENU_DISTRIBUTION_START,DIALOG_DISTRIBUTION_START);
  if (mDistribution.showEulaOrNewVersion()) {
    return;
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH)   HomeIconHelper.activity_actionbar_setHomeButtonEnabled(this);
  setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
  File data=resolveIntentData();
  mFragment=(SimpleFileListFragment)getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG);
  if (mFragment == null) {
    mFragment=new SimpleFileListFragment();
    Bundle args=new Bundle();
    if (data == null)     args.putString(FileManagerIntents.EXTRA_DIR_PATH,Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) ? Environment.getExternalStorageDirectory().getAbsolutePath() : ""String_Node_Str"");
 else     args.putString(FileManagerIntents.EXTRA_DIR_PATH,data.toString());
    mFragment.setArguments(args);
    getSupportFragmentManager().beginTransaction().add(android.R.id.content,mFragment,FRAGMENT_TAG).commit();
  }
 else {
    mFragment.openInformingPathBar(new FileHolder(new File(data.toString()),this));
  }
}",0.9595619208087616
186294,"@Override protected void onNewIntent(Intent intent){
  mFragment.open(new FileHolder(FileUtils.getFile(intent.getData()),this));
}","@Override protected void onNewIntent(Intent intent){
  mFragment.openInformingPathBar(new FileHolder(FileUtils.getFile(intent.getData()),this));
}",0.9420289855072465
186295,"/** 
 * This is called after the file manager finished.
 */
@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case REQUEST_CODE_BOOKMARKS:
    if (resultCode == RESULT_OK && data != null) {
      mFragment.open(new FileHolder(new File(data.getStringExtra(BookmarkListActivity.KEY_RESULT_PATH)),this));
    }
  break;
default :
super.onActivityResult(requestCode,resultCode,data);
}
}","/** 
 * This is called after the file manager finished.
 */
@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case REQUEST_CODE_BOOKMARKS:
    if (resultCode == RESULT_OK && data != null) {
      mFragment.openInformingPathBar(new FileHolder(new File(data.getStringExtra(BookmarkListActivity.KEY_RESULT_PATH)),this));
    }
  break;
default :
super.onActivityResult(requestCode,resultCode,data);
}
}",0.9822616407982262
186296,"@Override public void onListItemClick(ListView l,View v,int position,long id){
  FileHolder item=(FileHolder)mAdapter.getItem(position);
  if (mPathBar == null)   open(item);
 else   mPathBar.cd(item.getFile());
}","@Override public void onListItemClick(ListView l,View v,int position,long id){
  FileHolder item=(FileHolder)mAdapter.getItem(position);
  openInformingPathBar(item);
}",0.8188976377952756
186297,"/** 
 * Point this Fragment to show the contents of the passed file.
 * @param f If same as current, does nothing.
 */
public void open(FileHolder f){
  if (!f.getFile().exists())   return;
  if (f.getFile().isDirectory()) {
    openDir(f);
  }
 else   if (f.getFile().isFile()) {
    openFile(f);
  }
}","/** 
 * Point this Fragment to show the contents of the passed file.
 * @param f If same as current, does nothing.
 */
private void open(FileHolder f){
  if (!f.getFile().exists())   return;
  if (f.getFile().isDirectory()) {
    openDir(f);
  }
 else   if (f.getFile().isFile()) {
    openFile(f);
  }
}",0.5074135090609555
186298,"/** 
 * Central point where we handle actions for single selection, for every API level.
 * @param mItem The selected menu option/action.
 * @param fItem The data to act upon.
 */
public static boolean handleSingleSelectionAction(final SimpleFileListFragment navigator,MenuItem mItem,FileHolder fItem,Context context){
  DialogFragment dialog;
  Bundle args;
switch (mItem.getItemId()) {
case R.id.menu_open:
    navigator.open(fItem);
  return true;
case R.id.menu_create_shortcut:
createShortcut(fItem,context);
return true;
case R.id.menu_move:
((FileManagerApplication)navigator.getActivity().getApplication()).getCopyHelper().cut(fItem);
return true;
case R.id.menu_copy:
((FileManagerApplication)navigator.getActivity().getApplication()).getCopyHelper().copy(fItem);
return true;
case R.id.menu_delete:
dialog=new SingleDeleteDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),SingleDeleteDialog.class.getName());
return true;
case R.id.menu_rename:
dialog=new RenameDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),RenameDialog.class.getName());
return true;
case R.id.menu_send:
sendFile(fItem,context);
return true;
case R.id.menu_details:
dialog=new DetailsDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),DetailsDialog.class.getName());
return true;
case R.id.menu_compress:
dialog=new SingleCompressDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),SingleCompressDialog.class.getName());
return true;
case R.id.menu_extract:
File dest=new File(fItem.getFile().getParentFile(),FileUtils.getNameWithoutExtension(fItem.getFile()));
dest.mkdirs();
new ExtractManager(context).setOnExtractFinishedListener(new ExtractManager.OnExtractFinishedListener(){
@Override public void extractFinished(){
navigator.refresh();
}
}
).extract(fItem.getFile(),dest.getAbsolutePath());
return true;
case R.id.menu_bookmark:
String path=fItem.getFile().getAbsolutePath();
Cursor query=context.getContentResolver().query(BookmarksProvider.CONTENT_URI,new String[]{BookmarksProvider._ID},BookmarksProvider.PATH + ""String_Node_Str"",new String[]{path},null);
if (!query.moveToFirst()) {
ContentValues values=new ContentValues();
values.put(BookmarksProvider.NAME,fItem.getName());
values.put(BookmarksProvider.PATH,path);
context.getContentResolver().insert(BookmarksProvider.CONTENT_URI,values);
Toast.makeText(context,R.string.bookmark_added,Toast.LENGTH_SHORT).show();
}
 else {
Toast.makeText(context,R.string.bookmark_already_exists,Toast.LENGTH_SHORT).show();
}
query.close();
return true;
case R.id.menu_more:
if (!PreferenceActivity.getShowAllWarning(context)) {
showMoreCommandsDialog(fItem,context);
return true;
}
showWarningDialog(fItem,context);
return true;
}
return false;
}","/** 
 * Central point where we handle actions for single selection, for every API level.
 * @param mItem The selected menu option/action.
 * @param fItem The data to act upon.
 */
public static boolean handleSingleSelectionAction(final SimpleFileListFragment navigator,MenuItem mItem,FileHolder fItem,Context context){
  DialogFragment dialog;
  Bundle args;
switch (mItem.getItemId()) {
case R.id.menu_open:
    navigator.openInformingPathBar(fItem);
  return true;
case R.id.menu_create_shortcut:
createShortcut(fItem,context);
return true;
case R.id.menu_move:
((FileManagerApplication)navigator.getActivity().getApplication()).getCopyHelper().cut(fItem);
return true;
case R.id.menu_copy:
((FileManagerApplication)navigator.getActivity().getApplication()).getCopyHelper().copy(fItem);
return true;
case R.id.menu_delete:
dialog=new SingleDeleteDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),SingleDeleteDialog.class.getName());
return true;
case R.id.menu_rename:
dialog=new RenameDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),RenameDialog.class.getName());
return true;
case R.id.menu_send:
sendFile(fItem,context);
return true;
case R.id.menu_details:
dialog=new DetailsDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),DetailsDialog.class.getName());
return true;
case R.id.menu_compress:
dialog=new SingleCompressDialog();
dialog.setTargetFragment(navigator,0);
args=new Bundle();
args.putParcelable(FileManagerIntents.EXTRA_DIALOG_FILE_HOLDER,fItem);
dialog.setArguments(args);
dialog.show(navigator.getFragmentManager(),SingleCompressDialog.class.getName());
return true;
case R.id.menu_extract:
File dest=new File(fItem.getFile().getParentFile(),FileUtils.getNameWithoutExtension(fItem.getFile()));
dest.mkdirs();
new ExtractManager(context).setOnExtractFinishedListener(new ExtractManager.OnExtractFinishedListener(){
@Override public void extractFinished(){
navigator.refresh();
}
}
).extract(fItem.getFile(),dest.getAbsolutePath());
return true;
case R.id.menu_bookmark:
String path=fItem.getFile().getAbsolutePath();
Cursor query=context.getContentResolver().query(BookmarksProvider.CONTENT_URI,new String[]{BookmarksProvider._ID},BookmarksProvider.PATH + ""String_Node_Str"",new String[]{path},null);
if (!query.moveToFirst()) {
ContentValues values=new ContentValues();
values.put(BookmarksProvider.NAME,fItem.getName());
values.put(BookmarksProvider.PATH,path);
context.getContentResolver().insert(BookmarksProvider.CONTENT_URI,values);
Toast.makeText(context,R.string.bookmark_added,Toast.LENGTH_SHORT).show();
}
 else {
Toast.makeText(context,R.string.bookmark_already_exists,Toast.LENGTH_SHORT).show();
}
query.close();
return true;
case R.id.menu_more:
if (!PreferenceActivity.getShowAllWarning(context)) {
showMoreCommandsDialog(fItem,context);
return true;
}
showWarningDialog(fItem,context);
return true;
}
return false;
}",0.9975910870219812
186299,"public void run(){
  Log.v(TAG,""String_Node_Str"" + currentDirectory);
  File[] files=currentDirectory.listFiles();
  int fileCount=0;
  int dirCount=0;
  int sdCount=0;
  int totalCount=0;
  if (cancel) {
    Log.v(TAG,""String_Node_Str"");
    clearData();
    return;
  }
  if (files == null) {
    Log.v(TAG,""String_Node_Str"");
    totalCount=0;
  }
 else {
    totalCount=files.length;
  }
  operationStartTime=SystemClock.uptimeMillis();
  Log.v(TAG,""String_Node_Str"" + totalCount + ""String_Node_Str"");
  int progress=0;
  List<IconifiedText> listDir=new ArrayList<IconifiedText>(totalCount);
  List<File> listDirFile=new ArrayList<File>(totalCount);
  List<IconifiedText> listFile=new ArrayList<IconifiedText>(totalCount);
  List<File> listFileFile=new ArrayList<File>(totalCount);
  List<IconifiedText> listSdCard=new ArrayList<IconifiedText>(3);
  boolean noMedia=false;
  Drawable sdIcon=context.getResources().getDrawable(R.drawable.ic_launcher_sdcard);
  Drawable folderIcon=context.getResources().getDrawable(R.drawable.ic_launcher_folder);
  Drawable genericFileIcon=context.getResources().getDrawable(R.drawable.icon_file);
  Drawable currentIcon=null;
  boolean displayHiddenFiles=PreferenceActivity.getDisplayHiddenFiles(context);
  if (files != null) {
    for (    File currentFile : files) {
      if (cancel) {
        Log.v(TAG,""String_Node_Str"");
        clearData();
        return;
      }
      progress++;
      updateProgress(progress,totalCount);
      if (!displayHiddenFiles && currentFile.isHidden()) {
        continue;
      }
      if (currentFile.isDirectory()) {
        if (currentFile.getAbsolutePath().equals(mSdCardPath)) {
          currentIcon=sdIcon;
          listSdCard.add(new IconifiedText(currentFile.getName(),""String_Node_Str"",currentIcon));
        }
 else {
          if (!mWriteableOnly || currentFile.canWrite()) {
            listDirFile.add(currentFile);
          }
        }
      }
 else {
        String fileName=currentFile.getName();
        if (!noMedia) {
          if (fileName.equalsIgnoreCase(""String_Node_Str"")) {
            noMedia=true;
          }
        }
        String mimetype=mMimeTypes.getMimeType(fileName);
        String filetype=FileUtils.getExtension(fileName);
        boolean ext_allow=filetype.equalsIgnoreCase(mFilterFiletype) || mFilterFiletype == ""String_Node_Str"";
        boolean mime_allow=mFilterMimetype != null && (mimetype.contentEquals(mFilterMimetype) || mFilterMimetype.contentEquals(""String_Node_Str"") || mFilterFiletype == null);
        if (!mDirectoriesOnly && (ext_allow || mime_allow)) {
          listFileFile.add(currentFile);
        }
      }
    }
  }
  Log.v(TAG,""String_Node_Str"");
  int sortBy=PreferenceActivity.getSortBy(context);
  boolean ascending=PreferenceActivity.getAscending(context);
  Collections.sort(listDirFile,Comparators.getForDirectory(sortBy,ascending));
  Collections.sort(listFileFile,Comparators.getForFile(sortBy,ascending));
  for (  File f : listDirFile) {
    listDir.add(new IconifiedText(f.getName(),""String_Node_Str"",folderIcon));
  }
  for (  File currentFile : listFileFile) {
    String mimetype=mMimeTypes.getMimeType(currentFile.getName());
    currentIcon=getDrawableForMimetype(currentFile,mimetype);
    if (currentIcon == null) {
      currentIcon=genericFileIcon;
    }
 else {
      int width=genericFileIcon.getIntrinsicWidth();
      int height=genericFileIcon.getIntrinsicHeight();
      currentIcon=resizeDrawable(currentIcon,width,height);
    }
    String size=""String_Node_Str"";
    try {
      size=(String)formatter_formatFileSize.invoke(null,context,currentFile.length());
    }
 catch (    Exception e) {
      size=Long.toString(currentFile.length() / 1024);
      size+=""String_Node_Str"";
    }
    listFile.add(new IconifiedText(currentFile.getName(),size + ""String_Node_Str"" + FileUtils.formatDate(context,currentFile.lastModified()),currentIcon));
  }
  if (!cancel) {
    Log.v(TAG,""String_Node_Str"");
    DirectoryContents contents=new DirectoryContents();
    contents.listDir=listDir;
    contents.listFile=listFile;
    contents.listSdCard=listSdCard;
    contents.noMedia=noMedia;
    Message msg=handler.obtainMessage(FileManagerActivity.MESSAGE_SHOW_DIRECTORY_CONTENTS);
    msg.obj=contents;
    msg.sendToTarget();
  }
  clearData();
}","public void run(){
  Log.v(TAG,""String_Node_Str"" + currentDirectory);
  File[] files=currentDirectory.listFiles();
  int fileCount=0;
  int dirCount=0;
  int sdCount=0;
  int totalCount=0;
  if (cancel) {
    Log.v(TAG,""String_Node_Str"");
    clearData();
    return;
  }
  if (files == null) {
    Log.v(TAG,""String_Node_Str"");
    totalCount=0;
  }
 else {
    totalCount=files.length;
  }
  operationStartTime=SystemClock.uptimeMillis();
  Log.v(TAG,""String_Node_Str"" + totalCount + ""String_Node_Str"");
  int progress=0;
  List<IconifiedText> listDir=new ArrayList<IconifiedText>(totalCount);
  List<File> listDirFile=new ArrayList<File>(totalCount);
  List<IconifiedText> listFile=new ArrayList<IconifiedText>(totalCount);
  List<File> listFileFile=new ArrayList<File>(totalCount);
  List<IconifiedText> listSdCard=new ArrayList<IconifiedText>(3);
  boolean noMedia=false;
  Drawable sdIcon=context.getResources().getDrawable(R.drawable.ic_launcher_sdcard);
  Drawable folderIcon=context.getResources().getDrawable(R.drawable.ic_launcher_folder);
  Drawable genericFileIcon=context.getResources().getDrawable(R.drawable.icon_file);
  Drawable currentIcon=null;
  boolean displayHiddenFiles=PreferenceActivity.getDisplayHiddenFiles(context);
  if (files != null) {
    for (    File currentFile : files) {
      if (cancel) {
        Log.v(TAG,""String_Node_Str"");
        clearData();
        return;
      }
      progress++;
      updateProgress(progress,totalCount);
      if (!displayHiddenFiles && currentFile.isHidden()) {
        continue;
      }
      if (currentFile.isDirectory()) {
        if (currentFile.getAbsolutePath().equals(mSdCardPath)) {
          currentIcon=sdIcon;
          listSdCard.add(new IconifiedText(currentFile.getName(),""String_Node_Str"",currentIcon));
        }
 else {
          if (!mWriteableOnly || currentFile.canWrite()) {
            listDirFile.add(currentFile);
          }
        }
      }
 else {
        String fileName=currentFile.getName();
        if (!noMedia) {
          if (fileName.equalsIgnoreCase(""String_Node_Str"")) {
            noMedia=true;
          }
        }
        String mimetype=mMimeTypes.getMimeType(fileName);
        String filetype=FileUtils.getExtension(fileName);
        boolean ext_allow=filetype.equalsIgnoreCase(mFilterFiletype) || mFilterFiletype == ""String_Node_Str"";
        boolean mime_allow=mFilterMimetype != null && (mimetype.contentEquals(mFilterMimetype) || mFilterMimetype.contentEquals(""String_Node_Str"") || mFilterFiletype == null);
        if (!mDirectoriesOnly && (ext_allow || mime_allow)) {
          listFileFile.add(currentFile);
        }
      }
    }
  }
  Log.v(TAG,""String_Node_Str"");
  int sortBy=PreferenceActivity.getSortBy(context);
  boolean ascending=PreferenceActivity.getAscending(context);
  Collections.sort(listDirFile,Comparators.getForDirectory(sortBy,ascending));
  Collections.sort(listFileFile,Comparators.getForFile(sortBy,ascending));
  for (  File f : listDirFile) {
    listDir.add(new IconifiedText(f.getName(),""String_Node_Str"",folderIcon));
  }
  for (  File currentFile : listFileFile) {
    String mimetype=mMimeTypes.getMimeType(currentFile.getName());
    currentIcon=getDrawableForMimetype(currentFile,mimetype);
    if (currentIcon == null) {
      currentIcon=genericFileIcon;
    }
 else {
      int width=genericFileIcon.getIntrinsicWidth();
      int height=genericFileIcon.getIntrinsicHeight();
      currentIcon=ImageUtils.resizeDrawable(currentIcon,width,height);
    }
    String size=""String_Node_Str"";
    try {
      size=(String)formatter_formatFileSize.invoke(null,context,currentFile.length());
    }
 catch (    Exception e) {
      size=Long.toString(currentFile.length() / 1024);
      size+=""String_Node_Str"";
    }
    listFile.add(new IconifiedText(currentFile.getName(),size + ""String_Node_Str"" + FileUtils.formatDate(context,currentFile.lastModified()),currentIcon));
  }
  if (!cancel) {
    Log.v(TAG,""String_Node_Str"");
    DirectoryContents contents=new DirectoryContents();
    contents.listDir=listDir;
    contents.listFile=listFile;
    contents.listSdCard=listSdCard;
    contents.noMedia=noMedia;
    Message msg=handler.obtainMessage(FileManagerActivity.MESSAGE_SHOW_DIRECTORY_CONTENTS);
    msg.obj=contents;
    msg.sendToTarget();
  }
  clearData();
}",0.9987264096329744
186300,"/** 
 * @param parentFile The parentFile, so we can obtain the full path of the bitmap
 * @param fileName The name of the file, also the text in the list item.
 * @return The resized and resampled bitmap, if can not be decoded it returns null.
 */
private Bitmap decodeFile(String parentFile,String fileName){
  if (!cancel) {
    try {
      BitmapFactory.Options options=new BitmapFactory.Options();
      options.inJustDecodeBounds=true;
      options.outWidth=0;
      options.outHeight=0;
      options.inSampleSize=1;
      String filePath=FileUtils.getFile(parentFile,fileName).getPath();
      BitmapFactory.decodeFile(filePath,options);
      if (options.outWidth > 0 && options.outHeight > 0) {
        if (!cancel) {
          int widthFactor=(options.outWidth + thumbnailWidth - 1) / thumbnailWidth;
          int heightFactor=(options.outHeight + thumbnailHeight - 1) / thumbnailHeight;
          widthFactor=Math.max(widthFactor,heightFactor);
          widthFactor=Math.max(widthFactor,1);
          if (widthFactor > 1) {
            if ((widthFactor & (widthFactor - 1)) != 0) {
              while ((widthFactor & (widthFactor - 1)) != 0) {
                widthFactor&=widthFactor - 1;
              }
              widthFactor<<=1;
            }
          }
          options.inSampleSize=widthFactor;
          options.inJustDecodeBounds=false;
          Bitmap bitmap=BitmapFactory.decodeFile(filePath,options);
          if (bitmap != null) {
            return bitmap;
          }
        }
      }
 else {
        if (!mBlacklist.contains(fileName)) {
          mBlacklist.add(fileName);
        }
      }
    }
 catch (    Exception e) {
    }
  }
  return null;
}","/** 
 * @param parentFile The parentFile, so we can obtain the full path of the bitmap
 * @param fileName The name of the file, also the text in the list item.
 * @return The resized and resampled bitmap, if can not be decoded it returns null.
 */
private Bitmap decodeFile(String parentFile,String fileName){
  if (!cancel) {
    try {
      BitmapFactory.Options options=new BitmapFactory.Options();
      options.inJustDecodeBounds=true;
      options.outWidth=0;
      options.outHeight=0;
      options.inSampleSize=1;
      String filePath=FileUtils.getFile(parentFile,fileName).getPath();
      BitmapFactory.decodeFile(filePath,options);
      if (options.outWidth > 0 && options.outHeight > 0) {
        if (!cancel) {
          int widthFactor=(options.outWidth + thumbnailWidth - 1) / thumbnailWidth;
          int heightFactor=(options.outHeight + thumbnailHeight - 1) / thumbnailHeight;
          widthFactor=Math.max(widthFactor,heightFactor);
          widthFactor=Math.max(widthFactor,1);
          if (widthFactor > 1) {
            if ((widthFactor & (widthFactor - 1)) != 0) {
              while ((widthFactor & (widthFactor - 1)) != 0) {
                widthFactor&=widthFactor - 1;
              }
              widthFactor<<=1;
            }
          }
          options.inSampleSize=widthFactor;
          options.inJustDecodeBounds=false;
          Bitmap bitmap=ImageUtils.resizeBitmap(BitmapFactory.decodeFile(filePath,options),72,72);
          if (bitmap != null) {
            return bitmap;
          }
        }
      }
 else {
        if (!mBlacklist.contains(fileName)) {
          mBlacklist.add(fileName);
        }
      }
    }
 catch (    Exception e) {
    }
  }
  return null;
}",0.99091175608326
186301,"/** 
 * Return the Drawable that is associated with a specific mime type for the VIEW action.
 * @param mimetype
 * @return
 */
Drawable getDrawableForMimetype(File file,String mimetype){
  if (mimetype == null) {
    return null;
  }
  PackageManager pm=context.getPackageManager();
  if (mimetype.equals(MIME_APK)) {
    String path=file.getPath();
    PackageInfo pInfo=pm.getPackageArchiveInfo(path,PackageManager.GET_ACTIVITIES);
    ApplicationInfo aInfo=pInfo.applicationInfo;
    if (Build.VERSION.SDK_INT >= 8) {
      aInfo.sourceDir=path;
      aInfo.publicSourceDir=path;
    }
    return aInfo.loadIcon(pm);
  }
  Uri data=FileUtils.getUri(file);
  Intent intent=new Intent(Intent.ACTION_VIEW);
  intent.setDataAndType(data,mimetype);
  final List<ResolveInfo> lri=pm.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY);
  if (lri != null && lri.size() > 0) {
    int index=0;
    index=lri.size() - 1;
    final ResolveInfo ri=lri.get(index);
    return ri.loadIcon(pm);
  }
  return null;
}","/** 
 * Return the Drawable that is associated with a specific mime type for the VIEW action.
 * @param mimetype
 * @return
 */
Drawable getDrawableForMimetype(File file,String mimetype){
  if (mimetype == null) {
    return null;
  }
  PackageManager pm=context.getPackageManager();
  if (mimetype.equals(MIME_APK)) {
    String path=file.getPath();
    PackageInfo pInfo=pm.getPackageArchiveInfo(path,PackageManager.GET_ACTIVITIES);
    if (pInfo != null) {
      ApplicationInfo aInfo=pInfo.applicationInfo;
      if (Build.VERSION.SDK_INT >= 8) {
        aInfo.sourceDir=path;
        aInfo.publicSourceDir=path;
      }
      return aInfo.loadIcon(pm);
    }
  }
  Uri data=FileUtils.getUri(file);
  Intent intent=new Intent(Intent.ACTION_VIEW);
  intent.setDataAndType(data,mimetype);
  final List<ResolveInfo> lri=pm.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY);
  if (lri != null && lri.size() > 0) {
    int index=0;
    index=lri.size() - 1;
    final ResolveInfo ri=lri.get(index);
    return ri.loadIcon(pm);
  }
  return null;
}",0.979297063071738
186302,"private void sendFile(File file){
  String filename=file.getName();
  String content=""String_Node_Str"";
  Log.i(TAG,""String_Node_Str"" + filename);
  Log.i(TAG,""String_Node_Str"" + content);
  Intent i=new Intent();
  i.setAction(Intent.ACTION_SEND);
  i.setType(mMimeTypes.getMimeType(file.getName()));
  i.putExtra(Intent.EXTRA_SUBJECT,filename);
  i.putExtra(Intent.EXTRA_STREAM,Uri.parse(""String_Node_Str"" + FileManagerProvider.AUTHORITY + ""String_Node_Str""+ file.getAbsolutePath()));
  i=Intent.createChooser(i,getString(R.string.menu_send));
  try {
    startActivity(i);
  }
 catch (  ActivityNotFoundException e) {
    Toast.makeText(this,R.string.send_not_available,Toast.LENGTH_SHORT).show();
    Log.e(TAG,""String_Node_Str"");
  }
}","private void sendFile(File file){
  String filename=file.getName();
  String content=""String_Node_Str"";
  Log.i(TAG,""String_Node_Str"" + filename);
  Log.i(TAG,""String_Node_Str"" + content);
  Intent i=new Intent();
  i.setAction(Intent.ACTION_SEND);
  i.setType(mMimeTypes.getMimeType(file.getName()));
  i.putExtra(Intent.EXTRA_SUBJECT,filename);
  i.putExtra(Intent.EXTRA_STREAM,Uri.parse(""String_Node_Str"" + FileManagerProvider.AUTHORITY + file.getAbsolutePath()));
  i=Intent.createChooser(i,getString(R.string.menu_send));
  try {
    startActivity(i);
  }
 catch (  ActivityNotFoundException e) {
    Toast.makeText(this,R.string.send_not_available,Toast.LENGTH_SHORT).show();
    Log.e(TAG,""String_Node_Str"");
  }
}",0.9869952087611226
186303,"@Override public boolean onCreateOptionsMenu(Menu menu){
  super.onCreateOptionsMenu(menu);
  menu.add(0,MENU_NEW_FOLDER,0,R.string.menu_new_folder).setIcon(android.R.drawable.ic_menu_add).setShortcut('0','f');
  mIncludeMediaScanMenuItem=menu.add(0,MENU_INCLUDE_IN_MEDIA_SCAN,0,R.string.menu_include_in_media_scan).setShortcut('1','s').setIcon(android.R.drawable.ic_menu_gallery);
  mExcludeMediaScanMenuItem=menu.add(0,MENU_EXCLUDE_FROM_MEDIA_SCAN,0,R.string.menu_exclude_from_media_scan).setShortcut('1','s').setIcon(android.R.drawable.ic_menu_gallery);
  UpdateMenu.addUpdateMenu(this,menu,0,MENU_UPDATE,0,R.string.update);
  menu.add(0,MENU_ABOUT,0,R.string.about).setIcon(android.R.drawable.ic_menu_info_details).setShortcut('0','a');
  return true;
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  super.onCreateOptionsMenu(menu);
  menu.add(0,MENU_NEW_FOLDER,0,R.string.menu_new_folder).setIcon(android.R.drawable.ic_menu_add).setShortcut('0','f');
  mIncludeMediaScanMenuItem=menu.add(0,MENU_INCLUDE_IN_MEDIA_SCAN,0,R.string.menu_include_in_media_scan).setShortcut('1','s').setIcon(android.R.drawable.ic_menu_gallery);
  mExcludeMediaScanMenuItem=menu.add(0,MENU_EXCLUDE_FROM_MEDIA_SCAN,0,R.string.menu_exclude_from_media_scan).setShortcut('1','s').setIcon(android.R.drawable.ic_menu_gallery);
  UpdateMenu.addUpdateMenu(this,menu,0,MENU_UPDATE,0,R.string.menu_update);
  menu.add(0,MENU_ABOUT,0,R.string.about).setIcon(android.R.drawable.ic_menu_info_details).setShortcut('0','a');
  return true;
}",0.9967083607636604
186304,"/** 
 * distributes points along a 3D line segment sequence. This can be used for many different features, such as steps along a way, street lights along a road or posts along a fence.
 * @param preferredDistance  ideal distance between resulting points;this method will try to keep the actual distance as close to this as possible
 * @param pointsAtStartAndEnd  if true, there will be a point at lineStartand lineEnd each; if false, the closest points will be half the usual distance away from these
 */
public static List<VectorXYZ> equallyDistributePointsAlong(double preferredDistance,boolean pointsAtStartAndEnd,List<VectorXYZ> points){
  double length=0;
  for (int i=0; i + 1 < points.size(); i++) {
    length+=points.get(i).distanceToXZ(points.get(i + 1));
  }
  int numSegments=(int)Math.round(length / preferredDistance);
  if (numSegments == 0) {
    return emptyList();
  }
  double pointDistance=length / numSegments;
  int numPoints=pointsAtStartAndEnd ? numSegments + 1 : numSegments;
  List<VectorXYZ> result=new ArrayList<VectorXYZ>(numPoints);
  double currentDistanceFromStart=pointsAtStartAndEnd ? 0 : pointDistance / 2;
  int currentInputPoint=0;
  double offsetCurrentInputPoint=0;
  double offsetNextInputPoint=points.get(0).distanceToXZ(points.get(1));
  for (int i=0; i < numPoints; i++) {
    while (currentDistanceFromStart > offsetNextInputPoint) {
      currentInputPoint+=1;
      offsetCurrentInputPoint=offsetNextInputPoint;
      offsetNextInputPoint=offsetCurrentInputPoint + points.get(currentInputPoint).distanceToXZ(points.get(currentInputPoint + 1));
    }
    VectorXYZ p=interpolateBetween(points.get(currentInputPoint),points.get(currentInputPoint + 1),(currentDistanceFromStart - offsetCurrentInputPoint) / (offsetNextInputPoint - offsetCurrentInputPoint));
    result.add(p);
    currentDistanceFromStart+=pointDistance;
  }
  return result;
}","/** 
 * distributes points along a 3D line segment sequence. This can be used for many different features, such as steps along a way, street lights along a road or posts along a fence.
 * @param preferredDistance  ideal distance between resulting points;this method will try to keep the actual distance as close to this as possible
 * @param pointsAtStartAndEnd  if true, there will be a point at lineStartand lineEnd each; if false, the closest points will be half the usual distance away from these
 */
public static List<VectorXYZ> equallyDistributePointsAlong(double preferredDistance,boolean pointsAtStartAndEnd,List<VectorXYZ> points){
  double length=0;
  for (int i=0; i + 1 < points.size(); i++) {
    length+=points.get(i).distanceToXZ(points.get(i + 1));
  }
  int numSegments=(int)Math.round(length / preferredDistance);
  if (numSegments == 0) {
    return emptyList();
  }
  double pointDistance=length / numSegments;
  int numPoints=pointsAtStartAndEnd ? numSegments + 1 : numSegments;
  List<VectorXYZ> result=new ArrayList<VectorXYZ>(numPoints);
  double currentDistanceFromStart=pointsAtStartAndEnd ? 0 : pointDistance / 2;
  int currentInputPoint=0;
  double offsetCurrentInputPoint=0;
  double offsetNextInputPoint=points.get(0).distanceToXZ(points.get(1));
  for (int i=0; i < numPoints; i++) {
    if (pointsAtStartAndEnd && i == numPoints - 1) {
      result.add(points.get(points.size() - 1));
      break;
    }
    while (currentDistanceFromStart > offsetNextInputPoint) {
      currentInputPoint+=1;
      offsetCurrentInputPoint=offsetNextInputPoint;
      offsetNextInputPoint=offsetCurrentInputPoint + points.get(currentInputPoint).distanceToXZ(points.get(currentInputPoint + 1));
    }
    VectorXYZ p=interpolateBetween(points.get(currentInputPoint),points.get(currentInputPoint + 1),(currentDistanceFromStart - offsetCurrentInputPoint) / (offsetNextInputPoint - offsetCurrentInputPoint));
    result.add(p);
    currentDistanceFromStart+=pointDistance;
  }
  return result;
}",0.9689345314505776
186305,"@Test public void testEquallyDistributePointsAlong1StartEnd(){
  List<VectorXZ> result1=equallyDistributePointsAlong(1f,true,new VectorXZ(-2,5),new VectorXZ(+4,5));
  List<VectorXYZ> result2=equallyDistributePointsAlong(1f,true,asList(new VectorXYZ(-2,0,5),new VectorXYZ(+4,2,5)));
  for (  List<? extends Vector3D> result : asList(result1,result2)) {
    assertSame(7,result.size());
    assertAlmostEquals(-2,5,result.get(0).xz());
    assertAlmostEquals(-1,5,result.get(1).xz());
    assertAlmostEquals(0,5,result.get(2).xz());
    assertAlmostEquals(+1,5,result.get(3).xz());
    assertAlmostEquals(+2,5,result.get(4).xz());
    assertAlmostEquals(+3,5,result.get(5).xz());
    assertAlmostEquals(+4,5,result.get(6).xz());
  }
}","@Test @SuppressWarnings(""String_Node_Str"") public void testEquallyDistributePointsAlong1StartEnd(){
  List<VectorXZ> result1=equallyDistributePointsAlong(1f,true,new VectorXZ(-2,5),new VectorXZ(+4,5));
  List<VectorXYZ> result2=equallyDistributePointsAlong(1f,true,asList(new VectorXYZ(-2,0,5),new VectorXYZ(+4,2,5)));
  for (  List<? extends Vector3D> result : asList(result1,result2)) {
    assertSame(7,result.size());
    assertAlmostEquals(-2,5,result.get(0).xz());
    assertAlmostEquals(-1,5,result.get(1).xz());
    assertAlmostEquals(0,5,result.get(2).xz());
    assertAlmostEquals(+1,5,result.get(3).xz());
    assertAlmostEquals(+2,5,result.get(4).xz());
    assertAlmostEquals(+3,5,result.get(5).xz());
    assertAlmostEquals(+4,5,result.get(6).xz());
  }
}",0.9753497668221186
186306,"@Test public void testEquallyDistributePointsAlong1NoStartEnd(){
  List<VectorXZ> result1=equallyDistributePointsAlong(1f,false,new VectorXZ(-2,5),new VectorXZ(+4,5));
  List<VectorXYZ> result2=equallyDistributePointsAlong(1f,false,asList(new VectorXYZ(-2,0,5),new VectorXYZ(+4,2,5)));
  for (  List<? extends Vector3D> result : asList(result1,result2)) {
    assertSame(6,result.size());
    assertAlmostEquals(-1.5f,5,result.get(0).xz());
    assertAlmostEquals(-0.5f,5,result.get(1).xz());
    assertAlmostEquals(+0.5f,5,result.get(2).xz());
    assertAlmostEquals(+1.5f,5,result.get(3).xz());
    assertAlmostEquals(+2.5f,5,result.get(4).xz());
    assertAlmostEquals(+3.5f,5,result.get(5).xz());
  }
}","@Test @SuppressWarnings(""String_Node_Str"") public void testEquallyDistributePointsAlong1NoStartEnd(){
  List<VectorXZ> result1=equallyDistributePointsAlong(1f,false,new VectorXZ(-2,5),new VectorXZ(+4,5));
  List<VectorXYZ> result2=equallyDistributePointsAlong(1f,false,asList(new VectorXYZ(-2,0,5),new VectorXYZ(+4,2,5)));
  for (  List<? extends Vector3D> result : asList(result1,result2)) {
    assertSame(6,result.size());
    assertAlmostEquals(-1.5f,5,result.get(0).xz());
    assertAlmostEquals(-0.5f,5,result.get(1).xz());
    assertAlmostEquals(+0.5f,5,result.get(2).xz());
    assertAlmostEquals(+1.5f,5,result.get(3).xz());
    assertAlmostEquals(+2.5f,5,result.get(4).xz());
    assertAlmostEquals(+3.5f,5,result.get(5).xz());
  }
}",0.974465148378192
186307,"/** 
 * fetches data from any Overpass API instance according to an arbitrary query.
 * @throws IOException 
 */
public OverpassReader(String apiURL,String queryString){
  super(new OverpassSource(apiURL,queryString));
}","/** 
 * fetches data from any Overpass API instance according to an arbitrary query. 
 */
public OverpassReader(String apiURL,String queryString){
  super(new OverpassSource(apiURL,queryString));
}",0.9448441247002398
186308,"/** 
 * similar to   {@link #applyProjectionMatrices(GL2,Projection)}, but allows rendering only a part of the ""normal"" image.
 */
static final void applyProjectionMatricesForPart(PMVMatrix pmvMatrix,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if ((xStart != 0 || xEnd != 1 || yStart != 0 || yEnd != 1) && !projection.isOrthographic()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  pmvMatrix.glMatrixMode(GL_PROJECTION);
  pmvMatrix.glLoadIdentity();
  if (projection.isOrthographic()) {
    double volumeWidth=projection.getAspectRatio() * projection.getVolumeHeight();
    pmvMatrix.glOrthof((float)((-0.5 + xStart) * volumeWidth),(float)((-0.5 + xEnd) * volumeWidth),(float)((-0.5 + yStart) * projection.getVolumeHeight()),(float)((-0.5 + yEnd) * projection.getVolumeHeight()),(float)(projection.getNearClippingDistance()),(float)(projection.getFarClippingDistance()));
  }
 else {
    pmvMatrix.gluPerspective((float)(projection.getVertAngle()),(float)(projection.getAspectRatio()),(float)(projection.getNearClippingDistance()),(float)(projection.getFarClippingDistance()));
  }
  pmvMatrix.glMatrixMode(GL_MODELVIEW);
}","/** 
 * similar to   {@link #applyProjectionMatrices(PMVMatrix,Projection)}, but allows rendering only a part of the ""normal"" image.
 */
static final void applyProjectionMatricesForPart(PMVMatrix pmvMatrix,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if ((xStart != 0 || xEnd != 1 || yStart != 0 || yEnd != 1) && !projection.isOrthographic()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  pmvMatrix.glMatrixMode(GL_PROJECTION);
  pmvMatrix.glLoadIdentity();
  if (projection.isOrthographic()) {
    double volumeWidth=projection.getAspectRatio() * projection.getVolumeHeight();
    pmvMatrix.glOrthof((float)((-0.5 + xStart) * volumeWidth),(float)((-0.5 + xEnd) * volumeWidth),(float)((-0.5 + yStart) * projection.getVolumeHeight()),(float)((-0.5 + yEnd) * projection.getVolumeHeight()),(float)(projection.getNearClippingDistance()),(float)(projection.getFarClippingDistance()));
  }
 else {
    pmvMatrix.gluPerspective((float)(projection.getVertAngle()),(float)(projection.getAspectRatio()),(float)(projection.getNearClippingDistance()),(float)(projection.getFarClippingDistance()));
  }
  pmvMatrix.glMatrixMode(GL_MODELVIEW);
}",0.995008319467554
186309,"public JOGLRenderingParameters(){
  this.frontFace=null;
  this.wireframe=false;
  this.useZBuffer=false;
  this.drawBoundingBox=false;
  this.useShadowVolumes=false;
  this.useShadowMaps=false;
  this.shadowMapWidth=0;
  this.shadowMapHeight=0;
  this.shadowMapCameraFrustumPadding=0;
  this.useSSAO=false;
  this.SSAOkernelSize=0;
  this.SSAOradius=0;
  this.overwriteProjectionClippingPlanes=false;
}","public JOGLRenderingParameters(){
  this.frontFace=null;
  this.wireframe=false;
  this.useZBuffer=true;
  this.drawBoundingBox=false;
  this.useShadowVolumes=false;
  this.useShadowMaps=false;
  this.shadowMapWidth=0;
  this.shadowMapHeight=0;
  this.shadowMapCameraFrustumPadding=0;
  this.useSSAO=false;
  this.SSAOkernelSize=0;
  this.SSAOradius=0;
  this.overwriteProjectionClippingPlanes=false;
}",0.991304347826087
186310,"public TextRendererShader(GL2ES2 gl){
  this.gl=gl;
  try {
    textRendererFont=FontFactory.getDefault().get(FontSet.FAMILY_REGULAR,FontSet.STYLE_SERIF);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  RenderState renderState=RenderState.createRenderState(new ShaderState(),SVertex.factory());
  textRenderer=TextRenderer.create(renderState,0);
  textRenderer.init(gl);
  if (!textRenderer.isInitialized()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}","public TextRendererShader(GL2ES2 gl){
  this.gl=gl;
  try {
    textRendererFont=FontFactory.getDefault().get(FontSet.FAMILY_REGULAR,FontSet.STYLE_SERIF);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  RenderState renderState=RenderState.createRenderState(new ShaderState(),SVertex.factory());
  textRenderer=TextRenderer.create(renderState,0);
  textRenderer.init(gl);
  if (!textRenderer.isInitialized()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  textRenderer.enable(gl,true);
  textRenderer.enable(gl,false);
}",0.9383886255924172
186311,"@Override public void renderPart(Camera camera,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if (renderer == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  applyProjectionMatricesForPart(pmvMatrix,projection,xStart,xEnd,yStart,yEnd);
  applyCameraMatrices(pmvMatrix,camera);
  if (renderingParameters.useShadowMaps) {
    shadowMapShader.useShader();
    shadowMapShader.preparePMVMatrix(globalLightingParameters,pmvMatrix,rendererShader.getBoundingBox());
    rendererShader.setShader(shadowMapShader);
    rendererShader.render(camera,projection);
    shadowMapShader.disableShader();
  }
  defaultShader.useShader();
  defaultShader.loadDefaults();
  if (showShadowPerspective)   defaultShader.setPMVMatrix(shadowMapShader.getPMVMatrix());
 else   defaultShader.setPMVMatrix(pmvMatrix);
  applyRenderingParameters(gl,renderingParameters);
  applyLightingParameters(defaultShader,globalLightingParameters);
  if (renderingParameters.useShadowMaps) {
    defaultShader.bindShadowMap(shadowMapShader.getShadowMapHandle());
    defaultShader.setShadowMatrix(shadowMapShader.getPMVMatrix());
  }
  rendererShader.setShader(defaultShader);
  rendererShader.render(camera,projection);
  defaultShader.disableShader();
  nonAreaShader.useShader();
  nonAreaShader.loadDefaults();
  nonAreaShader.setPMVMatrix(pmvMatrix);
  nonAreaRenderer.render();
  nonAreaShader.disableShader();
  if (renderingParameters.useShadowVolumes) {
    gl.glDrawBuffer(GL.GL_NONE);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDepthMask(false);
    gl.glEnable(GL3.GL_DEPTH_CLAMP);
    gl.glDisable(GL_CULL_FACE);
    gl.glStencilFunc(GL.GL_ALWAYS,0,0xff);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_INCR_WRAP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_DECR_WRAP,GL.GL_KEEP);
    shadowVolumeShader.useShader();
    shadowVolumeShader.setPMVMatrix(pmvMatrix);
    rendererShadowVolume.setShader(shadowVolumeShader);
    rendererShadowVolume.render(camera,projection);
    shadowVolumeShader.disableShader();
    gl.glDepthMask(true);
    gl.glClear(GL.GL_DEPTH_BUFFER_BIT);
    gl.glDisable(GL3.GL_DEPTH_CLAMP);
    gl.glEnable(GL_CULL_FACE);
    gl.glDrawBuffer(GL_BACK);
    gl.glStencilFunc(GL.GL_NOTEQUAL,0x0,0xFF);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    applyRenderingParameters(gl,renderingParameters);
    defaultShader.useShader();
    defaultShader.loadDefaults();
    defaultShader.setPMVMatrix(pmvMatrix);
    defaultShader.setShadowed(true);
    rendererShader.setShader(defaultShader);
    rendererShader.render(camera,projection);
    defaultShader.setShadowed(false);
    defaultShader.disableShader();
    nonAreaShader.useShader();
    nonAreaShader.loadDefaults();
    nonAreaShader.setPMVMatrix(pmvMatrix);
    nonAreaRenderer.render();
    nonAreaShader.disableShader();
  }
}","@Override public void renderPart(Camera camera,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if (renderer == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  applyProjectionMatricesForPart(pmvMatrix,projection,xStart,xEnd,yStart,yEnd);
  applyCameraMatrices(pmvMatrix,camera);
  if (renderingParameters.useShadowMaps) {
    shadowMapShader.useShader();
    shadowMapShader.preparePMVMatrix(globalLightingParameters,pmvMatrix,rendererShader.getBoundingBox());
    rendererShader.setShader(shadowMapShader);
    rendererShader.render(camera,projection);
    shadowMapShader.disableShader();
  }
  defaultShader.useShader();
  defaultShader.loadDefaults();
  if (showShadowPerspective)   defaultShader.setPMVMatrix(shadowMapShader.getPMVMatrix());
 else   defaultShader.setPMVMatrix(pmvMatrix);
  applyRenderingParameters(gl,renderingParameters);
  applyLightingParameters(defaultShader,globalLightingParameters);
  if (renderingParameters.useShadowMaps) {
    defaultShader.bindShadowMap(shadowMapShader.getShadowMapHandle());
    defaultShader.setShadowMatrix(shadowMapShader.getPMVMatrix());
  }
  rendererShader.setShader(defaultShader);
  rendererShader.render(camera,projection);
  defaultShader.disableShader();
  nonAreaShader.useShader();
  nonAreaShader.loadDefaults();
  nonAreaShader.setPMVMatrix(pmvMatrix);
  nonAreaRenderer.render();
  nonAreaShader.disableShader();
  if (renderingParameters.useShadowVolumes) {
    gl.glDrawBuffer(GL.GL_NONE);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDepthMask(false);
    gl.glEnable(GL3.GL_DEPTH_CLAMP);
    gl.glDisable(GL_CULL_FACE);
    gl.glStencilFunc(GL.GL_ALWAYS,0,0xff);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_INCR_WRAP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_DECR_WRAP,GL.GL_KEEP);
    shadowVolumeShader.useShader();
    shadowVolumeShader.setPMVMatrix(pmvMatrix);
    rendererShadowVolume.setShader(shadowVolumeShader);
    rendererShadowVolume.render(camera,projection);
    shadowVolumeShader.disableShader();
    gl.glDepthMask(true);
    gl.glClear(GL.GL_DEPTH_BUFFER_BIT);
    gl.glDisable(GL3.GL_DEPTH_CLAMP);
    gl.glEnable(GL_CULL_FACE);
    gl.glDrawBuffer(GL_BACK);
    gl.glStencilFunc(GL.GL_NOTEQUAL,0x0,0xFF);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    applyRenderingParameters(gl,renderingParameters);
    defaultShader.useShader();
    defaultShader.loadDefaults();
    defaultShader.setPMVMatrix(pmvMatrix);
    defaultShader.setShadowed(true);
    rendererShader.setShader(defaultShader);
    rendererShader.render(camera,projection);
    defaultShader.setShadowed(false);
    defaultShader.disableShader();
    nonAreaShader.useShader();
    nonAreaShader.loadDefaults();
    nonAreaShader.setPMVMatrix(pmvMatrix);
    nonAreaRenderer.render();
    nonAreaShader.disableShader();
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
}",0.9936560934891486
186312,"private static JOGLTarget createJOGLTarget(GL gl,Results results,Configuration config){
  JOGLTarget target;
  if (""String_Node_Str"".equals(config.getString(""String_Node_Str""))) {
    boolean shadowVolumes=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
    boolean shadowMaps=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
    target=new JOGLTargetShader(gl.getGL3(),new JOGLRenderingParameters(CCW,false,true,shadowVolumes,shadowMaps),GlobalLightingParameters.DEFAULT);
  }
 else {
    target=new JOGLTargetFixedFunction(gl.getGL2(),new JOGLRenderingParameters(CCW,false,true,false,false),GlobalLightingParameters.DEFAULT);
  }
  target.setConfiguration(config);
  boolean underground=config.getBoolean(""String_Node_Str"",true);
  TargetUtil.renderWorldObjects(target,results.getMapData(),underground);
  target.finish();
  return target;
}","private static JOGLTarget createJOGLTarget(GL gl,Results results,Configuration config){
  JOGLTarget target;
  if (""String_Node_Str"".equals(config.getString(""String_Node_Str""))) {
    boolean shadowVolumes=""String_Node_Str"".equals(config.getString(""String_Node_Str"")) || ""String_Node_Str"".equals(config.getString(""String_Node_Str""));
    boolean shadowMaps=""String_Node_Str"".equals(config.getString(""String_Node_Str"")) || ""String_Node_Str"".equals(config.getString(""String_Node_Str""));
    target=new JOGLTargetShader(gl.getGL3(),new JOGLRenderingParameters(CCW,false,true,shadowVolumes,shadowMaps),GlobalLightingParameters.DEFAULT);
  }
 else {
    target=new JOGLTargetFixedFunction(gl.getGL2(),new JOGLRenderingParameters(CCW,false,true,false,false),GlobalLightingParameters.DEFAULT);
  }
  target.setConfiguration(config);
  boolean underground=config.getBoolean(""String_Node_Str"",true);
  TargetUtil.renderWorldObjects(target,results.getMapData(),underground);
  target.finish();
  return target;
}",0.9306296691568836
186313,"public DepthBufferShader(GL3 gl){
  super(gl,""String_Node_Str"");
  vertexPositionID=gl.glGetAttribLocation(shaderProgram,""String_Node_Str"");
  for (int i=0; i < BumpMapShader.MAX_TEXTURE_LAYERS; i++)   vertexTexCoordID[i]=gl.glGetAttribLocation(shaderProgram,""String_Node_Str"" + i + ""String_Node_Str"");
  modelViewProjectionMatrixID=gl.glGetUniformLocation(shaderProgram,""String_Node_Str"");
  pmvMat=new PMVMatrix();
}","public DepthBufferShader(GL3 gl){
  super(gl,""String_Node_Str"");
  vertexPositionID=gl.glGetAttribLocation(shaderProgram,""String_Node_Str"");
  for (int i=0; i < BumpMapShader.MAX_TEXTURE_LAYERS; i++)   vertexTexCoordID[i]=gl.glGetAttribLocation(shaderProgram,""String_Node_Str"" + i + ""String_Node_Str"");
  modelViewProjectionMatrixID=gl.glGetUniformLocation(shaderProgram,""String_Node_Str"");
}",0.9679012345679012
186314,"@Override public void renderPart(Camera camera,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if (renderer == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  applyProjectionMatricesForPart(pmvMatrix,projection,xStart,xEnd,yStart,yEnd);
  applyCameraMatrices(pmvMatrix,camera);
  if (renderingParameters.useShadowMaps) {
    shadowMapShader.useShader();
    shadowMapShader.preparePMVMatrix(globalLightingParameters,pmvMatrix,rendererShader.getBoundingBox());
    rendererShader.setShader(shadowMapShader);
    rendererShader.render(camera,projection);
    shadowMapShader.disableShader();
  }
  defaultShader.useShader();
  defaultShader.loadDefaults();
  if (showShadowPerspective)   defaultShader.setPMVMatrix(shadowMapShader.getPMVMatrix());
 else   defaultShader.setPMVMatrix(pmvMatrix);
  applyRenderingParameters(gl,renderingParameters);
  applyLightingParameters(defaultShader,globalLightingParameters);
  if (renderingParameters.useShadowMaps) {
    defaultShader.bindShadowMap(shadowMapShader.getShadowMapHandle());
    defaultShader.setShadowMatrix(shadowMapShader.getPMVMatrix());
  }
  rendererShader.setShader(defaultShader);
  rendererShader.render(camera,projection);
  defaultShader.disableShader();
  nonAreaShader.useShader();
  nonAreaShader.loadDefaults();
  nonAreaShader.setPMVMatrix(pmvMatrix);
  nonAreaRenderer.render();
  nonAreaShader.disableShader();
  if (renderingParameters.useShadowVolumes) {
    gl.glDrawBuffer(GL.GL_NONE);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDepthMask(false);
    gl.glEnable(GL3.GL_DEPTH_CLAMP);
    gl.glDisable(GL_CULL_FACE);
    gl.glStencilFunc(GL.GL_ALWAYS,0,0xff);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_INCR_WRAP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_DECR_WRAP,GL.GL_KEEP);
    shadowVolumeShader.useShader();
    shadowVolumeShader.setPMVMatrix(pmvMatrix);
    rendererShadowVolume.setShader(shadowVolumeShader);
    rendererShadowVolume.render(camera,projection);
    shadowVolumeShader.disableShader();
    gl.glDepthMask(true);
    gl.glClear(GL.GL_DEPTH_BUFFER_BIT);
    gl.glDisable(GL3.GL_DEPTH_CLAMP);
    gl.glEnable(GL_CULL_FACE);
    gl.glDrawBuffer(GL_BACK);
    gl.glStencilFunc(GL.GL_NOTEQUAL,0x0,0xFF);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    applyRenderingParameters(gl,renderingParameters);
    defaultShader.useShader();
    defaultShader.loadDefaults();
    defaultShader.setPMVMatrix(pmvMatrix);
    defaultShader.setShadowed(true);
    rendererShader.setShader(defaultShader);
    rendererShader.render(camera,projection);
    defaultShader.setShadowed(false);
    defaultShader.disableShader();
    nonAreaShader.useShader();
    nonAreaShader.loadDefaults();
    nonAreaShader.setPMVMatrix(pmvMatrix);
    nonAreaRenderer.render();
    nonAreaShader.disableShader();
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
}","@Override public void renderPart(Camera camera,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if (renderer == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  applyProjectionMatricesForPart(pmvMatrix,projection,xStart,xEnd,yStart,yEnd);
  applyCameraMatrices(pmvMatrix,camera);
  if (renderingParameters.useShadowMaps) {
    shadowMapShader.useShader();
    shadowMapShader.preparePMVMatrix(globalLightingParameters,pmvMatrix,rendererShader.getBoundingBox());
    rendererShader.setShader(shadowMapShader);
    rendererShader.render(camera,projection);
    shadowMapShader.disableShader();
  }
  defaultShader.useShader();
  defaultShader.loadDefaults();
  if (showShadowPerspective)   defaultShader.setPMVMatrix(shadowMapShader.getPMVMatrix());
 else   defaultShader.setPMVMatrix(pmvMatrix);
  applyRenderingParameters(gl,renderingParameters);
  applyLightingParameters(defaultShader,globalLightingParameters);
  if (renderingParameters.useShadowMaps) {
    defaultShader.bindShadowMap(shadowMapShader.getShadowMapHandle());
    defaultShader.setShadowMatrix(shadowMapShader.getPMVMatrix());
  }
  rendererShader.setShader(defaultShader);
  rendererShader.render(camera,projection);
  defaultShader.disableShader();
  nonAreaShader.useShader();
  nonAreaShader.loadDefaults();
  nonAreaShader.setPMVMatrix(pmvMatrix);
  nonAreaRenderer.render();
  nonAreaShader.disableShader();
  if (renderingParameters.useShadowVolumes) {
    gl.glDrawBuffer(GL.GL_NONE);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDepthMask(false);
    gl.glEnable(GL3.GL_DEPTH_CLAMP);
    gl.glDisable(GL_CULL_FACE);
    gl.glStencilFunc(GL.GL_ALWAYS,0,0xff);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_INCR_WRAP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_DECR_WRAP,GL.GL_KEEP);
    shadowVolumeShader.useShader();
    shadowVolumeShader.setPMVMatrix(pmvMatrix);
    rendererShadowVolume.setShader(shadowVolumeShader);
    rendererShadowVolume.render(camera,projection);
    shadowVolumeShader.disableShader();
    gl.glDepthMask(true);
    gl.glDisable(GL3.GL_DEPTH_CLAMP);
    gl.glEnable(GL_CULL_FACE);
    gl.glDrawBuffer(GL_BACK);
    gl.glStencilFunc(GL.GL_NOTEQUAL,0x0,0xFF);
    gl.glStencilOpSeparate(GL.GL_BACK,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glStencilOpSeparate(GL.GL_FRONT,GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glDepthFunc(GL.GL_LEQUAL);
    applyRenderingParameters(gl,renderingParameters);
    defaultShader.useShader();
    defaultShader.loadDefaults();
    defaultShader.setPMVMatrix(pmvMatrix);
    defaultShader.setShadowed(true);
    rendererShader.setShader(defaultShader);
    rendererShader.render(camera,projection);
    defaultShader.setShadowed(false);
    defaultShader.disableShader();
    nonAreaShader.useShader();
    nonAreaShader.loadDefaults();
    nonAreaShader.setPMVMatrix(pmvMatrix);
    nonAreaRenderer.render();
    nonAreaShader.disableShader();
    gl.glDisable(GL.GL_STENCIL_TEST);
    gl.glDepthFunc(GL.GL_LESS);
  }
}",0.9824909150974562
186315,"public ShadowMapShader(GL3 gl){
  super(gl);
  initializeShadowMap();
}","public ShadowMapShader(GL3 gl){
  super(gl);
  pmvMat=new PMVMatrix();
  initializeShadowMap();
}",0.8452380952380952
186316,"/** 
 * renders the content added by   {@link #fillTarget(JOGLTarget)}. Only has an effect if   {@link #canBeUsed()} is true.
 * @param gl  needs to be the same gl as in previous calls
 */
public void renderTo(GL gl,Camera camera,Projection projection){
  if (canBeUsed() && camera != null && projection != null) {
    if (target == null) {
      if (""String_Node_Str"".equals(config.getString(""String_Node_Str""))) {
        boolean shadowVolumes=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
        boolean shadowMaps=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
        target=new JOGLTargetShader(gl.getGL3(),new JOGLRenderingParameters(null,false,true,shadowVolumes,shadowMaps),null);
      }
 else {
        target=new JOGLTargetFixedFunction(gl.getGL2(),new JOGLRenderingParameters(null,false,true,false,false),null);
      }
      target.setConfiguration(config);
    }
 else     if (targetNeedsReset) {
      target.reset();
    }
    targetNeedsReset=false;
    boolean viewChanged=!camera.getPos().equals(this.cameraPos) || !camera.getUp().equals(this.cameraUp) || !camera.getLookAt().equals(this.cameraLookAt)|| !projection.equals(this.projection);
    this.camera=camera;
    this.cameraPos=camera.getPos();
    this.cameraUp=camera.getUp();
    this.cameraLookAt=camera.getLookAt();
    this.projection=projection;
    if (!target.isFinished()) {
      fillTarget(target);
      target.finish();
    }
 else {
      updateTarget(target,viewChanged);
      target.finish();
    }
    target.render(camera,projection);
  }
}","/** 
 * renders the content added by   {@link #fillTarget(JOGLTarget)}. Only has an effect if   {@link #canBeUsed()} is true.
 * @param gl  needs to be the same gl as in previous calls
 */
public void renderTo(GL gl,Camera camera,Projection projection){
  if (canBeUsed() && camera != null && projection != null) {
    if (target == null) {
      if (""String_Node_Str"".equals(config.getString(""String_Node_Str""))) {
        target=new JOGLTargetShader(gl.getGL3(),new JOGLRenderingParameters(null,false,true,false,false),null);
      }
 else {
        target=new JOGLTargetFixedFunction(gl.getGL2(),new JOGLRenderingParameters(null,false,true,false,false),null);
      }
      target.setConfiguration(config);
    }
 else     if (targetNeedsReset) {
      target.reset();
    }
    targetNeedsReset=false;
    boolean viewChanged=!camera.getPos().equals(this.cameraPos) || !camera.getUp().equals(this.cameraUp) || !camera.getLookAt().equals(this.cameraLookAt)|| !projection.equals(this.projection);
    this.camera=camera;
    this.cameraPos=camera.getPos();
    this.cameraUp=camera.getUp();
    this.cameraLookAt=camera.getLookAt();
    this.projection=projection;
    if (!target.isFinished()) {
      fillTarget(target);
      target.finish();
    }
 else {
      updateTarget(target,viewChanged);
      target.finish();
    }
    target.render(camera,projection);
  }
}",0.9259510869565216
186317,"private void setParameters(final JOGLTarget target){
  boolean shadowVolumes=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  boolean shadowMaps=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  target.setRenderingParameters(new JOGLRenderingParameters(renderOptions.isBackfaceCulling() ? CCW : null,renderOptions.isWireframe(),true,shadowVolumes,shadowMaps));
  target.setGlobalLightingParameters(GlobalLightingParameters.DEFAULT);
}","private void setParameters(final JOGLTarget target){
  boolean shadowVolumes=""String_Node_Str"".equals(config.getString(""String_Node_Str"")) || ""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  boolean shadowMaps=""String_Node_Str"".equals(config.getString(""String_Node_Str"")) || ""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  target.setRenderingParameters(new JOGLRenderingParameters(renderOptions.isBackfaceCulling() ? CCW : null,renderOptions.isWireframe(),true,shadowVolumes,shadowMaps));
  target.setGlobalLightingParameters(GlobalLightingParameters.DEFAULT);
}",0.8773584905660378
186318,"private void setParameters(final JOGLTarget target){
  boolean shadowVolumes=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  boolean shadowMaps=""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  target.setRenderingParameters(new JOGLRenderingParameters(renderOptions.isBackfaceCulling() ? CCW : null,renderOptions.isWireframe(),true,shadowVolumes,shadowMaps));
  target.setGlobalLightingParameters(GlobalLightingParameters.DEFAULT);
}","private void setParameters(final JOGLTarget target){
  boolean shadowVolumes=""String_Node_Str"".equals(config.getString(""String_Node_Str"")) || ""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  boolean shadowMaps=""String_Node_Str"".equals(config.getString(""String_Node_Str"")) || ""String_Node_Str"".equals(config.getString(""String_Node_Str""));
  target.setRenderingParameters(new JOGLRenderingParameters(renderOptions.isBackfaceCulling() ? CCW : null,renderOptions.isWireframe(),true,shadowVolumes,shadowMaps));
  target.setGlobalLightingParameters(GlobalLightingParameters.DEFAULT);
}",0.8773584905660378
186319,"public PolygonWithHolesXZ(SimplePolygonXZ outerPolygon,List<SimplePolygonXZ> holes){
  this.outerPolygon=outerPolygon;
  this.holes=holes;
}","public PolygonWithHolesXZ(SimplePolygonXZ outerPolygon,List<SimplePolygonXZ> holes){
  this.outerPolygon=outerPolygon;
  this.holes=holes;
  this.getArea();
}",0.9395973154362416
186320,"private void addTileSites(Collection<VectorXYZ> result,int tileLon,int tileLat,double minLon,double minLat,double maxLon,double maxLat){
  SRTMTile tile=getTile(tileLon,tileLat);
  if (tile == null)   return;
  int minX=max(0,(int)ceil(SRTMTile.PIXELS * (minLon - tileLon)));
  int maxX=min(SRTMTile.PIXELS - 1,(int)floor(SRTMTile.PIXELS * (maxLon - tileLon)));
  int minY=max(0,(int)ceil(SRTMTile.PIXELS * (minLat - tileLat)));
  int maxY=min(SRTMTile.PIXELS - 1,(int)floor(SRTMTile.PIXELS * (maxLat - tileLat)));
  for (int x=minX; x < maxX; x++) {
    for (int y=minY; y < maxY; y++) {
      short value=tile.getData(x,y);
      double lat=tileLat + 1.0 / SRTMTile.PIXELS * y;
      double lon=tileLon + 1.0 / SRTMTile.PIXELS * x;
      VectorXZ pos=projection.calcPos(lat,lon);
      if (value != SRTMTile.BLANK_VALUE && !Double.isNaN(pos.x) && !Double.isNaN(pos.z)) {
        result.add(pos.xyz(value));
      }
    }
  }
}","private void addTileSites(Collection<VectorXYZ> result,int tileLon,int tileLat,double minLon,double minLat,double maxLon,double maxLat){
  SRTMTile tile=getTile(tileLon,tileLat);
  if (tile == null)   return;
  int minX=max(0,(int)ceil(SRTMTile.PIXELS * (minLon - tileLon)));
  int maxX=min(SRTMTile.PIXELS - 1,(int)floor(SRTMTile.PIXELS * (maxLon - tileLon)));
  int minY=max(0,(int)ceil(SRTMTile.PIXELS * (minLat - tileLat)));
  int maxY=min(SRTMTile.PIXELS - 1,(int)floor(SRTMTile.PIXELS * (maxLat - tileLat)));
  for (int x=minX; x < maxX; x++) {
    for (int y=minY; y < maxY; y++) {
      short value=tile.getData(x,y);
      double lat=tileLat + 1.0 / SRTMTile.PIXELS * (y + 0.5);
      double lon=tileLon + 1.0 / SRTMTile.PIXELS * (x + 0.5);
      VectorXZ pos=projection.calcPos(lat,lon);
      if (value != SRTMTile.BLANK_VALUE && !Double.isNaN(pos.x) && !Double.isNaN(pos.z)) {
        result.add(pos.xyz(value));
      }
    }
  }
}",0.9903846153846154
186321,"@Override public void drawTriangles(Material material,Collection<? extends TriangleXYZ> triangles,List<List<VectorXZ>> texCoordLists){
  int i=0;
  for (  TriangleXYZ triangle : triangles) {
    if (reconstructFaces()) {
      VectorXYZ n=triangle.getNormal();
      if (Double.isNaN(n.x) || Double.isNaN(n.y) || Double.isNaN(n.z)) {
        continue;
      }
      isolatedTriangles.put(material,new IsolatedTriangle(triangle,n,i * 3,texCoordLists));
    }
 else {
      drawFace(material,triangle.getVertices(),null,texCoordLists);
    }
  }
}","@Override public void drawTriangles(Material material,Collection<? extends TriangleXYZ> triangles,List<List<VectorXZ>> texCoordLists){
  int i=0;
  for (  TriangleXYZ triangle : triangles) {
    if (reconstructFaces()) {
      VectorXYZ n=triangle.getNormal();
      if (Double.isNaN(n.x) || Double.isNaN(n.y) || Double.isNaN(n.z)) {
        continue;
      }
      isolatedTriangles.put(material,new IsolatedTriangle(triangle,n,i * 3,texCoordLists));
    }
 else {
      List<List<VectorXZ>> subLists=new ArrayList<List<VectorXZ>>();
      for (      List<VectorXZ> list : texCoordLists) {
        subLists.add(list.subList(3 * i,3 * (i + 1)));
      }
      drawFace(material,triangle.getVertices(),null,subLists);
    }
    i++;
  }
}",0.8377535101404057
186322,"public void insert(VectorXYZ point){
  DelaunayTriangle triangleEnclosingPoint=getEnlosingTriangle(point);
  Stack<Flip> splitStack=new Stack<Flip>();
  Flip13 initialFlip=new Flip13(triangleEnclosingPoint,point);
  initialFlip.perform();
  splitStack.push(initialFlip);
  Queue<DelaunayTriangle> uncheckedTriangles=new LinkedList<DelaunayTriangle>();
  uncheckedTriangles.offer(initialFlip.createdTriangles[0]);
  uncheckedTriangles.offer(initialFlip.createdTriangles[1]);
  uncheckedTriangles.offer(initialFlip.createdTriangles[2]);
  while (!uncheckedTriangles.isEmpty()) {
    DelaunayTriangle triangle=uncheckedTriangles.poll();
    if (!isDelaunay(triangle)) {
      Flip22 flip=new Flip22(triangle);
      flip.perform();
      splitStack.push(flip);
    }
  }
}","public void insert(VectorXYZ point){
  DelaunayTriangle triangleEnclosingPoint=getEnlosingTriangle(point);
  Stack<Flip> splitStack=new Stack<Flip>();
  Flip13 initialFlip=new Flip13(triangleEnclosingPoint,point);
  initialFlip.perform();
  splitStack.push(initialFlip);
  Queue<DelaunayTriangle> uncheckedTriangles=new LinkedList<DelaunayTriangle>();
  uncheckedTriangles.offer(initialFlip.createdTriangles[0]);
  uncheckedTriangles.offer(initialFlip.createdTriangles[1]);
  uncheckedTriangles.offer(initialFlip.createdTriangles[2]);
  while (!uncheckedTriangles.isEmpty()) {
    DelaunayTriangle triangle=uncheckedTriangles.poll();
    if (!isDelaunay(triangle)) {
      Flip22 flip=new Flip22(triangle);
      flip.perform();
      splitStack.push(flip);
      uncheckedTriangles.offer(flip.createdTriangles[0]);
      uncheckedTriangles.offer(flip.createdTriangles[1]);
    }
  }
}",0.9298669891172914
186323,"public List<TriangleXYZ> getVoronoiParts(VectorXYZ point){
  List<TriangleXYZ> result=new ArrayList<TriangleXYZ>();
  List<DelaunayEdge> edges=getIncidentEdges(point);
  for (int i=0; i < edges.size(); i++) {
    result.add(new TriangleXYZ(point,edges.get(i).getCenter(),edges.get((i + 1) % edges.size()).getCenter()));
  }
  return result;
}","public List<TriangleXZ> getVoronoiParts(VectorXYZ point){
  List<TriangleXZ> result=new ArrayList<TriangleXZ>();
  final VectorXZ pointXZ=point.xz();
  List<VectorXZ> centers=new ArrayList<VectorXZ>();
  for (  DelaunayTriangle t : getIncidentTriangles(point)) {
    centers.add(t.getCircumcircleCenter());
  }
  Collections.sort(centers,new Comparator<VectorXZ>(){
    @Override public int compare(    VectorXZ v1,    VectorXZ v2){
      return Double.compare(v2.subtract(pointXZ).angle(),v1.subtract(pointXZ).angle());
    }
  }
);
  for (int i=0; i < centers.size(); i++) {
    result.add(new TriangleXZ(point.xz(),centers.get(i),centers.get((i + 1) % centers.size())));
  }
  return result;
}",0.4874759152215799
186324,"@Override public void perform(){
  VectorXYZ[] points=new VectorXYZ[4];
  DelaunayTriangle[] neighbors=new DelaunayTriangle[4];
  points[0]=originalTriangles[0].getPoint(1);
  neighbors[0]=originalTriangles[0].getNeighbor(1);
  points[1]=originalTriangles[0].getPoint(2);
  neighbors[1]=originalTriangles[0].getNeighbor(2);
  int i=originalTriangles[1].indexOfNeighbor(originalTriangles[0]);
  points[2]=originalTriangles[1].getPoint((i + 1) % 3);
  neighbors[2]=originalTriangles[1].getNeighbor((i + 1) % 3);
  points[3]=originalTriangles[1].getPoint((i + 2) % 3);
  neighbors[3]=originalTriangles[1].getNeighbor((i + 2) % 3);
  createdTriangles=new DelaunayTriangle[2];
  createdTriangles[0]=new DelaunayTriangle(points[1],points[2],points[3]);
  createdTriangles[1]=new DelaunayTriangle(points[3],points[0],points[1]);
  createdTriangles[0].setNeighbor(0,neighbors[1]);
  createdTriangles[0].setNeighbor(1,neighbors[2]);
  createdTriangles[0].setNeighbor(2,createdTriangles[1]);
  createdTriangles[1].setNeighbor(0,neighbors[3]);
  createdTriangles[1].setNeighbor(1,neighbors[0]);
  createdTriangles[1].setNeighbor(2,createdTriangles[0]);
  if (neighbors[0] != null)   neighbors[0].replaceNeighbor(originalTriangles[0],createdTriangles[1]);
  if (neighbors[1] != null)   neighbors[1].replaceNeighbor(originalTriangles[0],createdTriangles[0]);
  if (neighbors[2] != null)   neighbors[2].replaceNeighbor(originalTriangles[1],createdTriangles[0]);
  if (neighbors[3] != null)   neighbors[3].replaceNeighbor(originalTriangles[1],createdTriangles[1]);
  triangles.remove(originalTriangles[0]);
  triangles.remove(originalTriangles[1]);
  triangles.add(createdTriangles[0]);
  triangles.add(createdTriangles[1]);
}","@Override public void perform(){
  VectorXYZ[] points=new VectorXYZ[4];
  DelaunayTriangle[] neighbors=new DelaunayTriangle[4];
  points[0]=originalTriangles[0].getPoint(1);
  neighbors[0]=originalTriangles[0].getNeighbor(1);
  points[1]=originalTriangles[0].getPoint(2);
  neighbors[1]=originalTriangles[0].getNeighbor(2);
  int i=originalTriangles[1].indexOfNeighbor(originalTriangles[0]);
  points[2]=originalTriangles[1].getPoint((i + 1) % 3);
  neighbors[2]=originalTriangles[1].getNeighbor((i + 1) % 3);
  points[3]=originalTriangles[1].getPoint((i + 2) % 3);
  neighbors[3]=originalTriangles[1].getNeighbor((i + 2) % 3);
  createdTriangles=new DelaunayTriangle[2];
  createdTriangles[0]=new DelaunayTriangle(points[2],points[3],points[1]);
  createdTriangles[1]=new DelaunayTriangle(points[3],points[0],points[1]);
  createdTriangles[0].setNeighbor(0,neighbors[2]);
  createdTriangles[0].setNeighbor(1,createdTriangles[1]);
  createdTriangles[0].setNeighbor(2,neighbors[1]);
  createdTriangles[1].setNeighbor(0,neighbors[3]);
  createdTriangles[1].setNeighbor(1,neighbors[0]);
  createdTriangles[1].setNeighbor(2,createdTriangles[0]);
  if (neighbors[0] != null)   neighbors[0].replaceNeighbor(originalTriangles[0],createdTriangles[1]);
  if (neighbors[1] != null)   neighbors[1].replaceNeighbor(originalTriangles[0],createdTriangles[0]);
  if (neighbors[2] != null)   neighbors[2].replaceNeighbor(originalTriangles[1],createdTriangles[0]);
  if (neighbors[3] != null)   neighbors[3].replaceNeighbor(originalTriangles[1],createdTriangles[1]);
  triangles.remove(originalTriangles[0]);
  triangles.remove(originalTriangles[1]);
  triangles.add(createdTriangles[0]);
  triangles.add(createdTriangles[1]);
}",0.9824663939216832
186325,"public double angleAt(int pointIndex){
  VectorXZ vecToPoint=getPoint(pointIndex).xz().subtract(getPoint((pointIndex + 2) % 3).xz());
  VectorXZ vecFromPoint=getPoint((pointIndex + 1) % 3).xz().subtract(getPoint(pointIndex).xz());
  return VectorXZ.angleBetween(vecToPoint,vecFromPoint);
}","public double angleAt(int pointIndex){
  VectorXZ vecToNext=getPoint(pointIndex).xz().subtract(getPoint((pointIndex + 2) % 3).xz());
  VectorXZ vecToPrev=getPoint((pointIndex + 1) % 3).xz().subtract(getPoint(pointIndex).xz()).invert();
  return VectorXZ.angleBetween(vecToNext,vecToPrev);
}",0.9084628670120898
186326,"public void clear(){
  minX=minZ=Float.MAX_VALUE;
  maxX=maxZ=-Float.MAX_VALUE;
  points=new ArrayList<VectorXYZ>();
  triangulation=null;
  this.add(new VectorXYZ(-SIZE,0,-SIZE));
  this.add(new VectorXYZ(-SIZE,0,+SIZE));
  this.add(new VectorXYZ(+SIZE,0,+SIZE));
  this.add(new VectorXYZ(+SIZE,0,-SIZE));
  this.repaint(0);
}","public void clear(){
  minX=minZ=Float.MAX_VALUE;
  maxX=maxZ=-Float.MAX_VALUE;
  points=new ArrayList<VectorXYZ>();
  triangulation=null;
  this.add(new VectorXYZ(-SIZE,0,-SIZE));
  this.add(new VectorXYZ(+SIZE,0,-SIZE));
  this.add(new VectorXYZ(+SIZE,0,+SIZE));
  this.add(new VectorXYZ(-SIZE,0,+SIZE));
  this.repaint(0);
}",0.9510703363914372
186327,"@Override public void paint(Graphics g){
  super.paint(g);
  if (points.size() > 4) {
    VectorXYZ p=points.get(points.size() - 1);
    g.setColor(Color.YELLOW);
    for (    TriangleXYZ t : triangulation.getVoronoiParts(p)) {
      fill(g,new TriangleXZ(t.v1.xz(),t.v2.xz(),t.v3.xz()));
    }
    g.setColor(Color.GREEN);
    for (    DelaunayTriangle t : triangulation.getIncidentTriangles(p)) {
      VectorXZ center=t.getCircumcircleCenter();
      draw(g,center);
      drawCircle(g,center,t.p0.distanceToXZ(center));
    }
  }
  g.setColor(Color.RED);
  for (  DelaunayTriangle triangle : triangulation.triangles) {
    draw(g,triangle.asTriangleXZ());
  }
  g.setColor(Color.BLACK);
  for (  VectorXYZ p : points) {
    draw(g,p.xz());
  }
}","@Override public void paint(Graphics g){
  super.paint(g);
  if (points.size() > 4) {
    Random random=new Random(0);
    for (    VectorXYZ p : points) {
      g.setColor(new Color(0.5f + random.nextFloat() / 2,0.5f + random.nextFloat() / 2,0.5f + random.nextFloat() / 2));
      for (      TriangleXZ t : triangulation.getVoronoiParts(p)) {
        fill(g,t);
      }
    }
    VectorXYZ p=points.get(points.size() - 1);
    g.setColor(Color.GREEN);
    for (    DelaunayTriangle t : triangulation.getIncidentTriangles(p)) {
      VectorXZ center=t.getCircumcircleCenter();
      double radius=t.p0.distanceToXZ(center);
      draw(g,center);
      drawCircle(g,center,radius);
    }
  }
  g.setColor(Color.RED);
  for (  DelaunayTriangle triangle : triangulation.triangles) {
    draw(g,triangle.asTriangleXZ());
  }
  g.setColor(Color.BLACK);
  for (  VectorXYZ p : points) {
    draw(g,p.xz());
  }
}",0.6441087613293052
186328,"@Override public void actionPerformed(ActionEvent e){
  double x=(Math.random() * 2 * SIZE) - SIZE;
  double z=(Math.random() * 2 * SIZE) - SIZE;
  panel.add(new VectorXYZ(x,0,z));
}","@Override public void actionPerformed(ActionEvent e){
  if (panel.points.size() <= 4) {
    random=new Random(1);
  }
  double x=(random.nextDouble() * 2 * SIZE) - SIZE;
  double z=(random.nextDouble() * 2 * SIZE) - SIZE;
  panel.add(new VectorXYZ(x,0,z));
}",0.6818181818181818
186329,"/** 
 * @param outputFile
 * @param outputMode   one of the image output modes
 * @param x            horizontal resolution
 * @param y            vertical resolution
 * @param results
 * @param camera
 * @param projection
 * @throws IOException
 */
public void writeImageFile(File outputFile,OutputMode outputMode,int x,int y,final Camera camera,final Projection projection) throws IOException {
  int xParts=1 + ((x - 1) / pBufferSizeX);
  int yParts=1 + ((y - 1) / pBufferSizeY);
  BufferedImage image=new BufferedImage(x,y,BufferedImage.TYPE_INT_RGB);
  for (int xPart=0; xPart < xParts; ++xPart) {
    for (int yPart=0; yPart < yParts; ++yPart) {
      int xStart=xPart * pBufferSizeX;
      int xEnd=(xPart + 1 < xParts) ? (xStart + (pBufferSizeX - 1)) : (x - 1);
      int xSize=(xEnd - xStart) + 1;
      int yStart=yPart * pBufferSizeY;
      int yEnd=(yPart + 1 < yParts) ? (yStart + (pBufferSizeY - 1)) : (y - 1);
      int ySize=(yEnd - yStart) + 1;
      JOGLTarget.clearGL(gl,null);
      if (backgroundImage != null) {
        JOGLTarget.drawBackgoundImage(gl,backgroundImage,xStart,yStart,xSize,ySize,backgroundTextureManager);
      }
      JOGLTarget target=(bufferTarget == null) ? createJOGLTarget(gl,results,config) : bufferTarget;
      target.renderPart(camera,projection,xStart / (double)(x - 1),xEnd / (double)(x - 1),yStart / (double)(y - 1),yEnd / (double)(y - 1));
      if (target != bufferTarget) {
        target.freeResources();
      }
      BufferedImage imagePart=Screenshot.readToBufferedImage(pBufferSizeX,pBufferSizeY);
      image.getGraphics().drawImage(imagePart,xStart,y - 1 - yEnd,xSize,ySize,null);
    }
  }
switch (outputMode) {
case PNG:
    ImageIO.write(image,""String_Node_Str"",outputFile);
  break;
case PPM:
writePPMFile(image,outputFile);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + outputMode);
}
}","/** 
 * renders this ImageExporter's content to a file
 * @param outputMode   one of the image output modes
 * @param x            horizontal resolution
 * @param y            vertical resolution
 */
public void writeImageFile(File outputFile,OutputMode outputMode,int x,int y,final Camera camera,final Projection projection) throws IOException {
  int xParts=1 + ((x - 1) / pBufferSizeX);
  int yParts=1 + ((y - 1) / pBufferSizeY);
  BufferedImage image=new BufferedImage(x,y,BufferedImage.TYPE_INT_RGB);
  for (int xPart=0; xPart < xParts; ++xPart) {
    for (int yPart=0; yPart < yParts; ++yPart) {
      int xStart=xPart * pBufferSizeX;
      int xEnd=(xPart + 1 < xParts) ? (xStart + (pBufferSizeX - 1)) : (x - 1);
      int xSize=(xEnd - xStart) + 1;
      int yStart=yPart * pBufferSizeY;
      int yEnd=(yPart + 1 < yParts) ? (yStart + (pBufferSizeY - 1)) : (y - 1);
      int ySize=(yEnd - yStart) + 1;
      JOGLTarget.clearGL(gl,null);
      if (backgroundImage != null) {
        JOGLTarget.drawBackgoundImage(gl,backgroundImage,xStart,yStart,xSize,ySize,backgroundTextureManager);
      }
      JOGLTarget target=(bufferTarget == null) ? createJOGLTarget(gl,results,config) : bufferTarget;
      target.renderPart(camera,projection,xStart / (double)(x - 1),xEnd / (double)(x - 1),yStart / (double)(y - 1),yEnd / (double)(y - 1));
      if (target != bufferTarget) {
        target.freeResources();
      }
      BufferedImage imagePart=Screenshot.readToBufferedImage(pBufferSizeX,pBufferSizeY);
      image.getGraphics().drawImage(imagePart,xStart,y - 1 - yEnd,xSize,ySize,null);
    }
  }
switch (outputMode) {
case PNG:
    ImageIO.write(image,""String_Node_Str"",outputFile);
  break;
case PPM:
writePPMFile(image,outputFile);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + outputMode);
}
}",0.9223300970873788
186330,"/** 
 * manually frees resources that would otherwise remain used until the finalize call. It is no longer possible to use  {@link #writeImageFile(File,OutputMode,int,int,Camera,Projection)}afterwards.
 */
public void freeResources(){
  if (backgroundTextureManager != null) {
    backgroundTextureManager.releaseAll();
    backgroundTextureManager=null;
  }
  if (bufferTarget != null) {
    bufferTarget.freeResources();
    bufferTarget=null;
  }
  if (pBuffer != null) {
    pBuffer.getContext().release();
    pBuffer.destroy();
    pBuffer=null;
    gl=null;
  }
}","/** 
 * manually frees resources that would otherwise remain used until the finalize call. It is no longer possible to use  {@link #writeImageFile(File,CLIArgumentsUtil.OutputMode,int,int,Camera,Projection)}afterwards.
 */
public void freeResources(){
  if (backgroundTextureManager != null) {
    backgroundTextureManager.releaseAll();
    backgroundTextureManager=null;
  }
  if (bufferTarget != null) {
    bufferTarget.freeResources();
    bufferTarget=null;
  }
  if (pBuffer != null) {
    pBuffer.getContext().release();
    pBuffer.destroy();
    pBuffer=null;
    gl=null;
  }
}",0.9853068280034571
186331,"/** 
 * returns a boundary based on the bounds in the input file if available, otherwise returns the same as   {@link #getBoundary()}
 */
public AxisAlignedBoundingBoxXZ getBoundary(){
  if (fileBoundary != null) {
    return fileBoundary;
  }
 else {
    return dataBoundary;
  }
}","/** 
 * returns a boundary based on the bounds in the input file if available, otherwise returns the same as   {@link #getDataBoundary()}
 */
public AxisAlignedBoundingBoxXZ getBoundary(){
  if (fileBoundary != null) {
    return fileBoundary;
  }
 else {
    return dataBoundary;
  }
}",0.9929577464788732
186332,"/** 
 * creates the ordering described for   {@link #getConnectedLines()}
 */
private void sortLinesByAngle(List<? extends MapSegment> lines){
  Collections.sort(lines,new Comparator<MapSegment>(){
    @Override public int compare(    MapSegment l1,    MapSegment l2){
      VectorXZ d1=l1.getDirection();
      VectorXZ d2=l2.getDirection();
      if (inboundLines.contains(l1)) {
        d1=d1.invert();
      }
      if (inboundLines.contains(l2)) {
        d2=d2.invert();
      }
      if (d1.z < 0 && d2.z > 0) {
        return -1;
      }
 else       if (d1.z > 0 && d2.z < 0) {
        return +1;
      }
      double comparison=d1.dot(X_UNIT) - d2.dot(X_UNIT);
      if (comparison == 0) {
        return 0;
      }
      if (d1.z < 0) {
        return (comparison > 0) ? -1 : +1;
      }
 else {
        return (comparison > 0) ? +1 : -1;
      }
    }
  }
);
}","/** 
 * creates the ordering described for   {@link #getConnectedSegments()}
 */
private void sortLinesByAngle(List<? extends MapSegment> lines){
  Collections.sort(lines,new Comparator<MapSegment>(){
    @Override public int compare(    MapSegment l1,    MapSegment l2){
      VectorXZ d1=l1.getDirection();
      VectorXZ d2=l2.getDirection();
      if (inboundLines.contains(l1)) {
        d1=d1.invert();
      }
      if (inboundLines.contains(l2)) {
        d2=d2.invert();
      }
      if (d1.z < 0 && d2.z > 0) {
        return -1;
      }
 else       if (d1.z > 0 && d2.z < 0) {
        return +1;
      }
      double comparison=d1.dot(X_UNIT) - d2.dot(X_UNIT);
      if (comparison == 0) {
        return 0;
      }
      if (d1.z < 0) {
        return (comparison > 0) ? -1 : +1;
      }
 else {
        return (comparison > 0) ? +1 : -1;
      }
    }
  }
);
}",0.9936962750716332
186333,"/** 
 * Triangulates a simple polygon using Ear Clipping. The implementation is based on the paper ""Triangulation by Ear Clipping"" by David Eberly.
 * @param outline  outline of the polygon to triangulate;can be arbitrarily modified by this method.
 * @return
 */
static final List<TriangleXZ> triangulateSimplePolygon(List<VectorXZ> outline){
  if (outline.size() == 3) {
    return Collections.singletonList(new TriangleXZ(outline.get(1),outline.get(2),outline.get(3)));
  }
  outline.remove(0);
  List<TriangleXZ> triangles=new ArrayList<TriangleXZ>(outline.size() - 2);
  boolean progress=true;
  while (outline.size() >= 3 && progress) {
    progress=false;
    for (int i=0; i < outline.size(); i++) {
      if (isEarTip(i,outline)) {
        triangles.add(triangleAtTip(i,outline));
        outline.remove(i);
        progress=true;
        break;
      }
    }
  }
  if (outline.size() >= 3) {
    throw new InvalidGeometryException(""String_Node_Str"" + ""String_Node_Str"" + outline + ""String_Node_Str""+ triangles);
  }
  return triangles;
}","/** 
 * Triangulates a simple polygon using Ear Clipping. The implementation is based on the paper ""Triangulation by Ear Clipping"" by David Eberly.
 * @param outline  outline of the polygon to triangulate;can be arbitrarily modified by this method.
 */
static final List<TriangleXZ> triangulateSimplePolygon(List<VectorXZ> outline){
  if (outline.size() == 3) {
    return Collections.singletonList(new TriangleXZ(outline.get(1),outline.get(2),outline.get(3)));
  }
  outline.remove(0);
  List<TriangleXZ> triangles=new ArrayList<TriangleXZ>(outline.size() - 2);
  boolean progress=true;
  while (outline.size() >= 3 && progress) {
    progress=false;
    for (int i=0; i < outline.size(); i++) {
      if (isEarTip(i,outline)) {
        triangles.add(triangleAtTip(i,outline));
        outline.remove(i);
        progress=true;
        break;
      }
    }
  }
  if (outline.size() >= 3) {
    throw new InvalidGeometryException(""String_Node_Str"" + ""String_Node_Str"" + outline + ""String_Node_Str""+ triangles);
  }
  return triangles;
}",0.9947191550648103
186334,"/** 
 * finds a vertex in the polygon outline that is visible from a given point.  Visibility means that the connection between the point and the outline vertex does not intersect the outline or any hole polygon.
 * @return  index of a vertex in the polygon outlineor null if none was found. The method will always find an outline vertex if there are no holes.
 */
static final Integer findVisibleOutlineVertex(List<VectorXZ> polygonOutline,VectorXZ point,Iterable<SimplePolygonXZ> holes){
  int outerIndex=-1;
  checkOuterVertex:   for (  VectorXZ outerVertex : polygonOutline) {
    outerIndex+=1;
    for (int i=0; i + 1 < polygonOutline.size(); i++) {
      if (null != GeometryUtil.getTrueLineSegmentIntersection(point,outerVertex,polygonOutline.get(i),polygonOutline.get(i + 1))) {
        continue checkOuterVertex;
      }
    }
    for (    SimplePolygonXZ hole : holes) {
      if (hole.intersects(point,outerVertex)) {
        continue checkOuterVertex;
      }
    }
    return outerIndex;
  }
  return null;
}","/** 
 * finds a vertex in the polygon outline that is visible from a given point. Visibility means that the connection between the point and the outline vertex does not intersect the outline or any hole polygon.
 * @return  index of a vertex in the polygon outlineor null if none was found. The method will always find an outline vertex if there are no holes.
 */
static final Integer findVisibleOutlineVertex(List<VectorXZ> polygonOutline,VectorXZ point,Iterable<SimplePolygonXZ> holes){
  int outerIndex=-1;
  checkOuterVertex:   for (  VectorXZ outerVertex : polygonOutline) {
    outerIndex+=1;
    for (int i=0; i + 1 < polygonOutline.size(); i++) {
      if (null != GeometryUtil.getTrueLineSegmentIntersection(point,outerVertex,polygonOutline.get(i),polygonOutline.get(i + 1))) {
        continue checkOuterVertex;
      }
    }
    for (    SimplePolygonXZ hole : holes) {
      if (hole.intersects(point,outerVertex)) {
        continue checkOuterVertex;
      }
    }
    return outerIndex;
  }
  return null;
}",0.9995105237395986
186335,"/** 
 * draws a triangle strip.
 * @param vs             vertices of the triangle strip
 * @param texCoordsList  one texture coordinate list per texture.Each must have the same length as the ""vs"" parameter. Can be null if no texturing information is available.
 */
void drawTriangleStrip(Material material,List<VectorXYZ> vs,List<List<VectorXZ>> texCoordLists);","/** 
 * draws a triangle strip.
 * @param vs             vertices of the triangle strip
 * @param texCoordLists  one texture coordinate list per texture.Each must have the same length as the ""vs"" parameter. Can be null if no texturing information is available.
 */
void drawTriangleStrip(Material material,List<VectorXYZ> vs,List<List<VectorXZ>> texCoordLists);",0.9861495844875346
186336,"/** 
 * returns the vector that is orthogonal to the connection between pos and lookAt and points to the right of it. The result has length 1 and is parallel to the XZ plane.
 */
public VectorXYZ getRight(){
  return getViewDirection().crossNormalized(up);
}","/** 
 * returns the vector that is orthogonal to the connection between pos and lookAt and points to the right of it. The result has length 1.
 */
public VectorXYZ getRight(){
  return getViewDirection().crossNormalized(up);
}",0.9338842975206612
186337,"/** 
 * similar to   {@link #applyProjectionMatrices(GL,Projection)}, but allows rendering only a part of the ""normal"" image.
 * @see
 */
static final void applyProjectionMatricesForPart(GL2 gl,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if ((xStart != 0 || xEnd != 1 || yStart != 0 || yEnd != 1) && !projection.isOrthographic()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  gl.glMatrixMode(GL_PROJECTION);
  gl.glLoadIdentity();
  if (projection.isOrthographic()) {
    double volumeWidth=projection.getAspectRatio() * projection.getVolumeHeight();
    gl.glOrtho((-0.5 + xStart) * volumeWidth,(-0.5 + xEnd) * volumeWidth,(-0.5 + yStart) * projection.getVolumeHeight(),(-0.5 + yEnd) * projection.getVolumeHeight(),projection.getNearClippingDistance(),projection.getFarClippingDistance());
  }
 else {
    new GLU().gluPerspective(projection.getVertAngle(),projection.getAspectRatio(),projection.getNearClippingDistance(),projection.getFarClippingDistance());
  }
  gl.glMatrixMode(GL_MODELVIEW);
}","/** 
 * similar to   {@link #applyProjectionMatrices(GL2,Projection)}, but allows rendering only a part of the ""normal"" image.
 */
static final void applyProjectionMatricesForPart(GL2 gl,Projection projection,double xStart,double xEnd,double yStart,double yEnd){
  if ((xStart != 0 || xEnd != 1 || yStart != 0 || yEnd != 1) && !projection.isOrthographic()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  gl.glMatrixMode(GL_PROJECTION);
  gl.glLoadIdentity();
  if (projection.isOrthographic()) {
    double volumeWidth=projection.getAspectRatio() * projection.getVolumeHeight();
    gl.glOrtho((-0.5 + xStart) * volumeWidth,(-0.5 + xEnd) * volumeWidth,(-0.5 + yStart) * projection.getVolumeHeight(),(-0.5 + yEnd) * projection.getVolumeHeight(),projection.getNearClippingDistance(),projection.getFarClippingDistance());
  }
 else {
    new GLU().gluPerspective(projection.getVertAngle(),projection.getAspectRatio(),projection.getNearClippingDistance(),projection.getFarClippingDistance());
  }
  gl.glMatrixMode(GL_MODELVIEW);
}",0.9957963568425968
186338,"/** 
 * builds lane connections at a junction of just oneway roads. Intended to handle motorway merges and splits well. Inbound and outbound roads must not be mixed, but build two separate continuous blocks instead.
 * @param inboundOnewayRoadsLTR  inbound roads, left to right
 * @param inboundOnewayRoadsLTR  outbound roads, left to right
 */
private static List<LaneConnection> buildLaneConnections_allOneway(MapNode node,List<Road> inboundOnewayRoadsLTR,List<Road> outboundOnewayRoadsLTR){
  List<Lane> inboundLanes=new ArrayList<Lane>();
  List<Lane> outboundLanes=new ArrayList<Lane>();
  for (  Road road : inboundOnewayRoadsLTR) {
    inboundLanes.addAll(road.getLaneLayout().getLanesLeftToRight());
  }
  for (  Road road : outboundOnewayRoadsLTR) {
    outboundLanes.addAll(road.getLaneLayout().getLanesLeftToRight());
  }
  Map<Integer,Integer> matches=findMatchingLanes(inboundLanes,outboundLanes,false,false);
  List<LaneConnection> result=new ArrayList<RoadModule.LaneConnection>();
  for (  int lane1Index : matches.keySet()) {
    final Lane lane1=inboundLanes.get(lane1Index);
    final Lane lane2=outboundLanes.get(matches.get(lane1Index));
    result.add(buildLaneConnection(lane1,lane2,RoadPart.LEFT,false,true));
  }
  return result;
}","/** 
 * builds lane connections at a junction of just oneway roads. Intended to handle motorway merges and splits well. Inbound and outbound roads must not be mixed, but build two separate continuous blocks instead.
 * @param inboundOnewayRoadsLTR  inbound roads, left to right
 * @param outboundOnewayRoadsLTR  outbound roads, left to right
 */
private static List<LaneConnection> buildLaneConnections_allOneway(MapNode node,List<Road> inboundOnewayRoadsLTR,List<Road> outboundOnewayRoadsLTR){
  List<Lane> inboundLanes=new ArrayList<Lane>();
  List<Lane> outboundLanes=new ArrayList<Lane>();
  for (  Road road : inboundOnewayRoadsLTR) {
    inboundLanes.addAll(road.getLaneLayout().getLanesLeftToRight());
  }
  for (  Road road : outboundOnewayRoadsLTR) {
    outboundLanes.addAll(road.getLaneLayout().getLanesLeftToRight());
  }
  Map<Integer,Integer> matches=findMatchingLanes(inboundLanes,outboundLanes,false,false);
  List<LaneConnection> result=new ArrayList<RoadModule.LaneConnection>();
  for (  int lane1Index : matches.keySet()) {
    final Lane lane1=inboundLanes.get(lane1Index);
    final Lane lane2=outboundLanes.get(matches.get(lane1Index));
    result.add(buildLaneConnection(lane1,lane2,RoadPart.LEFT,false,true));
  }
  return result;
}",0.9980103461997611
186339,"/** 
 * creates an rotated version of a list of vectors by rotating them by the given angle around the parallel of the x axis defined by the given Y and Z coordinates
 * @angle  rotation angle in degrees
 */
public static final List<VectorXYZ> rotateShapeX(List<VectorXYZ> shape,double angle,double posY,double posZ){
  VectorXYZ[] result=new VectorXYZ[shape.size()];
  for (int i=0; i < shape.size(); ++i) {
    result[i]=shape.get(i).add(0f,-posY,-posZ);
    result[i]=result[i].rotateX(toRadians(angle));
    result[i]=result[i].add(0f,posY,posZ);
  }
  return asList(result);
}","/** 
 * creates an rotated version of a list of vectors by rotating them by the given angle around the parallel of the x axis defined by the given Y and Z coordinates
 * @param angle  rotation angle in degrees
 */
public static final List<VectorXYZ> rotateShapeX(List<VectorXYZ> shape,double angle,double posY,double posZ){
  VectorXYZ[] result=new VectorXYZ[shape.size()];
  for (int i=0; i < shape.size(); ++i) {
    result[i]=shape.get(i).add(0f,-posY,-posZ);
    result[i]=result[i].rotateX(toRadians(angle));
    result[i]=result[i].add(0f,posY,posZ);
  }
  return asList(result);
}",0.9948630136986302
186340,"/** 
 * Returns a two- or three-element array containing first the custom data flavor, if one was created in the constructors, second the default   {@link #DATA_FLAVOR} associated with{@link TransferableObject}, and third the  {@link java.awt.datatransfer.DataFlavor.stringFlavor}.
 * @return An array of supported data flavors
 * @since 1.1
 */
public java.awt.datatransfer.DataFlavor[] getTransferDataFlavors(){
  if (customFlavor != null)   return new java.awt.datatransfer.DataFlavor[]{customFlavor,DATA_FLAVOR,java.awt.datatransfer.DataFlavor.stringFlavor};
 else   return new java.awt.datatransfer.DataFlavor[]{DATA_FLAVOR,java.awt.datatransfer.DataFlavor.stringFlavor};
}","/** 
 * Returns a two- or three-element array containing first the custom data flavor, if one was created in the constructors, second the default   {@link #DATA_FLAVOR} associated with{@link TransferableObject}, and third the  {@code java.awt.datatransfer.DataFlavor.stringFlavor}.
 * @return An array of supported data flavors
 * @since 1.1
 */
public java.awt.datatransfer.DataFlavor[] getTransferDataFlavors(){
  if (customFlavor != null)   return new java.awt.datatransfer.DataFlavor[]{customFlavor,DATA_FLAVOR,java.awt.datatransfer.DataFlavor.stringFlavor};
 else   return new java.awt.datatransfer.DataFlavor[]{DATA_FLAVOR,java.awt.datatransfer.DataFlavor.stringFlavor};
}",0.9941002949852508
186341,"public void drawText(String string,int x,int y,int screenWidth,int screenHeight,Color color){
  textRenderer.beginRendering(screenWidth,screenHeight);
  textRenderer.setColor(color);
  textRenderer.draw(string,x,y);
  textRenderer.endRendering();
}","public static final void drawText(String string,int x,int y,int screenWidth,int screenHeight,Color color){
  textRenderer.beginRendering(screenWidth,screenHeight);
  textRenderer.setColor(color);
  textRenderer.draw(string,x,y);
  textRenderer.endRendering();
}",0.974459724950884
186342,"public ViewerFrame(final Data data,final MessageManager messageManager,final RenderOptions renderOptions,final Configuration config){
  super(""String_Node_Str"");
  this.data=data;
  this.renderOptions=renderOptions;
  this.messageManager=messageManager;
  data.setConfig(config);
  createMenuBar();
  glCanvas=new ViewerGLCanvas(data,messageManager,renderOptions);
  add(glCanvas,BorderLayout.CENTER);
  new FileDrop(glCanvas,new FileDrop.Listener(){
    @Override public void filesDropped(    File[] files){
      if (files.length >= 1) {
        new OpenOSMAction(ViewerFrame.this,data,renderOptions).openOSMFile(files[0],true);
      }
    }
  }
);
  DefaultNavigation navigation=new DefaultNavigation(this,renderOptions);
  glCanvas.addMouseListener(navigation);
  glCanvas.addMouseMotionListener(navigation);
  glCanvas.addMouseWheelListener(navigation);
  glCanvas.addKeyListener(navigation);
  new ToggleDebugViewAction(new HelpView(),-1,true,this,data,renderOptions);
  setDefaultCloseOperation(EXIT_ON_CLOSE);
  pack();
}","public ViewerFrame(final Data data,final MessageManager messageManager,final RenderOptions renderOptions,final Configuration config){
  super(""String_Node_Str"");
  this.data=data;
  this.renderOptions=renderOptions;
  this.messageManager=messageManager;
  data.setConfig(config);
  createMenuBar();
  glCanvas=new ViewerGLCanvas(data,messageManager,renderOptions);
  add(glCanvas,BorderLayout.CENTER);
  new FileDrop(glCanvas,new FileDrop.Listener(){
    @Override public void filesDropped(    File[] files){
      if (files.length >= 1) {
        new OpenOSMAction(ViewerFrame.this,data,renderOptions).openOSMFile(files[0],true);
      }
    }
  }
);
  DefaultNavigation navigation=new DefaultNavigation(this,renderOptions);
  glCanvas.addMouseListener(navigation);
  glCanvas.addMouseMotionListener(navigation);
  glCanvas.addMouseWheelListener(navigation);
  glCanvas.addKeyListener(navigation);
  setDefaultCloseOperation(EXIT_ON_CLOSE);
  pack();
}",0.961169944528492
186343,"@Override public void display(GLAutoDrawable glDrawable){
  final GL2 gl=glDrawable.getGL().getGL2();
  JOGLTarget.clearGL(gl,Color.BLACK);
  if (renderOptions.camera != null) {
    DebugView activeWorldObjectView=null;
    for (    DebugView debugView : renderOptions.activeDebugViews) {
      if (debugView instanceof WorldObjectView) {
        activeWorldObjectView=debugView;
        continue;
      }
      debugView.renderTo(gl,renderOptions.camera,renderOptions.projection);
    }
    if (activeWorldObjectView != null) {
      activeWorldObjectView.renderTo(gl,renderOptions.camera,renderOptions.projection);
    }
    int messageCount=0;
    for (    Message message : messageManager.getLiveMessages()) {
      new JOGLTarget(gl,null,null).drawText(message.messageString,10,10 + messageCount * 20,ViewerGLCanvas.this.getWidth(),ViewerGLCanvas.this.getHeight(),Color.WHITE);
      messageCount++;
    }
    gl.glFlush();
  }
}","@Override public void display(GLAutoDrawable glDrawable){
  final GL2 gl=glDrawable.getGL().getGL2();
  JOGLTarget.clearGL(gl,Color.BLACK);
  helpView.renderTo(gl,null,null);
  if (renderOptions.camera != null) {
    DebugView activeWorldObjectView=null;
    for (    DebugView debugView : renderOptions.activeDebugViews) {
      if (debugView instanceof WorldObjectView) {
        activeWorldObjectView=debugView;
        continue;
      }
      debugView.renderTo(gl,renderOptions.camera,renderOptions.projection);
    }
    if (activeWorldObjectView != null) {
      activeWorldObjectView.renderTo(gl,renderOptions.camera,renderOptions.projection);
    }
    int messageCount=0;
    for (    Message message : messageManager.getLiveMessages()) {
      JOGLTarget.drawText(message.messageString,10,10 + messageCount * 20,ViewerGLCanvas.this.getWidth(),ViewerGLCanvas.this.getHeight(),Color.WHITE);
      messageCount++;
    }
    gl.glFlush();
  }
}",0.9718832891246684
186344,"@Override public void renderTo(GL2 gl,Camera camera,Projection projection){
  if (!canBeUsed()) {
    return;
  }
  JOGLTarget target=new JOGLTarget(gl,null,null);
  target.drawText(""String_Node_Str"" + ""String_Node_Str"",50,550,800,600,Color.LIGHT_GRAY);
  target.drawText(""String_Node_Str"" + GlobalValues.VERSION_STRING,50,100,800,600,Color.LIGHT_GRAY);
  target.drawText(""String_Node_Str"" + GlobalValues.OSM2WORLD_URI,50,75,800,600,Color.LIGHT_GRAY);
  target.drawText(""String_Node_Str"" + GlobalValues.WIKI_URI,50,50,800,600,Color.LIGHT_GRAY);
}","@Override public void renderTo(GL2 gl,Camera camera,Projection projection){
  if (!canBeUsed()) {
    return;
  }
  JOGLTarget.drawText(""String_Node_Str"" + ""String_Node_Str"",50,550,800,600,Color.LIGHT_GRAY);
  JOGLTarget.drawText(""String_Node_Str"" + GlobalValues.VERSION_STRING,50,100,800,600,Color.LIGHT_GRAY);
  JOGLTarget.drawText(""String_Node_Str"" + GlobalValues.OSM2WORLD_URI,50,75,800,600,Color.LIGHT_GRAY);
  JOGLTarget.drawText(""String_Node_Str"" + GlobalValues.WIKI_URI,50,50,800,600,Color.LIGHT_GRAY);
}",0.9395085066162572
186345,"/** 
 * Creates an   {@link ImageExporter} for later use.Also performs calculations that only need to be done once for a group of files, based on a  {@link CLIArgumentsGroup}.
 * @param expectedGroup  group that should contain at least the argumentsfor the files that will later be requested. Basis for optimization preparations.
 */
public ImageExporter(Configuration config,Results results,CLIArgumentsGroup expectedGroup){
  this.results=results;
  float[] clearColor={0f,0f,0f};
  if (config.containsKey(BG_COLOR_CONFIG_KEY)) {
    try {
      Color.decode(config.getString(BG_COLOR_CONFIG_KEY)).getColorComponents(clearColor);
    }
 catch (    NumberFormatException e) {
      System.err.println(""String_Node_Str"" + config.getString(BG_COLOR_CONFIG_KEY));
    }
  }
  int canvasLimit=config.getInt(CANVAS_LIMIT_CONFIG_KEY,DEFAULT_CANVAS_LIMIT);
  int expectedFileCalls=0;
  int expectedMaxSizeX=1;
  int expectedMaxSizeY=1;
  for (  CLIArguments args : expectedGroup.getCLIArgumentsList()) {
    for (    File outputFile : args.getOutput()) {
      OutputMode outputMode=CLIArgumentsUtil.getOutputMode(outputFile);
      if (outputMode == OutputMode.PNG || outputMode == OutputMode.PPM) {
        expectedFileCalls=1;
        expectedMaxSizeX=max(expectedMaxSizeX,args.getResolution().x);
        expectedMaxSizeY=max(expectedMaxSizeY,args.getResolution().y);
      }
    }
  }
  GLProfile profile=GLProfile.getDefault();
  GLDrawableFactory factory=GLDrawableFactory.getFactory(profile);
  if (!factory.canCreateGLPbuffer(null)) {
    throw new Error(""String_Node_Str"");
  }
  GLCapabilities cap=new GLCapabilities(profile);
  cap.setDoubleBuffered(false);
  pBufferSizeX=min(canvasLimit,expectedMaxSizeX);
  pBufferSizeY=min(canvasLimit,expectedMaxSizeY);
  pBuffer=factory.createGLPbuffer(null,cap,null,pBufferSizeX,pBufferSizeY,null);
  pBuffer.getContext().makeCurrent();
  gl=pBuffer.getGL().getGL2();
  gl.glFrontFace(GL_CCW);
  gl.glClearColor(clearColor[0],clearColor[1],clearColor[2],1.0f);
  gl.glEnable(GL_DEPTH_TEST);
  gl.glCullFace(GL_BACK);
  gl.glEnable(GL_CULL_FACE);
  gl.glLightfv(GL_LIGHT0,GL_AMBIENT,new float[]{1.0f,1.0f,1.0f,1.0f},0);
  gl.glLightfv(GL_LIGHT0,GL_DIFFUSE,new float[]{1.0f,1.0f,1.0f,1.0f},0);
  gl.glLightfv(GL_LIGHT0,GL_SPECULAR,new float[]{1.0f,1.0f,1.0f,1.0f},0);
  gl.glLightfv(GL_LIGHT0,GL_POSITION,new float[]{1.0f,1.5f,-(-1.0f),0.0f},0);
  gl.glEnable(GL_LIGHT0);
  gl.glEnable(GL_LIGHTING);
  gl.glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
  if (config.getBoolean(""String_Node_Str"",false) || (expectedFileCalls <= 1 && expectedMaxSizeX <= canvasLimit && expectedMaxSizeY <= canvasLimit)) {
    PrimitiveBuffer buffer=new PrimitiveBuffer();
    TargetUtil.renderWorldObjects(buffer,results.getMapData());
    TargetUtil.renderObject(buffer,results.getTerrain());
    bufferRenderer=new JOGLPrimitiveBufferRenderer(gl,buffer);
  }
 else {
    bufferRenderer=null;
  }
}","/** 
 * Creates an   {@link ImageExporter} for later use.Also performs calculations that only need to be done once for a group of files, based on a  {@link CLIArgumentsGroup}.
 * @param expectedGroup  group that should contain at least the argumentsfor the files that will later be requested. Basis for optimization preparations.
 */
public ImageExporter(Configuration config,Results results,CLIArgumentsGroup expectedGroup){
  this.results=results;
  float[] clearColor={0f,0f,0f};
  if (config.containsKey(BG_COLOR_CONFIG_KEY)) {
    try {
      Color.decode(config.getString(BG_COLOR_CONFIG_KEY)).getColorComponents(clearColor);
    }
 catch (    NumberFormatException e) {
      System.err.println(""String_Node_Str"" + config.getString(BG_COLOR_CONFIG_KEY));
    }
  }
  int canvasLimit=config.getInt(CANVAS_LIMIT_CONFIG_KEY,DEFAULT_CANVAS_LIMIT);
  int expectedFileCalls=0;
  int expectedMaxSizeX=1;
  int expectedMaxSizeY=1;
  for (  CLIArguments args : expectedGroup.getCLIArgumentsList()) {
    for (    File outputFile : args.getOutput()) {
      OutputMode outputMode=CLIArgumentsUtil.getOutputMode(outputFile);
      if (outputMode == OutputMode.PNG || outputMode == OutputMode.PPM) {
        expectedFileCalls=1;
        expectedMaxSizeX=max(expectedMaxSizeX,args.getResolution().x);
        expectedMaxSizeY=max(expectedMaxSizeY,args.getResolution().y);
      }
    }
  }
  GLProfile profile=GLProfile.getDefault();
  GLDrawableFactory factory=GLDrawableFactory.getFactory(profile);
  if (!factory.canCreateGLPbuffer(null)) {
    throw new Error(""String_Node_Str"");
  }
  GLCapabilities cap=new GLCapabilities(profile);
  cap.setDoubleBuffered(false);
  pBufferSizeX=min(canvasLimit,expectedMaxSizeX);
  pBufferSizeY=min(canvasLimit,expectedMaxSizeY);
  pBuffer=factory.createGLPbuffer(null,cap,null,pBufferSizeX,pBufferSizeY,null);
  pBuffer.getContext().makeCurrent();
  gl=pBuffer.getGL().getGL2();
  gl.glFrontFace(GL_CCW);
  gl.glClearColor(clearColor[0],clearColor[1],clearColor[2],1.0f);
  gl.glEnable(GL_DEPTH_TEST);
  gl.glCullFace(GL_BACK);
  gl.glEnable(GL_CULL_FACE);
  gl.glLightfv(GL_LIGHT0,GL_AMBIENT,new float[]{1.0f,1.0f,1.0f,1.0f},0);
  gl.glLightfv(GL_LIGHT0,GL_DIFFUSE,new float[]{1.0f,1.0f,1.0f,1.0f},0);
  gl.glLightfv(GL_LIGHT0,GL_SPECULAR,new float[]{1.0f,1.0f,1.0f,1.0f},0);
  gl.glLightfv(GL_LIGHT0,GL_POSITION,new float[]{1.0f,1.5f,-(-1.0f),0.0f},0);
  gl.glEnable(GL_LIGHT0);
  gl.glEnable(GL_LIGHTING);
  gl.glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
  boolean onlyOneRenderPass=(expectedFileCalls <= 1 && expectedMaxSizeX <= canvasLimit && expectedMaxSizeY <= canvasLimit);
  if (config.getBoolean(""String_Node_Str"",false) || onlyOneRenderPass) {
    bufferRenderer=null;
  }
 else {
    PrimitiveBuffer buffer=new PrimitiveBuffer();
    TargetUtil.renderWorldObjects(buffer,results.getMapData());
    TargetUtil.renderObject(buffer,results.getTerrain());
    bufferRenderer=new JOGLPrimitiveBufferRenderer(gl,buffer);
  }
}",0.9474757776644568
186346,"/** 
 * put the values for a primitive's vertices into the buffer
 */
private void addPrimitiveToValueBuffer(DoubleBuffer buffer,Primitive primitive){
  List<VectorXYZ> primVertices=new ArrayList<VectorXYZ>(primitive.indices.length);
  for (  int index : primitive.indices) {
    primVertices.add(primitiveBuffer.getVertex(index));
  }
  List<VectorXYZ> primNormals=primitive.normals;
  List<List<VectorXZ>> primTexCoordLists=primitive.texCoordLists;
  if (primitive.type == Type.TRIANGLE_STRIP) {
    primVertices=triangleVertexListFromTriangleStrip(primVertices);
    primNormals=triangleVertexListFromTriangleStrip(primNormals);
    if (primTexCoordLists != null) {
      List<List<VectorXZ>> newPrimTexCoordLists=new ArrayList<List<VectorXZ>>();
      for (      List<VectorXZ> primTexCoordList : primTexCoordLists) {
        newPrimTexCoordLists.add(triangleVertexListFromTriangleStrip(primTexCoordList));
      }
      primTexCoordLists=newPrimTexCoordLists;
    }
  }
 else   if (primitive.type == Type.TRIANGLE_FAN) {
    primVertices=triangleVertexListFromTriangleFan(primVertices);
    primNormals=triangleVertexListFromTriangleFan(primNormals);
    if (primTexCoordLists != null) {
      List<List<VectorXZ>> newPrimTexCoordLists=new ArrayList<List<VectorXZ>>();
      for (      List<VectorXZ> primTexCoordList : primTexCoordLists) {
        newPrimTexCoordLists.add(triangleVertexListFromTriangleFan(primTexCoordList));
      }
      primTexCoordLists=newPrimTexCoordLists;
    }
  }
  for (int i=0; i < primVertices.size(); i++) {
    if (primTexCoordLists == null && material.getNumTextureLayers() > 0) {
      System.out.println(material);
    }
    for (int t=0; t < material.getNumTextureLayers(); t++) {
      VectorXZ textureCoord=primTexCoordLists.get(t).get(i);
      buffer.put(textureCoord.x);
      buffer.put(textureCoord.z);
    }
    VectorXYZ n=primNormals.get(i);
    buffer.put(n.x);
    buffer.put(n.y);
    buffer.put(-n.z);
    VectorXYZ v=primVertices.get(i);
    buffer.put(v.x);
    buffer.put(v.y);
    buffer.put(-v.z);
  }
}","/** 
 * put the values for a primitive's vertices into the buffer
 */
private void addPrimitiveToValueBuffer(DoubleBuffer buffer,Primitive primitive){
}",0.1371841155234657
186347,"private void renderStepsTo(Target<?> target){
  WaySegmentElevationProfile elevationProfile=line.getElevationProfile();
  final VectorXZ startWithOffset=getStartPosition();
  final VectorXZ endWithOffset=getEndPosition();
  List<VectorXYZ> leftOutline=getOutline(false);
  List<VectorXYZ> rightOutline=getOutline(true);
  double lineLength=VectorXZ.distance(line.getStartNode().getPos(),line.getEndNode().getPos());
  List<VectorXYZ> vs=createTriangleStripBetween(leftOutline,rightOutline);
  target.drawTriangleStrip(ASPHALT,vs,null);
  float stepLength=0.3f;
  if (tags.containsKey(""String_Node_Str"")) {
    try {
      int stepCount=Integer.parseInt(tags.getValue(""String_Node_Str""));
      stepLength=(float)lineLength / stepCount;
    }
 catch (    NumberFormatException e) {
    }
  }
  List<VectorXZ> stepBorderPositionsXZ=GeometryUtil.equallyDistributePointsAlong(stepLength,true,startWithOffset,endWithOffset);
  List<VectorXYZ> stepBorderPositions=new ArrayList<VectorXYZ>();
  for (  VectorXZ posXZ : stepBorderPositionsXZ) {
    VectorXYZ posXYZ=posXZ.xyz(elevationProfile.getEleAt(posXZ));
    stepBorderPositions.add(posXYZ);
  }
  for (int step=0; step < stepBorderPositions.size() - 1; step++) {
    VectorXYZ frontCenter=stepBorderPositions.get(step);
    VectorXYZ backCenter=stepBorderPositions.get(step + 1);
    double height=abs(frontCenter.y - backCenter.y);
    VectorXYZ center=(frontCenter.add(backCenter)).mult(0.5);
    center=center.subtract(Y_UNIT.mult(0.5 * height));
    VectorXZ faceDirection=line.getDirection();
    if (frontCenter.y < backCenter.y) {
      faceDirection=faceDirection.invert();
    }
    target.drawBox(Materials.STEPS_DEFAULT,center,faceDirection,height,width,backCenter.distanceToXZ(frontCenter));
  }
  List<List<VectorXYZ>> handrailFootprints=new ArrayList<List<VectorXYZ>>();
  if (line.getTags().contains(""String_Node_Str"",""String_Node_Str"")) {
    handrailFootprints.add(leftOutline);
  }
  if (line.getTags().contains(""String_Node_Str"",""String_Node_Str"")) {
    handrailFootprints.add(rightOutline);
  }
  int centerHandrails=0;
  if (line.getTags().contains(""String_Node_Str"",""String_Node_Str"")) {
    centerHandrails=1;
  }
 else   if (line.getTags().containsKey(""String_Node_Str"")) {
    try {
      centerHandrails=Integer.parseInt(line.getTags().getValue(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
  }
  for (int i=0; i < centerHandrails; i++) {
    handrailFootprints.add(createLineBetween(leftOutline,rightOutline,(i + 1.0f) / (centerHandrails + 1)));
  }
  for (  List<VectorXYZ> handrailFootprint : handrailFootprints) {
    List<VectorXYZ> handrailLine=new ArrayList<VectorXYZ>();
    for (    VectorXYZ v : handrailFootprint) {
      handrailLine.add(v.y(v.y + 1));
    }
    List<List<VectorXYZ>> strips=createShapeExtrusionAlong(HANDRAIL_SHAPE,handrailLine,Collections.nCopies(handrailLine.size(),VectorXYZ.Y_UNIT));
    for (    List<VectorXYZ> strip : strips) {
      target.drawTriangleStrip(HANDRAIL_DEFAULT,strip,null);
    }
    target.drawColumn(HANDRAIL_DEFAULT,4,handrailFootprint.get(0),1,0.03,0.03,false,true);
    target.drawColumn(HANDRAIL_DEFAULT,4,handrailFootprint.get(handrailFootprint.size() - 1),1,0.03,0.03,false,true);
  }
}","private void renderStepsTo(Target<?> target){
  WaySegmentElevationProfile elevationProfile=line.getElevationProfile();
  final VectorXZ startWithOffset=getStartPosition();
  final VectorXZ endWithOffset=getEndPosition();
  List<VectorXYZ> leftOutline=getOutline(false);
  List<VectorXYZ> rightOutline=getOutline(true);
  double lineLength=VectorXZ.distance(line.getStartNode().getPos(),line.getEndNode().getPos());
  List<VectorXYZ> vs=createTriangleStripBetween(leftOutline,rightOutline);
  target.drawTriangleStrip(ASPHALT,vs,globalTexCoordLists(vs,ASPHALT,false));
  float stepLength=0.3f;
  if (tags.containsKey(""String_Node_Str"")) {
    try {
      int stepCount=Integer.parseInt(tags.getValue(""String_Node_Str""));
      stepLength=(float)lineLength / stepCount;
    }
 catch (    NumberFormatException e) {
    }
  }
  List<VectorXZ> stepBorderPositionsXZ=GeometryUtil.equallyDistributePointsAlong(stepLength,true,startWithOffset,endWithOffset);
  List<VectorXYZ> stepBorderPositions=new ArrayList<VectorXYZ>();
  for (  VectorXZ posXZ : stepBorderPositionsXZ) {
    VectorXYZ posXYZ=posXZ.xyz(elevationProfile.getEleAt(posXZ));
    stepBorderPositions.add(posXYZ);
  }
  for (int step=0; step < stepBorderPositions.size() - 1; step++) {
    VectorXYZ frontCenter=stepBorderPositions.get(step);
    VectorXYZ backCenter=stepBorderPositions.get(step + 1);
    double height=abs(frontCenter.y - backCenter.y);
    VectorXYZ center=(frontCenter.add(backCenter)).mult(0.5);
    center=center.subtract(Y_UNIT.mult(0.5 * height));
    VectorXZ faceDirection=line.getDirection();
    if (frontCenter.y < backCenter.y) {
      faceDirection=faceDirection.invert();
    }
    target.drawBox(Materials.STEPS_DEFAULT,center,faceDirection,height,width,backCenter.distanceToXZ(frontCenter));
  }
  List<List<VectorXYZ>> handrailFootprints=new ArrayList<List<VectorXYZ>>();
  if (line.getTags().contains(""String_Node_Str"",""String_Node_Str"")) {
    handrailFootprints.add(leftOutline);
  }
  if (line.getTags().contains(""String_Node_Str"",""String_Node_Str"")) {
    handrailFootprints.add(rightOutline);
  }
  int centerHandrails=0;
  if (line.getTags().contains(""String_Node_Str"",""String_Node_Str"")) {
    centerHandrails=1;
  }
 else   if (line.getTags().containsKey(""String_Node_Str"")) {
    try {
      centerHandrails=Integer.parseInt(line.getTags().getValue(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
  }
  for (int i=0; i < centerHandrails; i++) {
    handrailFootprints.add(createLineBetween(leftOutline,rightOutline,(i + 1.0f) / (centerHandrails + 1)));
  }
  for (  List<VectorXYZ> handrailFootprint : handrailFootprints) {
    List<VectorXYZ> handrailLine=new ArrayList<VectorXYZ>();
    for (    VectorXYZ v : handrailFootprint) {
      handrailLine.add(v.y(v.y + 1));
    }
    List<List<VectorXYZ>> strips=createShapeExtrusionAlong(HANDRAIL_SHAPE,handrailLine,Collections.nCopies(handrailLine.size(),VectorXYZ.Y_UNIT));
    for (    List<VectorXYZ> strip : strips) {
      target.drawTriangleStrip(HANDRAIL_DEFAULT,strip,wallTexCoordLists(strip,HANDRAIL_DEFAULT));
    }
    target.drawColumn(HANDRAIL_DEFAULT,4,handrailFootprint.get(0),1,0.03,0.03,false,true);
    target.drawColumn(HANDRAIL_DEFAULT,4,handrailFootprint.get(handrailFootprint.size() - 1),1,0.03,0.03,false,true);
  }
}",0.954005482790131
186348,"@Override public void renderTo(Target<?> target){
  target.drawTriangles(WATER,getTriangulation(),globalTexCoordLists(getTriangulation(),WATER,false));
  double width=0.1;
  double height=0.5;
  List<VectorXYZ> wallShape=asList(new VectorXYZ(-width / 2,0,0),new VectorXYZ(-width / 2,height,0),new VectorXYZ(+width / 2,height,0),new VectorXYZ(+width / 2,0,0));
  List<VectorXYZ> path=area.getElevationProfile().getWithEle(area.getOuterPolygon().getVertexLoop());
  List<List<VectorXYZ>> strips=createShapeExtrusionAlong(wallShape,path,nCopies(path.size(),VectorXYZ.Y_UNIT));
  for (  List<VectorXYZ> strip : strips) {
    target.drawTriangleStrip(Materials.ASPHALT,strip,null);
  }
}","@Override public void renderTo(Target<?> target){
  target.drawTriangles(WATER,getTriangulation(),globalTexCoordLists(getTriangulation(),WATER,false));
  double width=0.1;
  double height=0.5;
  List<VectorXYZ> wallShape=asList(new VectorXYZ(-width / 2,0,0),new VectorXYZ(-width / 2,height,0),new VectorXYZ(+width / 2,height,0),new VectorXYZ(+width / 2,0,0));
  List<VectorXYZ> path=area.getElevationProfile().getWithEle(area.getOuterPolygon().getVertexLoop());
  List<List<VectorXYZ>> strips=createShapeExtrusionAlong(wallShape,path,nCopies(path.size(),VectorXYZ.Y_UNIT));
  for (  List<VectorXYZ> strip : strips) {
    target.drawTriangleStrip(Materials.CONCRETE,strip,wallTexCoordLists(strip,Materials.CONCRETE));
  }
}",0.945868945868946
186349,"/** 
 * creates an IntersectionGrid with all terrain cells and boundaries
 */
private IntersectionGrid prepareSpeedupGrid(MapData mapData,CellularTerrainElevation eleData){
  final IntersectionGrid speedupGrid=new IntersectionGrid(mapData.getDataBoundary().pad(20),50,50);
  for (  TerrainElevationCell cell : eleData.getCells()) {
    speedupGrid.insert(cell);
  }
  iterate(mapData.getWorldObjects(IntersectionTestObject.class),new Operation<IntersectionTestObject>(){
    @Override public void perform(    IntersectionTestObject object){
      if (((WorldObject)object).getGroundState() == GroundState.ON) {
        speedupGrid.insert(object);
      }
    }
  }
);
  return speedupGrid;
}","/** 
 * creates an IntersectionGrid with all terrain cells and boundaries
 */
private IntersectionGrid prepareSpeedupGrid(MapData mapData,CellularTerrainElevation eleData){
  AxisAlignedBoundingBoxXZ speedupGridBounds=union(mapData.getDataBoundary(),new AxisAlignedBoundingBoxXZ(eleData.getBoundaryPolygonXZ().getVertexCollection()));
  final IntersectionGrid speedupGrid=new IntersectionGrid(speedupGridBounds.pad(20),50,50);
  for (  TerrainElevationCell cell : eleData.getCells()) {
    speedupGrid.insert(cell);
  }
  iterate(mapData.getWorldObjects(IntersectionTestObject.class),new Operation<IntersectionTestObject>(){
    @Override public void perform(    IntersectionTestObject object){
      if (((WorldObject)object).getGroundState() == GroundState.ON) {
        speedupGrid.insert(object);
      }
    }
  }
);
  return speedupGrid;
}",0.8736979166666666
186350,"/** 
 * adds the overlap between two   {@link MapArea}s to both, if it exists
 */
private static void addOverlapBetween(MapArea area1,MapArea area2){
  for (  MapAreaSegment area1Segment : area1.getAreaSegments()) {
    for (    MapAreaSegment area2Segment : area2.getAreaSegments()) {
      if (area1Segment.sharesBothNodes(area2Segment)) {
        MapOverlapAA newOverlap=new MapOverlapAA(area1,area2,MapOverlapType.SHARE_SEGMENT);
        area1.addOverlap(newOverlap);
        area2.addOverlap(newOverlap);
        return;
      }
    }
  }
  boolean contains;
  boolean intersects;
{
    final PolygonWithHolesXZ polygon1=area1.getPolygon();
    final PolygonWithHolesXZ polygon2=area2.getPolygon();
    Set<VectorXZ> commonNodes=new HashSet<VectorXZ>();
    for (    SimplePolygonXZ p : polygon1.getPolygons()) {
      commonNodes.addAll(p.getVertices());
    }
    Set<VectorXZ> nodes2=new HashSet<VectorXZ>();
    for (    SimplePolygonXZ p : polygon2.getPolygons()) {
      nodes2.addAll(p.getVertices());
    }
    commonNodes.retainAll(nodes2);
    intersects=false;
    intersectionPosCheck:     for (    VectorXZ pos : polygon1.intersectionPositions(polygon2)) {
      for (      VectorXZ commonNode : commonNodes) {
        if (distance(pos,commonNode) > 0.01) {
          intersects=true;
          break intersectionPosCheck;
        }
      }
    }
    contains=polygon1.contains(polygon2.getOuter()) || polygon2.contains(polygon2.getOuter());
  }
  if (contains || intersects) {
    MapOverlapAA newOverlap=new MapOverlapAA(area1,area2,intersects ? MapOverlapType.INTERSECT : MapOverlapType.CONTAIN);
    area1.addOverlap(newOverlap);
    area2.addOverlap(newOverlap);
  }
}","/** 
 * adds the overlap between two   {@link MapArea}s to both, if it exists
 */
private static void addOverlapBetween(MapArea area1,MapArea area2){
  for (  MapAreaSegment area1Segment : area1.getAreaSegments()) {
    for (    MapAreaSegment area2Segment : area2.getAreaSegments()) {
      if (area1Segment.sharesBothNodes(area2Segment)) {
        MapOverlapAA newOverlap=new MapOverlapAA(area1,area2,MapOverlapType.SHARE_SEGMENT);
        area1.addOverlap(newOverlap);
        area2.addOverlap(newOverlap);
        return;
      }
    }
  }
  boolean contains;
  boolean intersects;
{
    final PolygonWithHolesXZ polygon1=area1.getPolygon();
    final PolygonWithHolesXZ polygon2=area2.getPolygon();
    Set<VectorXZ> commonNodes=new HashSet<VectorXZ>();
    for (    SimplePolygonXZ p : polygon1.getPolygons()) {
      commonNodes.addAll(p.getVertices());
    }
    Set<VectorXZ> nodes2=new HashSet<VectorXZ>();
    for (    SimplePolygonXZ p : polygon2.getPolygons()) {
      nodes2.addAll(p.getVertices());
    }
    commonNodes.retainAll(nodes2);
    intersects=false;
    intersectionPosCheck:     for (    VectorXZ pos : polygon1.intersectionPositions(polygon2)) {
      boolean trueIntersection=true;
      for (      VectorXZ commonNode : commonNodes) {
        if (distance(pos,commonNode) < 0.01) {
          trueIntersection=false;
        }
      }
      if (trueIntersection) {
        intersects=true;
        break intersectionPosCheck;
      }
    }
    contains=polygon1.contains(polygon2.getOuter()) || polygon2.contains(polygon2.getOuter());
  }
  if (contains || intersects) {
    MapOverlapAA newOverlap=new MapOverlapAA(area1,area2,intersects ? MapOverlapType.INTERSECT : MapOverlapType.CONTAIN);
    area1.addOverlap(newOverlap);
    area2.addOverlap(newOverlap);
  }
}",0.9555491826785202
186351,"/** 
 * returns a sequence of node running along the center of the line from start to end (each with offset). Uses the   {@link WaySegmentElevationProfile} for addingelevation information.
 */
public List<VectorXYZ> getCenterline(){
  WaySegmentElevationProfile eleProfile=line.getElevationProfile();
  if (startOffset == VectorXZ.NULL_VECTOR && endOffset == VectorXZ.NULL_VECTOR) {
    return eleProfile.getPointsWithEle();
  }
 else {
    List<VectorXYZ> centerline=new ArrayList<VectorXYZ>();
    VectorXZ startWithOffset=getStartWithOffset();
    VectorXZ endWithOffset=getEndWithOffset();
    if (startOffset != VectorXZ.NULL_VECTOR) {
      centerline.add(startWithOffset.xyz(eleProfile.getEleAt(startWithOffset)));
    }
    for (    VectorXYZ p : eleProfile.getPointsWithEle()) {
      VectorXZ pXZ=p.xz();
      if (isBetween(pXZ,startWithOffset,endWithOffset) && distanceSquared(pXZ,startWithOffset) > 0.1 && distanceSquared(pXZ,endWithOffset) > 0.1) {
        centerline.add(p);
      }
    }
    if (endOffset != VectorXZ.NULL_VECTOR) {
      centerline.add(endWithOffset.xyz(eleProfile.getEleAt(endWithOffset)));
    }
    return centerline;
  }
}","/** 
 * returns a sequence of node running along the center of the line from start to end (each with offset). Uses the   {@link WaySegmentElevationProfile} for addingelevation information.
 */
public List<VectorXYZ> getCenterline(){
  WaySegmentElevationProfile eleProfile=line.getElevationProfile();
  if (startOffset == VectorXZ.NULL_VECTOR && endOffset == VectorXZ.NULL_VECTOR) {
    return eleProfile.getPointsWithEle();
  }
 else {
    List<VectorXYZ> centerline=new ArrayList<VectorXYZ>();
    VectorXZ startWithOffset=getStartWithOffset();
    VectorXZ endWithOffset=getEndWithOffset();
    centerline.add(startWithOffset.xyz(eleProfile.getEleAt(startWithOffset)));
    for (int i=1; i < eleProfile.getPointsWithEle().size() - 1; ++i) {
      VectorXYZ p=eleProfile.getPointsWithEle().get(i);
      VectorXZ pXZ=p.xz();
      if (isBetween(pXZ,startWithOffset,endWithOffset) && distanceSquared(pXZ,startWithOffset) > 0.1 && distanceSquared(pXZ,endWithOffset) > 0.1) {
        centerline.add(p);
      }
    }
    centerline.add(endWithOffset.xyz(eleProfile.getEleAt(endWithOffset)));
    return centerline;
  }
}",0.895129442738043
186352,"/** 
 * provides the left or right border (a line at an appropriate distance from the center line), taking into account cut vectors, offsets and elevation information.  Available after cut vectors, offsets and elevation information have been calculated. Left and right border have the same number of nodes as the elevation profile's   {@link WaySegmentElevationProfile#getPointsWithEle()}. //TODO: compatible with future offset/clearing influences?
 */
public List<VectorXYZ> getOutline(boolean right){
  if (right) {
    if (rightOutline == null) {
      calculateOutlines();
    }
    return rightOutline;
  }
 else {
    if (leftOutline == null) {
      calculateOutlines();
    }
    return leftOutline;
  }
}","/** 
 * provides the left or right border (a line at an appropriate distance from the center line), taking into account cut vectors, offsets and elevation information. Available after cut vectors, offsets and elevation information have been calculated. Left and right border have the same number of nodes as the elevation profile's   {@link WaySegmentElevationProfile#getPointsWithEle()}. //TODO: compatible with future offset/clearing influences?
 */
public List<VectorXYZ> getOutline(boolean right){
  if (right) {
    if (rightOutline == null) {
      calculateOutlines();
    }
    return rightOutline;
  }
 else {
    if (leftOutline == null) {
      calculateOutlines();
    }
    return leftOutline;
  }
}",0.9992982456140352
186353,"/** 
 * create forces between all nodes depending on their position in the base terrain grid: <ul> <li> connect each TerrainPoint to its up to 4 grid neighbors <li> distribute other nodes to grid cells (quadrangle created by 4 TerrainPoints) and connect them with other nodes from the same cell as well as the corner TerrainPoints </ul>
 */
private void addNeighborshipForces(){
  final IntersectionGrid speedupGrid=new IntersectionGrid(new AxisAlignedBoundingBoxXZ(eleData.getBoundaryPolygonXZ().getVertices()).pad(20),50,50);
  for (  TerrainElevationCell cell : eleData.getCells()) {
    speedupGrid.insert(cell);
  }
  for (  Multimap<? extends MapElement,ForceNode> map : asList(lineMap,areaMap)) {
    for (    MapElement segment : map.keySet()) {
      if (segment.getPrimaryRepresentation() != null && segment.getPrimaryRepresentation().getGroundState() == GroundState.ON) {
        for (        ForceNode fNode : ((Multimap<Object,ForceNode>)map).get(segment)) {
          speedupGrid.insert(fNode);
        }
      }
    }
  }
  for (  MapNode node : nodeMap.keySet()) {
    if (node.getPrimaryRepresentation() != null && node.getPrimaryRepresentation().getGroundState() == GroundState.ON) {
      ForceNode fNode=nodeMap.get(node);
      speedupGrid.insert(fNode);
    }
  }
  for (  TerrainElevationCell cell : eleData.getCells()) {
    forces.add(new NeighborshipForce(terrainPointMap.get(cell.getTopLeft()),terrainPointMap.get(cell.getBottomLeft())));
    forces.add(new NeighborshipForce(terrainPointMap.get(cell.getTopLeft()),terrainPointMap.get(cell.getTopRight())));
    Set<ForceNode> forceNodesInCell=new HashSet<ForceNode>();
    Iterable<IntersectionTestObject> potentialNodes=Iterables.concat(speedupGrid.cellsFor(cell));
    for (    IntersectionTestObject potentialNode : potentialNodes) {
      if (potentialNode instanceof ForceNode) {
        ForceNode node=(ForceNode)potentialNode;
        if (cell.getPolygonXZ().contains(node.getPos())) {
          forceNodesInCell.add(node);
        }
      }
    }
    for (    final ForceNode fNode : forceNodesInCell) {
      TerrainPoint closestTerrainPoint=MinUtil.min(cell.getTerrainPoints(),new Function<TerrainPoint,Double>(){
        @Override public Double apply(        TerrainPoint p){
          return VectorXZ.distance(fNode.getPos(),p.getPos());
        }
      }
);
      forces.add(new NeighborshipForce(fNode,terrainPointMap.get(closestTerrainPoint)));
    }
  }
}","/** 
 * create forces between all nodes depending on their position in the base terrain grid: <ul> <li> connect each TerrainPoint to its up to 4 grid neighbors <li> distribute other nodes to grid cells (quadrangle created by 4 TerrainPoints) and connect them with other nodes from the same cell as well as the corner TerrainPoints </ul>
 */
private void addNeighborshipForces(){
  final IntersectionGrid speedupGrid=new IntersectionGrid(new AxisAlignedBoundingBoxXZ(eleData.getBoundaryPolygonXZ().getVertices()).pad(20),50,50);
  for (  TerrainElevationCell cell : eleData.getCells()) {
    speedupGrid.insert(cell);
  }
  for (  MapWaySegment segment : lineMap.keySet()) {
    if (segment.getPrimaryRepresentation() != null && segment.getPrimaryRepresentation().getGroundState() == GroundState.ON) {
      for (      ForceNode fNode : lineMap.get(segment)) {
        speedupGrid.insert(fNode);
      }
    }
  }
  for (  MapArea area : areaMap.keySet()) {
    if (area.getPrimaryRepresentation() != null && area.getPrimaryRepresentation().getGroundState() == GroundState.ON) {
      for (      ForceNode fNode : areaMap.get(area)) {
        speedupGrid.insert(fNode);
      }
    }
  }
  for (  MapNode node : nodeMap.keySet()) {
    if (node.getPrimaryRepresentation() != null && node.getPrimaryRepresentation().getGroundState() == GroundState.ON) {
      ForceNode fNode=nodeMap.get(node);
      speedupGrid.insert(fNode);
    }
  }
  for (  TerrainElevationCell cell : eleData.getCells()) {
    forces.add(new NeighborshipForce(terrainPointMap.get(cell.getTopLeft()),terrainPointMap.get(cell.getBottomLeft())));
    forces.add(new NeighborshipForce(terrainPointMap.get(cell.getTopLeft()),terrainPointMap.get(cell.getTopRight())));
    Set<ForceNode> forceNodesInCell=new HashSet<ForceNode>();
    Iterable<IntersectionTestObject> potentialNodes=Iterables.concat(speedupGrid.cellsFor(cell));
    for (    IntersectionTestObject potentialNode : potentialNodes) {
      if (potentialNode instanceof ForceNode) {
        ForceNode node=(ForceNode)potentialNode;
        if (cell.getPolygonXZ().contains(node.getPos())) {
          forceNodesInCell.add(node);
        }
      }
    }
    for (    final ForceNode fNode : forceNodesInCell) {
      TerrainPoint closestTerrainPoint=MinUtil.min(cell.getTerrainPoints(),new Function<TerrainPoint,Double>(){
        @Override public Double apply(        TerrainPoint p){
          return VectorXZ.distance(fNode.getPos(),p.getPos());
        }
      }
);
      forces.add(new NeighborshipForce(fNode,terrainPointMap.get(closestTerrainPoint)));
    }
  }
}",0.5974643423137876
186354,"public void visitMethodInsn(int opcode,String owner,String name,String desc){
  SrgFile.MethodInfo smi=main.srg.getMethod(owner,name,desc);
  String seargeName=smi.name;
  desc=main.deobfMethodDescriptor(desc);
  String deobfName=main.methods.get(seargeName);
  if (deobfName == null)   deobfName=seargeName;
  owner=main.srg.getClassName(owner);
  super.visitMethodInsn(opcode,owner,deobfName,desc);
}","public void visitMethodInsn(int opcode,String owner,String name,String desc){
  String seargeName=main.lookupInheritedMethod(owner,name,desc);
  desc=main.deobfMethodDescriptor(desc);
  String deobfName=main.methods.get(seargeName);
  if (deobfName == null)   deobfName=seargeName;
  owner=main.srg.getClassName(owner);
  super.visitMethodInsn(opcode,owner,deobfName,desc);
}",0.3166023166023166
186355,"public void visitLdcInsn(Object cst){
  if (cst instanceof Type) {
    String desc=((Type)cst).getDescriptor();
    if (desc.charAt(0) == 'L' && desc.charAt(desc.length() - 1) == ';')     cst=Type.getType(""String_Node_Str"" + main.srg.getClassName(desc.substring(1,desc.length() - 1)) + ""String_Node_Str"");
  }
  super.visitLdcInsn(cst);
}","public void visitLdcInsn(Object cst){
  if (cst instanceof Type) {
    cst=Type.getType(main.deobfTypeDescriptor(((Type)cst).getDescriptor()));
  }
  super.visitLdcInsn(cst);
}",0.5486381322957199
186356,"public void visitTypeInsn(int opcode,String type){
  super.visitTypeInsn(opcode,main.srg.getClassName(type));
}","public void visitTypeInsn(int opcode,String type){
  String deobf=type.charAt(0) == '[' ? main.deobfTypeDescriptor(type) : main.srg.getClassName(type);
  super.visitTypeInsn(opcode,deobf);
}",0.5647840531561462
186357,"public void visitFieldInsn(int opcode,String owner,String name,String desc){
  String deobfOwner=main.srg.getClassName(owner);
  String seargeName=main.srg.getFieldName(owner,name);
  String deobfName=main.fields.get(seargeName);
  String deobfDesc=main.deobfTypeDescriptor(desc);
  super.visitFieldInsn(opcode,deobfOwner,deobfName,deobfDesc);
}","public void visitFieldInsn(int opcode,String owner,String name,String desc){
  String deobfOwner=main.srg.getClassName(owner);
  String seargeName=main.lookupInheritedField(owner,name);
  String deobfName=main.fields.get(seargeName);
  String deobfDesc=main.deobfTypeDescriptor(desc);
  super.visitFieldInsn(opcode,deobfOwner,deobfName,deobfDesc);
}",0.962536023054755
186358,"@Override public FieldVisitor visitField(int access,String name,String desc,String signature,Object value){
  String seargeName=main.srg.getFieldName(obfname,name);
  String deobfName=main.fields.get(seargeName);
  return super.visitField(access,deobfName,main.deobfTypeDescriptor(desc),signature,value);
}","@Override public FieldVisitor visitField(int access,String name,String desc,String signature,Object value){
  String seargeName=main.srg.getFieldName(obfname,name);
  String deobfName=seargeName == null ? name : main.fields.get(seargeName);
  return super.visitField(access,deobfName,main.deobfTypeDescriptor(desc),signature,value);
}",0.95625
186359,"@Override public MethodVisitor visitMethod(int access,String name,String desc,String signature,String[] exceptions){
  SrgFile.MethodInfo smi=main.srg.getMethod(obfname,name,desc);
  String deobfName=main.methods.get(smi.name);
  desc=main.deobfMethodDescriptor(desc);
  if (exceptions == null)   exceptions=new String[0];
  String[] addExceptions=main.exc.getExceptionClasses(obfname,name,desc);
  List<String> newExceptions=new LinkedList<String>(Arrays.asList(exceptions));
  newExceptions.addAll(Arrays.asList(addExceptions));
  return new DeobfuscateMethodVisitor(super.visitMethod(access,deobfName,desc,signature,(String[])newExceptions.toArray(new String[newExceptions.size()])),main);
}","@Override public MethodVisitor visitMethod(int access,String name,String desc,String signature,String[] exceptions){
  String seargeName=main.lookupInheritedMethod(obfname,name,desc);
  String deobfName=main.methods.get(seargeName);
  desc=main.deobfMethodDescriptor(desc);
  if (exceptions == null)   exceptions=new String[0];
  String[] addExceptions=main.exc.getExceptionClasses(obfname,name,desc);
  List<String> newExceptions=new LinkedList<String>(Arrays.asList(exceptions));
  newExceptions.addAll(Arrays.asList(addExceptions));
  return new DeobfuscateMethodVisitor(super.visitMethod(access,deobfName,desc,signature,(String[])newExceptions.toArray(new String[newExceptions.size()])),main);
}",0.9461593682699212
186360,"public void run() throws IOException {
  ZipInputStream inZip=new ZipInputStream(new FileInputStream(input));
  ZipOutputStream outZip=new ZipOutputStream(new FileOutputStream(output));
  while (true) {
    ZipEntry inEntry=inZip.getNextEntry();
    if (inEntry == null)     break;
    if (!inEntry.getName().endsWith(""String_Node_Str"")) {
      ZipEntry outEntry=new ZipEntry(inEntry.getName());
      outZip.putNextEntry(outEntry);
      byte[] buf=new byte[1048576];
      int len=0;
      do {
        len=inZip.read(buf);
        if (len > 0)         outZip.write(buf,0,len);
      }
 while (len > 0);
      inZip.closeEntry();
      outZip.closeEntry();
      continue;
    }
    String oldName=fileToClass(inEntry.getName());
    String newName=srg.getClassName(oldName);
    System.out.println(oldName + ""String_Node_Str"" + newName);
    try {
      ClassReader cr=new ClassReader(inZip);
      inZip.closeEntry();
      ClassWriter cw=new ClassWriter(ClassWriter.COMPUTE_MAXS);
      cr.accept(new DeobfuscateVisitor(cw,this),0);
      ZipEntry outEntry=new ZipEntry(classToFile(newName));
      outZip.putNextEntry(outEntry);
      outZip.write(cw.toByteArray());
      outZip.closeEntry();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + oldName + ""String_Node_Str""+ newName);
      throw new RuntimeException(e);
    }
  }
  inZip.close();
  outZip.close();
}","public void run() throws IOException {
  ZipInputStream inZip;
  ZipOutputStream outZip=new ZipOutputStream(new FileOutputStream(output));
  for (  String xpath : xpathlist)   getParents(new File(xpath));
  getParents(input);
  inZip=new ZipInputStream(new FileInputStream(input));
  while (true) {
    ZipEntry inEntry=inZip.getNextEntry();
    if (inEntry == null)     break;
    if (!inEntry.getName().endsWith(""String_Node_Str"")) {
      ZipEntry outEntry=new ZipEntry(inEntry.getName());
      outZip.putNextEntry(outEntry);
      byte[] buf=new byte[1048576];
      int len=0;
      do {
        len=inZip.read(buf);
        if (len > 0)         outZip.write(buf,0,len);
      }
 while (len > 0);
      inZip.closeEntry();
      outZip.closeEntry();
      continue;
    }
    String oldName=fileToClass(inEntry.getName());
    String newName=srg.getClassName(oldName);
    try {
      ClassReader cr=new ClassReader(inZip);
      ClassWriter cw=new ClassWriter(ClassWriter.COMPUTE_MAXS);
      cr.accept(new DeobfuscateVisitor(cw,this),0);
      inZip.closeEntry();
      ZipEntry outEntry=new ZipEntry(classToFile(newName));
      outZip.putNextEntry(outEntry);
      outZip.write(cw.toByteArray());
      outZip.closeEntry();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + oldName + ""String_Node_Str""+ newName);
      throw new RuntimeException(e);
    }
  }
  inZip.close();
  outZip.close();
}",0.8402116402116402
186361,"public static void main(String[] args) throws Exception {
  if (args.length == 1 && args[0].equals(""String_Node_Str"")) {
    Main m=new Main();
    m.base=new File(MCP_BASE);
    m.input=new File(""String_Node_Str"");
    m.output=new File(""String_Node_Str"");
    m.exc=new ExcFile(new File(m.base,""String_Node_Str""));
    m.srg=new SrgFile(new File(m.base,""String_Node_Str""));
    m.fields=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.methods=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.run();
  }
 else {
    if (args.length != 8 || (!args[7].equals(""String_Node_Str"") && !args[7].equals(""String_Node_Str""))) {
      System.err.println(""String_Node_Str"");
      return;
    }
    boolean reob=args[7].equals(""String_Node_Str"");
    if (reob)     System.err.println(""String_Node_Str"");
    int side=Integer.parseInt(args[6]);
    Main m=new Main();
    m.base=new File(""String_Node_Str"");
    m.input=new File(args[0]);
    m.output=new File(args[1]);
    m.exc=new ExcFile(new File(args[2]));
    m.srg=new SrgFile(new File(args[3]));
    m.fields=new CsvFile(new File(args[4]),side,reob);
    m.methods=new CsvFile(new File(args[5]),side,reob);
    m.run();
  }
}","public static void main(String[] args) throws Exception {
  if (args.length == 1 && args[0].equals(""String_Node_Str"")) {
    Main m=new Main();
    m.base=new File(MCP_BASE);
    m.input=new File(""String_Node_Str"");
    m.output=new File(""String_Node_Str"");
    m.exc=new ExcFile(new File(m.base,""String_Node_Str""));
    m.srg=new SrgFile(new File(m.base,""String_Node_Str""),m);
    m.fields=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.methods=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.xpathlist=new String[]{""String_Node_Str""};
    m.run();
  }
 else {
    if ((args.length != 8 && args.length != 9) || (!args[7].equals(""String_Node_Str"") && !args[7].equals(""String_Node_Str""))) {
      System.err.println(""String_Node_Str"");
      System.err.println(""String_Node_Str"" + File.pathSeparator + ""String_Node_Str"");
      System.err.println(""String_Node_Str"");
      return;
    }
    boolean reob=args[7].equals(""String_Node_Str"");
    if (reob)     System.err.println(""String_Node_Str"");
    int side=Integer.parseInt(args[6]);
    Main m=new Main();
    m.base=new File(""String_Node_Str"");
    m.input=new File(args[0]);
    m.output=new File(args[1]);
    m.exc=new ExcFile(new File(args[2]));
    m.srg=new SrgFile(new File(args[3]),m);
    m.fields=new CsvFile(new File(args[4]),side,reob);
    m.methods=new CsvFile(new File(args[5]),side,reob);
    m.xpathlist=(args.length < 9 ? ""String_Node_Str"" : args[8]).split(File.pathSeparator);
    m.run();
  }
}",0.8907686649503493
186362,"public String getClassName(String obf){
  if (obf == null)   return null;
  String r=classes.get(obf);
  if (r != null)   return r;
  if (!obf.contains(""String_Node_Str"") || obf.startsWith(""String_Node_Str""))   return ""String_Node_Str"" + obf;
  return obf;
}","public String getClassName(String obf){
  if (obf == null)   return null;
  if (obf.charAt(0) == '[')   return main.deobfTypeDescriptor(obf);
  String r=classes.get(obf);
  if (r != null)   return r;
  if (!obf.contains(""String_Node_Str"") || obf.startsWith(""String_Node_Str""))   return ""String_Node_Str"" + obf;
  return obf;
}",0.8835616438356164
186363,"public MethodInfo getMethod(String clazz,String obf,String desc){
  MethodInfo r=methods.get(clazz + ""String_Node_Str"" + obf+ desc);
  if (r == null) {
    r=new MethodInfo();
    r.name=obf;
    r.desc=desc;
  }
  return r;
}","public String getMethod(String clazz,String obf,String desc){
  return methods.get(clazz + ""String_Node_Str"" + obf+ desc);
}",0.6685714285714286
186364,"public String getFieldName(String clazz,String obf){
  String r=fields.get(clazz + ""String_Node_Str"" + obf);
  return r == null ? obf : r;
}","public String getFieldName(String clazz,String obf){
  return fields.get(clazz + ""String_Node_Str"" + obf);
}",0.8467741935483871
186365,"public SrgFile(File f) throws IOException {
  Scanner in=new Scanner(f);
  try {
    while (in.hasNextLine()) {
      if (in.hasNext(""String_Node_Str"")) {
        in.next();
        String obf=in.next();
        String deobf=in.next();
        classes.put(obf,deobf);
      }
 else       if (in.hasNext(""String_Node_Str"")) {
        in.next();
        String obf=in.next();
        String deobf=in.next();
        fields.put(obf,getLastComponent(deobf));
      }
 else       if (in.hasNext(""String_Node_Str"")) {
        in.next();
        String obf=in.next();
        String obfdesc=in.next();
        String deobf=in.next();
        String deobfdesc=in.next();
        MethodInfo mi=new MethodInfo();
        mi.desc=deobfdesc;
        mi.name=getLastComponent(deobf);
        methods.put(obf + obfdesc,mi);
      }
 else {
        in.nextLine();
      }
    }
  }
  finally {
    in.close();
  }
}","public SrgFile(File f,Main m) throws IOException {
  this.main=m;
  Scanner in=new Scanner(f);
  try {
    while (in.hasNextLine()) {
      if (in.hasNext(""String_Node_Str"")) {
        in.next();
        String obf=in.next();
        String deobf=in.next();
        classes.put(obf,deobf);
      }
 else       if (in.hasNext(""String_Node_Str"")) {
        in.next();
        String obf=in.next();
        String deobf=in.next();
        fields.put(obf,getLastComponent(deobf));
      }
 else       if (in.hasNext(""String_Node_Str"")) {
        in.next();
        String obf=in.next();
        String obfdesc=in.next();
        String deobf=in.next();
        String deobfdesc=in.next();
        methods.put(obf + obfdesc,getLastComponent(deobf));
      }
 else {
        in.nextLine();
      }
    }
  }
  finally {
    in.close();
  }
}",0.8172910662824208
186366,"public void visitMethodInsn(int opcode,String owner,String name,String desc){
  if (main.map.getClass(owner).contains(""String_Node_Str""))   throw new RuntimeException(""String_Node_Str"" + owner + ""String_Node_Str""+ main.map.getClass(owner)+ ""String_Node_Str"");
  super.visitMethodInsn(opcode,main.map.getClass(owner),main.lookupInheritedMethod(owner,name,desc),main.deobfMethodDescriptor(desc));
}","public void visitMethodInsn(int opcode,String owner,String name,String desc){
  super.visitMethodInsn(opcode,main.map.getClass(owner),main.lookupInheritedMethod(owner,name,desc),main.deobfMethodDescriptor(desc));
}",0.7016393442622951
186367,"public static void main(String[] args) throws Exception {
  if (args.length == 1 && args[0].equals(""String_Node_Str"")) {
    Main m=new Main();
    m.base=new File(MCP_BASE);
    m.input=new File(""String_Node_Str"");
    m.output=new File(""String_Node_Str"");
    m.xpathlist=new String[]{""String_Node_Str""};
    m.run();
  }
 else {
    if ((args.length != 5 && args.length != 6) || (!args[4].equals(""String_Node_Str"") && !args[4].equals(""String_Node_Str""))) {
      System.err.println(""String_Node_Str"");
      System.err.println(""String_Node_Str"" + File.pathSeparator + ""String_Node_Str"");
      System.err.println(""String_Node_Str"");
      return;
    }
    boolean reob=args[4].equals(""String_Node_Str"");
    File confDir=new File(args[2]);
    if (!confDir.isDirectory()) {
      System.err.println(args[2] + ""String_Node_Str"");
      return;
    }
    Side side=Side.fromString(args[3]);
    if (side == null) {
      System.err.println(args[3] + ""String_Node_Str"");
      return;
    }
    McpMapping mcp=new McpBukkitMapping(confDir,side,reob);
    Main m=new Main();
    m.base=new File(""String_Node_Str"");
    m.input=new File(args[0]);
    m.output=new File(args[1]);
    m.map=mcp.getMapping();
    m.xpathlist=(args.length < 6 ? new String[0] : args[8].split(File.pathSeparator));
    m.run();
  }
}","public static void main(String[] args) throws Exception {
  if (args.length == 1 && args[0].equals(""String_Node_Str"")) {
    Main m=new Main();
    m.base=new File(MCP_BASE);
    m.input=new File(""String_Node_Str"");
    m.output=new File(""String_Node_Str"");
    m.xpathlist=new String[]{""String_Node_Str""};
    m.run();
  }
 else {
    if ((args.length != 5 && args.length != 6) || (!args[4].equals(""String_Node_Str"") && !args[4].equals(""String_Node_Str""))) {
      System.err.println(""String_Node_Str"");
      System.err.println(""String_Node_Str"" + File.pathSeparator + ""String_Node_Str"");
      System.err.println(""String_Node_Str"");
      return;
    }
    boolean reob=args[4].equals(""String_Node_Str"");
    File confDir=new File(args[2]);
    if (!confDir.isDirectory()) {
      System.err.println(args[2] + ""String_Node_Str"");
      return;
    }
    Side side=Side.fromString(args[3]);
    if (side == null) {
      System.err.println(args[3] + ""String_Node_Str"");
      return;
    }
    McpMapping mcp=new McpBukkitMapping(confDir,side,reob);
    Main m=new Main();
    m.base=new File(""String_Node_Str"");
    m.input=new File(args[0]);
    m.output=new File(args[1]);
    m.map=mcp.getMapping();
    m.xpathlist=(args.length < 6 ? new String[0] : args[5].split(File.pathSeparator));
    m.run();
  }
}",0.9992372234935164
186368,"@Override public FieldVisitor visitField(int access,String name,String desc,String signature,Object value){
  String deobfName=main.deobfField(inClassName,name);
  return super.visitField(access,deobfName,main.deobfTypeDescriptor(desc),signature,value);
}","@Override public FieldVisitor visitField(int access,String name,String desc,String signature,Object value){
  String deobfName=main.lookupInheritedField(inClassName,name);
  return super.visitField(access,deobfName,main.deobfTypeDescriptor(desc),signature,value);
}",0.9615384615384616
186369,"public void visitLdcInsn(Object cst){
  super.visitLdcInsn(cst);
}","public void visitLdcInsn(Object cst){
  if (cst instanceof Type) {
    String desc=((Type)cst).getDescriptor();
    if (desc.charAt(0) == 'L' && desc.charAt(desc.length() - 1) == ';')     cst=Type.getType(""String_Node_Str"" + main.srg.getClassName(desc.substring(1,desc.length() - 1)) + ""String_Node_Str"");
  }
  super.visitLdcInsn(cst);
}",0.3267326732673267
186370,"public void run() throws IOException {
  ZipInputStream inZip=new ZipInputStream(new FileInputStream(input));
  ZipOutputStream outZip=new ZipOutputStream(new FileOutputStream(output));
  while (true) {
    ZipEntry inEntry=inZip.getNextEntry();
    if (inEntry == null)     break;
    if (!inEntry.getName().endsWith(""String_Node_Str"")) {
      ZipEntry outEntry=new ZipEntry(inEntry.getName());
      outZip.putNextEntry(outEntry);
      byte[] buf=new byte[1048576];
      int len=0;
      do {
        len=inZip.read(buf);
        if (len > 0)         outZip.write(buf,0,len);
      }
 while (len > 0);
      inZip.closeEntry();
      outZip.closeEntry();
      continue;
    }
    String oldName=fileToClass(inEntry.getName());
    String newName=srg.getClassName(oldName);
    try {
      ClassReader cr=new ClassReader(inZip);
      inZip.closeEntry();
      ClassWriter cw=new ClassWriter(ClassWriter.COMPUTE_MAXS);
      cr.accept(new DeobfuscateVisitor(cw,this),0);
      ZipEntry outEntry=new ZipEntry(classToFile(newName));
      outZip.putNextEntry(outEntry);
      outZip.write(cw.toByteArray());
      outZip.closeEntry();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + oldName + ""String_Node_Str""+ newName);
      throw new RuntimeException(e);
    }
  }
  inZip.close();
  outZip.close();
}","public void run() throws IOException {
  ZipInputStream inZip=new ZipInputStream(new FileInputStream(input));
  ZipOutputStream outZip=new ZipOutputStream(new FileOutputStream(output));
  while (true) {
    ZipEntry inEntry=inZip.getNextEntry();
    if (inEntry == null)     break;
    if (!inEntry.getName().endsWith(""String_Node_Str"")) {
      ZipEntry outEntry=new ZipEntry(inEntry.getName());
      outZip.putNextEntry(outEntry);
      byte[] buf=new byte[1048576];
      int len=0;
      do {
        len=inZip.read(buf);
        if (len > 0)         outZip.write(buf,0,len);
      }
 while (len > 0);
      inZip.closeEntry();
      outZip.closeEntry();
      continue;
    }
    String oldName=fileToClass(inEntry.getName());
    String newName=srg.getClassName(oldName);
    System.out.println(oldName + ""String_Node_Str"" + newName);
    try {
      ClassReader cr=new ClassReader(inZip);
      inZip.closeEntry();
      ClassWriter cw=new ClassWriter(ClassWriter.COMPUTE_MAXS);
      cr.accept(new DeobfuscateVisitor(cw,this),0);
      ZipEntry outEntry=new ZipEntry(classToFile(newName));
      outZip.putNextEntry(outEntry);
      outZip.write(cw.toByteArray());
      outZip.closeEntry();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + oldName + ""String_Node_Str""+ newName);
      throw new RuntimeException(e);
    }
  }
  inZip.close();
  outZip.close();
}",0.976998904709748
186371,"public static void main(String[] args) throws Exception {
  if (args.length == 1 && args[0].equals(""String_Node_Str"")) {
    Main m=new Main();
    m.base=new File(MCP_BASE);
    m.input=new File(""String_Node_Str"");
    m.output=new File(""String_Node_Str"");
    m.exc=new ExcFile(new File(m.base,""String_Node_Str""));
    m.srg=new SrgFile(new File(m.base,""String_Node_Str""));
    m.fields=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.methods=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.run();
  }
 else {
    if (args.length != 8 || (!args[7].equals(""String_Node_Str"") && !args[7].equals(""String_Node_Str""))) {
      System.err.println(""String_Node_Str"");
      return;
    }
    boolean reob=args[7].equals(""String_Node_Str"");
    if (reob)     System.err.println(""String_Node_Str"");
    int side=Integer.parseInt(args[6]);
    Main m=new Main();
    m.base=new File(""String_Node_Str"");
    m.input=new File(m.base,args[0]);
    m.output=new File(args[1]);
    m.exc=new ExcFile(new File(m.base,args[2]));
    m.srg=new SrgFile(new File(m.base,args[3]));
    m.fields=new CsvFile(new File(m.base,args[4]),side,reob);
    m.methods=new CsvFile(new File(m.base,args[5]),side,reob);
    m.run();
  }
}","public static void main(String[] args) throws Exception {
  if (args.length == 1 && args[0].equals(""String_Node_Str"")) {
    Main m=new Main();
    m.base=new File(MCP_BASE);
    m.input=new File(""String_Node_Str"");
    m.output=new File(""String_Node_Str"");
    m.exc=new ExcFile(new File(m.base,""String_Node_Str""));
    m.srg=new SrgFile(new File(m.base,""String_Node_Str""));
    m.fields=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.methods=new CsvFile(new File(m.base,""String_Node_Str""),CLIENT,false);
    m.run();
  }
 else {
    if (args.length != 8 || (!args[7].equals(""String_Node_Str"") && !args[7].equals(""String_Node_Str""))) {
      System.err.println(""String_Node_Str"");
      return;
    }
    boolean reob=args[7].equals(""String_Node_Str"");
    if (reob)     System.err.println(""String_Node_Str"");
    int side=Integer.parseInt(args[6]);
    Main m=new Main();
    m.base=new File(""String_Node_Str"");
    m.input=new File(args[0]);
    m.output=new File(args[1]);
    m.exc=new ExcFile(new File(args[2]));
    m.srg=new SrgFile(new File(args[3]));
    m.fields=new CsvFile(new File(args[4]),side,reob);
    m.methods=new CsvFile(new File(args[5]),side,reob);
    m.run();
  }
}",0.9857549857549858
186372,"public String getClassName(String obf){
  String r=classes.get(obf);
  return r == null ? obf : r;
}","public String getClassName(String obf){
  if (obf == null)   return null;
  String r=classes.get(obf);
  if (r != null)   return r;
  if (!obf.contains(""String_Node_Str"") || obf.startsWith(""String_Node_Str""))   return ""String_Node_Str"" + obf;
  return obf;
}",0.4134078212290503
186373,"public HttpWebRequest(String urlString){
  try {
    url=new URL(urlString);
  }
 catch (  MalformedURLException e) {
    throw new RuntimeMalformedURLException(e);
  }
}","HttpWebRequest(URL url){
  super(url);
}",0.3142857142857143
186374,public abstract WebResponse getResponse();,"public WebResponse getResponse(){
  try {
    URLConnection connection;
    if (proxy == null) {
      connection=url.openConnection();
    }
 else {
      connection=url.openConnection(proxy);
    }
    if (timeout != 0) {
      connection.setConnectTimeout(timeout);
    }
    configureConnection(connection);
    connection.connect();
    return new WebResponse(connection);
  }
 catch (  IOException e) {
    throw new RuntimeIOException(e);
  }
}",0.1298174442190669
186375,"public static WebRequest create(String requestUriString){
  return new HttpWebRequest(requestUriString);
}","private static WebRequest create(URL url){
  String protocol=url.getProtocol();
  if (""String_Node_Str"".equals(protocol) || ""String_Node_Str"".equals(protocol)) {
    return new HttpWebRequest(url);
  }
 else   if (""String_Node_Str"".equals(protocol)) {
    return new FtpWebRequest(url);
  }
 else   if (""String_Node_Str"".equals(protocol)) {
    return new FileWebRequest(url);
  }
 else {
    return new UnknownWebRequest(url);
  }
}",0.1076066790352504
186376,"public WebResponse(HttpURLConnection connection){
  this.connection=connection;
}","public WebResponse(URLConnection connection){
  this.connection=connection;
}",0.9746835443037974
186377,"public static void assertNotEqual(String message,Object expected,Object actual){
  assertThat(message,actual,is(not(equalTo(expected))));
}","public static void assertNotEqual(String message,Object expected,Object actual){
  assertThat(message,actual,not(equalTo(expected)));
}",0.9854014598540146
186378,"public static <T extends Comparable<T>>void assertLess(T a,T b){
  assertThat(a,is(lessThan(b)));
}","public static <T extends Comparable<T>>void assertLess(T a,T b){
  assertThat(a,lessThan(b));
}",0.979381443298969
186379,"public static void assertIsEmpty(String str){
  assertThat(str,is(EmptyStringMatcher.instance));
}","public static void assertIsEmpty(String str){
  assertThat(str,isEmptyString());
}",0.9
186380,"public static <T extends Comparable<T>>void assertGreater(T a,T b){
  assertThat(a,is(greaterThan(b)));
}","public static <T extends Comparable<T>>void assertGreater(T a,T b){
  assertThat(a,greaterThan(b));
}",0.9805825242718448
186381,"/** 
 * Sets component size to cca 80% of screen size and centers window.
 * @param component
 */
public static void resizeAndCenter(final Component component){
  final Dimension screenSize=component.getToolkit().getScreenSize();
  component.setSize((int)(screenSize.width * 0.8),(int)(screenSize.height * 0.8));
  center(component);
}","/** 
 * Sets component size to cca 80% of screen size and centers window.
 * @param component
 */
public static void resizeAndCenter(final Component component){
  final GraphicsDevice gd=GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
  final int screenWidth=gd.getDisplayMode().getWidth();
  final int screenHeight=gd.getDisplayMode().getHeight();
  component.setSize((int)(screenWidth * 0.8),(int)(screenHeight * 0.8));
  center(component);
}",0.4560099132589839
186382,"/** 
 * Locates the given component on the screen's center.
 * @param component the component to be centered
 */
public static void center(final Component component){
  final Dimension paneSize=component.getSize();
  final Dimension screenSize=component.getToolkit().getScreenSize();
  component.setLocation((screenSize.width - paneSize.width) / 2,(int)((screenSize.height - paneSize.height) * 0.45));
}","/** 
 * Locates the given component on the screen's center.
 * @param component the component to be centered
 */
public static void center(final Component component){
  final GraphicsDevice gd=GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
  final int screenWidth=gd.getDisplayMode().getWidth();
  final int screenHeight=gd.getDisplayMode().getHeight();
  final Dimension paneSize=component.getSize();
  component.setLocation((screenWidth - paneSize.width) / 2,(int)((screenHeight - paneSize.height) * 0.45));
}",0.6553552492046659
186383,"public void run(){
  if (options == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  boolean tmpResult=false;
  try {
    options.log(""String_Node_Str"",options.getKsType());
    final KeyStore ks=KeyStore.getInstance(options.getKsType());
    InputStream ksInputStream=null;
    if (!StringUtils.isEmpty(options.getKsFile())) {
      options.log(""String_Node_Str"",options.getKsFile());
      ksInputStream=new FileInputStream(options.getKsFile());
    }
    ks.load(ksInputStream,options.getKsPasswd());
    options.log(""String_Node_Str"");
    String tmpAlias=options.getKeyAliasX();
    if (tmpAlias == null || tmpAlias.length() == 0) {
      tmpAlias=(String)ks.aliases().nextElement();
    }
    options.log(""String_Node_Str"");
    final PrivateKey key=(PrivateKey)ks.getKey(tmpAlias,options.getKeyPasswdX());
    options.log(""String_Node_Str"");
    final Certificate[] chain=ks.getCertificateChain(tmpAlias);
    options.log(""String_Node_Str"",options.getInFile());
    PdfReader reader;
    try {
      reader=new PdfReader(options.getInFile());
    }
 catch (    Exception e) {
      try {
        reader=new PdfReader(options.getInFile(),new byte[0]);
      }
 catch (      Exception e2) {
        reader=new PdfReader(options.getInFile(),options.getPdfOwnerPwdStr().getBytes());
      }
    }
    options.log(""String_Node_Str"",options.getOutFile());
    final FileOutputStream fout=new FileOutputStream(options.getOutFile());
    options.log(""String_Node_Str"");
    final PdfStamper stp=PdfStamper.createSignature(reader,fout,'\0',null,options.isAppendX());
    if (options.isEncryptedX()) {
      options.log(""String_Node_Str"");
      final int tmpRight=options.getRightPrinting().getRight() | (options.isRightCopy() ? PdfWriter.ALLOW_COPY : 0) | (options.isRightAssembly() ? PdfWriter.ALLOW_ASSEMBLY : 0)| (options.isRightFillIn() ? PdfWriter.ALLOW_FILL_IN : 0)| (options.isRightScreanReaders() ? PdfWriter.ALLOW_SCREENREADERS : 0)| (options.isRightModifyAnnotations() ? PdfWriter.ALLOW_MODIFY_ANNOTATIONS : 0)| (options.isRightModifyContents() ? PdfWriter.ALLOW_MODIFY_CONTENTS : 0);
      stp.setEncryption(true,options.getPdfUserPwdStr(),options.getPdfOwnerPwdStr(),tmpRight);
    }
    final PdfSignatureAppearance sap=stp.getSignatureAppearance();
    sap.setCrypto(key,chain,null,PdfSignatureAppearance.WINCER_SIGNED);
    if (!StringUtils.isEmpty(options.getReason())) {
      options.log(""String_Node_Str"",options.getReason());
      sap.setReason(options.getReason());
    }
    if (!StringUtils.isEmpty(options.getLocation())) {
      options.log(""String_Node_Str"",options.getLocation());
      sap.setLocation(options.getLocation());
    }
    options.log(""String_Node_Str"");
    sap.setCertificationLevel(options.getCertLevelX().getLevel());
    if (options.isVisible()) {
      options.log(""String_Node_Str"");
      options.log(""String_Node_Str"");
      sap.setAcro6Layers(true);
      final String tmpImgPath=options.getImgPath();
      if (tmpImgPath != null) {
        options.log(""String_Node_Str"",tmpImgPath);
        final Image img=Image.getInstance(tmpImgPath);
        options.log(""String_Node_Str"");
        sap.setSignatureGraphic(img);
      }
      final String tmpBgImgPath=options.getBgImgPath();
      if (tmpBgImgPath != null) {
        options.log(""String_Node_Str"",tmpBgImgPath);
        final Image img=Image.getInstance(tmpBgImgPath);
        options.log(""String_Node_Str"");
        sap.setImage(img);
      }
      options.log(""String_Node_Str"");
      sap.setImageScale(options.getBgImgScale());
      options.log(""String_Node_Str"");
      sap.setLayer2Text(options.getL2Text());
      options.log(""String_Node_Str"");
      sap.setLayer4Text(options.getL4Text());
      options.log(""String_Node_Str"");
      sap.setRender(options.getRenderMode().getRender());
      options.log(""String_Node_Str"");
      sap.setVisibleSignature(new Rectangle(options.getPositionLLX(),options.getPositionLLY(),options.getPositionURX(),options.getPositionURY()),options.getPage(),null);
    }
    options.log(""String_Node_Str"");
    stp.close();
    options.log(""String_Node_Str"");
    fout.close();
    tmpResult=true;
  }
 catch (  Exception e) {
    options.log(""String_Node_Str"");
    e.printStackTrace(options.getPrintWriter());
  }
catch (  OutOfMemoryError e) {
    e.printStackTrace(options.getPrintWriter());
    options.log(""String_Node_Str"");
  }
  options.log(""String_Node_Str"" + (tmpResult ? ""String_Node_Str"" : ""String_Node_Str""));
  options.fireSignerFinishedEvent(tmpResult);
}","public void run(){
  if (options == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  boolean tmpResult=false;
  try {
    options.log(""String_Node_Str"",options.getKsType());
    final KeyStore ks=KeyStore.getInstance(options.getKsType());
    InputStream ksInputStream=null;
    if (!StringUtils.isEmpty(options.getKsFile())) {
      options.log(""String_Node_Str"",options.getKsFile());
      ksInputStream=new FileInputStream(options.getKsFile());
    }
    ks.load(ksInputStream,options.getKsPasswd());
    options.log(""String_Node_Str"");
    String tmpAlias=options.getKeyAliasX();
    if (tmpAlias == null || tmpAlias.length() == 0) {
      final String tmpAliases[]=KeyStoreUtils.getKeyAliases(options);
      if (tmpAliases != null && tmpAliases.length > 0) {
        tmpAlias=tmpAliases[0];
      }
    }
    options.log(""String_Node_Str"");
    final PrivateKey key=(PrivateKey)ks.getKey(tmpAlias,options.getKeyPasswdX());
    options.log(""String_Node_Str"");
    final Certificate[] chain=ks.getCertificateChain(tmpAlias);
    options.log(""String_Node_Str"",options.getInFile());
    PdfReader reader;
    try {
      reader=new PdfReader(options.getInFile());
    }
 catch (    Exception e) {
      try {
        reader=new PdfReader(options.getInFile(),new byte[0]);
      }
 catch (      Exception e2) {
        reader=new PdfReader(options.getInFile(),options.getPdfOwnerPwdStr().getBytes());
      }
    }
    options.log(""String_Node_Str"",options.getOutFile());
    final FileOutputStream fout=new FileOutputStream(options.getOutFile());
    options.log(""String_Node_Str"");
    final PdfStamper stp=PdfStamper.createSignature(reader,fout,'\0',null,options.isAppendX());
    if (options.isEncryptedX()) {
      options.log(""String_Node_Str"");
      final int tmpRight=options.getRightPrinting().getRight() | (options.isRightCopy() ? PdfWriter.ALLOW_COPY : 0) | (options.isRightAssembly() ? PdfWriter.ALLOW_ASSEMBLY : 0)| (options.isRightFillIn() ? PdfWriter.ALLOW_FILL_IN : 0)| (options.isRightScreanReaders() ? PdfWriter.ALLOW_SCREENREADERS : 0)| (options.isRightModifyAnnotations() ? PdfWriter.ALLOW_MODIFY_ANNOTATIONS : 0)| (options.isRightModifyContents() ? PdfWriter.ALLOW_MODIFY_CONTENTS : 0);
      stp.setEncryption(true,options.getPdfUserPwdStr(),options.getPdfOwnerPwdStr(),tmpRight);
    }
    final PdfSignatureAppearance sap=stp.getSignatureAppearance();
    sap.setCrypto(key,chain,null,PdfSignatureAppearance.WINCER_SIGNED);
    if (!StringUtils.isEmpty(options.getReason())) {
      options.log(""String_Node_Str"",options.getReason());
      sap.setReason(options.getReason());
    }
    if (!StringUtils.isEmpty(options.getLocation())) {
      options.log(""String_Node_Str"",options.getLocation());
      sap.setLocation(options.getLocation());
    }
    options.log(""String_Node_Str"");
    sap.setCertificationLevel(options.getCertLevelX().getLevel());
    if (options.isVisible()) {
      options.log(""String_Node_Str"");
      options.log(""String_Node_Str"");
      sap.setAcro6Layers(true);
      final String tmpImgPath=options.getImgPath();
      if (tmpImgPath != null) {
        options.log(""String_Node_Str"",tmpImgPath);
        final Image img=Image.getInstance(tmpImgPath);
        options.log(""String_Node_Str"");
        sap.setSignatureGraphic(img);
      }
      final String tmpBgImgPath=options.getBgImgPath();
      if (tmpBgImgPath != null) {
        options.log(""String_Node_Str"",tmpBgImgPath);
        final Image img=Image.getInstance(tmpBgImgPath);
        options.log(""String_Node_Str"");
        sap.setImage(img);
      }
      options.log(""String_Node_Str"");
      sap.setImageScale(options.getBgImgScale());
      options.log(""String_Node_Str"");
      sap.setLayer2Text(options.getL2Text());
      options.log(""String_Node_Str"");
      sap.setLayer4Text(options.getL4Text());
      options.log(""String_Node_Str"");
      sap.setRender(options.getRenderMode().getRender());
      options.log(""String_Node_Str"");
      sap.setVisibleSignature(new Rectangle(options.getPositionLLX(),options.getPositionLLY(),options.getPositionURX(),options.getPositionURY()),options.getPage(),null);
    }
    options.log(""String_Node_Str"");
    stp.close();
    options.log(""String_Node_Str"");
    fout.close();
    tmpResult=true;
  }
 catch (  Exception e) {
    options.log(""String_Node_Str"");
    e.printStackTrace(options.getPrintWriter());
  }
catch (  OutOfMemoryError e) {
    e.printStackTrace(options.getPrintWriter());
    options.log(""String_Node_Str"");
  }
  options.log(""String_Node_Str"" + (tmpResult ? ""String_Node_Str"" : ""String_Node_Str""));
  options.fireSignerFinishedEvent(tmpResult);
}",0.9797694148357624
186384,"/** 
 * Loads properties saved by previous run of application
 */
private void updateFromOptions(){
  tfPage.setText(ConvertUtils.toString(options.getPage()));
  tfPosLLX.setText(ConvertUtils.toString(options.getPositionLLX()));
  tfPosLLX.setText(ConvertUtils.toString(options.getPositionLLY()));
  tfPosURX.setText(ConvertUtils.toString(options.getPositionURX()));
  tfPosURY.setText(ConvertUtils.toString(options.getPositionURY()));
  tfBgImgScale.setText(ConvertUtils.toString(options.getBgImgScale()));
  cbDisplayMode.setSelectedItem(options.getRenderMode());
  tfL2Text.setText(options.getL2Text());
  chkbL2TextDefault.setSelected(options.getL2Text() == null);
  tfL4Text.setText(options.getL4Text());
  chkbL4TextDefault.setSelected(options.getL4Text() == null);
  tfImgPath.setText(options.getImgPath());
  tfBgImgPath.setText(options.getBgImgPath());
  chkbL2TextDefaultActionPerformed(null);
  chkbL4TextDefaultActionPerformed(null);
}","/** 
 * Loads properties saved by previous run of application
 */
private void updateFromOptions(){
  tfPage.setText(ConvertUtils.toString(options.getPage()));
  tfPosLLX.setText(ConvertUtils.toString(options.getPositionLLX()));
  tfPosLLY.setText(ConvertUtils.toString(options.getPositionLLY()));
  tfPosURX.setText(ConvertUtils.toString(options.getPositionURX()));
  tfPosURY.setText(ConvertUtils.toString(options.getPositionURY()));
  tfBgImgScale.setText(ConvertUtils.toString(options.getBgImgScale()));
  cbDisplayMode.setSelectedItem(options.getRenderMode());
  tfL2Text.setText(options.getL2Text());
  chkbL2TextDefault.setSelected(options.getL2Text() == null);
  tfL4Text.setText(options.getL4Text());
  chkbL4TextDefault.setSelected(options.getL4Text() == null);
  tfImgPath.setText(options.getImgPath());
  tfBgImgPath.setText(options.getBgImgPath());
  chkbL2TextDefaultActionPerformed(null);
  chkbL4TextDefaultActionPerformed(null);
}",0.9989440337909188
186385,"/** 
 * Creates a new Thread and sets its UncaughtExceptionHandler. The Thread is not started autmatically.
 */
public final static Thread newThread(final Runnable r,final String name){
  final Thread t=new Thread(r,name);
  t.setUncaughtExceptionHandler(UEH);
  return t;
}","/** 
 * Creates a new Thread and sets its UncaughtExceptionHandler. The Thread is not started automatically.
 */
public final static Thread newThread(final Runnable r,final String name){
  final Thread t=new Thread(r,name);
  t.setUncaughtExceptionHandler(UEH);
  return t;
}",0.9981785063752276
186386,"/** 
 * @return Whether deserialisation must be done on Bukkit's main thread. You must override and use {@link #deserialize(Fields)} if this method returns true!
 */
public abstract boolean mustSyncDeserialization();","/** 
 * Not currently used (everything happens on Bukkit's main thread).
 * @return Whether deserialisation must be done on Bukkit's main thread.
 */
public abstract boolean mustSyncDeserialization();",0.6346153846153846
186387,"@Override public boolean canBeInstantiated(final Class<? extends T> c){
}","/** 
 * You must override and use   {@link #deserialize(Fields)} if this method returns false.
 */
@Override public abstract boolean canBeInstantiated(final Class<? extends T> c);",0.5555555555555556
186388,"/** 
 * For testing
 * @param s
 * @param fileName
 * @param simple
 * @param allowEmptySections
 * @param defaultSeparator
 * @throws IOException
 */
public Config(final String s,final String fileName,final boolean simple,final boolean allowEmptySections,final String defaultSeparator) throws IOException {
  this(new ByteArrayInputStream(s.getBytes(""String_Node_Str"")),fileName,simple,allowEmptySections,defaultSeparator);
}","/** 
 * For testing
 * @param s
 * @param fileName
 * @param simple
 * @param allowEmptySections
 * @param defaultSeparator
 * @throws IOException
 */
public Config(final String s,final String fileName,final boolean simple,final boolean allowEmptySections,final String defaultSeparator) throws IOException {
  this(new ByteArrayInputStream(s.getBytes(StandardCharsets.UTF_8)),fileName,simple,allowEmptySections,defaultSeparator);
}",0.9568261376896148
186389,"/** 
 * Splits a line into value and comment. <p> Whitespace is preserved (whitespace in front of the comment is added to the value), and any ## in the value are replaced by a single #. The comment is returned with a leading #, except if there is no comment in which case it will be the empty string.
 * @param line
 * @return A pair (value, comment).
 */
public final static NonNullPair<String,String> splitLine(final String line){
  final Matcher m=linePattern.matcher(line);
  if (m.find())   return new NonNullPair<String,String>(""String_Node_Str"" + m.group(1).replace(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"" + m.group(2));
  return new NonNullPair<String,String>(line,""String_Node_Str"");
}","/** 
 * Splits a line into value and comment. <p> Whitespace is preserved (whitespace in front of the comment is added to the value), and any ## in the value are replaced by a single #. The comment is returned with a leading #, except if there is no comment in which case it will be the empty string.
 * @param line
 * @return A pair (value, comment).
 */
public final static NonNullPair<String,String> splitLine(final String line){
  final Matcher m=linePattern.matcher(line);
  if (m.matches())   return new NonNullPair<String,String>(""String_Node_Str"" + m.group(1).replace(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"" + m.group(2));
  return new NonNullPair<String,String>(""String_Node_Str"" + line.replace(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
}",0.9434724091520862
186390,"private final void setIndex(final Event e,final String index,final @Nullable Object value){
  assert list;
  final String s=name.toString(e).toLowerCase(Locale.ENGLISH);
  Variables.setVariable(s.substring(0,s.length() - 1) + index.toLowerCase(Locale.ENGLISH),value,e,local);
}","private final void setIndex(final Event e,final String index,final @Nullable Object value){
}",0.5027027027027027
186391,"@Override public boolean log(final LogEntry entry){
  return false;
}","@Override public LogResult log(final LogEntry entry){
  return LogResult.DONT_LOG;
}",0.7843137254901961
186392,"@Override public boolean log(final LogEntry entry){
  if (entry.level.intValue() >= minimum)   count++;
  return true;
}","@Override public LogResult log(final LogEntry entry){
  if (entry.level.intValue() >= minimum)   count++;
  return LogResult.LOG;
}",0.8924302788844621
186393,"@Override public boolean log(final LogEntry entry){
  if (!hadError && entry.getLevel() == Level.SEVERE) {
    hadError=true;
    beforeErrors();
  }
  return true;
}","@Override public LogResult log(final LogEntry entry){
  if (!hadError && entry.getLevel() == Level.SEVERE) {
    hadError=true;
    beforeErrors();
  }
  return LogResult.LOG;
}",0.9212827988338192
186394,"@Override public boolean log(final LogEntry entry){
  return entry.level.intValue() >= minimum;
}","@Override public LogResult log(final LogEntry entry){
  return entry.level.intValue() >= minimum ? LogResult.LOG : LogResult.DONT_LOG;
}",0.7896995708154506
186395,"/** 
 * Creates a new SkriptCommand.<br/> No parameters may be null except for permission & permissionMessage.
 * @param name /name
 * @param pattern
 * @param arguments the list of Arguments this command takes
 * @param description description to display in /help
 * @param usage message to display if the command was used incorrectly
 * @param aliases /alias1, /alias2, ...
 * @param permission permission or null if none
 * @param permissionMessage message to display if the player doesn't have the given permission
 * @param items trigger to execute
 */
public ScriptCommand(final File script,final String name,final String pattern,final List<Argument<?>> arguments,final String description,final String usage,final List<String> aliases,final String permission,final String permissionMessage,final int executableBy,final List<TriggerItem> items){
  Validate.notNull(name,pattern,arguments,description,usage,aliases,items);
  this.name=name;
  label=name.toLowerCase();
  this.permission=permission;
  this.permissionMessage=permissionMessage == null ? Language.get(""String_Node_Str"") : permissionMessage;
  this.aliases=aliases;
  activeAliases=new ArrayList<String>(aliases);
  this.description=Utils.replaceChatStyles(description);
  this.usage=Utils.replaceChatStyles(usage);
  this.executableBy=executableBy;
  this.pattern=pattern;
  this.arguments=arguments;
  trigger=new Trigger(script,""String_Node_Str"" + name,new SimpleEvent(),items);
  setupBukkitCommand();
}","/** 
 * Creates a new SkriptCommand.<br/> No parameters may be null except for permission & permissionMessage.
 * @param name /name
 * @param pattern
 * @param arguments the list of Arguments this command takes
 * @param description description to display in /help
 * @param usage message to display if the command was used incorrectly
 * @param aliases /alias1, /alias2, ...
 * @param permission permission or null if none
 * @param permissionMessage message to display if the player doesn't have the given permission
 * @param items trigger to execute
 */
public ScriptCommand(final File script,final String name,final String pattern,final List<Argument<?>> arguments,final String description,final String usage,final List<String> aliases,final String permission,final String permissionMessage,final int executableBy,final List<TriggerItem> items){
  Validate.notNull(name,pattern,arguments,description,usage,aliases,items);
  this.name=name;
  label=name.toLowerCase();
  this.permission=permission;
  this.permissionMessage=permissionMessage == null ? Language.get(""String_Node_Str"") : permissionMessage;
  this.aliases=aliases;
  activeAliases=new ArrayList<String>(aliases);
  this.description=Utils.replaceEnglishChatStyles(description);
  this.usage=Utils.replaceEnglishChatStyles(usage);
  this.executableBy=executableBy;
  this.pattern=pattern;
  this.arguments=arguments;
  trigger=new Trigger(script,""String_Node_Str"" + name,new SimpleEvent(),items);
  setupBukkitCommand();
}",0.9952734638757595
186396,"public boolean execute(final CommandSender sender,@SuppressWarnings(""String_Node_Str"") final String commandLabel,final String rest){
  if (!sender.hasPermission(permission)) {
    sender.sendMessage(permissionMessage);
    return false;
  }
  String[] args=rest.split(""String_Node_Str"");
  if (args.length == 1 && args[0].isEmpty())   args=new String[0];
  final SkriptCommandEvent event=new SkriptCommandEvent(this,sender,args);
  for (int i=0; i < arguments.size(); i++) {
    final Argument<?> a=arguments.get(i);
    if (i < args.length) {
      if (a.isSingle()) {
        if (!a.parse(args[i],sender)) {
          return false;
        }
      }
 else {
        if (!a.parse(args,i,sender)) {
          return false;
        }
      }
    }
 else {
      a.setToDefault(event);
    }
  }
  if (Skript.log(Verbosity.VERY_HIGH))   Skript.info(""String_Node_Str"" + name + ""String_Node_Str""+ Utils.join(args,""String_Node_Str""));
  final long startTrigger=System.nanoTime();
  trigger.run(event);
  if (Skript.log(Verbosity.VERY_HIGH))   Skript.info(""String_Node_Str"" + name + ""String_Node_Str""+ 1. * (System.nanoTime() - startTrigger) / 1000000. + ""String_Node_Str"");
  return true;
}","public boolean execute(final CommandSender sender,@SuppressWarnings(""String_Node_Str"") final String commandLabel,final String rest){
  if (permission != null && !sender.hasPermission(permission)) {
    sender.sendMessage(permissionMessage);
    return false;
  }
  String[] args=rest.split(""String_Node_Str"");
  if (args.length == 1 && args[0].isEmpty())   args=new String[0];
  final SkriptCommandEvent event=new SkriptCommandEvent(this,sender,args);
  for (int i=0; i < arguments.size(); i++) {
    final Argument<?> a=arguments.get(i);
    if (i < args.length) {
      if (a.isSingle()) {
        if (!a.parse(args[i],sender)) {
          return false;
        }
      }
 else {
        if (!a.parse(args,i,sender)) {
          return false;
        }
      }
    }
 else {
      a.setToDefault(event);
    }
  }
  if (Skript.log(Verbosity.VERY_HIGH))   Skript.info(""String_Node_Str"" + name + ""String_Node_Str""+ Utils.join(args,""String_Node_Str""));
  final long startTrigger=System.nanoTime();
  trigger.run(event);
  if (Skript.log(Verbosity.VERY_HIGH))   Skript.info(""String_Node_Str"" + name + ""String_Node_Str""+ 1. * (System.nanoTime() - startTrigger) / 1000000. + ""String_Node_Str"");
  return true;
}",0.9908026755852842
186397,"@Override protected Iterator<?> iterator(final Event e){
  if (arg.getCurrent().length == 0)   return null;
  if (!isContainer) {
    return new ArrayIterator<Object>(arg.getCurrent());
  }
  final Object[] os=arg.getCurrent();
  return new Iterator<Object>(){
    private int i=0;
    private Iterator<?> current=((Container<?>)os[i]).containerIterator();
    @Override public boolean hasNext(){
      while (i < os.length && !current.hasNext())       current=((Container<?>)os[++i]).containerIterator();
      return i < os.length || current.hasNext();
    }
    @Override public Object next(){
      return current.next();
    }
    @Override public void remove(){
    }
  }
;
}","@Override protected Iterator<?> iterator(final Event e){
  if (arg.getCurrent().length == 0)   return null;
  if (!isContainer) {
    return new ArrayIterator<Object>(arg.getCurrent());
  }
  final Object[] os=arg.getCurrent();
  return new Iterator<Object>(){
    private int i=0;
    private Iterator<?> current=((Container<?>)os[i]).containerIterator();
    @Override public boolean hasNext(){
      while (i < os.length - 1 && !current.hasNext())       current=((Container<?>)os[++i]).containerIterator();
      return i < os.length - 1 || current.hasNext();
    }
    @Override public Object next(){
      return current.next();
    }
    @Override public void remove(){
    }
  }
;
}",0.994160583941606
186398,"@Override public boolean hasNext(){
  while (i < os.length && !current.hasNext())   current=((Container<?>)os[++i]).containerIterator();
  return i < os.length || current.hasNext();
}","@Override public boolean hasNext(){
  while (i < os.length - 1 && !current.hasNext())   current=((Container<?>)os[++i]).containerIterator();
  return i < os.length - 1 || current.hasNext();
}",0.9786096256684492
186399,"public static VariableString newInstance(final String s){
  final ArrayList<Object> string=new ArrayList<Object>();
  if (!s.contains(""String_Node_Str"")) {
    return new VariableString(s);
  }
  int c=s.indexOf('%');
  string.add(s.substring(0,c));
  while (c != s.length()) {
    final int c2=s.indexOf('%',c + 1);
    if (c2 == -1) {
      Skript.error(""String_Node_Str"");
      return null;
    }
    if (c + 1 == c2) {
      string.add(""String_Node_Str"");
    }
 else {
      final Variable<?> var=(Variable<?>)ExprParser.parse(s.substring(c + 1,c2),Skript.getVariables().iterator(),false,""String_Node_Str"" + s.substring(c + 1,c2) + ""String_Node_Str"");
      if (var == null) {
        return null;
      }
 else {
        string.add(var);
      }
    }
    c=s.indexOf('%',c2 + 1);
    if (c == -1)     c=s.length();
    string.add(s.substring(c2 + 1,c));
  }
  return new VariableString(string);
}","/** 
 * @param s unquoted string
 * @return
 */
public static VariableString newInstance(final String s){
  final ArrayList<Object> string=new ArrayList<Object>();
  if (!s.contains(""String_Node_Str"")) {
    return new VariableString(s);
  }
  int c=s.indexOf('%');
  string.add(s.substring(0,c));
  while (c != s.length()) {
    final int c2=s.indexOf('%',c + 1);
    if (c2 == -1) {
      Skript.error(""String_Node_Str"");
      return null;
    }
    if (c + 1 == c2) {
      string.add(""String_Node_Str"");
    }
 else {
      final Variable<?> var=(Variable<?>)ExprParser.parse(s.substring(c + 1,c2),Skript.getVariables().iterator(),false,""String_Node_Str"" + s.substring(c + 1,c2) + ""String_Node_Str"");
      if (var == null) {
        return null;
      }
 else {
        string.add(var);
      }
    }
    c=s.indexOf('%',c2 + 1);
    if (c == -1)     c=s.length();
    string.add(s.substring(c2 + 1,c));
  }
  return new VariableString(string);
}",0.9741379310344828
186400,"@Override protected Object decode(ChannelHandlerContext ctx,Channel ch,ChannelBuffer cb) throws Exception {
  ChannelBuffer buffer=(ChannelBuffer)super.decode(ctx,ch,cb);
  ProtocolCoder coder=GameBoss.getInstance().getProtocolCoder();
  if (coder != null) {
    byte[] decodebytes=coder.decode(buffer.array());
    return ChannelBuffers.wrappedBuffer(decodebytes);
  }
  return buffer;
}","@Override protected Object decode(ChannelHandlerContext ctx,Channel ch,ChannelBuffer cb) throws Exception {
  ChannelBuffer buffer=(ChannelBuffer)super.decode(ctx,ch,cb);
  ProtocolCoder coder=GameBoss.getInstance().getProtocolCoder();
  if (coder != null && buffer != null) {
    byte[] decodebytes=coder.decode(buffer.array());
    return ChannelBuffers.wrappedBuffer(decodebytes);
  }
  return buffer;
}",0.9773299748110832
186401,"public void broadcast(GameDownBuffer buffer) throws Exception {
  if (buffer.getChannelBuffer().writable()) {
    throw new IllegalStateException(""String_Node_Str"" + buffer.getChannelBuffer().getShort(2));
  }
  channel.write(buffer.getChannelBuffer());
}","public void broadcast(GameDownBuffer buffer) throws Exception {
  if (buffer.getChannelBuffer().writable()) {
    throw new IllegalStateException(""String_Node_Str"" + buffer.getChannelBuffer().getShort(2));
  }
  ProtocolCoder coder=GameBoss.getInstance().getProtocolCoder();
  if (coder != null) {
    coder.encode(buffer.getChannelBuffer().array(),GameBoss.getInstance().getWriteHeaderSize());
  }
  channel.write(buffer.getChannelBuffer());
}",0.6180257510729614
186402,"@Override protected Object encode(ChannelHandlerContext ctx,Channel ch,Object obj) throws Exception {
  ChannelBuffer buffer=(ChannelBuffer)obj;
  ProtocolCoder coder=GameBoss.getInstance().getProtocolCoder();
  if (coder != null) {
    byte[] encodebytes=coder.encode(buffer.array(),GameBoss.getInstance().getWriteHeaderSize());
    return ChannelBuffers.wrappedBuffer(encodebytes);
  }
  return buffer;
}","@Override protected Object encode(ChannelHandlerContext ctx,Channel ch,Object obj) throws Exception {
  ChannelBuffer buffer=(ChannelBuffer)obj;
  return buffer;
}",0.5729349736379613
186403,"public void sendGameDownBuffer(GameDownBuffer gameBuffer) throws IllegalStateException {
  final Channel channel=ctx.getChannel();
  ChannelBuffer channelBuffer=gameBuffer.getChannelBuffer();
  if (channelBuffer.writable()) {
    throw new IllegalStateException(""String_Node_Str"" + channelBuffer.getShort(2));
  }
  channel.write(gameBuffer.getChannelBuffer());
}","public void sendGameDownBuffer(GameDownBuffer gameBuffer) throws IllegalStateException {
  final Channel channel=ctx.getChannel();
  ChannelBuffer channelBuffer=gameBuffer.getChannelBuffer();
  if (channelBuffer.writable()) {
    throw new IllegalStateException(""String_Node_Str"" + channelBuffer.getShort(2));
  }
  ProtocolCoder coder=GameBoss.getInstance().getProtocolCoder();
  if (coder != null) {
    coder.encode(channelBuffer.array(),GameBoss.getInstance().getWriteHeaderSize());
  }
  channel.write(gameBuffer.getChannelBuffer());
}",0.70874861572536
186404,"public void kill(GameDownBuffer buffer) throws IllegalStateException {
  final Channel channel=ctx.getChannel();
  if (channel.isConnected()) {
    if (buffer != null) {
      ChannelBuffer channelBuffer=buffer.getChannelBuffer();
      if (channelBuffer.writable()) {
        throw new IllegalStateException(""String_Node_Str"" + channelBuffer.getShort(2));
      }
      ChannelFuture cf=channel.write(channelBuffer);
      cf.addListener(new ChannelFutureListener(){
        @Override public void operationComplete(        ChannelFuture future) throws Exception {
          kill();
        }
      }
);
    }
  }
 else   kill();
}","public void kill(GameDownBuffer buffer) throws IllegalStateException {
  final Channel channel=ctx.getChannel();
  if (channel.isConnected()) {
    if (buffer != null) {
      ChannelBuffer channelBuffer=buffer.getChannelBuffer();
      ProtocolCoder coder=GameBoss.getInstance().getProtocolCoder();
      if (coder != null) {
        coder.encode(channelBuffer.array(),GameBoss.getInstance().getWriteHeaderSize());
      }
      if (channelBuffer.writable()) {
        throw new IllegalStateException(""String_Node_Str"" + channelBuffer.getShort(2));
      }
      ChannelFuture cf=channel.write(channelBuffer);
      cf.addListener(new ChannelFutureListener(){
        @Override public void operationComplete(        ChannelFuture future) throws Exception {
          kill();
        }
      }
);
    }
  }
 else   kill();
}",0.8673539518900344
186405,"@Override protected Object decode(ChannelHandlerContext ctx,Channel channel,Object msg) throws Exception {
  if (msg instanceof ChannelBuffer) {
    ChannelBuffer cb=(ChannelBuffer)msg;
    if (cb.readableBytes() == 23 && cb.getShort(0) == 15472) {
      ChannelBuffer data=cb.readBytes(requestBuffer.readableBytes());
      if (data.equals(requestBuffer)) {
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + channel.getRemoteAddress());
        channel.write(ChannelBuffers.wrappedBuffer(XML_REPLAY)).addListener(ChannelFutureListener.CLOSE);
        return null;
      }
    }
  }
  return msg;
}","@Override protected Object decode(ChannelHandlerContext ctx,Channel channel,Object msg) throws Exception {
  if (msg instanceof ChannelBuffer) {
    ChannelBuffer cb=(ChannelBuffer)msg;
    if (cb.readableBytes() == 23 && cb.getShort(0) == 15472) {
      ChannelBuffer data=cb.readBytes(requestBuffer.readableBytes());
      if (data.equals(requestBuffer)) {
        if (logger.isDebugEnabled())         logger.debug(""String_Node_Str"" + channel.getRemoteAddress());
        ctx.getPipeline().remove(GameEncoder.class);
        ctx.getPipeline().remove(GameDecoder.class);
        channel.write(ChannelBuffers.wrappedBuffer(XML_REPLAY)).addListener(ChannelFutureListener.CLOSE);
        return null;
      }
    }
  }
  return msg;
}",0.9219440353460971
186406,"public void kill(GameDownBuffer buffer) throws IllegalStateException {
  final Channel channel=ctx.getChannel();
  if (channel.isConnected()) {
    if (buffer != null) {
      ChannelBuffer channelBuffer=buffer.getChannelBuffer();
      if (channelBuffer.writableBytes() != 0)       throw new IllegalStateException(""String_Node_Str"" + channelBuffer.getShort(2));
      ChannelFuture cf=channel.write(buffer);
      cf.addListener(ChannelFutureListener.CLOSE);
    }
 else     ctx.getChannel().close();
  }
}","public void kill(GameDownBuffer buffer) throws IllegalStateException {
  final Channel channel=ctx.getChannel();
  if (channel.isConnected()) {
    if (buffer != null) {
      ChannelBuffer channelBuffer=buffer.getChannelBuffer();
      if (channelBuffer.writableBytes() != 0)       throw new IllegalStateException(""String_Node_Str"" + channelBuffer.getShort(2));
      ChannelFuture cf=channel.write(channelBuffer);
      cf.addListener(ChannelFutureListener.CLOSE);
    }
 else     ctx.getChannel().close();
  }
  ConnectionManager.getInstance().removeConnection(this);
}",0.93790546802595
186407,"public Object getAttachment(){
  return attachment;
}","public Object getAttachment(){
synchronized (readWriteLock) {
    return attachment;
  }
}",0.7412587412587412
186408,"public void setAttachment(Object attachment){
  this.attachment=attachment;
}","public void setAttachment(Object attachment){
synchronized (readWriteLock) {
    this.attachment=attachment;
  }
}",0.806282722513089
186409,"public String getUTFString(){
  int len=buffer.readShort();
  if (len <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  byte[] strData=new byte[len];
  String result=null;
  try {
    result=new String(strData,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    result=new String(strData);
    e.printStackTrace();
  }
  return result;
}","public String getUTFString(){
  int len=buffer.readShort();
  if (len <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  byte[] strData=new byte[len];
  if (buffer.readableBytes() < len) {
    throw new IllegalArgumentException(""String_Node_Str"" + len);
  }
  buffer.readBytes(strData);
  String result=null;
  try {
    result=new String(strData,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    result=new String(strData);
    e.printStackTrace();
  }
  return result;
}",0.8454545454545455
186410,"/** 
 * @param readSize
 * @param maxReadSize
 * @param hasReadSize 是否读取消息中的包含消息本身的大小
 * @param writeSize
 */
public GamePipeFactory(int readSize,int maxReadSize,boolean hasReadSize,int writeSize,boolean hasWriteSize){
  GameBufferFactory.setupGameBuffer(readSize,hasReadSize,writeSize,hasWriteSize);
  this.maxReadSize=maxReadSize;
  this.readOffset=hasReadSize ? 0 : 2;
}","/** 
 * @param readSize
 * @param maxReadSize
 * @param hasReadSize 是否读取消息中的包含消息本身的大小
 * @param writeSize
 */
public GamePipeFactory(int readSize,int maxReadSize,boolean hasReadSize,int writeSize,boolean hasWriteSize){
  GameBufferFactory.setupGameBuffer(readSize,hasReadSize,writeSize,hasWriteSize);
  this.maxReadSize=maxReadSize;
  this.readOffset=hasReadSize ? 0 : readSize;
}",0.9880478087649402
186411,"public void broadcast(GameDownBuffer buffer){
  channel.write(buffer);
}","public void broadcast(GameDownBuffer buffer){
  channel.write(buffer.getChannelBuffer());
}",0.8834355828220859
186412,"private HeadsetMode getActualHeadsetMode(){
  return actualMode;
}","private HeadsetMode getActualHeadsetMode(){
  return (actualMode != null) ? actualMode : desiredMode;
}",0.7810650887573964
186413,"public VadProcessor(int sampleRate,int lowThreshold,int highThreshold,int hangover,boolean enable){
  this.sampleRate=sampleRate;
  windowSize=round(sampleRate * windowTimeInterval);
  final float initialDbfs=(lowThreshold + highThreshold) / 2F;
  meanObserver=new LuenbergerObserver(0,0,meanObserverGain);
  energyObserver=new LuenbergerObserver(initialDbfs,0,energyObserverGain);
  trigger=new SchmittTrigger(false,initialDbfs,lowThreshold,highThreshold);
  hangoverMaxDuration=hangover;
  hangoverDuration=0;
  isEnabled=enable;
}","public VadProcessor(int sampleRate,int lowThreshold,int highThreshold,int hangover,boolean enable){
  this.sampleRate=sampleRate;
  windowSize=round(sampleRate * windowTimeInterval);
  final float initialDbfs=(lowThreshold + highThreshold) / 2F;
  energyObserver=new LuenbergerObserver(initialDbfs,0,energyObserverGain);
  trigger=new SchmittTrigger(false,initialDbfs,lowThreshold,highThreshold);
  hangoverMaxDuration=hangover;
  hangoverDuration=0;
  isEnabled=enable;
}",0.9393034825870646
186414,"private void processFrameInternal(short[] frame,int offset,int length,float windowDuration){
  short currentMean=mean(frame,offset,length);
  float currentRms=rms(frame,offset,length,currentMean);
  float currentDbfs=rms2dbfs(currentRms);
  currentMean=(short)meanObserver.smooth(currentMean);
  currentDbfs=energyObserver.smooth(currentDbfs);
  boolean currentState=trigger.state(currentDbfs);
  if (hangoverMaxDuration > 0) {
    if (!currentState) {
      hangoverDuration=min(hangoverMaxDuration,hangoverDuration + windowDuration);
      currentState=hangoverDuration < hangoverMaxDuration;
    }
 else {
      hangoverDuration=0;
    }
  }
  if (!currentState) {
    for (int i=offset; i < length; i++) {
      frame[i]=currentMean;
    }
  }
}","private void processFrameInternal(short[] frame,int offset,int length,float windowDuration){
  float currentRms=rms(frame,offset,length);
  float currentDbfs=rms2dbfs(currentRms,1e-10F,1F);
  currentDbfs=energyObserver.smooth(currentDbfs);
  boolean currentState=trigger.state(currentDbfs);
  if (hangoverMaxDuration > 0) {
    if (!currentState) {
      hangoverDuration=min(hangoverMaxDuration,hangoverDuration + windowDuration);
      currentState=hangoverDuration < hangoverMaxDuration;
    }
 else {
      hangoverDuration=0;
    }
  }
  if (!currentState) {
    for (int i=offset; i < offset + length; i++) {
      frame[i]=0;
    }
  }
}",0.8959081119885139
186415,"public void onWiredHeadsetOff(){
  if (getHeadsetMode() == HeadsetMode.WIRED_HEADSET && isThreadRunning()) {
    stopThread(false);
    if (listener != null) {
      listener.onServiceFailed();
    }
  }
}","public void onWiredHeadsetOff(){
  if (getActualHeadsetMode() == HeadsetMode.WIRED_HEADSET && isThreadRunning()) {
    stopThread(false);
    if (listener != null) {
      listener.onServiceFailed();
    }
  }
}",0.9855769230769232
186416,"@Override public void onCreate(){
  new Utils(this).log(""String_Node_Str"");
  super.onCreate();
  preferences=new Preferences(getApplicationContext());
  preferences.registerOnSharedPreferenceChangeListener(this);
  if (mode == null) {
    mode=preferences.getHeadsetMode();
  }
  if (headset == null) {
    headset=new HeadsetManager(this.getApplicationContext());
    headset.setListener(this);
    headset.registerHeadsetDetector();
  }
}","@Override public void onCreate(){
  new Utils(this).log(""String_Node_Str"");
  super.onCreate();
  preferences=new Preferences(getApplicationContext());
  preferences.registerOnSharedPreferenceChangeListener(this);
  if (desiredMode == null) {
    desiredMode=preferences.getHeadsetMode();
  }
  if (headset == null) {
    headset=new HeadsetManager(this.getApplicationContext());
    headset.setListener(this);
    headset.registerHeadsetDetector();
  }
}",0.9799107142857144
186417,"public void onBluetoothHeadsetOff(){
  if (getHeadsetMode() == HeadsetMode.BLUETOOTH_HEADSET && isThreadRunning()) {
    stopThread(false);
    if (listener != null) {
      listener.onServiceFailed();
    }
  }
}","public void onBluetoothHeadsetOff(){
  if (getActualHeadsetMode() == HeadsetMode.BLUETOOTH_HEADSET && isThreadRunning()) {
    stopThread(false);
    if (listener != null) {
      listener.onServiceFailed();
    }
  }
}",0.9861111111111112
186418,"public HeadsetMode getHeadsetMode(){
  return mode;
}","public HeadsetMode getHeadsetMode(){
  return desiredMode;
}",0.9203539823008848
186419,"public void setHeadsetMode(HeadsetMode mode){
  if (this.mode == mode)   return;
  preferences.setHeadsetMode(mode);
  if (isThreadRunning()) {
    stopThread(true);
    disposeAudioDevices();
    this.mode=mode;
    startThread();
  }
 else {
    disposeAudioDevices();
    this.mode=mode;
  }
}","public void setHeadsetMode(HeadsetMode mode){
  if (this.desiredMode == mode)   return;
  this.desiredMode=mode;
  preferences.setHeadsetMode(mode);
  if (isThreadRunning()) {
    stopThread(true);
    disposeAudioDevices();
    startThread();
  }
 else {
    disposeAudioDevices();
  }
}",0.8732876712328768
186420,"public void stopThread(boolean restarting){
  if (isThreadRunning())   thread.stop();
  if (!restarting) {
    new Utils(this).cancelAllNotifications();
  }
  headset.storeVolumeLevel(getHeadsetMode());
  if (headset.isBluetoothScoOn()) {
    headset.setBluetoothScoOn(false);
  }
  if (thread != null) {
    thread.dispose();
    thread=null;
  }
  disposeAudioDevices();
}","public void stopThread(boolean restarting){
  if (isThreadRunning())   thread.stop();
  if (!restarting) {
    new Utils(this).cancelAllNotifications();
  }
  headset.storeVolumeLevel(getActualHeadsetMode());
  if (headset.isBluetoothScoOn()) {
    headset.setBluetoothScoOn(false);
  }
  if (thread != null) {
    thread.dispose();
    thread=null;
  }
  disposeAudioDevices();
}",0.9920424403183024
186421,"public void startThread(){
  if (isThreadRunning())   return;
  HeadsetMode fallbackMode=getHeadsetMode();
  if (getHeadsetMode() == HeadsetMode.WIRED_HEADSET && !headset.isWiredHeadsetOn()) {
    if (listener != null) {
      listener.onServiceFailed();
    }
    return;
  }
  if (getHeadsetMode() == HeadsetMode.BLUETOOTH_HEADSET) {
    if (headset.isBluetoothHeadsetOn()) {
      if (!headset.isBluetoothScoOn()) {
        headset.setBluetoothScoOn(true);
        if (!headset.waitForBluetoothSco()) {
          headset.setBluetoothScoOn(false);
          fallbackMode=HeadsetMode.WIRED_HEADSET;
        }
      }
    }
 else {
      fallbackMode=HeadsetMode.WIRED_HEADSET;
    }
    if (fallbackMode == HeadsetMode.WIRED_HEADSET && !headset.isWiredHeadsetOn()) {
      if (listener != null) {
        listener.onServiceFailed();
      }
      return;
    }
  }
  if (!initAudioDevices(fallbackMode)) {
    if (listener != null) {
      listener.onServiceFailed();
    }
    return;
  }
  headset.restoreVolumeLevel(getHeadsetMode());
  thread=createAudioThread(input,output);
  if (threadParams != null) {
    thread.configure(threadParams);
  }
  thread.start();
}","public void startThread(){
  if (isThreadRunning())   return;
  setActualHeadsetMode(getHeadsetMode());
  if (getActualHeadsetMode() == HeadsetMode.BLUETOOTH_HEADSET) {
    if (headset.isBluetoothHeadsetOn()) {
      if (!headset.isBluetoothScoOn()) {
        headset.setBluetoothScoOn(true);
        if (!headset.waitForBluetoothSco()) {
          headset.setBluetoothScoOn(false);
          setActualHeadsetMode(HeadsetMode.WIRED_HEADSET);
        }
      }
    }
 else {
      setActualHeadsetMode(HeadsetMode.WIRED_HEADSET);
    }
  }
  if (getActualHeadsetMode() == HeadsetMode.WIRED_HEADSET && !headset.isWiredHeadsetOn()) {
    if (listener != null) {
      listener.onServiceFailed();
    }
    return;
  }
  if (!initAudioDevices(getActualHeadsetMode())) {
    if (listener != null) {
      listener.onServiceFailed();
    }
    return;
  }
  headset.restoreVolumeLevel(getActualHeadsetMode());
  thread=createAudioThread(input,output);
  if (threadParams != null) {
    thread.configure(threadParams);
  }
  thread.start();
}",0.8136054421768707
186422,"/** 
 * Returns the next entry in the tar file
 * @return TarEntry
 * @throws IOException
 */
public TarEntry getNextEntry() throws IOException {
  closeCurrentEntry();
  byte[] header=new byte[TarConstants.HEADER_BLOCK];
  byte[] theader=new byte[TarConstants.HEADER_BLOCK];
  int tr=0;
  while (tr < TarConstants.HEADER_BLOCK) {
    int res=read(theader,0,TarConstants.HEADER_BLOCK - tr);
    if (res < 0) {
      break;
    }
    System.arraycopy(theader,0,header,tr,res);
    tr+=res;
  }
  boolean eof=true;
  for (  byte b : header) {
    if (b != 0) {
      eof=false;
      break;
    }
  }
  if (!eof) {
    bytesRead+=header.length;
    currentEntry=new TarEntry(header);
  }
  return currentEntry;
}","/** 
 * Returns the next entry in the tar file
 * @return TarEntry
 * @throws IOException
 */
public TarEntry getNextEntry() throws IOException {
  closeCurrentEntry();
  byte[] header=new byte[TarConstants.HEADER_BLOCK];
  byte[] theader=new byte[TarConstants.HEADER_BLOCK];
  int tr=0;
  while (tr < TarConstants.HEADER_BLOCK) {
    int res=read(theader,0,TarConstants.HEADER_BLOCK - tr);
    if (res < 0) {
      break;
    }
    System.arraycopy(theader,0,header,tr,res);
    tr+=res;
  }
  boolean eof=true;
  for (  byte b : header) {
    if (b != 0) {
      eof=false;
      break;
    }
  }
  if (!eof) {
    currentEntry=new TarEntry(header);
  }
  return currentEntry;
}",0.9784172661870504
186423,"/** 
 * Skips 'n' bytes on the InputStream<br> Overrides default implementation of skip
 */
@Override public long skip(long n) throws IOException {
  if (defaultSkip) {
    return super.skip(n);
  }
  if (n <= 0) {
    return 0;
  }
  long left=n;
  byte[] sBuff=new byte[SKIP_BUFFER_SIZE];
  while (left > 0) {
    int res=read(sBuff,0,(int)(left < SKIP_BUFFER_SIZE ? left : SKIP_BUFFER_SIZE));
    if (res < 0) {
      break;
    }
    left-=res;
  }
  return n - left;
}","/** 
 * Skips 'n' bytes on the InputStream<br> Overrides default implementation of skip
 */
@Override public long skip(long n) throws IOException {
  if (defaultSkip) {
    long bs=super.skip(n);
    bytesRead+=bs;
    return bs;
  }
  if (n <= 0) {
    return 0;
  }
  long left=n;
  byte[] sBuff=new byte[SKIP_BUFFER_SIZE];
  while (left > 0) {
    int res=read(sBuff,0,(int)(left < SKIP_BUFFER_SIZE ? left : SKIP_BUFFER_SIZE));
    if (res < 0) {
      break;
    }
    left-=res;
  }
  return n - left;
}",0.9500509683995922
186424,"private Object handleObject(XMLEventReader parser,XMLEvent startEvent,ExtensionRegistry extensionRegistry,Message.Builder builder,FieldDescriptor field,ExtensionRegistry.ExtensionInfo extension) throws XMLStreamException {
}","private Object handleObject(XMLEventReader parser,XMLEvent startEvent,ExtensionRegistry extensionRegistry,Message.Builder builder,FieldDescriptor field,ExtensionRegistry.ExtensionInfo extension) throws XMLStreamException {
  Message.Builder subBuilder=createSubBuilder(builder,field,extension);
  XMLEvent event=startEvent;
  int depth=0;
  do {
    if (event.isStartElement()) {
      depth++;
      mergeField(parser,event,extensionRegistry,subBuilder);
      XMLEvent nextEvent=parser.nextTag();
      if (nextEvent.isEndElement()) {
        depth--;
        if (depth <= 0 && parser.peek().isEndElement()) {
          break;
        }
      }
 else       if (nextEvent.isStartElement()) {
        depth++;
      }
    }
 else {
      break;
    }
  }
 while (parser.hasNext() && (event=parser.nextTag()) != null);
  return subBuilder.build();
}",0.417910447761194
186425,"/** 
 * If the next token is a string, consume it and return its (unescaped) value. Otherwise, throw a   {@link ParseException}.
 */
public String consumeString() throws ParseException {
  return consumeByteString().toStringUtf8();
}","/** 
 * If the next token is a string, consume it and return its (unescaped) value. Otherwise, throw a   {@link ParseException}.
 */
public String consumeString() throws ParseException {
  char quote=currentToken.length() > 0 ? currentToken.charAt(0) : '\0';
  if ((quote != '\""') && (quote != '\'')) {
    throw parseException(""String_Node_Str"");
  }
  if ((currentToken.length() < 2) || (currentToken.charAt(currentToken.length() - 1) != quote)) {
    throw parseException(""String_Node_Str"");
  }
  try {
    String escaped=currentToken.substring(1,currentToken.length() - 1);
    String result=unescapeText(escaped);
    nextToken();
    return result;
  }
 catch (  InvalidEscapeSequence e) {
    throw parseException(e.getMessage());
  }
}",0.3971340839303992
186426,"/** 
 * Like   {@link #escapeBytes(com.google.protobuf.ByteString)}, but escapes a text string. Non-ASCII characters are first encoded as UTF-8, then each byte is escaped individually as a 3-digit octal escape. Yes, it's weird.
 */
static String escapeText(String input){
  return escapeBytes(ByteString.copyFromUtf8(input));
}","/** 
 * Implements JSON string escaping as specified <a href=""http://www.ietf.org/rfc/rfc4627.txt"">here</a>. <ul> <li>The following characters are escaped by prefixing them with a '\' : \b,\f,\n,\r,\t,\,""</li>  <li>Other control characters in the range 0x0000-0x001F are escaped using the \\uXXXX notation</li> <li>UTF-16 surrogate pairs are encoded using the \\uXXXX\\uXXXX notation</li> <li>any other character is printed as-is</li> </ul>
 */
static String escapeText(String input){
  StringBuilder builder=new StringBuilder(input.length());
  CharacterIterator iter=new StringCharacterIterator(input);
  for (char c=iter.first(); c != CharacterIterator.DONE; c=iter.next()) {
switch (c) {
case '\b':
      builder.append(""String_Node_Str"");
    break;
case '\f':
  builder.append(""String_Node_Str"");
break;
case '\n':
builder.append(""String_Node_Str"");
break;
case '\r':
builder.append(""String_Node_Str"");
break;
case '\t':
builder.append(""String_Node_Str"");
break;
case '\\':
builder.append(""String_Node_Str"");
break;
case '""':
builder.append(""String_Node_Str"");
break;
default :
if (c >= 0x0000 && c <= 0x001F) {
appendEscapedUnicode(builder,c);
}
 else if (Character.isHighSurrogate(c)) {
appendEscapedUnicode(builder,c);
c=iter.next();
if (c == CharacterIterator.DONE) throw new IllegalArgumentException(""String_Node_Str"");
appendEscapedUnicode(builder,c);
}
 else {
builder.append(c);
}
break;
}
}
return builder.toString();
}",0.0863145939806927
186427,"private static void printSingleField(FieldDescriptor field,Object value,JsonGenerator generator) throws IOException {
  if (field.isExtension()) {
    generator.print(""String_Node_Str"");
    generator.print(""String_Node_Str"");
    if (field.getContainingType().getOptions().getMessageSetWireFormat() && (field.getType() == FieldDescriptor.Type.MESSAGE) && (field.isOptional())&& (field.getExtensionScope() == field.getMessageType())) {
      generator.print(field.getMessageType().getFullName());
    }
 else {
      generator.print(field.getFullName());
    }
    generator.print(""String_Node_Str"");
    generator.print(""String_Node_Str"");
  }
 else {
    generator.print(""String_Node_Str"");
    if (field.getType() == FieldDescriptor.Type.GROUP) {
      generator.print(field.getMessageType().getName());
    }
 else {
      generator.print(field.getName());
    }
    generator.print(""String_Node_Str"");
  }
  if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) {
    generator.print(""String_Node_Str"");
    generator.indent();
  }
 else {
    generator.print(""String_Node_Str"");
  }
  if (field.isRepeated()) {
    generator.print(""String_Node_Str"");
    for (Iterator<?> iter=((List<?>)value).iterator(); iter.hasNext(); ) {
      printFieldValue(field,iter.next(),generator);
      if (iter.hasNext()) {
        generator.print(""String_Node_Str"");
      }
    }
    generator.print(""String_Node_Str"");
  }
 else {
    printFieldValue(field,value,generator);
    if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) {
      generator.outdent();
    }
  }
}","private static void printSingleField(FieldDescriptor field,Object value,JsonGenerator generator) throws IOException {
  if (field.isExtension()) {
    generator.print(""String_Node_Str"");
    if (field.getContainingType().getOptions().getMessageSetWireFormat() && (field.getType() == FieldDescriptor.Type.MESSAGE) && (field.isOptional())&& (field.getExtensionScope() == field.getMessageType())) {
      generator.print(field.getMessageType().getFullName());
    }
 else {
      generator.print(field.getFullName());
    }
    generator.print(""String_Node_Str"");
  }
 else {
    generator.print(""String_Node_Str"");
    if (field.getType() == FieldDescriptor.Type.GROUP) {
      generator.print(field.getMessageType().getName());
    }
 else {
      generator.print(field.getName());
    }
    generator.print(""String_Node_Str"");
  }
  if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) {
    generator.print(""String_Node_Str"");
    generator.indent();
  }
 else {
    generator.print(""String_Node_Str"");
  }
  if (field.isRepeated()) {
    generator.print(""String_Node_Str"");
    for (Iterator<?> iter=((List<?>)value).iterator(); iter.hasNext(); ) {
      printFieldValue(field,iter.next(),generator);
      if (iter.hasNext()) {
        generator.print(""String_Node_Str"");
      }
    }
    generator.print(""String_Node_Str"");
  }
 else {
    printFieldValue(field,value,generator);
    if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) {
      generator.outdent();
    }
  }
}",0.9739921976592978
186428,"/** 
 * Parse a single field from   {@code tokenizer} and merge it into {@code builder}. If a ',' is detected after the field ends, the next field will be parsed automatically
 */
protected static void mergeField(Tokenizer tokenizer,ExtensionRegistry extensionRegistry,Message.Builder builder) throws ParseException {
  FieldDescriptor field;
  Descriptor type=builder.getDescriptorForType();
  ExtensionRegistry.ExtensionInfo extension=null;
  boolean unknown=false;
  if (tokenizer.tryConsume(""String_Node_Str"")) {
    StringBuilder name=new StringBuilder(tokenizer.consumeIdentifier());
    while (tokenizer.tryConsume(""String_Node_Str"")) {
      name.append(""String_Node_Str"");
      name.append(tokenizer.consumeIdentifier());
    }
    extension=extensionRegistry.findExtensionByName(name.toString());
    if (extension == null) {
      throw tokenizer.parseExceptionPreviousToken(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else     if (extension.descriptor.getContainingType() != type) {
      throw tokenizer.parseExceptionPreviousToken(""String_Node_Str"" + name + ""String_Node_Str""+ type.getFullName()+ ""String_Node_Str"");
    }
    tokenizer.consume(""String_Node_Str"");
    field=extension.descriptor;
  }
 else {
    String name=tokenizer.consumeIdentifier();
    field=type.findFieldByName(name);
    if (field == null) {
      String lowerName=name.toLowerCase(Locale.US);
      field=type.findFieldByName(lowerName);
      if ((field != null) && (field.getType() != FieldDescriptor.Type.GROUP)) {
        field=null;
      }
    }
    if ((field != null) && (field.getType() == FieldDescriptor.Type.GROUP) && !field.getMessageType().getName().equals(name)) {
      field=null;
    }
    if (field == null && DIGITS.matcher(name).matches()) {
      field=type.findFieldByNumber(Integer.parseInt(name));
      unknown=true;
    }
    if (field == null) {
      handleMissingField(tokenizer,extensionRegistry,builder);
    }
  }
  if (field != null) {
    tokenizer.consume(""String_Node_Str"");
    boolean array=tokenizer.tryConsume(""String_Node_Str"");
    if (array) {
      while (!tokenizer.tryConsume(""String_Node_Str"")) {
        handleValue(tokenizer,extensionRegistry,builder,field,extension,unknown);
        tokenizer.tryConsume(""String_Node_Str"");
      }
    }
 else {
      handleValue(tokenizer,extensionRegistry,builder,field,extension,unknown);
    }
  }
  if (tokenizer.tryConsume(""String_Node_Str"")) {
    mergeField(tokenizer,extensionRegistry,builder);
  }
}","/** 
 * Parse a single field from   {@code tokenizer} and merge it into {@code builder}. If a ',' is detected after the field ends, the next field will be parsed automatically
 */
protected static void mergeField(Tokenizer tokenizer,ExtensionRegistry extensionRegistry,Message.Builder builder) throws ParseException {
  FieldDescriptor field;
  Descriptor type=builder.getDescriptorForType();
  ExtensionRegistry.ExtensionInfo extension=null;
  boolean unknown=false;
  String name=tokenizer.consumeIdentifier();
  field=type.findFieldByName(name);
  if (field == null) {
    String lowerName=name.toLowerCase(Locale.US);
    field=type.findFieldByName(lowerName);
    if ((field != null) && (field.getType() != FieldDescriptor.Type.GROUP)) {
      field=null;
    }
  }
  if ((field != null) && (field.getType() == FieldDescriptor.Type.GROUP) && !field.getMessageType().getName().equals(name)) {
    field=null;
  }
  if (field == null && DIGITS.matcher(name).matches()) {
    field=type.findFieldByNumber(Integer.parseInt(name));
    unknown=true;
  }
  extension=extensionRegistry.findExtensionByName(name);
  if (extension != null) {
    if (extension.descriptor.getContainingType() != type) {
      throw tokenizer.parseExceptionPreviousToken(""String_Node_Str"" + name + ""String_Node_Str""+ type.getFullName()+ ""String_Node_Str"");
    }
    field=extension.descriptor;
  }
  if (field == null) {
    handleMissingField(tokenizer,extensionRegistry,builder);
  }
  if (field != null) {
    tokenizer.consume(""String_Node_Str"");
    boolean array=tokenizer.tryConsume(""String_Node_Str"");
    if (array) {
      while (!tokenizer.tryConsume(""String_Node_Str"")) {
        handleValue(tokenizer,extensionRegistry,builder,field,extension,unknown);
        tokenizer.tryConsume(""String_Node_Str"");
      }
    }
 else {
      handleValue(tokenizer,extensionRegistry,builder,field,extension,unknown);
    }
  }
  if (tokenizer.tryConsume(""String_Node_Str"")) {
    mergeField(tokenizer,extensionRegistry,builder);
  }
}",0.6962305986696231
186429,"/** 
 * Un-escape a text string as escaped using   {@link #escapeText(String)}. Two-digit hex escapes (starting with ""\x"") are also recognized.
 */
static String unescapeText(String input) throws InvalidEscapeSequence {
  return unescapeBytes(input).toStringUtf8();
}","/** 
 * Un-escape a text string as escaped using   {@link #escapeText(String)}.
 */
static String unescapeText(String input) throws InvalidEscapeSequence {
  StringBuilder builder=new StringBuilder();
  char[] array=input.toCharArray();
  for (int i=0; i < array.length; i++) {
    char c=array[i];
    if (c == '\\') {
      if (i + 1 < array.length) {
        ++i;
        c=array[i];
switch (c) {
case 'b':
          builder.append('\b');
        break;
case 'f':
      builder.append('\f');
    break;
case 'n':
  builder.append('\n');
break;
case 'r':
builder.append('\r');
break;
case 't':
builder.append('\t');
break;
case '\\':
builder.append('\\');
break;
case '""':
builder.append('\""');
break;
case '\'':
builder.append('\'');
break;
case 'u':
if (i + 4 < array.length) {
++i;
int code=Integer.parseInt(new String(array,i,4),16);
builder.append((char)code);
i+=3;
}
 else {
throw new InvalidEscapeSequence(""String_Node_Str"");
}
break;
default :
throw new InvalidEscapeSequence(""String_Node_Str"" + c + ""String_Node_Str"");
}
}
 else {
throw new InvalidEscapeSequence(""String_Node_Str"");
}
}
 else {
builder.append(c);
}
}
return builder.toString();
}",0.2301754385964912
186430,"protected static void printUnknownFields(UnknownFieldSet unknownFields,JsonGenerator generator) throws IOException {
  for (  Map.Entry<Integer,UnknownFieldSet.Field> entry : unknownFields.asMap().entrySet()) {
    UnknownFieldSet.Field field=entry.getValue();
    for (    long value : field.getVarintList()) {
      generator.print(""String_Node_Str"");
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(""String_Node_Str"");
      generator.print(unsignedToString(value));
      generator.print(""String_Node_Str"");
    }
    for (    int value : field.getFixed32List()) {
      generator.print(""String_Node_Str"");
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(""String_Node_Str"");
      generator.print(String.format((Locale)null,""String_Node_Str"",value));
      generator.print(""String_Node_Str"");
    }
    for (    long value : field.getFixed64List()) {
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(String.format((Locale)null,""String_Node_Str"",value));
      generator.print(""String_Node_Str"");
    }
    for (    ByteString value : field.getLengthDelimitedList()) {
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(escapeBytes(value));
      generator.print(""String_Node_Str"");
    }
    for (    UnknownFieldSet value : field.getGroupList()) {
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.indent();
      printUnknownFields(value,generator);
      generator.outdent();
      generator.print(""String_Node_Str"");
    }
  }
}","protected static void printUnknownFields(UnknownFieldSet unknownFields,JsonGenerator generator) throws IOException {
  boolean firstField=true;
  for (  Map.Entry<Integer,UnknownFieldSet.Field> entry : unknownFields.asMap().entrySet()) {
    UnknownFieldSet.Field field=entry.getValue();
    for (    long value : field.getVarintList()) {
      if (firstField) {
        firstField=false;
      }
 else {
        generator.print(""String_Node_Str"");
      }
      generator.print(""String_Node_Str"");
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(""String_Node_Str"");
      generator.print(unsignedToString(value));
    }
    for (    int value : field.getFixed32List()) {
      if (firstField) {
        firstField=false;
      }
 else {
        generator.print(""String_Node_Str"");
      }
      generator.print(""String_Node_Str"");
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(""String_Node_Str"");
      generator.print(String.format((Locale)null,""String_Node_Str"",value));
    }
    for (    long value : field.getFixed64List()) {
      if (firstField) {
        firstField=false;
      }
 else {
        generator.print(""String_Node_Str"");
      }
      generator.print(""String_Node_Str"");
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(String.format((Locale)null,""String_Node_Str"",value));
    }
    for (    ByteString value : field.getLengthDelimitedList()) {
      if (firstField) {
        firstField=false;
      }
 else {
        generator.print(""String_Node_Str"");
      }
      generator.print(""String_Node_Str"");
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(""String_Node_Str"");
      generator.print(escapeBytes(value));
      generator.print(""String_Node_Str"");
    }
    for (    UnknownFieldSet value : field.getGroupList()) {
      if (firstField) {
        firstField=false;
      }
 else {
        generator.print(""String_Node_Str"");
      }
      generator.print(""String_Node_Str"");
      generator.print(entry.getKey().toString());
      generator.print(""String_Node_Str"");
      generator.print(""String_Node_Str"");
      printUnknownFields(value,generator);
      generator.print(""String_Node_Str"");
    }
  }
}",0.7670837343599615
186431,"public void testPrintToString() throws Exception {
}","public void testPrintToString() throws Exception {
  String javaText=JsonFormat.printToString(TestUtil.getAllSet());
}",0.611764705882353
186432,"/** 
 * Un-escape a byte sequence as escaped using  {@link #escapeBytes(com.google.protobuf.ByteString)}. Two-digit hex escapes (starting with ""\x"") are also recognized.
 */
static ByteString unescapeBytes(CharSequence input) throws InvalidEscapeSequence {
  byte[] result=new byte[input.length()];
  int pos=0;
  for (int i=0; i < input.length(); i++) {
    char c=input.charAt(i);
    if (c == '\\') {
      if (i + 1 < input.length()) {
        ++i;
        c=input.charAt(i);
        if (isOctal(c)) {
          int code=digitValue(c);
          if ((i + 1 < input.length()) && isOctal(input.charAt(i + 1))) {
            ++i;
            code=code * 8 + digitValue(input.charAt(i));
          }
          if ((i + 1 < input.length()) && isOctal(input.charAt(i + 1))) {
            ++i;
            code=code * 8 + digitValue(input.charAt(i));
          }
          result[pos++]=(byte)code;
        }
 else {
switch (c) {
case 'a':
            result[pos++]=0x07;
          break;
case 'b':
        result[pos++]='\b';
      break;
case 'f':
    result[pos++]='\f';
  break;
case 'n':
result[pos++]='\n';
break;
case 'r':
result[pos++]='\r';
break;
case 't':
result[pos++]='\t';
break;
case 'v':
result[pos++]=0x0b;
break;
case '\\':
result[pos++]='\\';
break;
case '\'':
result[pos++]='\'';
break;
case '""':
result[pos++]='\""';
break;
case 'x':
int code=0;
if ((i + 1 < input.length()) && isHex(input.charAt(i + 1))) {
++i;
code=digitValue(input.charAt(i));
}
 else {
throw new InvalidEscapeSequence(""String_Node_Str"");
}
if ((i + 1 < input.length()) && isHex(input.charAt(i + 1))) {
++i;
code=code * 16 + digitValue(input.charAt(i));
}
result[pos++]=(byte)code;
break;
case 'u':
code=(16 * 3 * digitValue(input.charAt(i + 1))) + (16 * 2 * digitValue(input.charAt(i + 2))) + (16 * digitValue(input.charAt(i + 3)))+ digitValue(input.charAt(i + 4));
i=i + 4;
try {
byte[] bytes=String.valueOf((char)code).getBytes(""String_Node_Str"");
result[pos++]=bytes[0];
result[pos++]=bytes[1];
}
 catch (UnsupportedEncodingException e) {
throw new InvalidEscapeSequence(e.getMessage());
}
break;
default :
throw new InvalidEscapeSequence(""String_Node_Str"" + c + ""String_Node_Str"");
}
}
}
 else {
throw new InvalidEscapeSequence(""String_Node_Str"");
}
}
 else {
result[pos++]=(byte)c;
}
}
return ByteString.copyFrom(result,0,pos);
}","/** 
 * Un-escape a byte sequence as escaped using  {@link #escapeBytes(com.google.protobuf.ByteString)}. Two-digit hex escapes (starting with ""\x"") are also recognized.
 */
static ByteString unescapeBytes(CharSequence input) throws InvalidEscapeSequence {
  byte[] result=new byte[input.length()];
  int pos=0;
  for (int i=0; i < input.length(); i++) {
    char c=input.charAt(i);
    if (c == '\\') {
      if (i + 1 < input.length()) {
        ++i;
        c=input.charAt(i);
        if (isOctal(c)) {
          int code=digitValue(c);
          if ((i + 1 < input.length()) && isOctal(input.charAt(i + 1))) {
            ++i;
            code=code * 8 + digitValue(input.charAt(i));
          }
          if ((i + 1 < input.length()) && isOctal(input.charAt(i + 1))) {
            ++i;
            code=code * 8 + digitValue(input.charAt(i));
          }
          result[pos++]=(byte)code;
        }
 else {
switch (c) {
case 'a':
            result[pos++]=0x07;
          break;
case 'b':
        result[pos++]='\b';
      break;
case 'f':
    result[pos++]='\f';
  break;
case 'n':
result[pos++]='\n';
break;
case 'r':
result[pos++]='\r';
break;
case 't':
result[pos++]='\t';
break;
case 'v':
result[pos++]=0x0b;
break;
case '\\':
result[pos++]='\\';
break;
case '\'':
result[pos++]='\'';
break;
case '""':
result[pos++]='\""';
break;
case 'x':
int code=0;
if ((i + 1 < input.length()) && isHex(input.charAt(i + 1))) {
++i;
code=digitValue(input.charAt(i));
}
 else {
throw new InvalidEscapeSequence(""String_Node_Str"");
}
if ((i + 1 < input.length()) && isHex(input.charAt(i + 1))) {
++i;
code=code * 16 + digitValue(input.charAt(i));
}
result[pos++]=(byte)code;
break;
case 'u':
code=(16 * 3 * digitValue(input.charAt(i + 1))) + (16 * 2 * digitValue(input.charAt(i + 2))) + (16 * digitValue(input.charAt(i + 3)))+ digitValue(input.charAt(i + 4));
i=i + 4;
result[pos++]=(byte)code;
break;
default :
throw new InvalidEscapeSequence(""String_Node_Str"" + c + ""String_Node_Str"");
}
}
}
 else {
throw new InvalidEscapeSequence(""String_Node_Str"");
}
}
 else {
result[pos++]=(byte)c;
}
}
return ByteString.copyFrom(result,0,pos);
}",0.9460916442048516
186433,"/** 
 * Sets the max value
 * @param < W > the widget type
 * @param max the max value
 * @return this, for chaining
 */
@SuppressWarnings(""String_Node_Str"") public <W extends AbstractSlider<T>>W setMax(Integer max){
  this.options.set(""String_Node_Str"",max);
  return (W)this;
}","/** 
 * Sets the max value
 * @param < W > the widget type
 * @param max the max value
 * @return this, for chaining
 */
public AbstractSlider<T> setMax(Integer max){
  this.options.set(""String_Node_Str"",max);
  return this;
}",0.8950495049504951
186434,"/** 
 * Sets the   {@link Orientation}
 * @param < W > the widget type
 * @param orientation the {@code Orientation}
 * @return this, for chaining
 */
@SuppressWarnings(""String_Node_Str"") public <W extends AbstractSlider<T>>W setOrientation(Orientation orientation){
  this.options.set(""String_Node_Str"",orientation);
  return (W)this;
}","/** 
 * Sets the   {@link Orientation}
 * @param < W > the widget type
 * @param orientation the {@code Orientation}
 * @return this, for chaining
 */
public AbstractSlider<T> setOrientation(Orientation orientation){
  this.options.set(""String_Node_Str"",orientation);
  return this;
}",0.6473429951690821
186435,"/** 
 * Adds a   {@link RangeValidator} so slider value(s) are valid only if comprised between minimum and maximum.<br><br> <b>Warning:</b> it does not define the minimum and maximum values the slider can slide on, but only valid ones.<br> To define the minimum and maximum values the slider can slide on, use  {@link #setMin(Integer)} and {@link #setMax(Integer)}<br> <br> <b>Dev note:</b> this method is masked abstract to make sure the developer that will add the validator to the right input(s) in   {@link #onInitialize()}
 * @param < W > the widget type
 * @param validator the {@link RangeValidator}
 * @return this
 */
public abstract <W extends AbstractSlider<T>>W setRangeValidator(RangeValidator<Integer> validator);","/** 
 * Adds a   {@link RangeValidator} so slider value(s) are valid only if comprised between minimum and maximum.<br><br> <b>Warning:</b> it does not define the minimum and maximum values the slider can slide on, but only valid ones.<br> To define the minimum and maximum values the slider can slide on, use  {@link #setMin(Integer)} and {@link #setMax(Integer)}<br> <br> <b>Dev note:</b> this method is masked abstract to make sure the developer that will add the validator to the right input(s) in   {@link #onInitialize()}
 * @param < W > the widget type
 * @param validator the {@link RangeValidator}
 * @return this
 */
public abstract AbstractSlider<T> setRangeValidator(RangeValidator<Integer> validator);",0.9909784871616932
186436,"/** 
 * Sets the min value
 * @param < W > the widget type
 * @param min the min value
 * @return this, for chaining
 */
@SuppressWarnings(""String_Node_Str"") public <W extends AbstractSlider<T>>W setMin(Integer min){
  this.options.set(""String_Node_Str"",min);
  return (W)this;
}","/** 
 * Sets the min value
 * @param < W > the widget type
 * @param min the min value
 * @return this, for chaining
 */
public AbstractSlider<T> setMin(Integer min){
  this.options.set(""String_Node_Str"",min);
  return this;
}",0.8950495049504951
186437,"/** 
 * Sets the step value
 * @param < W > the widget type
 * @param step the step value
 * @return this, for chaining
 */
@SuppressWarnings(""String_Node_Str"") public <W extends AbstractSlider<T>>W setStep(Integer step){
  this.options.set(""String_Node_Str"",step);
  return (W)this;
}","/** 
 * Sets the step value
 * @param < W > the widget type
 * @param step the step value
 * @return this, for chaining
 */
public AbstractSlider<T> setStep(Integer step){
  this.options.set(""String_Node_Str"",step);
  return this;
}",0.8974854932301741
186438,"@Override @SuppressWarnings(""String_Node_Str"") public <W extends AbstractSlider<RangeValue>>W setRangeValidator(RangeValidator<Integer> validator){
  this.rangeValidator=validator;
  return (W)this;
}","@Override public AbstractSlider<RangeValue> setRangeValidator(RangeValidator<Integer> validator){
  this.rangeValidator=validator;
  return this;
}",0.8472622478386167
186439,"@Override @SuppressWarnings(""String_Node_Str"") public <W extends AbstractSlider<Integer>>W setRangeValidator(RangeValidator<Integer> validator){
  this.rangeValidator=validator;
  return (W)this;
}","@Override public Slider setRangeValidator(RangeValidator<Integer> validator){
  this.rangeValidator=validator;
  return this;
}",0.7839506172839507
186440,"/** 
 * Gets the CSS class to be applied on the button<br/> <b>Caution:</b>   {@code super.getCSSClass()} should be called when overridden
 * @return the CSS class
 */
public String getCSSClass(){
  return this.isEnabled() ? ""String_Node_Str"" : ""String_Node_Str"";
}","/** 
 * Gets the CSS class to be applied on the button<br> <b>Caution:</b>   {@code super.getCSSClass()} should be called when overridden
 * @return the CSS class
 */
public String getCSSClass(){
  return this.isEnabled() ? ""String_Node_Str"" : ""String_Node_Str"";
}",0.998109640831758
186441,"/** 
 * Constructor
 * @param name the button's name
 * @param text the button's text
 * @param property the property used to retrieve the row's object value
 */
public SecuredCommandButton(String name,IModel<String> text,String property,String[] roles,IJQuerySecurityProvider provider){
  super(name,text,property);
  this.roles=roles;
  this.provider=provider;
}","/** 
 * Constructor
 * @param name the button's name
 * @param text the button's text
 * @param property the property used to retrieve the row's object value
 * @param roles list of roles allowed to enable the button
 * @param provider the {@link IJQuerySecurityProvider}
 */
public SecuredCommandButton(String name,IModel<String> text,String property,String[] roles,IJQuerySecurityProvider provider){
  super(name,text,property);
  this.roles=roles;
  this.provider=provider;
}",0.8646080760095012
186442,"/** 
 * Gets a new   {@link JQueryAjaxBehavior} that will be wired to the 'eventResize' event, triggered when the user resizes an event
 * @param source the {@link IJQueryAjaxAware}
 * @return a new {@code OnEventResizeAjaxBehavior} by default
 */
protected JQueryAjaxBehavior newOnEventResizeAjaxBehavior(IJQueryAjaxAware source,CharSequence precondition){
  return new OnEventResizeAjaxBehavior(source,precondition);
}","/** 
 * Gets a new   {@link JQueryAjaxBehavior} that will be wired to the 'eventResize' event, triggered when the user resizes an event
 * @param source the {@link IJQueryAjaxAware}
 * @param precondition the JavaScript precondition
 * @return a new {@code OnEventResizeAjaxBehavior} by default
 */
protected JQueryAjaxBehavior newOnEventResizeAjaxBehavior(IJQueryAjaxAware source,CharSequence precondition){
  return new OnEventResizeAjaxBehavior(source,precondition);
}",0.9427609427609428
186443,"/** 
 * Gets a new   {@link JQueryAjaxBehavior} that will be wired to the 'eventDrop' event, triggered when the user moves (drag & drop) an event
 * @param source the {@link IJQueryAjaxAware}
 * @return a new {@code OnEventDropAjaxBehavior} by default
 */
protected JQueryAjaxBehavior newOnEventDropAjaxBehavior(IJQueryAjaxAware source,CharSequence precondition){
  return new OnEventDropAjaxBehavior(source,precondition);
}","/** 
 * Gets a new   {@link JQueryAjaxBehavior} that will be wired to the 'eventDrop' event, triggered when the user moves (drag &#38; drop) an event
 * @param source the {@link IJQueryAjaxAware}
 * @param precondition the JavaScript precondition
 * @return a new {@code OnEventDropAjaxBehavior} by default
 */
protected JQueryAjaxBehavior newOnEventDropAjaxBehavior(IJQueryAjaxAware source,CharSequence precondition){
  return new OnEventDropAjaxBehavior(source,precondition);
}",0.939091915836102
186444,"/** 
 * Visitor accept method
 * @param visitor
 */
public final void accept(ICalendarVisitor visitor){
  visitor.visit(this);
}","/** 
 * Visitor accept method
 * @param visitor the {@link ICalendarVisitor}
 */
public final void accept(ICalendarVisitor visitor){
  visitor.visit(this);
}",0.8982456140350877
186445,"/** 
 * Indicates whether the   {@link #onViewRender(AjaxRequestTarget,CalendarView,LocalDateTime,LocalDateTime)} event will be triggered
 * @return false by default
 */
boolean isViewRenderEnabled();","/** 
 * Indicates whether the   {@link #onViewRender(AjaxRequestTarget,CalendarView,LocalDate,LocalDate)} event will be triggered
 * @return false by default
 */
boolean isViewRenderEnabled();",0.979591836734694
186446,"/** 
 * Gets a behavior option, referenced by its key
 * @param key the option key
 * @return null if the key does not exists
 */
public <T>T getOption(String key){
  return this.options.get(key);
}","/** 
 * Gets a behavior option, referenced by its key
 * @param < T > the object type
 * @param key the option key
 * @return {@code null} if the key does not exists
 */
public <T>T getOption(String key){
  return this.options.get(key);
}",0.7752293577981652
186447,"/** 
 * In addition to   {@link #set(String,Object)} this enables to build trees of Options.<p> Example: <pre> Options o = new Options(); o.set(""foo"", new Options(""foo1"", ""value1""), new Options(""foo2"", Options.asString(""value2""))); results in json: { ""foo"": [ { ""foo1"": value1 }, { ""foo2"": ""value2"" } ] } </pre> </p>
 * @param key - key with which the specified value is to be associated
 * @param values - values to be associated with the specified key
 * @return this, for chaining
 */
public final Options set(String key,List<?> values){
  return this.set(key,values.toString());
}","/** 
 * In addition to   {@link #set(String,Object)} this enables to build trees of Options.<br><br> Example: <pre><code> Options o = new Options(); o.set(""foo"", new Options(""foo1"", ""value1""), new Options(""foo2"", Options.asString(""value2""))); results in json: { ""foo"": [ { ""foo1"": value1 }, { ""foo2"": ""value2"" } ] } </code></pre>
 * @param key - key with which the specified value is to be associated
 * @param values - values to be associated with the specified key
 * @return this, for chaining
 */
public final Options set(String key,List<?> values){
  return this.set(key,values.toString());
}",0.97883149872989
186448,"/** 
 * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
 * @param key the key whose associated value is to be returned
 * @return the value to which the specified key is mapped, or null if this map contains no mapping for the key
 */
@SuppressWarnings(""String_Node_Str"") public <T extends Object>T get(String key){
  Object value=this.map.get(key);
  if (value != null) {
    return (T)value;
  }
  return null;
}","/** 
 * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
 * @param < T > the object type
 * @param key the key whose associated value is to be returned
 * @return the value to which the specified key is mapped, or null if this map contains no mapping for the key
 */
@SuppressWarnings(""String_Node_Str"") public <T extends Object>T get(String key){
  Object value=this.map.get(key);
  if (value != null) {
    return (T)value;
  }
  return null;
}",0.9673469387755104
186449,"/** 
 * Renders the object. This typically returns a JSON body (without brackets)
 */
String render(T object);","/** 
 * Renders the object. This typically returns a JSON body (without brackets)
 * @param object the object to render
 * @return the rendered object
 */
String render(T object);",0.7612456747404844
186450,"/** 
 * Constructor
 * @param scope the scope
 * @param the function, i.e.: the name of the '.js' file without the extension
 * @param variables the variable {@code Map} to supply to the file
 */
public JavaScriptPackageHeaderItem(Class<?> scope,String function,Map<String,Object> variables){
  super(new TextTemplateResourceReference(scope,function + ""String_Node_Str"",Model.ofMap(variables)),null,function,false,null,null);
}","/** 
 * Constructor
 * @param scope the scope
 * @param function the function, i.e.: the name of the '.js' file without the extension
 * @param variables the variable {@code Map} to supply to the file
 */
public JavaScriptPackageHeaderItem(Class<?> scope,String function,Map<String,Object> variables){
  super(new TextTemplateResourceReference(scope,function + ""String_Node_Str"",Model.ofMap(variables)),null,function,false,null,null);
}",0.9895712630359212
186451,"/** 
 * Converts the object to its string representation using the appropriate converter, if defined.
 * @param object the object
 * @return the string representation using the appropriate converter, if defined. #toString() otherwise.
 */
public static <T>String toString(T object){
  String value=null;
  @SuppressWarnings(""String_Node_Str"") IConverter<T> converter=(IConverter<T>)Application.get().getConverterLocator().getConverter(object.getClass());
  if (converter != null) {
    value=converter.convertToString(object,Session.get().getLocale());
  }
 else {
    value=object.toString();
  }
  return value;
}","/** 
 * Converts the object to its string representation using the appropriate converter, if defined.
 * @param < T > the object type
 * @param object the object
 * @return the string representation using the appropriate converter, if defined. #toString() otherwise.
 */
public static <T>String toString(T object){
  String value=null;
  @SuppressWarnings(""String_Node_Str"") IConverter<T> converter=(IConverter<T>)Application.get().getConverterLocator().getConverter(object.getClass());
  if (converter != null) {
    value=converter.convertToString(object,Session.get().getLocale());
  }
 else {
    value=object.toString();
  }
  return value;
}",0.9746434231378764
186452,"/** 
 * Gets the current timezone offset
 * @param time
 * @return the timezone offset
 * @see TimeZone#getRawOffset()
 */
public static long offset(long time){
  return TimeZone.getDefault().getOffset(time);
}","/** 
 * Gets the current timezone offset
 * @param time the timestamp
 * @return the timezone offset
 * @see TimeZone#getRawOffset()
 */
public static long offset(long time){
  return TimeZone.getDefault().getOffset(time);
}",0.967741935483871
186453,"/** 
 * Converts a ISO8601 string date to an   {@code UTC} {@link Date}
 * @param date the date to convert
 * @return the UTC date
 * @throws ParseException
 */
public static long utc(String date) throws ParseException {
  return DateUtils.utc(DateUtils.parse(date).getTime());
}","/** 
 * Converts a ISO8601 string date to an   {@code UTC} {@link Date}
 * @param date the date to convert
 * @return the UTC date
 * @throws ParseException if the string cannot be parsed
 */
public static long utc(String date) throws ParseException {
  return DateUtils.utc(DateUtils.parse(date).getTime());
}",0.9473684210526316
186454,"/** 
 * Converts a ISO8601 string date (without timezone) to a   {@link Date}
 * @param date ISO8601 string date
 * @return the {@code Date}
 * @throws ParseException
 */
public static Date parse(String date) throws ParseException {
  return new SimpleDateFormat(ISO8601).parse(date);
}","/** 
 * Converts a ISO8601 string date (without timezone) to a   {@link Date}
 * @param date ISO8601 string date
 * @return the {@code Date}
 * @throws ParseException if the string cannot be parsed
 */
public static Date parse(String date) throws ParseException {
  return new SimpleDateFormat(ISO8601).parse(date);
}",0.9485903814262024
186455,"/** 
 * Gets the statement that detaches the element matching the current selector from the DOM.<br> The   {@code #detach} method is the same as {@code #remove}, except that   {@code #detach} keeps all jQuery data associated with the removed elements.<br>This method is useful when removed elements are to be reinserted into the DOM at a later time.
 * @param selector the jQuery selector
 * @return the statement
 * @see #remove(AjaxRequestTarget)
 */
public static String detach(String selector){
  return String.format(""String_Node_Str"",selector);
}","/** 
 * Gets the statement that detaches the element matching the current selector from the DOM.<br> The   {@code #detach} method is the same as {@code #remove}, except that   {@code #detach} keeps all jQuery data associated with the removed elements.<br>This method is useful when removed elements are to be reinserted into the DOM at a later time.
 * @param selector the jQuery selector
 * @return the statement
 * @see #remove(String)
 */
public static String detach(String selector){
  return String.format(""String_Node_Str"",selector);
}",0.9807868252516012
186456,"/** 
 * Gets the statement that removes the element matching the current selector from the DOM.<br> Use   {@code #remove} when you want to remove the element itself, as well as everything inside it.<br>In addition to the elements themselves, all bound events and jQuery data associated with the elements are removed.<br> To remove the elements without removing data and events, use  {@code #detach} instead.
 * @param selector the jQuery selector
 * @return the statement
 * @see #detach(AjaxRequestTarget)
 */
public static String remove(String selector){
  return String.format(""String_Node_Str"",selector);
}","/** 
 * Gets the statement that removes the element matching the current selector from the DOM.<br> Use   {@code #remove} when you want to remove the element itself, as well as everything inside it.<br>In addition to the elements themselves, all bound events and jQuery data associated with the elements are removed.<br> To remove the elements without removing data and events, use  {@code #detach} instead.
 * @param selector the jQuery selector
 * @return the statement
 * @see #detach(String)
 */
public static String remove(String selector){
  return String.format(""String_Node_Str"",selector);
}",0.9809760132340778
186457,"/** 
 * Gets the list-item matching the given hash against the list
 * @param hash the hashcode to match
 * @param list the {@link List} to search in
 * @return the list-item or {@code null} if not found
 */
public static synchronized <T>T fromHash(int hash,List<T> list){
  int index=ListUtils.indexOf(hash,list);
  if (index > -1) {
    return list.get(index);
  }
  return null;
}","/** 
 * Gets the list-item matching the given hash against the list
 * @param < T > the object type
 * @param hash the hashcode to match
 * @param list the {@link List} to search in
 * @return the list-item or {@code null} if not found
 */
public static synchronized <T>T fromHash(int hash,List<T> list){
  int index=ListUtils.indexOf(hash,list);
  if (index > -1) {
    return list.get(index);
  }
  return null;
}",0.9598997493734336
186458,"/** 
 * Utility method to move a list-item at a new position in the specified list<br> This method will use the hashcode of the list-item to retrieve it against the list.
 * @param list the {@link List}
 * @param item the item
 * @param index the position to move to
 */
public static synchronized <T>void move(final T item,int index,final List<T> list){
  if (index < list.size()) {
    list.add(index,list.remove(ListUtils.indexOf(item.hashCode(),list)));
  }
}","/** 
 * Utility method to move a list-item at a new position in the specified list<br> This method will use the hashcode of the list-item to retrieve it against the list.
 * @param < T > the object type
 * @param list the {@link List}
 * @param item the item
 * @param index the position to move to
 */
public static synchronized <T>void move(final T item,int index,final List<T> list){
  if (index < list.size()) {
    list.add(index,list.remove(ListUtils.indexOf(item.hashCode(),list)));
  }
}",0.9665970772442588
186459,"/** 
 * Parses a value as a String and returns a Number.<br>
 * @param value the string to parse
 * @param min the minimum allowed value
 * @param max the maximum allowed value
 * @param locale the {@link Locale}
 * @return the converted number
 * @throws ConversionException
 */
protected N parse(String value,final double min,final double max,Locale locale) throws ConversionException {
  if (value == null) {
    return null;
  }
  final NumberFormat format=NumberFormat.getCurrencyInstance(locale);
  final N number=this.parse(format,value,locale);
  if (number == null) {
    return null;
  }
  if (number.doubleValue() < min) {
    throw newConversionException(""String_Node_Str"" + min,value,locale).setFormat(format);
  }
  if (number.doubleValue() > max) {
    throw newConversionException(""String_Node_Str"" + max,value,locale).setFormat(format);
  }
  return number;
}","/** 
 * Parses a value as a String and returns a Number.<br>
 * @param value the string to parse
 * @param min the minimum allowed value
 * @param max the maximum allowed value
 * @param locale the {@link Locale}
 * @return the converted number
 * @throws ConversionException if value is unparsable or out of range
 */
protected N parse(String value,final double min,final double max,Locale locale) throws ConversionException {
  if (value == null) {
    return null;
  }
  final NumberFormat format=NumberFormat.getCurrencyInstance(locale);
  final N number=this.parse(format,value,locale);
  if (number == null) {
    return null;
  }
  if (number.doubleValue() < min) {
    throw newConversionException(""String_Node_Str"" + min,value,locale).setFormat(format);
  }
  if (number.doubleValue() > max) {
    throw newConversionException(""String_Node_Str"" + max,value,locale).setFormat(format);
  }
  return number;
}",0.9782244556113904
186460,"/** 
 * Set whether the menu-item is enabled
 * @param enabled
 */
public void setEnabled(boolean enabled){
  this.enabled=enabled;
}","/** 
 * Set whether the menu-item is enabled
 * @param enabled {@code true} or {@code false}
 */
public void setEnabled(boolean enabled){
  this.enabled=enabled;
}",0.8986486486486487
186461,"/** 
 * Set whether a page is opened in a new window
 * @param openInNewWindow
 */
public void setOpenInNewWindow(boolean openInNewWindow){
  this.openInNewWindow=openInNewWindow;
}","/** 
 * Set whether a page is opened in a new window
 * @param openInNewWindow {@code true} or {@code false}
 */
public void setOpenInNewWindow(boolean openInNewWindow){
  this.openInNewWindow=openInNewWindow;
}",0.923469387755102
186462,"/** 
 * Gets a new   {@link IVisitor} that will be used by {@link #onBeforeRespond(Map,AjaxRequestTarget)}
 * @return the new {@code IVisitor}
 */
protected static IVisitor<Component,Object> newBeforeRespondVisitor(final AjaxRequestTarget target){
  return (  Component component,  IVisit<Object> visit) -> {
    for (    IDestroyable behavior : component.getBehaviors(JQueryUIBehavior.class)) {
      behavior.destroy(target);
    }
  }
;
}","/** 
 * Gets a new   {@link IVisitor} that will be used by {@link #onBeforeRespond(Map,AjaxRequestTarget)}
 * @param target the {@link AjaxRequestTarget}
 * @return the new {@code IVisitor}
 */
protected static IVisitor<Component,Object> newBeforeRespondVisitor(final AjaxRequestTarget target){
  return (  Component component,  IVisit<Object> visit) -> {
    for (    IDestroyable behavior : component.getBehaviors(JQueryUIBehavior.class)) {
      behavior.destroy(target);
    }
  }
;
}",0.9494079655543596
186463,"/** 
 * Gets a new   {@link JQueryEffectBehavior}
 * @param selector
 * @return the widget behavior
 */
protected JQueryEffectBehavior newEffectBehavior(String selector){
  return new JQueryEffectBehavior(selector,this){
    private static final long serialVersionUID=1L;
    @Override public void onConfigure(    Component component){
      super.onConfigure(component);
      JQueryEffectContainer.this.onConfigure(this);
    }
  }
;
}","/** 
 * Gets a new   {@link JQueryEffectBehavior}
 * @param selector the html selector (ie: '#myId')
 * @return the widget behavior
 */
protected JQueryEffectBehavior newEffectBehavior(String selector){
  return new JQueryEffectBehavior(selector,this){
    private static final long serialVersionUID=1L;
    @Override public void onConfigure(    Component component){
      super.onConfigure(component);
      JQueryEffectContainer.this.onConfigure(this);
    }
  }
;
}",0.9646799116997792
186464,"/** 
 * Sets the roles allowed to enable the button
 * @param roles
 */
public void setRoles(String[] roles){
  this.roles=roles.clone();
}","/** 
 * Sets the roles allowed to enable the button
 * @param roles list of roles allowed to enable the button
 */
public void setRoles(String[] roles){
  this.roles=roles.clone();
}",0.8660436137071651
186465,"@Override protected void onInitialize(){
  super.onInitialize();
  this.modelBehavior=this.newSchedulerModelBehavior(this.getModel(),this.getSchedulerEventFactory());
  this.add(this.modelBehavior);
  this.editTemplate=this.newEditTemplate();
  if (this.editTemplate != null) {
    this.editTemplateBehavior=new KendoTemplateBehavior(this.editTemplate);
    this.add(this.editTemplateBehavior);
  }
  this.eventTemplate=this.newEventTemplate();
  if (this.eventTemplate != null) {
    this.eventTemplateBehavior=new KendoTemplateBehavior(this.eventTemplate);
    this.add(this.eventTemplateBehavior);
  }
}","@Override protected void onInitialize(){
  super.onInitialize();
  this.modelBehavior=this.newSchedulerModelBehavior(this.getModel(),this.getSchedulerEventFactory());
  this.add(this.modelBehavior);
  this.editTemplate=this.newEditTemplate();
  if (this.editTemplate != null) {
    this.editTemplateBehavior=new KendoTemplateBehavior(this.editTemplate,""String_Node_Str"");
    this.add(this.editTemplateBehavior);
  }
  this.eventTemplate=this.newEventTemplate();
  if (this.eventTemplate != null) {
    this.eventTemplateBehavior=new KendoTemplateBehavior(this.eventTemplate,""String_Node_Str"");
    this.add(this.eventTemplateBehavior);
  }
}",0.971153846153846
186466,"@Override public void bind(Component component){
  super.bind(component);
  this.token=String.format(""String_Node_Str"",component.getMarkupId());
}","@Override public void bind(Component component){
  super.bind(component);
  this.token=String.format(""String_Node_Str"",component.getMarkupId(),this.suffix);
}",0.9605263157894736
186467,"/** 
 * Constructor
 * @param template the {@link IJQueryTemplate} that this behavior should render via the resource stream
 */
public KendoTemplateBehavior(IJQueryTemplate template){
  this.template=template;
}","/** 
 * Constructor
 * @param template the {@link IJQueryTemplate} that this behavior should render via the resource stream
 * @param suffix the token suffix
 */
public KendoTemplateBehavior(IJQueryTemplate template,String suffix){
  this.template=template;
  this.suffix=suffix;
}",0.8577235772357723
186468,"/** 
 * Constructor
 * @param id the markup-id
 * @param model the {@link IModel}
 * @param toolbar the {@link IWysiwygToolbar}
 */
public WysiwygEditor(String id,IModel<String> model,IWysiwygToolbar toolbar){
  super(id,model);
  this.container=this.newMarkupContainer();
  this.add(this.container);
  if (toolbar != null) {
    toolbar.attachToEditor(this.container);
  }
  this.setEscapeModelStrings(false);
}","/** 
 * Constructor
 * @param id the markup id
 * @param model the {@link IModel}
 * @param toolbar the {@link IWysiwygToolbar}
 */
public WysiwygEditor(String id,IModel<String> model,IWysiwygToolbar toolbar){
  super(id,model);
  this.container=this.newMarkupContainer();
  this.add(this.container);
  if (toolbar != null) {
    toolbar.attachToEditor(this.container);
  }
  this.setEscapeModelStrings(false);
}",0.9975728155339806
186469,"/** 
 * Constructor
 * @param id the markup-id
 * @param model the {@link IModel}
 */
public DefaultWysiwygToolbar(String id,IModel<String> model){
  super(id,model);
  this.toolbar=new WebMarkupContainer(""String_Node_Str"");
  this.toolbar.setMarkupId(""String_Node_Str"");
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new Label(""String_Node_Str"",new ResourceModel(""String_Node_Str"")));
  this.toolbar.add(new Label(""String_Node_Str"",new ResourceModel(""String_Node_Str"")));
  this.toolbar.add(new Label(""String_Node_Str"",new ResourceModel(""String_Node_Str"")));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.add(this.toolbar);
}","/** 
 * Constructor
 * @param id the markup id
 * @param model the {@link IModel}
 */
public DefaultWysiwygToolbar(String id,IModel<String> model){
  super(id,model);
  this.toolbar=new WebMarkupContainer(""String_Node_Str"");
  this.toolbar.setMarkupId(""String_Node_Str"");
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new Label(""String_Node_Str"",new ResourceModel(""String_Node_Str"")));
  this.toolbar.add(new Label(""String_Node_Str"",new ResourceModel(""String_Node_Str"")));
  this.toolbar.add(new Label(""String_Node_Str"",new ResourceModel(""String_Node_Str"")));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.toolbar.add(new WebMarkupContainer(""String_Node_Str"").add(AttributeModifier.replace(""String_Node_Str"",new ResourceModel(""String_Node_Str""))));
  this.add(this.toolbar);
}",0.99967845659164
186470,"/** 
 * Get the label pattern to be used to display the value. Should be overridden with care!<br> <b>Note: </b> the pattern is a javascript string, where lower value is represented by ""ui.values[0]"", upper value by ""ui.values[1]"".<br>
 * @return default to '[' + ui.values[0] + ', ' + ui.values[1] + ']'
 */
protected String getLabelPattern(){
  return ""String_Node_Str"";
}","/** 
 * Get the label pattern to be used to display the value. Should be overridden with care!<br> <b>Note: </b> the pattern is a javascript string, where lower value is represented by ""ui.values[0]"", upper value by ""ui.values[1]"".<br>
 * @return default to '[' + ui.values[0] + ', ' +  ui.values[1] + ']'
 */
protected String getLabelPattern(){
  return ""String_Node_Str"";
}",0.9986648865153538
186471,"/** 
 * Gets a new   {@link FormComponent} that will be used as an input.<br>Override this method when you need to use a  {@code IValidator} or different input type, e.g. {@code NumberTextField} or {@code PasswordField}.
 * @param id the markup-id
 * @param model the {@link IModel}
 * @return the new {@link FormComponent}
 */
protected FormComponent<T> newTextField(String id,IModel<T> model){
  return new TextField<T>(id,model);
}","/** 
 * Gets a new   {@link FormComponent} that will be used as an input.<br>Override this method when you need to use a  {@code IValidator} or different input type, e.g. {@code NumberTextField} or {@code PasswordField}.
 * @param id the markup id
 * @param model the {@link IModel}
 * @return the new {@link FormComponent}
 */
protected FormComponent<T> newTextField(String id,IModel<T> model){
  return new TextField<T>(id,model);
}",0.9976958525345622
186472,"/** 
 * Gets a new   {@link Form}
 * @param id the markup-id
 * @return the new form
 */
private static Form<?> newForm(String id){
  return new Form<Void>(id){
    private static final long serialVersionUID=1L;
    @Override protected boolean wantSubmitOnParentFormSubmit(){
      return false;
    }
  }
;
}","/** 
 * Gets a new   {@link Form}
 * @param id the markup id
 * @return the new form
 */
private static Form<?> newForm(String id){
  return new Form<Void>(id){
    private static final long serialVersionUID=1L;
    @Override protected boolean wantSubmitOnParentFormSubmit(){
      return false;
    }
  }
;
}",0.9967637540453076
186473,"/** 
 * Gets a new   {@link Component} that will be used as a label in the dialog.<br>Override this method when you need to show formatted label.
 * @param id the markup-id
 * @param model the label {@link IModel}
 * @return the new label component.
 */
protected Component newLabel(String id,IModel<String> model){
  return new Label(id,model);
}","/** 
 * Gets a new   {@link Component} that will be used as a label in the dialog.<br>Override this method when you need to show formatted label.
 * @param id the markup id
 * @param model the label {@link IModel}
 * @return the new label component.
 */
protected Component newLabel(String id,IModel<String> model){
  return new Label(id,model);
}",0.9971181556195964
186474,"/** 
 * Gets the   {@link Component} that will be lazy loaded
 * @param id the markup-id
 * @param value the value corresponding to the column's field
 * @return the new {@code Component}
 */
protected abstract Component newLazyComponent(String id,String value);","/** 
 * Gets the   {@link Component} that will be lazy loaded
 * @param id the markup id
 * @param value the value corresponding to the column's field
 * @return the new {@code Component}
 */
protected abstract Component newLazyComponent(String id,String value);",0.9961832061068704
186475,"/** 
 * Indicates whether the 'seriesClick' event is enabled.<br> If true, the   {@link #onSeriesClick(AjaxRequestTarget,String,String,String,long)} event will be triggered by clicking an event or a free event slot.<br>
 * @return {@code false} by default
 */
boolean isSeriesClickEventEnabled();","/** 
 * Indicates whether the 'seriesClick' event is enabled.<br> If true, the   {@link #onSeriesClick(AjaxRequestTarget,String,String,String,long)} event will be triggered by clicking an event or a free event slot.
 * @return {@code false} by default
 */
boolean isSeriesClickEventEnabled();",0.9931972789115646
186476,"/** 
 * Gets a new   {@link FormComponent} that will be used as an input.<br>Override this method when you need to use a  {@code IValidator} or different input type, e.g. {@code NumberTextField} or {@code PasswordField}.
 * @param id the markup-id
 * @param model the {@link IModel}
 * @return the new {@link FormComponent}
 */
protected FormComponent<T> newTextField(String id,IModel<T> model){
  return new TextField<T>(id,model);
}","/** 
 * Gets a new   {@link FormComponent} that will be used as an input.<br>Override this method when you need to use a  {@code IValidator} or different input type, e.g. {@code NumberTextField} or {@code PasswordField}.
 * @param id the markup id
 * @param model the {@link IModel}
 * @return the new {@link FormComponent}
 */
protected FormComponent<T> newTextField(String id,IModel<T> model){
  return new TextField<T>(id,model);
}",0.9976958525345622
186477,"/** 
 * Gets a new   {@link Form}
 * @param id the markup-id
 * @return the new form
 */
private static Form<Void> newForm(String id){
  return new Form<Void>(id){
    private static final long serialVersionUID=1L;
    @Override protected boolean wantSubmitOnParentFormSubmit(){
      return false;
    }
  }
;
}","/** 
 * Gets a new   {@link Form}
 * @param id the markup id
 * @return the new form
 */
private static Form<Void> newForm(String id){
  return new Form<Void>(id){
    private static final long serialVersionUID=1L;
    @Override protected boolean wantSubmitOnParentFormSubmit(){
      return false;
    }
  }
;
}",0.9967948717948718
186478,"/** 
 * Gets a new   {@link Component} that will be used as a label in the window.<br>Override this method when you need to show formatted label.
 * @param id the markup-id
 * @param model the label {@link IModel}
 * @return the new label component.
 */
protected Component newLabel(String id,IModel<String> model){
  return new Label(id,model);
}","/** 
 * Gets a new   {@link Component} that will be used as a label in the window.<br>Override this method when you need to show formatted label.
 * @param id the markup id
 * @param model the label {@link IModel}
 * @return the new label component.
 */
protected Component newLabel(String id,IModel<String> model){
  return new Label(id,model);
}",0.9971181556195964
186479,"/** 
 * Gets a new   {@link KendoFeedbackPanel}
 * @param id the markup-id
 * @return a new {@code KendoFeedbackPanel}
 */
protected KendoFeedbackPanel newFeedbackPanel(String id){
  return new KendoFeedbackPanel(id,this);
}","/** 
 * Gets a new   {@link KendoFeedbackPanel}
 * @param id the markup id
 * @return a new {@code KendoFeedbackPanel}
 */
protected KendoFeedbackPanel newFeedbackPanel(String id){
  return new KendoFeedbackPanel(id,this);
}",0.9955357142857144
186480,"/** 
 * Gets a new   {@link Form}
 * @param id the markup-id
 * @return the new form
 */
private static Form<Void> newForm(String id){
  return new Form<Void>(id){
    private static final long serialVersionUID=1L;
    @Override protected boolean wantSubmitOnParentFormSubmit(){
      return false;
    }
  }
;
}","/** 
 * Gets a new   {@link Form}
 * @param id the markup id
 * @return the new form
 */
private static Form<Void> newForm(String id){
  return new Form<Void>(id){
    private static final long serialVersionUID=1L;
    @Override protected boolean wantSubmitOnParentFormSubmit(){
      return false;
    }
  }
;
}",0.9967948717948718
186481,"@Override public String toScript(){
  return String.format(""String_Node_Str"",this.getName(),super.toString());
}","@Override public String toScript(){
  return String.format(""String_Node_Str"",this.getName(),this.build());
}",0.9181818181818182
186482,"@Override public void renderHead(Component component,IHeaderResponse response){
  super.renderHead(component,response);
  if (this.datasources != null) {
    for (    IKendoDataSource datasource : this.datasources) {
      this.renderPriorityHeaderItem(JavaScriptHeaderItem.forScript(datasource.toString(),datasource.getToken()),response);
    }
  }
}","@Override public void renderHead(Component component,IHeaderResponse response){
  super.renderHead(component,response);
  if (this.datasources != null) {
    for (    IKendoDataSource datasource : this.datasources) {
      this.renderPriorityHeaderItem(JavaScriptHeaderItem.forScript(datasource.toScript(),datasource.getToken()),response);
    }
  }
}",0.9202279202279202
186483,"@Override public String toScript(){
  return String.format(""String_Node_Str"",this.getName(),this.toString());
}","@Override public String toScript(){
  return String.format(""String_Node_Str"",this.getName(),this.build());
}",0.9497716894977168
186484,"/** 
 * Initializes CSS & JavaScript resource references
 */
private void initReferences(){
  WysiwygLibrarySettings settings=WysiwygLibrarySettings.get();
  if (settings.getBootstrapCombinedNoIconsStyleSheetReference() != null) {
    this.add(settings.getBootstrapCombinedNoIconsStyleSheetReference());
  }
  if (settings.getBootstrapResponsiveStyleSheetReference() != null) {
    this.add(settings.getBootstrapResponsiveStyleSheetReference());
  }
  if (settings.getEditorStyleSheetReference() != null) {
    this.add(settings.getEditorStyleSheetReference());
  }
  if (settings.getBootstrapWysiwygJavaScriptReference() != null) {
    this.add(settings.getBootstrapWysiwygJavaScriptReference());
  }
  if (settings.getBootstrapDropDownJavaScriptReference() != null) {
    this.add(settings.getBootstrapDropDownJavaScriptReference());
  }
  if (settings.getJQueryHotKeysJavaScriptReference() != null) {
    this.add(settings.getJQueryHotKeysJavaScriptReference());
  }
  if (settings.getPrettifyJavaScriptReference() != null) {
    this.add(settings.getPrettifyJavaScriptReference());
  }
}","/** 
 * Initializes CSS & JavaScript resource references
 */
private void initReferences(){
  WysiwygLibrarySettings settings=WysiwygLibrarySettings.get();
  if (settings.getBootstrapCombinedNoIconsStyleSheetReference() != null) {
    this.add(settings.getBootstrapCombinedNoIconsStyleSheetReference());
  }
  if (settings.getBootstrapResponsiveStyleSheetReference() != null) {
    this.add(settings.getBootstrapResponsiveStyleSheetReference());
  }
  if (settings.getEditorStyleSheetReference() != null) {
    this.add(settings.getEditorStyleSheetReference());
  }
  if (settings.getEditorJavaScriptResourceReference() != null) {
    this.add(settings.getEditorJavaScriptResourceReference());
  }
  if (settings.getBootstrapWysiwygJavaScriptReference() != null) {
    this.add(settings.getBootstrapWysiwygJavaScriptReference());
  }
  if (settings.getBootstrapDropDownJavaScriptReference() != null) {
    this.add(settings.getBootstrapDropDownJavaScriptReference());
  }
  if (settings.getJQueryHotKeysJavaScriptReference() != null) {
    this.add(settings.getJQueryHotKeysJavaScriptReference());
  }
  if (settings.getPrettifyJavaScriptReference() != null) {
    this.add(settings.getPrettifyJavaScriptReference());
  }
}",0.9429559204840104
186485,"/** 
 * Constructor
 * @param id the markup-id
 * @param model the {@link IModel}
 * @param toolbar the {@link IWysiwygToolbar}
 */
public WysiwygEditor(String id,IModel<String> model,IWysiwygToolbar toolbar){
  super(id,model);
  this.container=new WebMarkupContainer(""String_Node_Str"");
  this.add(this.container);
  if (toolbar != null) {
    toolbar.attachToEditor(this.container);
  }
  this.setEscapeModelStrings(false);
}","/** 
 * Constructor
 * @param id the markup-id
 * @param model the {@link IModel}
 * @param toolbar the {@link IWysiwygToolbar}
 */
public WysiwygEditor(String id,IModel<String> model,IWysiwygToolbar toolbar){
  super(id,model);
  this.container=new WebMarkupContainer(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override protected void onComponentTag(    ComponentTag tag){
      super.onComponentTag(tag);
      if (!WysiwygEditor.this.getForm().isEnabled()) {
        tag.put(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
;
  this.add(this.container);
  if (toolbar != null) {
    toolbar.attachToEditor(this.container);
  }
  this.setEscapeModelStrings(false);
}",0.7535211267605634
186486,"/** 
 * Escape JSON quotes (  {@value #QUOTE})
 * @param value the string to escape
 * @return the escaped string
 */
public static String escapeQuotes(String value){
  return String.valueOf(value).replaceAll(QUOTE,""String_Node_Str"" + QUOTE);
}","/** 
 * Escape JSON quotes (  {@value #QUOTE})
 * @param value the string to escape
 * @return the escaped string
 */
public static String escapeQuotes(String value){
  return value.replaceAll(QUOTE,""String_Node_Str"" + QUOTE);
}",0.9449152542372882
186487,"/** 
 * Converts a string to its javascript representation. ie: ""myvalue"" (with the double quotes)<br/> If the supplied value is null, ""null"" is returned
 * @param value the object
 * @return the JSON value
 */
public static String asString(String value){
  return String.format(""String_Node_Str"",QUOTE,Options.escapeQuotes(value),QUOTE);
}","/** 
 * Converts a string to its javascript representation. ie: ""myvalue"" (with the double quotes)
 * @param value the object
 * @return the JSON value
 */
public static String asString(String value){
  return String.format(""String_Node_Str"",QUOTE,Options.escapeQuotes(value),QUOTE);
}",0.912
186488,"public SamplePage(){
  super();
  this.add(new Label(""String_Node_Str"",this.getResourceString(""String_Node_Str"")));
  this.add(new Label(""String_Node_Str"",this.getSource(Source.TEXT)).setEscapeModelStrings(false));
  this.add(new Label(""String_Node_Str"",this.getSource(Source.JAVA)));
  this.add(new Label(""String_Node_Str"",this.getSource(Source.HTML)));
  this.add(new JQueryUIBehavior(""String_Node_Str"",""String_Node_Str""));
  this.add(new ListView<DemoLink>(""String_Node_Str"",Model.ofList(this.getDemoLinks())){
    private static final long serialVersionUID=1L;
    @Override protected void populateItem(    ListItem<DemoLink> item){
      DemoLink object=item.getModelObject();
      Link<SamplePage> link=new BookmarkablePageLink<SamplePage>(""String_Node_Str"",object.getPage());
      link.add(new Label(""String_Node_Str"",object.getLabel()).setEscapeModelStrings(false));
      item.add(link);
    }
    @Override public boolean isVisible(){
      return !this.getModelObject().isEmpty();
    }
  }
);
}","public SamplePage(){
  super();
  this.add(new Label(""String_Node_Str"",this.getResourceString(""String_Node_Str"")));
  this.add(new Label(""String_Node_Str"",this.getSource(Source.TEXT)).setEscapeModelStrings(false));
  this.add(new Label(""String_Node_Str"",this.getSource(Source.JAVA)));
  this.add(new Label(""String_Node_Str"",this.getSource(Source.HTML)));
  this.add(new JQueryUIBehavior(""String_Node_Str"",""String_Node_Str""));
}",0.5951219512195122
186489,"private AjaxButton newForwardButton(){
  return new AjaxButton(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override protected String getIcon(){
      return JQueryIcon.CIRCLE_TRIANGLE_E;
    }
    @Override protected void onSubmit(    AjaxRequestTarget target,    Form<?> form){
      NavigationAjaxButton.this.onForward(target,this);
    }
  }
;
}","private final AjaxButton newForwardButton(){
  return new AjaxButton(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override protected String getIcon(){
      return JQueryIcon.CIRCLE_TRIANGLE_E;
    }
    @Override protected void onSubmit(    AjaxRequestTarget target,    Form<?> form){
      NavigationAjaxButton.this.onForward(target,this);
    }
  }
;
}",0.9921671018276762
186490,"private AjaxButton newBackwardButton(){
  return new AjaxButton(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override protected String getIcon(){
      return JQueryIcon.CIRCLE_TRIANGLE_W;
    }
    @Override protected void onSubmit(    AjaxRequestTarget target,    Form<?> form){
      NavigationAjaxButton.this.onBackward(target,this);
    }
  }
;
}","private final AjaxButton newBackwardButton(){
  return new AjaxButton(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override protected String getIcon(){
      return JQueryIcon.CIRCLE_TRIANGLE_W;
    }
    @Override protected void onSubmit(    AjaxRequestTarget target,    Form<?> form){
      NavigationAjaxButton.this.onBackward(target,this);
    }
  }
;
}",0.9922077922077922
186491,"public void setCategory(Category category){
  this.category=category;
  if (this.category != null) {
    this.setColor(this.category.getColor());
    this.setClassName(this.category.toString());
  }
}","public final void setCategory(Category category){
  this.category=category;
  if (this.category != null) {
    this.setColor(this.category.getColor());
    this.setClassName(this.category.toString());
  }
}",0.9852216748768472
186492,"protected int newId(){
  return ++this.id;
}","protected final int newId(){
  return ++this.id;
}",0.9361702127659576
186493,"private List<Book> newBookList(){
  return Arrays.asList(new Book(""String_Node_Str"",25.64f,""String_Node_Str""),new Book(""String_Node_Str"",31.59f,""String_Node_Str""),new Book(""String_Node_Str"",29.21f,""String_Node_Str""),new Book(""String_Node_Str"",30.22f,""String_Node_Str""));
}","private static List<Book> newBookList(){
  return Arrays.asList(new Book(""String_Node_Str"",25.64f,""String_Node_Str""),new Book(""String_Node_Str"",31.59f,""String_Node_Str""),new Book(""String_Node_Str"",29.21f,""String_Node_Str""),new Book(""String_Node_Str"",30.22f,""String_Node_Str""));
}",0.9872958257713248
186494,"public ShoppingDroppablePage(){
  this.books=this.newBookList();
  this.orders=new ArrayList<Book>();
  this.initialize();
}","public ShoppingDroppablePage(){
  this.books=newBookList();
  this.orders=new ArrayList<Book>();
  this.initialize();
}",0.9794238683127572
186495,"protected FeedbackMessagesModel newFeedbackMessagesModel(){
  return new FeedbackMessagesModel(this,new ErrorLevelFeedbackMessageFilter(FeedbackMessage.ERROR));
}","protected final FeedbackMessagesModel newFeedbackMessagesModel(){
  return new FeedbackMessagesModel(this,new ErrorLevelFeedbackMessageFilter(FeedbackMessage.ERROR));
}",0.9818181818181818
186496,"public Item(String name){
  this.name=name;
}","public Item(String name){
  this.name=Args.notNull(name,""String_Node_Str"");
}",0.7377049180327869
186497,"@Override public void onAjax(AjaxRequestTarget target,JQueryEvent event){
  if (event instanceof SortableEvent) {
    SortableEvent ev=(SortableEvent)event;
    int hash=ev.getHash();
    int index=ev.getIndex();
    if (event instanceof UpdateEvent) {
      List<T> list=this.getItemList();
      if (list != null) {
        this.onUpdate(target,ListUtils.fromHash(hash,list),index);
      }
    }
    if (event instanceof ReceiveEvent) {
      List<T> list=this.getConnectedList();
      if (list.size() > 0) {
        this.onReceive(target,ListUtils.fromHash(hash,list),index);
      }
    }
    if (event instanceof RemoveEvent) {
      List<T> list=this.getItemList();
      if (list != null) {
        this.onRemove(target,ListUtils.fromHash(hash,list));
      }
    }
  }
}","@Override public void onAjax(AjaxRequestTarget target,JQueryEvent event){
  if (event instanceof SortableEvent) {
    SortableEvent ev=(SortableEvent)event;
    int hash=ev.getHash();
    int index=ev.getIndex();
    if (event instanceof UpdateEvent) {
      List<T> list=this.getItemList();
      if (list != null) {
        this.onUpdate(target,ListUtils.fromHash(hash,list),index);
      }
    }
    if (event instanceof ReceiveEvent) {
      List<T> list=this.getConnectedList();
      if (!list.isEmpty()) {
        this.onReceive(target,ListUtils.fromHash(hash,list),index);
      }
    }
    if (event instanceof RemoveEvent) {
      List<T> list=this.getItemList();
      if (list != null) {
        this.onRemove(target,ListUtils.fromHash(hash,list));
      }
    }
  }
}",0.9807692307692308
186498,"@Override protected String getModelValue(){
  return this.renderer.getText(this.getModelObject());
}","@Override protected final String getModelValue(){
  return this.renderer.getText(this.getModelObject());
}",0.970873786407767
186499,"/** 
 * Parses a value as a String and returns a Number.<br/>
 * @param value the string to parse
 * @param min the minimum allowed value
 * @param max the maximum allowed value
 * @param locale the {@link Locale}
 * @return the converted number
 */
protected N parse(String value,final double min,final double max,Locale locale){
  if (value == null) {
    return null;
  }
  final NumberFormat format=NumberFormat.getCurrencyInstance(locale);
  final N number=this.parse(format,value,locale);
  if (number == null) {
    return null;
  }
  if (number.doubleValue() < min) {
    throw newConversionException(""String_Node_Str"" + min,value,locale).setFormat(format);
  }
  if (number.doubleValue() > max) {
    throw newConversionException(""String_Node_Str"" + max,value,locale).setFormat(format);
  }
  return number;
}","/** 
 * Parses a value as a String and returns a Number.<br/>
 * @param value the string to parse
 * @param min the minimum allowed value
 * @param max the maximum allowed value
 * @param locale the {@link Locale}
 * @return the converted number
 * @throws ConversionException
 */
protected N parse(String value,final double min,final double max,Locale locale) throws ConversionException {
  if (value == null) {
    return null;
  }
  final NumberFormat format=NumberFormat.getCurrencyInstance(locale);
  final N number=this.parse(format,value,locale);
  if (number == null) {
    return null;
  }
  if (number.doubleValue() < min) {
    throw newConversionException(""String_Node_Str"" + min,value,locale).setFormat(format);
  }
  if (number.doubleValue() > max) {
    throw newConversionException(""String_Node_Str"" + max,value,locale).setFormat(format);
  }
  return number;
}",0.9651917404129794
186500,"@Override protected String getModelValue(){
  return this.renderer.getText(this.getModelObject());
}","@Override protected final String getModelValue(){
  return this.renderer.getText(this.getModelObject());
}",0.970873786407767
186501,"/** 
 * Sets the label's markupId on which the current slide value will be displayed.<br/> <b>Warning:</b> It cannot be set/changed once the Component has been initialized.
 * @param markupId the label's markupId
 * @return this
 */
public AbstractSlider<T> setLabelId(String markupId){
  this.labelId=markupId;
  return this;
}","/** 
 * Sets the label's markupId on which the current slide value will be displayed.<br/> <b>Warning:</b> It cannot be set/changed once the Component has been initialized.
 * @param markupId the label's markupId
 * @return this
 */
public final AbstractSlider<T> setLabelId(String markupId){
  this.labelId=markupId;
  return this;
}",0.9909365558912386
186502,"/** 
 * Initialization
 */
@Override void initialize(){
  super.initialize();
  this.setRange(true);
}","/** 
 * Initialization
 */
@Override final void initialize(){
  super.initialize();
  this.setRange(true);
}",0.9714285714285714
186503,"@SuppressWarnings(""String_Node_Str"") protected void setSort(String property,SortOrder order){
  ISortStateLocator<String> locator=((ISortStateLocator<String>)this.provider);
  locator.getSortState().setPropertySortOrder(property,order);
}","@SuppressWarnings(""String_Node_Str"") protected void setSort(String property,SortOrder order){
  ISortStateLocator<String> locator=(ISortStateLocator<String>)this.provider;
  locator.getSortState().setPropertySortOrder(property,order);
}",0.9957805907172996
186504,"@Override public List<String> getAggregates(){
  return null;
}","@Override public List<String> getAggregates(){
  return Collections.emptyList();
}",0.8413793103448276
186505,"@Override public String toString(){
  StringBuilder builder=new StringBuilder();
  builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getTitle()).append(Options.QUOTE);
  builder.append(""String_Node_Str"");
  builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getField()).append(Options.QUOTE);
  builder.append(""String_Node_Str"");
  builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(!this.isVisible());
  if (this.getWidth() > 0) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getWidth());
  }
  if (this.getFormat() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getFormat()).append(Options.QUOTE);
  }
  if (this.getGroupHeaderTemplate() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getGroupHeaderTemplate()).append(Options.QUOTE);
  }
  if (this.getGroupFooterTemplate() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getGroupFooterTemplate()).append(Options.QUOTE);
  }
  if (this.getMenu() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getMenu());
  }
  if (this.getAggregates() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getAggregatesAsString());
  }
  if (this.getFilterable() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getFilterable());
  }
  return builder.toString();
}","@Override public String toString(){
  StringBuilder builder=new StringBuilder();
  builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getTitle()).append(Options.QUOTE);
  builder.append(""String_Node_Str"");
  builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getField()).append(Options.QUOTE);
  builder.append(""String_Node_Str"");
  builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(!this.isVisible());
  if (this.getWidth() > 0) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getWidth());
  }
  if (this.getFormat() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getFormat()).append(Options.QUOTE);
  }
  if (this.getGroupHeaderTemplate() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getGroupHeaderTemplate()).append(Options.QUOTE);
  }
  if (this.getGroupFooterTemplate() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(this.getGroupFooterTemplate()).append(Options.QUOTE);
  }
  if (this.getMenu() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getMenu());
  }
  if (!this.getAggregates().isEmpty()) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getAggregatesAsString());
  }
  if (this.getFilterable() != null) {
    builder.append(""String_Node_Str"");
    builder.append(Options.QUOTE).append(""String_Node_Str"").append(Options.QUOTE).append(""String_Node_Str"").append(this.getFilterable());
  }
  return builder.toString();
}",0.8880358285348688
186506,"/** 
 * Exports a row to the output
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param row the row of typed objects
 * @param writer the {@link PrintWriter}
 */
private <T>void exportRow(IDataProvider<T> provider,List<IExportableColumn> columns,T row,PrintWriter writer){
  boolean first=true;
  for (  IExportableColumn column : columns) {
    if (first) {
      first=false;
    }
 else {
      writer.print(this.delimiter);
    }
    Object object=column.newDataModel(provider.model(row)).getObject();
    if (object != null) {
      String value=ConverterUtils.toString(object);
      writer.print(this.quoteValue(value));
    }
  }
  writer.print(CRLF);
}","/** 
 * Exports a row to the output
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param row the row of typed objects
 * @param writer the {@link PrintWriter}
 */
private <T>void exportRow(IDataProvider<T> provider,List<IExportableColumn> columns,T row,PrintWriter writer){
  boolean first=true;
  for (  IExportableColumn column : columns) {
    if (first) {
      first=false;
    }
 else {
      writer.print(CSVDataExporter.delimiter);
    }
    Object object=column.newDataModel(provider.model(row)).getObject();
    if (object != null) {
      String value=ConverterUtils.toString(object);
      writer.print(this.quoteValue(value));
    }
  }
  writer.print(CRLF);
}",0.986722571628232
186507,"/** 
 * Writes the headers to the output
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param writer the {@link PrintWriter}
 */
private void exportHeaders(List<IExportableColumn> columns,PrintWriter writer){
  boolean first=true;
  for (  IExportableColumn column : columns) {
    if (first) {
      first=false;
    }
 else {
      writer.print(this.delimiter);
    }
    writer.print(this.quoteValue(column.getTitle()));
  }
  writer.print(CRLF);
}","/** 
 * Writes the headers to the output
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param writer the {@link PrintWriter}
 */
private void exportHeaders(List<IExportableColumn> columns,PrintWriter writer){
  boolean first=true;
  for (  IExportableColumn column : columns) {
    if (first) {
      first=false;
    }
 else {
      writer.print(CSVDataExporter.delimiter);
    }
    writer.print(this.quoteValue(column.getTitle()));
  }
  writer.print(CRLF);
}",0.981169474727453
186508,"/** 
 * Exports the data provided by the   {@link IDataProvider} to the {@link OutputStream}.
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param output the {@link OutputStream}
 * @param first the first row of datacount
 * @param count the number of elements to retrieve
 * @throws IOException
 */
public <T>void exportData(IDataProvider<T> provider,List<IExportableColumn> columns,OutputStream output,long first,long count) throws IOException {
  PrintWriter writer=new PrintWriter(new OutputStreamWriter(output,Charset.forName(this.characterSet)));
  try {
    if (this.isExportHeadersEnabled()) {
      this.exportHeaders(columns,writer);
    }
    Iterator<? extends T> iterator=provider.iterator(first,count);
    while (iterator.hasNext()) {
      this.exportRow(provider,columns,iterator.next(),writer);
    }
  }
  finally {
    writer.close();
  }
}","/** 
 * Exports the data provided by the   {@link IDataProvider} to the {@link OutputStream}.
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param output the {@link OutputStream}
 * @param first the first row of datacount
 * @param count the number of elements to retrieve
 * @throws IOException
 */
public <T>void exportData(IDataProvider<T> provider,List<IExportableColumn> columns,OutputStream output,long first,long count) throws IOException {
  PrintWriter writer=new PrintWriter(new OutputStreamWriter(output,Charset.forName(CSVDataExporter.characterSet)));
  try {
    if (this.isExportHeadersEnabled()) {
      this.exportHeaders(columns,writer);
    }
    Iterator<? extends T> iterator=provider.iterator(first,count);
    while (iterator.hasNext()) {
      this.exportRow(provider,columns,iterator.next(),writer);
    }
  }
  finally {
    writer.close();
  }
}",0.9896004378763
186509,"/** 
 * Indicates whether headers will be written to the output
 * @return true or false
 */
public boolean isExportHeadersEnabled();","/** 
 * Indicates whether headers will be written to the output
 * @return true or false
 */
boolean isExportHeadersEnabled();",0.972972972972973
186510,"/** 
 * Gets the content type
 * @return the content type
 */
public String getContentType();","/** 
 * Gets the content type
 * @return the content type
 */
String getContentType();",0.9608938547486032
186511,"/** 
 * Exports all data provided by the   {@link IDataProvider} to the {@link OutputStream}.
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param output the {@link OutputStream}
 * @throws IOException
 */
public <T>void exportData(IDataProvider<T> provider,List<IExportableColumn> columns,OutputStream output) throws IOException ;","/** 
 * Exports all data provided by the   {@link IDataProvider} to the {@link OutputStream}.
 * @param provider the {@link IDataProvider}
 * @param columns the list of {@link IColumn}
 * @param output the {@link OutputStream}
 * @throws IOException
 */
<T>void exportData(IDataProvider<T> provider,List<IExportableColumn> columns,OutputStream output) throws IOException ;",0.9906790945406124
186512,"/** 
 * Refreshes the ProgressBar.<br/> This method needs to be called after the model object changes.<br/> But It is not required to be called when calling forward or backward methods.
 * @param target the {@link AjaxRequestTarget}
 */
public final void refresh(AjaxRequestTarget target){
  String $=String.format(""String_Node_Str"",JQueryWidget.getSelector(this),ProgressBarBehavior.METHOD);
  target.appendJavaScript(String.format(""String_Node_Str"",$,this.getModelObject()));
}","/** 
 * Refreshes the ProgressBar.<br/> This method needs to be called after the model object changes.<br/> But It is not required to be called when calling forward or backward methods.
 * @param target the {@link AjaxRequestTarget}
 */
public final void refresh(AjaxRequestTarget target){
  String widget=String.format(""String_Node_Str"",JQueryWidget.getSelector(this),ProgressBarBehavior.METHOD);
  target.appendJavaScript(String.format(""String_Node_Str"",widget,this.getModelObject()));
}",0.9855371900826446
186513,"@Override public String toString(){
  DateFormat df=new SimpleDateFormat(""String_Node_Str"");
  df.setTimeZone(UTC);
  return String.format(""String_Node_Str"",df.format(this.getStart()),df.format(this.getEnd()));
}","@Override public String toString(){
  DateFormat df=new SimpleDateFormat(PATTERN);
  df.setTimeZone(UTC);
  return String.format(""String_Node_Str"",df.format(this.getStart()),df.format(this.getEnd()));
}",0.4541062801932367
186514,"/** 
 * Gets a new   {@link DateFormat} to be used by the {@link TextField}'s   {@link IConverter}
 * @param locale the {@link Locale}
 * @return the {@link DateFormat}
 */
protected DateFormat newDateFormat(Locale locale){
  return new SimpleDateFormat(""String_Node_Str"",locale);
}","/** 
 * Gets a new   {@link DateFormat} to be used by the {@link TextField}'s   {@link IConverter}
 * @param locale the {@link Locale}
 * @return the {@link DateFormat}
 */
protected DateFormat newDateFormat(Locale locale){
  DateFormat df=new SimpleDateFormat(""String_Node_Str"",locale);
  df.setTimeZone(DateRange.UTC);
  return df;
}",0.8881685575364667
186515,"public RangeDatePickerPage(){
  final Options options=new Options();
  options.set(""String_Node_Str"",true);
  options.set(""String_Node_Str"",3);
  final FeedbackPanel feedback=new JQueryFeedbackPanel(""String_Node_Str"");
  this.add(feedback.setOutputMarkupId(true));
  this.add(new RangeDatePicker(""String_Node_Str"",new Model<DateRange>(DateRange.today()),options){
    private static final long serialVersionUID=1L;
    @Override public void onValueChanged(    AjaxRequestTarget target,    DateRange range){
      DateFormat df=new SimpleDateFormat(""String_Node_Str"");
      info(String.format(""String_Node_Str"",df.format(range.getStart()),df.format(range.getEnd())));
      target.add(feedback);
    }
  }
);
}","public RangeDatePickerPage(){
  final Options options=new Options();
  options.set(""String_Node_Str"",true);
  options.set(""String_Node_Str"",3);
  final FeedbackPanel feedback=new JQueryFeedbackPanel(""String_Node_Str"");
  this.add(feedback.setOutputMarkupId(true));
  this.add(new RangeDatePicker(""String_Node_Str"",new Model<DateRange>(DateRange.today()),options){
    private static final long serialVersionUID=1L;
    @Override public void onValueChanged(    AjaxRequestTarget target,    DateRange range){
      DateFormat df=new SimpleDateFormat(""String_Node_Str"");
      df.setTimeZone(DateRange.UTC);
      this.info(String.format(""String_Node_Str"",df.format(range.getStart()),df.format(range.getEnd())));
      target.add(feedback);
    }
  }
);
}",0.950752393980848
186516,"@Override public void onValueChanged(AjaxRequestTarget target,DateRange range){
  DateFormat df=new SimpleDateFormat(""String_Node_Str"");
  info(String.format(""String_Node_Str"",df.format(range.getStart()),df.format(range.getEnd())));
  target.add(feedback);
}","@Override public void onValueChanged(AjaxRequestTarget target,DateRange range){
  DateFormat df=new SimpleDateFormat(""String_Node_Str"");
  df.setTimeZone(DateRange.UTC);
  this.info(String.format(""String_Node_Str"",df.format(range.getStart()),df.format(range.getEnd())));
  target.add(feedback);
}",0.9314079422382672
186517,"public RangeDatePickerTextFieldPage(){
  Form<Void> form=new Form<Void>(""String_Node_Str"");
  this.add(form);
  final FeedbackPanel feedback=new JQueryFeedbackPanel(""String_Node_Str"");
  form.add(feedback.setOutputMarkupId(true));
  final IModel<DateRange> model=new Model<DateRange>(new DateRange(new Date(new Date().getTime() - Duration.ONE_DAY.getMilliseconds() * 3),new Date()));
  final RangeDatePickerTextField datepicker=new RangeDatePickerTextField(""String_Node_Str"",model);
  form.add(datepicker);
  form.add(new Button(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override public void onSubmit(){
      DateRange dateRange=datepicker.getModelObject();
      if (dateRange != null) {
        DateFormat df=new SimpleDateFormat(""String_Node_Str"");
        info(String.format(""String_Node_Str"",df.format(dateRange.getStart()),df.format(dateRange.getEnd())));
      }
 else {
        warn(""String_Node_Str"");
      }
    }
  }
);
}","public RangeDatePickerTextFieldPage(){
  Form<Void> form=new Form<Void>(""String_Node_Str"");
  this.add(form);
  final FeedbackPanel feedback=new JQueryFeedbackPanel(""String_Node_Str"");
  form.add(feedback.setOutputMarkupId(true));
  final IModel<DateRange> model=new Model<DateRange>(new DateRange(new Date(new Date().getTime() - Duration.ONE_DAY.getMilliseconds() * 3),new Date()));
  final RangeDatePickerTextField datepicker=new RangeDatePickerTextField(""String_Node_Str"",model);
  form.add(datepicker);
  form.add(new Button(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override public void onSubmit(){
      DateRange range=datepicker.getModelObject();
      if (range != null) {
        DateFormat df=new SimpleDateFormat(""String_Node_Str"");
        df.setTimeZone(DateRange.UTC);
        this.info(String.format(""String_Node_Str"",df.format(range.getStart()),df.format(range.getEnd())));
      }
 else {
        warn(""String_Node_Str"");
      }
    }
  }
);
}",0.9653767820773932
186518,"@Override public void onSubmit(){
  DateRange dateRange=datepicker.getModelObject();
  if (dateRange != null) {
    DateFormat df=new SimpleDateFormat(""String_Node_Str"");
    info(String.format(""String_Node_Str"",df.format(dateRange.getStart()),df.format(dateRange.getEnd())));
  }
 else {
    warn(""String_Node_Str"");
  }
}","@Override public void onSubmit(){
  DateRange range=datepicker.getModelObject();
  if (range != null) {
    DateFormat df=new SimpleDateFormat(""String_Node_Str"");
    df.setTimeZone(DateRange.UTC);
    this.info(String.format(""String_Node_Str"",df.format(range.getStart()),df.format(range.getEnd())));
  }
 else {
    warn(""String_Node_Str"");
  }
}",0.9044776119402984
186519,"/** 
 * Constructor
 * @param selector the html selector (ie: ""#myId"")
 * @param options the {@link Options}
 */
public WysiwygBehavior(String selector,Options options){
  super(selector,METHOD,options);
  IPackageResourceGuard packageResourceGuard=Application.get().getResourceSettings().getPackageResourceGuard();
  if (packageResourceGuard instanceof SecurePackageResourceGuard) {
    SecurePackageResourceGuard guard=(SecurePackageResourceGuard)packageResourceGuard;
    if (!guard.getPattern().contains(new SearchPattern(""String_Node_Str""))) {
      guard.addPattern(""String_Node_Str"");
      guard.addPattern(""String_Node_Str"");
      guard.addPattern(""String_Node_Str"");
    }
  }
  this.initReferences();
}","/** 
 * Constructor
 * @param selector the html selector (ie: ""#myId"")
 * @param options the {@link Options}
 */
public WysiwygBehavior(String selector,Options options){
  super(selector,METHOD,options);
  this.initReferences();
}",0.451271186440678
186520,"/** 
 * Constructor
 * @param id the markup-id
 * @param model the {@link IModel}
 * @param toolbar the {@link IWysiwygToolbar}
 */
public WysiwygEditor(String id,IModel<String> model,IWysiwygToolbar toolbar){
  super(id,model);
  this.container=new WebMarkupContainer(""String_Node_Str"");
  this.add(this.container);
  this.textarea=new TextArea<String>(""String_Node_Str"",Model.of(this.getModelObject()));
  this.textarea.setEscapeModelStrings(false);
  this.add(this.textarea.setOutputMarkupId(true));
  if (toolbar != null) {
    toolbar.attachToEditor(this.container);
  }
}","/** 
 * Constructor
 * @param id the markup-id
 * @param model the {@link IModel}
 * @param toolbar the {@link IWysiwygToolbar}
 */
public WysiwygEditor(String id,IModel<String> model,IWysiwygToolbar toolbar){
  super(id,model);
  this.container=new WebMarkupContainer(""String_Node_Str"");
  this.add(this.container);
  if (toolbar != null) {
    toolbar.attachToEditor(this.container);
  }
}",0.8078512396694215
186521,"@Override protected void onInitialize(){
  super.onInitialize();
  this.add(JQueryWidget.newWidgetBehavior(this,this.container));
}","@Override protected void onInitialize(){
  super.onInitialize();
  this.textarea=new TextArea<String>(""String_Node_Str"",this.getModel());
  this.textarea.setEscapeModelStrings(false);
  this.add(this.textarea.setOutputMarkupId(true));
  this.add(JQueryWidget.newWidgetBehavior(this,this.container));
}",0.6064814814814815
186522,"/** 
 * @see org.apache.wicket.Application#init()
 */
@Override public void init(){
  super.init();
  this.getMarkupSettings().setStripWicketTags(true);
  this.getResourceSettings().setThrowExceptionOnMissingResource(false);
  this.mountPage(""String_Node_Str"",SiteMapPage.class);
  this.mountPackage(""String_Node_Str"",DefaultAccordionPage.class);
  this.mountPackage(""String_Node_Str"",DefaultAutoCompletePage.class);
  this.mountPackage(""String_Node_Str"",DefaultButtonPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDatePickerPage.class);
  this.mountPackage(""String_Node_Str"",MessageDialogPage.class);
  this.mountPackage(""String_Node_Str"",DefaultMenuPage.class);
  this.mountPackage(""String_Node_Str"",ButtonProgressBarPage.class);
  this.mountPackage(""String_Node_Str"",DefaultSliderPage.class);
  this.mountPackage(""String_Node_Str"",DefaultSpinnerPage.class);
  this.mountPackage(""String_Node_Str"",DefaultTabsPage.class);
  this.mountPackage(""String_Node_Str"",DefaultTooltipPage.class);
  this.mountPackage(""String_Node_Str"",DefaultWizardPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDraggablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultDroppablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultResizablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultSelectablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultSortablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultEffectPage.class);
  this.mountPackage(""String_Node_Str"",DefaultEditorPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDropDownPage.class);
  this.mountPackage(""String_Node_Str"",DefaultComboBoxPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDataTablePage.class);
  this.mountPackage(""String_Node_Str"",KendoDatePickerPage.class);
  this.mountPackage(""String_Node_Str"",DefaultSplitterPage.class);
  this.mountPackage(""String_Node_Str"",DefaultConsolePage.class);
  this.mountPackage(""String_Node_Str"",DefaultCalendarPage.class);
  this.mountPackage(""String_Node_Str"",FontSizePage.class);
  this.mountPackage(""String_Node_Str"",RangeDatePickerPage.class);
  this.mountPackage(""String_Node_Str"",WysiwygEditorPage.class);
  this.mountPackage(""String_Node_Str"",TestPage.class);
}","/** 
 * @see org.apache.wicket.Application#init()
 */
@Override public void init(){
  super.init();
  this.getMarkupSettings().setStripWicketTags(true);
  this.getResourceSettings().setThrowExceptionOnMissingResource(false);
  this.mountPage(""String_Node_Str"",SiteMapPage.class);
  this.mountPackage(""String_Node_Str"",DefaultAccordionPage.class);
  this.mountPackage(""String_Node_Str"",DefaultAutoCompletePage.class);
  this.mountPackage(""String_Node_Str"",DefaultButtonPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDatePickerPage.class);
  this.mountPackage(""String_Node_Str"",MessageDialogPage.class);
  this.mountPackage(""String_Node_Str"",DefaultMenuPage.class);
  this.mountPackage(""String_Node_Str"",ButtonProgressBarPage.class);
  this.mountPackage(""String_Node_Str"",DefaultSliderPage.class);
  this.mountPackage(""String_Node_Str"",DefaultSpinnerPage.class);
  this.mountPackage(""String_Node_Str"",DefaultTabsPage.class);
  this.mountPackage(""String_Node_Str"",DefaultTooltipPage.class);
  this.mountPackage(""String_Node_Str"",DefaultWizardPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDraggablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultDroppablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultResizablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultSelectablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultSortablePage.class);
  this.mountPackage(""String_Node_Str"",DefaultEffectPage.class);
  this.mountPackage(""String_Node_Str"",DefaultEditorPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDropDownPage.class);
  this.mountPackage(""String_Node_Str"",DefaultComboBoxPage.class);
  this.mountPackage(""String_Node_Str"",DefaultDataTablePage.class);
  this.mountPackage(""String_Node_Str"",KendoDatePickerPage.class);
  this.mountPackage(""String_Node_Str"",DefaultSplitterPage.class);
  this.mountPackage(""String_Node_Str"",DefaultConsolePage.class);
  this.mountPackage(""String_Node_Str"",DefaultCalendarPage.class);
  this.mountPackage(""String_Node_Str"",FontSizePage.class);
  this.mountPackage(""String_Node_Str"",RangeDatePickerPage.class);
  this.mountPackage(""String_Node_Str"",WysiwygEditorPage.class);
  this.mountPackage(""String_Node_Str"",TestPage.class);
  this.mountPage(""String_Node_Str"",EditorPage.class);
}",0.9880530973451328
186523,"/** 
 * Constructor
 * @param title {@link IModel} that represent the title of the menu-item
 */
public AbstractSfMenuItem(IModel<String> title,Class<? extends Page> pageClass){
  this.title=title;
  this.pageClass=pageClass;
}","/** 
 * Constructor
 * @param title {@link IModel} that represent the title of the menu-item
 */
public AbstractSfMenuItem(IModel<String> title,Class<? extends Page> pageClass){
  this.title=title;
  if (pageClass != null) {
    this.pageClassProvider=new ClassReference(pageClass);
  }
 else {
    this.pageClassProvider=null;
  }
}",0.7785714285714286
186524,"/** 
 * Get the page class registered with the link
 * @return Page Class
 */
public Class<? extends Page> getPageClass(){
  return pageClass;
}","/** 
 * Get the page class registered with the link
 * @return Page Class
 */
public Class<? extends Page> getPageClass(){
  if (pageClassProvider != null) {
    return pageClassProvider.get();
  }
  return null;
}",0.7150837988826816
186525,"@Override protected void populateItem(ListItem<ISfMenuItem> item){
  ISfMenuItem menuItem=item.getModelObject();
  item.add(new ItemFragment(""String_Node_Str"",menuItem));
  item.add(new MenuFragment(""String_Node_Str"",menuItem.getItems()));
  item.add(AttributeModifier.replace(""String_Node_Str"",menuItem.getId()));
}","@Override protected void populateItem(ListItem<ISfMenuItem> item){
  ISfMenuItem menuItem=item.getModelObject();
  item.add(new ItemFragment(""String_Node_Str"",menuItem));
  item.add(new MenuFragment(""String_Node_Str"",menuItem.getItems()));
}",0.8653500897666068
186526,"public ListFragment(String id,List<ISfMenuItem> items){
  super(id,""String_Node_Str"",SfMenu.this);
  this.add(new ListView<ISfMenuItem>(""String_Node_Str"",items){
    private static final long serialVersionUID=1L;
    @Override protected void populateItem(    ListItem<ISfMenuItem> item){
      ISfMenuItem menuItem=item.getModelObject();
      item.add(new ItemFragment(""String_Node_Str"",menuItem));
      item.add(new MenuFragment(""String_Node_Str"",menuItem.getItems()));
      item.add(AttributeModifier.replace(""String_Node_Str"",menuItem.getId()));
    }
  }
);
}","public ListFragment(String id,List<ISfMenuItem> items){
  super(id,""String_Node_Str"",SfMenu.this);
  this.add(new ListView<ISfMenuItem>(""String_Node_Str"",items){
    private static final long serialVersionUID=1L;
    @Override protected void populateItem(    ListItem<ISfMenuItem> item){
      ISfMenuItem menuItem=item.getModelObject();
      item.add(new ItemFragment(""String_Node_Str"",menuItem));
      item.add(new MenuFragment(""String_Node_Str"",menuItem.getItems()));
    }
  }
);
}",0.9249762583095916
186527,"/** 
 * Constructor
 * @param selector
 * @param options
 */
public SfMenuBehavior(String selector,Options options,Boolean verticalSfMenu){
  super(selector,METHOD,options);
  this.add(new CssResourceReference(SfMenuBehavior.class,""String_Node_Str""));
  if (verticalSfMenu) {
    this.add(new CssResourceReference(SfMenuBehavior.class,""String_Node_Str""));
  }
  this.add(new JavaScriptResourceReference(SfMenuBehavior.class,""String_Node_Str""));
  this.add(new JavaScriptResourceReference(SfMenuBehavior.class,""String_Node_Str""));
}","/** 
 * Constructor
 * @param selector
 * @param options
 */
public SfMenuBehavior(String selector,Options options,Boolean verticalSfMenu){
  super(selector,METHOD,options);
  ISuperfishLibrarySettings settings=getLibrarySettings();
  if (settings.getSuperfishStyleSheetReference() != null) {
    this.add(settings.getSuperfishStyleSheetReference());
  }
  if (verticalSfMenu && settings.getSuperfishVerticalStyleSheetReference() != null) {
    this.add(settings.getSuperfishVerticalStyleSheetReference());
  }
  this.add(HoverIntentJavaScriptResourceReference.get());
  this.add(SuperfishJavaScriptResourceReference.get());
}",0.3370786516853932
186528,"@Override protected void onSubmit(AjaxRequestTarget target,Form<?> form){
  target.add(accordion.setActiveTab(2));
}","@Override protected void onSubmit(AjaxRequestTarget target,Form<?> form){
  target.add(accordion.setActiveTab(accordion.getLastTabIndex()));
}",0.8914728682170543
186529,"private List<ITab> newTabList(){
  List<ITab> tabs=new ArrayList<ITab>();
  tabs.add(new SimpleTab(new Model<String>(""String_Node_Str""),new Model<String>(""String_Node_Str"")));
  tabs.add(new AbstractTab(new Model<String>(""String_Node_Str"")){
    private static final long serialVersionUID=1L;
    @Override public WebMarkupContainer getPanel(    String panelId){
      return new Fragment(panelId,""String_Node_Str"",AccordionPanelPage.this);
    }
  }
);
  tabs.add(new AjaxTab(new Model<String>(""String_Node_Str"")){
    private static final long serialVersionUID=1L;
    @Override public WebMarkupContainer getLazyPanel(    String panelId){
      try {
        Thread.sleep(750);
      }
 catch (      InterruptedException e) {
        error(e.getMessage());
      }
      return new Fragment(panelId,""String_Node_Str"",AccordionPanelPage.this);
    }
  }
);
  return tabs;
}","private List<ITab> newTabList(){
  List<ITab> tabs=new ArrayList<ITab>();
  tabs.add(new SimpleTab(new Model<String>(""String_Node_Str""),new Model<String>(""String_Node_Str"")));
  tabs.add(new SimpleTab(new Model<String>(""String_Node_Str""),Model.of(""String_Node_Str"")){
    private static final long serialVersionUID=1L;
    @Override public boolean isVisible(){
      return false;
    }
  }
);
  tabs.add(new AbstractTab(new Model<String>(""String_Node_Str"")){
    private static final long serialVersionUID=1L;
    @Override public WebMarkupContainer getPanel(    String panelId){
      return new Fragment(panelId,""String_Node_Str"",AccordionPanelPage.this);
    }
  }
);
  tabs.add(new AjaxTab(new Model<String>(""String_Node_Str"")){
    private static final long serialVersionUID=1L;
    @Override public WebMarkupContainer getLazyPanel(    String panelId){
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
        error(e.getMessage());
      }
      return new Fragment(panelId,""String_Node_Str"",AccordionPanelPage.this);
    }
  }
);
  return tabs;
}",0.7202441505595117
186530,"public AccordionPanelPage(){
  final Form<?> form=new Form<Void>(""String_Node_Str"");
  this.add(form);
  final FeedbackPanel feedback=new JQueryFeedbackPanel(""String_Node_Str"");
  form.add(feedback.setOutputMarkupId(true));
  Options options=new Options();
  options.set(""String_Node_Str"",Options.asString(""String_Node_Str""));
  final AccordionPanel accordion=new AccordionPanel(""String_Node_Str"",this.newTabList(),options){
    private static final long serialVersionUID=1L;
    @Override public void onActivate(    AjaxRequestTarget target,    int index,    ITab tab){
      info(String.format(""String_Node_Str"",index,tab.getTitle().getObject()));
      target.add(feedback);
    }
  }
;
  form.add(accordion);
  form.add(new AjaxButton(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override protected void onSubmit(    AjaxRequestTarget target,    Form<?> form){
      target.add(accordion.setActiveTab(2));
    }
  }
);
}","public AccordionPanelPage(){
  final Form<?> form=new Form<Void>(""String_Node_Str"");
  this.add(form);
  final FeedbackPanel feedback=new JQueryFeedbackPanel(""String_Node_Str"");
  form.add(feedback.setOutputMarkupId(true));
  Options options=new Options();
  options.set(""String_Node_Str"",Options.asString(""String_Node_Str""));
  final AccordionPanel accordion=new AccordionPanel(""String_Node_Str"",this.newTabList(),options){
    private static final long serialVersionUID=1L;
    @Override public void onActivate(    AjaxRequestTarget target,    int index,    ITab tab){
      info(String.format(""String_Node_Str"",index,tab.getTitle().getObject()));
      target.add(feedback);
    }
  }
;
  form.add(accordion);
  form.add(new AjaxButton(""String_Node_Str""){
    private static final long serialVersionUID=1L;
    @Override protected void onSubmit(    AjaxRequestTarget target,    Form<?> form){
      target.add(accordion.setActiveTab(accordion.getLastTabIndex()));
    }
  }
);
}",0.9855371900826446
186531,"@Override public WebMarkupContainer getLazyPanel(String panelId){
  try {
    Thread.sleep(750);
  }
 catch (  InterruptedException e) {
    error(e.getMessage());
  }
  return new Fragment(panelId,""String_Node_Str"",AccordionPanelPage.this);
}","@Override public WebMarkupContainer getLazyPanel(String panelId){
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
    error(e.getMessage());
  }
  return new Fragment(panelId,""String_Node_Str"",AccordionPanelPage.this);
}",0.9958847736625516
186532,"@Override public void onAjax(AjaxRequestTarget target,JQueryEvent event){
  if (event instanceof ActivateEvent) {
    int index=((ActivateEvent)event).getIndex();
    if (-1 < index && index < this.getTabs().size()) {
      ITab tab=this.getTabs().get(index);
      if (tab instanceof AjaxTab) {
        ((AjaxTab)tab).load(target);
      }
      this.onActivate(target,index,tab);
    }
  }
}","@Override public void onAjax(AjaxRequestTarget target,JQueryEvent event){
  if (event instanceof ActivateEvent) {
    int index=((ActivateEvent)event).getIndex();
    List<ITab> tabs=this.getVisibleTabs();
    if (-1 < index && index < tabs.size()) {
      ITab tab=tabs.get(index);
      if (tab instanceof AjaxTab) {
        ((AjaxTab)tab).load(target);
      }
      this.onActivate(target,index,tab);
    }
  }
}",0.5241038318912238
186533,"@Override protected LoopItem newItem(final int index){
  return new LoopItem(index){
    private static final long serialVersionUID=1L;
    @Override protected void onConfigure(){
      super.onConfigure();
      ITab tab=AccordionPanel.this.getModelObject().get(index);
      setVisible(tab.isVisible());
    }
  }
;
}","@Override protected LoopItem newItem(final int index){
  return new LoopItem(index){
    private static final long serialVersionUID=1L;
    @Override protected void onConfigure(){
      super.onConfigure();
      ITab tab=AccordionPanel.this.getModelObject().get(index);
      this.setVisible(tab.isVisible());
    }
  }
;
}",0.9922239502332816
186534,"@Override protected void onInitialize(){
  super.onInitialize();
  this.add(new Loop(""String_Node_Str"",this.getCountModel()){
    private static final long serialVersionUID=1L;
    @Override protected LoopItem newItem(    final int index){
      return new LoopItem(index){
        private static final long serialVersionUID=1L;
        @Override protected void onConfigure(){
          super.onConfigure();
          ITab tab=AccordionPanel.this.getModelObject().get(index);
          setVisible(tab.isVisible());
        }
      }
;
    }
    @Override protected void populateItem(    LoopItem item){
      int index=item.getIndex();
      final ITab tab=AccordionPanel.this.getModelObject().get(index);
      item.add(AccordionPanel.this.newTitleLabel(""String_Node_Str"",tab.getTitle()));
      item.add(tab.getPanel(""String_Node_Str""));
    }
  }
);
  this.add(this.widgetBehavior=this.newWidgetBehavior(JQueryWidget.getSelector(this)));
}","@Override protected void onInitialize(){
  super.onInitialize();
  this.add(new Loop(""String_Node_Str"",this.getCountModel()){
    private static final long serialVersionUID=1L;
    @Override protected LoopItem newItem(    final int index){
      return new LoopItem(index){
        private static final long serialVersionUID=1L;
        @Override protected void onConfigure(){
          super.onConfigure();
          ITab tab=AccordionPanel.this.getModelObject().get(index);
          this.setVisible(tab.isVisible());
        }
      }
;
    }
    @Override protected void populateItem(    LoopItem item){
      int index=item.getIndex();
      final ITab tab=AccordionPanel.this.getModelObject().get(index);
      item.add(AccordionPanel.this.newTitleLabel(""String_Node_Str"",tab.getTitle()));
      item.add(tab.getPanel(""String_Node_Str""));
    }
  }
);
  this.add(this.widgetBehavior=this.newWidgetBehavior(JQueryWidget.getSelector(this)));
}",0.9973530968766544
186535,"@Override protected void onConfigure(){
  super.onConfigure();
  ITab tab=AccordionPanel.this.getModelObject().get(index);
  setVisible(tab.isVisible());
}","@Override protected void onConfigure(){
  super.onConfigure();
  ITab tab=AccordionPanel.this.getModelObject().get(index);
  this.setVisible(tab.isVisible());
}",0.984126984126984
186536,"/** 
 * Constructor
 * @param title {@link IModel} that represent the title of the menu-item
 * @param icon the icon css class (ie: ui-my-icon)
 */
public AbstractMenuItem(IModel<String> title,String icon){
  this.title=title;
  this.icon=icon;
}","/** 
 * Constructor
 * @param title {@link IModel} that represent the title of the menu-item
 * @param icon the icon css class; <code>'ui-icon-blank'</code> or {@link JQueryIcon#BLANK} may be used to not display any icon.
 */
public AbstractMenuItem(IModel<String> title,String icon){
  this.title=title;
  this.icon=icon;
}",0.8175438596491228
186537,"@Override public String getText(T object,String expression){
  if (expression != null) {
    Object value=PropertyResolver.getValue(expression,object);
    if (value != null) {
      return value.toString();
    }
  }
  if (object != null) {
    return object.toString();
  }
  return ""String_Node_Str"";
}","@Override public String getText(T object,String expression){
  if (expression != null) {
    Object value=PropertyResolver.getValue(expression,object);
    if (value != null) {
      return value.toString();
    }
  }
  return ""String_Node_Str"";
}",0.894927536231884
186538,"/** 
 * Adds a reference to be added at   {@link #renderHead(Component,IHeaderResponse)} time.
 * @param reference a {@link CssResourceReference}, a   {@link JavaScriptResourceReference}
 * @return true (as specified by Collection.add(E)) 
 */
protected boolean add(ResourceReference reference){
  return this.references.add(reference);
}","/** 
 * Adds a reference to be added at   {@link #renderHead(Component,IHeaderResponse)} time.
 * @param reference a {@link CssResourceReference} or a {@link JavaScriptResourceReference}
 * @return true (as specified by Collection.add(E)) 
 */
protected boolean add(ResourceReference reference){
  return this.references.add(reference);
}",0.985207100591716
186539,"@Override public void renderHead(Component component,IHeaderResponse response){
  response.renderJavaScriptReference(JQueryAbstractBehavior.CORE_JS);
  response.renderJavaScriptReference(JQueryAbstractBehavior.CORE_UI);
  for (  ResourceReference reference : this.references) {
    if (reference instanceof JavaScriptResourceReference) {
      response.renderJavaScriptReference(reference);
    }
    if (reference instanceof CssResourceReference) {
      response.renderCSSReference(reference);
    }
  }
  response.renderJavaScript(this.$(),this.getToken());
}","@Override public void renderHead(Component component,IHeaderResponse response){
  if (JQueryLibrarySettings.CORE_JS != null) {
    response.renderJavaScriptReference(JQueryLibrarySettings.CORE_JS);
  }
  if (JQueryLibrarySettings.CORE_UI != null) {
    response.renderJavaScriptReference(JQueryLibrarySettings.CORE_UI);
  }
  for (  ResourceReference reference : this.references) {
    if (reference instanceof JavaScriptResourceReference) {
      response.renderJavaScriptReference(reference);
    }
    if (reference instanceof CssResourceReference) {
      response.renderCSSReference(reference);
    }
  }
  response.renderJavaScript(this.$(),this.getToken());
}",0.755700325732899
186540,"@Override public void renderHead(Component component,IHeaderResponse response){
  super.renderHead(component,response);
  response.renderJavaScriptReference(JQueryAbstractBehavior.CORE_JS);
  response.renderJavaScriptReference(JQueryAbstractTemplateBehavior.TMPL_JS);
  response.renderString(this.newResourceStream().getString());
}","@Override public void renderHead(Component component,IHeaderResponse response){
  super.renderHead(component,response);
  if (JQueryLibrarySettings.CORE_JS != null) {
    response.renderJavaScriptReference(JQueryLibrarySettings.CORE_JS);
  }
  response.renderJavaScriptReference(JQueryAbstractTemplateBehavior.TMPL_JS);
  response.renderString(this.newResourceStream().getString());
}",0.7932960893854749
186541,"@Override public void onClick(AjaxRequestTarget target){
  if (AjaxTab.this.state == STATE_LOAD) {
    Component inner=AjaxTab.this.panel.getInnerLabel();
    Component panel=AjaxTab.this.getLazyPanel();
    target.add(inner.replaceWith(panel));
    AjaxTab.this.state=STATE_ADDED;
    this.getPage().dirty();
  }
}","@Override public void onClick(AjaxRequestTarget target){
  if (AjaxTab.this.state == STATE_LOAD) {
    AjaxTab.this.container=AjaxTab.this.getLazyPanel();
    target.add(AjaxTab.this.replaceComponent());
    AjaxTab.this.state=STATE_ADDED;
    this.getPage().dirty();
  }
}",0.782312925170068
186542,"/** 
 * Gets the default panel (loading indicator)
 */
public final Panel getPanel(String panelId){
  this.panel=new LoadingPanel(panelId);
  this.state=STATE_LOAD;
  return this.panel;
}","/** 
 * Gets the default panel (loading indicator)
 */
public final WebMarkupContainer getPanel(String panelId){
  this.panel=new LoadingPanel(panelId);
  if (this.state == STATE_INIT) {
    this.state=STATE_LOAD;
  }
 else   if (this.state == STATE_ADDED) {
    this.replaceComponent();
  }
  return this.panel;
}",0.7265469061876247
186543,"/** 
 * Gets the   {@link AjaxLink} for this {@link ITab}, which will handle the lazy-panel load.
 * @param id the markup id
 * @return the {@link AjaxLink}
 */
public AjaxLink<Void> newLink(String id){
  return new AjaxLink<Void>(id){
    private static final long serialVersionUID=1L;
    @Override public void onClick(    AjaxRequestTarget target){
      if (AjaxTab.this.state == STATE_LOAD) {
        Component inner=AjaxTab.this.panel.getInnerLabel();
        Component panel=AjaxTab.this.getLazyPanel();
        target.add(inner.replaceWith(panel));
        AjaxTab.this.state=STATE_ADDED;
        this.getPage().dirty();
      }
    }
  }
;
}","/** 
 * Gets the   {@link AjaxLink} for this {@link ITab}, which will handle the lazy-panel load.
 * @param id the markup id
 * @return the {@link AjaxLink}
 */
public AjaxLink<Void> newLink(String id){
  return new AjaxLink<Void>(id){
    private static final long serialVersionUID=1L;
    @Override public void onClick(    AjaxRequestTarget target){
      if (AjaxTab.this.state == STATE_LOAD) {
        AjaxTab.this.container=AjaxTab.this.getLazyPanel();
        target.add(AjaxTab.this.replaceComponent());
        AjaxTab.this.state=STATE_ADDED;
        this.getPage().dirty();
      }
    }
  }
;
}",0.8931419457735247
186544,"private static void f_monitorexit(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.unlock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    throw JVMHelp.IMSExc;
  }
  entry_count[index]--;
  c.lockLevel--;
  if (entry_count[index] == 0) {
    if (queue_front[index] == queue_back[index]) {
      queue_front[index]=0;
      queue_back[index]=0;
      cam.RESET=0;
      entries--;
    }
 else {
      queue_front[index]=c.lockQueue;
    }
    c.lockQueue=0;
  }
  if (c.lockLevel == 0) {
    Native.wr(0xffffffff,Const.IO_INTMASK);
  }
  Native.unlock();
}","private static void f_monitorexit(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.unlock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    throw JVMHelp.IMSExc;
  }
  entry_count[index]--;
  c.lockLevel--;
  if (entry_count[index] == 0) {
    if (queue_front[index] == 0) {
      cam.RESET=0;
      entries--;
    }
 else {
      int new_owner=queue_front[index];
      current_owner[index]=new_owner;
      RtThreadImpl t=Native.toRtThreadImpl(new_owner);
      if (t.lockQueue != 0) {
        queue_front[index]=t.lockQueue;
      }
 else {
        queue_front[index]=0;
        queue_back[index]=0;
      }
      t.lockQueue=0;
    }
    if (c.lockLevel == 0) {
      Native.wr(0xffffffff,Const.IO_INTMASK);
    }
  }
  Native.unlock();
}",0.7989041095890411
186545,"private static void f_monitorenter(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.lock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    entries++;
    if (entries >= Const.CAM_SIZE) {
      throw JVMHelp.IMSExc;
    }
    queue_front[index]=current_thread;
    queue_back[index]=queue_front[index];
  }
 else {
    if (queue_front[index] != current_thread) {
      RtThreadImpl t=Native.toRtThreadImpl(queue_back[index]);
      t.lockQueue=current_thread;
      queue_back[index]=current_thread;
      Native.wr(0xfffffffe,Const.IO_INTMASK);
      Native.unlock();
      for (; ; ) {
        Native.lock();
        if (queue_front[index] == current_thread) {
          break;
        }
        Native.unlock();
      }
    }
  }
  c.lockLevel++;
  entry_count[index]++;
  Native.unlock();
}","private static void f_monitorenter(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.lock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    entries++;
    if (entries >= Const.CAM_SIZE) {
      throw JVMHelp.IMSExc;
    }
    current_owner[index]=current_thread;
  }
 else {
    if (current_owner[index] != current_thread) {
      if (queue_front[index] == 0) {
        queue_front[index]=current_thread;
        queue_back[index]=current_thread;
      }
 else {
        RtThreadImpl t=Native.toRtThreadImpl(queue_back[index]);
        t.lockQueue=current_thread;
        queue_back[index]=current_thread;
      }
      Native.wr(0xfffffffe,Const.IO_INTMASK);
      Native.unlock();
      for (; ; ) {
        Native.lock();
        if (current_owner[index] == current_thread) {
          break;
        }
        Native.unlock();
      }
    }
  }
  c.lockLevel++;
  entry_count[index]++;
  Native.unlock();
}",0.8635547576301615
186546,"private static void f_monitorexit(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.unlock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    throw JVMHelp.IMSExc;
  }
  entry_count[index]--;
  if (entry_count[index] == 0) {
    Native.wr(0xffffffff,Const.IO_INTMASK);
    if (queue_front[index] == queue_back[index]) {
      queue_front[index]=0;
      queue_back[index]=0;
      cam.RESET=0;
      entries--;
    }
 else {
      queue_front[index]=c.lockQueue;
      c.lockQueue=0;
    }
  }
  Native.unlock();
}","private static void f_monitorexit(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.unlock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    throw JVMHelp.IMSExc;
  }
  entry_count[index]--;
  c.lockLevel--;
  if (entry_count[index] == 0) {
    if (queue_front[index] == queue_back[index]) {
      queue_front[index]=0;
      queue_back[index]=0;
      cam.RESET=0;
      entries--;
    }
 else {
      queue_front[index]=c.lockQueue;
    }
    c.lockQueue=0;
  }
  if (c.lockLevel == 0) {
    Native.wr(0xffffffff,Const.IO_INTMASK);
  }
  Native.unlock();
}",0.6721003134796238
186547,"private static void f_monitorenter(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.lock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    entries++;
    if (entries >= Const.CAM_SIZE) {
      throw JVMHelp.IMSExc;
    }
 else {
      queue_front[index]=current_thread;
      queue_back[index]=queue_front[index];
    }
  }
 else {
    if (queue_front[index] != current_thread) {
      RtThreadImpl t=Native.toRtThreadImpl(queue_back[index]);
      t.lockQueue=current_thread;
      queue_back[index]=current_thread;
      Native.wr(0xfffffffe,Const.IO_INTMASK);
      Native.unlock();
      for (; ; ) {
        Native.lock();
        if (queue_front[index] == current_thread) {
          break;
        }
        Native.unlock();
      }
    }
  }
  entry_count[index]++;
  Native.unlock();
}","private static void f_monitorenter(int objAddr){
  if (!RtThreadImpl.useLocks || objAddr == 0) {
    Native.lock();
    return;
  }
  Scheduler s=Scheduler.sched[Native.rd(Const.IO_CPU_ID)];
  RtThreadImpl c=s.ref[s.active];
  Native.lock();
  cam.ADDRESS=objAddr;
  int result=cam.ADDRESS;
  int index=result & 0x7FFFFFFF;
  int current_thread=Native.toInt(c);
  if ((result & 0x80000000) == 0) {
    entries++;
    if (entries >= Const.CAM_SIZE) {
      throw JVMHelp.IMSExc;
    }
    queue_front[index]=current_thread;
    queue_back[index]=queue_front[index];
  }
 else {
    if (queue_front[index] != current_thread) {
      RtThreadImpl t=Native.toRtThreadImpl(queue_back[index]);
      t.lockQueue=current_thread;
      queue_back[index]=current_thread;
      Native.wr(0xfffffffe,Const.IO_INTMASK);
      Native.unlock();
      for (; ; ) {
        Native.lock();
        if (queue_front[index] == current_thread) {
          break;
        }
        Native.unlock();
      }
    }
  }
  c.lockLevel++;
  entry_count[index]++;
  Native.unlock();
}",0.9834358731661146
186548,"static int newArray(int size,int type){
  if (size < 0) {
    throw new NegativeArraySizeException();
  }
  int arrayLength=size;
  if ((type == 11) || (type == 7))   size<<=1;
  if (Config.USE_SCOPES) {
    int ptr=allocationPointer;
    if (RtThreadImpl.initArea == null) {
      allocationPointer+=size + HEADER_SIZE;
    }
 else {
      Memory sc=null;
      if (RtThreadImpl.mission) {
        Scheduler s=Scheduler.sched[RtThreadImpl.sys.cpuId];
        sc=s.ref[s.active].currentArea;
      }
 else {
        sc=RtThreadImpl.initArea;
      }
      if (sc.allocPtr + size + HEADER_SIZE > sc.endLocalPtr) {
        throw OOMError;
      }
      ptr=sc.allocPtr;
      sc.allocPtr+=size + HEADER_SIZE;
      if (Config.ADD_REF_INFO) {
        ptr=ptr | (sc.level << 25);
      }
      Native.wrMem(sc.level,ptr + OFF_SPACE);
    }
    Native.wrMem(ptr + HEADER_SIZE,ptr + OFF_PTR);
    Native.wrMem(arrayLength,ptr + OFF_MTAB_ALEN);
    Native.wrMem(type,ptr + OFF_TYPE);
    return ptr;
  }
synchronized (mutex) {
    if (copyPtr + size >= allocPtr) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        gc_alloc();
      }
      if (copyPtr + size >= allocPtr) {
        throw OOMError;
      }
    }
  }
synchronized (mutex) {
    if (freeList == 0) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        log(""String_Node_Str"");
        gc_alloc();
        if (freeList == 0) {
          throw OOMError;
        }
      }
    }
  }
  int ref;
synchronized (mutex) {
    allocPtr-=size;
    ref=freeList;
    freeList=Native.rdMem(ref + OFF_NEXT);
    Native.wrMem(useList,ref + OFF_NEXT);
    useList=ref;
    Native.wrMem(allocPtr,ref);
    Native.wrMem(toSpace,ref + OFF_SPACE);
    Native.wrMem(0,ref + OFF_GREY);
    Native.wrMem(type,ref + OFF_TYPE);
    Native.wrMem(arrayLength,ref + OFF_MTAB_ALEN);
  }
  return ref;
}","static int newArray(int size,int type){
  if (size < 0) {
    throw new NegativeArraySizeException();
  }
  int arrayLength=size;
  if ((type == 11) || (type == 7))   size<<=1;
  if (Config.USE_SCOPES) {
    int ptr=allocationPointer;
    if (RtThreadImpl.initArea == null) {
      allocationPointer+=size + HEADER_SIZE;
    }
 else {
      Memory sc=null;
      if (RtThreadImpl.mission) {
        Scheduler s=Scheduler.sched[RtThreadImpl.sys.cpuId];
        sc=s.ref[s.active].currentArea;
      }
 else {
        sc=RtThreadImpl.initArea;
      }
      if (sc.allocPtr + size + HEADER_SIZE > sc.endLocalPtr) {
        throw OOMError;
      }
      ptr=sc.allocPtr;
      sc.allocPtr+=size + HEADER_SIZE;
      if (Config.ADD_REF_INFO) {
        ptr=ptr | (sc.level << 25);
      }
      Native.wrMem(sc.level,ptr + OFF_SCOPE_LEVEL);
    }
    Native.wrMem(ptr + HEADER_SIZE,ptr + OFF_PTR);
    Native.wrMem(arrayLength,ptr + OFF_MTAB_ALEN);
    Native.wrMem(type,ptr + OFF_TYPE);
    return ptr;
  }
synchronized (mutex) {
    if (copyPtr + size >= allocPtr) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        gc_alloc();
      }
      if (copyPtr + size >= allocPtr) {
        throw OOMError;
      }
    }
  }
synchronized (mutex) {
    if (freeList == 0) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        log(""String_Node_Str"");
        gc_alloc();
        if (freeList == 0) {
          throw OOMError;
        }
      }
    }
  }
  int ref;
synchronized (mutex) {
    allocPtr-=size;
    ref=freeList;
    freeList=Native.rdMem(ref + OFF_NEXT);
    Native.wrMem(useList,ref + OFF_NEXT);
    useList=ref;
    Native.wrMem(allocPtr,ref);
    Native.wrMem(toSpace,ref + OFF_SPACE);
    Native.wrMem(0,ref + OFF_GREY);
    Native.wrMem(type,ref + OFF_TYPE);
    Native.wrMem(arrayLength,ref + OFF_MTAB_ALEN);
  }
  return ref;
}",0.9968253968253968
186549,"/** 
 * Allocate a new Object. Invoked from JVM.f_new(cons);
 * @param cons pointer to class struct
 * @return address of the handle
 */
static int newObject(int cons){
  int size=Native.rdMem(cons);
  if (Config.USE_SCOPES) {
    int ptr=allocationPointer;
    if (RtThreadImpl.initArea == null) {
      allocationPointer+=size + HEADER_SIZE;
    }
 else {
      Memory sc=null;
      if (RtThreadImpl.mission) {
        Scheduler s=Scheduler.sched[RtThreadImpl.sys.cpuId];
        sc=s.ref[s.active].currentArea;
      }
 else {
        sc=RtThreadImpl.initArea;
      }
      if (sc.allocPtr + size + HEADER_SIZE > sc.endLocalPtr) {
        throw OOMError;
      }
      ptr=sc.allocPtr;
      sc.allocPtr+=size + HEADER_SIZE;
      if (Config.ADD_REF_INFO) {
        ptr=ptr | (sc.level << 25);
      }
      Native.wrMem(sc.level,ptr + OFF_SPACE);
    }
    Native.wrMem(ptr + HEADER_SIZE,ptr + OFF_PTR);
    Native.wrMem(cons + Const.CLASS_HEADR,ptr + OFF_MTAB_ALEN);
    Native.wrMem(0,ptr + OFF_TYPE);
    return ptr;
  }
synchronized (mutex) {
    if (copyPtr + size >= allocPtr) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        gc_alloc();
        if (copyPtr + size >= allocPtr) {
          throw OOMError;
        }
      }
    }
  }
synchronized (mutex) {
    if (freeList == 0) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        log(""String_Node_Str"");
        gc_alloc();
        if (freeList == 0) {
          throw OOMError;
        }
      }
    }
  }
  int ref;
synchronized (mutex) {
    allocPtr-=size;
    ref=freeList;
    freeList=Native.rdMem(ref + OFF_NEXT);
    Native.wrMem(useList,ref + OFF_NEXT);
    useList=ref;
    Native.wrMem(allocPtr,ref);
    Native.wrMem(toSpace,ref + OFF_SPACE);
    Native.wrMem(0,ref + OFF_GREY);
    Native.wrMem(IS_OBJ,ref + OFF_TYPE);
    Native.wrMem(cons + Const.CLASS_HEADR,ref + OFF_MTAB_ALEN);
  }
  return ref;
}","/** 
 * Allocate a new Object. Invoked from JVM.f_new(cons);
 * @param cons pointer to class struct
 * @return address of the handle
 */
static int newObject(int cons){
  int size=Native.rdMem(cons);
  if (Config.USE_SCOPES) {
    int ptr=allocationPointer;
    if (RtThreadImpl.initArea == null) {
      allocationPointer+=size + HEADER_SIZE;
    }
 else {
      Memory sc=null;
      if (RtThreadImpl.mission) {
        Scheduler s=Scheduler.sched[RtThreadImpl.sys.cpuId];
        sc=s.ref[s.active].currentArea;
      }
 else {
        sc=RtThreadImpl.initArea;
      }
      if (sc.allocPtr + size + HEADER_SIZE > sc.endLocalPtr) {
        throw OOMError;
      }
      ptr=sc.allocPtr;
      sc.allocPtr+=size + HEADER_SIZE;
      if (Config.ADD_REF_INFO) {
        ptr=ptr | (sc.level << 25);
      }
      Native.wrMem(sc.level,ptr + OFF_SCOPE_LEVEL);
    }
    Native.wrMem(ptr + HEADER_SIZE,ptr + OFF_PTR);
    Native.wrMem(cons + Const.CLASS_HEADR,ptr + OFF_MTAB_ALEN);
    Native.wrMem(0,ptr + OFF_TYPE);
    return ptr;
  }
synchronized (mutex) {
    if (copyPtr + size >= allocPtr) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        gc_alloc();
        if (copyPtr + size >= allocPtr) {
          throw OOMError;
        }
      }
    }
  }
synchronized (mutex) {
    if (freeList == 0) {
      if (Config.USE_SCOPES) {
        throw OOMError;
      }
 else {
        log(""String_Node_Str"");
        gc_alloc();
        if (freeList == 0) {
          throw OOMError;
        }
      }
    }
  }
  int ref;
synchronized (mutex) {
    allocPtr-=size;
    ref=freeList;
    freeList=Native.rdMem(ref + OFF_NEXT);
    Native.wrMem(useList,ref + OFF_NEXT);
    useList=ref;
    Native.wrMem(allocPtr,ref);
    Native.wrMem(toSpace,ref + OFF_SPACE);
    Native.wrMem(0,ref + OFF_GREY);
    Native.wrMem(IS_OBJ,ref + OFF_TYPE);
    Native.wrMem(cons + Const.CLASS_HEADR,ref + OFF_MTAB_ALEN);
  }
  return ref;
}",0.9969135802469136
186550,"@Override public void run(){
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"");
  Object[] Array=new Object[10];
  int i=Native.rdMem(Native.toInt(Array) + GC.getOffSpace());
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"" + i);
  for (int j=0; j < Array.length; j++) {
    Array[j]=new Object();
  }
  int j=Native.rdMem(Native.toInt(Array[0]) + GC.getOffSpace());
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"" + j);
  i=Native.rdMem(Native.toInt(Array) + GC.getOffSpace());
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"" + i);
}","@Override public void run(){
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"");
  Object[] Array=new Object[10];
  int i=Native.rdMem(Native.toInt(Array) + GC.OFF_SCOPE_LEVEL);
  System.out.println(Native.toInt(Array) + GC.OFF_SCOPE_LEVEL);
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"" + i);
  for (int j=0; j < Array.length; j++) {
    Array[j]=new Object();
  }
  int j=Native.rdMem(Native.toInt(Array[0]) + GC.OFF_SCOPE_LEVEL);
  System.out.println(Native.toInt(Array[0]) + GC.OFF_SCOPE_LEVEL);
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"" + j);
  i=Native.rdMem(Native.toInt(Array) + GC.OFF_SCOPE_LEVEL);
  System.out.println(Native.toInt(Array) + GC.OFF_SCOPE_LEVEL);
  ArrayReferenceTest.terminal.writeln(""String_Node_Str"" + i);
}",0.6079759217456734
186551,"/** 
 * If this is the implementation of a virtual/interface invoke instruction, return the InvokeNode for the virtual invoke instruction. TODO: This can be removed, if we ever remove   {@link ControlFlowGraph#resolveVirtualInvokes()}
 * @return the node representing the virtual invoke or null if not instanciated from a virtual invoke.
 */
public InvokeNode getVirtualNode(){
  if (this.instantiatedFrom != null)   return this.instantiatedFrom;
 else   return this;
}","/** 
 * If this is the implementation of a virtual/interface invoke instruction, return the InvokeNode for the virtual invoke instruction. TODO: This can be removed, if we ever remove   {@link ControlFlowGraph#resolveVirtualInvokes()}
 * @return the node representing the virtual invoke or null if not instantiated from a virtual invoke.
 */
public InvokeNode getVirtualNode(){
  if (this.instantiatedFrom != null)   return this.instantiatedFrom;
 else   return this;
}",0.997867803837953
186552,"@Override public boolean visitNode(ExecutionContext context){
  MethodInfo method=context.getMethodInfo();
  MethodCode code=method.getCode();
  long ec=getExecCount(method);
  if (ec == 0)   return false;
  ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
  for (  CFGNode node : cfg.getGraph().vertexSet()) {
    if (node instanceof InvokeNode) {
      InvokeNode inv=(InvokeNode)node;
      long ef=getExecFrequency(method,node);
      if (!inv.isVirtual()) {
        addExecCount(inv.getImplementingMethod(),ec * ef);
      }
 else {
        for (        MethodInfo invokee : ((InvokeNode)node).getImplementingMethods()) {
          addExecCount(invokee,ec * ef);
        }
      }
    }
 else     if (node instanceof BasicBlockNode) {
      for (      InstructionHandle ih : node.getBasicBlock().getInstructions()) {
        if (!code.isInvokeSite(ih))         continue;
        long ef=getExecFrequency(method,node);
        for (        MethodInfo invokee : method.getAppInfo().findImplementations(code.getInvokeSite(ih))) {
          addExecCount(invokee,ec * ef);
        }
      }
    }
  }
  return true;
}","@Override public boolean visitNode(ExecutionContext context){
  MethodInfo method=context.getMethodInfo();
  MethodCode code=method.getCode();
  long ec=getExecCount(method);
  if (ec == 0)   return false;
  ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
  for (  CFGNode node : cfg.getGraph().vertexSet()) {
    if (node instanceof InvokeNode) {
      InvokeNode inv=(InvokeNode)node;
      long ef=getExecFrequency(method,node);
      for (      MethodInfo invokee : inv.getImplementingMethods()) {
        addExecCount(invokee,ec * ef);
      }
    }
 else     if (node instanceof BasicBlockNode) {
      for (      InstructionHandle ih : node.getBasicBlock().getInstructions()) {
        if (!code.isInvokeSite(ih))         continue;
        long ef=getExecFrequency(method,node);
        for (        MethodInfo invokee : method.getAppInfo().findImplementations(code.getInvokeSite(ih))) {
          addExecCount(invokee,ec * ef);
        }
      }
    }
  }
  return true;
}",0.8780487804878049
186553,"private void updateWCEP(){
  if (!provideWCAExecCount)   return;
  execCounts.clear();
  for (  MethodInfo root : getWcaTargets()) {
    execCounts.put(root,1L);
  }
  NodeVisitor<ExecutionContext> visitor=new NodeVisitor<ExecutionContext>(){
    @Override public boolean visitNode(    ExecutionContext context){
      MethodInfo method=context.getMethodInfo();
      MethodCode code=method.getCode();
      long ec=getExecCount(method);
      if (ec == 0)       return false;
      ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
      for (      CFGNode node : cfg.getGraph().vertexSet()) {
        if (node instanceof InvokeNode) {
          InvokeNode inv=(InvokeNode)node;
          long ef=getExecFrequency(method,node);
          if (!inv.isVirtual()) {
            addExecCount(inv.getImplementingMethod(),ec * ef);
          }
 else {
            for (            MethodInfo invokee : ((InvokeNode)node).getImplementingMethods()) {
              addExecCount(invokee,ec * ef);
            }
          }
        }
 else         if (node instanceof BasicBlockNode) {
          for (          InstructionHandle ih : node.getBasicBlock().getInstructions()) {
            if (!code.isInvokeSite(ih))             continue;
            long ef=getExecFrequency(method,node);
            for (            MethodInfo invokee : method.getAppInfo().findImplementations(code.getInvokeSite(ih))) {
              addExecCount(invokee,ec * ef);
            }
          }
        }
      }
      return true;
    }
  }
;
  TopologicalTraverser<ExecutionContext,ContextEdge> topOrder=new TopologicalTraverser<ExecutionContext,ContextEdge>(wcetTool.getCallGraph().getGraph(),visitor);
  topOrder.traverse();
}","private void updateWCEP(){
  if (!provideWCAExecCount)   return;
  execCounts.clear();
  for (  MethodInfo root : getWcaTargets()) {
    execCounts.put(root,1L);
  }
  NodeVisitor<ExecutionContext> visitor=new NodeVisitor<ExecutionContext>(){
    @Override public boolean visitNode(    ExecutionContext context){
      MethodInfo method=context.getMethodInfo();
      MethodCode code=method.getCode();
      long ec=getExecCount(method);
      if (ec == 0)       return false;
      ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
      for (      CFGNode node : cfg.getGraph().vertexSet()) {
        if (node instanceof InvokeNode) {
          InvokeNode inv=(InvokeNode)node;
          long ef=getExecFrequency(method,node);
          for (          MethodInfo invokee : inv.getImplementingMethods()) {
            addExecCount(invokee,ec * ef);
          }
        }
 else         if (node instanceof BasicBlockNode) {
          for (          InstructionHandle ih : node.getBasicBlock().getInstructions()) {
            if (!code.isInvokeSite(ih))             continue;
            long ef=getExecFrequency(method,node);
            for (            MethodInfo invokee : method.getAppInfo().findImplementations(code.getInvokeSite(ih))) {
              addExecCount(invokee,ec * ef);
            }
          }
        }
      }
      return true;
    }
  }
;
  TopologicalTraverser<ExecutionContext,ContextEdge> topOrder=new TopologicalTraverser<ExecutionContext,ContextEdge>(wcetTool.getCallGraph().getGraph(),visitor);
  topOrder.traverse();
}",0.7356881851400731
186554,"@Override public Set<MethodInfo> updateChangeSet(ExecFrequencyProvider ecp,Set<MethodInfo> optimizedMethods,Set<MethodInfo> candidateChanges){
  Set<MethodInfo> changeSet=new HashSet<MethodInfo>(candidateChanges);
  changeSet.addAll(analyses.getExecFrequencyAnalysis().getChangeSet());
  changeSet.addAll(analyses.getMethodCacheAnalysis().getMissCountChangeSet(ecp));
  changeSet.addAll(analyses.getWCAInvoker().updateWCA(optimizedMethods));
  return changeSet;
}","@Override public Set<MethodInfo> updateChangeSet(ExecFrequencyProvider ecp,Set<MethodInfo> optimizedMethods,Set<MethodInfo> candidateChanges){
  Set<MethodInfo> changeSet=new HashSet<MethodInfo>(candidateChanges);
  changeSet.addAll(ecp.getChangeSet());
  changeSet.addAll(analyses.getMethodCacheAnalysis().getMissCountChangeSet(ecp));
  changeSet.addAll(analyses.getWCAInvoker().updateWCA(optimizedMethods));
  return changeSet;
}",0.5816554809843401
186555,"/** 
 * This merges the results for invokes and adds results for the virtual nodes. This is required if results for the virtual nodes are needed too, e.g. if  {@link ControlFlowGraph#getHandleNode(InstructionHandle)} is used.
 * @return the flow graph, including results for virtual blocks.
 */
public Map<CFGNode,Long> getNodeFlowVirtual(){
  Map<CFGNode,Long> flow=new HashMap<CFGNode,Long>(nodeFlow);
  for (  CFGNode node : nodeFlow.keySet()) {
    if (!(node instanceof InvokeNode))     continue;
    InvokeNode inv=(InvokeNode)node;
    InvokeNode virt=inv.getVirtualNode();
    if (virt != null) {
      Long val=flow.get(virt);
      if (val == null) {
        flow.put(virt,flow.get(inv));
      }
 else {
        flow.put(virt,flow.get(inv) + val);
      }
    }
  }
  return flow;
}","/** 
 * This merges the results for invokes and adds results for the virtual nodes. This is required if results for the virtual nodes are needed too, e.g. if  {@link ControlFlowGraph#getHandleNode(InstructionHandle)} is used.
 * @return the flow graph, including results for virtual blocks.
 */
public Map<CFGNode,Long> getNodeFlowVirtual(){
  Map<CFGNode,Long> flow=new HashMap<CFGNode,Long>(nodeFlow);
  for (  CFGNode node : nodeFlow.keySet()) {
    if (!(node instanceof InvokeNode))     continue;
    InvokeNode inv=(InvokeNode)node;
    if (!inv.isVirtualInstance())     continue;
    InvokeNode virt=inv.getVirtualNode();
    if (virt != null) {
      Long val=flow.get(virt);
      if (val == null) {
        flow.put(virt,flow.get(inv));
      }
 else {
        flow.put(virt,flow.get(inv) + val);
      }
    }
  }
  return flow;
}",0.97062423500612
186556,"/** 
 * @param newHandles key is old handle, value is new handle
 */
public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  if (receivers != null) {
    receivers.copyResults(newHandles);
  }
  if (loopBounds != null) {
    loopBounds.copyResults(newHandles);
  }
}","/** 
 * @param method the method containing the new instructions
 * @param newHandles key is old handle, value is new handle. Value can be null.
 */
public void copyResults(MethodInfo method,Map<InstructionHandle,InstructionHandle> newHandles){
  if (receivers != null) {
    receivers.copyResults(method,newHandles);
  }
  if (loopBounds != null) {
    loopBounds.copyResults(method,newHandles);
  }
}",0.838150289017341
186557,"@Override public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    if (newHandle == null)     continue;
    ContextMap<CallString,Set<String>> value=targets.get(oldHandle);
    if (value != null)     targets.put(newHandle,value);
  }
}","@Override public void copyResults(MethodInfo newContainer,Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    if (newHandle == null)     continue;
    ContextMap<CallString,Set<String>> value=targets.get(oldHandle);
    if (value != null)     targets.put(newHandle,value.copy(newContainer));
  }
}",0.9541088580576308
186558,"@Override public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    if (newHandle == null)     continue;
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> value=bounds.get(oldHandle);
    if (value != null)     bounds.put(newHandle,value);
    ContextMap<CallString,Interval> value1=arrayIndices.get(oldHandle);
    if (value1 != null)     arrayIndices.put(newHandle,value1);
    ContextMap<CallString,Integer> value2=scopes.get(oldHandle);
    if (value2 != null)     scopes.put(newHandle,value2);
    ContextMap<CallString,Interval[]> value3=sizes.get(oldHandle);
    if (value3 != null)     sizes.put(newHandle,value3);
    ContextMap<CallString,Set<FlowEdge>> old=infeasibles.get(oldHandle);
    if (old != null) {
      Map<CallString,Set<FlowEdge>> map=new HashMap<CallString,Set<FlowEdge>>(old.size());
      for (      CallString cs : old.keySet()) {
        Set<FlowEdge> newSet=new HashSet<FlowEdge>();
        for (        FlowEdge edge : old.get(cs)) {
          InstructionHandle newHead=newHandles.get(edge.getHead());
          InstructionHandle newTail=newHandles.get(edge.getTail());
          if (newHead != null && newTail != null) {
            newSet.add(new FlowEdge(newTail,newHead,edge.getType()));
          }
        }
        map.put(cs,newSet);
      }
      ContextMap<CallString,Set<FlowEdge>> edges=new ContextMap<CallString,Set<FlowEdge>>(old.getContext(),map);
      infeasibles.put(newHandle,edges);
    }
  }
}","@Override public void copyResults(MethodInfo newContainer,Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    if (newHandle == null)     continue;
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> value=bounds.get(oldHandle);
    if (value != null)     bounds.put(newHandle,value.copy(newContainer));
    ContextMap<CallString,Interval> value1=arrayIndices.get(oldHandle);
    if (value1 != null)     arrayIndices.put(newHandle,value1.copy(newContainer));
    ContextMap<CallString,Integer> value2=scopes.get(oldHandle);
    if (value2 != null)     scopes.put(newHandle,value2.copy(newContainer));
    ContextMap<CallString,Interval[]> value3=sizes.get(oldHandle);
    if (value3 != null)     sizes.put(newHandle,value3.copy(newContainer));
    ContextMap<CallString,Set<FlowEdge>> old=infeasibles.get(oldHandle);
    if (old != null) {
      Map<CallString,Set<FlowEdge>> map=new HashMap<CallString,Set<FlowEdge>>(old.size());
      for (      CallString cs : old.keySet()) {
        Set<FlowEdge> newSet=new HashSet<FlowEdge>();
        for (        FlowEdge edge : old.get(cs)) {
          InstructionHandle newHead=newHandles.get(edge.getHead());
          InstructionHandle newTail=newHandles.get(edge.getTail());
          if (newHead != null && newTail != null) {
            newSet.add(new FlowEdge(newTail,newHead,edge.getType()));
          }
        }
        map.put(cs,newSet);
      }
      Context c=old.getContext();
      c.setMethodInfo(newContainer);
      ContextMap<CallString,Set<FlowEdge>> edges=new ContextMap<CallString,Set<FlowEdge>>(c,map);
      infeasibles.put(newHandle,edges);
    }
  }
}",0.9460699942627654
186559,"@Override public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  throw new AppInfoError(""String_Node_Str"");
}","@Override public void copyResults(MethodInfo newContainer,Map<InstructionHandle,InstructionHandle> newHandles){
  throw new AppInfoError(""String_Node_Str"");
}",0.9178082191780822
186560,"/** 
 * Copy results to a new instruction handle.
 * @param newHandles keys are old handles, values are corresponding new handles
 */
void copyResults(Map<InstructionHandle,InstructionHandle> newHandles);","/** 
 * Copy results to a new instruction handle.
 * @param newContainer
 * @param newHandles keys are old handles, values are corresponding new handles
 */
void copyResults(MethodInfo newContainer,Map<InstructionHandle,InstructionHandle> newHandles);",0.8967032967032967
186561,"/** 
 * <p>Result Map: MethodInfo -> Instruction Offset -> Callstring -> R</p> <p>TODO: More efficient representations are possible</p>
 * @param result the result of the DFA analysis
 * @param serializer converter for the result domain (if not serializable), or nullif the results of type T should be serialized directly
 */
public static <T,R>AnalysisResultSerialization<R> fromContextMapResult(Map<InstructionHandle,ContextMap<CallString,T>> result,Serializer<T,R> serializer){
  AnalysisResultSerialization<R> analysisResult=new AnalysisResultSerialization<R>();
  for (  InstructionHandle instr : result.keySet()) {
    ContextMap<CallString,T> r=result.get(instr);
    Context c=r.getContext();
    for (    CallString cs : r.keySet()) {
      Integer position=instr.getPosition();
      if (serializer != null) {
        T rValue=r.get(cs);
        R sValue=serializer.serializedRepresentation(rValue);
        analysisResult.addResult(c.getMethodInfo(),position,cs,sValue);
      }
 else {
        analysisResult.addResult(c.getMethodInfo(),position,cs,(R)r.get(cs));
      }
    }
  }
  return analysisResult;
}","/** 
 * <p>Result Map: MethodInfo -> Instruction Offset -> Callstring -> R</p> <p>TODO: More efficient representations are possible</p>
 * @param result the result of the DFA analysis
 * @param serializer converter for the result domain (if not serializable), or nullif the results of type T should be serialized directly
 */
public static <T,R>AnalysisResultSerialization<R> fromContextMapResult(Map<InstructionHandle,ContextMap<CallString,T>> result,Serializer<T,R> serializer){
  AnalysisResultSerialization<R> analysisResult=new AnalysisResultSerialization<R>();
  for (  InstructionHandle instr : result.keySet()) {
    ContextMap<CallString,T> r=result.get(instr);
    Context c=r.getContext();
    InstructionList il=c.getMethodInfo().getCode().getInstructionList(true,false);
    for (    CallString cs : r.keySet()) {
      Integer position=instr.getPosition();
      if (position < 0)       continue;
      if (il.findHandle(position) != instr)       continue;
      if (serializer != null) {
        T rValue=r.get(cs);
        R sValue=serializer.serializedRepresentation(rValue);
        analysisResult.addResult(c.getMethodInfo(),position,cs,sValue);
      }
 else {
        analysisResult.addResult(c.getMethodInfo(),position,cs,(R)r.get(cs));
      }
    }
  }
  return analysisResult;
}",0.9162195625257944
186562,"private Map<InvokeSite,InvokeSite> insertInvokee(AnalysisManager analyses,CallString callString,InstructionList il,InstructionHandle next){
  MethodCode code=getMethod().getCode();
  MethodCode invokeeCode=invokee.getCode();
  InstructionList iList=invokeeCode.getInstructionList(true,false);
  Map<InstructionHandle,InstructionHandle> instrMap=new HashMap<InstructionHandle,InstructionHandle>();
  Map<InvokeSite,InvokeSite> invokeMap=new HashMap<InvokeSite,InvokeSite>();
  StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(invokee);
  for (InstructionHandle src=iList.getStart(); src != null; src=src.getNext()) {
    InstructionHandle ih=copyInstruction(code,stacksize,il,src,next);
    if (ih == null)     continue;
    code.copyCustomValues(invokee,ih,src);
    if (code.isInvokeSite(ih)) {
      InvokeSite newInvoke=code.getInvokeSite(ih);
      InvokeSite oldInvoke=invokeeCode.getInvokeSite(src);
      invokeMap.put(oldInvoke,newInvoke);
      setInlineCallString(code,ih,callString);
    }
    instrMap.put(src,ih);
  }
  remapTargets(instrMap,next);
  if (updateDFA) {
    jcopter.getDfaTool().copyResults(instrMap);
  }
  return invokeMap;
}","private Map<InvokeSite,InvokeSite> insertInvokee(AnalysisManager analyses,CallString callString,InstructionList il,InstructionHandle next){
  MethodCode code=getMethod().getCode();
  MethodCode invokeeCode=invokee.getCode();
  InstructionList iList=invokeeCode.getInstructionList(true,false);
  Map<InstructionHandle,InstructionHandle> instrMap=new HashMap<InstructionHandle,InstructionHandle>();
  Map<InvokeSite,InvokeSite> invokeMap=new HashMap<InvokeSite,InvokeSite>();
  StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(invokee);
  for (InstructionHandle src=iList.getStart(); src != null; src=src.getNext()) {
    InstructionHandle ih=copyInstruction(code,stacksize,il,src,next);
    if (ih == null)     continue;
    code.copyCustomValues(invokee,ih,src);
    if (code.isInvokeSite(ih)) {
      InvokeSite newInvoke=code.getInvokeSite(ih);
      InvokeSite oldInvoke=invokeeCode.getInvokeSite(src);
      invokeMap.put(oldInvoke,newInvoke);
      setInlineCallString(code,ih,callString);
    }
    instrMap.put(src,ih);
  }
  remapTargets(instrMap,next);
  if (updateDFA) {
    jcopter.getDfaTool().copyResults(invokeSite.getInvoker(),instrMap);
  }
  return invokeMap;
}",0.9897872340425532
186563,"public static void registerOptions(OptionGroup options){
  options.addOption(GREEDY_ORDER);
  options.addOption(TARGETS);
  options.addOption(USE_WCEP);
  options.addOption(USE_WCA_EXEC_COUNT);
  options.addOption(USE_FREQUENCY_ONLY);
  options.addOption(CACHE_ANALYSIS_TYPE);
  options.addOption(WCA_CACHE_APPROXIMATION);
  options.addOption(DUMP_TARGET_CALLGRAPH);
}","public static void registerOptions(OptionGroup options){
  options.addOption(GREEDY_ORDER);
  options.addOption(TARGETS);
  options.addOption(USE_WCEP);
  options.addOption(USE_WCA_EXEC_COUNT);
  options.addOption(USE_FREQUENCY_ONLY);
  options.addOption(CACHE_ANALYSIS_TYPE);
  options.addOption(WCA_CACHE_APPROXIMATION);
  options.addOption(DUMP_TARGET_CALLGRAPH);
  options.addOption(MAX_STEPS);
}",0.9583333333333334
186564,"private void optimizeMethods(AnalysisManager analyses,ExecFrequencyProvider ecp,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates(ecp);
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates(ecp);
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(ecp,optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,ecp,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(ecp,methods);
    }
 else {
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + changeSet.size());
      }
      selector.sortCandidates(ecp,changeSet);
    }
    candidates=selector.selectNextCandidates(ecp);
  }
}","private void optimizeMethods(AnalysisManager analyses,ExecFrequencyProvider ecp,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  if (maxSteps > 0 && countOptimized >= maxSteps) {
    return;
  }
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates(ecp);
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates(ecp);
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      if (maxSteps > 0 && countOptimized >= maxSteps) {
        return;
      }
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(ecp,optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,ecp,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(ecp,methods);
    }
 else {
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + changeSet.size());
      }
      selector.sortCandidates(ecp,changeSet);
    }
    candidates=selector.selectNextCandidates(ecp);
  }
}",0.975209380234506
186565,"private void resetCounters(){
  countCandidates=0;
  countOptimized=0;
}","private void resetCounters(){
  countCandidates=0;
  countOptimized=0;
  maxSteps=config.getMaxSteps();
}",0.8135593220338984
186566,"/** 
 * @param cs the callstring from the invoker to the invoke to inline (if recursive). Used to check DFA results.
 * @param invokee the invoked method to analyze
 * @param inlineData the map to populate with the parameters and the instructions to inline.
 * @return true if inlining is possible
 */
private boolean analyzeInvokee(CallString cs,MethodInfo invokee,InlineData inlineData){
  ValueMapAnalysis values=new ValueMapAnalysis(invokee);
  values.loadParameters();
  InstructionList il=invokee.getCode().getInstructionList(true,false);
  InstructionHandle ih=il.getStart();
  int count=0;
  while (true) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof PushInstruction || instruction instanceof NOP) {
      values.transfer(instruction);
      ih=ih.getNext();
      count++;
    }
 else {
      break;
    }
  }
  for (  ValueInfo value : values.getValueTable().getStack()) {
    inlineData.addParam(value);
  }
  inlineData.setInlineStart(count);
  boolean needsNPCheck=helper.needsNullpointerCheck(cs,invokee,false);
  boolean hasNPCheck=false;
  for (int i=0; i < 6; i++) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof InvokeInstruction) {
      if (inlineData.getInvokeSite() != null) {
        return false;
      }
      InvokeSite is=invokee.getCode().getInvokeSite(ih);
      inlineData.setInvokeSite(is);
      hasNPCheck|=!is.isInvokeStatic();
    }
 else     if (instruction instanceof FieldInstruction) {
      if (instruction instanceof GETFIELD) {
        hasNPCheck|=values.getValueTable().top(1).isThisReference();
      }
      if (instruction instanceof PUTFIELD) {
        int down=values.getValueTable().top().isContinued() ? 2 : 1;
        hasNPCheck|=values.getValueTable().top(down).isThisReference();
      }
    }
 else     if (instruction instanceof ArithmeticInstruction || instruction instanceof ConversionInstruction || instruction instanceof StackInstruction|| instruction instanceof LDC|| instruction instanceof LDC2_W|| instruction instanceof ARRAYLENGTH|| instruction instanceof CHECKCAST|| instruction instanceof NOP) {
    }
 else     if (instruction instanceof ReturnInstruction) {
      if (needsNPCheck && !hasNPCheck) {
        this.requiresNPCheck++;
        if (logger.isTraceEnabled()) {
          logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str"");
        }
        return false;
      }
      if (instruction instanceof RETURN) {
        while (values.getValueTable().getStackSize() > 0) {
          Instruction pop;
          if (values.getValueTable().top().isContinued()) {
            pop=new POP2();
          }
 else {
            pop=new POP();
          }
          inlineData.addEpilogue(pop);
          values.transfer(pop);
        }
        return true;
      }
 else {
        Type type=((ReturnInstruction)instruction).getType();
        return values.getValueTable().getStackSize() == type.getSize();
      }
    }
 else {
      unhandledInstructions++;
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str""+ instruction.toString(invokee.getClassInfo().getConstantPoolGen().getConstantPool()));
      }
      return false;
    }
    values.transfer(instruction);
    ih=ih.getNext();
  }
  return false;
}","/** 
 * @param cs the callstring from the invoker to the invoke to inline (if recursive). Used to check DFA results.
 * @param invokee the invoked method to analyze
 * @param inlineData the map to populate with the parameters and the instructions to inline.
 * @return true if inlining is possible
 */
private boolean analyzeInvokee(CallString cs,MethodInfo invokee,InlineData inlineData){
  ValueMapAnalysis values=new ValueMapAnalysis(invokee);
  values.loadParameters();
  InstructionList il=invokee.getCode().getInstructionList(true,false);
  InstructionHandle ih=il.getStart();
  int count=0;
  while (true) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof PushInstruction || instruction instanceof NOP) {
      values.transfer(instruction);
      ih=ih.getNext();
      count++;
    }
 else {
      break;
    }
  }
  for (  ValueInfo value : values.getValueTable().getStack()) {
    inlineData.addParam(value);
  }
  inlineData.setInlineStart(count);
  boolean needsNPCheck=helper.needsNullpointerCheck(cs,invokee,false);
  boolean hasNPCheck=false;
  for (int i=0; i < 6; i++) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof InvokeInstruction) {
      if (inlineData.getInvokeSite() != null) {
        return false;
      }
      InvokeSite is=invokee.getCode().getInvokeSite(ih);
      inlineData.setInvokeSite(is);
      hasNPCheck|=!is.isInvokeStatic();
    }
 else     if (instruction instanceof FieldInstruction) {
      if (instruction instanceof GETFIELD) {
        hasNPCheck|=values.getValueTable().top().isThisReference();
      }
      if (instruction instanceof PUTFIELD) {
        int down=values.getValueTable().top().isContinued() ? 2 : 1;
        hasNPCheck|=values.getValueTable().top(down).isThisReference();
      }
    }
 else     if (instruction instanceof ArithmeticInstruction || instruction instanceof ConversionInstruction || instruction instanceof StackInstruction|| instruction instanceof LDC|| instruction instanceof LDC2_W|| instruction instanceof ARRAYLENGTH|| instruction instanceof CHECKCAST|| instruction instanceof NOP) {
    }
 else     if (instruction instanceof ReturnInstruction) {
      if (needsNPCheck && !hasNPCheck) {
        this.requiresNPCheck++;
        if (logger.isTraceEnabled()) {
          logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str"");
        }
        return false;
      }
      if (instruction instanceof RETURN) {
        while (values.getValueTable().getStackSize() > 0) {
          Instruction pop;
          if (values.getValueTable().top().isContinued()) {
            pop=new POP2();
          }
 else {
            pop=new POP();
          }
          inlineData.addEpilogue(pop);
          values.transfer(pop);
        }
        return true;
      }
 else {
        Type type=((ReturnInstruction)instruction).getType();
        return values.getValueTable().getStackSize() == type.getSize();
      }
    }
 else {
      unhandledInstructions++;
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str""+ instruction.toString(invokee.getClassInfo().getConstantPoolGen().getConstantPool()));
      }
      return false;
    }
    values.transfer(instruction);
    ih=ih.getNext();
  }
  return false;
}",0.9998487369535622
186567,"@Override public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    ContextMap<CallString,Set<String>> value=targets.get(oldHandle);
    if (value != null)     targets.put(newHandle,value);
  }
}","@Override public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    if (newHandle == null)     continue;
    ContextMap<CallString,Set<String>> value=targets.get(oldHandle);
    if (value != null)     targets.put(newHandle,value);
  }
}",0.9519343493552168
186568,"@Override public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> value=bounds.get(oldHandle);
    if (value != null)     bounds.put(newHandle,value);
    ContextMap<CallString,Interval> value1=arrayIndices.get(oldHandle);
    if (value1 != null)     arrayIndices.put(newHandle,value1);
    ContextMap<CallString,Integer> value2=scopes.get(oldHandle);
    if (value2 != null)     scopes.put(newHandle,value2);
    ContextMap<CallString,Interval[]> value3=sizes.get(oldHandle);
    if (value3 != null)     sizes.put(newHandle,value3);
    ContextMap<CallString,Set<FlowEdge>> old=infeasibles.get(oldHandle);
    if (old != null) {
      Map<CallString,Set<FlowEdge>> map=new HashMap<CallString,Set<FlowEdge>>(old.size());
      for (      CallString cs : old.keySet()) {
        Set<FlowEdge> newSet=new HashSet<FlowEdge>();
        for (        FlowEdge edge : old.get(cs)) {
          InstructionHandle newHead=newHandles.get(edge.getHead());
          InstructionHandle newTail=newHandles.get(edge.getTail());
          if (newHead != null && newTail != null) {
            newSet.add(new FlowEdge(newTail,newHead,edge.getType()));
          }
        }
        map.put(cs,newSet);
      }
      ContextMap<CallString,Set<FlowEdge>> edges=new ContextMap<CallString,Set<FlowEdge>>(old.getContext(),map);
      infeasibles.put(newHandle,edges);
    }
  }
}","@Override public void copyResults(Map<InstructionHandle,InstructionHandle> newHandles){
  for (  Map.Entry<InstructionHandle,InstructionHandle> entry : newHandles.entrySet()) {
    InstructionHandle oldHandle=entry.getKey();
    InstructionHandle newHandle=entry.getValue();
    if (newHandle == null)     continue;
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> value=bounds.get(oldHandle);
    if (value != null)     bounds.put(newHandle,value);
    ContextMap<CallString,Interval> value1=arrayIndices.get(oldHandle);
    if (value1 != null)     arrayIndices.put(newHandle,value1);
    ContextMap<CallString,Integer> value2=scopes.get(oldHandle);
    if (value2 != null)     scopes.put(newHandle,value2);
    ContextMap<CallString,Interval[]> value3=sizes.get(oldHandle);
    if (value3 != null)     sizes.put(newHandle,value3);
    ContextMap<CallString,Set<FlowEdge>> old=infeasibles.get(oldHandle);
    if (old != null) {
      Map<CallString,Set<FlowEdge>> map=new HashMap<CallString,Set<FlowEdge>>(old.size());
      for (      CallString cs : old.keySet()) {
        Set<FlowEdge> newSet=new HashSet<FlowEdge>();
        for (        FlowEdge edge : old.get(cs)) {
          InstructionHandle newHead=newHandles.get(edge.getHead());
          InstructionHandle newTail=newHandles.get(edge.getTail());
          if (newHead != null && newTail != null) {
            newSet.add(new FlowEdge(newTail,newHead,edge.getType()));
          }
        }
        map.put(cs,newSet);
      }
      ContextMap<CallString,Set<FlowEdge>> edges=new ContextMap<CallString,Set<FlowEdge>>(old.getContext(),map);
      infeasibles.put(newHandle,edges);
    }
  }
}",0.9875342049255093
186569,"public void setUpdateDFA(boolean updateDFA){
  this.updateDFA=updateDFA && appInfo.getCallstringLength() == 0;
}","public void setUpdateDFA(boolean updateDFA){
  if (updateDFA && appInfo.getCallstringLength() != 0) {
    logger.warn(""String_Node_Str"");
  }
  this.updateDFA=updateDFA && appInfo.getCallstringLength() == 0;
}",0.6978193146417445
186570,"public Set<InvokeSite> getInvokeSites(MethodInfo invokee){
  MethodNode node=getMethodNode(invokee);
  Set<InvokeSite> invokeSites=new HashSet<InvokeSite>();
  for (  ExecutionContext ec : node.getInstances()) {
    if (ec.getCallString().isEmpty()) {
      AppInfo appInfo=AppInfo.getSingleton();
      for (      ContextEdge edge : callGraph.incomingEdgesOf(ec)) {
        for (        InvokeSite invokeSite : edge.getSource().getMethodInfo().getCode().getInvokeSites()) {
          if (invokeSite.canInvoke(invokee) == Ternary.TRUE) {
            invokeSites.add(invokeSite);
          }
        }
      }
    }
 else {
      invokeSites.add(ec.getCallString().top());
    }
  }
  return invokeSites;
}","public Set<InvokeSite> getInvokeSites(MethodInfo invokee){
  MethodNode node=getMethodNode(invokee);
  Set<InvokeSite> invokeSites=new HashSet<InvokeSite>();
  for (  ExecutionContext ec : node.getInstances()) {
    if (ec.getCallString().isEmpty()) {
      AppInfo appInfo=AppInfo.getSingleton();
      for (      ContextEdge edge : callGraph.incomingEdgesOf(ec)) {
        for (        InvokeSite invokeSite : edge.getSource().getMethodInfo().getCode().getInvokeSites()) {
          if (invokeSite.canInvoke(invokee) != Ternary.FALSE) {
            invokeSites.add(invokeSite);
          }
        }
      }
    }
 else {
      invokeSites.add(ec.getCallString().top());
    }
  }
  return invokeSites;
}",0.9936215450035436
186571,"/** 
 * @param methodInfo a possible invokee
 * @return true if this invokeSite may invoke the method. Does not use the callgraph to check.
 */
public Ternary canInvoke(MethodInfo methodInfo){
  MethodRef invokeeRef=getInvokeeRef();
  MethodInfo method=invokeeRef.getMethodInfo();
  if (!isVirtual()) {
    return Ternary.valueOf(methodInfo.equals(invokeeRef.getMethodInfo()));
  }
  if (method == null) {
    return Ternary.UNKNOWN;
  }
  if (!methodInfo.getClassInfo().isSubclassOf(invokeeRef.getClassInfo())) {
    return Ternary.FALSE;
  }
  return Ternary.valueOf(methodInfo.overrides(method,true));
}","/** 
 * @param methodInfo a possible invokee
 * @return true if this invokeSite may invoke the method. Does not use the callgraph to check.For interface invoke sites this can return UNKNOWN if the class of the given method implementation does not implement the referenced interface.
 */
public Ternary canInvoke(MethodInfo methodInfo){
  MethodRef invokeeRef=getInvokeeRef();
  MethodInfo method=invokeeRef.getMethodInfo();
  if (!isVirtual()) {
    return Ternary.valueOf(methodInfo.equals(invokeeRef.getMethodInfo()));
  }
  if (method == null) {
    return Ternary.UNKNOWN;
  }
  if (!methodInfo.getClassInfo().isSubclassOf(invokeeRef.getClassInfo())) {
    if (isInvokeInterface() && !methodInfo.getClassInfo().isInterface()) {
      if (!invokeeRef.getMethodSignature().equals(methodInfo.getMethodSignature())) {
        return Ternary.FALSE;
      }
      return Ternary.UNKNOWN;
    }
    return Ternary.FALSE;
  }
  return Ternary.valueOf(methodInfo.overrides(method,true));
}",0.7559748427672957
186572,"private void updateChilds(ExecutionContext context,List<ExecutionContext> childs){
  long ecCount=nodeCount.get(context);
  List<ExecutionContext> emptyCSNodes=new LinkedList<ExecutionContext>();
  for (  ExecutionContext child : childs) {
    long count;
    if (!child.getCallString().isEmpty()) {
      count=ecCount * getExecFrequency(context,child.getCallString().top().getInstructionHandle());
      addExecCount(child,count);
    }
 else {
      emptyCSNodes.add(child);
    }
  }
  if (emptyCSNodes.isEmpty())   return;
  for (  InvokeSite invokeSite : context.getMethodInfo().getCode().getInvokeSites()) {
    long count=getExecCount(context,invokeSite.getInstructionHandle());
    for (    ExecutionContext child : emptyCSNodes) {
      if (invokeSite.canInvoke(child.getMethodInfo()) == Ternary.TRUE) {
        addExecCount(child,count);
      }
    }
  }
}","private void updateChilds(ExecutionContext context,List<ExecutionContext> childs){
  long ecCount=nodeCount.get(context);
  List<ExecutionContext> emptyCSNodes=new LinkedList<ExecutionContext>();
  for (  ExecutionContext child : childs) {
    long count;
    if (!child.getCallString().isEmpty()) {
      count=ecCount * getExecFrequency(context,child.getCallString().top().getInstructionHandle());
      addExecCount(child,count);
    }
 else {
      emptyCSNodes.add(child);
    }
  }
  if (emptyCSNodes.isEmpty())   return;
  for (  InvokeSite invokeSite : context.getMethodInfo().getCode().getInvokeSites()) {
    long count=getExecCount(context,invokeSite.getInstructionHandle());
    for (    ExecutionContext child : emptyCSNodes) {
      if (invokeSite.canInvoke(child.getMethodInfo()) != Ternary.FALSE) {
        addExecCount(child,count);
      }
    }
  }
}",0.9948186528497408
186573,"@Override public void optimizeMethod(MethodInfo method){
  ConstantPoolGen cpg=method.getConstantPoolGen();
  InstructionList il=method.getCode().getInstructionList();
  InlineData inlineData=new InlineData();
  for (  InvokeSite invoke : method.getCode().getInvokeSites()) {
    CallString cs=new CallString(invoke);
    while (invoke != null) {
      MethodInfo invokee=helper.devirtualize(cs);
      if (checkInvoke(invoke,cs,invokee,inlineData)) {
        invoke=performSimpleInline(invoke,invokee,inlineData);
        inlineCounter++;
        if (inlineData.getInvokeSite() != null) {
          cs.push(inlineData.getInvokeSite());
        }
 else {
          break;
        }
      }
 else {
        break;
      }
    }
  }
}","@Override public void optimizeMethod(MethodInfo method){
  ConstantPoolGen cpg=method.getConstantPoolGen();
  InstructionList il=method.getCode().getInstructionList();
  InlineData inlineData=new InlineData();
  List<InvokeSite> invokes=new ArrayList<InvokeSite>(method.getCode().getInvokeSites());
  Collections.sort(invokes,new Comparator<InvokeSite>(){
    @Override public int compare(    InvokeSite o1,    InvokeSite o2){
      return o1.getInstructionHandle().getPosition() - o2.getInstructionHandle().getPosition();
    }
  }
);
  for (  InvokeSite invoke : invokes) {
    CallString cs=new CallString(invoke);
    while (invoke != null) {
      MethodInfo invokee=helper.devirtualize(cs);
      if (checkInvoke(invoke,cs,invokee,inlineData)) {
        invoke=performSimpleInline(invoke,invokee,inlineData);
        inlineCounter++;
        if (inlineData.getInvokeSite() != null) {
          cs.push(inlineData.getInvokeSite());
        }
 else {
          break;
        }
      }
 else {
        break;
      }
    }
  }
}",0.7925170068027211
186574,"/** 
 * @param methodInfo a possible invokee
 * @return true if this invokeSite may invoke the method. Does not use the callgraph to check.For interface invoke sites this can return UNKNOWN if the class of the given method implementation does not implement the referenced interface.
 */
public Ternary canInvoke(MethodInfo methodInfo){
  MethodRef invokeeRef=getInvokeeRef();
  MethodInfo method=invokeeRef.getMethodInfo();
  if (!isVirtual()) {
    return Ternary.valueOf(methodInfo.equals(invokeeRef.getMethodInfo()));
  }
  if (method == null) {
    return Ternary.UNKNOWN;
  }
  if (!methodInfo.getClassInfo().isSubclassOf(invokeeRef.getClassInfo())) {
    if (isInvokeInterface() && !methodInfo.getClassInfo().isInterface()) {
      if (!invokeeRef.getMethodSignature().equals(methodInfo.getMethodSignature())) {
        return Ternary.FALSE;
      }
      return Ternary.UNKNOWN;
    }
    return Ternary.FALSE;
  }
  return Ternary.valueOf(methodInfo.overrides(method,true));
}","/** 
 * @param methodInfo a possible invokee
 * @return true if this invokeSite may invoke the method. Does not use the callgraph to check.For interface invoke sites this can return UNKNOWN if the class of the given method implementation does not implement the referenced interface.
 */
public Ternary canInvoke(MethodInfo methodInfo){
}",0.5102195306585919
186575,"private void updateExecCounts(DirectedGraph<ExecutionContext,ContextEdge> dag){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(dag);
  while (topOrder.hasNext()) {
    ExecutionContext next=topOrder.next();
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + next);
    }
    updateChilds(next,callGraph.getChildren(next));
  }
}","private void updateExecCounts(DirectedGraph<ExecutionContext,ContextEdge> dag){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(dag);
  while (topOrder.hasNext()) {
    ExecutionContext next=topOrder.next();
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + next);
    }
    updateChilds(next);
  }
}",0.9662650602409638
186576,"private void updateChilds(ExecutionContext context,List<ExecutionContext> childs){
  long ecCount=nodeCount.get(context);
  List<ExecutionContext> emptyCSNodes=new LinkedList<ExecutionContext>();
  for (  ExecutionContext child : childs) {
    long count;
    if (!child.getCallString().isEmpty()) {
      count=ecCount * getExecFrequency(context,child.getCallString().top().getInstructionHandle());
      addExecCount(child,count);
    }
 else {
      emptyCSNodes.add(child);
    }
  }
  if (emptyCSNodes.isEmpty())   return;
  for (  InvokeSite invokeSite : context.getMethodInfo().getCode().getInvokeSites()) {
    long count=getExecCount(context,invokeSite.getInstructionHandle());
    for (    ExecutionContext child : emptyCSNodes) {
      if (invokeSite.canInvoke(child.getMethodInfo()) != Ternary.FALSE) {
        addExecCount(child,count);
      }
    }
  }
}","private void updateChilds(ExecutionContext context){
  long ecCount=nodeCount.get(context);
  for (  Map.Entry<InvokeSite,Set<ExecutionContext>> entry : callGraph.getChildsPerInvokeSite(context).entrySet()) {
    InvokeSite invokeSite=entry.getKey();
    long count=ecCount * getExecFrequency(context,invokeSite.getInstructionHandle());
    for (    ExecutionContext child : entry.getValue()) {
      addExecCount(child,count);
    }
  }
}",0.1177370030581039
186577,"private Set<MethodInfo> runAnalysis(DirectedGraph<ExecutionContext,ContextEdge> reversed){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(reversed);
  Set<MethodInfo> changed=new HashSet<MethodInfo>();
  while (topOrder.hasNext()) {
    ExecutionContext node=topOrder.next();
    RecursiveWcetAnalysis<AnalysisContextLocal>.LocalWCETSolution sol=recursiveAnalysis.computeSolution(node.getMethodInfo(),new AnalysisContextLocal(cacheApproximation,node.getCallString()));
    wcaNodeFlow.put(node,sol.getNodeFlowVirtual());
    if (node.getMethodInfo().equals(wcetTool.getTargetMethod())) {
      logger.info(""String_Node_Str"" + sol.getCost().getCost());
    }
    changed.add(node.getMethodInfo());
  }
  return changed;
}","private Set<MethodInfo> runAnalysis(DirectedGraph<ExecutionContext,ContextEdge> reversed){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(reversed);
  Set<MethodInfo> changed=new HashSet<MethodInfo>();
  while (topOrder.hasNext()) {
    ExecutionContext node=topOrder.next();
    RecursiveWcetAnalysis<AnalysisContextLocal>.LocalWCETSolution sol=recursiveAnalysis.computeSolution(node.getMethodInfo(),new AnalysisContextLocal(cacheApproximation,node.getCallString()));
    wcaNodeFlow.put(node,sol.getNodeFlowVirtual());
    if (node.getMethodInfo().equals(wcetTool.getTargetMethod())) {
      lastWCET=sol.getCost().getCost();
      logger.info(""String_Node_Str"" + lastWCET);
    }
    changed.add(node.getMethodInfo());
  }
  return changed;
}",0.9561998766193708
186578,void initialize();,void initialize(GreedyConfig config);,0.6545454545454545
186579,"public static void registerOptions(OptionGroup options){
  options.addOption(GREEDY_ORDER);
  options.addOption(TARGETS);
  options.addOption(USE_WCEP);
  options.addOption(USE_WCA_EXEC_COUNT);
  options.addOption(USE_FREQUENCY_ONLY);
  options.addOption(CACHE_ANALYSIS_TYPE);
  options.addOption(WCA_CACHE_APPROXIMATION);
  options.addOption(DUMP_TARGET_CALLGRAPH);
  options.addOption(MAX_STEPS);
}","public static void registerOptions(OptionGroup options){
  options.addOption(GREEDY_ORDER);
  options.addOption(TARGETS);
  options.addOption(USE_WCEP);
  options.addOption(USE_WCA_EXEC_COUNT);
  options.addOption(USE_FREQUENCY_ONLY);
  options.addOption(CACHE_ANALYSIS_TYPE);
  options.addOption(WCA_CACHE_APPROXIMATION);
  options.addOption(DUMP_TARGET_CALLGRAPH);
  options.addOption(MAX_STEPS);
  options.addOption(DUMP_STATS);
}",0.9603841536614646
186580,"private void loadOptions() throws BadConfigurationException {
  String targetNames=options.getOption(TARGETS);
  if (""String_Node_Str"".equals(targetNames)) {
    targets=new ArrayList<MethodInfo>(AppInfo.getSingleton().getCallGraph().getRootMethods());
  }
 else   if (""String_Node_Str"".equals(targetNames)) {
    targets=jcopter.getJConfig().getWCATargets();
  }
 else {
    targets=Config.parseMethodList(targetNames);
  }
  useWCEP=useWCA() && options.getOption(USE_WCEP);
  GreedyOrder order=getOrder();
  if (order == GreedyOrder.BottomUp || order == GreedyOrder.TopDown) {
    logger.warn(""String_Node_Str"" + order + ""String_Node_Str"");
    useWCEP=false;
  }
}","private void loadOptions() throws BadConfigurationException {
  String targetNames=options.getOption(TARGETS);
  if (""String_Node_Str"".equals(targetNames)) {
    targets=new ArrayList<MethodInfo>(AppInfo.getSingleton().getCallGraph().getRootMethods());
  }
 else   if (""String_Node_Str"".equals(targetNames)) {
    targets=jcopter.getJConfig().getWCATargets();
  }
 else {
    targets=Config.parseMethodList(targetNames);
  }
  useWCEP=useWCA() && options.getOption(USE_WCEP);
  GreedyOrder order=getOrder();
  if (useWCEP && (order == GreedyOrder.BottomUp || order == GreedyOrder.TopDown)) {
    logger.warn(""String_Node_Str"" + order + ""String_Node_Str"");
    useWCEP=false;
  }
}",0.9903489235337788
186581,"public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  resetCounters();
  boolean useWCAProvider=config.useWCA() && config.useWCAExecCount();
  GreedyOrder order=config.getOrder();
  if (order != GreedyOrder.WCAFirst) {
    if (!config.getTargetMethodSet().equals(config.getWCATargetSet())) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"");
      useWCAProvider=false;
    }
  }
  AnalysisManager analyses=initializeAnalyses(config.useWCEP() || useWCAProvider);
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    GainCalculator gc=new GainCalculator(analyses);
    if (config.useWCEP()) {
      logger.info(""String_Node_Str"");
      selector=new WCEPRebateSelector(analyses,gc,config.getMaxCodesize());
    }
 else {
      logger.info(""String_Node_Str"");
      selector=new WCETRebateSelector(analyses,gc,config.getMaxCodesize());
    }
  }
 else {
    logger.info(""String_Node_Str"");
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
  }
  selector.initialize();
  ExecFrequencyProvider ecp=useWCAProvider ? analyses.getWCAInvoker() : analyses.getExecFrequencyAnalysis();
  if (config.useLocalExecCount()) {
    ecp=new LocalExecFrequencyProvider(ecp);
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    logger.info(""String_Node_Str"");
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,ecp,selector,wcaMethods);
    selector.printStatistics();
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    logger.info(""String_Node_Str"");
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
    selector.initialize();
    ecp=analyses.getExecFrequencyAnalysis();
    if (config.useLocalExecCount()) {
      ecp=new LocalExecFrequencyProvider(ecp);
    }
    optimizeMethods(analyses,ecp,selector,others);
  }
 else   if (order == GreedyOrder.TopDown || order == GreedyOrder.BottomUp) {
    if (config.useWCA() && !analyses.hasWCATargetsOnly()) {
      throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
    }
    TopologicalOrderIterator<MethodNode,InvokeEdge> topOrder=new TopologicalOrderIterator<MethodNode,InvokeEdge>(analyses.getTargetCallGraph().getAcyclicMergedGraph(order == GreedyOrder.BottomUp));
    while (topOrder.hasNext()) {
      MethodNode node=topOrder.next();
      optimizeMethods(analyses,ecp,selector,Collections.singleton(node.getMethodInfo()));
    }
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  selector.printStatistics();
  printStatistics();
}","public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  resetCounters();
  boolean useWCAProvider=config.useWCA() && config.useWCAExecCount();
  GreedyOrder order=config.getOrder();
  if (order != GreedyOrder.WCAFirst) {
    if (!config.getTargetMethodSet().equals(config.getWCATargetSet())) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"");
      useWCAProvider=false;
    }
  }
  AnalysisManager analyses=initializeAnalyses(config.useWCEP() || useWCAProvider);
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    GainCalculator gc=new GainCalculator(analyses);
    if (config.useWCEP()) {
      logger.info(""String_Node_Str"");
      selector=new WCEPRebateSelector(analyses,gc,config.getMaxCodesize());
    }
 else {
      logger.info(""String_Node_Str"");
      selector=new WCETRebateSelector(analyses,gc,config.getMaxCodesize());
    }
  }
 else {
    logger.info(""String_Node_Str"");
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
  }
  selector.initialize(config);
  ExecFrequencyProvider ecp=useWCAProvider ? analyses.getWCAInvoker() : analyses.getExecFrequencyAnalysis();
  if (config.useLocalExecCount()) {
    ecp=new LocalExecFrequencyProvider(ecp);
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    logger.info(""String_Node_Str"");
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,ecp,selector,wcaMethods);
    selector.printStatistics();
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    logger.info(""String_Node_Str"");
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
    selector.initialize(config);
    ecp=analyses.getExecFrequencyAnalysis();
    if (config.useLocalExecCount()) {
      ecp=new LocalExecFrequencyProvider(ecp);
    }
    optimizeMethods(analyses,ecp,selector,others);
  }
 else   if (order == GreedyOrder.TopDown || order == GreedyOrder.BottomUp) {
    if (config.useWCA() && !analyses.hasWCATargetsOnly()) {
      throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
    }
    TopologicalOrderIterator<MethodNode,InvokeEdge> topOrder=new TopologicalOrderIterator<MethodNode,InvokeEdge>(analyses.getTargetCallGraph().getAcyclicMergedGraph(order == GreedyOrder.BottomUp));
    while (topOrder.hasNext()) {
      MethodNode node=topOrder.next();
      optimizeMethods(analyses,ecp,selector,Collections.singleton(node.getMethodInfo()));
    }
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  selector.printStatistics();
  printStatistics();
}",0.9982808022922636
186582,"@Override public void printStatistics(){
  logger.info(""String_Node_Str"" + globalCodesize + ""String_Node_Str"");
}","@Override public void printStatistics(){
  logger.info(""String_Node_Str"" + globalCodesize + ""String_Node_Str"");
  dumpStats();
  if (dump != null) {
    dump.close();
  }
}",0.7929824561403509
186583,"protected void logSelection(ExecFrequencyProvider ecp,RebateRatio ratio){
  if (ratio == null)   return;
  logger.info(""String_Node_Str"" + ratio.getRatio() + ""String_Node_Str""+ ratio.getGain()+ ""String_Node_Str""+ ratio.getCandidate().getLocalGain()+ ""String_Node_Str""+ ratio.getCandidate().getDeltaCacheMissCosts(analyses,ecp)+ ""String_Node_Str""+ analyses.getMethodCacheAnalysis().getDeltaCacheMissCosts(ecp,ratio.getCandidate())+ ""String_Node_Str""+ ratio.getCandidate().getDeltaLocalCodesize()+ ""String_Node_Str""+ ecp.getExecCount(ratio.getCandidate().getMethod(),ratio.getCandidate().getEntry()));
}","protected void logSelection(ExecFrequencyProvider ecp,RebateRatio ratio){
  if (ratio == null)   return;
  long localGain=ratio.getCandidate().getLocalGain();
  long cache=analyses.getMethodCacheAnalysis().getDeltaCacheMissCosts(ecp,ratio.getCandidate());
  long localCache=ratio.getCandidate().getDeltaCacheMissCosts(analyses,ecp);
  int codesize=ratio.getCandidate().getDeltaLocalCodesize();
  long execCount=ecp.getExecCount(ratio.getCandidate().getMethod(),ratio.getCandidate().getEntry());
  logger.info(""String_Node_Str"" + ratio.getRatio() + ""String_Node_Str""+ ratio.getGain()+ ""String_Node_Str""+ localGain+ ""String_Node_Str""+ cache+ ""String_Node_Str""+ localCache+ ""String_Node_Str""+ codesize+ ""String_Node_Str""+ execCount);
  dumpStats();
  if (dump != null) {
    dump.print(""String_Node_Str"" + ratio.getCandidate().toString());
    dump.print(""String_Node_Str"" + ratio.getRatio() + ""String_Node_Str""+ ratio.getGain()+ ""String_Node_Str""+ localGain);
    dump.print(""String_Node_Str"" + cache + ""String_Node_Str""+ localCache+ ""String_Node_Str""+ codesize+ ""String_Node_Str""+ execCount);
    dump.println();
  }
}",0.3469150174621653
186584,"@Override public void initialize(){
  globalCodesize=0;
  if (usesCodeRemover) {
    for (    MethodInfo method : AppInfo.getSingleton().getCallGraph().getMethodInfos()) {
      if (!method.hasCode())       continue;
      globalCodesize+=method.getCode().getNumberOfBytes();
    }
  }
 else {
    for (    ClassInfo cls : AppInfo.getSingleton().getClassInfos()) {
      for (      MethodInfo method : cls.getMethods()) {
        if (!method.hasCode())         continue;
        globalCodesize+=method.getCode().getNumberOfBytes();
      }
    }
  }
  DFSVisitor<ExecutionContext,ContextEdge> visitor=new EmptyDFSVisitor<ExecutionContext,ContextEdge>(){
    private int counter=1;
    @Override public void postorder(    ExecutionContext node){
      depthMap.put(node.getMethodInfo(),counter++);
    }
  }
;
  DirectedGraph<ExecutionContext,ContextEdge> graph=analyses.getTargetCallGraph().getReversedGraph();
  DFSTraverser<ExecutionContext,ContextEdge> traverser=new DFSTraverser<ExecutionContext,ContextEdge>(visitor);
  traverser.traverse(graph);
  logger.info(""String_Node_Str"" + globalCodesize + ""String_Node_Str"");
}","@Override public void initialize(GreedyConfig config){
  globalCodesize=0;
  if (usesCodeRemover) {
    for (    MethodInfo method : AppInfo.getSingleton().getCallGraph().getMethodInfos()) {
      if (!method.hasCode())       continue;
      globalCodesize+=method.getCode().getNumberOfBytes();
    }
  }
 else {
    for (    ClassInfo cls : AppInfo.getSingleton().getClassInfos()) {
      for (      MethodInfo method : cls.getMethods()) {
        if (!method.hasCode())         continue;
        globalCodesize+=method.getCode().getNumberOfBytes();
      }
    }
  }
  DFSVisitor<ExecutionContext,ContextEdge> visitor=new EmptyDFSVisitor<ExecutionContext,ContextEdge>(){
    private int counter=1;
    @Override public void postorder(    ExecutionContext node){
      depthMap.put(node.getMethodInfo(),counter++);
    }
  }
;
  DirectedGraph<ExecutionContext,ContextEdge> graph=analyses.getTargetCallGraph().getReversedGraph();
  DFSTraverser<ExecutionContext,ContextEdge> traverser=new DFSTraverser<ExecutionContext,ContextEdge>(visitor);
  traverser.traverse(graph);
  logger.info(""String_Node_Str"" + globalCodesize + ""String_Node_Str"");
  if (config.doDumpStats()) {
    try {
      dump=new PrintWriter(config.getStatsFile());
      dump.print(""String_Node_Str"");
      if (analyses.useWCAInvoker())       dump.print(""String_Node_Str"");
      dump.println(""String_Node_Str"");
    }
 catch (    FileNotFoundException e) {
      throw new AppInfoError(""String_Node_Str"",e);
    }
  }
}",0.8603138155376961
186585,"/** 
 * Inline all methods which do not increase the code size.
 */
public void performSimpleInline(){
  if (getJConfig().doAssumeDynamicClassLoader()) {
    logger.info(""String_Node_Str"");
    return;
  }
  logger.info(""String_Node_Str"");
  new SimpleInliner(jcopter,inlineConfig).optimize();
  logger.info(""String_Node_Str"");
}","/** 
 * Inline all methods which do not increase the code size.
 */
public void performSimpleInline(){
  if (!getOptimizeOptions().getOption(SIMPLE_INLINER)) {
    logger.info(""String_Node_Str"");
    return;
  }
  if (getJConfig().doAssumeDynamicClassLoader()) {
    logger.info(""String_Node_Str"");
    return;
  }
  logger.info(""String_Node_Str"");
  new SimpleInliner(jcopter,inlineConfig).optimize();
  logger.info(""String_Node_Str"");
}",0.8578878748370273
186586,"private void optimizeMethods(AnalysisManager analyses,ExecFrequencyProvider ecp,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  if (maxSteps > 0 && countOptimized >= maxSteps) {
    return;
  }
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates(ecp);
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates(ecp);
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      if (maxSteps > 0 && countOptimized >= maxSteps) {
        return;
      }
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(ecp,optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,ecp,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(ecp,methods);
    }
 else {
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + changeSet.size());
      }
      selector.sortCandidates(ecp,changeSet);
    }
    candidates=selector.selectNextCandidates(ecp);
  }
}","private void optimizeMethods(AnalysisManager analyses,ExecFrequencyProvider ecp,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  if (maxSteps > 0 && countOptimized >= maxSteps) {
    return;
  }
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates(ecp);
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates(ecp);
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      if (maxSteps > 0 && countOptimized >= maxSteps) {
        return;
      }
      method.getCode().compile();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      if (c.getStart() != null) {
        stacksize.analyze(c.getStart(),c.getEnd());
        int locals=c.getMaxLocalsInRegion();
        for (        CodeOptimizer optimizer : optimizers) {
          Collection<Candidate> found;
          found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
          newCandidates.addAll(found);
        }
        countCandidates+=newCandidates.size();
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(ecp,optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,ecp,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(ecp,methods);
    }
 else {
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + changeSet.size());
      }
      selector.sortCandidates(ecp,changeSet);
    }
    candidates=selector.selectNextCandidates(ecp);
  }
}",0.8931693104564584
186587,"@Override public boolean optimize(AnalysisManager analyses,StacksizeAnalysis stacksize){
  MethodCode code=getMethod().getCode();
  InstructionList il=code.getInstructionList();
  assert(start == end);
  InstructionHandle invoke=start;
  InstructionHandle next=end.getNext();
  insertPrologue(il,next);
  Map<InvokeSite,InvokeSite> invokeMap;
  CallString callString=getInlineCallString(code,invoke).push(invokeSite);
  invokeMap=insertInvokee(analyses,callString,il,next);
  start=invoke.getNext();
  end=next.getPrev();
  if (end == null) {
    start=null;
  }
  try {
    il.delete(invoke);
  }
 catch (  TargetLostException e) {
    code.retarget(e,start);
  }
  il.setPositions();
  for (  CallGraph cg : analyses.getCallGraphs()) {
    updateCallgraph(cg,invokeMap);
  }
  updateAnalyses(analyses,invokeMap);
  isLastInvoke=!analyses.getAppInfoCallGraph().containsMethod(invokee);
  return true;
}","@Override public boolean optimize(AnalysisManager analyses,StacksizeAnalysis stacksize){
  MethodCode code=getMethod().getCode();
  InstructionList il=code.getInstructionList();
  assert(start == end);
  InstructionHandle invoke=start;
  InstructionHandle next=end.getNext();
  insertPrologue(il,next);
  Map<InvokeSite,InvokeSite> invokeMap;
  CallString callString=getInlineCallString(code,invoke).push(invokeSite);
  invokeMap=insertInvokee(analyses,callString,il,next);
  start=invoke.getNext();
  end=next.getPrev();
  if (end == null) {
    start=null;
  }
  if (end == invoke) {
    start=null;
    end=null;
  }
  InstructionHandle tmp=invoke.getNext();
  try {
    il.delete(invoke);
  }
 catch (  TargetLostException e) {
    code.retarget(e,tmp);
  }
  il.setPositions();
  for (  CallGraph cg : analyses.getCallGraphs()) {
    updateCallgraph(cg,invokeMap);
  }
  updateAnalyses(analyses,invokeMap);
  isLastInvoke=!analyses.getAppInfoCallGraph().containsMethod(invokee);
  return true;
}",0.9437729900157644
186588,"private Method replace(Method method){
  MethodGen mg=new MethodGen(method,clazz.getClassName(),cpoolgen);
  InstructionList il=mg.getInstructionList();
  InstructionFinder f=new InstructionFinder(il);
  String methodId=method.getName() + method.getSignature();
  OldMethodInfo mi=getCli().getMethodInfo(methodId);
  String invokeStr=""String_Node_Str"";
  for (Iterator i=f.search(invokeStr); i.hasNext(); ) {
    InstructionHandle[] match=(InstructionHandle[])i.next();
    InstructionHandle first=match[0];
    InvokeInstruction ii=(InvokeInstruction)first.getInstruction();
    if (ii.getClassName(cpoolgen).equals(JOPizer.nativeClass)) {
      short opid=(short)JopInstr.getNative(ii.getMethodName(cpoolgen));
      if (opid == -1) {
        System.err.println(method.getName() + ""String_Node_Str"" + ii.getMethodName(cpoolgen)+ ""String_Node_Str"");
        first.setInstruction(new NOP());
      }
 else {
        first.setInstruction(new NativeInstruction(opid,(short)1));
        ((JOPizer)ai).outTxt.println(""String_Node_Str"" + first.getPosition());
        if (JOPizer.dumpMgci) {
          il.setPositions();
          int pc=first.getPosition();
          GCRTMethodInfo.removePC(pc + 2,mi);
          GCRTMethodInfo.removePC(pc + 1,mi);
        }
      }
    }
    if (ii instanceof INVOKESPECIAL) {
      if (!ii.getMethodName(cpoolgen).equals(""String_Node_Str"")) {
        if (!getCli().clazz.getClassName().equals(ii.getClassName(cpoolgen))) {
          Integer idx=new Integer(ii.getIndex());
          int new_index=getCli().cpoolUsed.indexOf(idx) + 1;
          first.setInstruction(new JOPSYS_INVOKESUPER((short)new_index));
        }
      }
    }
  }
  if (JOPizer.CACHE_INVAL) {
    f=new InstructionFinder(il);
    String fieldInstr=""String_Node_Str"";
    for (Iterator i=f.search(fieldInstr); i.hasNext(); ) {
      InstructionHandle[] match=(InstructionHandle[])i.next();
      InstructionHandle ih=match[0];
      FieldInstruction fi=(FieldInstruction)ih.getInstruction();
      JavaClass jc=JOPizer.jz.cliMap.get(fi.getClassName(cpoolgen)).clazz;
      Field field=null;
      while (field == null) {
        Field[] fields=jc.getFields();
        for (int k=0; k < fields.length; k++) {
          if (fields[k].getName().equals(fi.getFieldName(cpoolgen))) {
            field=fields[k];
            break;
          }
        }
        if (field == null) {
          try {
            jc=jc.getSuperClass();
          }
 catch (          ClassNotFoundException e) {
            e.printStackTrace();
            throw new Error();
          }
        }
      }
      if (field.isVolatile()) {
        if (field.getType().getSize() < 2) {
          if (fi instanceof GETFIELD || fi instanceof GETSTATIC) {
            ih.setInstruction(new InvalidateInstruction());
            ih=il.append(ih,fi);
          }
        }
 else {
          ih.setInstruction(new ACONST_NULL());
          ih=il.append(ih,new MONITORENTER());
          ih=il.append(ih,fi);
          ih=il.append(ih,new ACONST_NULL());
          ih=il.append(ih,new MONITOREXIT());
        }
      }
    }
  }
  f=new InstructionFinder(il);
  String cpInstr=""String_Node_Str"";
  for (Iterator it=f.search(cpInstr); it.hasNext(); ) {
    InstructionHandle[] match=(InstructionHandle[])it.next();
    InstructionHandle ih=match[0];
    CPInstruction cpii=(CPInstruction)ih.getInstruction();
    int index=cpii.getIndex();
    FieldInstruction fi=null;
    Type ft=null;
    if (cpii instanceof FieldInstruction) {
      fi=(FieldInstruction)ih.getInstruction();
      ft=fi.getFieldType(cpoolgen);
    }
    Integer idx=new Integer(index);
    int pos=getCli().cpoolUsed.indexOf(idx);
    int new_index=pos + 1;
    if (cpii instanceof GETFIELD || cpii instanceof PUTFIELD || cpii instanceof GETSTATIC|| cpii instanceof PUTSTATIC) {
      new_index=getFieldOffset(cp,index);
    }
 else {
      if (pos == -1) {
        System.out.println(""String_Node_Str"" + index + ""String_Node_Str""+ cpoolgen.getConstant(index)+ ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + getCli().cpoolUsed);
        System.out.println(""String_Node_Str"" + cpoolgen);
        System.exit(-1);
      }
    }
    cpii.setIndex(new_index);
    if (cpii instanceof FieldInstruction) {
      boolean isRef=ft instanceof ReferenceType;
      boolean isLong=ft == BasicType.LONG || ft == BasicType.DOUBLE;
      if (fi instanceof GETSTATIC) {
        if (isRef) {
          ih.setInstruction(new GETSTATIC_REF((short)new_index));
        }
 else         if (isLong) {
          ih.setInstruction(new GETSTATIC_LONG((short)new_index));
        }
      }
 else       if (fi instanceof PUTSTATIC) {
        if (isRef) {
          if (!com.jopdesign.build.JOPizer.USE_RTTM) {
            ih.setInstruction(new PUTSTATIC_REF((short)new_index));
          }
        }
 else         if (isLong) {
          ih.setInstruction(new PUTSTATIC_LONG((short)new_index));
        }
      }
 else       if (fi instanceof GETFIELD) {
        if (isRef) {
          ih.setInstruction(new GETFIELD_REF((short)new_index));
        }
 else         if (isLong) {
          ih.setInstruction(new GETFIELD_LONG((short)new_index));
        }
      }
 else       if (fi instanceof PUTFIELD) {
        if (isRef) {
          if (!com.jopdesign.build.JOPizer.USE_RTTM) {
            ih.setInstruction(new PUTFIELD_REF((short)new_index));
          }
        }
 else         if (isLong) {
          ih.setInstruction(new PUTFIELD_LONG((short)new_index));
        }
      }
    }
  }
  Method m=mg.getMethod();
  il.dispose();
  return m;
}","private Method replace(Method method){
  MethodGen mg=new MethodGen(method,clazz.getClassName(),cpoolgen);
  InstructionList il=mg.getInstructionList();
  InstructionFinder f=new InstructionFinder(il);
  String methodId=method.getName() + method.getSignature();
  OldMethodInfo mi=getCli().getMethodInfo(methodId);
  String invokeStr=""String_Node_Str"";
  for (Iterator i=f.search(invokeStr); i.hasNext(); ) {
    InstructionHandle[] match=(InstructionHandle[])i.next();
    InstructionHandle first=match[0];
    InvokeInstruction ii=(InvokeInstruction)first.getInstruction();
    if (ii.getClassName(cpoolgen).equals(JOPizer.nativeClass)) {
      short opid=(short)JopInstr.getNative(ii.getMethodName(cpoolgen));
      if (opid == -1) {
        System.err.println(method.getName() + ""String_Node_Str"" + ii.getMethodName(cpoolgen)+ ""String_Node_Str"");
        first.setInstruction(new NOP());
      }
 else {
        first.setInstruction(new NativeInstruction(opid,(short)1));
        ((JOPizer)ai).outTxt.println(""String_Node_Str"" + first.getPosition());
        if (JOPizer.dumpMgci) {
          il.setPositions();
          int pc=first.getPosition();
          GCRTMethodInfo.removePC(pc + 2,mi);
          GCRTMethodInfo.removePC(pc + 1,mi);
        }
      }
    }
    if (ii instanceof INVOKESPECIAL) {
      if (!ii.getMethodName(cpoolgen).equals(""String_Node_Str"")) {
        boolean isSuper=false;
        String declaredType=ii.getClassName(cpoolgen);
        JopClassInfo cls=getCli();
        OldClassInfo superClass=cls.superClass;
        while (superClass != null) {
          if (superClass.clazz.getClassName().equals(declaredType)) {
            isSuper=true;
            break;
          }
          if (""String_Node_Str"".equals(superClass.clazz.getClassName())) {
            break;
          }
          superClass=superClass.superClass;
        }
        if (isSuper) {
          Integer idx=ii.getIndex();
          int new_index=getCli().cpoolUsed.indexOf(idx) + 1;
          first.setInstruction(new JOPSYS_INVOKESUPER((short)new_index));
        }
      }
    }
  }
  if (JOPizer.CACHE_INVAL) {
    f=new InstructionFinder(il);
    String fieldInstr=""String_Node_Str"";
    for (Iterator i=f.search(fieldInstr); i.hasNext(); ) {
      InstructionHandle[] match=(InstructionHandle[])i.next();
      InstructionHandle ih=match[0];
      FieldInstruction fi=(FieldInstruction)ih.getInstruction();
      JavaClass jc=JOPizer.jz.cliMap.get(fi.getClassName(cpoolgen)).clazz;
      Field field=null;
      while (field == null) {
        Field[] fields=jc.getFields();
        for (int k=0; k < fields.length; k++) {
          if (fields[k].getName().equals(fi.getFieldName(cpoolgen))) {
            field=fields[k];
            break;
          }
        }
        if (field == null) {
          try {
            jc=jc.getSuperClass();
          }
 catch (          ClassNotFoundException e) {
            e.printStackTrace();
            throw new Error();
          }
        }
      }
      if (field.isVolatile()) {
        if (field.getType().getSize() < 2) {
          if (fi instanceof GETFIELD || fi instanceof GETSTATIC) {
            ih.setInstruction(new InvalidateInstruction());
            ih=il.append(ih,fi);
          }
        }
 else {
          ih.setInstruction(new ACONST_NULL());
          ih=il.append(ih,new MONITORENTER());
          ih=il.append(ih,fi);
          ih=il.append(ih,new ACONST_NULL());
          ih=il.append(ih,new MONITOREXIT());
        }
      }
    }
  }
  f=new InstructionFinder(il);
  String cpInstr=""String_Node_Str"";
  for (Iterator it=f.search(cpInstr); it.hasNext(); ) {
    InstructionHandle[] match=(InstructionHandle[])it.next();
    InstructionHandle ih=match[0];
    CPInstruction cpii=(CPInstruction)ih.getInstruction();
    int index=cpii.getIndex();
    FieldInstruction fi=null;
    Type ft=null;
    if (cpii instanceof FieldInstruction) {
      fi=(FieldInstruction)ih.getInstruction();
      ft=fi.getFieldType(cpoolgen);
    }
    Integer idx=new Integer(index);
    int pos=getCli().cpoolUsed.indexOf(idx);
    int new_index=pos + 1;
    if (cpii instanceof GETFIELD || cpii instanceof PUTFIELD || cpii instanceof GETSTATIC|| cpii instanceof PUTSTATIC) {
      new_index=getFieldOffset(cp,index);
    }
 else {
      if (pos == -1) {
        System.out.println(""String_Node_Str"" + index + ""String_Node_Str""+ cpoolgen.getConstant(index)+ ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + getCli().cpoolUsed);
        System.out.println(""String_Node_Str"" + cpoolgen);
        System.exit(-1);
      }
    }
    cpii.setIndex(new_index);
    if (cpii instanceof FieldInstruction) {
      boolean isRef=ft instanceof ReferenceType;
      boolean isLong=ft == BasicType.LONG || ft == BasicType.DOUBLE;
      if (fi instanceof GETSTATIC) {
        if (isRef) {
          ih.setInstruction(new GETSTATIC_REF((short)new_index));
        }
 else         if (isLong) {
          ih.setInstruction(new GETSTATIC_LONG((short)new_index));
        }
      }
 else       if (fi instanceof PUTSTATIC) {
        if (isRef) {
          if (!com.jopdesign.build.JOPizer.USE_RTTM) {
            ih.setInstruction(new PUTSTATIC_REF((short)new_index));
          }
        }
 else         if (isLong) {
          ih.setInstruction(new PUTSTATIC_LONG((short)new_index));
        }
      }
 else       if (fi instanceof GETFIELD) {
        if (isRef) {
          ih.setInstruction(new GETFIELD_REF((short)new_index));
        }
 else         if (isLong) {
          ih.setInstruction(new GETFIELD_LONG((short)new_index));
        }
      }
 else       if (fi instanceof PUTFIELD) {
        if (isRef) {
          if (!com.jopdesign.build.JOPizer.USE_RTTM) {
            ih.setInstruction(new PUTFIELD_REF((short)new_index));
          }
        }
 else         if (isLong) {
          ih.setInstruction(new PUTFIELD_LONG((short)new_index));
        }
      }
    }
  }
  Method m=mg.getMethod();
  il.dispose();
  return m;
}",0.9571071027876068
186589,"private void loadMethod(MethodInfo method){
  MethodCode mcode=method.getCode();
  InstructionHandle exit;
  exit=(InstructionHandle)method.getCustomValue(KEY_NOP);
  if (exit == null) {
    exit=new InstructionList(new NOP()).getStart();
    method.setCustomValue(KEY_NOP,exit);
  }
  this.getStatements().add(exit);
  for (Iterator<?> l=mcode.getInstructionList(true,false).iterator(); l.hasNext(); ) {
    InstructionHandle handle=(InstructionHandle)l.next();
    this.getStatements().add(handle);
    Instruction instr=handle.getInstruction();
    if (instr instanceof BranchInstruction) {
      if (instr instanceof Select) {
        Select s=(Select)instr;
        InstructionHandle[] target=s.getTargets();
        for (        InstructionHandle aTarget : target) {
          this.getFlow().addEdge(new FlowEdge(handle,aTarget,FlowEdge.TRUE_EDGE));
        }
        this.getFlow().addEdge(new FlowEdge(handle,s.getTarget(),FlowEdge.FALSE_EDGE));
      }
 else {
        BranchInstruction b=(BranchInstruction)instr;
        this.getFlow().addEdge(new FlowEdge(handle,b.getTarget(),FlowEdge.TRUE_EDGE));
      }
    }
    if (handle.getNext() != null && !(instr instanceof UnconditionalBranch || instr instanceof Select || instr instanceof ReturnInstruction)) {
      if (instr instanceof BranchInstruction) {
        this.getFlow().addEdge(new FlowEdge(handle,handle.getNext(),FlowEdge.FALSE_EDGE));
      }
 else {
        this.getFlow().addEdge(new FlowEdge(handle,handle.getNext(),FlowEdge.NORMAL_EDGE));
      }
    }
    if (instr instanceof ReturnInstruction) {
      this.getFlow().addEdge(new FlowEdge(handle,exit,FlowEdge.NORMAL_EDGE));
    }
  }
}","private void loadMethod(MethodInfo method){
  MethodCode mcode=method.getCode();
  InstructionHandle exit;
  exit=(InstructionHandle)method.getCustomValue(KEY_NOP);
  if (exit == null) {
    exit=new InstructionList(new NOP()).getStart();
    method.setCustomValue(KEY_NOP,exit);
  }
  this.getStatements().add(exit);
  InstructionList il=mcode.getInstructionList(true,false);
  il.setPositions();
  for (Iterator<?> l=il.iterator(); l.hasNext(); ) {
    InstructionHandle handle=(InstructionHandle)l.next();
    this.getStatements().add(handle);
    Instruction instr=handle.getInstruction();
    if (instr instanceof BranchInstruction) {
      if (instr instanceof Select) {
        Select s=(Select)instr;
        InstructionHandle[] target=s.getTargets();
        for (        InstructionHandle aTarget : target) {
          this.getFlow().addEdge(new FlowEdge(handle,aTarget,FlowEdge.TRUE_EDGE));
        }
        this.getFlow().addEdge(new FlowEdge(handle,s.getTarget(),FlowEdge.FALSE_EDGE));
      }
 else {
        BranchInstruction b=(BranchInstruction)instr;
        this.getFlow().addEdge(new FlowEdge(handle,b.getTarget(),FlowEdge.TRUE_EDGE));
      }
    }
    if (handle.getNext() != null && !(instr instanceof UnconditionalBranch || instr instanceof Select || instr instanceof ReturnInstruction)) {
      if (instr instanceof BranchInstruction) {
        this.getFlow().addEdge(new FlowEdge(handle,handle.getNext(),FlowEdge.FALSE_EDGE));
      }
 else {
        this.getFlow().addEdge(new FlowEdge(handle,handle.getNext(),FlowEdge.NORMAL_EDGE));
      }
    }
    if (instr instanceof ReturnInstruction) {
      this.getFlow().addEdge(new FlowEdge(handle,exit,FlowEdge.NORMAL_EDGE));
    }
  }
}",0.965047393364929
186590,"@SuppressWarnings(""String_Node_Str"") public void dataflowAnalysis(boolean loopBounds){
  int callstringLength=appInfo.getCallstringLength();
  DFATool dfaTool=jcopter.getDfaTool();
  logger.info(""String_Node_Str"");
  dfaTool.setAnalyzeBootMethod(true);
  dfaTool.load();
  logger.info(""String_Node_Str"");
  dfaTool.runReceiverAnalysis(callstringLength);
  if (loopBounds) {
    logger.info(""String_Node_Str"");
    dfaTool.runLoopboundAnalysis(callstringLength);
  }
  dfaTool.cleanup();
}","@SuppressWarnings(""String_Node_Str"") public void dataflowAnalysis(boolean loopBounds){
  int callstringLength=appInfo.getCallstringLength();
  DFATool dfaTool=jcopter.getDfaTool();
  logger.info(""String_Node_Str"");
  dfaTool.setAnalyzeBootMethod(true);
  dfaTool.load();
  logger.info(""String_Node_Str"");
  dfaTool.runReceiverAnalysis(callstringLength);
  if (loopBounds) {
    logger.info(""String_Node_Str"");
    dfaTool.runLoopboundAnalysis(callstringLength);
    if (jcopter.useWCA()) {
      jcopter.getWcetTool().setHasDfaResults(true);
    }
  }
  dfaTool.cleanup();
}",0.8832391713747646
186591,"@Override public Collection<Candidate> findCandidates(MethodInfo method,AnalysisManager analyses,StacksizeAnalysis stacksize,int maxLocals,InstructionHandle start,InstructionHandle end){
  List<Candidate> candidates=new LinkedList<Candidate>();
  MethodCode code=method.getCode();
  InstructionHandle next=end.getNext();
  for (InstructionHandle ih=start; ih != next; ih=ih.getNext()) {
    if (code.isInvokeSite(ih)) {
      InvokeSite site=code.getInvokeSite(ih);
      CallString cs=new CallString(site);
      MethodInfo invokee=helper.devirtualize(cs);
      if (invokee == null)       continue;
      cs=getInlineCallString(code,ih).push(site);
      Candidate candidate=checkInvoke(code,cs,site,invokee,maxLocals);
      if (candidate == null) {
        continue;
      }
      if (!candidate.recalculate(analyses,stacksize)) {
        continue;
      }
      candidates.add(candidate);
    }
  }
  return candidates;
}","@Override public Collection<Candidate> findCandidates(MethodInfo method,AnalysisManager analyses,StacksizeAnalysis stacksize,int maxLocals,InstructionHandle start,InstructionHandle end){
  List<Candidate> candidates=new LinkedList<Candidate>();
  MethodCode code=method.getCode();
  InstructionHandle next=end.getNext();
  for (InstructionHandle ih=start; ih != next; ih=ih.getNext()) {
    if (code.isInvokeSite(ih)) {
      InvokeSite site=code.getInvokeSite(ih);
      CallString cs=new CallString(site);
      countInvokeSites++;
      MethodInfo invokee=helper.devirtualize(cs);
      if (invokee == null)       continue;
      countDevirtualized++;
      cs=getInlineCallString(code,ih).push(site);
      Candidate candidate=checkInvoke(code,cs,site,invokee,maxLocals);
      if (candidate == null) {
        continue;
      }
      if (!candidate.recalculate(analyses,stacksize)) {
        continue;
      }
      candidates.add(candidate);
    }
  }
  return candidates;
}",0.9716684155299056
186592,"@Override public void printStatistics(){
}","@Override public void printStatistics(){
  logger.info(""String_Node_Str"" + countInvokeSites + ""String_Node_Str""+ (countInvokeSites - countDevirtualized));
}",0.4242424242424242
186593,"@Override public void initialize(AnalysisManager analyses,Collection<MethodInfo> roots){
  if (!preciseCycleEstimate) {
    ExecutionContext dummy=new ExecutionContext(roots.iterator().next());
    WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
    InstructionList il=new InstructionList();
    storeCycles=(int)pm.getExecutionTime(dummy,il.append(new ASTORE(10)));
    checkNPCycles=0;
    checkNPCycles+=(int)pm.getExecutionTime(dummy,il.append(new DUP()));
    checkNPCycles+=(int)pm.getExecutionTime(dummy,il.append(new IFNONNULL(il.append(new ATHROW()))));
    deltaReturnCycles=(int)pm.getExecutionTime(dummy,il.append(new RETURN()));
    deltaReturnCycles-=(int)pm.getExecutionTime(dummy,il.append(new GOTO(il.getEnd())));
  }
}","@Override public void initialize(AnalysisManager analyses,Collection<MethodInfo> roots){
  if (!preciseCycleEstimate) {
    ExecutionContext dummy=new ExecutionContext(roots.iterator().next());
    WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
    InstructionList il=new InstructionList();
    storeCycles=(int)pm.getExecutionTime(dummy,il.append(new ASTORE(10)));
    checkNPCycles=0;
    checkNPCycles+=(int)pm.getExecutionTime(dummy,il.append(new DUP()));
    checkNPCycles+=(int)pm.getExecutionTime(dummy,il.append(new IFNONNULL(il.append(new ATHROW()))));
    deltaReturnCycles=(int)pm.getExecutionTime(dummy,il.append(new RETURN()));
    deltaReturnCycles-=(int)pm.getExecutionTime(dummy,il.append(new GOTO(il.getEnd())));
  }
  countInvokeSites=0;
  countDevirtualized=0;
}",0.9705128205128204
186594,"@Override public void optimizeMethod(MethodInfo method){
  ConstantPoolGen cpg=method.getConstantPoolGen();
  InstructionList il=method.getCode().getInstructionList();
  InlineData inlineData=new InlineData();
  List<InvokeSite> invokes=new ArrayList<InvokeSite>(method.getCode().getInvokeSites());
  Collections.sort(invokes,new Comparator<InvokeSite>(){
    @Override public int compare(    InvokeSite o1,    InvokeSite o2){
      return o1.getInstructionHandle().getPosition() - o2.getInstructionHandle().getPosition();
    }
  }
);
  for (  InvokeSite invoke : invokes) {
    CallString cs=new CallString(invoke);
    while (invoke != null) {
      MethodInfo invokee=helper.devirtualize(cs);
      if (checkInvoke(invoke,cs,invokee,inlineData)) {
        invoke=performSimpleInline(invoke,invokee,inlineData);
        inlineCounter++;
        if (inlineData.getInvokeSite() != null) {
          cs.push(inlineData.getInvokeSite());
        }
 else {
          break;
        }
      }
 else {
        break;
      }
    }
  }
}","@Override public void optimizeMethod(MethodInfo method){
  InlineData inlineData=new InlineData();
  List<InvokeSite> invokes=new ArrayList<InvokeSite>(method.getCode().getInvokeSites());
  Collections.sort(invokes,new Comparator<InvokeSite>(){
    @Override public int compare(    InvokeSite o1,    InvokeSite o2){
      return o1.getInstructionHandle().getPosition() - o2.getInstructionHandle().getPosition();
    }
  }
);
  for (  InvokeSite invoke : invokes) {
    CallString cs=new CallString(invoke);
    while (invoke != null) {
      countInvokeSites++;
      MethodInfo invokee=helper.devirtualize(cs);
      if (invokee == null)       break;
      countDevirtualized++;
      if (checkInvoke(invoke,cs,invokee,inlineData)) {
        invoke=performSimpleInline(invoke,invokee,inlineData);
        inlineCounter++;
        if (inlineData.getInvokeSite() != null) {
          cs.push(inlineData.getInvokeSite());
        }
 else {
          break;
        }
      }
 else {
        break;
      }
    }
  }
}",0.8998534440644846
186595,"@Override public void printStatistics(){
  logger.info(""String_Node_Str"" + inlineCounter + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + candidates + ""String_Node_Str""+ requiresNPCheck+ ""String_Node_Str""+ signatureMismatch+ ""String_Node_Str""+ unhandledInstructions+ ""String_Node_Str""+ codesizeTooLarge);
}","@Override public void printStatistics(){
  logger.info(""String_Node_Str"" + inlineCounter + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + countInvokeSites + ""String_Node_Str""+ (countInvokeSites - countDevirtualized));
  logger.info(""String_Node_Str"" + candidates + ""String_Node_Str""+ requiresNPCheck+ ""String_Node_Str""+ signatureMismatch+ ""String_Node_Str""+ unhandledInstructions+ ""String_Node_Str""+ codesizeTooLarge);
}",0.845945945945946
186596,"@Override public void initialize(){
  inlineCounter=0;
  candidates=0;
  unhandledInstructions=0;
  requiresNPCheck=0;
  signatureMismatch=0;
  codesizeTooLarge=0;
}","@Override public void initialize(){
  inlineCounter=0;
  candidates=0;
  unhandledInstructions=0;
  requiresNPCheck=0;
  signatureMismatch=0;
  codesizeTooLarge=0;
  countInvokeSites=0;
  countDevirtualized=0;
}",0.8776595744680851
186597,"/** 
 * Get a loop bound from the DFA for a certain loop and call string and merge it with the annotated value.
 * @return The loop bound to be used for further computations
 */
public LoopBound dfaLoopBound(BasicBlock headOfLoopBlock,ExecutionContext eCtx,LoopBound annotatedBound){
  LoopBounds lbAnalysis=project.getDfaLoopBounds();
  if (lbAnalysis == null)   return annotatedBound;
  MethodInfo methodInfo=headOfLoopBlock.getMethodInfo();
  int dfaUpperBound;
  try {
    dfaUpperBound=lbAnalysis.getBound(headOfLoopBlock.getLastInstruction(),eCtx.getCallString());
  }
 catch (  NullPointerException ex) {
    ex.printStackTrace();
    dfaUpperBound=-1;
  }
  if (dfaUpperBound < 0) {
    if (!printedLoopBoundInfoMessage.contains(headOfLoopBlock)) {
      logger.info(""String_Node_Str"" + methodInfo + ""String_Node_Str""+ headOfLoopBlock+ ""String_Node_Str""+ annotatedBound);
      printedLoopBoundInfoMessage.add(headOfLoopBlock);
    }
    return annotatedBound;
  }
  LoopBound loopBound;
  if (annotatedBound == null) {
    loopBound=LoopBound.boundedAbove(dfaUpperBound);
    logger.debug(""String_Node_Str"" + methodInfo + ""String_Node_Str"");
  }
 else {
    loopBound=annotatedBound.clone();
    loopBound.addBound(LoopBoundExpr.numUpperBound(dfaUpperBound),SymbolicMarker.LOOP_ENTRY);
    long loopUb=annotatedBound.getSimpleLoopBound().upperBound(eCtx);
    if (dfaUpperBound < loopUb) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + dfaUpperBound + ""String_Node_Str""+ loopUb+ ""String_Node_Str""+ methodInfo+ ""String_Node_Str""+ headOfLoopBlock);
      }
    }
 else     if (dfaUpperBound > loopUb) {
      logger.warn(""String_Node_Str"" + dfaUpperBound + ""String_Node_Str""+ loopUb+ ""String_Node_Str""+ methodInfo);
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + methodInfo);
      }
    }
  }
  if (!printedLoopBoundInfoMessage.contains(headOfLoopBlock)) {
    logger.info(""String_Node_Str"" + methodInfo + ""String_Node_Str""+ headOfLoopBlock+ ""String_Node_Str""+ loopBound+ ""String_Node_Str""+ annotatedBound);
    printedLoopBoundInfoMessage.add(headOfLoopBlock);
  }
  return loopBound;
}","/** 
 * Get a loop bound from the DFA for a certain loop and call string and merge it with the annotated value.
 * @return The loop bound to be used for further computations
 */
public LoopBound dfaLoopBound(BasicBlock headOfLoopBlock,ExecutionContext eCtx,LoopBound annotatedBound){
  LoopBounds lbAnalysis=project.getDfaLoopBounds();
  if (lbAnalysis == null)   return annotatedBound;
  MethodInfo methodInfo=headOfLoopBlock.getMethodInfo();
  int dfaUpperBound;
  try {
    dfaUpperBound=lbAnalysis.getBound(headOfLoopBlock.getLastInstruction(),eCtx.getCallString());
  }
 catch (  NullPointerException ex) {
    logger.error(""String_Node_Str"",ex);
    dfaUpperBound=-1;
  }
  if (dfaUpperBound < 0) {
    if (!printedLoopBoundInfoMessage.contains(headOfLoopBlock)) {
      logger.info(""String_Node_Str"" + methodInfo + ""String_Node_Str""+ headOfLoopBlock+ ""String_Node_Str""+ annotatedBound);
      printedLoopBoundInfoMessage.add(headOfLoopBlock);
    }
    return annotatedBound;
  }
  LoopBound loopBound;
  if (annotatedBound == null) {
    loopBound=LoopBound.boundedAbove(dfaUpperBound);
    logger.debug(""String_Node_Str"" + methodInfo + ""String_Node_Str"");
  }
 else {
    loopBound=annotatedBound.clone();
    loopBound.addBound(LoopBoundExpr.numUpperBound(dfaUpperBound),SymbolicMarker.LOOP_ENTRY);
    long loopUb=annotatedBound.getSimpleLoopBound().upperBound(eCtx);
    if (dfaUpperBound < loopUb) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + dfaUpperBound + ""String_Node_Str""+ loopUb+ ""String_Node_Str""+ methodInfo+ ""String_Node_Str""+ headOfLoopBlock);
      }
    }
 else     if (dfaUpperBound > loopUb) {
      logger.warn(""String_Node_Str"" + dfaUpperBound + ""String_Node_Str""+ loopUb+ ""String_Node_Str""+ methodInfo);
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + methodInfo);
      }
    }
  }
  if (!printedLoopBoundInfoMessage.contains(headOfLoopBlock)) {
    logger.info(""String_Node_Str"" + methodInfo + ""String_Node_Str""+ headOfLoopBlock+ ""String_Node_Str""+ loopBound+ ""String_Node_Str""+ annotatedBound);
    printedLoopBoundInfoMessage.add(headOfLoopBlock);
  }
  return loopBound;
}",0.9889857732905002
186598,"/** 
 * @return true if the invokation denotes an interface, not an implementation
 */
public boolean isVirtual(){
  return receiverImpl == null;
}","/** 
 * @return true if the invokation denotes an interface, not an implementation
 */
@Override public boolean isVirtual(){
  return receiverImpl == null;
}",0.9671052631578948
186599,"public ControlFlowGraph receiverFlowGraph(){
  return receiverImpl.getCode().getControlFlowGraph(false);
}","@Override public ControlFlowGraph receiverFlowGraph(){
  return receiverImpl.getCode().getControlFlowGraph(false);
}",0.954954954954955
186600,"public InstructionHandle getInstructionHandle(){
  return instr;
}","@Override public InstructionHandle getInstructionHandle(){
  return instr;
}",0.9295774647887324
186601,"public MethodInfo getImplementingMethod(){
  return this.receiverImpl;
}","@Override public MethodInfo getImplementingMethod(){
  return this.receiverImpl;
}",0.935064935064935
186602,"/** 
 * Get miss cost for an edge accessing the method cache
 * @param accessEdge either a SuperInvoke or SuperReturn edge, or an entry edge of the segment analyzed
 * @return maximum miss penalty (in cycles)
 */
private long getMissCost(SuperGraphEdge accessEdge){
  SuperGraphNode accessed=accessEdge.getTarget();
  ControlFlowGraph cfg=accessed.getCfg();
  if (accessEdge instanceof SuperReturnEdge) {
    Type returnType=accessEdge.getSource().getCfg().getMethodInfo().getType();
    return methodCache.getMissPenaltyOnReturn(cfg.getNumberOfWords(),returnType);
  }
 else   if (accessEdge instanceof SuperInvokeEdge) {
    InvokeInstruction invokeIns=((SuperInvokeEdge)accessEdge).getInvokeNode().getInvokeSite().getInvokeInstruction();
    return methodCache.getMissPenaltyOnInvoke(cfg.getNumberOfWords(),invokeIns);
  }
 else {
    return methodCache.getMissPenalty(cfg.getNumberOfWords(),false);
  }
}","/** 
 * Get miss cost for an edge accessing the method cache
 * @param accessEdge either a SuperInvoke or SuperReturn edge, or an entry edge of the segment analyzed
 * @return maximum miss penalty (in cycles)
 */
private long getMissCost(SuperGraphEdge accessEdge){
  SuperGraphNode accessed=accessEdge.getTarget();
  ControlFlowGraph cfg=accessed.getCfg();
  if (accessEdge instanceof SuperReturnEdge) {
    Type returnType=accessEdge.getSource().getCfg().getMethodInfo().getType();
    return methodCache.getMissPenaltyOnReturn(cfg.getNumberOfWords(),returnType);
  }
 else   if (accessEdge instanceof SuperInvokeEdge) {
    InstructionHandle invokeIns=((SuperInvokeEdge)accessEdge).getInvokeNode().getInvokeSite().getInstructionHandle();
    return methodCache.getMissPenaltyOnInvoke(cfg.getNumberOfWords(),invokeIns.getInstruction());
  }
 else {
    return methodCache.getMissPenalty(cfg.getNumberOfWords(),false);
  }
}",0.7223131478450627
186603,"/** 
 * Get the maximum method cache miss penalty for invoking   {@code invoked} and returning to {@code invoker}.<br/> Also works with virtual invokes (taking the maximum cost)
 * @param invokeSite the invoke site
 * @param context call context
 * @return miss penalty in cycles
 */
public long getInvokeReturnMissCost(InvokeSite invokeSite,CallString context){
  ControlFlowGraph invokerCfg=wcetTool.getFlowGraph(invokeSite.getInvoker());
  long rMiss=methodCache.getMissPenaltyOnReturn(invokerCfg.getNumberOfWords(),invokeSite.getInvokeeRef().getDescriptor().getType());
  long iMissMax=0;
  for (  MethodInfo target : wcetTool.findImplementations(invokeSite.getInvoker(),invokeSite.getInstructionHandle(),context)) {
    ControlFlowGraph invokedCfg=wcetTool.getFlowGraph(target);
    long iMiss=methodCache.getMissPenaltyOnInvoke(invokedCfg.getNumberOfWords(),invokeSite.getInvokeInstruction());
    if (iMiss > iMissMax)     iMissMax=iMiss;
  }
  return iMissMax + rMiss;
}","/** 
 * Get the maximum method cache miss penalty for invoking   {@code invoked} and returning to {@code invoker}.<br/> Also works with virtual invokes (taking the maximum cost)
 * @param invokeSite the invoke site
 * @param context call context
 * @return miss penalty in cycles
 */
public long getInvokeReturnMissCost(InvokeSite invokeSite,CallString context){
  ControlFlowGraph invokerCfg=wcetTool.getFlowGraph(invokeSite.getInvoker());
  long rMiss=methodCache.getMissPenaltyOnReturn(invokerCfg.getNumberOfWords(),invokeSite.getInvokeeRef().getDescriptor().getType());
  long iMissMax=0;
  for (  MethodInfo target : wcetTool.findImplementations(invokeSite.getInvoker(),invokeSite.getInstructionHandle(),context)) {
    ControlFlowGraph invokedCfg=wcetTool.getFlowGraph(target);
    long iMiss=methodCache.getMissPenaltyOnInvoke(invokedCfg.getNumberOfWords(),invokeSite.getInstructionHandle().getInstruction());
    if (iMiss > iMissMax)     iMissMax=iMiss;
  }
  return iMissMax + rMiss;
}",0.9873289406994424
186604,"/** 
 * Compute the delay (in cycles) caused by a method cache miss
 * @param invokeeWords number of words to load
 * @param invokeInstruction the invoke instruction
 * @return the maximum miss penalty for loading {@code words} words from method cache during {@code invokeInstruction}
 */
public long getMissPenaltyOnInvoke(int invokeeWords,InvokeInstruction invokeInstruction);","/** 
 * Compute the delay (in cycles) caused by a method cache miss
 * @param invokeeWords number of words to load
 * @param invokeInstruction the invoke instruction
 * @return the maximum miss penalty for loading {@code words} words from method cache during {@code invokeInstruction}
 */
public long getMissPenaltyOnInvoke(int invokeeWords,Instruction invokeInstruction);",0.992
186605,"/** 
 * @param invokeeWords number of words to load
 * @param invokeInstruction the invoke instruction
 * @return the maximum miss penalty for loading {@code words} words from method cache during {@code invokeInstruction}
 */
public long getMissPenaltyOnInvoke(int invokeeWords,InvokeInstruction invokeInstruction){
  return timing.getMethodCacheMissPenalty(invokeeWords,invokeInstruction.getOpcode());
}","/** 
 * @param invokeeWords number of words to load
 * @param invokeInstruction the invoke instruction
 * @return the maximum miss penalty for loading {@code words} words from method cache during {@code invokeInstruction}
 */
public long getMissPenaltyOnInvoke(int invokeeWords,Instruction invokeInstruction){
  return timing.getMethodCacheMissPenalty(invokeeWords,invokeInstruction.getOpcode());
}",0.9925187032418952
186606,"@Override public long getMissPenaltyOnInvoke(int invokeeWords,InvokeInstruction invokeInstruction){
  return 0;
}","@Override public long getMissPenaltyOnInvoke(int invokeeWords,Instruction invokeInstruction){
  return 0;
}",0.9727272727272728
186607,"public boolean isOnLocalWCETPath(MethodInfo method,InstructionHandle ih){
  ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
  BasicBlockNode block=cfg.getHandleNode(ih);
  for (  ExecutionContext node : wcetTool.getCallGraph().getNodes(method)) {
    Long flow=wcaNodeFlow.get(node).get(block);
    if (flow > 0)     return true;
  }
  return false;
}","public boolean isOnLocalWCETPath(MethodInfo method,InstructionHandle ih){
  ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
  BasicBlockNode block=cfg.getHandleNode(ih,true);
  if (block == null) {
    return false;
  }
  for (  ExecutionContext node : wcetTool.getCallGraph().getNodes(method)) {
    Long flow=wcaNodeFlow.get(node).get(block);
    if (flow > 0)     return true;
  }
  return false;
}",0.931472081218274
186608,"@Override public void visitInvokeNode(ControlFlowGraph.InvokeNode n){
  if (n.getVirtualNode() != null) {
    if (project.isInfeasibleReceiver(n.getImplementingMethod(),ctx.getCallString().push(n.getInvokeSite()))) {
      WCETTool.logger.info(""String_Node_Str"" + n.getImplementingMethod());
      return;
    }
  }
  cost.addLocalCost(processor.getExecutionTime(ctx.getExecutionContext(n),n.getInstructionHandle()));
  if (n.isVirtual()) {
    throw new AssertionError(""String_Node_Str"" + n.getReferenced() + ""String_Node_Str"");
  }
  cost.addCost(RecursiveWcetAnalysis.this.recursiveWCET.recursiveCost(RecursiveWcetAnalysis.this,n,ctx));
}","@Override public void visitInvokeNode(ControlFlowGraph.InvokeNode n){
  if (n.getVirtualNode() != null) {
    if (project.isInfeasibleReceiver(n.getImplementingMethod(),ctx.getCallString().push(n.getInvokeSite(),project.getCallstringLength()))) {
      WCETTool.logger.info(""String_Node_Str"" + n.getImplementingMethod());
      return;
    }
  }
  cost.addLocalCost(processor.getExecutionTime(ctx.getExecutionContext(n),n.getInstructionHandle()));
  if (n.isVirtual()) {
    throw new AssertionError(""String_Node_Str"" + n.getReferenced() + ""String_Node_Str"");
  }
  cost.addCost(RecursiveWcetAnalysis.this.recursiveWCET.recursiveCost(RecursiveWcetAnalysis.this,n,ctx));
}",0.9771341463414634
186609,"@Override public String toString(){
  if (this.isEmpty())   return ""String_Node_Str"";
  long hash=hashCode();
  if (hash < 0)   hash+=Integer.MAX_VALUE;
  return String.format(""String_Node_Str"",callString.length,hash);
}","@Override public String toString(){
  if (this.isEmpty())   return ""String_Node_Str"";
  long hash=hashCode();
  if (hash < 0)   hash+=Integer.MAX_VALUE;
  if (callString.length == 1) {
    return String.format(""String_Node_Str"",callString[0].toString());
  }
 else {
    return String.format(""String_Node_Str"",callString.length,hash);
  }
}",0.7357142857142858
186610,"public <K,V>Map runLocalAnalysis(Analysis<K,V> analysis,MethodInfo start){
  Interpreter<K,V> interpreter=new Interpreter<K,V>(analysis,this);
  if (start == null)   throw new AssertionError(""String_Node_Str"" + start);
  Context context=new Context();
  context.stackPtr=start.getCode().getMaxLocals();
  context.setMethodInfo(start);
  analysis.initialize(start,context);
  InstructionHandle entry=start.getCode().getInstructionList().getStart();
  interpreter.interpret(context,entry,new HashMap<InstructionHandle,ContextMap<K,V>>(),true);
  return analysis.getResult();
}","public <K,V>Map runLocalAnalysis(Analysis<K,V> localAnalysis,ExecutionContext scope){
  Interpreter<K,V> interpreter=new Interpreter<K,V>(localAnalysis,this);
  if (scope == null)   throw new AssertionError(""String_Node_Str"" + scope);
  Context context=new Context();
  MethodCode entryCode=scope.getMethodInfo().getCode();
  context.stackPtr=entryCode.getMaxLocals();
  context.setMethodInfo(scope.getMethodInfo());
  context.setCallString(scope.getCallString());
  localAnalysis.initialize(scope.getMethodInfo(),context);
  InstructionHandle entry=entryCode.getInstructionList(false,false).getStart();
  interpreter.interpret(context,entry,new HashMap<InstructionHandle,ContextMap<K,V>>(),true);
  return localAnalysis.getResult();
}",0.7563025210084033
186611,"public ContextMap<CallString,SymbolicAddressMap> initial(InstructionHandle stmt){
  ContextMap<CallString,SymbolicAddressMap> retval=new ContextMap<CallString,SymbolicAddressMap>(new Context(),new HashMap<CallString,SymbolicAddressMap>());
  CallString l=CallString.EMPTY;
  SymbolicAddressMap init=new SymbolicAddressMap(bsFactory);
  int stackPtr=0;
  if (!entryMethod.isStatic()) {
    init.putStack(stackPtr++,bsFactory.singleton(SymbolicAddress.rootAddress(""String_Node_Str"")));
  }
  String[] args=entryMethod.getArgumentNames();
  for (int i=0; i < args.length; i++) {
    Type ty=entryMethod.getArgumentType(i);
    if (ty instanceof ReferenceType) {
      init.putStack(stackPtr,bsFactory.singleton(SymbolicAddress.rootAddress(""String_Node_Str"" + args[i])));
    }
    stackPtr+=ty.getSize();
  }
  retval.put(l,init);
  return retval;
}","public ContextMap<CallString,SymbolicAddressMap> initial(InstructionHandle stmt){
  ContextMap<CallString,SymbolicAddressMap> retval=new ContextMap<CallString,SymbolicAddressMap>(new Context(),new HashMap<CallString,SymbolicAddressMap>());
  SymbolicAddressMap init=new SymbolicAddressMap(bsFactory);
  int stackPtr=0;
  if (!entryMethod.isStatic()) {
    init.putStack(stackPtr++,bsFactory.singleton(SymbolicAddress.rootAddress(""String_Node_Str"")));
  }
  String[] args=entryMethod.getArgumentNames();
  for (int i=0; i < args.length; i++) {
    Type ty=entryMethod.getArgumentType(i);
    if (ty instanceof ReferenceType) {
      init.putStack(stackPtr,bsFactory.singleton(SymbolicAddress.rootAddress(""String_Node_Str"" + args[i])));
    }
    stackPtr+=ty.getSize();
  }
  retval.put(initialCallString,init);
  return retval;
}",0.9695522388059702
186612,"public void initialize(MethodInfo mi,Context context){
  entryMethod=mi;
}","public void initialize(MethodInfo mi,Context context){
  entryMethod=mi;
  initialCallString=context.callString;
}",0.7872340425531915
186613,"/** 
 * Get DFA results on symbolic reference names for the given scope XXX: proper segment support
 * @param scope
 * @return
 */
public LocalPointsToResult getUsedRefs(ExecutionContext scope){
  ExecuteOnceAnalysis eoAna=new ExecuteOnceAnalysis(project);
  DFATool dfa=project.getDfaTool();
  SymbolicPointsTo spt=new SymbolicPointsTo(maxSetSize,project.getCallstringLength(),new ExecOnceQuery(eoAna,scope));
  dfa.runLocalAnalysis(spt,scope.getMethodInfo());
  LocalPointsToResult lpt=new LocalPointsToResult(spt.getResult());
  return lpt;
}","/** 
 * Get DFA results on symbolic reference names for the given scope XXX: proper segment support
 * @param scope
 * @return
 */
public LocalPointsToResult getUsedRefs(ExecutionContext scope){
  ExecuteOnceAnalysis eoAna=new ExecuteOnceAnalysis(project);
  DFATool dfa=project.getDfaTool();
  SymbolicPointsTo spt=new SymbolicPointsTo(maxSetSize,project.getCallstringLength(),new ExecOnceQuery(eoAna,scope));
  dfa.runLocalAnalysis(spt,scope);
  LocalPointsToResult lpt=new LocalPointsToResult(spt.getResult());
  return lpt;
}",0.851024208566108
186614,"/** 
 * Compute WCET for a segment, using global IPET, and cache analysis results
 * @throws InvalidFlowFactException 
 * @throws LpSolveException 
 */
public WcetCost computeWCET(String key,Segment segment,StaticCacheApproximation cacheMode) throws InvalidFlowFactException, LpSolveException {
  IPETSolver<SuperGraphEdge> ipetSolver=buildIpetProblem(project,key,segment,ipetConfig);
  setExecutionCost(segment,ipetSolver);
  Set<SuperGraphEdge> missEdges=new HashSet<SuperGraphEdge>();
  if (project.getWCETProcessorModel().hasMethodCache()) {
switch (cacheMode) {
case ALWAYS_HIT:
      break;
case ALWAYS_MISS:
    missEdges=methodCacheAnalysis.addMissAlwaysCost(segment,ipetSolver);
  break;
case ALL_FIT_SIMPLE:
missEdges=methodCacheAnalysis.addMissOnceCost(segment,ipetSolver);
break;
case ALL_FIT_REGIONS:
missEdges=methodCacheAnalysis.addMissOnceConstraints(segment,ipetSolver);
break;
case GLOBAL_ALL_FIT:
missEdges=methodCacheAnalysis.addGlobalAllFitConstraints(segment,ipetSolver);
break;
}
}
Map<SuperGraphEdge,Long> flowMap=new HashMap<SuperGraphEdge,Long>();
long _start=System.currentTimeMillis();
double relaxedCost=ipetSolver.solve(null,false);
long _time_rlp=System.currentTimeMillis() - _start;
double ilpCost=ipetSolver.solve(flowMap);
long _time_ilp=System.currentTimeMillis() - _start;
WCETTool.logger.info(String.format(""String_Node_Str"",_time_rlp,Math.round(relaxedCost),Math.round(ilpCost),_time_ilp));
WcetCost cost=new WcetCost();
for (Entry<SuperGraphEdge,Long> flowEntry : flowMap.entrySet()) {
SuperGraphEdge edge=flowEntry.getKey();
long edgeCost=ipetSolver.getEdgeCost(edge);
long flowCost=edgeCost * flowEntry.getValue();
if (missEdges.contains(edge)) {
if (WCETTool.logger.isTraceEnabled() && flowEntry.getValue() > 0) {
WCETTool.logger.trace(""String_Node_Str"" + edge + ""String_Node_Str""+ flowCost+ ""String_Node_Str""+ flowEntry.getValue()+ ""String_Node_Str""+ edgeCost+ ""String_Node_Str"");
}
cost.addCacheCost(flowCost);
}
 else {
if (WCETTool.logger.isTraceEnabled() && flowEntry.getValue() > 0) {
WCETTool.logger.trace(""String_Node_Str"" + edge + ""String_Node_Str""+ flowCost);
}
cost.addNonLocalCost(flowCost);
}
}
if (Double.isInfinite(ilpCost)) {
throw new AssertionError(""String_Node_Str"");
}
long objValue=(long)(ilpCost + 0.5);
if (cost.getCost() != objValue) {
throw new AssertionError(""String_Node_Str"" + objValue + ""String_Node_Str""+ cost.getCost());
}
return cost;
}","/** 
 * Compute WCET for a segment, using global IPET, and cache analysis results
 * @throws InvalidFlowFactException 
 * @throws LpSolveException 
 */
public WcetCost computeWCET(String key,Segment segment,StaticCacheApproximation cacheMode) throws InvalidFlowFactException, LpSolveException {
  String problemId=formatProblemName(key,segment.getEntryMethods().toString());
  IPETSolver<SuperGraphEdge> ipetSolver=buildIpetProblem(project,problemId,segment,ipetConfig);
  setExecutionCost(segment,ipetSolver);
  Set<SuperGraphEdge> missEdges=new HashSet<SuperGraphEdge>();
  if (project.getWCETProcessorModel().hasMethodCache()) {
switch (cacheMode) {
case ALWAYS_HIT:
      break;
case ALWAYS_MISS:
    missEdges=methodCacheAnalysis.addMissAlwaysCost(segment,ipetSolver);
  break;
case ALL_FIT_SIMPLE:
missEdges=methodCacheAnalysis.addMissOnceCost(segment,ipetSolver);
break;
case ALL_FIT_REGIONS:
missEdges=methodCacheAnalysis.addMissOnceConstraints(segment,ipetSolver);
break;
case GLOBAL_ALL_FIT:
missEdges=methodCacheAnalysis.addGlobalAllFitConstraints(segment,ipetSolver);
break;
}
}
Map<SuperGraphEdge,Long> flowMap=new HashMap<SuperGraphEdge,Long>();
long _start=System.currentTimeMillis();
double relaxedCost=ipetSolver.solve(null,false);
long _time_rlp=System.currentTimeMillis() - _start;
double ilpCost=ipetSolver.solve(flowMap);
long _time_ilp=System.currentTimeMillis() - _start;
WCETTool.logger.info(String.format(""String_Node_Str"",_time_rlp,Math.round(relaxedCost),Math.round(ilpCost),_time_ilp));
WcetCost cost=new WcetCost();
for (Entry<SuperGraphEdge,Long> flowEntry : flowMap.entrySet()) {
SuperGraphEdge edge=flowEntry.getKey();
long edgeCost=ipetSolver.getEdgeCost(edge);
long flowCost=edgeCost * flowEntry.getValue();
if (missEdges.contains(edge)) {
if (WCETTool.logger.isTraceEnabled() && flowEntry.getValue() > 0) {
WCETTool.logger.trace(""String_Node_Str"" + edge + ""String_Node_Str""+ flowCost+ ""String_Node_Str""+ flowEntry.getValue()+ ""String_Node_Str""+ edgeCost+ ""String_Node_Str"");
}
cost.addCacheCost(flowCost);
}
 else {
if (WCETTool.logger.isTraceEnabled() && flowEntry.getValue() > 0) {
WCETTool.logger.trace(""String_Node_Str"" + edge + ""String_Node_Str""+ flowCost);
}
cost.addNonLocalCost(flowCost);
}
}
if (Double.isInfinite(ilpCost)) {
throw new AssertionError(""String_Node_Str"");
}
long objValue=(long)(ilpCost + 0.5);
if (cost.getCost() != objValue) {
throw new AssertionError(""String_Node_Str"" + objValue + ""String_Node_Str""+ cost.getCost());
}
return cost;
}",0.98124745209947
186615,"public static IPETSolver<SuperGraphEdge> buildIpetProblem(WCETTool wcetTool,String problemName,Segment segment,IPETConfig ipetConfig) throws InvalidFlowFactException {
  problemName=problemName + (nameCounter++);
  IPETSolver<SuperGraphEdge> ipetSolver=new IPETSolver<SuperGraphEdge>(problemName,ipetConfig);
  try {
    segment.exportDOT(wcetTool.getProjectConfig().getOutFile(problemName + ""String_Node_Str""));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  ipetSolver.addConstraint(IPETUtils.constantFlow(segment.getEntryEdges(),1));
  ipetSolver.addConstraint(IPETUtils.constantFlow(segment.getExitEdges(),1));
  for (  SuperGraphNode node : segment.getNodes()) {
    ipetSolver.addConstraint(IPETUtils.flowPreservation(segment.incomingEdgesOf(node),segment.outgoingEdgesOf(node)));
  }
  for (  Pair<SuperInvokeEdge,SuperReturnEdge> superEdgePair : segment.getCallSites()) {
    Iterable<SuperGraphEdge> es1=Iterators.<SuperGraphEdge>singleton(superEdgePair.first());
    Iterable<SuperGraphEdge> es2=Iterators.<SuperGraphEdge>singleton(superEdgePair.second());
    ipetSolver.addConstraint(IPETUtils.flowPreservation(es1,es2));
  }
  for (  LinearConstraint<SuperGraphEdge> flowFact : getFlowFacts(wcetTool,segment)) {
    ipetSolver.addConstraint(flowFact);
  }
  return ipetSolver;
}","/** 
 * Create an interprocedural max-cost max-flow problem for the given segment<br/> Notes:<ul> <li/> super graph edges always have the callstring of the invoking method </ul>
 * @param wcetTool    A reference to the WCETTool
 * @param problemName A unique identifier for the problem (for reporting)
 * @param segment     The segment to build the ILP for
 * @param ipetConfig  Cost of nodes (or {@code null} if no cost is associated with nodes)
 * @return The max-cost maxflow problem
 * @throws InvalidFlowFactException 
 */
public static IPETSolver<SuperGraphEdge> buildIpetProblem(WCETTool wcetTool,String problemName,Segment segment,IPETConfig ipetConfig) throws InvalidFlowFactException {
  IPETSolver<SuperGraphEdge> ipetSolver=new IPETSolver<SuperGraphEdge>(problemName,ipetConfig);
  try {
    segment.exportDOT(wcetTool.getProjectConfig().getOutFile(problemName + ""String_Node_Str""));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  ipetSolver.addConstraint(IPETUtils.constantFlow(segment.getEntryEdges(),1));
  ipetSolver.addConstraint(IPETUtils.constantFlow(segment.getExitEdges(),1));
  for (  SuperGraphNode node : segment.getNodes()) {
    ipetSolver.addConstraint(IPETUtils.flowPreservation(segment.incomingEdgesOf(node),segment.outgoingEdgesOf(node)));
  }
  for (  Pair<SuperInvokeEdge,SuperReturnEdge> superEdgePair : segment.getCallSites()) {
    Iterable<SuperGraphEdge> es1=Iterators.<SuperGraphEdge>singleton(superEdgePair.first());
    Iterable<SuperGraphEdge> es2=Iterators.<SuperGraphEdge>singleton(superEdgePair.second());
    ipetSolver.addConstraint(IPETUtils.flowPreservation(es1,es2));
  }
  for (  LinearConstraint<SuperGraphEdge> flowFact : getFlowFacts(wcetTool,segment)) {
    ipetSolver.addConstraint(flowFact);
  }
  return ipetSolver;
}",0.8148626817447496
186616,"/** 
 * Analyze the cost for loading each distinct tag in the given segment at most once. This can also be used to count the number of distinct tags (given each tag the cost of 1), or the number of cache blocks for the variable block method cache (given each tag a cost equal to the number of cache blocks it needs)
 * @param segment the segment to analyze
 * @param accessEdges cache access edges partitioned by tag
 * @param costModel
 * @param useILP use integer variables (more expensive, more accurate)
 * @param analysisKey
 * @param wcetTool
 * @return
 * @throws InvalidFlowFactException 
 * @throws LpSolveException 
 */
public static <T>long computeMissOnceCost(Segment segment,Iterable<Entry<T,List<SuperGraphEdge>>> partition,F1<SuperGraphEdge,Long> costModel,boolean useILP,String analysisKey,WCETTool wcetTool) throws InvalidFlowFactException, LpSolveException {
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  IPETSolver<SuperGraphEdge> ipetSolver=GlobalAnalysis.buildIpetProblem(wcetTool,analysisKey,segment,ipetConfig);
  addPersistenceSegmentConstraints(segment,partition,ipetSolver,costModel,analysisKey);
  double lpCost=ipetSolver.solve(null,useILP);
  long maxCacheCost=(long)(lpCost + 0.5);
  return maxCacheCost;
}","/** 
 * Analyze the cost for loading each distinct tag in the given segment at most once. This can also be used to count the number of distinct tags (given each tag the cost of 1), or the number of cache blocks for the variable block method cache (given each tag a cost equal to the number of cache blocks it needs)
 * @param segment the segment to analyze
 * @param accessEdges cache access edges partitioned by tag
 * @param costModel
 * @param useILP use integer variables (more expensive, more accurate)
 * @param analysisKey
 * @param wcetTool
 * @return
 * @throws InvalidFlowFactException 
 * @throws LpSolveException 
 */
public static <T>long computeMissOnceCost(Segment segment,Iterable<Entry<T,List<SuperGraphEdge>>> partition,F1<SuperGraphEdge,Long> costModel,boolean useILP,String analysisKey,WCETTool wcetTool) throws InvalidFlowFactException, LpSolveException {
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  String problemKey=GlobalAnalysis.formatProblemName(analysisKey,segment.getEntryMethods().toString());
  IPETSolver<SuperGraphEdge> ipetSolver=GlobalAnalysis.buildIpetProblem(wcetTool,problemKey,segment,ipetConfig);
  addPersistenceSegmentConstraints(segment,partition,ipetSolver,costModel,analysisKey);
  double lpCost=ipetSolver.solve(null,useILP);
  long maxCacheCost=(long)(lpCost + 0.5);
  return maxCacheCost;
}",0.9544235924932976
186617,"/** 
 * @param persistenceSegment
 * @param ipetSolver
 * @param missEdgesOut
 */
public static <T>Set<SuperGraphEdge> addPersistenceSegmentConstraints(Segment persistenceSegment,Iterable<Entry<T,List<SuperGraphEdge>>> partition,IPETSolver<SuperGraphEdge> ipetSolver,F1<SuperGraphEdge,Long> costModel,Object analysisKey){
  HashSet<SuperGraphEdge> missEdges=new HashSet<SuperGraphEdge>();
  for (  Entry<T,List<SuperGraphEdge>> accessed : partition) {
    List<SuperGraphEdge> missOnceEdges=new ArrayList<SuperGraphEdge>();
    for (    SuperGraphEdge accessEdge : accessed.getValue()) {
      long cost=costModel.apply(accessEdge);
      SuperGraphEdge missEdge=SuperGraphSplitEdge.generateSplitEdges(accessEdge,analysisKey,1).iterator().next();
      ipetSolver.addConstraint(IPETUtils.relativeBound(Iterators.singleton(missEdge),Iterators.singleton(accessEdge),1));
      ipetSolver.addEdgeCost(missEdge,cost);
      missOnceEdges.add(missEdge);
    }
    ipetSolver.addConstraint(IPETUtils.flowBound(missOnceEdges,1));
    missEdges.addAll(missOnceEdges);
  }
  return missEdges;
}","/** 
 * Add constraints for a persistence segment
 * @param < T > cache tag type
 * @param < C > access edge collection type
 * @param persistenceSegment
 * @param partition
 * @param ipetSolver
 * @param costModel
 * @param analysisKey
 * @return
 */
public static <T,C extends Iterable<SuperGraphEdge>>Set<SuperGraphEdge> addPersistenceSegmentConstraints(Segment persistenceSegment,Iterable<Entry<T,C>> partition,IPETSolver<SuperGraphEdge> ipetSolver,F1<SuperGraphEdge,Long> costModel,Object analysisKey){
  HashSet<SuperGraphEdge> missEdges=new HashSet<SuperGraphEdge>();
  for (  Entry<T,C> accessed : partition) {
    List<SuperGraphEdge> missOnceEdges=new ArrayList<SuperGraphEdge>();
    for (    SuperGraphEdge accessEdge : accessed.getValue()) {
      long cost=costModel.apply(accessEdge);
      SuperGraphEdge missEdge=SuperGraphExtraCostEdge.generateExtraCostEdge(accessEdge,analysisKey,accessed.getKey());
      ipetSolver.addConstraint(IPETUtils.relativeBound(Iterators.singleton(missEdge),Iterators.singleton(accessEdge),1));
      ipetSolver.addEdgeCost(missEdge,cost);
      missOnceEdges.add(missEdge);
    }
    ipetSolver.addConstraint(IPETUtils.flowBound(missOnceEdges,1));
    missEdges.addAll(missOnceEdges);
  }
  return missEdges;
}",0.8360375747224594
186618,"/** 
 * Add miss once cost: for each method cache persistence segment, add maximum miss cost to the segment entries
 * @param segment
 * @param ipetSolver
 * @throws LpSolveException 
 * @throws InvalidFlowFactException 
 */
public Set<SuperGraphEdge> addMissOnceCost(Segment segment,IPETSolver<SuperGraphEdge> ipetSolver) throws InvalidFlowFactException, LpSolveException {
  Set<SuperGraphEdge> missEdges=new HashSet<SuperGraphEdge>();
  for (  Segment persistenceSegment : findPersistenceSegmentCover(segment,true)) {
    long cost=computeMissOnceCost(persistenceSegment,getCacheAccessesByTag(persistenceSegment).entrySet(),EDGE_MISS_COST,true,KEY,wcetTool);
    System.err.println(""String_Node_Str"" + persistenceSegment + ""String_Node_Str""+ cost);
    for (    SuperGraphEdge entryEdge : persistenceSegment.getEntryEdges()) {
      if (!persistenceSegment.includesEdge(entryEdge)) {
        throw new AssertionError(""String_Node_Str"" + entryEdge);
      }
 else {
        missEdges.add(fixedAdditionalCostEdge(entryEdge,cost,ipetSolver));
      }
    }
  }
  return missEdges;
}","/** 
 * Add miss once cost: for each method cache persistence segment, add maximum miss cost to the segment entries
 * @param segment
 * @param ipetSolver
 * @throws LpSolveException 
 * @throws InvalidFlowFactException 
 */
public Set<SuperGraphEdge> addMissOnceCost(Segment segment,IPETSolver<SuperGraphEdge> ipetSolver) throws InvalidFlowFactException, LpSolveException {
  Set<SuperGraphEdge> missEdges=new HashSet<SuperGraphEdge>();
  int tag=0;
  for (  Segment persistenceSegment : findPersistenceSegmentCover(segment,true)) {
    tag++;
    long cost=computeMissOnceCost(persistenceSegment,getCacheAccessesByTag(persistenceSegment).entrySet(),EDGE_MISS_COST,true,KEY,wcetTool);
    WCETTool.logger.debug(""String_Node_Str"" + persistenceSegment + ""String_Node_Str""+ cost);
    F1<SuperGraphEdge,Long> costModel=MiscUtils.const1(cost);
    Set<SuperGraphEdge> costEdges=CachePersistenceAnalysis.addFixedCostEdges(persistenceSegment.getEntryEdges(),ipetSolver,costModel,KEY + ""String_Node_Str"",tag);
    missEdges.addAll(costEdges);
  }
  return missEdges;
}",0.75
186619,"/** 
 * Add always miss cost: for each access to the method cache, add cost of access
 * @param segment
 * @param ipetSolver
 */
public Set<SuperGraphEdge> addMissAlwaysCost(Segment segment,IPETSolver<SuperGraphEdge> ipetSolver){
  Set<SuperGraphEdge> missEdges=new HashSet<SuperGraphEdge>();
  for (  SuperGraphEdge accessEdge : collectCacheAccesses(segment)) {
    if (!segment.includesEdge(accessEdge)) {
      throw new AssertionError(""String_Node_Str"" + accessEdge);
    }
 else {
      missEdges.add(fixedAdditionalCostEdge(accessEdge,getMissCost(accessEdge),ipetSolver));
    }
  }
  return missEdges;
}","/** 
 * Add always miss cost: for each access to the method cache, add cost of access
 * @param segment
 * @param ipetSolver
 */
public Set<SuperGraphEdge> addMissAlwaysCost(Segment segment,IPETSolver<SuperGraphEdge> ipetSolver){
  Iterable<SuperGraphEdge> accessEdges=collectCacheAccesses(segment);
  for (  SuperGraphEdge accessEdge : accessEdges) {
    if (!segment.includesEdge(accessEdge)) {
      throw new AssertionError(""String_Node_Str"" + accessEdge);
    }
  }
  return CachePersistenceAnalysis.addFixedCostEdges(accessEdges,ipetSolver,EDGE_MISS_COST,KEY + ""String_Node_Str"",0);
}",0.7166666666666667
186620,"public static void dumpBarPlot(List<OCacheAnalysisResult> samples,PrintStream out){
  for (  Entry<Integer,List<OCacheAnalysisResult>> entryConfig : partitionByConfig(samples).entrySet()) {
    int config=entryConfig.getKey();
    boolean first=true;
    out.println(""String_Node_Str"" + config + ""String_Node_Str"");
    for (    Entry<Integer,List<OCacheAnalysisResult>> entry : partitionByLineSize(entryConfig.getValue()).entrySet()) {
      int lineSize=entry.getKey();
      out.printf(""String_Node_Str"",lineSize);
      List<OCacheAnalysisResult> results=entry.getValue();
      Collections.sort(results,OCacheAnalysisResult.wayLineComperator());
      Vector<Integer> sampleWays=new Vector<Integer>();
      for (      OCacheAnalysisResult r : results) {
        if (r.blockSize > 1)         continue;
        out.printf(""String_Node_Str"",r.cyclesPerAccess);
        sampleWays.add(r.ways);
      }
      out.println(""String_Node_Str"" + sampleWays);
    }
    out.println(""String_Node_Str"" + config + ""String_Node_Str"");
    List<OCacheAnalysisResult> results=entryConfig.getValue();
    Collections.sort(results,OCacheAnalysisResult.wayLineComperator());
    int oldWays=-1;
    int oldLineSize=-1;
    for (    OCacheAnalysisResult r : results) {
      if (r.ways != oldWays || r.lineWords != oldLineSize) {
        oldWays=r.ways;
        oldLineSize=r.lineWords;
        out.printf(""String_Node_Str"",r.ways,r.lineWords);
      }
      out.printf(""String_Node_Str"",r.cyclesPerAccess);
    }
    out.println(""String_Node_Str"");
  }
}","public static void dumpBarPlot(List<OCacheAnalysisResult> samples,PrintStream out){
  for (  Entry<Integer,List<OCacheAnalysisResult>> entryConfig : partitionByConfig(samples).entrySet()) {
    int config=entryConfig.getKey();
    out.println(""String_Node_Str"" + config + ""String_Node_Str"");
    for (    Entry<Integer,List<OCacheAnalysisResult>> entry : partitionByLineSize(entryConfig.getValue()).entrySet()) {
      int lineSize=entry.getKey();
      out.printf(""String_Node_Str"",lineSize);
      List<OCacheAnalysisResult> results=entry.getValue();
      Collections.sort(results,OCacheAnalysisResult.wayLineComperator());
      Vector<Integer> sampleWays=new Vector<Integer>();
      for (      OCacheAnalysisResult r : results) {
        if (r.blockSize > 1)         continue;
        out.printf(""String_Node_Str"",r.cyclesPerAccess);
        sampleWays.add(r.ways);
      }
      out.println(""String_Node_Str"" + sampleWays);
    }
    out.println(""String_Node_Str"" + config + ""String_Node_Str"");
    List<OCacheAnalysisResult> results=entryConfig.getValue();
    Collections.sort(results,OCacheAnalysisResult.wayLineComperator());
    int oldWays=-1;
    int oldLineSize=-1;
    for (    OCacheAnalysisResult r : results) {
      if (r.ways != oldWays || r.lineWords != oldLineSize) {
        oldWays=r.ways;
        oldLineSize=r.lineWords;
        out.printf(""String_Node_Str"",r.ways,r.lineWords);
      }
      out.printf(""String_Node_Str"",r.cyclesPerAccess);
    }
    out.println(""String_Node_Str"");
  }
}",0.9921465968586388
186621,"/** 
 * Compile the callgraph back into an instruction list and store it in the associated MethodCode. <p> We do not order the blocks here, this is a separate optimization Also, we do not insert jump instructions if the fallthrough edge of a block does not link to the next block in the block list. Instead an error is raised. </p> TODO create method to insert jump blocks where necessary
 */
public void compile(){
  InstructionList il=new InstructionList();
  Object[] attributes={KEY_CFGNODE};
  Map<BasicBlock,BasicBlockNode> blockMap=buildBlockNodeMap();
  for (int i=0; i < blocks.size(); i++) {
    BasicBlock bb=blocks.get(i);
    BasicBlockNode bbn=blockMap.get(bb);
    if (bbn == null) {
      continue;
    }
    for (    CFGEdge e : graph.outgoingEdgesOf(bbn)) {
      if (e.getKind() != EdgeKind.NEXT_EDGE)       continue;
      BasicBlock target=graph.getEdgeTarget(e).getBasicBlock();
      if (blocks.get(i + 1) != target) {
        throw new ControlFlowError(""String_Node_Str"" + i + ""String_Node_Str""+ methodInfo);
      }
    }
  }
}","/** 
 * Compile the callgraph back into an instruction list and store it in the associated MethodCode. <p> We do not order the blocks here, this is a separate optimization Also, we do not insert jump instructions if the fallthrough edge of a block does not link to the next block in the block list. Instead an error is raised. </p> TODO create method to insert jump blocks where necessary
 */
public void compile(){
  InstructionList il=new InstructionList();
  Object[] attributes={KEY_CFGNODE};
  Map<BasicBlock,BasicBlockNode> blockMap=buildBlockNodeMap();
  for (int i=0; i < blocks.size(); i++) {
    BasicBlock bb=blocks.get(i);
    BasicBlockNode bbn=blockMap.get(bb);
    if (bbn == null) {
      continue;
    }
    for (    CFGEdge e : graph.outgoingEdgesOf(bbn)) {
      if (e.getKind() != EdgeKind.NEXT_EDGE)       continue;
      BasicBlock target=graph.getEdgeTarget(e).getBasicBlock();
      if (target == null)       continue;
      if (blocks.get(i + 1) != target) {
        throw new ControlFlowError(""String_Node_Str"" + i + ""String_Node_Str""+ methodInfo);
      }
    }
  }
}",0.9804287045666356
186622,"public Type getType(){
  return fieldInfo != null ? fieldInfo.getType() : type;
}","public Type getType(){
  if (fieldInfo == null && type == null) {
    ClassInfo classInfo=classRef.getClassInfo();
    if (classInfo != null) {
      fieldInfo=classInfo.getFieldInfoInherited(name,true);
    }
  }
  if (fieldInfo != null)   return fieldInfo.getType();
  return type;
}",0.3224043715846995
186623,"public static StoreInstruction createStoreInstruction(Type type,int slot){
switch (type.getType()) {
case Constants.T_BOOLEAN:
case Constants.T_CHAR:
case Constants.T_SHORT:
case Constants.T_INT:
    return new ISTORE(slot);
case Constants.T_FLOAT:
  return new FSTORE(slot);
case Constants.T_LONG:
return new LSTORE(slot);
case Constants.T_DOUBLE:
return new DSTORE(slot);
case Constants.T_OBJECT:
case Constants.T_ARRAY:
return new ASTORE(slot);
default :
throw new AppInfoError(""String_Node_Str"" + type + ""String_Node_Str""+ slot);
}
}","public static StoreInstruction createStoreInstruction(Type type,int slot){
switch (type.getType()) {
case Constants.T_BOOLEAN:
case Constants.T_BYTE:
case Constants.T_CHAR:
case Constants.T_SHORT:
case Constants.T_INT:
    return new ISTORE(slot);
case Constants.T_FLOAT:
  return new FSTORE(slot);
case Constants.T_LONG:
return new LSTORE(slot);
case Constants.T_DOUBLE:
return new DSTORE(slot);
case Constants.T_OBJECT:
case Constants.T_ARRAY:
return new ASTORE(slot);
default :
throw new AppInfoError(""String_Node_Str"" + type + ""String_Node_Str""+ slot);
}
}",0.9790337283500457
186624,"public static LoadInstruction createLoadInstruction(Type type,int slot){
switch (type.getType()) {
case Constants.T_BOOLEAN:
case Constants.T_CHAR:
case Constants.T_SHORT:
case Constants.T_INT:
    return new ILOAD(slot);
case Constants.T_FLOAT:
  return new FLOAD(slot);
case Constants.T_LONG:
return new LLOAD(slot);
case Constants.T_DOUBLE:
return new DLOAD(slot);
case Constants.T_OBJECT:
case Constants.T_ARRAY:
return new ALOAD(slot);
default :
throw new AppInfoError(""String_Node_Str"" + type + ""String_Node_Str""+ slot);
}
}","public static LoadInstruction createLoadInstruction(Type type,int slot){
switch (type.getType()) {
case Constants.T_BOOLEAN:
case Constants.T_BYTE:
case Constants.T_CHAR:
case Constants.T_SHORT:
case Constants.T_INT:
    return new ILOAD(slot);
case Constants.T_FLOAT:
  return new FLOAD(slot);
case Constants.T_LONG:
return new LLOAD(slot);
case Constants.T_DOUBLE:
return new DLOAD(slot);
case Constants.T_OBJECT:
case Constants.T_ARRAY:
return new ALOAD(slot);
default :
throw new AppInfoError(""String_Node_Str"" + type + ""String_Node_Str""+ slot);
}
}",0.9787626962142196
186625,"/** 
 * Run all configured optimizations and perform the required analyses.
 */
public void optimize(){
  boolean firstPassDFA=useDFA() && !config.doOptimizeFastOnly();
  if (firstPassDFA) {
    executor.dataflowAnalysis(false);
  }
  executor.buildCallGraph(firstPassDFA);
  executor.dumpCallgraph(""String_Node_Str"");
  executor.removeDebugAttributes();
  executor.cleanupMethodCode();
  executor.performSimpleInline();
  if (useDFA()) {
    executor.dataflowAnalysis(true);
  }
  executor.buildCallGraph(useDFA());
  if (useWCA()) {
    wcetTool.rebuildCallGraph();
  }
 else {
    logger.info(""String_Node_Str"");
  }
  executor.performGreedyOptimizer();
  executor.cleanupMethodCode();
  executor.removeUnusedMembers();
  executor.relinkInvokesuper();
  executor.cleanupConstantPool();
}","/** 
 * Run all configured optimizations and perform the required analyses.
 */
public void optimize(){
  boolean firstPassDFA=useDFA() && !config.doOptimizeFastOnly();
  if (firstPassDFA) {
    executor.dataflowAnalysis(false);
  }
  executor.buildCallGraph(firstPassDFA);
  executor.dumpCallgraph(""String_Node_Str"");
  executor.removeDebugAttributes();
  executor.cleanupMethodCode();
  executor.performSimpleInline();
  if (useDFA()) {
    executor.dataflowAnalysis(true);
  }
  executor.buildCallGraph(useDFA());
  executor.performGreedyOptimizer();
  executor.cleanupMethodCode();
  executor.removeUnusedMembers();
  executor.relinkInvokesuper();
  executor.cleanupConstantPool();
}",0.930264048747461
186626,"public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  resetCounters();
  boolean useWCAProvider=config.useWCA() && config.useWCAExecCount();
  GreedyOrder order=config.getOrder();
  if (order != GreedyOrder.WCAFirst) {
    if (!config.getTargetMethodSet().equals(config.getWCATargetSet())) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"");
      useWCAProvider=false;
    }
  }
  AnalysisManager analyses=initializeAnalyses(config.useWCEP() || useWCAProvider);
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    GainCalculator gc=new GainCalculator(analyses);
    if (config.useWCEP()) {
      selector=new WCEPRebateSelector(analyses,gc,config.getMaxCodesize());
    }
 else {
      selector=new WCETRebateSelector(analyses,gc,config.getMaxCodesize());
    }
  }
 else {
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
  }
  selector.initialize();
  ExecFrequencyProvider ecp=useWCAProvider ? analyses.getWCAInvoker() : analyses.getExecFrequencyAnalysis();
  if (config.useLocalExecCount()) {
    ecp=new LocalExecFrequencyProvider(ecp);
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,ecp,selector,wcaMethods);
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    selector.printStatistics();
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
    selector.initialize();
    ecp=analyses.getExecFrequencyAnalysis();
    if (config.useLocalExecCount()) {
      ecp=new LocalExecFrequencyProvider(ecp);
    }
    optimizeMethods(analyses,ecp,selector,others);
  }
 else   if (order == GreedyOrder.TopDown || order == GreedyOrder.BottomUp) {
    if (config.useWCA() && !analyses.hasWCATargetsOnly()) {
      throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
    }
    TopologicalOrderIterator<MethodNode,InvokeEdge> topOrder=new TopologicalOrderIterator<MethodNode,InvokeEdge>(analyses.getTargetCallGraph().getAcyclicMergedGraph(order == GreedyOrder.BottomUp));
    while (topOrder.hasNext()) {
      MethodNode node=topOrder.next();
      optimizeMethods(analyses,ecp,selector,Collections.singleton(node.getMethodInfo()));
    }
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  selector.printStatistics();
  printStatistics();
}","public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  resetCounters();
  boolean useWCAProvider=config.useWCA() && config.useWCAExecCount();
  GreedyOrder order=config.getOrder();
  if (order != GreedyOrder.WCAFirst) {
    if (!config.getTargetMethodSet().equals(config.getWCATargetSet())) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"");
      useWCAProvider=false;
    }
  }
  AnalysisManager analyses=initializeAnalyses(config.useWCEP() || useWCAProvider);
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    GainCalculator gc=new GainCalculator(analyses);
    if (config.useWCEP()) {
      logger.info(""String_Node_Str"");
      selector=new WCEPRebateSelector(analyses,gc,config.getMaxCodesize());
    }
 else {
      logger.info(""String_Node_Str"");
      selector=new WCETRebateSelector(analyses,gc,config.getMaxCodesize());
    }
  }
 else {
    logger.info(""String_Node_Str"");
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
  }
  selector.initialize();
  ExecFrequencyProvider ecp=useWCAProvider ? analyses.getWCAInvoker() : analyses.getExecFrequencyAnalysis();
  if (config.useLocalExecCount()) {
    ecp=new LocalExecFrequencyProvider(ecp);
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,ecp,selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    logger.info(""String_Node_Str"");
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,ecp,selector,wcaMethods);
    selector.printStatistics();
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    logger.info(""String_Node_Str"");
    selector=new ACETRebateSelector(analyses,new GainCalculator(analyses),config.getMaxCodesize());
    selector.initialize();
    ecp=analyses.getExecFrequencyAnalysis();
    if (config.useLocalExecCount()) {
      ecp=new LocalExecFrequencyProvider(ecp);
    }
    optimizeMethods(analyses,ecp,selector,others);
  }
 else   if (order == GreedyOrder.TopDown || order == GreedyOrder.BottomUp) {
    if (config.useWCA() && !analyses.hasWCATargetsOnly()) {
      throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
    }
    TopologicalOrderIterator<MethodNode,InvokeEdge> topOrder=new TopologicalOrderIterator<MethodNode,InvokeEdge>(analyses.getTargetCallGraph().getAcyclicMergedGraph(order == GreedyOrder.BottomUp));
    while (topOrder.hasNext()) {
      MethodNode node=topOrder.next();
      optimizeMethods(analyses,ecp,selector,Collections.singleton(node.getMethodInfo()));
    }
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
  analyses.getTargetCallGraph().dumpCallgraph(jcopter.getJConfig().getConfig(),""String_Node_Str"",config.getTargetCallgraphDumpType(),true);
  selector.printStatistics();
  printStatistics();
}",0.965507075471698
186627,"/** 
 * Check if this method is the same as or overrides a given method. <p> This checks the class of the reference if checkSignature is true, so even if the reference resolves to this method, this returns false if the reference refers to a subclass of this method's class. </p>
 * @param superMethod the superMethod to check, must refer to a known class.
 * @param checkSignature if true, check if the given method has the same signature and if the reference refers toa superclass of this method's class. If this is false, it is assumed that the signatures match and this method's class is a subclass of the referred class.
 * @return true if this method overrides the given method and can access the method.
 */
public boolean overrides(MethodRef superMethod,boolean checkSignature){
  ClassInfo classRef=superMethod.getClassInfo();
  if (classRef == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (classRef.equals(getClassInfo())) {
    if (checkSignature && !getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    return true;
  }
  if (isStatic()) {
    return false;
  }
  MethodInfo sm=superMethod.getMethodInfo();
  if (this.equals(sm)) {
    return true;
  }
  if (checkSignature) {
    if (!getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    if (!getClassInfo().isSubclassOf(superMethod.getClassInfo())) {
      return false;
    }
  }
  if (sm == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (sm.isStatic()) {
    logger.warn(""String_Node_Str"" + getMemberID() + ""String_Node_Str""+ sm.getMemberID());
  }
  return getClassInfo().canAccess(sm);
}","/** 
 * Check if this method is the same as or overrides a given method. <p> This checks the class of the reference if checkSignature is true, so even if the reference resolves to this method, this returns false if the reference refers to a subclass of this method's class. </p> <p>This might not work as expected for interface methods. To check if this method implements an interface method even if the class of this method does not implement the interface, use  {@link #implementsMethod(MethodRef)} instead.</p>
 * @param superMethod the superMethod to check, must refer to a known class.
 * @param checkSignature if true, check if the given method has the same signature and if the reference refers toa superclass of this method's class. If this is false, it is assumed that the signatures match and this method's class is a subclass of the referred class.
 * @return true if this method overrides the given method and can access the method.
 */
public boolean overrides(MethodRef superMethod,boolean checkSignature){
  ClassInfo superClass=superMethod.getClassInfo();
  if (superClass == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (superClass.equals(getClassInfo())) {
    if (checkSignature && !getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    return true;
  }
  if (isStatic()) {
    return false;
  }
  MethodInfo sm=superMethod.getMethodInfo();
  if (this.equals(sm)) {
    return true;
  }
  if (checkSignature) {
    if (!getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    if (!getClassInfo().isSubclassOf(superClass)) {
      return false;
    }
  }
  if (sm == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (sm.isStatic()) {
    logger.warn(""String_Node_Str"" + getMemberID() + ""String_Node_Str""+ sm.getMemberID());
  }
  return getClassInfo().canAccess(sm);
}",0.9178119105362436
186628,"/** 
 * For a given non-empty callstring, find all implementations which might get called by the last invocation in the callstring, i.e. find all methods which might appear in the next entry of the callstring. <p> This is only a lookup in the callgraph, and does not check if the invocation is a special invoke, so if callstring length of the callgraph is zero, the results are not correct. Instead use  {@link AppInfo#findImplementations(CallString)} which handles all special cases and falls backto the default callgraph. </p>
 * @param cs callstring of the invocation, must contain at least one invokesite.
 * @return a list of all methods which might get invoked by the top invocation of the callstring,with their callstrings.
 */
public Set<ExecutionContext> findImplementationContexts(CallString cs){
  if (cs.length() == 0) {
    throw new AssertionError(""String_Node_Str"");
  }
  InvokeSite invoke=cs.top();
  Set<ExecutionContext> methods=new HashSet<ExecutionContext>();
  MethodRef invokeeRef=invoke.getInvokeeRef();
  Set<ExecutionContext> invoker=getNodes(invoke.getInvoker());
  for (  ExecutionContext invokeNode : invoker) {
    for (    ContextEdge outEdge : callGraph.outgoingEdgesOf(invokeNode)) {
      CallString cgString=outEdge.getTarget().getCallString();
      if (cgString.isEmpty()) {
        if (outEdge.getTarget().getMethodInfo().overrides(invokeeRef,true)) {
          methods.add(outEdge.getTarget());
        }
      }
 else {
        if (cs.matches(cgString)) {
          methods.add(outEdge.getTarget());
        }
      }
    }
  }
  return methods;
}","/** 
 * For a given non-empty callstring, find all implementations which might get called by the last invocation in the callstring, i.e. find all methods which might appear in the next entry of the callstring. <p> This is only a lookup in the callgraph, and does not check if the invocation is a special invoke, so if callstring length of the callgraph is zero, the results are not correct. Instead use  {@link AppInfo#findImplementations(CallString)} which handles all special cases and falls backto the default callgraph. </p>
 * @param cs callstring of the invocation, must contain at least one invokesite.
 * @return a list of all methods which might get invoked by the top invocation of the callstring,with their callstrings.
 */
public Set<ExecutionContext> findImplementationContexts(CallString cs){
  if (cs.length() == 0) {
    throw new AssertionError(""String_Node_Str"");
  }
  InvokeSite invoke=cs.top();
  Set<ExecutionContext> methods=new HashSet<ExecutionContext>();
  MethodRef invokeeRef=invoke.getInvokeeRef();
  Set<ExecutionContext> invoker=getNodes(invoke.getInvoker());
  for (  ExecutionContext invokeNode : invoker) {
    for (    ContextEdge outEdge : callGraph.outgoingEdgesOf(invokeNode)) {
      CallString cgString=outEdge.getTarget().getCallString();
      if (cgString.isEmpty()) {
        if (invokeeRef.isInterfaceMethod() == Ternary.TRUE) {
          if (outEdge.getTarget().getMethodInfo().implementsMethod(invokeeRef)) {
            methods.add(outEdge.getTarget());
          }
        }
 else {
          if (outEdge.getTarget().getMethodInfo().overrides(invokeeRef,true)) {
            methods.add(outEdge.getTarget());
          }
        }
      }
 else {
        if (cs.matches(cgString)) {
          methods.add(outEdge.getTarget());
        }
      }
    }
  }
  return methods;
}",0.9237536656891496
186629,"public SerializedFlowEdge(FlowEdge e){
  this.type=e.type;
  this.methodName=e.getContext().getMethodInfo().getFQMethodName();
  this.headIns=e.head.getPosition();
  this.tailIns=e.head.getPosition();
}","public SerializedFlowEdge(FlowEdge e){
  this.type=e.type;
  this.methodName=e.getContext().getMethodInfo().getFQMethodName();
  this.headIns=e.head.getPosition();
  this.tailIns=e.tail.getPosition();
}",0.9801980198019802
186630,"@Override public int getMaxMethodSize(){
  return 65535;
}","@Override public int getMaxMethodSize(){
  return 512;
}",0.9473684210526316
186631,"public InlineHelper(JCopter jcopter,InlineConfig inlineConfig){
  this.jcopter=jcopter;
  this.inlineConfig=inlineConfig;
  maxInlineSize=0;
  maxRecursiveInlining=0;
  maxCodesize=0;
  maxLocals=0;
  maxStacksize=0;
}","public InlineHelper(JCopter jcopter,InlineConfig inlineConfig){
  this.jcopter=jcopter;
  this.inlineConfig=inlineConfig;
  maxInlineSize=0;
  maxRecursiveInlining=0;
  ProcessorModel pm=AppInfo.getSingleton().getProcessorModel();
  maxCodesize=pm.getMaxMethodSize();
  maxLocals=pm.getMaxLocals();
  maxStacksize=pm.getMaxStackSize();
}",0.7423423423423423
186632,"@Override public boolean recalculate(AnalysisManager analyses,StacksizeAnalysis stacksize){
  deltaLocals=invokee.getCode().getMaxLocals();
  if (!checkStackAndLocals(stacksize)) {
    return false;
  }
  deltaCodesize=calcDeltaCodesize(analyses);
  isLastLocalInvoke=checkIsLastLocalInvoke();
  isLastInvoke=isLastLocalInvoke && checkIsLastInvoker();
  localGain=calcLocalGain(analyses);
  calcCacheMissCosts(analyses,deltaCodesize);
  return true;
}","@Override public boolean recalculate(AnalysisManager analyses,StacksizeAnalysis stacksize){
  deltaLocals=invokee.getCode().getMaxLocals();
  deltaCodesize=calcDeltaCodesize(analyses);
  if (!checkConstraints(stacksize)) {
    return false;
  }
  isLastLocalInvoke=checkIsLastLocalInvoke();
  isLastInvoke=isLastLocalInvoke && checkIsLastInvoker();
  localGain=calcLocalGain(analyses);
  calcCacheMissCosts(analyses,deltaCodesize);
  return true;
}",0.8743047830923248
186633,"/** 
 * Check if this method is the same as or overrides a given method. <p> This checks the class of the reference if checkSignature is true, so even if the reference resolves to this method, this returns false if the reference refers to a subclass of this method's class. </p>
 * @param superMethod the superMethod to check, must refer to a known class.
 * @param checkSignature if true, check if the given method has the same signature and if the reference refers toa superclass of this method's class. If this is false, it is assumed that the signatures match and this method's class is a subclass of the referred class.
 * @return true if this method overrides the given method and can access the method.
 */
public boolean overrides(MethodRef superMethod,boolean checkSignature){
  ClassInfo classRef=superMethod.getClassInfo();
  if (classRef == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (classRef.equals(getClassInfo())) {
    if (checkSignature && !getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    return true;
  }
  if (isStatic()) {
    return false;
  }
  if (checkSignature) {
    if (!getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    if (!getClassInfo().isSubclassOf(superMethod.getClassInfo())) {
      return false;
    }
  }
  MethodInfo sm=superMethod.getMethodInfo();
  if (sm == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (sm.isStatic()) {
    logger.warn(""String_Node_Str"" + getMemberID() + ""String_Node_Str""+ sm.getMemberID());
  }
  return getClassInfo().canAccess(sm);
}","/** 
 * Check if this method is the same as or overrides a given method. <p> This checks the class of the reference if checkSignature is true, so even if the reference resolves to this method, this returns false if the reference refers to a subclass of this method's class. </p>
 * @param superMethod the superMethod to check, must refer to a known class.
 * @param checkSignature if true, check if the given method has the same signature and if the reference refers toa superclass of this method's class. If this is false, it is assumed that the signatures match and this method's class is a subclass of the referred class.
 * @return true if this method overrides the given method and can access the method.
 */
public boolean overrides(MethodRef superMethod,boolean checkSignature){
  ClassInfo classRef=superMethod.getClassInfo();
  if (classRef == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (classRef.equals(getClassInfo())) {
    if (checkSignature && !getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    return true;
  }
  if (isStatic()) {
    return false;
  }
  MethodInfo sm=superMethod.getMethodInfo();
  if (this.equals(sm)) {
    return true;
  }
  if (checkSignature) {
    if (!getMethodSignature().equals(superMethod.getMethodSignature())) {
      return false;
    }
    if (!getClassInfo().isSubclassOf(superMethod.getClassInfo())) {
      return false;
    }
  }
  if (sm == null) {
    throw new AppInfoError(""String_Node_Str"" + superMethod + ""String_Node_Str"");
  }
  if (sm.isStatic()) {
    logger.warn(""String_Node_Str"" + getMemberID() + ""String_Node_Str""+ sm.getMemberID());
  }
  return getClassInfo().canAccess(sm);
}",0.9604651162790696
186634,"/** 
 * Check the options, check if the assumptions on the code hold.
 * @throws BadConfigurationException if the WCA_TARGETS option is not set correctly
 */
public void initialize() throws BadConfigurationException {
  if (useWCA()) {
  }
 else   if (options.isSet(WCA_TARGETS)) {
    try {
      wcaTargets=Config.parseMethodList(options.getOption(WCA_TARGETS));
    }
 catch (    BadConfigurationException ignored) {
      logger.warn(""String_Node_Str"" + options.getOption(WCA_TARGETS) + ""String_Node_Str"");
    }
  }
 else {
    try {
      wcaTargets=Config.parseMethodList(options.getOption(WCA_TARGETS));
    }
 catch (    BadConfigurationException ignored) {
      logger.debug(""String_Node_Str"");
    }
  }
}","/** 
 * Check the options, check if the assumptions on the code hold.
 * @throws BadConfigurationException if the WCA_TARGETS option is not set correctly
 */
public void initialize() throws BadConfigurationException {
  if (useWCA()) {
    wcaTargets=Config.parseMethodList(options.getOption(WCA_TARGETS));
  }
 else   if (options.isSet(WCA_TARGETS)) {
    try {
      wcaTargets=Config.parseMethodList(options.getOption(WCA_TARGETS));
    }
 catch (    BadConfigurationException ignored) {
      logger.warn(""String_Node_Str"" + options.getOption(WCA_TARGETS) + ""String_Node_Str"");
    }
  }
 else {
    try {
      wcaTargets=Config.parseMethodList(options.getOption(WCA_TARGETS));
    }
 catch (    BadConfigurationException ignored) {
      logger.debug(""String_Node_Str"");
    }
  }
}",0.5913621262458472
186635,"public void initialize() throws BadConfigurationException {
  if (wcaTargets.size() != 1) {
    throw new BadConfigurationException(""String_Node_Str"");
  }
  setWCETOptions(wcaTargets.iterator().next(),false);
  wcetTool.initialize(false);
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  runAnalysis(wcetTool.getCallGraph().getReversedGraph());
}","public void initialize() throws BadConfigurationException {
  if (wcaTargets.isEmpty()) {
    throw new BadConfigurationException(""String_Node_Str"");
  }
  if (wcaTargets.size() != 1) {
    throw new BadConfigurationException(""String_Node_Str"");
  }
  setWCETOptions(wcaTargets.iterator().next(),false);
  wcetTool.initialize(false);
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  runAnalysis(wcetTool.getCallGraph().getReversedGraph());
}",0.9384010484927916
186636,"private void optimizeMethods(AnalysisManager analyses,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates();
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates();
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(methods);
    }
 else {
      logger.info(""String_Node_Str"" + changeSet.size());
      selector.sortCandidates(changeSet);
    }
    candidates=selector.selectNextCandidates();
  }
}","private void optimizeMethods(AnalysisManager analyses,ExecCountProvider ecp,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates();
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates();
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(methods);
    }
 else {
      logger.info(""String_Node_Str"" + changeSet.size());
      selector.sortCandidates(changeSet);
    }
    candidates=selector.selectNextCandidates();
  }
}",0.996103436060928
186637,"public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  resetCounters();
  AnalysisManager analyses=initializeAnalyses();
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    selector=new WCETRebateSelector(analyses,config.getMaxCodesize());
  }
 else {
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
  }
  selector.initialize();
  GreedyOrder order=config.getOrder();
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,selector,wcaMethods);
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    selector.printStatistics();
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
    selector.initialize();
    optimizeMethods(analyses,selector,others);
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
  selector.printStatistics();
  printStatistics();
}","public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  resetCounters();
  AnalysisManager analyses=initializeAnalyses();
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    selector=new WCETRebateSelector(analyses,config.getMaxCodesize());
  }
 else {
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
  }
  selector.initialize();
  GreedyOrder order=config.getOrder();
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,analyses.getExecCountAnalysis(),selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,analyses.getExecCountAnalysis(),selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,analyses.getWCAInvoker(),selector,wcaMethods);
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    selector.printStatistics();
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
    selector.initialize();
    optimizeMethods(analyses,analyses.getExecCountAnalysis(),selector,others);
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
  selector.printStatistics();
  printStatistics();
}",0.9620332601192344
186638,"private AnalysisManager initializeAnalyses(){
  AnalysisManager analyses=new AnalysisManager(jcopter);
  analyses.initAnalyses(config.getTargetMethods(),config.getCacheAnalysisType(),config.getWCATargets());
  logger.info(""String_Node_Str"" + analyses.getTargetCallGraph().getNodes().size());
  return analyses;
}","private AnalysisManager initializeAnalyses(){
  AnalysisManager analyses=new AnalysisManager(jcopter);
  analyses.initAnalyses(config.getTargetMethods(),config.getCacheAnalysisType(),config.useWCA() ? config.getWCATargets() : null);
  logger.info(""String_Node_Str"" + analyses.getTargetCallGraph().getNodes().size());
  return analyses;
}",0.9522342064714946
186639,"public Set<InvokeSite> getInvokeSites(MethodInfo invokee){
  MethodNode node=getMethodNode(invokee);
  Set<InvokeSite> invokeSites=new HashSet<InvokeSite>();
  for (  ExecutionContext ec : node.getInstances()) {
    if (ec.getCallString().isEmpty()) {
      AppInfo appInfo=AppInfo.getSingleton();
      for (      ContextEdge edge : callGraph.incomingEdgesOf(ec)) {
        for (        InvokeSite invokeSite : edge.getSource().getMethodInfo().getCode().getInvokeSites()) {
          Set<MethodInfo> impl=appInfo.findImplementations(invokeSite);
          if (impl.contains(invokee)) {
            invokeSites.add(invokeSite);
          }
        }
      }
    }
 else {
      invokeSites.add(ec.getCallString().top());
    }
  }
  return invokeSites;
}","public Set<InvokeSite> getInvokeSites(MethodInfo invokee){
  MethodNode node=getMethodNode(invokee);
  Set<InvokeSite> invokeSites=new HashSet<InvokeSite>();
  for (  ExecutionContext ec : node.getInstances()) {
    if (ec.getCallString().isEmpty()) {
      AppInfo appInfo=AppInfo.getSingleton();
      for (      ContextEdge edge : callGraph.incomingEdgesOf(ec)) {
        for (        InvokeSite invokeSite : edge.getSource().getMethodInfo().getCode().getInvokeSites()) {
          if (invokeSite.canInvoke(invokee) == Ternary.TRUE) {
            invokeSites.add(invokeSite);
          }
        }
      }
    }
 else {
      invokeSites.add(ec.getCallString().top());
    }
  }
  return invokeSites;
}",0.7333790267306374
186640,"private void traverse(EdgeProvider<V,E> provider,V parent,E edge,V node,int depth){
  Integer ts=discovery.get(node);
  DFSEdgeType type;
  if (parent == null) {
    type=DFSEdgeType.ROOT;
  }
 else   if (ts == null) {
    type=DFSEdgeType.TREE_EDGE;
  }
 else   if (ts < 0) {
    type=DFSEdgeType.BACK_EDGE;
  }
 else {
    int pts=-discovery.get(parent);
    type=pts <= ts ? DFSEdgeType.FORWARD_EDGE : DFSEdgeType.CROSS_EDGE;
  }
  Collection<E> outEdges=provider.outgoingEdgesOf(node);
  boolean descend=visitor.visitNode(parent,edge,node,type,outEdges,depth);
  if (ts == null) {
    return;
  }
  time++;
  int currTime=time;
  if (descend) {
    discovery.put(node,-currTime);
    for (    E out : outEdges) {
      traverse(provider,parent,out,provider.getEdgeTarget(out),depth + 1);
    }
  }
  visitor.finishNode(parent,edge,node,type,outEdges,depth);
  discovery.put(node,currTime);
  time++;
}","private void traverse(EdgeProvider<V,E> provider,V parent,E edge,V node,int depth){
  Integer ts=discovery.get(node);
  DFSEdgeType type;
  if (parent == null) {
    type=DFSEdgeType.ROOT;
  }
 else   if (ts == null) {
    type=DFSEdgeType.TREE_EDGE;
  }
 else   if (ts < 0) {
    type=DFSEdgeType.BACK_EDGE;
  }
 else {
    int pts=-discovery.get(parent);
    type=pts <= ts ? DFSEdgeType.FORWARD_EDGE : DFSEdgeType.CROSS_EDGE;
  }
  Collection<E> outEdges=provider.outgoingEdgesOf(node);
  boolean descend=visitor.visitNode(parent,edge,node,type,outEdges,depth);
  if (ts != null) {
    return;
  }
  time++;
  int currTime=time;
  if (descend) {
    discovery.put(node,-currTime);
    for (    E out : outEdges) {
      traverse(provider,node,out,provider.getEdgeTarget(out),depth + 1);
    }
  }
  visitor.finishNode(parent,edge,node,type,outEdges,depth);
  discovery.put(node,currTime);
  time++;
}",0.9933628318584072
186641,"private void updateExecCounts(DirectedGraph<ExecutionContext,ContextEdge> dag){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(dag);
  while (topOrder.hasNext()) {
    ExecutionContext next=topOrder.next();
    updateChilds(next,callGraph.getChildren(next));
  }
}","private void updateExecCounts(DirectedGraph<ExecutionContext,ContextEdge> dag){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(dag);
  while (topOrder.hasNext()) {
    ExecutionContext next=topOrder.next();
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + next);
    }
    updateChilds(next,callGraph.getChildren(next));
  }
}",0.8586251621271076
186642,"/** 
 * Update the execution counts after inlining. This must be called after the underlying callgraph has been updated!
 * @param invokeSite the inlined invokesite.
 * @param invokee the inlined method.
 * @param newInvokeSites the set of new invokesites in the invoker
 */
public void inline(InvokeSite invokeSite,MethodInfo invokee,Set<InvokeSite> newInvokeSites){
  List<ExecutionContext> queue=new ArrayList<ExecutionContext>();
  for (  ExecutionContext context : callGraph.getNodes(invokeSite.getInvoker())) {
    for (    ExecutionContext child : callGraph.getChildren(context)) {
      if (child.getCallString().isEmpty() && child.getMethodInfo().equals(invokee)) {
        nodeCount.put(child,nodeCount.get(child) - getExecCount(invokeSite));
      }
 else       if (!child.getCallString().isEmpty() && newInvokeSites.contains(child.getCallString().top())) {
        addExecCount(child,getExecCount(context,child.getCallString().top().getInstructionHandle()));
        queue.add(child);
      }
    }
  }
  DirectedGraph<ExecutionContext,ContextEdge> dag=GraphUtils.copyGraph(new InlineEdgeProvider(newInvokeSites),callGraph.getEdgeFactory(),queue,false);
  updateExecCounts(dag);
  changeSet.add(invokee);
}","/** 
 * Update the execution counts after inlining. This must be called after the underlying callgraph has been updated!
 * @param invokeSite the inlined invokesite.
 * @param invokee the inlined method.
 * @param newInvokeSites the set of new invokesites in the invoker
 */
public void inline(InvokeSite invokeSite,MethodInfo invokee,Set<InvokeSite> newInvokeSites){
  List<ExecutionContext> queue=new ArrayList<ExecutionContext>();
  for (  ExecutionContext context : callGraph.getNodes(invokeSite.getInvoker())) {
    for (    ExecutionContext child : callGraph.getChildren(context)) {
      if (child.getCallString().isEmpty() && child.getMethodInfo().equals(invokee)) {
        nodeCount.put(child,nodeCount.get(child) - getExecCount(invokeSite,invokee));
      }
 else       if (!child.getCallString().isEmpty() && newInvokeSites.contains(child.getCallString().top())) {
        addExecCount(child,getExecCount(context,child.getCallString().top().getInstructionHandle()));
        queue.add(child);
      }
    }
  }
  DirectedGraph<ExecutionContext,ContextEdge> dag=GraphUtils.copyGraph(new InlineEdgeProvider(newInvokeSites),callGraph.getEdgeFactory(),queue,false);
  updateExecCounts(dag);
  changeSet.add(invokee);
}",0.9967266775777414
186643,"/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not of the implementing class. </p> <p>To handle invocations of super-methods correctly, use   {@link #findImplementations(InvokeSite)}instead.</p>
 * @see #findImplementations(InvokeSite)
 * @see MethodInfo#overrides(MethodRef,boolean)
 * @param invokee the method to resolve.
 * @return all possible implementations, including native methods.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMethodSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.debug(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  boolean undefinedBaseMethod=false;
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      if (invokeeClass.isFullyKnown(true)) {
        throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
      }
 else {
        logger.debug(""String_Node_Str"" + invokee.toString());
        undefinedBaseMethod=true;
      }
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m;
      if (invokeeClass.isInterface() && !classInfo.isInterface()) {
        m=classInfo.getMethodInfoInherited(methodSig,true);
      }
 else {
        m=classInfo.getMethodInfo(methodSig);
      }
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  if (undefinedBaseMethod && methods.size() > 0) {
    throw new JavaClassFormatError(""String_Node_Str"" + invokee + ""String_Node_Str"");
  }
  return methods;
}","/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not of the implementing class. </p> <p>To handle invocations of super-methods correctly, use   {@link #findImplementations(InvokeSite)}instead.</p>
 * @see #findImplementations(InvokeSite)
 * @see MethodInfo#overrides(MethodRef,boolean)
 * @param invokee the method to resolve.
 * @return all possible implementations, including native methods.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMethodSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.debug(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  if (""String_Node_Str"".equals(invokee.getName())) {
    MethodInfo init=invokee.getMethodInfo();
    if (init == null) {
      throw new JavaClassFormatError(""String_Node_Str"" + invokee);
    }
    if (init.isAbstract()) {
      throw new JavaClassFormatError(""String_Node_Str"" + invokee);
    }
    methods.add(init);
    return methods;
  }
  boolean undefinedBaseMethod=false;
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      if (invokeeClass.isFullyKnown(true)) {
        throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
      }
 else {
        logger.debug(""String_Node_Str"" + invokee.toString());
        undefinedBaseMethod=true;
      }
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m;
      if (invokeeClass.isInterface() && !classInfo.isInterface()) {
        m=classInfo.getMethodInfoInherited(methodSig,true);
      }
 else {
        m=classInfo.getMethodInfo(methodSig);
      }
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  if (undefinedBaseMethod && methods.size() > 0) {
    throw new JavaClassFormatError(""String_Node_Str"" + invokee + ""String_Node_Str"");
  }
  return methods;
}",0.9213557091148404
186644,"/** 
 * Get all non-abstract methods (including this method if it is not abstract) overriding this method.
 * @see AppInfo#findImplementations(CallString)
 * @see AppInfo#findImplementations(MethodRef)
 * @param checkAccess if false, find all non-abstract methods with same signature even if they do notoverride this method.
 * @return a collection of all implementations of this method.
 */
public List<MethodInfo> getImplementations(final boolean checkAccess){
  final List<MethodInfo> implementations=new LinkedList<MethodInfo>();
  if (checkAccess && (isPrivate() || isStatic())) {
    if (isAbstract()) {
      throw new JavaClassFormatError(""String_Node_Str"" + toString());
    }
    implementations.add(this);
    return implementations;
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m=classInfo.getMethodInfo(getMethodSignature());
      if (m != null) {
        if (m.isPrivate() && !isPrivate()) {
          logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ getClassInfo().getClassName());
        }
        if (!m.isAbstract() && (!checkAccess || m.overrides(MethodInfo.this,false))) {
          implementations.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  new ClassHierarchyTraverser(visitor).traverseDown(getClassInfo());
  return implementations;
}","/** 
 * Get all non-abstract methods (including this method if it is not abstract) overriding this method.
 * @see AppInfo#findImplementations(CallString)
 * @see AppInfo#findImplementations(MethodRef)
 * @param checkAccess if false, find all non-abstract methods with same signature even if they do notoverride this method.
 * @return a collection of all implementations of this method.
 */
public List<MethodInfo> getImplementations(final boolean checkAccess){
  final List<MethodInfo> implementations=new LinkedList<MethodInfo>();
  if (checkAccess && (isPrivate() || isStatic())) {
    if (isAbstract()) {
      throw new JavaClassFormatError(""String_Node_Str"" + toString());
    }
    implementations.add(this);
    return implementations;
  }
  if (""String_Node_Str"".equals(getShortName())) {
    if (isAbstract()) {
      throw new JavaClassFormatError(""String_Node_Str"" + toString());
    }
    implementations.add(this);
    return implementations;
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m=classInfo.getMethodInfo(getMethodSignature());
      if (m != null) {
        if (m.isPrivate() && !isPrivate()) {
          logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ getClassInfo().getClassName());
        }
        if (!m.isAbstract() && (!checkAccess || m.overrides(MethodInfo.this,false))) {
          implementations.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  new ClassHierarchyTraverser(visitor).traverseDown(getClassInfo());
  return implementations;
}",0.9329556185080264
186645,"public void buildCallGraph(boolean useDFA){
  if (useDFA) {
    DFACallgraphBuilder builder=new DFACallgraphBuilder(jcopter.getDfaTool(),appInfo.getCallstringLength());
    builder.setSkipNatives(true);
    appInfo.buildCallGraph(builder);
  }
 else {
    DefaultCallgraphBuilder builder=new DefaultCallgraphBuilder();
    builder.setSkipNatives(true);
    appInfo.buildCallGraph(builder);
    reduceCallGraph();
  }
}","public void buildCallGraph(boolean useDFA){
  if (useDFA) {
    DFACallgraphBuilder builder=new DFACallgraphBuilder(jcopter.getDfaTool(),appInfo.getCallstringLength());
    builder.setSkipNatives(true);
    appInfo.buildCallGraph(builder);
  }
 else {
    DefaultCallgraphBuilder builder=new DefaultCallgraphBuilder();
    builder.setSkipNatives(true);
    builder.setUseCallgraph(false);
    appInfo.buildCallGraph(builder);
    reduceCallGraph();
  }
}",0.9587155963302753
186646,"public void initialize() throws BadConfigurationException {
  if (wcaTargets.size() != 1) {
    throw new BadConfigurationException(""String_Node_Str"");
  }
  setWCETOptions(wcaTargets.iterator().next(),false);
  wcetTool.initialize();
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  runAnalysis(wcetTool.getCallGraph().getReversedGraph());
}","public void initialize() throws BadConfigurationException {
  if (wcaTargets.size() != 1) {
    throw new BadConfigurationException(""String_Node_Str"");
  }
  setWCETOptions(wcaTargets.iterator().next(),false);
  wcetTool.initialize(false);
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  runAnalysis(wcetTool.getCallGraph().getReversedGraph());
}",0.9964961457603364
186647,"private boolean run(ExecHelper exec){
  File uppaalOutDir;
  try {
    project.setTopLevelLogger(tlLogger);
    tlLogger.info(""String_Node_Str"");
    project.initialize();
    uppaalOutDir=project.getOutDir(""String_Node_Str"");
  }
 catch (  Exception e) {
    exec.logException(""String_Node_Str"",e);
    return false;
  }
  UppaalAnalysis ua=new UppaalAnalysis(tlLogger,project,uppaalOutDir);
  List<MethodInfo> methods=project.getCallGraph().getReachableImplementations(project.getTargetMethod());
  Collections.reverse(methods);
  List<WCETEntry> entries=new ArrayList<WCETEntry>();
  for (  MethodInfo m : methods) {
    if (project.computeCyclomaticComplexity(m) > ECC_TRESHOLD) {
      tlLogger.info(""String_Node_Str"" + m + ""String_Node_Str""+ project.computeCyclomaticComplexity(m)+ ""String_Node_Str"");
    }
 else {
      tlLogger.info(""String_Node_Str"" + m);
      WcetCost wcet;
      try {
        wcet=ua.calculateWCET(m);
        entries.add(new WCETEntry(m,wcet.getCost(),ua.getSearchtime(),ua.getSolvertimemax()));
      }
 catch (      Exception e) {
        exec.logException(""String_Node_Str"",e);
        return false;
      }
    }
  }
  for (  WCETEntry entry : entries) {
    System.out.println(""String_Node_Str"" + entry.target.toString());
    System.out.println(""String_Node_Str"" + entry.wcet);
    System.out.println(""String_Node_Str"" + project.computeCyclomaticComplexity(entry.target));
    System.out.println(""String_Node_Str"" + entry.searchtime);
    System.out.println(""String_Node_Str"" + entry.solvertime);
  }
  return true;
}","private boolean run(ExecHelper exec){
  File uppaalOutDir;
  try {
    project.setTopLevelLogger(tlLogger);
    tlLogger.info(""String_Node_Str"");
    project.initialize(true);
    uppaalOutDir=project.getOutDir(""String_Node_Str"");
  }
 catch (  Exception e) {
    exec.logException(""String_Node_Str"",e);
    return false;
  }
  UppaalAnalysis ua=new UppaalAnalysis(tlLogger,project,uppaalOutDir);
  List<MethodInfo> methods=project.getCallGraph().getReachableImplementations(project.getTargetMethod());
  Collections.reverse(methods);
  List<WCETEntry> entries=new ArrayList<WCETEntry>();
  for (  MethodInfo m : methods) {
    if (project.computeCyclomaticComplexity(m) > ECC_TRESHOLD) {
      tlLogger.info(""String_Node_Str"" + m + ""String_Node_Str""+ project.computeCyclomaticComplexity(m)+ ""String_Node_Str"");
    }
 else {
      tlLogger.info(""String_Node_Str"" + m);
      WcetCost wcet;
      try {
        wcet=ua.calculateWCET(m);
        entries.add(new WCETEntry(m,wcet.getCost(),ua.getSearchtime(),ua.getSolvertimemax()));
      }
 catch (      Exception e) {
        exec.logException(""String_Node_Str"",e);
        return false;
      }
    }
  }
  for (  WCETEntry entry : entries) {
    System.out.println(""String_Node_Str"" + entry.target.toString());
    System.out.println(""String_Node_Str"" + entry.wcet);
    System.out.println(""String_Node_Str"" + project.computeCyclomaticComplexity(entry.target));
    System.out.println(""String_Node_Str"" + entry.searchtime);
    System.out.println(""String_Node_Str"" + entry.solvertime);
  }
  return true;
}",0.9987154784842646
186648,"private boolean run(){
  try {
    project.setTopLevelLogger(exec.getExecLogger());
    exec.info(""String_Node_Str"");
    project.initialize();
    MethodInfo largestMethod=project.getWCETProcessorModel().getMethodCache().checkCache();
    int minWords=MiscUtils.bytesToWords(largestMethod.getCode().getNumberOfBytes());
    reportMetric(""String_Node_Str"",largestMethod.getFQMethodName(),minWords);
  }
 catch (  Exception e) {
    exec.logException(""String_Node_Str"",e);
    return false;
  }
  if (project.getProjectConfig().doObjectCacheAnalysis()) {
    ObjectCacheAnalysis oca=new ObjectCacheAnalysis(project);
    return oca.run();
  }
 else {
    return runWCETAnalysis();
  }
}","private boolean run(){
  try {
    project.setTopLevelLogger(exec.getExecLogger());
    exec.info(""String_Node_Str"");
    project.initialize(true);
    MethodInfo largestMethod=project.getWCETProcessorModel().getMethodCache().checkCache();
    int minWords=MiscUtils.bytesToWords(largestMethod.getCode().getNumberOfBytes());
    reportMetric(""String_Node_Str"",largestMethod.getFQMethodName(),minWords);
  }
 catch (  Exception e) {
    exec.logException(""String_Node_Str"",e);
    return false;
  }
  if (project.getProjectConfig().doObjectCacheAnalysis()) {
    ObjectCacheAnalysis oca=new ObjectCacheAnalysis(project);
    return oca.run();
  }
 else {
    return runWCETAnalysis();
  }
}",0.9970887918486172
186649,"private void reportSpecial(String metric,WcetCost cost,long start,long stop,double solverTime){
  String key=""String_Node_Str"" + metric;
  System.out.println(key + ""String_Node_Str"" + cost);
  if (start != stop)   System.out.println(key + ""String_Node_Str"" + timeDiff(start,stop));
  if (solverTime != 0)   System.out.println(key + ""String_Node_Str"" + solverTime);
  project.recordSpecialResult(metric,cost);
  project.getReport().addStat(key,cost.toString());
}","private void reportSpecial(String metric,WcetCost cost,long start,long stop,double solverTime){
  String key=""String_Node_Str"" + metric;
  System.out.println(key + ""String_Node_Str"" + cost);
  if (start != stop)   System.out.println(key + ""String_Node_Str"" + timeDiff(start,stop));
  if (solverTime != 0)   System.out.println(key + ""String_Node_Str"" + solverTime);
  project.recordSpecialResult(metric,cost);
  if (project.reportGenerationActive()) {
    project.getReport().addStat(key,cost.toString());
  }
}",0.9506172839506172
186650,"public void initialize() throws BadConfigurationException {
  if (projectConfig.saveResults()) {
    this.resultRecord=projectConfig.getResultFile();
    if (!projectConfig.appendResults()) {
      recordMetric(""String_Node_Str"",this.getProjectName());
      if (projectConfig.addPerformanceResults()) {
        recordMetric(""String_Node_Str"",new Date());
      }
    }
  }
  linkerInfo=new LinkerInfo(this);
  try {
    linkerInfo.loadLinkInfo();
  }
 catch (  IOException e) {
    throw new BadConfigurationException(""String_Node_Str"",e);
  }
catch (  ClassNotFoundException e) {
    throw new BadConfigurationException(""String_Node_Str"",e);
  }
  if (doDataflowAnalysis()) {
    topLevelLogger.info(""String_Node_Str"");
    dataflowAnalysis();
    topLevelLogger.info(""String_Node_Str"");
  }
  if (!appInfo.hasCallGraph()) {
    DefaultCallgraphBuilder callGraphBuilder;
    if (doDataflowAnalysis()) {
      callGraphBuilder=new DFACallgraphBuilder(getDfaTool(),appInfo.getCallstringLength());
    }
 else {
      callGraphBuilder=new DefaultCallgraphBuilder();
    }
    callGraphBuilder.setSkipNatives(true);
    appInfo.buildCallGraph(callGraphBuilder);
  }
  rebuildCallGraph();
  if (projectConfig.doPreprocess()) {
    WCETPreprocess.preprocess(appInfo);
  }
  dumpCallGraph(""String_Node_Str"");
}","public void initialize(boolean loadLinkInfo) throws BadConfigurationException {
  if (projectConfig.saveResults()) {
    this.resultRecord=projectConfig.getResultFile();
    if (!projectConfig.appendResults()) {
      recordMetric(""String_Node_Str"",this.getProjectName());
      if (projectConfig.addPerformanceResults()) {
        recordMetric(""String_Node_Str"",new Date());
      }
    }
  }
  if (loadLinkInfo) {
    linkerInfo=new LinkerInfo(this);
    try {
      linkerInfo.loadLinkInfo();
    }
 catch (    IOException e) {
      throw new BadConfigurationException(""String_Node_Str"",e);
    }
catch (    ClassNotFoundException e) {
      throw new BadConfigurationException(""String_Node_Str"",e);
    }
  }
  if (doDataflowAnalysis()) {
    topLevelLogger.info(""String_Node_Str"");
    dataflowAnalysis();
    topLevelLogger.info(""String_Node_Str"");
  }
  if (!appInfo.hasCallGraph()) {
    DefaultCallgraphBuilder callGraphBuilder;
    if (doDataflowAnalysis()) {
      callGraphBuilder=new DFACallgraphBuilder(getDfaTool(),appInfo.getCallstringLength());
    }
 else {
      callGraphBuilder=new DefaultCallgraphBuilder();
    }
    callGraphBuilder.setSkipNatives(true);
    appInfo.buildCallGraph(callGraphBuilder);
  }
  rebuildCallGraph();
  if (projectConfig.doPreprocess()) {
    WCETPreprocess.preprocess(appInfo);
  }
  dumpCallGraph(""String_Node_Str"");
}",0.9304932735426008
186651,"/** 
 * Update class report (cost per line number)
 * @param key
 * @param sol FIXME: Currently only reported once per method
 */
private void updateClassReport(CacheKey key,LocalWCETSolution sol){
  MethodInfo m=key.m;
  if (costsPerLineReported.contains(m))   return;
  costsPerLineReported.add(m);
  Map<CFGNode,WcetCost> nodeCosts=sol.getNodeCostMap();
  HashMap<CFGNode,String> nodeFlowCostDescrs=new HashMap<CFGNode,String>();
  for (  Entry<CFGNode,WcetCost> entry : nodeCosts.entrySet()) {
    CFGNode n=entry.getKey();
    WcetCost cost=entry.getValue();
    if (sol.getNodeFlow(n) > 0) {
      nodeFlowCostDescrs.put(n,cost.toString());
      BasicBlock basicBlock=n.getBasicBlock();
      if (basicBlock != null) {
        TreeSet<Integer> lineRange=basicBlock.getSourceLineRange();
        if (lineRange.isEmpty()) {
          logger.error(""String_Node_Str"");
        }
        ClassInfo cli=basicBlock.getClassInfo();
        ClassReport cr=getWCETTool().getReport().getClassReport(cli);
        Long oldCost=(Long)cr.getLineProperty(lineRange.first(),""String_Node_Str"");
        if (oldCost == null)         oldCost=0L;
        long newCost=sol.getNodeFlow(n) * nodeCosts.get(n).getCost();
        if (logger.isTraceEnabled()) {
          logger.trace(""String_Node_Str"" + oldCost + ""String_Node_Str""+ newCost+ ""String_Node_Str""+ sol.getNodeFlow(n)+ ""String_Node_Str""+ nodeCosts.get(n).getCost()+ ""String_Node_Str""+ ""String_Node_Str""+ lineRange.first()+ ""String_Node_Str""+ basicBlock.getMethodInfo());
        }
        cr.addLineProperty(lineRange.first(),""String_Node_Str"",oldCost + newCost);
        for (        int i : lineRange) {
          cr.addLineProperty(i,""String_Node_Str"",""String_Node_Str"");
        }
      }
    }
 else {
      nodeFlowCostDescrs.put(n,""String_Node_Str"" + nodeCosts.get(n).getCost());
    }
  }
}","/** 
 * Update class report (cost per line number)
 * @param key
 * @param sol FIXME: Currently only reported once per method
 */
private void updateClassReport(CacheKey key,LocalWCETSolution sol){
  MethodInfo m=key.m;
  if (costsPerLineReported.contains(m))   return;
  costsPerLineReported.add(m);
  Map<CFGNode,WcetCost> nodeCosts=sol.getNodeCostMap();
  HashMap<CFGNode,String> nodeFlowCostDescrs=new HashMap<CFGNode,String>();
  for (  Entry<CFGNode,WcetCost> entry : nodeCosts.entrySet()) {
    CFGNode n=entry.getKey();
    WcetCost cost=entry.getValue();
    if (sol.getNodeFlow(n) > 0) {
      nodeFlowCostDescrs.put(n,cost.toString());
      BasicBlock basicBlock=n.getBasicBlock();
      if (basicBlock != null) {
        TreeSet<Integer> lineRange=basicBlock.getSourceLineRange();
        if (lineRange.isEmpty()) {
          logger.error(""String_Node_Str"" + basicBlock + ""String_Node_Str""+ m+ ""String_Node_Str"");
          continue;
        }
        ClassInfo cli=basicBlock.getClassInfo();
        ClassReport cr=getWCETTool().getReport().getClassReport(cli);
        Long oldCost=(Long)cr.getLineProperty(lineRange.first(),""String_Node_Str"");
        if (oldCost == null)         oldCost=0L;
        long newCost=sol.getNodeFlow(n) * nodeCosts.get(n).getCost();
        if (logger.isTraceEnabled()) {
          logger.trace(""String_Node_Str"" + oldCost + ""String_Node_Str""+ newCost+ ""String_Node_Str""+ sol.getNodeFlow(n)+ ""String_Node_Str""+ nodeCosts.get(n).getCost()+ ""String_Node_Str""+ ""String_Node_Str""+ lineRange.first()+ ""String_Node_Str""+ basicBlock.getMethodInfo());
        }
        cr.addLineProperty(lineRange.first(),""String_Node_Str"",oldCost + newCost);
        for (        int i : lineRange) {
          cr.addLineProperty(i,""String_Node_Str"",""String_Node_Str"");
        }
      }
    }
 else {
      nodeFlowCostDescrs.put(n,""String_Node_Str"" + nodeCosts.get(n).getCost());
    }
  }
}",0.9795158286778398
186652,"public LineNumberGen getLineNumberEntry(InstructionHandle ih,boolean checkPrevious){
  InstructionHandle prev=ih;
  while (prev != null) {
    InstructionTargeter[] targeter=ih.getTargeters();
    if (targeter != null) {
      for (      InstructionTargeter t : targeter) {
        if (t instanceof LineNumberGen) {
          return (LineNumberGen)t;
        }
      }
    }
    if (checkPrevious && prev.getAttribute(KEY_LINENUMBER) == null) {
      prev=prev.getPrev();
    }
 else {
      break;
    }
  }
  return null;
}","public LineNumberGen getLineNumberEntry(InstructionHandle ih,boolean checkPrevious){
  InstructionHandle prev=ih;
  while (prev != null) {
    InstructionTargeter[] targeter=prev.getTargeters();
    if (targeter != null) {
      for (      InstructionTargeter t : targeter) {
        if (t instanceof LineNumberGen) {
          return (LineNumberGen)t;
        }
      }
    }
    if (checkPrevious && prev.getAttribute(KEY_LINENUMBER) == null) {
      prev=prev.getPrev();
    }
 else {
      break;
    }
  }
  return null;
}",0.994296577946768
186653,"@Override public String toString(){
  return ""String_Node_Str"" + target.getPosition() + ""String_Node_Str""+ edgeKind+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + instructions;
}",0.6820276497695853
186654,"@Override protected void register(){
  if (instantiatedFrom == null) {
    super.register();
  }
}","@Override protected void register(){
  if (instantiatedFrom == null) {
    super.register();
  }
 else {
    instantiatedFrom.register();
  }
}",0.8132780082987552
186655,"public void initAnalysis(boolean useMethodCacheStrategy){
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  runAnalysis(wcetTool.getCallGraph().getReversedGraph());
}","public void initAnalysis(boolean useMethodCacheStrategy){
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  runAnalysis(wcetTool.getCallGraph().getReversedGraph());
  updateWCEP();
}",0.985239852398524
186656,"/** 
 * Update the WCA results after a set of methods have been changed. The changesets of analyses in the AnalysisManager are checked for changes too.
 * @param changedMethods a set of methods of which the code has been modified.
 * @return a set of all methods for which the path may have changed.
 */
public Set<MethodInfo> updateWCA(Collection<MethodInfo> changedMethods){
  CallGraph callGraph=wcetTool.getCallGraph();
  final Set<ExecutionContext> rootNodes=new HashSet<ExecutionContext>();
  for (  MethodInfo root : changedMethods) {
    rootNodes.addAll(callGraph.getNodes(root));
  }
  final int callstringLength=AppInfo.getSingleton().getCallstringLength();
  DFSVisitor<ExecutionContext,ContextEdge> visitor=new EmptyDFSVisitor<ExecutionContext,ContextEdge>(){
    @Override public boolean visitNode(    ExecutionContext parent,    ContextEdge edge,    ExecutionContext node,    DFSEdgeType type,    Collection<ContextEdge> outEdges,    int depth){
      if (type.isFirstVisit() && !wcaNodeFlow.containsKey(node)) {
        rootNodes.add(node);
      }
      return depth <= callstringLength;
    }
  }
;
  DFSTraverser<ExecutionContext,ContextEdge> traverser=new DFSTraverser<ExecutionContext,ContextEdge>(visitor);
  traverser.traverse(callGraph.getGraph(),rootNodes);
  for (  MethodInfo method : analyses.getMethodCacheAnalysis().getClassificationChangeSet()) {
    rootNodes.addAll(callGraph.getNodes(method));
  }
  return runAnalysis(wcetTool.getCallGraph().createInvokeGraph(rootNodes,true));
}","/** 
 * Update the WCA results after a set of methods have been changed. The changesets of analyses in the AnalysisManager are checked for changes too.
 * @param changedMethods a set of methods of which the code has been modified.
 * @return a set of all methods for which the path may have changed.
 */
public Set<MethodInfo> updateWCA(Collection<MethodInfo> changedMethods){
  CallGraph callGraph=wcetTool.getCallGraph();
  final Set<ExecutionContext> rootNodes=new HashSet<ExecutionContext>();
  for (  MethodInfo root : changedMethods) {
    rootNodes.addAll(callGraph.getNodes(root));
  }
  final int callstringLength=AppInfo.getSingleton().getCallstringLength();
  DFSVisitor<ExecutionContext,ContextEdge> visitor=new EmptyDFSVisitor<ExecutionContext,ContextEdge>(){
    @Override public boolean visitNode(    ExecutionContext parent,    ContextEdge edge,    ExecutionContext node,    DFSEdgeType type,    Collection<ContextEdge> outEdges,    int depth){
      if (type.isFirstVisit() && !wcaNodeFlow.containsKey(node)) {
        rootNodes.add(node);
      }
      return depth <= callstringLength;
    }
  }
;
  DFSTraverser<ExecutionContext,ContextEdge> traverser=new DFSTraverser<ExecutionContext,ContextEdge>(visitor);
  traverser.traverse(callGraph.getGraph(),rootNodes);
  for (  MethodInfo method : analyses.getMethodCacheAnalysis().getClassificationChangeSet()) {
    rootNodes.addAll(callGraph.getNodes(method));
  }
  Set<MethodInfo> changed=runAnalysis(wcetTool.getCallGraph().createInvokeGraph(rootNodes,true));
  updateWCEP();
  return changed;
}",0.9788892497564144
186657,"private Set<MethodInfo> runAnalysis(DirectedGraph<ExecutionContext,ContextEdge> reversed){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(reversed);
  MethodCacheAnalysis cacheAnalysis=analyses.getMethodCacheAnalysis();
  Set<MethodInfo> changed=new HashSet<MethodInfo>();
  while (topOrder.hasNext()) {
    ExecutionContext node=topOrder.next();
    RecursiveWcetAnalysis<AnalysisContextLocal>.LocalWCETSolution sol=recursiveAnalysis.computeSolution(node.getMethodInfo(),cacheAnalysis.getAnalysisContext(node.getCallString()));
    wcaNodeFlow.put(node,sol.getNodeFlow());
    if (node.getMethodInfo().equals(wcetTool.getTargetMethod())) {
      logger.info(""String_Node_Str"" + sol.getCost().getCost());
    }
    changed.add(node.getMethodInfo());
  }
  return changed;
}","private Set<MethodInfo> runAnalysis(DirectedGraph<ExecutionContext,ContextEdge> reversed){
  TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(reversed);
  MethodCacheAnalysis cacheAnalysis=analyses.getMethodCacheAnalysis();
  Set<MethodInfo> changed=new HashSet<MethodInfo>();
  while (topOrder.hasNext()) {
    ExecutionContext node=topOrder.next();
    RecursiveWcetAnalysis<AnalysisContextLocal>.LocalWCETSolution sol=recursiveAnalysis.computeSolution(node.getMethodInfo(),cacheAnalysis.getAnalysisContext(node.getCallString()));
    wcaNodeFlow.put(node,sol.getNodeFlowVirtual());
    if (node.getMethodInfo().equals(wcetTool.getTargetMethod())) {
      logger.info(""String_Node_Str"" + sol.getCost().getCost());
    }
    changed.add(node.getMethodInfo());
  }
  return changed;
}",0.9959040374488004
186658,"/** 
 * @param modification the modifications which will be done
 * @return the number of cache miss cycles due to the code size change
 */
public long getDeltaCacheMissCosts(CodeModification modification){
  int deltaBytes=modification.getDeltaLocalCodesize();
  MethodInfo method=modification.getMethod();
  if (deltaBytes == 0)   return 0;
  if (analysisType == AnalysisType.ALWAYS_HIT)   return 0;
  WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
  int size=getMethodSize(method);
  int oldWords=MiscUtils.bytesToWords(size);
  int newWords=MiscUtils.bytesToWords(size + deltaBytes);
  int deltaBlocks=cache.requiredNumberOfBlocks(newWords) - cache.requiredNumberOfBlocks(oldWords);
  int newBlocks=getRequiredBlocks(method) + deltaBlocks;
  long costs=0;
  if (analysisType == AnalysisType.ALWAYS_MISS || !cache.allFit(newBlocks)) {
    long oldCycles=pm.getMethodCacheMissPenalty(oldWords,true);
    long newCycles=pm.getMethodCacheMissPenalty(newWords,true);
    costs=analyses.getExecCountAnalysis().getExecCount(method) * (newCycles - oldCycles);
    oldCycles=pm.getMethodCacheMissPenalty(oldWords,false);
    newCycles=pm.getMethodCacheMissPenalty(newWords,false);
    for (    InvokeSite invokeSite : method.getCode().getInvokeSites()) {
      costs+=analyses.getExecCountAnalysis().getExecCount(invokeSite) * (newCycles - oldCycles);
    }
  }
  if (analysisType == AnalysisType.ALWAYS_MISS) {
    return costs;
  }
  Set<ExecutionContext> changes=findClassificationChanges(method,deltaBytes,modification.getRemovedInvokees(),false);
  long deltaCosts=0;
  for (  ExecutionContext node : changes) {
    for (    InvokeSite invokeSite : node.getMethodInfo().getCode().getInvokeSites()) {
      int sizeWords=0;
      for (      MethodInfo invokee : callGraph.findImplementations(node.getCallString().push(invokeSite))) {
        sizeWords=Math.max(sizeWords,invokee.getCode().getNumberOfWords());
      }
      long count=analyses.getExecCountAnalysis().getExecCount(node,invokeSite.getInstructionHandle());
      deltaCosts+=count * pm.getMethodCacheMissPenalty(sizeWords,true);
      deltaCosts+=count * pm.getMethodCacheMissPenalty(oldWords,false);
    }
  }
  if (deltaBytes > 0) {
    costs+=deltaCosts;
  }
 else {
    costs-=deltaCosts;
  }
  if (analysisType == AnalysisType.ALL_FIT_REGIONS) {
  }
  return costs;
}","/** 
 * @param modification the modifications which will be done
 * @return the number of cache miss cycles due to the code size change
 */
public long getDeltaCacheMissCosts(CodeModification modification){
  int deltaBytes=modification.getDeltaLocalCodesize();
  MethodInfo method=modification.getMethod();
  if (deltaBytes == 0)   return 0;
  if (analysisType == AnalysisType.ALWAYS_HIT)   return 0;
  WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
  int size=getMethodSize(method);
  int oldWords=MiscUtils.bytesToWords(size);
  int newWords=MiscUtils.bytesToWords(size + deltaBytes);
  int deltaBlocks=cache.requiredNumberOfBlocks(newWords) - cache.requiredNumberOfBlocks(oldWords);
  int newBlocks=getRequiredBlocks(method) + deltaBlocks;
  long costs=0;
  if (analysisType == AnalysisType.ALWAYS_MISS || !cache.allFit(newBlocks)) {
    long oldCycles=pm.getMethodCacheMissPenalty(oldWords,true);
    long newCycles=pm.getMethodCacheMissPenalty(newWords,true);
    costs=analyses.getExecCountAnalysis().getExecCount(method) * (newCycles - oldCycles);
    oldCycles=pm.getMethodCacheMissPenalty(oldWords,false);
    newCycles=pm.getMethodCacheMissPenalty(newWords,false);
    int startPos=modification.getStart().getPosition();
    int endPos=modification.getEnd().getPosition();
    for (    InvokeSite invokeSite : method.getCode().getInvokeSites()) {
      int pos=invokeSite.getInstructionHandle().getPosition();
      if (pos >= startPos && pos <= endPos)       continue;
      costs+=analyses.getExecCountAnalysis().getExecCount(invokeSite) * (newCycles - oldCycles);
    }
  }
  if (analysisType == AnalysisType.ALWAYS_MISS) {
    return costs;
  }
  Set<ExecutionContext> changes=findClassificationChanges(method,deltaBytes,modification.getRemovedInvokees(),false);
  AppInfo appInfo=AppInfo.getSingleton();
  long deltaCosts=0;
  for (  ExecutionContext node : changes) {
    for (    InvokeSite invokeSite : node.getMethodInfo().getCode().getInvokeSites()) {
      int sizeWords=0;
      for (      MethodInfo invokee : appInfo.findImplementations(node.getCallString().push(invokeSite))) {
        sizeWords=Math.max(sizeWords,invokee.getCode().getNumberOfWords());
      }
      long count=analyses.getExecCountAnalysis().getExecCount(node,invokeSite.getInstructionHandle());
      deltaCosts+=count * pm.getMethodCacheMissPenalty(sizeWords,true);
      deltaCosts+=count * pm.getMethodCacheMissPenalty(oldWords,false);
    }
  }
  if (deltaBytes > 0) {
    costs+=deltaCosts;
  }
 else {
    costs-=deltaCosts;
  }
  if (analysisType == AnalysisType.ALL_FIT_REGIONS) {
  }
  return costs;
}",0.942026078234704
186659,"public long getTotalInvokeReturnMissCosts(CallString callString){
  if (analysisType == AnalysisType.ALWAYS_HIT)   return 0;
  int size=0;
  for (  MethodInfo method : callGraph.findImplementations(callString)) {
    size=Math.max(size,method.getCode().getNumberOfWords());
  }
  WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
  int sizeInvoker=callString.top().getInvoker().getCode().getNumberOfWords();
  return getInvokeMissCount(callString) * pm.getMethodCacheMissPenalty(size,true) - getReturnMissCount(callString) * pm.getMethodCacheMissPenalty(sizeInvoker,false);
}","public long getTotalInvokeReturnMissCosts(CallString callString){
  if (analysisType == AnalysisType.ALWAYS_HIT)   return 0;
  AppInfo appInfo=AppInfo.getSingleton();
  int size=0;
  for (  MethodInfo method : appInfo.findImplementations(callString)) {
    size=Math.max(size,method.getCode().getNumberOfWords());
  }
  WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
  int sizeInvoker=callString.top().getInvoker().getCode().getNumberOfWords();
  return getInvokeMissCount(callString) * pm.getMethodCacheMissPenalty(size,true) - getReturnMissCount(callString) * pm.getMethodCacheMissPenalty(sizeInvoker,false);
}",0.9527687296416938
186660,"/** 
 * @return the first instruction in the instruction list which will be modified. After optimization this needsto refer to the first modified or new instruction.
 */
public InstructionHandle getStart(){
  return start;
}","public InstructionHandle getStart(){
  return start;
}",0.3884892086330935
186661,"/** 
 * @return the last instruction in the instruction list which will be modified. After optimization this needsto refer to the last modified or new instruction.
 */
public InstructionHandle getEnd(){
  return end;
}","public InstructionHandle getEnd(){
  return end;
}",0.373134328358209
186662,"private long calcLocalGain(AnalysisManager analyses){
  long gain=jcopter.getWCETProcessorModel().getExecutionTime(context,invokeSite.getInstructionHandle());
  if (!preciseCycleEstimate) {
    gain-=invokee.getArgumentTypes().length * storeCycles;
    if (!invokee.isStatic())     gain-=storeCycles;
    if (needsNPCheck)     gain-=checkNPCycles;
  }
 else {
  }
  return gain;
}","private long calcLocalGain(AnalysisManager analyses){
  long gain=jcopter.getWCETProcessorModel().getExecutionTime(context,invokeSite.getInstructionHandle());
  if (!preciseCycleEstimate) {
    gain-=invokee.getArgumentTypes().length * storeCycles;
    if (!invokee.isStatic())     gain-=storeCycles;
    if (needsNPCheck)     gain-=checkNPCycles;
    gain+=deltaReturnCycles;
  }
 else {
    throw new AppInfoError(""String_Node_Str"");
  }
  return gain;
}",0.9090909090909092
186663,"@Override public boolean recalculate(AnalysisManager analyses,StacksizeAnalysis stacksize){
  deltaLocals=invokee.getCode().getMaxLocals();
  if (!checkStackAndLocals(stacksize)) {
    return false;
  }
  deltaCodesize=calcDeltaCodesize(analyses);
  isLastLocalInvoke=checkIsLastLocalInvoke();
  isLastInvoke=isLastLocalInvoke && checkIsLastInvoker();
  localGain=calcLocalGain(analyses);
  deltaCacheMiss=-analyses.getMethodCacheAnalysis().getInvokeReturnMissCosts(invokeSite,invokee);
  return true;
}","@Override public boolean recalculate(AnalysisManager analyses,StacksizeAnalysis stacksize){
  deltaLocals=invokee.getCode().getMaxLocals();
  if (!checkStackAndLocals(stacksize)) {
    return false;
  }
  deltaCodesize=calcDeltaCodesize(analyses);
  isLastLocalInvoke=checkIsLastLocalInvoke();
  isLastInvoke=isLastLocalInvoke && checkIsLastInvoker();
  localGain=calcLocalGain(analyses);
  deltaCacheMiss=calcDeltaCacheMissCosts(analyses);
  return true;
}",0.86875
186664,"public boolean doExcludeInvokee(MethodInfo invokee){
  String className=invokee.getClassName();
  for (  MethodInfo target : jcopter.getJConfig().getWCATargets()) {
    if (target.equals(invokee)) {
      return false;
    }
  }
  for (  String prefix : ignorePrefix) {
    if (className.startsWith(prefix + ""String_Node_Str"") || className.equals(prefix) || prefix.equals(className + ""String_Node_Str"" + invokee.getShortName())|| prefix.equals(className + ""String_Node_Str"" + invokee.getShortName())) {
      return true;
    }
  }
  return false;
}","public boolean doExcludeInvokee(MethodInfo invokee){
  String className=invokee.getClassName();
  for (  MethodInfo target : jcopter.getJConfig().getWCATargets()) {
    if (target.equals(invokee)) {
      return true;
    }
  }
  for (  String prefix : ignorePrefix) {
    if (className.startsWith(prefix + ""String_Node_Str"") || className.equals(prefix) || prefix.equals(className + ""String_Node_Str"" + invokee.getShortName())|| prefix.equals(className + ""String_Node_Str"" + invokee.getShortName())) {
      return true;
    }
  }
  return false;
}",0.9936189608021878
186665,"/** 
 * @param cs the callstring from the invoker to the invoke to inline (if recursive). Used to check DFA results.
 * @param invokee the invoked method to analyze
 * @param inlineData the map to populate with the parameters and the instructions to inline.
 * @return true if inlining is possible
 */
private boolean analyzeInvokee(CallString cs,MethodInfo invokee,InlineData inlineData){
  ValueMapAnalysis values=new ValueMapAnalysis(invokee);
  values.loadParameters();
  InstructionList il=invokee.getCode().getInstructionList(true,false);
  InstructionHandle ih=il.getStart();
  int count=0;
  while (true) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof PushInstruction || instruction instanceof NOP) {
      values.transfer(instruction);
      ih=ih.getNext();
      count++;
    }
 else {
      break;
    }
  }
  for (  ValueInfo value : values.getValueTable().getStack()) {
    inlineData.addParam(value);
  }
  inlineData.setInlineStart(count);
  boolean needsNPCheck=helper.needsNullpointerCheck(cs,invokee,false);
  boolean hasNPCheck=false;
  for (int i=0; i < 6; i++) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof InvokeInstruction) {
      if (inlineData.getInvokeSite() != null) {
        return false;
      }
      InvokeSite is=invokee.getCode().getInvokeSite(ih);
      inlineData.setInvokeSite(is);
      hasNPCheck|=!is.isInvokeStatic();
    }
 else     if (instruction instanceof FieldInstruction) {
      if (instruction instanceof GETFIELD) {
        hasNPCheck|=values.getValueTable().top(1).isThisReference();
      }
      if (instruction instanceof PUTFIELD) {
        int down=values.getValueTable().top().isContinued() ? 2 : 1;
        hasNPCheck|=values.getValueTable().top(down).isThisReference();
      }
    }
 else     if (instruction instanceof ArithmeticInstruction || instruction instanceof ConversionInstruction || instruction instanceof StackInstruction|| instruction instanceof LDC|| instruction instanceof LDC2_W|| instruction instanceof ARRAYLENGTH|| instruction instanceof NOP) {
    }
 else     if (instruction instanceof ReturnInstruction) {
      if (needsNPCheck && !hasNPCheck) {
        this.requiresNPCheck++;
        if (logger.isTraceEnabled()) {
          logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str"");
        }
        return false;
      }
      if (instruction instanceof RETURN) {
        while (values.getValueTable().getStackSize() > 0) {
          Instruction pop;
          if (values.getValueTable().top().isContinued()) {
            pop=new POP2();
          }
 else {
            pop=new POP();
          }
          inlineData.addEpilogue(pop);
          values.transfer(pop);
        }
        return true;
      }
 else {
        Type type=((ReturnInstruction)instruction).getType();
        return values.getValueTable().getStackSize() == type.getSize();
      }
    }
 else {
      unhandledInstructions++;
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str""+ instruction.toString(invokee.getClassInfo().getConstantPoolGen().getConstantPool()));
      }
      return false;
    }
    values.transfer(instruction);
    ih=ih.getNext();
  }
  return false;
}","/** 
 * @param cs the callstring from the invoker to the invoke to inline (if recursive). Used to check DFA results.
 * @param invokee the invoked method to analyze
 * @param inlineData the map to populate with the parameters and the instructions to inline.
 * @return true if inlining is possible
 */
private boolean analyzeInvokee(CallString cs,MethodInfo invokee,InlineData inlineData){
  ValueMapAnalysis values=new ValueMapAnalysis(invokee);
  values.loadParameters();
  InstructionList il=invokee.getCode().getInstructionList(true,false);
  InstructionHandle ih=il.getStart();
  int count=0;
  while (true) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof PushInstruction || instruction instanceof NOP) {
      values.transfer(instruction);
      ih=ih.getNext();
      count++;
    }
 else {
      break;
    }
  }
  for (  ValueInfo value : values.getValueTable().getStack()) {
    inlineData.addParam(value);
  }
  inlineData.setInlineStart(count);
  boolean needsNPCheck=helper.needsNullpointerCheck(cs,invokee,false);
  boolean hasNPCheck=false;
  for (int i=0; i < 6; i++) {
    Instruction instruction=ih.getInstruction();
    if (instruction instanceof InvokeInstruction) {
      if (inlineData.getInvokeSite() != null) {
        return false;
      }
      InvokeSite is=invokee.getCode().getInvokeSite(ih);
      inlineData.setInvokeSite(is);
      hasNPCheck|=!is.isInvokeStatic();
    }
 else     if (instruction instanceof FieldInstruction) {
      if (instruction instanceof GETFIELD) {
        hasNPCheck|=values.getValueTable().top(1).isThisReference();
      }
      if (instruction instanceof PUTFIELD) {
        int down=values.getValueTable().top().isContinued() ? 2 : 1;
        hasNPCheck|=values.getValueTable().top(down).isThisReference();
      }
    }
 else     if (instruction instanceof ArithmeticInstruction || instruction instanceof ConversionInstruction || instruction instanceof StackInstruction|| instruction instanceof LDC|| instruction instanceof LDC2_W|| instruction instanceof ARRAYLENGTH|| instruction instanceof CHECKCAST|| instruction instanceof NOP) {
    }
 else     if (instruction instanceof ReturnInstruction) {
      if (needsNPCheck && !hasNPCheck) {
        this.requiresNPCheck++;
        if (logger.isTraceEnabled()) {
          logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str"");
        }
        return false;
      }
      if (instruction instanceof RETURN) {
        while (values.getValueTable().getStackSize() > 0) {
          Instruction pop;
          if (values.getValueTable().top().isContinued()) {
            pop=new POP2();
          }
 else {
            pop=new POP();
          }
          inlineData.addEpilogue(pop);
          values.transfer(pop);
        }
        return true;
      }
 else {
        Type type=((ReturnInstruction)instruction).getType();
        return values.getValueTable().getStackSize() == type.getSize();
      }
    }
 else {
      unhandledInstructions++;
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + invokee + ""String_Node_Str""+ instruction.toString(invokee.getClassInfo().getConstantPoolGen().getConstantPool()));
      }
      return false;
    }
    values.transfer(instruction);
    ih=ih.getNext();
  }
  return false;
}",0.9946784248137448
186666,"/** 
 * Check if the invokesite can be modified in a way so that the parameters are passed in the correct order
 * @param invokeSite the invokesite to inline.
 * @param invokee the invoked method.
 * @param inlineData the map to store the analyzer results
 * @return true if the prologue can be changed to match the expected behaviour
 */
private boolean analyzeInvokeSite(InvokeSite invokeSite,MethodInfo invokee,InlineData inlineData){
  MethodInfo invoker=invokeSite.getInvoker();
  ConstantPoolGen invokerCpg=invoker.getConstantPoolGen();
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  Type[] ret=StackHelper.produceStack(invokerCpg,invoke.getInstruction());
  boolean match=(ret.length == 1 && TypeHelper.canAssign(invokee.getType(),ret[0]));
  if (!match && !invokee.getType().equals(Type.VOID)) {
    return false;
  }
  Type[] args=StackHelper.consumeStack(invokerCpg,invoke.getInstruction());
  List<Instruction> oldPrologue=new LinkedList<Instruction>();
  int cnt=0;
  InstructionHandle current=invoke;
  while (cnt < args.length) {
    if (current.hasTargeters()) {
      break;
    }
    current=current.getPrev();
    Instruction instr=current.getInstruction();
    if (!(instr instanceof PushInstruction) || (instr instanceof DUP) || (instr instanceof DUP2)) {
      break;
    }
    cnt++;
    oldPrologue.add(0,instr);
  }
  inlineData.setOldPrologueLength(cnt);
  List<ValueInfo> params=inlineData.getParams();
  int offset=args.length - cnt;
  for (int i=0; i < offset; i++) {
    if (i >= params.size()) {
      Type t=args[i];
      inlineData.addPrologue(t.getSize() == 2 ? new POP2() : new POP());
    }
 else {
      ValueInfo value=params.get(i);
      int argNum=value.getParamNr();
      if (!invokee.isStatic()) {
        argNum++;
      }
      if (argNum != i) {
        return false;
      }
    }
  }
  for (int i=offset; i < params.size(); i++) {
    ValueInfo value=params.get(i);
    if (value.isThisReference() || value.isParamReference()) {
      int argNum=value.getParamNr();
      if (!invokee.isStatic()) {
        argNum++;
      }
      if (argNum < offset) {
        return false;
      }
      Instruction instr=oldPrologue.get(argNum - offset).copy();
      inlineData.addPrologue(instr);
    }
 else     if (value.isConstantValue() || value.isStaticFieldReference()) {
      Instruction instr=value.getConstantValue().createPushInstruction(invoker.getConstantPoolGen());
      inlineData.addPrologue(instr);
    }
 else     if (!value.isContinued()) {
      throw new AssertionError(""String_Node_Str"");
    }
  }
  return true;
}","/** 
 * Check if the invokesite can be modified in a way so that the parameters are passed in the correct order
 * @param invokeSite the invokesite to inline.
 * @param invokee the invoked method.
 * @param inlineData the map to store the analyzer results
 * @return true if the prologue can be changed to match the expected behaviour
 */
private boolean analyzeInvokeSite(InvokeSite invokeSite,MethodInfo invokee,InlineData inlineData){
  MethodInfo invoker=invokeSite.getInvoker();
  ConstantPoolGen invokerCpg=invoker.getConstantPoolGen();
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  Type[] ret=StackHelper.produceStack(invokerCpg,invoke.getInstruction());
  boolean match=(ret.length == 1 && TypeHelper.canAssign(invokee.getType(),ret[0]));
  if (!match && !invokee.getType().equals(Type.VOID)) {
    return false;
  }
  Type[] args=StackHelper.consumeStack(invokerCpg,invoke.getInstruction());
  List<Instruction> oldPrologue=new LinkedList<Instruction>();
  int cnt=0;
  InstructionHandle current=invoke;
  while (cnt < args.length) {
    if (current.hasTargeters()) {
      break;
    }
    current=current.getPrev();
    Instruction instr=current.getInstruction();
    if (!(instr instanceof PushInstruction) || (instr instanceof DUP) || (instr instanceof DUP2)) {
      break;
    }
    cnt++;
    oldPrologue.add(0,instr);
  }
  inlineData.setOldPrologueLength(cnt);
  List<ValueInfo> params=inlineData.getParams();
  int offset=args.length - cnt;
  for (int i=0; i < offset; i++) {
    if (i >= params.size()) {
      Type t=args[i];
      inlineData.addPrologue(t.getSize() == 2 ? new POP2() : new POP());
    }
 else {
      ValueInfo value=params.get(i);
      int argNum=value.getParamNr();
      if (!invokee.isStatic()) {
        argNum++;
      }
      if (argNum != i) {
        return false;
      }
    }
  }
  for (int i=offset; i < params.size(); i++) {
    ValueInfo value=params.get(i);
    if (value.isThisReference() || value.isParamReference()) {
      int argNum=value.getParamNr();
      if (!invokee.isStatic()) {
        argNum++;
      }
      if (argNum < offset) {
        return false;
      }
      Instruction instr=oldPrologue.get(argNum - offset).copy();
      inlineData.addPrologue(instr);
    }
 else     if (value.isNullReference()) {
      inlineData.addPrologue(InstructionConstants.ACONST_NULL);
    }
 else     if (value.isConstantValue() || value.isStaticFieldReference()) {
      Instruction instr=value.getConstantValue().createPushInstruction(invoker.getConstantPoolGen());
      inlineData.addPrologue(instr);
    }
 else     if (!value.isContinued()) {
      throw new AssertionError(""String_Node_Str"");
    }
  }
  return true;
}",0.9790447423069664
186667,"/** 
 * Remove all unused classes, methods and fields.
 */
private void removeUnusedMembers(){
  AppInfo appInfo=AppInfo.getSingleton();
  List<ClassInfo> unusedClasses=new LinkedList<ClassInfo>();
  List<FieldInfo> unusedFields=new LinkedList<FieldInfo>();
  List<MethodInfo> unusedMethods=new LinkedList<MethodInfo>();
  int fields=0;
  int methods=0;
  for (  ClassInfo cls : appInfo.getClassInfos()) {
    if (ucf.getMark(cls) == Mark.UNUSED) {
      unusedClasses.add(cls);
      logger.debug(""String_Node_Str"" + cls);
      continue;
    }
    unusedFields.clear();
    unusedMethods.clear();
    if (appInfo.isHwObject(cls)) {
      logger.debug(""String_Node_Str"" + cls);
    }
 else {
      for (      FieldInfo f : cls.getFields()) {
        if (ucf.getMark(f) == Mark.UNUSED) {
          unusedFields.add(f);
        }
      }
    }
    for (    MethodInfo m : cls.getMethods()) {
      Mark mark=ucf.getMark(m);
      if (mark == Mark.UNUSED) {
        unusedMethods.add(m);
      }
      if (mark == Mark.MARKED && !m.isNative() && !m.isAbstract()) {
        logger.info(""String_Node_Str"" + m + ""String_Node_Str"");
        m.setAbstract(true);
      }
    }
    for (    FieldInfo f : unusedFields) {
      fields+=removeField(f);
    }
    for (    MethodInfo m : unusedMethods) {
      methods+=removeMethod(m);
    }
  }
  appInfo.removeClasses(unusedClasses);
  int classes=unusedClasses.size();
  logger.info(""String_Node_Str"" + classes + (classes == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ fields+ (fields == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ methods+ (methods == 1 ? ""String_Node_Str"" : ""String_Node_Str""));
}","/** 
 * Remove all unused classes, methods and fields.
 */
private void removeUnusedMembers(){
  AppInfo appInfo=AppInfo.getSingleton();
  List<ClassInfo> unusedClasses=new LinkedList<ClassInfo>();
  List<FieldInfo> unusedFields=new LinkedList<FieldInfo>();
  List<MethodInfo> unusedMethods=new LinkedList<MethodInfo>();
  int fields=0;
  int methods=0;
  for (  ClassInfo cls : appInfo.getClassInfos()) {
    if (ucf.getMark(cls) == Mark.UNUSED) {
      unusedClasses.add(cls);
      logger.debug(""String_Node_Str"" + cls);
      continue;
    }
    unusedFields.clear();
    unusedMethods.clear();
    if (appInfo.isHwObject(cls)) {
      logger.debug(""String_Node_Str"" + cls);
    }
 else {
      for (      FieldInfo f : cls.getFields()) {
        if (ucf.getMark(f) == Mark.UNUSED) {
          unusedFields.add(f);
        }
      }
    }
    for (    MethodInfo m : cls.getMethods()) {
      Mark mark=ucf.getMark(m);
      if (mark == Mark.UNUSED) {
        unusedMethods.add(m);
      }
      if (mark == Mark.MARKED && !m.isNative() && !m.isAbstract()) {
        logger.info(""String_Node_Str"" + m + ""String_Node_Str"");
        m.setAbstract(true);
        m.getClassInfo().setAbstract(true);
      }
    }
    for (    FieldInfo f : unusedFields) {
      fields+=removeField(f);
    }
    for (    MethodInfo m : unusedMethods) {
      methods+=removeMethod(m);
    }
  }
  appInfo.removeClasses(unusedClasses);
  int classes=unusedClasses.size();
  logger.info(""String_Node_Str"" + classes + (classes == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ fields+ (fields == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ methods+ (methods == 1 ? ""String_Node_Str"" : ""String_Node_Str""));
}",0.986778846153846
186668,"public boolean removeNode(ExecutionContext context,boolean removeUnreachable){
  if (removeUnreachable) {
    for (    ContextEdge e : callGraph.outgoingEdgesOf(context)) {
      removeEdge(e,removeUnreachable);
    }
  }
  return callGraph.removeVertex(context);
}","public boolean removeNode(ExecutionContext context,boolean removeUnreachable){
  if (removeUnreachable) {
    List<ContextEdge> remove=new ArrayList<ContextEdge>(callGraph.outgoingEdgesOf(context));
    for (    ContextEdge e : remove) {
      removeEdge(e,removeUnreachable);
    }
  }
  return callGraph.removeVertex(context);
}",0.8436974789915966
186669,"private void interpret(InstructionList il,Map<InstructionHandle,T> start,boolean initialize){
  if (initialize) {
    InstructionHandle ih=il.getStart();
    while (ih != null) {
      results.put(ih,analysis.bottom());
      ih=ih.getNext();
    }
    results.putAll(start);
  }
  LinkedList<Edge> worklist=new LinkedList<Edge>();
  for (  InstructionHandle ih : start.keySet()) {
    worklist.addAll(getOutEdges(ih));
  }
  while (!worklist.isEmpty()) {
    Edge edge=worklist.removeFirst();
    InstructionHandle tail=edge.getTail();
    InstructionHandle head=edge.getHead();
    T tailValue=results.get(tail);
    T headValue=results.get(head);
    T transferred=analysis.transfer(tailValue,edge);
    if (!analysis.compare(transferred,headValue)) {
      T newValue=analysis.join(transferred,headValue);
      results.put(head,newValue);
      if (edge.getType() == EdgeType.EXIT_EDGE) {
        continue;
      }
      List<Edge> outEdges=getOutEdges(head);
      for (      Edge outEdge : outEdges) {
        if (worklist.contains(outEdge)) {
          continue;
        }
        if (outEdges.size() > 1) {
          worklist.addLast(outEdge);
        }
 else {
          worklist.addFirst(outEdge);
        }
      }
    }
  }
}","private void interpret(InstructionList il,Map<InstructionHandle,T> start,boolean initialize){
  if (initialize) {
    InstructionHandle ih=il.getStart();
    while (ih != null) {
      results.put(ih,analysis.bottom());
      ih=ih.getNext();
    }
    results.putAll(start);
  }
 else {
    for (InstructionHandle ih=il.getStart(); ih != null; ih=ih.getNext()) {
      if (results.containsKey(ih))       continue;
      if (ih.getPrev() == null && !ih.hasTargeters()) {
        results.put(ih,analysis.initial(ih));
      }
 else {
        results.put(ih,analysis.bottom());
        if (ih.hasTargeters()) {
          for (          InstructionTargeter targeter : ih.getTargeters()) {
            if (targeter instanceof CodeExceptionGen) {
              results.put(ih,analysis.initial((CodeExceptionGen)targeter));
              break;
            }
          }
        }
      }
    }
  }
  LinkedList<Edge> worklist=new LinkedList<Edge>();
  for (  InstructionHandle ih : start.keySet()) {
    if (initialize) {
      worklist.addAll(getOutEdges(ih));
    }
 else     if (ih.getPrev() == null && !ih.hasTargeters()) {
      worklist.addAll(getOutEdges(ih));
    }
 else {
      worklist.addAll(getInEdges(il,ih));
    }
  }
  while (!worklist.isEmpty()) {
    Edge edge=worklist.removeFirst();
    InstructionHandle tail=edge.getTail();
    InstructionHandle head=edge.getHead();
    T tailValue=results.get(tail);
    T headValue=results.get(head);
    T transferred=analysis.transfer(tailValue,edge);
    if (!analysis.compare(transferred,headValue)) {
      T newValue=analysis.join(transferred,headValue);
      results.put(head,newValue);
      if (edge.getType() == EdgeType.EXIT_EDGE) {
        continue;
      }
      List<Edge> outEdges=getOutEdges(head);
      for (      Edge outEdge : outEdges) {
        if (worklist.contains(outEdge)) {
          continue;
        }
        if (outEdges.size() > 1) {
          worklist.addLast(outEdge);
        }
 else {
          worklist.addFirst(outEdge);
        }
      }
    }
  }
}",0.7546479731789089
186670,"private InstructionHandle copyInstruction(MethodCode invokeeCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=instr.copy();
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
    if (ih == null) {
      return null;
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}","private InstructionHandle copyInstruction(MethodCode invokeeCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=instr.copy();
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}",0.8922742110990207
186671,"private void remapTargets(Map<InstructionHandle,InstructionHandle> instrMap,InstructionHandle last,InstructionHandle oldLast){
  InstructionHandle src=oldLast;
  InstructionHandle ih=last;
  while (src != null) {
    Instruction i=src.getInstruction();
    Instruction c=ih.getInstruction();
    if (i instanceof BranchInstruction) {
      BranchInstruction bi=(BranchInstruction)i;
      BranchInstruction bc=(BranchInstruction)c;
      InstructionHandle target=bi.getTarget();
      if (bi instanceof Select) {
        InstructionHandle[] targets=((Select)bi).getTargets();
        for (int j=0; j < targets.length; j++) {
          ((Select)bc).setTarget(j,instrMap.get(targets[j]));
        }
      }
      bc.setTarget(instrMap.get(target));
    }
    src=src.getPrev();
    ih=ih.getPrev();
  }
}","private void remapTargets(Map<InstructionHandle,InstructionHandle> instrMap,InstructionHandle next){
  for (  Map.Entry<InstructionHandle,InstructionHandle> e : instrMap.entrySet()) {
    InstructionHandle oldIh=e.getKey();
    InstructionHandle newIh=e.getValue();
    Instruction i=oldIh.getInstruction();
    Instruction c=newIh.getInstruction();
    if (c instanceof BranchInstruction) {
      BranchInstruction bi=(BranchInstruction)i;
      BranchInstruction bc=(BranchInstruction)c;
      InstructionHandle target=bi.getTarget();
      if (bi instanceof Select) {
        InstructionHandle[] targets=((Select)bi).getTargets();
        for (int j=0; j < targets.length; j++) {
          InstructionHandle newTarget=instrMap.get(targets[j]);
          ((Select)bc).setTarget(j,newTarget != null ? newTarget : next);
        }
      }
      InstructionHandle newTarget=instrMap.get(target);
      bc.setTarget(newTarget != null ? newTarget : next);
    }
  }
}",0.6342015855039638
186672,"private Map<InvokeSite,InvokeSite> insertInvokee(AnalysisManager analyses,CallString callString,InstructionList il,InstructionHandle next){
  MethodCode code=getMethod().getCode();
  MethodCode invokeeCode=invokee.getCode();
  InstructionList iList=invokeeCode.getInstructionList(true,false);
  Map<InstructionHandle,InstructionHandle> instrMap=new HashMap<InstructionHandle,InstructionHandle>();
  Map<InvokeSite,InvokeSite> invokeMap=new HashMap<InvokeSite,InvokeSite>();
  StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(invokee);
  for (InstructionHandle src=iList.getStart(); src != null; src=src.getNext()) {
    InstructionHandle ih=copyInstruction(invokeeCode,stacksize,il,src,next);
    if (ih == null)     continue;
    code.copyCustomValues(invokee,ih,src);
    if (code.isInvokeSite(ih)) {
      InvokeSite newInvoke=code.getInvokeSite(ih);
      InvokeSite oldInvoke=invokeeCode.getInvokeSite(src);
      invokeMap.put(oldInvoke,newInvoke);
      setInlineCallString(code,ih,callString);
    }
    instrMap.put(src,ih);
  }
  remapTargets(instrMap,next.getPrev(),iList.getEnd());
  return invokeMap;
}","private Map<InvokeSite,InvokeSite> insertInvokee(AnalysisManager analyses,CallString callString,InstructionList il,InstructionHandle next){
  MethodCode code=getMethod().getCode();
  MethodCode invokeeCode=invokee.getCode();
  InstructionList iList=invokeeCode.getInstructionList(true,false);
  Map<InstructionHandle,InstructionHandle> instrMap=new HashMap<InstructionHandle,InstructionHandle>();
  Map<InvokeSite,InvokeSite> invokeMap=new HashMap<InvokeSite,InvokeSite>();
  StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(invokee);
  for (InstructionHandle src=iList.getStart(); src != null; src=src.getNext()) {
    InstructionHandle ih=copyInstruction(invokeeCode,stacksize,il,src,next);
    if (ih == null)     continue;
    code.copyCustomValues(invokee,ih,src);
    if (code.isInvokeSite(ih)) {
      InvokeSite newInvoke=code.getInvokeSite(ih);
      InvokeSite oldInvoke=invokeeCode.getInvokeSite(src);
      invokeMap.put(oldInvoke,newInvoke);
      setInlineCallString(code,ih,callString);
    }
    instrMap.put(src,ih);
  }
  remapTargets(instrMap,next);
  return invokeMap;
}",0.9887539361223572
186673,"@Override public void sortCandidates(Set<MethodInfo> changedMethods){
  for (  MethodInfo method : changedMethods) {
    MethodData data=methodData.get(method);
    queue.removeAll(data.getRatios());
    data.getRatios().clear();
    Collection<RebateRatio> ratios=calculateRatios(method,data.getCandidates());
    data.getRatios().addAll(ratios);
    queue.addAll(ratios);
  }
}","@Override public void sortCandidates(Set<MethodInfo> changedMethods){
  for (  MethodInfo method : changedMethods) {
    MethodData data=methodData.get(method);
    if (data == null)     continue;
    queue.removeAll(data.getRatios());
    data.getRatios().clear();
    Collection<RebateRatio> ratios=calculateRatios(method,data.getCandidates());
    data.getRatios().addAll(ratios);
    queue.addAll(ratios);
  }
}",0.9546599496221664
186674,"private void createFlowGraph(MethodInfo method){
  logger.debug(""String_Node_Str"" + method);
  Map<Integer,BasicBlockNode> nodeTable=new HashMap<Integer,BasicBlockNode>();
  graph=new DefaultFlowGraph<CFGNode,CFGEdge>(CFGEdge.class,new DedicatedNode(DedicatedNodeName.ENTRY),new DedicatedNode(DedicatedNodeName.EXIT));
  blocks=new ArrayList<BasicBlock>();
  int i=0;
  for (  BasicBlock bb : BasicBlock.buildBasicBlocks(method.getCode())) {
    BasicBlockNode n=addBasicBlock(i++,bb);
    nodeTable.put(bb.getFirstInstruction().getPosition(),n);
  }
  graph.addEdge(graph.getEntry(),nodeTable.get(blocks.get(0).getFirstInstruction().getPosition()),entryEdge());
  hasThrowEdges=false;
  for (  BasicBlockNode bbNode : nodeTable.values()) {
    BasicBlock bb=bbNode.getBasicBlock();
    FlowInfo bbf=bb.getExitFlowInfo();
    if (bbf.isExit()) {
      if (bbNode.getBasicBlock().getLastInstruction().getInstruction().getOpcode() == Constants.ATHROW) {
        logger.warn(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
        hasThrowEdges=true;
      }
 else {
        graph.addEdge(bbNode,graph.getExit(),exitEdge());
      }
    }
 else     if (!bbf.isAlwaysTaken()) {
      BasicBlockNode bbSucc=nodeTable.get(bbNode.getBasicBlock().getLastInstruction().getNext().getPosition());
      if (bbSucc == null) {
        internalError(""String_Node_Str"" + bbNode.getBasicBlock().getLastInstruction());
      }
      graph.addEdge(bbNode,bbSucc,new CFGEdge(EdgeKind.NEXT_EDGE));
    }
    for (    FlowTarget target : bbf.getTargets()) {
      BasicBlockNode targetNode=nodeTable.get(target.getTarget().getPosition());
      if (targetNode == null)       internalError(""String_Node_Str"" + bbNode + ""String_Node_Str""+ target);
      graph.addEdge(bbNode,targetNode,new CFGEdge(target.getEdgeKind()));
    }
  }
  this.graph.addEdge(graph.getEntry(),graph.getExit(),exitEdge());
}","private void createFlowGraph(MethodInfo method){
  logger.debug(""String_Node_Str"" + method);
  Map<Integer,BasicBlockNode> nodeTable=new HashMap<Integer,BasicBlockNode>();
  graph=new DefaultFlowGraph<CFGNode,CFGEdge>(CFGEdge.class,new DedicatedNode(DedicatedNodeName.ENTRY),new DedicatedNode(DedicatedNodeName.EXIT));
  blocks=new ArrayList<BasicBlock>();
  int i=0;
  for (  BasicBlock bb : BasicBlock.buildBasicBlocks(method.getCode())) {
    BasicBlockNode n=addBasicBlock(i++,bb);
    nodeTable.put(bb.getFirstInstruction().getPosition(),n);
  }
  graph.addEdge(graph.getEntry(),nodeTable.get(blocks.get(0).getFirstInstruction().getPosition()),entryEdge());
  hasThrowEdges=false;
  for (  BasicBlockNode bbNode : nodeTable.values()) {
    BasicBlock bb=bbNode.getBasicBlock();
    FlowInfo bbf=bb.getExitFlowInfo();
    if (bbf.isExit()) {
      if (bbNode.getBasicBlock().getLastInstruction().getInstruction().getOpcode() == Constants.ATHROW) {
        if (ignoreATHROW) {
          if (logger.isTraceEnabled()) {
            logger.trace(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
          }
        }
 else {
          logger.warn(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
        }
        hasThrowEdges=true;
      }
 else {
        graph.addEdge(bbNode,graph.getExit(),exitEdge());
      }
    }
 else     if (!bbf.isAlwaysTaken()) {
      BasicBlockNode bbSucc=nodeTable.get(bbNode.getBasicBlock().getLastInstruction().getNext().getPosition());
      if (bbSucc == null) {
        internalError(""String_Node_Str"" + bbNode.getBasicBlock().getLastInstruction());
      }
      graph.addEdge(bbNode,bbSucc,new CFGEdge(EdgeKind.NEXT_EDGE));
    }
    for (    FlowTarget target : bbf.getTargets()) {
      BasicBlockNode targetNode=nodeTable.get(target.getTarget().getPosition());
      if (targetNode == null)       internalError(""String_Node_Str"" + bbNode + ""String_Node_Str""+ target);
      graph.addEdge(bbNode,targetNode,new CFGEdge(target.getEdgeKind()));
    }
  }
  this.graph.addEdge(graph.getEntry(),graph.getExit(),exitEdge());
}",0.9455645161290324
186675,"public ExecutionContext(MethodInfo method){
  assert(method != null);
  this.method=method;
  this.callString=CallString.EMPTY;
}","public ExecutionContext(MethodInfo method){
  assert(method != null);
  this.method=method;
  this.callString=CallString.EMPTY;
  this.hash=callString.hashCode() * 31 + method.hashCode();
}",0.8113207547169812
186676,"@Override public int hashCode(){
  final int prime=31;
  int result=callString.hashCode();
  result=prime * result + method.hashCode();
  return result;
}","@Override public int hashCode(){
  return hash;
}",0.4532019704433497
186677,"@Override public void onSetupConfig(AppSetup setup) throws Config.BadConfigurationException {
  OptionGroup options=setup.getConfig().getOptions();
  config=new JCopterConfig(options);
}","@Override public void onSetupConfig(AppSetup setup) throws Config.BadConfigurationException {
  OptionGroup options=setup.getConfig().getOptions();
  config=new JCopterConfig(options);
  ControlFlowGraph.setIgnoreATHROW(true);
}",0.8985507246376812
186678,"/** 
 * Return a set of methods which become unreachable (w.r.t. to the complete callgraph, not to the set of methods to optimize) after the optimization has been performed, e.g. due to inlining the last callsite. <p>This is used to calculate the resulting total codesize as well as to skip unused methods from optimizations.</p> <p>Note that the resultset can increase after another optimization took place.</p>
 * @return a set of methods which can be removed after the optimization, or null or an empty set if nothing changes.
 */
public Collection<MethodInfo> getUnreachableMethods(){
  return null;
}","/** 
 * Return a set of methods which become unreachable (w.r.t. to the complete callgraph, not to the set of methods to optimize) after the optimization has been performed, e.g. due to inlining the last callsite. <p>This is used to calculate the resulting total codesize as well as to skip unused methods from optimizations.</p> <p>Note that the resultset can become larger after another optimization took place. Also note that if a method becomes unreachable in the target- or WCA-callgraph but not in the main callgraph, it is not returned here.</p>
 * @return a set of methods which can be removed after the optimization, or null or an empty set if nothing changes.
 */
public Collection<MethodInfo> getUnreachableMethods(){
  return null;
}",0.8844444444444445
186679,"private void optimizeMethods(AnalysisManager analyses,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates();
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates();
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(methods);
    }
 else {
      selector.sortCandidates(changeSet);
    }
    candidates=selector.selectNextCandidates();
  }
}","private void optimizeMethods(AnalysisManager analyses,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates();
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates();
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(methods);
    }
 else {
      logger.info(""String_Node_Str"" + changeSet.size());
      selector.sortCandidates(changeSet);
    }
    candidates=selector.selectNextCandidates();
  }
}",0.9789832944135082
186680,"@Override public void sortCandidates(Set<MethodInfo> changedMethods){
  for (  MethodInfo method : changedMethods) {
    MethodData data=methodData.get(method);
    if (data == null)     continue;
    queue.removeAll(data.getRatios());
    data.getRatios().clear();
    Collection<RebateRatio> ratios=calculateRatios(method,data.getCandidates());
    data.getRatios().addAll(ratios);
    queue.addAll(ratios);
  }
}","@Override public void sortCandidates(Set<MethodInfo> changedMethods){
  for (  MethodInfo method : changedMethods) {
    MethodData data=methodData.get(method);
    if (data == null)     continue;
    if (!analyses.getTargetCallGraph().containsMethod(method)) {
      removeCandidates(method);
      continue;
    }
    queue.removeAll(data.getRatios());
    data.getRatios().clear();
    Collection<RebateRatio> ratios=calculateRatios(method,data.getCandidates());
    data.getRatios().addAll(ratios);
    queue.addAll(ratios);
  }
}",0.8746048472075869
186681,"public void removeCandidate(Candidate candidate){
  MethodData data=methodData.remove(candidate.getMethod());
  data.getCandidates().remove(candidate);
}","public void removeCandidate(Candidate candidate){
  MethodData data=methodData.get(candidate.getMethod());
  data.getCandidates().remove(candidate);
}",0.976897689768977
186682,"@Override public boolean optimize(AnalysisManager analyses,StacksizeAnalysis stacksize){
  MethodCode code=getMethod().getCode();
  InstructionList il=code.getInstructionList();
  assert(start == end);
  InstructionHandle invoke=start;
  InstructionHandle next=end.getNext();
  insertPrologue(il,next);
  Map<InvokeSite,InvokeSite> invokeMap;
  CallString callString=getInlineCallString(code,invoke).push(invokeSite);
  invokeMap=insertInvokee(analyses,callString,il,next);
  start=invoke.getNext();
  end=next.getPrev();
  if (end == null) {
    start=null;
  }
  try {
    il.delete(invoke);
  }
 catch (  TargetLostException e) {
    code.retarget(e,start);
  }
  for (  CallGraph cg : analyses.getCallGraphs()) {
    updateCallgraph(cg,invokeMap);
  }
  updateAnalyses(analyses,invokeMap);
  return true;
}","@Override public boolean optimize(AnalysisManager analyses,StacksizeAnalysis stacksize){
  MethodCode code=getMethod().getCode();
  InstructionList il=code.getInstructionList();
  assert(start == end);
  InstructionHandle invoke=start;
  InstructionHandle next=end.getNext();
  insertPrologue(il,next);
  Map<InvokeSite,InvokeSite> invokeMap;
  CallString callString=getInlineCallString(code,invoke).push(invokeSite);
  invokeMap=insertInvokee(analyses,callString,il,next);
  start=invoke.getNext();
  end=next.getPrev();
  if (end == null) {
    start=null;
  }
  try {
    il.delete(invoke);
  }
 catch (  TargetLostException e) {
    code.retarget(e,start);
  }
  for (  CallGraph cg : analyses.getCallGraphs()) {
    updateCallgraph(cg,invokeMap);
  }
  updateAnalyses(analyses,invokeMap);
  isLastInvoke=!analyses.getAppInfoCallGraph().containsMethod(invokee);
  return true;
}",0.9574468085106383
186683,"private void updateCallgraph(CallGraph cg,Map<InvokeSite,InvokeSite> invokeMap){
  Ternary acyclic=cg.getAcyclicity();
  for (  ExecutionContext invoker : cg.getNodes(getMethod())) {
    for (    ExecutionContext invokeeNode : cg.getInvokedNodes(invoker,invokeSite,invokee)) {
      for (      ExecutionContext child : cg.getChildren(invokeeNode)) {
        ExecutionContext newInvokee;
        if (!child.getCallString().isEmpty()) {
          CallString cs=invoker.getCallString();
          cs=cs.push(invokeMap.get(child.getCallString().top()),appInfo.getCallstringLength());
          newInvokee=cg.copyNodeRecursive(child,cs,appInfo.getCallstringLength());
        }
 else {
          newInvokee=child;
        }
        cg.addEdge(invoker,newInvokee);
      }
    }
  }
  if (!cg.removeNodes(invokeSite,invokee,true)) {
    if (!searchInvokeSites()) {
      cg.removeEdges(getMethod(),invokee,true);
    }
  }
  if (acyclic != Ternary.UNKNOWN) {
    cg.setAcyclicity(acyclic == Ternary.TRUE);
  }
  isLastInvoke=cg.containsMethod(invokee);
}","private void updateCallgraph(CallGraph cg,Map<InvokeSite,InvokeSite> invokeMap){
  Ternary acyclic=cg.getAcyclicity();
  for (  ExecutionContext invoker : cg.getNodes(getMethod())) {
    for (    ExecutionContext invokeeNode : cg.getInvokedNodes(invoker,invokeSite,invokee)) {
      for (      ExecutionContext child : cg.getChildren(invokeeNode)) {
        ExecutionContext newInvokee;
        if (!child.getCallString().isEmpty()) {
          CallString cs=invoker.getCallString();
          cs=cs.push(invokeMap.get(child.getCallString().top()),appInfo.getCallstringLength());
          newInvokee=cg.copyNodeRecursive(child,cs,appInfo.getCallstringLength());
        }
 else {
          newInvokee=child;
        }
        cg.addEdge(invoker,newInvokee);
      }
    }
  }
  if (!cg.removeNodes(invokeSite,invokee,true)) {
    if (!searchInvokeSites()) {
      cg.removeEdges(getMethod(),invokee,true);
    }
  }
  if (acyclic != Ternary.UNKNOWN) {
    cg.setAcyclicity(acyclic == Ternary.TRUE);
  }
}",0.9790550414028252
186684,"/** 
 * Get the control flow graph associated with this method code or create a new one. <p> By default, changes to the returned CFG are compiled back before the InstructionList of this method is accessed. If you want a CFG where changes to it are not compiled back automatically, use   {@code new ControlFlowGraph(MethodInfo)}instead. Also if you want to construct a CFG for a specific context or with a different implementation finder, you need to construct a callgraph yourself, keep a reference to it as long as you want to keep modifications to the graph and you need ensure that changes to a graph invalidate other graphs of the same method yourself, if required. </p>
 * @param clean if true, compile and recreate the graph if {@link ControlFlowGraph#isClean()} returns false.
 * @return the CFG for this method.
 */
public ControlFlowGraph getControlFlowGraph(boolean clean){
  if (cfg != null && clean && !cfg.isClean()) {
    cfg.compile();
    cfg=null;
  }
  if (this.cfg == null) {
    try {
      cfg=new ControlFlowGraph(this.getMethodInfo());
      for (      AppEventHandler ah : AppInfo.getSingleton().getEventHandlers()) {
        ah.onCreateMethodControlFlowGraph(cfg,clean);
      }
    }
 catch (    BadGraphException e) {
      throw new BadGraphError(""String_Node_Str"" + methodInfo,e);
    }
  }
  return cfg;
}","/** 
 * Get the control flow graph associated with this method code or create a new one. <p> By default, changes to the returned CFG are compiled back before the InstructionList of this method is accessed. If you want a CFG where changes to it are not compiled back automatically, use   {@code new ControlFlowGraph(MethodInfo)}instead. Also if you want to construct a CFG for a specific context or with a different implementation finder, you need to construct a callgraph yourself, keep a reference to it as long as you want to keep modifications to the graph and you need ensure that changes to a graph invalidate other graphs of the same method yourself, if required. </p>
 * @param clean if true, compile and recreate the graph if {@link ControlFlowGraph#isClean()} returns false.
 * @return the CFG for this method.
 */
public ControlFlowGraph getControlFlowGraph(boolean clean){
  if (cfg != null && clean && !cfg.isClean()) {
    cfg.compile();
    cfg=null;
  }
  if (this.cfg == null) {
    try {
      cfg=new ControlFlowGraph(this.getMethodInfo());
      cfg.registerHandleNodes();
      for (      AppEventHandler ah : AppInfo.getSingleton().getEventHandlers()) {
        ah.onCreateMethodControlFlowGraph(cfg,clean);
      }
    }
 catch (    BadGraphException e) {
      throw new BadGraphError(""String_Node_Str"" + methodInfo,e);
    }
  }
  return cfg;
}",0.9877913429522752
186685,"/** 
 * Get the line number of the instruction. This may refer to a line number in another file. To get the correct source file for this instruction, use   {@link #getSourceFileName(InstructionHandle)}.
 * @see #getSourceFileName(InstructionHandle)
 * @param ih the instruction to check.
 * @return the line number of the instruction, or -1 if unknown.
 */
public int getLineNumber(InstructionHandle ih){
  InstructionHandle handle=findLineNumberHandle(ih);
  if (handle == null)   return -1;
  Integer line=(Integer)handle.getAttribute(KEY_LINENUMBER);
  if (line != null) {
    return line;
  }
  LineNumberGen entry=getLineNumberEntry(ih,false);
  return entry != null ? entry.getSourceLine() : -1;
}","/** 
 * Get the line number of the instruction. This may refer to a line number in another file. To get the correct source file for this instruction, use   {@link #getSourceFileName(InstructionHandle)}.
 * @see #getSourceFileName(InstructionHandle)
 * @param ih the instruction to check.
 * @return the line number of the instruction, or -1 if unknown.
 */
public int getLineNumber(InstructionHandle ih){
  InstructionHandle handle=findLineNumberHandle(ih);
  if (handle == null)   return -1;
  Integer line=(Integer)handle.getAttribute(KEY_LINENUMBER);
  if (line != null) {
    return line;
  }
  LineNumberGen entry=getLineNumberEntry(handle,false);
  return entry != null ? entry.getSourceLine() : -1;
}",0.9943262411347518
186686,"/** 
 * Return a new callstring, extended by the given invoke site. <p>Let   {@code n(1)} be the id of the given invoke site, and{@code n(2),...,n(k)} be the callstring represented by {@code this}<ol><li/>If k &lt;= maxDepth, the resulting callstring is   {@code n(1),n(2),...,n(k)}<li/>If k &gt;=   maxDepth, the resulting callstring is   {@code n(1),n(2),...,n(maxDepth)}</ol>
 * @see MethodCode#getInvokeSite(InstructionHandle)
 * @param is the invokesite to be pushed at the end of the string.
 * @param maxLen the maximum length of the callstring
 * @return a new callstring with the given invocation as the last element.
 */
public CallString push(InvokeSite is,int maxLen){
  if (maxLen == 0)   return EMPTY;
  int k=Math.min(callString.length + 1,maxLen);
  int end=callString.length + 1;
  InvokeSite[] cs=Arrays.copyOfRange(callString,end - k,end);
  cs[k - 1]=is;
  return new CallString(cs);
}","/** 
 * Return a new callstring, extended by the given invoke site. <p>Let   {@code n(1)} be the id of the given invoke site, and{@code n(2),...,n(k)} be the callstring represented by {@code this}<ol><li/>If k &lt;= maxDepth, the resulting callstring is   {@code n(1),n(2),...,n(k)}<li/>If k &gt;=   maxDepth, the resulting callstring is   {@code n(1),n(2),...,n(maxDepth)}</ol>
 * @see MethodCode#getInvokeSite(InstructionHandle)
 * @param is the invokesite to be pushed at the end of the string.
 * @param maxLen the maximum length of the callstring
 * @return a new callstring with the given invocation as the last element.
 */
public CallString push(InvokeSite is,int maxLen){
  if (maxLen <= 0)   return EMPTY;
  if (callString.length == 0) {
    return new CallString(is);
  }
  int k=Math.min(callString.length + 1,maxLen);
  int end=callString.length + 1;
  InvokeSite[] cs=Arrays.copyOfRange(callString,end - k,end);
  cs[k - 1]=is;
  return new CallString(cs);
}",0.9632392115077252
186687,"/** 
 * Get the node for an instruction handle. This only works if   {@link #registerHandleNodes()} has been called first.
 * @param ih The instruction handle of a method which has this CFG associated with it
 * @return The basic block node associated with an instruction handle
 */
public BasicBlockNode getHandleNode(InstructionHandle ih){
  BasicBlockNode blockNode=(BasicBlockNode)ih.getAttribute(KEY_CFGNODE);
  if (blockNode == null) {
    String errMsg=""String_Node_Str"" + ih.toString(true);
    logger.error(errMsg);
    return null;
  }
  return blockNode;
}","public BasicBlockNode getHandleNode(InstructionHandle ih,boolean ignoreMissingNodes){
  BasicBlockNode blockNode=(BasicBlockNode)ih.getAttribute(KEY_CFGNODE);
  if (blockNode == null && !ignoreMissingNodes) {
    String errMsg=""String_Node_Str"" + ih.toString(true);
    logger.error(errMsg);
    return null;
  }
  return blockNode;
}",0.5083240843507214
186688,"/** 
 * Inline all InvokeSites which are marked for inlining by an inline strategy.
 */
public void performGreedyOptimizer(){
  if (!getJConfig().doAllowExperimental())   return;
  if (!getJConfig().doOptimizeNormal())   return;
  GreedyOptimizer optimizer=new GreedyOptimizer(greedyConfig);
  if (getJConfig().doAssumeDynamicClassLoader()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else {
    optimizer.addOptimizer(new InlineOptimizer(jcopter,inlineConfig));
  }
  logger.info(""String_Node_Str"");
  optimizer.optimize();
  logger.info(""String_Node_Str"");
}","/** 
 * Inline all InvokeSites which are marked for inlining by an inline strategy.
 */
public void performGreedyOptimizer(){
  if (!getJConfig().doOptimizeNormal())   return;
  GreedyOptimizer optimizer=new GreedyOptimizer(greedyConfig);
  if (getJConfig().doAssumeDynamicClassLoader()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else {
    optimizer.addOptimizer(new InlineOptimizer(jcopter,inlineConfig));
  }
  logger.info(""String_Node_Str"");
  optimizer.optimize();
  logger.info(""String_Node_Str"");
}",0.7750229568411386
186689,"private void loadOptions() throws BadConfigurationException {
  if (getJConfig().doOptimizeNormal() && getJConfig().doAllowExperimental()) {
    greedyConfig=new GreedyConfig(jcopter,getGreedyOptions());
  }
  inlineConfig=new InlineConfig(getInlineOptions());
}","private void loadOptions() throws BadConfigurationException {
  if (getJConfig().doOptimizeNormal()) {
    greedyConfig=new GreedyConfig(jcopter,getGreedyOptions());
  }
  inlineConfig=new InlineConfig(getInlineOptions());
}",0.9218106995884774
186690,"/** 
 * Quick'n'dirty initialization of all analyses. If the analyses get more options or get more complex in the future, this will need some work.
 * @param targets the root methods to use for all analyses and the callgraph.
 * @param cacheAnalysisType cache analysis type
 * @param wcaRoots if not null, initialize the WCA invoker with these roots.
 */
public void initAnalyses(Collection<MethodInfo> targets,AnalysisType cacheAnalysisType,Collection<MethodInfo> wcaRoots){
  targetCallGraph=CallGraph.buildCallGraph(targets,new DefaultCallgraphBuilder(AppInfo.getSingleton().getCallstringLength()));
  execCountAnalysis=new ExecCountAnalysis(targetCallGraph);
  methodCacheAnalysis=new MethodCacheAnalysis(this,cacheAnalysisType,targetCallGraph);
  if (wcaRoots != null) {
    wcaInvoker=new WCAInvoker(this,wcaRoots);
    try {
      wcaInvoker.initialize();
    }
 catch (    BadConfigurationException e) {
      throw new BadConfigurationError(e.getMessage(),e);
    }
  }
}","/** 
 * Quick'n'dirty initialization of all analyses. If the analyses get more options or get more complex in the future, this will need some work.
 * @param targets the root methods to use for all analyses and the callgraph.
 * @param cacheAnalysisType cache analysis type
 * @param wcaRoots if not null, initialize the WCA invoker with these roots.
 */
public void initAnalyses(Collection<MethodInfo> targets,AnalysisType cacheAnalysisType,Collection<MethodInfo> wcaRoots){
  logger.info(""String_Node_Str"");
  targetCallGraph=CallGraph.buildCallGraph(targets,new DefaultCallgraphBuilder(AppInfo.getSingleton().getCallstringLength()));
  logger.info(""String_Node_Str"");
  execCountAnalysis=new ExecCountAnalysis(targetCallGraph);
  execCountAnalysis.initialize();
  logger.info(""String_Node_Str"");
  methodCacheAnalysis=new MethodCacheAnalysis(this,cacheAnalysisType,targetCallGraph);
  methodCacheAnalysis.initialize();
  if (wcaRoots != null) {
    logger.info(""String_Node_Str"");
    wcaInvoker=new WCAInvoker(this,wcaRoots);
    try {
      wcaInvoker.initialize();
    }
 catch (    BadConfigurationException e) {
      throw new BadConfigurationError(e.getMessage(),e);
    }
  }
}",0.904059040590406
186691,"private void optimizeMethods(AnalysisManager analyses,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates();
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates();
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      if (!c.optimize(analyses,stacksize))       continue;
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(methods);
    }
 else {
      selector.sortCandidates(changeSet);
    }
    candidates=selector.selectNextCandidates();
  }
}","private void optimizeMethods(AnalysisManager analyses,CandidateSelector selector,Set<MethodInfo> methods){
  Map<MethodInfo,MethodData> methodData=new HashMap<MethodInfo,MethodData>(methods.size());
  selector.clear();
  for (  MethodInfo method : methods) {
    if (method.isNative())     continue;
    method.getCode().compile();
    StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
    int locals=method.getCode().getMaxLocals();
    for (    CodeOptimizer optimizer : optimizers) {
      Collection<Candidate> found;
      found=optimizer.findCandidates(method,analyses,stacksize,locals);
      selector.addCandidates(method,found);
      countCandidates+=found.size();
    }
    methodData.put(method,new MethodData(locals));
  }
  selector.sortCandidates();
  Set<MethodInfo> optimizedMethods=new HashSet<MethodInfo>();
  Set<MethodInfo> candidateChanges=new HashSet<MethodInfo>();
  Collection<Candidate> candidates=selector.selectNextCandidates();
  while (candidates != null) {
    optimizedMethods.clear();
    candidateChanges.clear();
    analyses.clearChangeSets();
    for (    Candidate c : candidates) {
      MethodInfo method=c.getMethod();
      StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(method);
      logger.info(""String_Node_Str"" + c.toString());
      if (!c.optimize(analyses,stacksize))       continue;
      countOptimized++;
      method.getCode().compile();
      stacksize.analyze(c.getStart(),c.getEnd());
      int locals=c.getMaxLocalsInRegion();
      List<Candidate> newCandidates=new ArrayList<Candidate>();
      for (      CodeOptimizer optimizer : optimizers) {
        Collection<Candidate> found;
        found=optimizer.findCandidates(method,analyses,stacksize,locals,c.getStart(),c.getEnd());
        newCandidates.addAll(found);
      }
      selector.onSuccessfulOptimize(c,newCandidates);
      countCandidates+=newCandidates.size();
      optimizedMethods.add(method);
    }
    candidateChanges.addAll(optimizedMethods);
    if (methods.size() > 1) {
      for (      MethodInfo method : optimizedMethods) {
        candidateChanges.addAll(appInfo.getCallGraph().getDirectInvokers(method));
      }
      candidateChanges.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
    }
    Set<MethodInfo> changeSet=selector.updateChangeSet(optimizedMethods,candidateChanges);
    for (    MethodInfo method : candidateChanges) {
      if (!methodData.containsKey(method))       continue;
      selector.updateCandidates(method,analyses.getStacksizeAnalysis(method));
    }
    if (methods.size() == 1) {
      selector.sortCandidates(methods);
    }
 else {
      selector.sortCandidates(changeSet);
    }
    candidates=selector.selectNextCandidates();
  }
}",0.9702859278639506
186692,"public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  AnalysisManager analyses=initializeAnalyses();
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    selector=new WCETRebateSelector(analyses,config.getMaxCodesize());
  }
 else {
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
  }
  selector.initialize();
  GreedyOrder order=config.getOrder();
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,selector,wcaMethods);
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
    selector.initialize();
    optimizeMethods(analyses,selector,others);
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
}","public void optimize(){
  List<MethodInfo> rootMethods=config.getTargetMethods();
  resetCounters();
  AnalysisManager analyses=initializeAnalyses();
  for (  CodeOptimizer opt : optimizers) {
    opt.initialize(analyses,rootMethods);
  }
  CandidateSelector selector;
  if (config.useWCA()) {
    selector=new WCETRebateSelector(analyses,config.getMaxCodesize());
  }
 else {
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
  }
  selector.initialize();
  GreedyOrder order=config.getOrder();
  if (order == GreedyOrder.Global || (order == GreedyOrder.WCAFirst && !config.useWCA())) {
    optimizeMethods(analyses,selector,analyses.getTargetCallGraph().getMethodInfos());
  }
 else   if (order == GreedyOrder.Targets) {
    for (    MethodInfo target : config.getTargetMethods()) {
      optimizeMethods(analyses,selector,analyses.getTargetCallGraph().getReachableImplementationsSet(target));
    }
  }
 else   if (order == GreedyOrder.WCAFirst) {
    Set<MethodInfo> wcaMethods=analyses.getWCAMethods();
    optimizeMethods(analyses,selector,wcaMethods);
    Set<MethodInfo> others=new HashSet<MethodInfo>(analyses.getTargetCallGraph().getMethodInfos());
    others.removeAll(wcaMethods);
    selector.printStatistics();
    selector=new ACETRebateSelector(analyses,config.getMaxCodesize());
    selector.initialize();
    optimizeMethods(analyses,selector,others);
  }
 else {
    throw new AppInfoError(""String_Node_Str"" + order + ""String_Node_Str"");
  }
  selector.printStatistics();
  printStatistics();
}",0.9655870445344128
186693,"private AnalysisManager initializeAnalyses(){
  AnalysisManager analyses=new AnalysisManager(jcopter);
  analyses.initAnalyses(config.getTargetMethods(),config.getCacheAnalysisType(),config.getWCATargets());
  return analyses;
}","private AnalysisManager initializeAnalyses(){
  AnalysisManager analyses=new AnalysisManager(jcopter);
  analyses.initAnalyses(config.getTargetMethods(),config.getCacheAnalysisType(),config.getWCATargets());
  logger.info(""String_Node_Str"" + analyses.getTargetCallGraph().getNodes().size());
  return analyses;
}",0.8444444444444444
186694,"protected boolean checkConstraints(Candidate candidate){
  int size=candidate.getMethod().getCode().getNumberOfBytes();
  size+=candidate.getDeltaLocalCodesize();
  if (size > processorModel.getMaxMethodSize())   return false;
  int newGlobalSize=globalCodesize + getDeltaGlobalCodesize(candidate);
  if (newGlobalSize > maxGlobalSize)   return false;
  return true;
}","protected boolean checkConstraints(Candidate candidate){
  int size=candidate.getMethod().getCode().getNumberOfBytes();
  size+=candidate.getDeltaLocalCodesize();
  if (size > processorModel.getMaxMethodSize())   return false;
  if (maxGlobalSize > 0) {
    int newGlobalSize=globalCodesize + getDeltaGlobalCodesize(candidate);
    if (newGlobalSize > maxGlobalSize)     return false;
  }
  return true;
}",0.9521345407503234
186695,"@Override public Collection<Candidate> findCandidates(MethodInfo method,AnalysisManager analyses,StacksizeAnalysis stacksize,int maxLocals,InstructionHandle start,InstructionHandle end){
  List<Candidate> candidates=new LinkedList<Candidate>();
  MethodCode code=method.getCode();
  InstructionHandle ih=start;
  while (ih != null) {
    if (code.isInvokeSite(ih)) {
      InvokeSite site=code.getInvokeSite(ih);
      CallString cs=new CallString(site);
      MethodInfo invokee=helper.devirtualize(cs);
      if (invokee == null)       continue;
      cs=getInlineCallString(code,ih).push(site);
      Candidate candidate=checkInvoke(code,cs,site,invokee,maxLocals);
      if (candidate == null) {
        continue;
      }
      if (!candidate.recalculate(analyses,stacksize)) {
        continue;
      }
      candidates.add(candidate);
    }
    if (ih == end)     break;
    ih=ih.getNext();
  }
  return candidates;
}","@Override public Collection<Candidate> findCandidates(MethodInfo method,AnalysisManager analyses,StacksizeAnalysis stacksize,int maxLocals,InstructionHandle start,InstructionHandle end){
  List<Candidate> candidates=new LinkedList<Candidate>();
  MethodCode code=method.getCode();
  for (InstructionHandle ih=start; ih != null; ih=ih.getNext()) {
    if (code.isInvokeSite(ih)) {
      InvokeSite site=code.getInvokeSite(ih);
      CallString cs=new CallString(site);
      MethodInfo invokee=helper.devirtualize(cs);
      if (invokee == null)       continue;
      cs=getInlineCallString(code,ih).push(site);
      Candidate candidate=checkInvoke(code,cs,site,invokee,maxLocals);
      if (candidate == null) {
        continue;
      }
      if (!candidate.recalculate(analyses,stacksize)) {
        continue;
      }
      candidates.add(candidate);
    }
    if (ih == end)     break;
  }
  return candidates;
}",0.9021739130434784
186696,"/** 
 * Get the flowgraph of the given method. <p> A new callgraph is constructed when this method is called, changes to this graph are not automatically stored back to MethodCode. If you want to keep changes to the graph you need to keep a reference to this graph yourself. </p>
 * @param mi the method to get the CFG for
 * @return the CFG for the method.
 */
public ControlFlowGraph getFlowGraph(MethodInfo mi){
  if (!mi.hasCode())   return null;
  ControlFlowGraph cfg;
  try {
    cfg=mi.getCode().getControlFlowGraph(false);
    cfg.resolveVirtualInvokes();
    cfg.insertReturnNodes();
    cfg.insertContinueLoopNodes();
    cfg.registerHandleNodes();
  }
 catch (  BadGraphException e) {
    throw new BadGraphError(e.getMessage(),e);
  }
  return cfg;
}","/** 
 * Get the flowgraph of the given method. <p> A new callgraph is constructed when this method is called, changes to this graph are not automatically stored back to MethodCode. If you want to keep changes to the graph you need to keep a reference to this graph yourself. </p>
 * @param mi the method to get the CFG for
 * @return the CFG for the method.
 */
public ControlFlowGraph getFlowGraph(MethodInfo mi){
  if (!mi.hasCode())   return null;
  ControlFlowGraph cfg;
  try {
    cfg=mi.getCode().getControlFlowGraph(false);
    cfg.resolveVirtualInvokes();
    cfg.insertReturnNodes();
    cfg.insertContinueLoopNodes();
  }
 catch (  BadGraphException e) {
    throw new BadGraphError(e.getMessage(),e);
  }
  return cfg;
}",0.9792642140468228
186697,"private void interpret(InstructionList il,Map<InstructionHandle,T> start,boolean initialize){
  if (initialize) {
    InstructionHandle ih=il.getStart();
    while (ih != null) {
      results.put(ih,analysis.bottom());
      ih=ih.getNext();
    }
    results.putAll(start);
  }
 else {
    for (InstructionHandle ih=il.getStart(); ih != null; ih=ih.getNext()) {
      if (results.containsKey(ih))       continue;
      if (ih.getPrev() == null && !ih.hasTargeters()) {
        results.put(ih,analysis.initial(ih));
      }
 else {
        results.put(ih,analysis.bottom());
        if (ih.hasTargeters()) {
          for (          InstructionTargeter targeter : ih.getTargeters()) {
            if (targeter instanceof CodeExceptionGen) {
              results.put(ih,analysis.initial((CodeExceptionGen)targeter));
              break;
            }
          }
        }
      }
    }
  }
  LinkedList<Edge> worklist=new LinkedList<Edge>();
  for (  InstructionHandle ih : start.keySet()) {
    if (initialize) {
      worklist.addAll(getOutEdges(ih));
    }
 else     if (ih.getPrev() == null && !ih.hasTargeters()) {
      worklist.addAll(getOutEdges(ih));
    }
 else {
      worklist.addAll(getInEdges(il,ih));
    }
  }
  while (!worklist.isEmpty()) {
    Edge edge=worklist.removeFirst();
    InstructionHandle tail=edge.getTail();
    InstructionHandle head=edge.getHead();
    T tailValue=results.get(tail);
    T headValue=results.get(head);
    T transferred=analysis.transfer(tailValue,edge);
    if (!analysis.compare(transferred,headValue)) {
      T newValue=analysis.join(transferred,headValue);
      results.put(head,newValue);
      if (edge.getType() == EdgeType.EXIT_EDGE) {
        continue;
      }
      List<Edge> outEdges=getOutEdges(head);
      for (      Edge outEdge : outEdges) {
        if (worklist.contains(outEdge)) {
          continue;
        }
        if (outEdges.size() > 1) {
          worklist.addLast(outEdge);
        }
 else {
          worklist.addFirst(outEdge);
        }
      }
    }
  }
}","private void interpret(InstructionList il,Map<InstructionHandle,T> start,boolean initialize){
  if (initialize) {
    InstructionHandle ih=il.getStart();
    while (ih != null) {
      results.put(ih,analysis.bottom());
      ih=ih.getNext();
    }
    results.putAll(start);
  }
 else {
    for (InstructionHandle ih=il.getStart(); ih != null; ih=ih.getNext()) {
      if (results.containsKey(ih))       continue;
      if (ih.getPrev() == null) {
        results.put(ih,analysis.initial(ih));
      }
 else {
        results.put(ih,analysis.bottom());
        if (ih.hasTargeters()) {
          for (          InstructionTargeter targeter : ih.getTargeters()) {
            if (targeter instanceof CodeExceptionGen) {
              results.put(ih,analysis.initial((CodeExceptionGen)targeter));
              break;
            }
          }
        }
      }
    }
  }
  LinkedList<Edge> worklist=new LinkedList<Edge>();
  for (  InstructionHandle ih : start.keySet()) {
    if (initialize) {
      worklist.addAll(getOutEdges(ih));
    }
 else {
      List<Edge> inEdges=getInEdges(il,ih);
      if (inEdges.isEmpty()) {
        worklist.addAll(getOutEdges(ih));
      }
 else {
        worklist.addAll(inEdges);
      }
    }
  }
  while (!worklist.isEmpty()) {
    Edge edge=worklist.removeFirst();
    InstructionHandle tail=edge.getTail();
    InstructionHandle head=edge.getHead();
    T tailValue=results.get(tail);
    T headValue=results.get(head);
    T transferred=analysis.transfer(tailValue,edge);
    if (!analysis.compare(transferred,headValue)) {
      T newValue=analysis.join(transferred,headValue);
      results.put(head,newValue);
      if (edge.getType() == EdgeType.EXIT_EDGE) {
        continue;
      }
      List<Edge> outEdges=getOutEdges(head);
      for (      Edge outEdge : outEdges) {
        if (worklist.contains(outEdge)) {
          continue;
        }
        if (outEdges.size() > 1) {
          worklist.addLast(outEdge);
        }
 else {
          worklist.addFirst(outEdge);
        }
      }
    }
  }
}",0.9518455145441213
186698,"public void reset(InstructionHandle from,InstructionHandle to){
  InstructionHandle ih=from;
  while (ih != to) {
    results.put(ih,analysis.bottom());
    ih=ih.getNext();
  }
  results.put(ih,analysis.bottom());
}","public void reset(InstructionHandle from,InstructionHandle to){
  InstructionHandle ih=from;
  while (ih != to) {
    results.remove(ih);
    ih=ih.getNext();
  }
  results.put(ih,analysis.bottom());
}",0.7386091127098321
186699,"@Override public int hashCode(){
  return toString().hashCode();
}","@Override public int hashCode(){
  int result=className != null ? className.hashCode() : 0;
  result=31 * result + (memberName != null ? memberName.hashCode() : 0);
  result=31 * result + (descriptor != null ? descriptor.hashCode() : 0);
  return result;
}",0.3043478260869565
186700,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (!this.getClass().equals(obj.getClass()))   return false;
  return this.toString().equals(obj.toString());
}","@SuppressWarnings({""String_Node_Str""}) @Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  MemberID memberID=(MemberID)o;
  if (className != null ? !className.equals(memberID.className) : memberID.className != null)   return false;
  if (memberName != null ? !memberName.equals(memberID.memberName) : memberID.memberName != null)   return false;
  if (descriptor != null ? !descriptor.equals(memberID.descriptor) : memberID.descriptor != null)   return false;
  return true;
}",0.2199747155499367
186701,"@Override public void onSetupAppInfo(AppSetup setup,AppInfo appInfo) throws BadConfigurationException {
  OptionGroup options=setup.getConfig().getOptions();
  config.checkOptions();
  executor=new PhaseExecutor(this,options);
}","@Override public void onSetupAppInfo(AppSetup setup,AppInfo appInfo) throws BadConfigurationException {
  OptionGroup options=setup.getConfig().getOptions();
  config.initialize();
  executor=new PhaseExecutor(this,options);
}",0.9515418502202644
186702,"/** 
 * Run all configured optimizations and perform the required analyses.
 */
public void optimize(){
  boolean firstPassDFA=useDFA() && !config.doOptimizeFastOnly();
  if (firstPassDFA) {
    executor.dataflowAnalysis(false);
  }
  executor.buildCallGraph(firstPassDFA);
  executor.dumpCallgraph(""String_Node_Str"");
  executor.removeDebugAttributes();
  executor.cleanupMethodCode();
  executor.performSimpleInline();
  if (useDFA()) {
    executor.dataflowAnalysis(true);
  }
  executor.buildCallGraph(useDFA());
  if (useWCET()) {
    wcetTool.rebuildCallGraph();
  }
 else {
    logger.info(""String_Node_Str"");
  }
  executor.performGreedyOptimizer();
  executor.cleanupMethodCode();
  executor.removeUnusedMembers();
  executor.relinkInvokesuper();
  executor.cleanupConstantPool();
}","/** 
 * Run all configured optimizations and perform the required analyses.
 */
public void optimize(){
  boolean firstPassDFA=useDFA() && !config.doOptimizeFastOnly();
  if (firstPassDFA) {
    executor.dataflowAnalysis(false);
  }
  executor.buildCallGraph(firstPassDFA);
  executor.dumpCallgraph(""String_Node_Str"");
  executor.removeDebugAttributes();
  executor.cleanupMethodCode();
  executor.performSimpleInline();
  if (useDFA()) {
    executor.dataflowAnalysis(true);
  }
  executor.buildCallGraph(useDFA());
  if (useWCA()) {
    wcetTool.rebuildCallGraph();
  }
 else {
    logger.info(""String_Node_Str"");
  }
  executor.performGreedyOptimizer();
  executor.cleanupMethodCode();
  executor.removeUnusedMembers();
  executor.relinkInvokesuper();
  executor.cleanupConstantPool();
}",0.9981024667931688
186703,"private void loadOptions() throws BadConfigurationException {
  if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=0;
  }
 else   if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=1;
  }
 else   if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=2;
  }
 else   if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=3;
  }
 else {
    throw new BadConfigurationException(""String_Node_Str"" + options.getOption(OPTIMIZE) + ""String_Node_Str"");
  }
  String max=options.getOption(MAX_CODE_SIZE);
  if (max != null) {
    max=max.toLowerCase();
    if (max.endsWith(""String_Node_Str"")) {
      maxCodesize=Integer.parseInt(max.substring(0,max.length() - 2)) * 1024;
    }
 else     if (max.endsWith(""String_Node_Str"")) {
      maxCodesize=Integer.parseInt(max.substring(0,max.length() - 2)) * 1024 * 1024;
    }
 else {
      maxCodesize=Integer.parseInt(max);
    }
  }
 else {
  }
  if (useWCA()) {
    wcaTargets=Config.parseMethodList(options.getOption(WCA_TARGETS));
  }
}","private void loadOptions() throws BadConfigurationException {
  if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=0;
  }
 else   if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=1;
  }
 else   if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=2;
  }
 else   if (""String_Node_Str"".equals(options.getOption(OPTIMIZE))) {
    optimizeLevel=3;
  }
 else {
    throw new BadConfigurationException(""String_Node_Str"" + options.getOption(OPTIMIZE) + ""String_Node_Str"");
  }
  String max=options.getOption(MAX_CODE_SIZE);
  if (max != null) {
    max=max.toLowerCase();
    if (max.endsWith(""String_Node_Str"")) {
      maxCodesize=Integer.parseInt(max.substring(0,max.length() - 2)) * 1024;
    }
 else     if (max.endsWith(""String_Node_Str"")) {
      maxCodesize=Integer.parseInt(max.substring(0,max.length() - 2)) * 1024 * 1024;
    }
 else {
      maxCodesize=Integer.parseInt(max);
    }
  }
 else {
  }
}",0.9540840985983567
186704,"/** 
 * Quick'n'dirty initialization of all analyses. If the analyses get more options or get more complex in the future, this will need some work.
 * @param targets the root methods to use for all analyses and the callgraph.
 * @param cacheAnalysisType cache analysis type
 * @param wcaRoots if not null, initialize the WCA invoker with these roots.
 */
public void initAnalyses(Collection<MethodInfo> targets,AnalysisType cacheAnalysisType,Collection<MethodInfo> wcaRoots){
  logger.info(""String_Node_Str"");
  targetCallGraph=CallGraph.buildCallGraph(targets,new DefaultCallgraphBuilder(AppInfo.getSingleton().getCallstringLength()));
  logger.info(""String_Node_Str"");
  execCountAnalysis=new ExecCountAnalysis(targetCallGraph);
  execCountAnalysis.initialize();
  logger.info(""String_Node_Str"");
  methodCacheAnalysis=new MethodCacheAnalysis(this,cacheAnalysisType,targetCallGraph);
  methodCacheAnalysis.initialize();
  if (wcaRoots != null) {
    logger.info(""String_Node_Str"");
    wcaInvoker=new WCAInvoker(this,wcaRoots);
    try {
      wcaInvoker.initialize();
    }
 catch (    BadConfigurationException e) {
      throw new BadConfigurationError(e.getMessage(),e);
    }
  }
}","/** 
 * Quick'n'dirty initialization of all analyses. If the analyses get more options or get more complex in the future, this will need some work.
 * @param targets the root methods to use for all analyses and the callgraph.
 * @param cacheAnalysisType cache analysis type
 * @param wcaRoots if not null, initialize the WCA invoker with these roots.
 */
public void initAnalyses(Collection<MethodInfo> targets,AnalysisType cacheAnalysisType,Collection<MethodInfo> wcaRoots){
  logger.info(""String_Node_Str"");
  Set<MethodInfo> allTargets=new HashSet<MethodInfo>(targets);
  if (wcaRoots != null) {
    allTargets.addAll(wcaRoots);
  }
  targetCallGraph=CallGraph.buildCallGraph(allTargets,new DefaultCallgraphBuilder(AppInfo.getSingleton().getCallstringLength()));
  logger.info(""String_Node_Str"");
  execCountAnalysis=new ExecCountAnalysis(targetCallGraph);
  execCountAnalysis.initialize();
  logger.info(""String_Node_Str"");
  methodCacheAnalysis=new MethodCacheAnalysis(this,cacheAnalysisType,targetCallGraph);
  methodCacheAnalysis.initialize();
  if (wcaRoots != null) {
    logger.info(""String_Node_Str"");
    wcaInvoker=new WCAInvoker(this,wcaRoots);
    try {
      wcaInvoker.initialize();
    }
 catch (    BadConfigurationException e) {
      throw new BadConfigurationError(e.getMessage(),e);
    }
  }
}",0.9477045908183632
186705,"private void traverseInvokeGraph(DirectedGraph<ExecutionContext,ContextEdge> graph,CacheUpdater updater){
  if (callGraph.getAcyclicity() == Ternary.TRUE) {
    TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(graph);
    while (topOrder.hasNext()) {
      ExecutionContext node=topOrder.next();
      int newBlocks=updater.getCacheBlocks(node,true);
      if (!updater.updateBlocks(node,newBlocks)) {
      }
    }
  }
 else {
    for (    ExecutionContext node : graph.vertexSet()) {
      int newBlocks=updater.getCacheBlocks(node,false);
      if (!updater.updateBlocks(node,newBlocks)) {
      }
    }
  }
}","private void traverseInvokeGraph(DirectedGraph<ExecutionContext,ContextEdge> graph,CacheUpdater updater){
  if (callGraph.getAcyclicity() == Ternary.TRUE) {
    TopologicalOrderIterator<ExecutionContext,ContextEdge> topOrder=new TopologicalOrderIterator<ExecutionContext,ContextEdge>(graph);
    while (topOrder.hasNext()) {
      ExecutionContext node=topOrder.next();
      int newBlocks=updater.getCacheBlocks(node,true);
      if (!updater.updateBlocks(node,newBlocks)) {
      }
    }
  }
 else {
    for (    ExecutionContext node : graph.vertexSet()) {
      int newBlocks=1;
      if (!updater.updateBlocks(node,newBlocks)) {
      }
    }
  }
}",0.9738610903659448
186706,"/** 
 * @param method the changed method
 * @param deltaBytes the number of bytes to add to the current code size
 * @return the number of cache miss cycles due to the code size change
 */
public long getDeltaCacheMissCosts(MethodInfo method,int deltaBytes){
  if (deltaBytes == 0)   return 0;
  if (analysisType == AnalysisType.ALWAYS_HIT)   return 0;
  WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
  int size=method.getCode().getNumberOfBytes();
  int oldWords=MiscUtils.bytesToWords(size);
  int newWords=MiscUtils.bytesToWords(size + deltaBytes);
  int deltaBlocks=cache.requiredNumberOfBlocks(newWords) - cache.requiredNumberOfBlocks(oldWords);
  int newBlocks=getRequiredBlocks(method) + deltaBlocks;
  long costs=0;
  if (analysisType == AnalysisType.ALWAYS_MISS || cache.allFit(newBlocks)) {
    long oldCycles=pm.getMethodCacheMissPenalty(oldWords,true);
    long newCycles=pm.getMethodCacheMissPenalty(newWords,true);
    costs=analyses.getExecCountAnalysis().getExecCount(method) * (newCycles - oldCycles);
    oldCycles=pm.getMethodCacheMissPenalty(oldWords,false);
    newCycles=pm.getMethodCacheMissPenalty(newWords,false);
    for (    InvokeSite invokeSite : method.getCode().getInvokeSites()) {
      costs+=analyses.getExecCountAnalysis().getExecCount(invokeSite) * (newCycles - oldCycles);
    }
  }
  if (analysisType == AnalysisType.ALWAYS_MISS) {
    return costs;
  }
  Set<ExecutionContext> changes=findClassificationChanges(method,deltaBytes);
  long deltaCosts=0;
  for (  ExecutionContext node : changes) {
    for (    InvokeSite invokeSite : node.getMethodInfo().getCode().getInvokeSites()) {
      int sizeWords=0;
      for (      MethodInfo invokee : callGraph.findImplementations(node.getCallString().push(invokeSite))) {
        sizeWords=Math.max(sizeWords,invokee.getCode().getNumberOfWords());
      }
      long count=analyses.getExecCountAnalysis().getExecCount(node,invokeSite.getInstructionHandle());
      deltaCosts+=count * pm.getMethodCacheMissPenalty(sizeWords,true);
      deltaCosts+=count * pm.getMethodCacheMissPenalty(oldWords,false);
    }
  }
  if (deltaBytes > 0) {
    costs+=deltaCosts;
  }
 else {
    costs-=deltaCosts;
  }
  if (analysisType == AnalysisType.ALL_FIT_REGIONS) {
  }
  return costs;
}","/** 
 * @param method the changed method
 * @param deltaBytes the number of bytes to add to the current code size
 * @return the number of cache miss cycles due to the code size change
 */
public long getDeltaCacheMissCosts(MethodInfo method,int deltaBytes){
  if (deltaBytes == 0)   return 0;
  if (analysisType == AnalysisType.ALWAYS_HIT)   return 0;
  WCETProcessorModel pm=analyses.getJCopter().getWCETProcessorModel();
  int size=method.getCode().getNumberOfBytes();
  int oldWords=MiscUtils.bytesToWords(size);
  int newWords=MiscUtils.bytesToWords(size + deltaBytes);
  int deltaBlocks=cache.requiredNumberOfBlocks(newWords) - cache.requiredNumberOfBlocks(oldWords);
  int newBlocks=getRequiredBlocks(method) + deltaBlocks;
  long costs=0;
  if (analysisType == AnalysisType.ALWAYS_MISS || !cache.allFit(newBlocks)) {
    long oldCycles=pm.getMethodCacheMissPenalty(oldWords,true);
    long newCycles=pm.getMethodCacheMissPenalty(newWords,true);
    costs=analyses.getExecCountAnalysis().getExecCount(method) * (newCycles - oldCycles);
    oldCycles=pm.getMethodCacheMissPenalty(oldWords,false);
    newCycles=pm.getMethodCacheMissPenalty(newWords,false);
    for (    InvokeSite invokeSite : method.getCode().getInvokeSites()) {
      costs+=analyses.getExecCountAnalysis().getExecCount(invokeSite) * (newCycles - oldCycles);
    }
  }
  if (analysisType == AnalysisType.ALWAYS_MISS) {
    return costs;
  }
  Set<ExecutionContext> changes=findClassificationChanges(method,deltaBytes);
  long deltaCosts=0;
  for (  ExecutionContext node : changes) {
    for (    InvokeSite invokeSite : node.getMethodInfo().getCode().getInvokeSites()) {
      int sizeWords=0;
      for (      MethodInfo invokee : callGraph.findImplementations(node.getCallString().push(invokeSite))) {
        sizeWords=Math.max(sizeWords,invokee.getCode().getNumberOfWords());
      }
      long count=analyses.getExecCountAnalysis().getExecCount(node,invokeSite.getInstructionHandle());
      deltaCosts+=count * pm.getMethodCacheMissPenalty(sizeWords,true);
      deltaCosts+=count * pm.getMethodCacheMissPenalty(oldWords,false);
    }
  }
  if (deltaBytes > 0) {
    costs+=deltaCosts;
  }
 else {
    costs-=deltaCosts;
  }
  if (analysisType == AnalysisType.ALL_FIT_REGIONS) {
  }
  return costs;
}",0.999780845934692
186707,"public AnalysisContextLocal getRootContext(){
  if (analysisType == AnalysisType.ALWAYS_HIT) {
    return new AnalysisContextLocal(StaticCacheApproximation.ALWAYS_HIT);
  }
  if (analysisType == AnalysisType.ALWAYS_MISS) {
    return new AnalysisContextLocal(StaticCacheApproximation.ALWAYS_MISS);
  }
  if (analysisType == AnalysisType.ALWAYS_MISS_OR_HIT) {
    return new AnalysisContextLocal(StaticCacheApproximation.ALL_FIT_SIMPLE);
  }
  return new AnalysisContextLocal(StaticCacheApproximation.ALL_FIT_SIMPLE);
}","public AnalysisContextLocal getRootContext(){
  return getAnalysisContext(CallString.EMPTY);
}",0.2777777777777778
186708,"private void setWCETOptions(MethodInfo targetMethod,boolean generateReports){
  Config config=wcetTool.getConfig();
  config.setOption(ProjectConfig.TARGET_METHOD,targetMethod.getMemberID().toString());
  config.setOption(ProjectConfig.DO_GENERATE_REPORTS,generateReports);
  config.setOption(ProjectConfig.DO_GENERATE_REPORTS,false);
  config.setOption(ProjectConfig.DUMP_TARGET_CALLGRAPH,DUMPTYPE.off);
}","private void setWCETOptions(MethodInfo targetMethod,boolean generateReports){
  Config config=wcetTool.getConfig();
  config.setOption(ProjectConfig.TARGET_METHOD,targetMethod.getMemberID().toString());
  config.setOption(ProjectConfig.DO_GENERATE_REPORTS,generateReports);
  config.setOption(ProjectConfig.DO_GENERATE_REPORTS,false);
  config.setOption(ProjectConfig.DUMP_TARGET_CALLGRAPH,DUMPTYPE.off);
  config.setOption(IPETConfig.DUMP_ILP,false);
}",0.9452852153667056
186709,"public void initialize() throws BadConfigurationException {
  if (wcaTargets.size() != 1) {
    throw new BadConfigurationException(""String_Node_Str"");
  }
  setWCETOptions(wcaTargets.iterator().next(),false);
  wcetTool.initialize();
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  WcetCost cost=recursiveAnalysis.computeCost(wcetTool.getTargetMethod(),analyses.getMethodCacheAnalysis().getRootContext());
}","public void initialize() throws BadConfigurationException {
  if (wcaTargets.size() != 1) {
    throw new BadConfigurationException(""String_Node_Str"");
  }
  setWCETOptions(wcaTargets.iterator().next(),false);
  wcetTool.initialize();
  IPETConfig ipetConfig=new IPETConfig(wcetTool.getConfig());
  RecursiveStrategy<AnalysisContextLocal,WcetCost> strategy;
  if (useMethodCacheStrategy) {
    strategy=analyses.getMethodCacheAnalysis().createRecursiveStrategy(wcetTool,ipetConfig);
  }
 else {
    strategy=new LocalAnalysis(wcetTool,ipetConfig);
  }
  recursiveAnalysis=new RecursiveWcetAnalysis<AnalysisContextLocal>(wcetTool,ipetConfig,strategy);
  runAnalysis(wcetTool.getCallGraph().getReversedGraph());
}",0.8891873740765615
186710,"public WCAInvoker(AnalysisManager analyses,Collection<MethodInfo> wcaTargets){
  this.analyses=analyses;
  this.jcopter=analyses.getJCopter();
  this.wcaTargets=wcaTargets;
  wcetTool=jcopter.getWcetTool();
  useMethodCacheStrategy=true;
}","public WCAInvoker(AnalysisManager analyses,Collection<MethodInfo> wcaTargets){
  this.analyses=analyses;
  this.jcopter=analyses.getJCopter();
  this.wcaTargets=wcaTargets;
  wcetTool=jcopter.getWcetTool();
  useMethodCacheStrategy=true;
  wcaNodeFlow=new HashMap<ExecutionContext,Map<CFGNode,Long>>();
}",0.8802946593001841
186711,"/** 
 * Update the WCA results after a set of methods have been changed. The changesets of analyses in the AnalysisManager are checked for changes too.
 * @param changedMethods a set of methods of which the code has been modified.
 */
public void updateWCA(Collection<MethodInfo> changedMethods){
  Set<MethodInfo> roots=new HashSet<MethodInfo>(changedMethods);
  roots.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
  CallGraph callGraph=wcetTool.getCallGraph();
  List<ExecutionContext> rootNodes=new ArrayList<ExecutionContext>(roots.size());
  for (  MethodInfo root : roots) {
    rootNodes.addAll(callGraph.getNodes(root));
  }
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  DFSVisitor<ExecutionContext,ContextEdge> visitor=new EmptyDFSVisitor<ExecutionContext,ContextEdge>(){
    @Override public void preorder(    ExecutionContext node){
      methods.add(node.getMethodInfo());
    }
  }
;
  DirectedGraph<ExecutionContext,ContextEdge> reversed=wcetTool.getCallGraph().getReversedGraph();
  DFSTraverser<ExecutionContext,ContextEdge> traverser=new DFSTraverser<ExecutionContext,ContextEdge>(visitor);
  traverser.traverse(reversed);
  recursiveAnalysis.clearCache(methods);
  recursiveAnalysis.computeCost(wcetTool.getTargetMethod(),analyses.getMethodCacheAnalysis().getRootContext());
}","/** 
 * Update the WCA results after a set of methods have been changed. The changesets of analyses in the AnalysisManager are checked for changes too.
 * @param changedMethods a set of methods of which the code has been modified.
 */
public void updateWCA(Collection<MethodInfo> changedMethods){
  Set<MethodInfo> roots=new HashSet<MethodInfo>(changedMethods);
  roots.addAll(analyses.getMethodCacheAnalysis().getClassificationChangeSet());
  CallGraph callGraph=wcetTool.getCallGraph();
  List<ExecutionContext> rootNodes=new ArrayList<ExecutionContext>(roots.size());
  for (  MethodInfo root : roots) {
    rootNodes.addAll(callGraph.getNodes(root));
  }
  runAnalysis(wcetTool.getCallGraph().createInvokeGraph(rootNodes,true));
}",0.6447559207346544
186712,"public boolean isOnWCETPath(MethodInfo method,InstructionHandle ih){
  ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
  BasicBlockNode node=cfg.getHandleNode(ih);
  return recursiveAnalysis.isWCETBlock(cfg,node);
}","public boolean isOnWCETPath(MethodInfo method,InstructionHandle ih){
  ControlFlowGraph cfg=method.getCode().getControlFlowGraph(false);
  BasicBlockNode block=cfg.getHandleNode(ih);
  for (  ExecutionContext node : wcetTool.getCallGraph().getNodes(method)) {
    Long flow=wcaNodeFlow.get(node).get(block);
    if (flow > 0)     return true;
  }
  return false;
}",0.626465661641541
186713,"public boolean useWCA(){
  return jcopter.useWCET();
}","public boolean useWCA(){
  return jcopter.useWCA();
}",0.97196261682243
186714,"/** 
 * Check for some preliminary requirements (method unsupported, abstract method, excluded packages, recursion, .. )
 * @param invokers a callstring leading to the invokee. The first entry in the callstring must be the method intowhich the other methods are recursively inlined, the last entry in the list must be invokesite of the invokee. This is needed to check to avoid endless inlining of recursive methods.
 * @param invokeSite the actual invokesite to inline.
 * @param invokee the devirtualized invokee.
 * @return true if the basic requirements for inlining are fulfilled.
 */
private boolean checkPreliminaries(CallString invokers,InvokeSite invokeSite,MethodInfo invokee){
  MethodInfo invoker=invokeSite.getInvoker();
  if (invokee.isSynchronized() || invokee.isAbstract() || invokee.isNative()) {
    return false;
  }
  if (AppInfo.getSingleton().isNative(invokee.getClassInfo().getClassName())) {
    return false;
  }
  if (invokers.contains(invokee)) {
    return false;
  }
  if (maxRecursiveInlining > 0 && invokers.length() > maxRecursiveInlining) {
    return false;
  }
  if (maxInlineSize > 0 && invokee.getCode().getNumberOfBytes() > maxInlineSize) {
    return false;
  }
  if (inlineConfig.doExcludeMethod(invoker)) {
    return false;
  }
  if (inlineConfig.doExcludeMethod(invokee)) {
    return false;
  }
  if (!inlineConfig.doInlineLibraries() && (AppInfo.getSingleton().isLibrary(invokee.getClassName()) || AppInfo.getSingleton().isLibrary(invoker.getClassName()))) {
    return false;
  }
  return invoker.canAccess(invokee);
}","/** 
 * Check for some preliminary requirements (method unsupported, abstract method, excluded packages, recursion, .. )
 * @param invokers a callstring leading to the invokee. The first entry in the callstring must be the method intowhich the other methods are recursively inlined, the last entry in the list must be invokesite of the invokee. This is needed to check to avoid endless inlining of recursive methods.
 * @param invokeSite the actual invokesite to inline.
 * @param invokee the devirtualized invokee.
 * @return true if the basic requirements for inlining are fulfilled.
 */
private boolean checkPreliminaries(CallString invokers,InvokeSite invokeSite,MethodInfo invokee){
  MethodInfo invoker=invokeSite.getInvoker();
  if (invokee.isSynchronized() || invokee.isAbstract() || invokee.isNative()) {
    return false;
  }
  if (AppInfo.getSingleton().isNative(invokee.getClassInfo().getClassName())) {
    return false;
  }
  if (invokers.contains(invokee)) {
    return false;
  }
  if (maxRecursiveInlining > 0 && invokers.length() > maxRecursiveInlining) {
    return false;
  }
  if (maxInlineSize > 0 && invokee.getCode().getNumberOfBytes() > maxInlineSize) {
    return false;
  }
  if (inlineConfig.doExcludeMethod(invoker)) {
    return false;
  }
  if (inlineConfig.doExcludeMethod(invokee)) {
    return false;
  }
  if (jcopter.useWCA()) {
    for (    MethodInfo method : jcopter.getJConfig().getWCATargets()) {
      if (method.equals(invokee)) {
        return false;
      }
    }
  }
  if (!inlineConfig.doInlineLibraries() && (AppInfo.getSingleton().isLibrary(invokee.getClassName()) || AppInfo.getSingleton().isLibrary(invoker.getClassName()))) {
    return false;
  }
  return invoker.canAccess(invokee);
}",0.9470178625491976
186715,"@Override public Collection<Candidate> findCandidates(MethodInfo method,AnalysisManager analyses,StacksizeAnalysis stacksize,int maxLocals,InstructionHandle start,InstructionHandle end){
  List<Candidate> candidates=new LinkedList<Candidate>();
  MethodCode code=method.getCode();
  for (InstructionHandle ih=start; ih != null; ih=ih.getNext()) {
    if (code.isInvokeSite(ih)) {
      InvokeSite site=code.getInvokeSite(ih);
      CallString cs=new CallString(site);
      MethodInfo invokee=helper.devirtualize(cs);
      if (invokee == null)       continue;
      cs=getInlineCallString(code,ih).push(site);
      Candidate candidate=checkInvoke(code,cs,site,invokee,maxLocals);
      if (candidate == null) {
        continue;
      }
      if (!candidate.recalculate(analyses,stacksize)) {
        continue;
      }
      candidates.add(candidate);
    }
    if (ih == end)     break;
  }
  return candidates;
}","@Override public Collection<Candidate> findCandidates(MethodInfo method,AnalysisManager analyses,StacksizeAnalysis stacksize,int maxLocals,InstructionHandle start,InstructionHandle end){
  List<Candidate> candidates=new LinkedList<Candidate>();
  MethodCode code=method.getCode();
  InstructionHandle next=end.getNext();
  for (InstructionHandle ih=start; ih != next; ih=ih.getNext()) {
    if (code.isInvokeSite(ih)) {
      InvokeSite site=code.getInvokeSite(ih);
      CallString cs=new CallString(site);
      MethodInfo invokee=helper.devirtualize(cs);
      if (invokee == null)       continue;
      cs=getInlineCallString(code,ih).push(site);
      Candidate candidate=checkInvoke(code,cs,site,invokee,maxLocals);
      if (candidate == null) {
        continue;
      }
      if (!candidate.recalculate(analyses,stacksize)) {
        continue;
      }
      candidates.add(candidate);
    }
  }
  return candidates;
}",0.8599348534201955
186716,"/** 
 * Replace instructions in this code with an instruction list or a part of it. If the number of instructions to replace differs from the number of source instructions, instruction handles will be removed or inserted appropriately and the targets will be updated. <p> Instruction handles will be reused, so attached values and targets will not be lost if the new length is not shorter than the old length. Else instruction handles are removed and the targeters to removed instructions are updated to the instruction after the next instruction after the deleted instructions. </p>
 * @param replaceStart the first instruction in this code to replace
 * @param replaceCount the number of instructions in this code to replace
 * @param sourceInfo the MethodInfo containing the source instruction. If non-null, the instructions will be copiedusing the constant pool from the given MethodInfo. If null, the instructions will not be copied.
 * @param source the instructions to use as replacement.
 * @param sourceStart the first instruction in the source list to use for replacing the code.
 * @param sourceCount the number of instructions to use from the source.
 * @param copyCustomValues if true copy the custom values from the source.
 * @return the first handle in the target list after the inserted code, or null if the last instruction in thislist has been replaced.
 */
public InstructionHandle replace(InstructionHandle replaceStart,int replaceCount,MethodInfo sourceInfo,InstructionList source,InstructionHandle sourceStart,int sourceCount,boolean copyCustomValues){
  InstructionList il=getInstructionList();
  InstructionHandle current=replaceStart;
  InstructionHandle currSource=sourceStart;
  int cnt=Math.min(replaceCount,sourceCount);
  for (int i=0; i < cnt; i++) {
    Instruction instr;
    if (sourceInfo != null) {
      instr=copyFrom(sourceInfo.getClassInfo(),currSource.getInstruction());
    }
 else {
      instr=currSource.getInstruction();
    }
    current.setInstruction(instr);
    if (copyCustomValues) {
      copyCustomValues(sourceInfo,current,currSource);
    }
    current=current.getNext();
    currSource=currSource.getNext();
  }
  InstructionHandle next=current;
  if (replaceCount > sourceCount) {
    int rest=replaceCount - sourceCount;
    for (int i=1; i < rest; i++) {
      next=next.getNext();
    }
    InstructionHandle end=next;
    next=next.getNext();
    try {
      il.delete(current,end);
    }
 catch (    TargetLostException e) {
      retarget(e,next);
    }
  }
  if (replaceCount < sourceCount) {
    int rest=sourceCount - replaceCount;
    for (int i=0; i < rest; i++) {
      Instruction instr;
      if (sourceInfo != null) {
        instr=copyFrom(sourceInfo.getClassInfo(),currSource.getInstruction());
      }
 else {
        instr=currSource.getInstruction();
      }
      if (next == null) {
        current=il.append(instr);
      }
 else {
        current=il.insert(next,instr);
      }
      if (copyCustomValues) {
        copyCustomValues(sourceInfo,current,currSource);
      }
      currSource=currSource.getNext();
    }
  }
  return next;
}","/** 
 * Replace instructions in this code with an instruction list or a part of it. If the number of instructions to replace differs from the number of source instructions, instruction handles will be removed or inserted appropriately and the targets will be updated. <p> Instruction handles will be reused, so attached values and targets will not be lost if the new length is not shorter than the old length. Else instruction handles are removed and the targeters to removed instructions are updated to the instruction after the next instruction after the deleted instructions. </p>
 * @param replaceStart the first instruction in this code to replace
 * @param replaceCount the number of instructions in this code to replace
 * @param sourceInfo the MethodInfo containing the source instruction. If non-null, the instructions will be copiedusing the constant pool from the given MethodInfo. If null, the instructions will not be copied.
 * @param sourceStart the first instruction in the source list to use for replacing the code.
 * @param sourceCount the number of instructions to use from the source.
 * @param copyCustomValues if true copy the custom values from the source.
 * @return the first handle in the target list after the inserted code, or null if the last instruction in thislist has been replaced.
 */
public InstructionHandle replace(InstructionHandle replaceStart,int replaceCount,MethodInfo sourceInfo,InstructionHandle sourceStart,int sourceCount,boolean copyCustomValues){
  InstructionList il=getInstructionList();
  InstructionHandle current=replaceStart;
  InstructionHandle currSource=sourceStart;
  int cnt=Math.min(replaceCount,sourceCount);
  for (int i=0; i < cnt; i++) {
    Instruction instr;
    if (sourceInfo != null) {
      instr=copyFrom(sourceInfo.getClassInfo(),currSource.getInstruction());
    }
 else {
      instr=currSource.getInstruction();
    }
    current.setInstruction(instr);
    if (copyCustomValues) {
      copyCustomValues(sourceInfo,current,currSource);
    }
    current=current.getNext();
    currSource=currSource.getNext();
  }
  InstructionHandle next=current;
  if (replaceCount > sourceCount) {
    int rest=replaceCount - sourceCount;
    for (int i=1; i < rest; i++) {
      next=next.getNext();
    }
    InstructionHandle end=next;
    next=next.getNext();
    try {
      il.delete(current,end);
    }
 catch (    TargetLostException e) {
      retarget(e,next);
    }
  }
  if (replaceCount < sourceCount) {
    int rest=sourceCount - replaceCount;
    for (int i=0; i < rest; i++) {
      Instruction instr;
      if (sourceInfo != null) {
        instr=copyFrom(sourceInfo.getClassInfo(),currSource.getInstruction());
      }
 else {
        instr=currSource.getInstruction();
      }
      if (next == null) {
        current=il.append(instr);
      }
 else {
        current=il.insert(next,instr);
      }
      if (copyCustomValues) {
        copyCustomValues(sourceInfo,current,currSource);
      }
      currSource=currSource.getNext();
    }
  }
  return next;
}",0.9870172022070756
186717,"private InstructionHandle copyInstruction(MethodCode invokeeCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=instr.copy();
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}","private InstructionHandle copyInstruction(MethodCode invokeeCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=invokeSite.getInvoker().getCode().copyFrom(invokee.getClassInfo(),instr);
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}",0.975451263537906
186718,"/** 
 * Try to inline a simple getter, wrapper or stub method. <p> If the inlined code is again an invoke, the InvokeSite does not change because the InstructionHandle of the invoker's invoke is kept.</p>
 * @param invokeSite the invoke to replace.
 * @param invokee the method to inline.
 * @param inlineData the parameters of the invokee and the code to inline.
 * @return true if inlining has been performed.
 */
private InvokeSite performSimpleInline(InvokeSite invokeSite,MethodInfo invokee,InlineData inlineData){
  MethodInfo invoker=invokeSite.getInvoker();
  MethodCode invokerCode=invoker.getCode();
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + invokeSite + ""String_Node_Str""+ invokee);
  }
  helper.prepareInlining(invoker,invokee);
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  if (inlineData.getOldPrologueLength() > 0) {
    InstructionHandle start=invoke;
    for (int i=0; i < inlineData.getOldPrologueLength(); i++) {
      start=start.getPrev();
    }
    invokerCode.replace(start,inlineData.getOldPrologueLength(),inlineData.getPrologue(),false);
  }
 else   if (inlineData.getPrologue().getLength() > 0) {
    if (invoke.hasTargeters()) {
      invokerCode.retarget(invoke,inlineData.getPrologue().getStart());
    }
    InstructionList il=invokerCode.getInstructionList();
    il.insert(invoke,inlineData.getPrologue());
  }
  InstructionList il=invokee.getCode().getInstructionList();
  InstructionHandle start=invokee.getCode().getInstructionHandle(inlineData.getInlineStart());
  int cnt=il.getLength() - inlineData.getInlineStart();
  if (il.getEnd().getInstruction() instanceof ReturnInstruction) {
    cnt--;
  }
  InstructionHandle end=invokerCode.replace(invoke,1,invokee,il,start,cnt,false);
  invokerCode.getInstructionList().insert(end,inlineData.getEpilogue());
  if (inlineData.getInvokeSite() != null) {
    end=end.getPrev();
    while (end != null) {
      if (invokerCode.isInvokeSite(end)) {
        return invokerCode.getInvokeSite(end);
      }
      end=end.getPrev();
    }
  }
  return null;
}","/** 
 * Try to inline a simple getter, wrapper or stub method. <p> If the inlined code is again an invoke, the InvokeSite does not change because the InstructionHandle of the invoker's invoke is kept.</p>
 * @param invokeSite the invoke to replace.
 * @param invokee the method to inline.
 * @param inlineData the parameters of the invokee and the code to inline.
 * @return true if inlining has been performed.
 */
private InvokeSite performSimpleInline(InvokeSite invokeSite,MethodInfo invokee,InlineData inlineData){
  MethodInfo invoker=invokeSite.getInvoker();
  MethodCode invokerCode=invoker.getCode();
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + invokeSite + ""String_Node_Str""+ invokee);
  }
  helper.prepareInlining(invoker,invokee);
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  if (inlineData.getOldPrologueLength() > 0) {
    InstructionHandle start=invoke;
    for (int i=0; i < inlineData.getOldPrologueLength(); i++) {
      start=start.getPrev();
    }
    invokerCode.replace(start,inlineData.getOldPrologueLength(),inlineData.getPrologue(),false);
  }
 else   if (inlineData.getPrologue().getLength() > 0) {
    if (invoke.hasTargeters()) {
      invokerCode.retarget(invoke,inlineData.getPrologue().getStart());
    }
    InstructionList il=invokerCode.getInstructionList();
    il.insert(invoke,inlineData.getPrologue());
  }
  InstructionList il=invokee.getCode().getInstructionList();
  InstructionHandle start=invokee.getCode().getInstructionHandle(inlineData.getInlineStart());
  int cnt=il.getLength() - inlineData.getInlineStart();
  if (il.getEnd().getInstruction() instanceof ReturnInstruction) {
    cnt--;
  }
  InstructionHandle end=invokerCode.replace(invoke,1,invokee,start,cnt,false);
  invokerCode.getInstructionList().insert(end,inlineData.getEpilogue());
  if (inlineData.getInvokeSite() != null) {
    end=end.getPrev();
    while (end != null) {
      if (invokerCode.isInvokeSite(end)) {
        return invokerCode.getInvokeSite(end);
      }
      end=end.getPrev();
    }
  }
  return null;
}",0.9992786727578744
186719,"/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    List<String> libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    List<String> ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.EXCLUDE_NATIVES)) {
    appInfo.setLoadNatives(!config.getOption(Config.EXCLUDE_NATIVES));
  }
  appInfo.setCallstringLength(config.getOption(Config.CALLSTRING_LENGTH).intValue());
  for (  String hwObject : Config.splitStringList(config.getOption(Config.HW_OBJECTS))) {
    appInfo.addHwObjectName(hwObject);
  }
  if (config.hasOption(Config.LOAD_SOURCELINES)) {
    String filename=config.getOption(Config.LOAD_SOURCELINES);
    if (filename != null && !""String_Node_Str"".equals(filename.trim())) {
      File storage=new File(filename);
      if (storage.exists()) {
        appInfo.registerEventHandler(new SourceLineStorage(storage));
      }
    }
  }
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  if (config.hasOption(Config.PROCESSOR_MODEL)) {
    initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  }
  List<String> roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.out.flush();
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  String mainClassName=null;
  if (args.length > 0 && !""String_Node_Str"".equals(args[0])) {
    mainClassName=args[0];
  }
 else   if (config.hasOption(Config.MAIN_METHOD_NAME)) {
    mainClassName=MemberID.parse(config.getOption(Config.MAIN_METHOD_NAME)).getClassName();
  }
 else {
    System.out.flush();
    System.err.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  try {
    MethodInfo main=getMainMethod(mainClassName.replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.out.flush();
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupRoots(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.out.flush();
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (loadTransitiveHull) {
    loadClassInfos();
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupAppInfo(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.out.flush();
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
}","/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    List<String> libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    List<String> ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.EXCLUDE_NATIVES)) {
    appInfo.setLoadNatives(!config.getOption(Config.EXCLUDE_NATIVES));
  }
  appInfo.setCallstringLength(config.getOption(Config.CALLSTRING_LENGTH).intValue());
  for (  String hwObject : Config.splitStringList(config.getOption(Config.HW_OBJECTS))) {
    appInfo.addHwObjectName(hwObject);
  }
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  if (config.hasOption(Config.PROCESSOR_MODEL)) {
    initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  }
  List<String> roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.out.flush();
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  String mainClassName=null;
  if (args.length > 0 && !""String_Node_Str"".equals(args[0])) {
    mainClassName=args[0];
  }
 else   if (config.hasOption(Config.MAIN_METHOD_NAME)) {
    mainClassName=MemberID.parse(config.getOption(Config.MAIN_METHOD_NAME)).getClassName();
  }
 else {
    System.out.flush();
    System.err.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  try {
    MethodInfo main=getMainMethod(mainClassName.replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.out.flush();
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupRoots(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.out.flush();
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (loadTransitiveHull) {
    loadClassInfos();
    if (config.hasOption(Config.LOAD_SOURCELINES)) {
      String filename=config.getOption(Config.LOAD_SOURCELINES);
      if (filename != null && !""String_Node_Str"".equals(filename.trim())) {
        File storage=new File(filename);
        if (storage.exists()) {
          new SourceLineStorage(storage).loadSourceInfos();
        }
      }
    }
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupAppInfo(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.out.flush();
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
}",0.4321014651213645
186720,"@Override public String toString(){
  return memberId.toString();
}","@Override public String toString(){
  return memberId.toString(false);
}",0.9640287769784172
186721,"/** 
 * @return all source code lines this basic block maps to
 */
public TreeSet<Integer> getSourceLineRange(){
  TreeSet<Integer> lines=new TreeSet<Integer>();
  for (  InstructionHandle ih : instructions) {
    int sourceLine=methodCode.getLineNumber(ih);
    if (sourceLine >= 0)     lines.add(sourceLine);
  }
  return lines;
}","/** 
 * @return all source code lines this basic block maps to
 */
public TreeSet<Integer> getSourceLineRange(){
  TreeSet<Integer> lines=new TreeSet<Integer>();
  for (  InstructionHandle ih : instructions) {
    LineNumberGen gen=methodCode.getLineNumberEntry(ih,ih == instructions.getFirst());
    int sourceLine=gen != null ? gen.getSourceLine() : -1;
    if (sourceLine >= 0)     lines.add(sourceLine);
  }
  return lines;
}",0.7910643889618922
186722,"@Override public void onCreateClass(ClassInfo classInfo,boolean loaded){
  if (!loaded)   return;
  try {
    if (AppInfo.getSingleton().getClassFile(classInfo).getTime() > storage.lastModified()) {
      logger.error(""String_Node_Str"" + classInfo + ""String_Node_Str""+ storage+ ""String_Node_Str"");
      return;
    }
    for (    MethodInfo method : classInfo.getMethods()) {
      if (!method.hasCode())       continue;
      List<SourceLineEntry> entries=sourceLineMap.get(method);
      if (entries == null)       continue;
      applySourceInfos(method,entries);
    }
  }
 catch (  FileNotFoundException e) {
    logger.warn(""String_Node_Str"",e);
  }
}","@Override public void onCreateClass(ClassInfo classInfo,boolean loaded){
  if (!loaded)   return;
  try {
    if (AppInfo.getSingleton().getClassFile(classInfo).getTime() > storage.lastModified()) {
      logger.error(""String_Node_Str"" + classInfo + ""String_Node_Str""+ storage+ ""String_Node_Str"");
      return;
    }
    for (    MethodInfo method : classInfo.getMethods()) {
      if (!method.hasCode())       continue;
      List<SourceLineEntry> entries=sourceLineMap.get(method.getMemberID());
      if (entries == null)       continue;
      applySourceInfos(method,entries);
    }
  }
 catch (  FileNotFoundException e) {
    logger.warn(""String_Node_Str"",e);
  }
}",0.9894736842105264
186723,"/** 
 * Load all source file and -line annotations for all classes from the storage file.
 * @throws IOException on file read errors
 */
public void loadSourceInfos() throws IOException {
  if (sourceLineMap == null) {
    readSourceInfos();
  }
  for (  MethodInfo method : sourceLineMap.keySet()) {
    if (AppInfo.getSingleton().getClassFile(method.getClassInfo()).getTime() > storage.lastModified()) {
      logger.error(""String_Node_Str"" + storage + ""String_Node_Str"");
      return;
    }
  }
  for (  Map.Entry<MethodInfo,List<SourceLineEntry>> entry : sourceLineMap.entrySet()) {
    MethodInfo method=entry.getKey();
    applySourceInfos(method,entry.getValue());
  }
}","/** 
 * Load all source file and -line annotations for all classes from the storage file.
 */
public void loadSourceInfos(){
  if (sourceLineMap == null) {
    try {
      readSourceInfos();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + storage,e);
    }
  }
  Map<MethodInfo,List<SourceLineEntry>> methodMap=new HashMap<MethodInfo,List<SourceLineEntry>>(sourceLineMap.size());
  for (  MemberID mID : sourceLineMap.keySet()) {
    try {
      MethodInfo method=AppInfo.getSingleton().getMethodInfo(mID);
      methodMap.put(method,sourceLineMap.get(mID));
    }
 catch (    MethodNotFoundException ignored) {
      logger.warn(""String_Node_Str"" + mID + ""String_Node_Str""+ storage+ ""String_Node_Str"");
    }
  }
  for (  MethodInfo method : methodMap.keySet()) {
    try {
      if (AppInfo.getSingleton().getClassFile(method.getClassInfo()).getTime() > storage.lastModified()) {
        logger.error(""String_Node_Str"" + storage + ""String_Node_Str"");
        return;
      }
    }
 catch (    FileNotFoundException e) {
      logger.error(""String_Node_Str"" + method.getClassInfo() + ""String_Node_Str"",e);
      return;
    }
  }
  for (  Map.Entry<MethodInfo,List<SourceLineEntry>> entry : methodMap.entrySet()) {
    MethodInfo method=entry.getKey();
    applySourceInfos(method,entry.getValue());
  }
}",0.3651741293532338
186724,"@Override public void onSuccessfulOptimize(Candidate optimized,List<Candidate> newCandidates){
  globalCodesize+=getDeltaGlobalCodesize(optimized);
  Collection<MethodInfo> unreachable=optimized.getUnreachableMethods();
  if (unreachable != null && !unreachable.isEmpty()) {
    for (    MethodInfo m : unreachable) {
      removeCandidates(m);
    }
  }
  removeCandidates(optimized.getMethod(),optimized.getStart(),optimized.getEnd());
  addCandidates(optimized.getMethod(),newCandidates);
}","@Override public void onSuccessfulOptimize(Candidate optimized,List<Candidate> newCandidates){
  globalCodesize+=getDeltaGlobalCodesize(optimized);
  Collection<MethodInfo> unreachable=optimized.getUnreachableMethods();
  if (unreachable != null && !unreachable.isEmpty()) {
    for (    MethodInfo m : unreachable) {
      removeCandidates(m);
    }
  }
  removeCandidate(optimized);
  removeCandidates(optimized.getMethod(),optimized.getStart(),optimized.getEnd());
  addCandidates(optimized.getMethod(),newCandidates);
}",0.970472440944882
186725,"private InstructionHandle copyInstruction(MethodCode invokeeCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=invokeSite.getInvoker().getCode().copyFrom(invokee.getClassInfo(),instr);
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}","private InstructionHandle copyInstruction(MethodCode invokerCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=invokerCode.copyFrom(invokee.getClassInfo(),instr);
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}",0.9907407407407408
186726,"private Map<InvokeSite,InvokeSite> insertInvokee(AnalysisManager analyses,CallString callString,InstructionList il,InstructionHandle next){
  MethodCode code=getMethod().getCode();
  MethodCode invokeeCode=invokee.getCode();
  InstructionList iList=invokeeCode.getInstructionList(true,false);
  Map<InstructionHandle,InstructionHandle> instrMap=new HashMap<InstructionHandle,InstructionHandle>();
  Map<InvokeSite,InvokeSite> invokeMap=new HashMap<InvokeSite,InvokeSite>();
  StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(invokee);
  for (InstructionHandle src=iList.getStart(); src != null; src=src.getNext()) {
    InstructionHandle ih=copyInstruction(invokeeCode,stacksize,il,src,next);
    if (ih == null)     continue;
    code.copyCustomValues(invokee,ih,src);
    if (code.isInvokeSite(ih)) {
      InvokeSite newInvoke=code.getInvokeSite(ih);
      InvokeSite oldInvoke=invokeeCode.getInvokeSite(src);
      invokeMap.put(oldInvoke,newInvoke);
      setInlineCallString(code,ih,callString);
    }
    instrMap.put(src,ih);
  }
  remapTargets(instrMap,next);
  return invokeMap;
}","private Map<InvokeSite,InvokeSite> insertInvokee(AnalysisManager analyses,CallString callString,InstructionList il,InstructionHandle next){
  MethodCode code=getMethod().getCode();
  MethodCode invokeeCode=invokee.getCode();
  InstructionList iList=invokeeCode.getInstructionList(true,false);
  Map<InstructionHandle,InstructionHandle> instrMap=new HashMap<InstructionHandle,InstructionHandle>();
  Map<InvokeSite,InvokeSite> invokeMap=new HashMap<InvokeSite,InvokeSite>();
  StacksizeAnalysis stacksize=analyses.getStacksizeAnalysis(invokee);
  for (InstructionHandle src=iList.getStart(); src != null; src=src.getNext()) {
    InstructionHandle ih=copyInstruction(code,stacksize,il,src,next);
    if (ih == null)     continue;
    code.copyCustomValues(invokee,ih,src);
    if (code.isInvokeSite(ih)) {
      InvokeSite newInvoke=code.getInvokeSite(ih);
      InvokeSite oldInvoke=invokeeCode.getInvokeSite(src);
      invokeMap.put(oldInvoke,newInvoke);
      setInlineCallString(code,ih,callString);
    }
    instrMap.put(src,ih);
  }
  remapTargets(instrMap,next);
  return invokeMap;
}",0.9958922866271108
186727,"/** 
 * Copy an existing node, and replace the callstring of the node with a new callstring. All reachable nodes are also copied using the new callstring if they do not exist.
 * @param source the node to copy
 * @param newContext the new callstring for the new node
 * @param callstringLength the maximum callstring length for new nodes.
 * @return the new node
 */
public ExecutionContext copyNodeRecursive(ExecutionContext source,CallString newContext,int callstringLength){
  ExecutionContext root=new ExecutionContext(source.getMethodInfo(),newContext);
  if (callGraph.containsVertex(root)) {
    return root;
  }
  callGraph.addVertex(root);
  List<ExecutionContext> newQueue=new LinkedList<ExecutionContext>();
  List<ExecutionContext> oldQueue=new LinkedList<ExecutionContext>();
  oldQueue.add(source);
  newQueue.add(root);
  while (!newQueue.isEmpty()) {
    ExecutionContext newNode=newQueue.remove(0);
    ExecutionContext oldNode=oldQueue.remove(0);
    for (    ExecutionContext oldChild : getChildren(oldNode)) {
      CallString newString;
      if (oldChild.getCallString().isEmpty()) {
        newString=CallString.EMPTY;
      }
 else {
        newString=newNode.getCallString().push(oldChild.getCallString().top(),callstringLength);
      }
      ExecutionContext newChild=new ExecutionContext(oldChild.getMethodInfo(),newString);
      if (!callGraph.containsVertex(newChild)) {
        oldQueue.add(oldChild);
        newQueue.add(newChild);
      }
      callGraph.addEdge(newNode,newChild);
    }
  }
  return root;
}","/** 
 * Copy an existing node, and replace the callstring of the node with a new callstring. All reachable nodes are also copied using the new callstring if they do not exist.
 * @param source the node to copy
 * @param newContext the new callstring for the new node
 * @param callstringLength the maximum callstring length for new nodes.
 * @return the new node
 */
public ExecutionContext copyNodeRecursive(ExecutionContext source,CallString newContext,int callstringLength){
  ExecutionContext root=new ExecutionContext(source.getMethodInfo(),newContext);
  if (callGraph.containsVertex(root)) {
    return root;
  }
  callGraph.addVertex(root);
  List<ExecutionContext> newQueue=new LinkedList<ExecutionContext>();
  List<ExecutionContext> oldQueue=new LinkedList<ExecutionContext>();
  oldQueue.add(source);
  newQueue.add(root);
  while (!newQueue.isEmpty()) {
    ExecutionContext newNode=newQueue.remove(0);
    ExecutionContext oldNode=oldQueue.remove(0);
    for (    ExecutionContext oldChild : getChildren(oldNode)) {
      CallString newString;
      if (oldChild.getCallString().isEmpty()) {
        newString=CallString.EMPTY;
      }
 else {
        newString=newNode.getCallString().push(oldChild.getCallString().top(),callstringLength);
      }
      ExecutionContext newChild=new ExecutionContext(oldChild.getMethodInfo(),newString);
      if (!callGraph.containsVertex(newChild)) {
        callGraph.addVertex(newChild);
        oldQueue.add(oldChild);
        newQueue.add(newChild);
      }
      callGraph.addEdge(newNode,newChild);
    }
  }
  return root;
}",0.98752
186728,"private InstructionHandle copyInstruction(MethodCode invokerCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=invokerCode.copyFrom(invokee.getClassInfo(),instr);
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}","private InstructionHandle copyInstruction(MethodCode invokerCode,StacksizeAnalysis stacksize,InstructionList il,InstructionHandle src,InstructionHandle next){
  InstructionHandle ih;
  Instruction instr=src.getInstruction();
  Instruction c=invokerCode.copyFrom(invokee.getClassInfo(),instr);
  if (instr instanceof LocalVariableInstruction) {
    int slot=maxLocals + ((LocalVariableInstruction)instr).getIndex();
    ((LocalVariableInstruction)c).setIndex(slot);
    ih=il.insert(next,c);
  }
 else   if (instr instanceof ReturnInstruction) {
    if (src.getNext() != null) {
      c=new GOTO(next);
      ih=il.insert(next,(BranchInstruction)c);
    }
 else {
      ih=null;
    }
    int stack=stacksize.getStacksizeBefore(src);
    Type type=((ReturnInstruction)instr).getType();
    stack-=type.getSize();
    if (stack != 0) {
      Instruction store=TypeHelper.createStoreInstruction(type,maxLocals);
      ih=il.insert(ih == null ? next : ih,store);
      Instruction load=TypeHelper.createLoadInstruction(type,maxLocals);
      il.append(ih,load);
      while (stack > 0) {
        if (stack > 1) {
          il.append(ih,new POP2());
          stack-=2;
        }
 else {
          il.append(ih,new POP());
          stack--;
        }
      }
    }
  }
 else   if (c instanceof BranchInstruction) {
    ih=il.insert(next,(BranchInstruction)c);
  }
 else {
    ih=il.insert(next,c);
  }
  return ih;
}",0.9932263814616756
186729,"private void remapTargets(Map<InstructionHandle,InstructionHandle> instrMap,InstructionHandle next){
  for (  Map.Entry<InstructionHandle,InstructionHandle> e : instrMap.entrySet()) {
    InstructionHandle oldIh=e.getKey();
    InstructionHandle newIh=e.getValue();
    Instruction i=oldIh.getInstruction();
    Instruction c=newIh.getInstruction();
    if (c instanceof BranchInstruction) {
      BranchInstruction bi=(BranchInstruction)i;
      BranchInstruction bc=(BranchInstruction)c;
      InstructionHandle target=bi.getTarget();
      if (bi instanceof Select) {
        InstructionHandle[] targets=((Select)bi).getTargets();
        for (int j=0; j < targets.length; j++) {
          InstructionHandle newTarget=instrMap.get(targets[j]);
          ((Select)bc).setTarget(j,newTarget != null ? newTarget : next);
        }
      }
      InstructionHandle newTarget=instrMap.get(target);
      bc.setTarget(newTarget != null ? newTarget : next);
    }
  }
}","private void remapTargets(Map<InstructionHandle,InstructionHandle> instrMap,InstructionHandle next){
  for (  Map.Entry<InstructionHandle,InstructionHandle> e : instrMap.entrySet()) {
    InstructionHandle oldIh=e.getKey();
    InstructionHandle newIh=e.getValue();
    Instruction i=oldIh.getInstruction();
    Instruction c=newIh.getInstruction();
    if (i instanceof BranchInstruction) {
      BranchInstruction bi=(BranchInstruction)i;
      BranchInstruction bc=(BranchInstruction)c;
      InstructionHandle target=bi.getTarget();
      if (bi instanceof Select) {
        InstructionHandle[] targets=((Select)bi).getTargets();
        for (int j=0; j < targets.length; j++) {
          InstructionHandle newTarget=instrMap.get(targets[j]);
          ((Select)bc).setTarget(j,newTarget != null ? newTarget : next);
        }
      }
      InstructionHandle newTarget=instrMap.get(target);
      bc.setTarget(newTarget != null ? newTarget : next);
    }
  }
}",0.9989626556016598
186730,"public Set<ExecutionContext> getInstances(){
  return instances;
}","public Set<ExecutionContext> getInstances(){
  return Collections.unmodifiableSet(instances);
}",0.8198757763975155
186731,"public void inline(InvokeSite invokeSite,MethodInfo invokee){
  updateCodesize(invokeSite.getInvoker());
  onExecCountUpdate();
}","public void inline(InvokeSite invokeSite,MethodInfo invokee){
  Set<ExecutionContext> nodes=new HashSet<ExecutionContext>(callGraph.getNodes(invokeSite.getInvoker()));
  List<ExecutionContext> queue=new LinkedList<ExecutionContext>(nodes);
  while (!queue.isEmpty()) {
    ExecutionContext node=queue.remove(0);
    for (    ExecutionContext child : callGraph.getChildren(node)) {
      if (!cacheBlocks.containsKey(child) && !nodes.contains(child)) {
        nodes.add(child);
        queue.add(child);
      }
    }
  }
  updateCodesize(nodes);
  onExecCountUpdate();
}",0.3
186732,"public void updateCodesize(MethodInfo method){
  updateBlockCounts(callGraph.getNodes(method));
}","public void updateCodesize(Set<ExecutionContext> nodes){
  updateBlockCounts(nodes);
}",0.6885245901639344
186733,"@Override public boolean optimize(AnalysisManager analyses,StacksizeAnalysis stacksize){
  MethodCode code=getMethod().getCode();
  InstructionList il=code.getInstructionList();
  assert(start == end);
  InstructionHandle invoke=start;
  InstructionHandle next=end.getNext();
  insertPrologue(il,next);
  Map<InvokeSite,InvokeSite> invokeMap;
  CallString callString=getInlineCallString(code,invoke).push(invokeSite);
  invokeMap=insertInvokee(analyses,callString,il,next);
  start=invoke.getNext();
  end=next.getPrev();
  if (end == null) {
    start=null;
  }
  try {
    il.delete(invoke);
  }
 catch (  TargetLostException e) {
    code.retarget(e,start);
  }
  for (  CallGraph cg : analyses.getCallGraphs()) {
    updateCallgraph(cg,invokeMap);
  }
  updateAnalyses(analyses,invokeMap);
  isLastInvoke=!analyses.getAppInfoCallGraph().containsMethod(invokee);
  return true;
}","@Override public boolean optimize(AnalysisManager analyses,StacksizeAnalysis stacksize){
  MethodCode code=getMethod().getCode();
  InstructionList il=code.getInstructionList();
  assert(start == end);
  InstructionHandle invoke=start;
  InstructionHandle next=end.getNext();
  insertPrologue(il,next);
  Map<InvokeSite,InvokeSite> invokeMap;
  CallString callString=getInlineCallString(code,invoke).push(invokeSite);
  invokeMap=insertInvokee(analyses,callString,il,next);
  start=invoke.getNext();
  end=next.getPrev();
  if (end == null) {
    start=null;
  }
  try {
    il.delete(invoke);
  }
 catch (  TargetLostException e) {
    code.retarget(e,start);
  }
  il.setPositions();
  for (  CallGraph cg : analyses.getCallGraphs()) {
    updateCallgraph(cg,invokeMap);
  }
  updateAnalyses(analyses,invokeMap);
  isLastInvoke=!analyses.getAppInfoCallGraph().containsMethod(invokee);
  return true;
}",0.9882352941176472
186734,"private void updateCallgraph(CallGraph cg,Map<InvokeSite,InvokeSite> invokeMap){
  Ternary acyclic=cg.getAcyclicity();
  for (  ExecutionContext invoker : cg.getNodes(getMethod())) {
    for (    ExecutionContext invokeeNode : cg.getInvokedNodes(invoker,invokeSite,invokee)) {
      for (      ExecutionContext child : cg.getChildren(invokeeNode)) {
        ExecutionContext newInvokee;
        if (!child.getCallString().isEmpty()) {
          CallString cs=invoker.getCallString();
          cs=cs.push(invokeMap.get(child.getCallString().top()),appInfo.getCallstringLength());
          newInvokee=cg.copyNodeRecursive(child,cs,appInfo.getCallstringLength());
        }
 else {
          newInvokee=child;
        }
        cg.addEdge(invoker,newInvokee);
      }
    }
  }
  if (!cg.removeNodes(invokeSite,invokee,true)) {
    if (!searchInvokeSites()) {
      cg.removeEdges(getMethod(),invokee,true);
    }
  }
  if (acyclic != Ternary.UNKNOWN) {
    cg.setAcyclicity(acyclic == Ternary.TRUE);
  }
}","private void updateCallgraph(CallGraph cg,Map<InvokeSite,InvokeSite> invokeMap){
  Ternary acyclic=cg.getAcyclicity();
  List<ExecutionContext> nodes=new ArrayList<ExecutionContext>(cg.getNodes(getMethod()));
  for (  ExecutionContext invoker : nodes) {
    for (    ExecutionContext invokeeNode : cg.getInvokedNodes(invoker,invokeSite,invokee)) {
      for (      ExecutionContext child : cg.getChildren(invokeeNode)) {
        ExecutionContext newInvokee;
        if (!child.getCallString().isEmpty()) {
          CallString cs=invoker.getCallString();
          cs=cs.push(invokeMap.get(child.getCallString().top()),appInfo.getCallstringLength());
          newInvokee=cg.copyNodeRecursive(child,cs,appInfo.getCallstringLength());
        }
 else {
          newInvokee=child;
        }
        cg.addEdge(invoker,newInvokee);
      }
    }
  }
  if (!cg.removeNodes(invokeSite,invokee,true)) {
    if (!searchInvokeSites()) {
      cg.removeEdges(getMethod(),invokee,true);
    }
  }
  if (acyclic != Ternary.UNKNOWN) {
    cg.setAcyclicity(acyclic == Ternary.TRUE);
  }
}",0.9428159538683324
186735,"HighResolutionTime add(long millis,int nanos,HighResolutionTime dest){
  dest.set(addSafe(this.millis,millis),((long)this.nanos) + nanos);
  return dest;
}","/** 
 * Behaves exactly like target.wait() but with the enhancement that it waits with a precision of HighResolutionTime.
 * @param target The object on which to wait. The current thread must have a lock on the object.
 * @param time The time for which to wait. If it is RelativeTime(0,0) then wait indefinitely. If it is null then wait indefinitely.
 * @throws java.lang.InterruptedException
 */
HighResolutionTime add(long millis,int nanos,HighResolutionTime dest){
  dest.set(addSafe(this.millis,millis),((long)this.nanos) + nanos);
  return dest;
}",0.4384724186704384
186736,"@Override public void visitSelect(Select obj){
  super.visitSelect(obj);
  for (  InstructionHandle tih : obj.getTargets()) {
    flowInfo.addTarget(tih,ControlFlowGraph.EdgeKind.SELECT_EDGE);
    this.targeted.add(tih);
  }
}","@Override public void visitSelect(Select obj){
  super.visitSelect(obj);
  flowInfo.addTarget(obj.getTarget(),ControlFlowGraph.EdgeKind.SELECT_EDGE);
  this.targeted.add(obj.getTarget());
  for (  InstructionHandle tih : obj.getTargets()) {
    flowInfo.addTarget(tih,ControlFlowGraph.EdgeKind.SELECT_EDGE);
    this.targeted.add(tih);
  }
}",0.5925925925925926
186737,"public static AnnotationElementValue createValue(DataInputStream in,ConstantPool cp) throws IOException {
  byte tag=in.readByte();
switch (tag) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'T':
case 'J':
case 'S':
case 'Z':
case 's':
    short constValueIndex=in.readShort();
  return new AnnotationElementValue(tag,cp,constValueIndex);
case 'e':
case 'c':
case '@':
case '[':
default :
throw new UnsupportedOperationException(""String_Node_Str"" + ((char)tag) + ""String_Node_Str"");
}
}","public static AnnotationElementValue createValue(DataInputStream in,ConstantPool cp) throws IOException {
  byte tag=in.readByte();
switch (tag) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'T':
case 'J':
case 'S':
case 'Z':
case 's':
    short constValueIndex=in.readShort();
  return new AnnotationElementValue(tag,cp,constValueIndex);
case 'e':
short typeNameIndex=in.readShort();
short constNameIndex=in.readShort();
return new AnnotationElementValue(tag,cp,typeNameIndex,constNameIndex);
case 'c':
short classInfoIndex=in.readShort();
return new AnnotationElementValue(tag,cp,classInfoIndex);
case '@':
Annotation annotation=Annotation.createAnnotation(in,cp);
return new AnnotationElementValue(tag,cp,annotation);
case '[':
short numValues=in.readShort();
List<AnnotationElementValue> arrayValue=new ArrayList<AnnotationElementValue>(numValues);
for (int i=0; i < numValues; i++) {
arrayValue.add(createValue(in,cp));
}
return new AnnotationElementValue(tag,cp,arrayValue);
default :
throw new UnsupportedOperationException(""String_Node_Str"" + ((char)tag) + ""String_Node_Str"");
}
}",0.6065989847715736
186738,"public int length(){
switch (tag) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'T':
case 'J':
case 'S':
case 'Z':
case 's':
    return 3;
case 'e':
case 'c':
case '@':
case '[':
default :
  throw new UnsupportedOperationException(""String_Node_Str"" + ((char)tag) + ""String_Node_Str"");
}
}","public int length(){
switch (tag) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'T':
case 'J':
case 'S':
case 'Z':
case 's':
    return 3;
case 'e':
  return 5;
case 'c':
return 3;
case '@':
return 1 + annotation.length();
case '[':
int length=3;
for (AnnotationElementValue ev : arrayValue) {
length+=ev.length();
}
return length;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + ((char)tag) + ""String_Node_Str"");
}
}",0.7626886145404664
186739,"public void dump(DataOutputStream out) throws IOException {
  out.writeByte(tag);
switch (tag) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'T':
case 'J':
case 'S':
case 'Z':
case 's':
    out.writeShort(constValueIndex);
  return;
case 'e':
case 'c':
case '@':
case '[':
default :
throw new UnsupportedOperationException(""String_Node_Str"" + ((char)tag) + ""String_Node_Str"");
}
}","public void dump(DataOutputStream out) throws IOException {
  out.writeByte(tag);
switch (tag) {
case 'B':
case 'C':
case 'D':
case 'F':
case 'T':
case 'J':
case 'S':
case 'Z':
case 's':
    out.writeShort(constValueIndex);
  return;
case 'e':
out.writeShort(typeNameIndex);
out.writeShort(constNameIndex);
return;
case 'c':
out.writeShort(classInfoIndex);
return;
case '@':
annotation.dump(out);
return;
case '[':
out.writeShort(arrayValue.size());
for (AnnotationElementValue ev : arrayValue) {
ev.dump(out);
}
return;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + ((char)tag) + ""String_Node_Str"");
}
}",0.7373637264618434
186740,"public AnnotationElementValue(byte tag,ConstantPool constantPool,short constValueIndex){
  this.tag=tag;
  this.constantPool=constantPool;
  this.constValueIndex=constValueIndex;
}","public AnnotationElementValue(byte tag,ConstantPool constantPool,Annotation annotation){
  this.tag=tag;
  this.constantPool=constantPool;
  this.annotation=annotation;
}",0.8057142857142857
186741,"@Override public void visitSelect(Select obj){
  super.visitSelect(obj);
  for (  InstructionHandle tih : obj.getTargets()) {
    flowInfo.addTarget(tih,ControlFlowGraph.EdgeKind.SELECT_EDGE);
    this.targeted.add(tih);
  }
}","@Override public void visitSelect(Select obj){
  super.visitSelect(obj);
  flowInfo.addTarget(obj.getTarget(),ControlFlowGraph.EdgeKind.SELECT_EDGE);
  this.targeted.add(obj.getTarget());
  for (  InstructionHandle tih : obj.getTargets()) {
    flowInfo.addTarget(tih,ControlFlowGraph.EdgeKind.SELECT_EDGE);
    this.targeted.add(tih);
  }
}",0.5925925925925926
186742,"/** 
 * Get the flowgraph of the given method. <p> A new callgraph is constructed when this method is called, changes to this graph are not automatically stored back to MethodCode. If you want to keep changes to the graph you need to keep a reference to this graph yourself. </p>
 * @param mi the method to get the CFG for
 * @return the CFG for the method.
 */
public ControlFlowGraph getFlowGraph(MethodInfo mi){
  if (!mi.hasCode())   return null;
  ControlFlowGraph cfg;
  try {
    cfg=new ControlFlowGraph(mi,CallString.EMPTY,callGraph);
    cfg.resolveVirtualInvokes();
    cfg.insertReturnNodes();
    cfg.insertContinueLoopNodes();
  }
 catch (  BadGraphException e) {
    throw new BadGraphError(e.getMessage(),e);
  }
  return cfg;
}","/** 
 * Get the flowgraph of the given method. <p> A new callgraph is constructed when this method is called, changes to this graph are not automatically stored back to MethodCode. If you want to keep changes to the graph you need to keep a reference to this graph yourself. </p>
 * @param mi the method to get the CFG for
 * @return the CFG for the method.
 */
public ControlFlowGraph getFlowGraph(MethodInfo mi){
  if (!mi.hasCode())   return null;
  ControlFlowGraph cfg;
  try {
    cfg=mi.getCode().getControlFlowGraph(false);
    cfg.resolveVirtualInvokes();
    cfg.insertReturnNodes();
    cfg.insertContinueLoopNodes();
  }
 catch (  BadGraphException e) {
    throw new BadGraphError(e.getMessage(),e);
  }
  return cfg;
}",0.9634146341463414
186743,"@Override public void visitInvokeNode(ControlFlowGraph.InvokeNode n){
  if (n.getVirtualNode() != null) {
    Set<MethodInfo> actuallyReachable=n.getVirtualNode().getImplementedMethods(ctx.getCallString());
    if (!actuallyReachable.contains(n.getImplementedMethod()))     return;
  }
  cost.addLocalCost(processor.getExecutionTime(ctx.getExecutionContext(n),n.getInstructionHandle()));
  if (n.isVirtual()) {
    throw new AssertionError(""String_Node_Str"" + n.getReferenced() + ""String_Node_Str"");
  }
  cost.addCost(RecursiveWcetAnalysis.this.recursiveWCET.recursiveCost(RecursiveWcetAnalysis.this,n,ctx));
}","@Override public void visitInvokeNode(ControlFlowGraph.InvokeNode n){
  if (n.getVirtualNode() != null) {
    Set<MethodInfo> actuallyReachable=n.getVirtualNode().getImplementedMethods(ctx.getCallString(),project.getCallGraph());
    if (!actuallyReachable.contains(n.getImplementedMethod()))     return;
  }
  cost.addLocalCost(processor.getExecutionTime(ctx.getExecutionContext(n),n.getInstructionHandle()));
  if (n.isVirtual()) {
    throw new AssertionError(""String_Node_Str"" + n.getReferenced() + ""String_Node_Str"");
  }
  cost.addCost(RecursiveWcetAnalysis.this.recursiveWCET.recursiveCost(RecursiveWcetAnalysis.this,n,ctx));
}",0.9815261044176706
186744,"public void recordResult(WcetCost wcet,double timeDiff,double solverTime){
  if (resultRecord == null)   return;
  Config c=projectConfig.getConfig();
  if (projectConfig.addPerformanceResults()) {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,timeDiff,solverTime,c.getOption(JOPConfig.CACHE_IMPL),c.getOption(JOPConfig.CACHE_SIZE_WORDS),c.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(IPETConfig.STATIC_CACHE_APPROX),c.getOption(IPETConfig.ASSUME_MISS_ONCE_ON_INVOKE));
  }
 else {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,c.getOption(JOPConfig.CACHE_IMPL),c.getOption(JOPConfig.CACHE_SIZE_WORDS),c.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(IPETConfig.STATIC_CACHE_APPROX),c.getOption(IPETConfig.ASSUME_MISS_ONCE_ON_INVOKE));
  }
}","public void recordResult(WcetCost wcet,double timeDiff,double solverTime){
  if (resultRecord == null)   return;
  Config c=projectConfig.getConfig();
  OptionGroup o=JOPConfig.getOptions(c);
  if (projectConfig.addPerformanceResults()) {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,timeDiff,solverTime,o.getOption(JOPConfig.CACHE_IMPL),o.getOption(JOPConfig.CACHE_SIZE_WORDS),o.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(IPETConfig.STATIC_CACHE_APPROX),c.getOption(IPETConfig.ASSUME_MISS_ONCE_ON_INVOKE));
  }
 else {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,o.getOption(JOPConfig.CACHE_IMPL),o.getOption(JOPConfig.CACHE_SIZE_WORDS),o.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(IPETConfig.STATIC_CACHE_APPROX),c.getOption(IPETConfig.ASSUME_MISS_ONCE_ON_INVOKE));
  }
}",0.9660038486209108
186745,"public void recordResultUppaal(WcetCost wcet,double timeDiff,double searchtime,double solvertimemax){
  if (resultRecord == null)   return;
  Config c=projectConfig.getConfig();
  if (projectConfig.addPerformanceResults()) {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,timeDiff,searchtime,solvertimemax,c.getOption(JOPConfig.CACHE_IMPL),c.getOption(JOPConfig.CACHE_SIZE_WORDS),c.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(UppAalConfig.UPPAAL_CACHE_APPROX),c.getOption(UppAalConfig.UPPAAL_COMPLEXITY_TRESHOLD),c.getOption(UppAalConfig.UPPAAL_COLLAPSE_LEAVES),c.getOption(UppAalConfig.UPPAAL_CONVEX_HULL),c.getOption(UppAalConfig.UPPAAL_TIGHT_BOUNDS),c.getOption(UppAalConfig.UPPAAL_PROGRESS_MEASURE),c.getOption(UppAalConfig.UPPAAL_SUPERGRAPH_TEMPLATE),c.getOption(UppAalConfig.UPPAAL_EMPTY_INITIAL_CACHE));
  }
 else {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,c.getOption(JOPConfig.CACHE_IMPL),c.getOption(JOPConfig.CACHE_SIZE_WORDS),c.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(UppAalConfig.UPPAAL_CACHE_APPROX),c.getOption(UppAalConfig.UPPAAL_COMPLEXITY_TRESHOLD),c.getOption(UppAalConfig.UPPAAL_COLLAPSE_LEAVES),c.getOption(UppAalConfig.UPPAAL_CONVEX_HULL),c.getOption(UppAalConfig.UPPAAL_TIGHT_BOUNDS),c.getOption(UppAalConfig.UPPAAL_PROGRESS_MEASURE),c.getOption(UppAalConfig.UPPAAL_SUPERGRAPH_TEMPLATE),c.getOption(UppAalConfig.UPPAAL_EMPTY_INITIAL_CACHE));
  }
}","public void recordResultUppaal(WcetCost wcet,double timeDiff,double searchtime,double solvertimemax){
  if (resultRecord == null)   return;
  Config c=projectConfig.getConfig();
  OptionGroup o=JOPConfig.getOptions(c);
  if (projectConfig.addPerformanceResults()) {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,timeDiff,searchtime,solvertimemax,o.getOption(JOPConfig.CACHE_IMPL),o.getOption(JOPConfig.CACHE_SIZE_WORDS),o.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(UppAalConfig.UPPAAL_CACHE_APPROX),c.getOption(UppAalConfig.UPPAAL_COMPLEXITY_TRESHOLD),c.getOption(UppAalConfig.UPPAAL_COLLAPSE_LEAVES),c.getOption(UppAalConfig.UPPAAL_CONVEX_HULL),c.getOption(UppAalConfig.UPPAAL_TIGHT_BOUNDS),c.getOption(UppAalConfig.UPPAAL_PROGRESS_MEASURE),c.getOption(UppAalConfig.UPPAAL_SUPERGRAPH_TEMPLATE),c.getOption(UppAalConfig.UPPAAL_EMPTY_INITIAL_CACHE));
  }
 else {
    recordCVS(""String_Node_Str"",""String_Node_Str"",wcet,o.getOption(JOPConfig.CACHE_IMPL),o.getOption(JOPConfig.CACHE_SIZE_WORDS),o.getOption(JOPConfig.CACHE_BLOCKS),c.getOption(UppAalConfig.UPPAAL_CACHE_APPROX),c.getOption(UppAalConfig.UPPAAL_COMPLEXITY_TRESHOLD),c.getOption(UppAalConfig.UPPAAL_COLLAPSE_LEAVES),c.getOption(UppAalConfig.UPPAAL_CONVEX_HULL),c.getOption(UppAalConfig.UPPAAL_TIGHT_BOUNDS),c.getOption(UppAalConfig.UPPAAL_PROGRESS_MEASURE),c.getOption(UppAalConfig.UPPAAL_SUPERGRAPH_TEMPLATE),c.getOption(UppAalConfig.UPPAAL_EMPTY_INITIAL_CACHE));
  }
}",0.9813445969728968
186746,"@Override public Instruction createPushInstruction(ConstantPoolGen cpg){
  return null;
}","@Override public Instruction createPushInstruction(ConstantPoolGen cpg){
  FieldInfo fieldInfo=getValue().getFieldInfo();
  if (fieldInfo != null && fieldInfo.isStatic()) {
    return new GETSTATIC(addConstant(cpg));
  }
  return null;
}",0.4785276073619632
186747,"public boolean isConstantValue(){
  return constantValue != null || type.equals(Type.NULL);
}","public boolean isConstantValue(){
  return (constantValue != null && !(constantValue instanceof ConstantFieldInfo)) || Type.NULL.equals(type);
}",0.6835443037974683
186748,"public void push(ValueInfo value,boolean addContinueMarker){
  if (Type.VOID.equals(value.getType()))   return;
  stack.add(value);
  if (addContinueMarker && value.usesTwoSlots()) {
    stack.add(ValueInfo.CONTINUED);
  }
}","public void push(ValueInfo value,boolean addContinueMarker){
  if (Type.VOID.equals(value.getType()) && !value.isThisReference())   return;
  stack.add(value);
  if (addContinueMarker && value.usesTwoSlots()) {
    stack.add(ValueInfo.CONTINUED);
  }
}",0.9411764705882352
186749,"public void transfer(Instruction instruction){
switch (instruction.getOpcode()) {
case Constants.NOP:
    break;
case Constants.ACONST_NULL:
  values.push(new ValueInfo(Type.NULL));
break;
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
int value=instr.getValue().intValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantIntegerInfo(value)));
break;
}
case Constants.LCONST_0:
case Constants.LCONST_1:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
long value=instr.getValue().longValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantLongInfo(value)));
break;
}
case Constants.FCONST_0:
case Constants.FCONST_1:
case Constants.FCONST_2:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
float value=instr.getValue().floatValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantFloatInfo(value)));
break;
}
case Constants.DCONST_0:
case Constants.DCONST_1:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
double value=instr.getValue().doubleValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantDoubleInfo(value)));
break;
}
case Constants.LDC:
case Constants.LDC_W:
case Constants.LDC2_W:
{
CPInstruction instr=(CPInstruction)instruction;
values.push(new ValueInfo(methodInfo.getClassInfo().getConstantInfo(instr.getIndex())));
break;
}
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
case Constants.LSTORE_0:
case Constants.LSTORE_1:
case Constants.LSTORE_2:
case Constants.LSTORE_3:
case Constants.LSTORE:
case Constants.DSTORE_0:
case Constants.DSTORE_1:
case Constants.DSTORE_2:
case Constants.DSTORE_3:
case Constants.DSTORE:
case Constants.FSTORE_0:
case Constants.FSTORE_1:
case Constants.FSTORE_2:
case Constants.FSTORE_3:
case Constants.FSTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
values.setLocalValue(index,values.popValue());
break;
}
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
case Constants.LLOAD_0:
case Constants.LLOAD_1:
case Constants.LLOAD_2:
case Constants.LLOAD_3:
case Constants.LLOAD:
case Constants.FLOAD_0:
case Constants.FLOAD_1:
case Constants.FLOAD_2:
case Constants.FLOAD_3:
case Constants.FLOAD:
case Constants.DLOAD_0:
case Constants.DLOAD_1:
case Constants.DLOAD_2:
case Constants.DLOAD_3:
case Constants.DLOAD:
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
int index=instr.getIndex();
values.push(values.getLocalValue(index));
break;
}
case Constants.DUP:
values.push(values.top());
break;
case Constants.DUP_X1:
values.insert(2,values.top());
break;
case Constants.DUP_X2:
values.insert(3,values.top());
case Constants.DUP2:
values.push(values.top(1),false);
values.push(values.top(1),false);
break;
case Constants.DUP2_X1:
values.insert(3,values.top(1));
values.insert(3,values.top(0));
break;
case Constants.DUP2_X2:
values.insert(4,values.top(1));
values.insert(4,values.top(0));
break;
case Constants.POP:
values.pop();
break;
case Constants.POP2:
values.pop();
values.pop();
break;
case Constants.SWAP:
values.insert(1,values.pop());
break;
case Constants.IASTORE:
case Constants.LASTORE:
case Constants.FASTORE:
case Constants.DASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
case Constants.AASTORE:
values.popValue();
values.pop();
values.pop();
break;
case Constants.IALOAD:
case Constants.LALOAD:
case Constants.FALOAD:
case Constants.DALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
case Constants.AALOAD:
{
values.pop();
values.pop();
Type t=((ArrayInstruction)instruction).getType(cpg);
values.push(new ValueInfo(t));
break;
}
case Constants.IINC:
{
int i=((IINC)instruction).getIndex();
ValueInfo old=values.getLocalValue(i);
if (old.isConstantValue() && old.getConstantValue() instanceof ConstantIntegerInfo) {
ConstantIntegerInfo value=(ConstantIntegerInfo)old.getConstantValue();
int newval=value.getValue() + ((IINC)instruction).getIncrement();
values.setLocalValue(i,new ValueInfo(new ConstantIntegerInfo(newval)));
}
 else {
values.setLocalValue(i,new ValueInfo(Type.INT));
}
break;
}
case Constants.IADD:
case Constants.ISUB:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.ISHL:
case Constants.ISHR:
case Constants.IUSHR:
values.pop();
case Constants.INEG:
values.pop();
values.push(new ValueInfo(Type.INT));
break;
case Constants.FADD:
case Constants.FSUB:
case Constants.FMUL:
case Constants.FDIV:
case Constants.FREM:
values.pop();
case Constants.FNEG:
values.pop();
values.push(new ValueInfo(Type.FLOAT));
break;
case Constants.LADD:
case Constants.LSUB:
case Constants.LMUL:
case Constants.LDIV:
case Constants.LREM:
case Constants.LAND:
case Constants.LOR:
case Constants.LXOR:
values.pop();
values.pop();
case Constants.LNEG:
values.pop();
values.pop();
values.push(new ValueInfo(Type.LONG));
break;
case Constants.DADD:
case Constants.DSUB:
case Constants.DMUL:
case Constants.DDIV:
case Constants.DREM:
values.pop();
values.pop();
case Constants.DNEG:
values.pop();
values.pop();
values.push(new ValueInfo(Type.DOUBLE));
break;
case Constants.LSHL:
case Constants.LSHR:
case Constants.LUSHR:
values.pop();
values.pop();
values.pop();
values.push(new ValueInfo(Type.LONG));
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
case Constants.I2L:
case Constants.I2F:
case Constants.I2D:
case Constants.L2I:
case Constants.L2F:
case Constants.L2D:
case Constants.F2I:
case Constants.F2L:
case Constants.F2D:
case Constants.D2I:
case Constants.D2L:
case Constants.D2F:
{
values.popValue();
values.push(new ValueInfo(((ConversionInstruction)instruction).getType(cpg)));
break;
}
case Constants.LCMP:
case Constants.DCMPL:
case Constants.DCMPG:
values.pop();
values.pop();
case Constants.FCMPL:
case Constants.FCMPG:
values.pop();
values.pop();
values.push(new ValueInfo(Type.INT));
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
values.pop();
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
case Constants.IFNULL:
case Constants.IFNONNULL:
values.pop();
break;
case Constants.GOTO:
case Constants.RET:
break;
case Constants.JSR:
values.push(new ValueInfo(Type.INT));
break;
case Constants.ARETURN:
case Constants.IRETURN:
case Constants.LRETURN:
case Constants.FRETURN:
case Constants.DRETURN:
case Constants.RETURN:
values.clearStack();
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
values.pop();
break;
case Constants.GETFIELD:
values.pop();
case Constants.GETSTATIC:
{
FieldInstruction f=(FieldInstruction)instruction;
values.push(new ValueInfo(f.getFieldType(cpg)));
break;
}
case Constants.PUTFIELD:
values.pop();
case Constants.PUTSTATIC:
{
FieldInstruction f=(FieldInstruction)instruction;
values.pop(f.getFieldType(cpg).getSize());
break;
}
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESPECIAL:
values.pop();
case Constants.INVOKESTATIC:
{
InvokeInstruction invoke=(InvokeInstruction)instruction;
values.pop(TypeHelper.getNumSlots(invoke.getArgumentTypes(cpg)));
values.push(new ValueInfo(invoke.getReturnType(cpg)));
break;
}
case Constants.MONITORENTER:
case Constants.MONITOREXIT:
values.pop();
break;
case Constants.ATHROW:
ValueInfo ref=values.pop();
values.clearStack();
values.push(ref);
break;
case Constants.CHECKCAST:
break;
case Constants.INSTANCEOF:
values.pop();
values.push(new ValueInfo(Type.INT));
break;
case Constants.NEW:
values.push(new ValueInfo(((NEW)instruction).getType(cpg)));
break;
case Constants.NEWARRAY:
{
Type t=((NEWARRAY)instruction).getType();
values.push(new ValueInfo(new ArrayType(t,1)));
break;
}
case Constants.ANEWARRAY:
{
Type t=((ANEWARRAY)instruction).getType(cpg);
values.push(new ValueInfo(new ArrayType(t,1)));
break;
}
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
values.pop(instr.getDimensions());
values.push(new ValueInfo(new ArrayType(instr.getType(cpg),instr.getDimensions())));
break;
}
case Constants.ARRAYLENGTH:
values.pop();
values.push(new ValueInfo(Type.INT));
break;
default :
throw new AppInfoError(""String_Node_Str"" + instruction);
}
}","public void transfer(Instruction instruction){
switch (instruction.getOpcode()) {
case Constants.NOP:
    break;
case Constants.ACONST_NULL:
  values.push(new ValueInfo(Type.NULL));
break;
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
int value=instr.getValue().intValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantIntegerInfo(value)));
break;
}
case Constants.LCONST_0:
case Constants.LCONST_1:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
long value=instr.getValue().longValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantLongInfo(value)));
break;
}
case Constants.FCONST_0:
case Constants.FCONST_1:
case Constants.FCONST_2:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
float value=instr.getValue().floatValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantFloatInfo(value)));
break;
}
case Constants.DCONST_0:
case Constants.DCONST_1:
{
ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
double value=instr.getValue().doubleValue();
values.push(new ValueInfo(instr.getType(cpg),new ConstantDoubleInfo(value)));
break;
}
case Constants.LDC:
case Constants.LDC_W:
case Constants.LDC2_W:
{
CPInstruction instr=(CPInstruction)instruction;
values.push(new ValueInfo(methodInfo.getClassInfo().getConstantInfo(instr.getIndex())));
break;
}
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
case Constants.LSTORE_0:
case Constants.LSTORE_1:
case Constants.LSTORE_2:
case Constants.LSTORE_3:
case Constants.LSTORE:
case Constants.DSTORE_0:
case Constants.DSTORE_1:
case Constants.DSTORE_2:
case Constants.DSTORE_3:
case Constants.DSTORE:
case Constants.FSTORE_0:
case Constants.FSTORE_1:
case Constants.FSTORE_2:
case Constants.FSTORE_3:
case Constants.FSTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
values.setLocalValue(index,values.popValue());
break;
}
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
case Constants.LLOAD_0:
case Constants.LLOAD_1:
case Constants.LLOAD_2:
case Constants.LLOAD_3:
case Constants.LLOAD:
case Constants.FLOAD_0:
case Constants.FLOAD_1:
case Constants.FLOAD_2:
case Constants.FLOAD_3:
case Constants.FLOAD:
case Constants.DLOAD_0:
case Constants.DLOAD_1:
case Constants.DLOAD_2:
case Constants.DLOAD_3:
case Constants.DLOAD:
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
int index=instr.getIndex();
values.push(values.getLocalValue(index));
break;
}
case Constants.DUP:
values.push(values.top());
break;
case Constants.DUP_X1:
values.insert(2,values.top());
break;
case Constants.DUP_X2:
values.insert(3,values.top());
case Constants.DUP2:
values.push(values.top(1),false);
values.push(values.top(1),false);
break;
case Constants.DUP2_X1:
values.insert(3,values.top(1));
values.insert(3,values.top(0));
break;
case Constants.DUP2_X2:
values.insert(4,values.top(1));
values.insert(4,values.top(0));
break;
case Constants.POP:
values.pop();
break;
case Constants.POP2:
values.pop();
values.pop();
break;
case Constants.SWAP:
values.insert(1,values.pop());
break;
case Constants.IASTORE:
case Constants.LASTORE:
case Constants.FASTORE:
case Constants.DASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
case Constants.AASTORE:
values.popValue();
values.pop();
values.pop();
break;
case Constants.IALOAD:
case Constants.LALOAD:
case Constants.FALOAD:
case Constants.DALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
case Constants.AALOAD:
{
values.pop();
values.pop();
Type t=((ArrayInstruction)instruction).getType(cpg);
values.push(new ValueInfo(t));
break;
}
case Constants.IINC:
{
int i=((IINC)instruction).getIndex();
ValueInfo old=values.getLocalValue(i);
if (old.isConstantValue() && old.getConstantValue() instanceof ConstantIntegerInfo) {
ConstantIntegerInfo value=(ConstantIntegerInfo)old.getConstantValue();
int newval=value.getValue() + ((IINC)instruction).getIncrement();
values.setLocalValue(i,new ValueInfo(new ConstantIntegerInfo(newval)));
}
 else {
values.setLocalValue(i,new ValueInfo(Type.INT));
}
break;
}
case Constants.IADD:
case Constants.ISUB:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.ISHL:
case Constants.ISHR:
case Constants.IUSHR:
values.pop();
case Constants.INEG:
values.pop();
values.push(new ValueInfo(Type.INT));
break;
case Constants.FADD:
case Constants.FSUB:
case Constants.FMUL:
case Constants.FDIV:
case Constants.FREM:
values.pop();
case Constants.FNEG:
values.pop();
values.push(new ValueInfo(Type.FLOAT));
break;
case Constants.LADD:
case Constants.LSUB:
case Constants.LMUL:
case Constants.LDIV:
case Constants.LREM:
case Constants.LAND:
case Constants.LOR:
case Constants.LXOR:
values.pop();
values.pop();
case Constants.LNEG:
values.pop();
values.pop();
values.push(new ValueInfo(Type.LONG));
break;
case Constants.DADD:
case Constants.DSUB:
case Constants.DMUL:
case Constants.DDIV:
case Constants.DREM:
values.pop();
values.pop();
case Constants.DNEG:
values.pop();
values.pop();
values.push(new ValueInfo(Type.DOUBLE));
break;
case Constants.LSHL:
case Constants.LSHR:
case Constants.LUSHR:
values.pop();
values.pop();
values.pop();
values.push(new ValueInfo(Type.LONG));
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
case Constants.I2L:
case Constants.I2F:
case Constants.I2D:
case Constants.L2I:
case Constants.L2F:
case Constants.L2D:
case Constants.F2I:
case Constants.F2L:
case Constants.F2D:
case Constants.D2I:
case Constants.D2L:
case Constants.D2F:
{
values.popValue();
values.push(new ValueInfo(((ConversionInstruction)instruction).getType(cpg)));
break;
}
case Constants.LCMP:
case Constants.DCMPL:
case Constants.DCMPG:
values.pop();
values.pop();
case Constants.FCMPL:
case Constants.FCMPG:
values.pop();
values.pop();
values.push(new ValueInfo(Type.INT));
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
values.pop();
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
case Constants.IFNULL:
case Constants.IFNONNULL:
values.pop();
break;
case Constants.GOTO:
case Constants.RET:
break;
case Constants.JSR:
values.push(new ValueInfo(Type.INT));
break;
case Constants.ARETURN:
case Constants.IRETURN:
case Constants.LRETURN:
case Constants.FRETURN:
case Constants.DRETURN:
case Constants.RETURN:
values.clearStack();
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
values.pop();
break;
case Constants.GETFIELD:
values.pop();
case Constants.GETSTATIC:
{
FieldInstruction f=(FieldInstruction)instruction;
ConstantFieldInfo field=(ConstantFieldInfo)methodInfo.getClassInfo().getConstantInfo(f.getIndex());
values.push(new ValueInfo(f.getFieldType(cpg),field.getValue()));
break;
}
case Constants.PUTFIELD:
values.pop();
case Constants.PUTSTATIC:
{
FieldInstruction f=(FieldInstruction)instruction;
values.pop(f.getFieldType(cpg).getSize());
break;
}
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESPECIAL:
values.pop();
case Constants.INVOKESTATIC:
{
InvokeInstruction invoke=(InvokeInstruction)instruction;
values.pop(TypeHelper.getNumSlots(invoke.getArgumentTypes(cpg)));
values.push(new ValueInfo(invoke.getReturnType(cpg)));
break;
}
case Constants.MONITORENTER:
case Constants.MONITOREXIT:
values.pop();
break;
case Constants.ATHROW:
ValueInfo ref=values.pop();
values.clearStack();
values.push(ref);
break;
case Constants.CHECKCAST:
break;
case Constants.INSTANCEOF:
values.pop();
values.push(new ValueInfo(Type.INT));
break;
case Constants.NEW:
values.push(new ValueInfo(((NEW)instruction).getType(cpg)));
break;
case Constants.NEWARRAY:
{
Type t=((NEWARRAY)instruction).getType();
values.push(new ValueInfo(new ArrayType(t,1)));
break;
}
case Constants.ANEWARRAY:
{
Type t=((ANEWARRAY)instruction).getType(cpg);
values.push(new ValueInfo(new ArrayType(t,1)));
break;
}
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
values.pop(instr.getDimensions());
values.push(new ValueInfo(new ArrayType(instr.getType(cpg),instr.getDimensions())));
break;
}
case Constants.ARRAYLENGTH:
values.pop();
values.push(new ValueInfo(Type.INT));
break;
default :
throw new AppInfoError(""String_Node_Str"" + instruction);
}
}",0.9924154348668548
186750,"/** 
 * Try to inline a simple getter, wrapper or stub method. <p> If the inlined code is again an invoke, the InvokeSite does not change because the InstructionHandle of the invoker's invoke is kept.</p>
 * @param invokeSite the invoke to replace.
 * @param invokee the method to inline.
 * @param invokeMap the parameters of the invokee and the code to inline.
 * @return true if inlining has been performed.
 */
private InvokeSite performSimpleInline(InvokeSite invokeSite,MethodInfo invokee,InvokeMap invokeMap){
  MethodInfo invoker=invokeSite.getInvoker();
  MethodCode invokerCode=invoker.getCode();
  helper.prepareInlining(invoker,invokee);
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  if (invokeMap.getOldPrologueLength() > 0) {
    InstructionHandle start=invoke;
    for (int i=0; i < invokeMap.getOldPrologueLength(); i++) {
      start=start.getPrev();
    }
    invokerCode.replace(start,invokeMap.getOldPrologueLength(),invokeMap.getPrologue(),false);
  }
  InstructionList il=invokee.getCode().getInstructionList();
  InstructionHandle start=invokee.getCode().getInstructionHandle(invokeMap.getInlineStart());
  int cnt=il.getLength() - invokeMap.getInlineStart();
  if (il.getEnd().getInstruction() instanceof ReturnInstruction) {
    cnt--;
  }
  InstructionHandle end=invokerCode.replace(invoke,1,invokee,il,start,cnt,false);
  invokerCode.getInstructionList().insert(end,invokeMap.getEpilogue());
  if (invokeMap.getInvokeSite() != null) {
    end=end.getPrev();
    while (end != null) {
      if (invokerCode.isInvokeSite(end)) {
        return invokerCode.getInvokeSite(end);
      }
      end=end.getPrev();
    }
  }
  return null;
}","/** 
 * Try to inline a simple getter, wrapper or stub method. <p> If the inlined code is again an invoke, the InvokeSite does not change because the InstructionHandle of the invoker's invoke is kept.</p>
 * @param invokeSite the invoke to replace.
 * @param invokee the method to inline.
 * @param invokeMap the parameters of the invokee and the code to inline.
 * @return true if inlining has been performed.
 */
private InvokeSite performSimpleInline(InvokeSite invokeSite,MethodInfo invokee,InvokeMap invokeMap){
  MethodInfo invoker=invokeSite.getInvoker();
  MethodCode invokerCode=invoker.getCode();
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + invokeSite + ""String_Node_Str""+ invokee);
  }
  helper.prepareInlining(invoker,invokee);
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  if (invokeMap.getOldPrologueLength() > 0) {
    InstructionHandle start=invoke;
    for (int i=0; i < invokeMap.getOldPrologueLength(); i++) {
      start=start.getPrev();
    }
    invokerCode.replace(start,invokeMap.getOldPrologueLength(),invokeMap.getPrologue(),false);
  }
 else   if (invokeMap.getPrologue().getLength() > 0) {
    InstructionList il=invokerCode.getInstructionList();
    il.insert(invoke,invokeMap.getPrologue());
  }
  InstructionList il=invokee.getCode().getInstructionList();
  InstructionHandle start=invokee.getCode().getInstructionHandle(invokeMap.getInlineStart());
  int cnt=il.getLength() - invokeMap.getInlineStart();
  if (il.getEnd().getInstruction() instanceof ReturnInstruction) {
    cnt--;
  }
  InstructionHandle end=invokerCode.replace(invoke,1,invokee,il,start,cnt,false);
  invokerCode.getInstructionList().insert(end,invokeMap.getEpilogue());
  if (invokeMap.getInvokeSite() != null) {
    end=end.getPrev();
    while (end != null) {
      if (invokerCode.isInvokeSite(end)) {
        return invokerCode.getInvokeSite(end);
      }
      end=end.getPrev();
    }
  }
  return null;
}",0.9232462173314994
186751,"@Override public void optimizeMethod(MethodInfo method){
  ConstantPoolGen cpg=method.getConstantPoolGen();
  InstructionList il=method.getCode().getInstructionList();
  InvokeMap invokeMap=new InvokeMap();
  for (  InvokeSite invoke : method.getCode().getInvokeSites()) {
    CallString cs=new CallString(invoke);
    while (invoke != null) {
      MethodInfo invokee=helper.devirtualize(cs);
      if (checkInvoke(invoke,cs,invokee,invokeMap)) {
        invoke=performSimpleInline(cs.first(),invokee,invokeMap);
        inlineCounter++;
        if (invokeMap.getInvokeSite() != null) {
          cs.push(invokeMap.getInvokeSite());
        }
 else {
          break;
        }
      }
 else {
        break;
      }
    }
  }
}","@Override public void optimizeMethod(MethodInfo method){
  ConstantPoolGen cpg=method.getConstantPoolGen();
  InstructionList il=method.getCode().getInstructionList();
  InvokeMap invokeMap=new InvokeMap();
  for (  InvokeSite invoke : method.getCode().getInvokeSites()) {
    CallString cs=new CallString(invoke);
    while (invoke != null) {
      MethodInfo invokee=helper.devirtualize(cs);
      if (checkInvoke(invoke,cs,invokee,invokeMap)) {
        invoke=performSimpleInline(invoke,invokee,invokeMap);
        inlineCounter++;
        if (invokeMap.getInvokeSite() != null) {
          cs.push(invokeMap.getInvokeSite());
        }
 else {
          break;
        }
      }
 else {
        break;
      }
    }
  }
}",0.9889958734525448
186752,"/** 
 * Check if the invokesite can be modified in a way so that the parameters are passed in the correct order
 * @param invokeSite the invokesite to inline.
 * @param invokee the invoked method.
 * @param invokeMap the map to store the analyzer results
 * @return true if the prologue can be changed to match the expected behaviour
 */
private boolean analyzeInvokeSite(InvokeSite invokeSite,MethodInfo invokee,InvokeMap invokeMap){
  MethodInfo invoker=invokeSite.getInvoker();
  ConstantPoolGen invokerCpg=invoker.getConstantPoolGen();
  ConstantPoolGen invokeeCpg=invokee.getConstantPoolGen();
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  Type[] ret=StackHelper.produceStack(invokerCpg,invoke.getInstruction());
  boolean match=(ret.length == 1 && TypeHelper.canAssign(invokee.getType(),ret[0]));
  if (!match && !invokee.getType().equals(Type.VOID)) {
    return false;
  }
  Type[] args=StackHelper.consumeStack(invokerCpg,invoke.getInstruction());
  List<Instruction> oldPrologue=new LinkedList<Instruction>();
  int cnt=0;
  InstructionHandle current=invoke;
  while (cnt < args.length) {
    if (current.hasTargeters()) {
      break;
    }
    current=current.getPrev();
    Instruction instr=current.getInstruction();
    if (!(instr instanceof PushInstruction) || (instr instanceof DUP) || (instr instanceof DUP2)) {
      break;
    }
    cnt++;
    oldPrologue.add(0,instr);
  }
  int offset=args.length - cnt;
  for (int i=0; i < offset; i++) {
    ValueInfo value=invokeMap.getParams().get(i);
    if (!value.isParamReference() || value.getParamNr() != i) {
      return false;
    }
  }
  invokeMap.setOldPrologueLength(cnt);
  for (int i=offset; i < invokeMap.getParams().size(); i++) {
    ValueInfo value=invokeMap.getParams().get(i);
    if (value.isThisReference() || value.isParamReference()) {
      int argNum=value.getParamNr();
      if (!invokee.isStatic()) {
        argNum++;
      }
      if (argNum < offset) {
        return false;
      }
      Instruction instr=oldPrologue.get(argNum - offset).copy();
      invokeMap.addPrologue(instr);
    }
 else     if (value.isConstantValue()) {
      Instruction instr=value.getConstantValue().createPushInstruction(invoker.getConstantPoolGen());
      invokeMap.addPrologue(instr);
    }
 else     if (!value.isContinued()) {
      throw new AssertionError(""String_Node_Str"");
    }
  }
  return false;
}","/** 
 * Check if the invokesite can be modified in a way so that the parameters are passed in the correct order
 * @param invokeSite the invokesite to inline.
 * @param invokee the invoked method.
 * @param invokeMap the map to store the analyzer results
 * @return true if the prologue can be changed to match the expected behaviour
 */
private boolean analyzeInvokeSite(InvokeSite invokeSite,MethodInfo invokee,InvokeMap invokeMap){
  MethodInfo invoker=invokeSite.getInvoker();
  ConstantPoolGen invokerCpg=invoker.getConstantPoolGen();
  InstructionHandle invoke=invokeSite.getInstructionHandle();
  Type[] ret=StackHelper.produceStack(invokerCpg,invoke.getInstruction());
  boolean match=(ret.length == 1 && TypeHelper.canAssign(invokee.getType(),ret[0]));
  if (!match && !invokee.getType().equals(Type.VOID)) {
    return false;
  }
  Type[] args=StackHelper.consumeStack(invokerCpg,invoke.getInstruction());
  List<Instruction> oldPrologue=new LinkedList<Instruction>();
  int cnt=0;
  InstructionHandle current=invoke;
  while (cnt < args.length) {
    if (current.hasTargeters()) {
      break;
    }
    current=current.getPrev();
    Instruction instr=current.getInstruction();
    if (!(instr instanceof PushInstruction) || (instr instanceof DUP) || (instr instanceof DUP2)) {
      break;
    }
    cnt++;
    oldPrologue.add(0,instr);
  }
  invokeMap.setOldPrologueLength(cnt);
  List<ValueInfo> params=invokeMap.getParams();
  int offset=args.length - cnt;
  for (int i=0; i < offset; i++) {
    if (i >= params.size()) {
      Type t=args[i];
      invokeMap.addPrologue(t.getSize() == 2 ? new POP2() : new POP());
    }
 else {
      ValueInfo value=params.get(i);
      int argNum=value.getParamNr();
      if (invokee.isStatic()) {
        argNum++;
      }
      if (argNum != i) {
        return false;
      }
    }
  }
  for (int i=offset; i < params.size(); i++) {
    ValueInfo value=params.get(i);
    if (value.isThisReference() || value.isParamReference()) {
      int argNum=value.getParamNr();
      if (!invokee.isStatic()) {
        argNum++;
      }
      if (argNum < offset) {
        return false;
      }
      Instruction instr=oldPrologue.get(argNum - offset).copy();
      invokeMap.addPrologue(instr);
    }
 else     if (value.isConstantValue() || value.isStaticFieldReference()) {
      Instruction instr=value.getConstantValue().createPushInstruction(invoker.getConstantPoolGen());
      invokeMap.addPrologue(instr);
    }
 else     if (!value.isContinued()) {
      throw new AssertionError(""String_Node_Str"");
    }
  }
  return true;
}",0.717753259779338
186753,"/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not of the implementing class. </p> <p>To handle invocations of super-methods correctly, use   {@link #findImplementations(InvokeSite)}instead.</p>
 * @see #findImplementations(InvokeSite)
 * @param invokee the method to resolve.
 * @return all possible implementations.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMethodSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.debug(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  boolean undefinedBaseMethod=false;
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      if (invokeeClass.isFullyKnown(true)) {
        throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
      }
 else {
        logger.debug(""String_Node_Str"" + invokee.toString());
        undefinedBaseMethod=true;
      }
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m=classInfo.getMethodInfo(methodSig);
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  if (undefinedBaseMethod && methods.size() > 0) {
    throw new JavaClassFormatError(""String_Node_Str"" + invokee + ""String_Node_Str"");
  }
  return methods;
}","/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not of the implementing class. </p> <p>To handle invocations of super-methods correctly, use   {@link #findImplementations(InvokeSite)}instead.</p>
 * @see #findImplementations(InvokeSite)
 * @param invokee the method to resolve.
 * @return all possible implementations.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMethodSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.debug(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  boolean undefinedBaseMethod=false;
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      if (invokeeClass.isFullyKnown(true)) {
        throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
      }
 else {
        logger.debug(""String_Node_Str"" + invokee.toString());
        undefinedBaseMethod=true;
      }
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m;
      if (invokeeClass.isInterface() && !classInfo.isInterface()) {
        m=classInfo.getMethodInfoInherited(methodSig,true);
      }
 else {
        m=classInfo.getMethodInfo(methodSig);
      }
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  if (undefinedBaseMethod && methods.size() > 0) {
    throw new JavaClassFormatError(""String_Node_Str"" + invokee + ""String_Node_Str"");
  }
  return methods;
}",0.9662548404941914
186754,"public boolean visitClass(ClassInfo classInfo){
  MethodInfo m=classInfo.getMethodInfo(methodSig);
  if (m != null) {
    if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
      logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
    }
    if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
      methods.add(m);
    }
  }
  return true;
}","public boolean visitClass(ClassInfo classInfo){
  MethodInfo m;
  if (invokeeClass.isInterface() && !classInfo.isInterface()) {
    m=classInfo.getMethodInfoInherited(methodSig,true);
  }
 else {
    m=classInfo.getMethodInfo(methodSig);
  }
  if (m != null) {
    if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
      logger.error(""String_Node_Str"" + m.getMethodSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
    }
    if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
      methods.add(m);
    }
  }
  return true;
}",0.8469483568075117
186755,"private void addProcessorModelOptions(){
  config.addOption(Config.PROCESSOR_MODEL);
  OptionGroup jopGroup=config.getOptions().addGroup(""String_Node_Str"",false);
  jopGroup.addOptions(JOPConfig.jopOptions);
}","private void addProcessorModelOptions(){
  config.addOption(Config.PROCESSOR_MODEL);
  JOPConfig.registerOptions(config);
}",0.6506024096385542
186756,"public <T>void setDefaultValue(Option<T> option,T value){
  config.setDefaultProperty(getConfigKey(option),value.toString());
}","public <T>void setDefaultValue(Option<T> option,T value){
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  config.setDefaultProperty(getConfigKey(option),value.toString());
}",0.6463104325699746
186757,"/** 
 * Try to get the value of an option, or return null for optional options with no default value. An exception is thrown if no value (and no default value) is given and the option is not optional, or if the config-value cannot be parsed. <p/> Note that after   {@link #checkOptions()} has been called, this methodshould not throw any errors.
 * @param option the option to get the value for.
 * @param < T >    type of the option.
 * @return the option value or null if
 * @throws Config.BadConfigurationError if the config-value cannot be parsed or if the option is null but required.
 */
public <T>T getOption(Option<T> option) throws Config.BadConfigurationError {
  T opt;
  try {
    opt=tryGetOption(option);
  }
 catch (  IllegalArgumentException e) {
    throw new Config.BadConfigurationError(""String_Node_Str"" + getConfigKey(option) + ""String_Node_Str""+ e.getMessage(),e);
  }
  if (opt == null && !option.isOptional()) {
    throw new Config.BadConfigurationError(""String_Node_Str"" + getConfigKey(option));
  }
  return opt;
}","/** 
 * Try to get the value of an option, or return null for optional options with no default value. An exception is thrown if no value (and no default value) is given and the option is not optional, or if the config-value cannot be parsed. <p/> Note that after   {@link #checkOptions()} has been called, this methodshould not throw any errors.
 * @param option the option to get the value for.
 * @param < T >    type of the option.
 * @return the option value or null if
 * @throws BadConfigurationError if the option is not defined in this group, if config-value cannotbe parsed or if the option is null but required.
 */
public <T>T getOption(Option<T> option) throws BadConfigurationError {
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  T opt;
  try {
    opt=tryGetOption(option);
  }
 catch (  IllegalArgumentException e) {
    throw new Config.BadConfigurationError(""String_Node_Str"" + getConfigKey(option) + ""String_Node_Str""+ e.getMessage(),e);
  }
  if (opt == null && !option.isOptional()) {
    throw new Config.BadConfigurationError(""String_Node_Str"" + getConfigKey(option));
  }
  return opt;
}",0.8967052537845058
186758,"/** 
 * Get the parsed default value from the config or from the option if not set.
 * @param option the option to get the default value for.
 * @param < T >    the type of the value
 * @return the default value, or null if no default is set in neither the config nor the option.
 */
public <T>T getDefaultValue(Option<T> option){
  String val=config.getDefaultValue(getConfigKey(option));
  if (val == null) {
    return option.getDefaultValue(this);
  }
 else {
    return option.parse(this,val);
  }
}","/** 
 * Get the parsed default value from the config or from the option if not set.
 * @param option the option to get the default value for.
 * @param < T >    the type of the value
 * @return the default value, or null if no default is set in neither the config nor the option.
 */
public <T>T getDefaultValue(Option<T> option){
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  String val=config.getDefaultValue(getConfigKey(option));
  if (val == null) {
    return option.getDefaultValue(this);
  }
 else {
    return option.parse(this,val);
  }
}",0.8788142981691369
186759,"/** 
 * Try to get the value of an option, or its default value. If no value and no default value is available, this returns null, even if the option is not optional. <p/> Note that after   {@link #checkOptions()} has been called, this methodshould not throw any errors.
 * @param option the option to query.
 * @param < T >    Type of the option
 * @return The value, the default value, or null if no value is available.
 * @throws IllegalArgumentException if the config-value cannot be parsed or is not valid.
 */
public <T>T tryGetOption(Option<T> option) throws IllegalArgumentException {
  String val;
  if (prefix != null && !optionSet.containsKey(option.getKey())) {
    val=config.getValue(option.getKey());
  }
 else {
    val=config.getValue(getConfigKey(option));
  }
  if (val == null) {
    return option.getDefaultValue(this);
  }
 else {
    return option.parse(this,val);
  }
}","/** 
 * Try to get the value of an option, or its default value. If no value and no default value is available, this returns null, even if the option is not optional. <p/> Note that after   {@link #checkOptions()} has been called, this methodshould not throw any errors.
 * @param option the option to query.
 * @param < T >    Type of the option
 * @return The value, the default value, or null if no value is available.
 * @throws IllegalArgumentException if the config-value cannot be parsed or is not valid.
 */
public <T>T tryGetOption(Option<T> option) throws IllegalArgumentException {
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  String val=config.getValue(getConfigKey(option));
  if (val == null) {
    return option.getDefaultValue(this);
  }
 else {
    return option.parse(this,val);
  }
}",0.8196538246789503
186760,"/** 
 * Get the default value from the config or from the option if not set, but do not parse it or replace any keywords.
 * @param option the option to get the default value for.
 * @return the default value as set in the config file or the option.
 */
public String getDefaultValueText(Option option){
  String val=config.getDefaultValue(getConfigKey(option));
  if (val == null) {
    Object def=option.getDefaultValue();
    return def != null ? def.toString() : null;
  }
 else {
    return val;
  }
}","/** 
 * Get the default value from the config or from the option if not set, but do not parse it or replace any keywords.
 * @param option the option to get the default value for.
 * @return the default value as set in the config file or the option.
 */
public String getDefaultValueText(Option option){
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  String val=config.getDefaultValue(getConfigKey(option));
  if (val == null) {
    Object def=option.getDefaultValue();
    return def != null ? def.toString() : null;
  }
 else {
    return val;
  }
}",0.8792354474370113
186761,"public <T>void setOption(Option<T> option,T value){
  config.setProperty(getConfigKey(option),value.toString());
}","public <T>void setOption(Option<T> option,T value){
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  config.setProperty(getConfigKey(option),value.toString());
}",0.6212534059945504
186762,"/** 
 * Check if option has been assigned a value in the config.
 * @param option the option to check.
 * @return true if option has been explicitly set.
 * @see Option#isEnabled(OptionGroup)
 * @see #hasValue(Option)
 */
public boolean isSet(Option<?> option){
  return config.isSet(getConfigKey(option));
}","/** 
 * Check if option has been assigned a value in the config.
 * @param option the option to check.
 * @return true if option has been explicitly set.
 * @see Option#isEnabled(OptionGroup)
 * @see #hasValue(Option)
 */
public boolean isSet(Option<?> option){
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  return config.isSet(getConfigKey(option));
}",0.7814569536423841
186763,"/** 
 * Check if we have any value for this option (either set explicitly or some default value). Does not check if the value can be parsed.
 * @param option the option to check.
 * @return true if there is some value available for this option.
 * @see Option#isEnabled(OptionGroup)
 * @see #isSet(Option)
 */
public boolean hasValue(Option<?> option){
  String val=config.getValue(getConfigKey(option));
  return val != null || option.getDefaultValue(this) != null;
}","/** 
 * Check if we have any value for this option (either set explicitly or some default value). Does not check if the value can be parsed.
 * @param option the option to check.
 * @return true if there is some value available for this option.
 * @see Option#isEnabled(OptionGroup)
 * @see #isSet(Option)
 */
public boolean hasValue(Option<?> option){
  if (!containsOption(option)) {
    throw new BadConfigurationError(""String_Node_Str"" + option.getKey() + ""String_Node_Str""+ prefix);
  }
  String val=config.getValue(getConfigKey(option));
  return val != null || option.getDefaultValue(this) != null;
}",0.8706976744186047
186764,"public JOPConfig(Config configData){
  OptionGroup jopConfig=configData.getOptions().getGroup(""String_Node_Str"");
  this.asmFile=new File(jopConfig.getOption(ASM_FILE));
  this.rws=jopConfig.getOption(READ_WAIT_STATES).intValue();
  this.wws=jopConfig.getOption(WRITE_WAIT_STATES).intValue();
  this.cmp=jopConfig.getOption(MULTIPROCESSOR);
  this.cpus=jopConfig.getOption(CMP_CPUS).intValue();
  this.timeslot=jopConfig.getOption(CMP_TIMESLOT).intValue();
  this.objectCacheName=jopConfig.getOption(CACHE_IMPL);
  this.objectCacheAssociativity=jopConfig.getOption(OBJECT_CACHE_ASSOCIATIVITY).intValue();
  this.objectCacheBlockSize=jopConfig.getOption(OBJECT_CACHE_BLOCK_SIZE).intValue();
  this.objectCacheFieldTag=false;
  this.objectCacheLineSize=jopConfig.getOption(OBJECT_CACHE_WORDS_PER_LINE).intValue();
  this.objectCacheHitCycles=jopConfig.getOption(OBJECT_CACHE_HIT_CYCLES);
  this.objectCacheLoadFieldCycles=jopConfig.getOption(OBJECT_CACHE_LOAD_FIELD_CYCLES);
  this.objectCacheLoadBlockCycles=jopConfig.getOption(OBJECT_CACHE_LOAD_BLOCK_CYCLES);
}","public JOPConfig(Config configData){
  OptionGroup jopConfig=getOptions(configData);
  this.asmFile=new File(jopConfig.getOption(ASM_FILE));
  this.rws=jopConfig.getOption(READ_WAIT_STATES).intValue();
  this.wws=jopConfig.getOption(WRITE_WAIT_STATES).intValue();
  this.cmp=jopConfig.getOption(MULTIPROCESSOR);
  this.cpus=jopConfig.getOption(CMP_CPUS).intValue();
  this.timeslot=jopConfig.getOption(CMP_TIMESLOT).intValue();
  this.objectCacheName=jopConfig.getOption(CACHE_IMPL);
  this.objectCacheAssociativity=jopConfig.getOption(OBJECT_CACHE_ASSOCIATIVITY).intValue();
  this.objectCacheBlockSize=jopConfig.getOption(OBJECT_CACHE_BLOCK_SIZE).intValue();
  this.objectCacheFieldTag=false;
  this.objectCacheLineSize=jopConfig.getOption(OBJECT_CACHE_WORDS_PER_LINE).intValue();
  this.objectCacheHitCycles=jopConfig.getOption(OBJECT_CACHE_HIT_CYCLES);
  this.objectCacheLoadFieldCycles=jopConfig.getOption(OBJECT_CACHE_LOAD_FIELD_CYCLES);
  this.objectCacheLoadBlockCycles=jopConfig.getOption(OBJECT_CACHE_LOAD_BLOCK_CYCLES);
}",0.9756330625895844
186765,"/** 
 * Find and remove unused classes, methods and fields
 */
public void removeUnusedMembers(){
  if (!getPhaseOptions().getOption(REMOVE_UNUSED_MEMBERS)) {
    return;
  }
  logger.info(""String_Node_Str"");
  new UnusedCodeRemover(jcopter,getOptimizeOptions()).execute();
  logger.info(""String_Node_Str"");
}","/** 
 * Find and remove unused classes, methods and fields
 */
public void removeUnusedMembers(){
  if (!getOptimizeOptions().getOption(REMOVE_UNUSED_MEMBERS)) {
    return;
  }
  logger.info(""String_Node_Str"");
  new UnusedCodeRemover(jcopter,getOptimizeOptions()).execute();
  logger.info(""String_Node_Str"");
}",0.9822866344605476
186766,"public static MethodCache getCacheModel(WCETTool p){
  Config c=p.getConfig();
switch (c.getOption(JOPConfig.CACHE_IMPL)) {
case NO_METHOD_CACHE:
    return new NoMethodCache(p);
case LRU_CACHE:
  return BlockCache.fromConfig(p,true);
case FIFO_CACHE:
return BlockCache.fromConfig(p,false);
case LRU_VARBLOCK_CACHE:
return VarBlockCache.fromConfig(p,true);
case FIFO_VARBLOCK_CACHE:
return VarBlockCache.fromConfig(p,false);
default :
throw new AssertionError(""String_Node_Str"" + c.getOption(JOPConfig.CACHE_IMPL));
}
}","public static MethodCache getCacheModel(WCETTool p){
  OptionGroup options=JOPConfig.getOptions(p.getConfig());
switch (options.getOption(JOPConfig.CACHE_IMPL)) {
case NO_METHOD_CACHE:
    return new NoMethodCache(p);
case LRU_CACHE:
  return BlockCache.fromConfig(p,true);
case FIFO_CACHE:
return BlockCache.fromConfig(p,false);
case LRU_VARBLOCK_CACHE:
return VarBlockCache.fromConfig(p,true);
case FIFO_VARBLOCK_CACHE:
return VarBlockCache.fromConfig(p,false);
default :
throw new AssertionError(""String_Node_Str"" + options.getOption(JOPConfig.CACHE_IMPL));
}
}",0.917820867959372
186767,"public static MethodCache fromConfig(WCETTool p,boolean isLRU){
  Config c=p.getConfig();
  return new VarBlockCache(p,c.getOption(JOPConfig.CACHE_BLOCKS).intValue(),c.getOption(JOPConfig.CACHE_SIZE_WORDS).intValue(),isLRU);
}","public static MethodCache fromConfig(WCETTool p,boolean isLRU){
  OptionGroup o=JOPConfig.getOptions(p.getConfig());
  return new VarBlockCache(p,o.getOption(JOPConfig.CACHE_BLOCKS).intValue(),o.getOption(JOPConfig.CACHE_SIZE_WORDS).intValue(),isLRU);
}",0.8517745302713987
186768,"/** 
 * If caching is enabled, look for cached results for the given analysis
 */
private Map getCachedResults(Analysis analysis){
  File cacheFile=getCacheFile(analysis);
  try {
    if (!cacheFile.exists())     return null;
    return analysis.deSerializeResult(appInfo,cacheFile);
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"" + analysis.getId() + ""String_Node_Str"",ex);
  }
catch (  ClassNotFoundException ex) {
    logger.error(""String_Node_Str"" + analysis.getId() + ""String_Node_Str"",ex);
  }
catch (  MethodNotFoundException ex) {
    logger.error(""String_Node_Str"" + analysis.getId() + ""String_Node_Str"",ex);
  }
  return null;
}","/** 
 * If caching is enabled, look for cached results for the given analysis
 */
private Map getCachedResults(Analysis analysis){
  if (cacheDir == null)   return null;
  File cacheFile=getCacheFile(analysis);
  try {
    if (!cacheFile.exists())     return null;
    return analysis.deSerializeResult(appInfo,cacheFile);
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"" + analysis.getId() + ""String_Node_Str"",ex);
  }
catch (  ClassNotFoundException ex) {
    logger.error(""String_Node_Str"" + analysis.getId() + ""String_Node_Str"",ex);
  }
catch (  MethodNotFoundException ex) {
    logger.error(""String_Node_Str"" + analysis.getId() + ""String_Node_Str"",ex);
  }
  return null;
}",0.9712177121771216
186769,"@Override public void onSetupConfig(AppSetup setup) throws Config.BadConfigurationException {
  if (setup.getConfig().hasOption(OPT_DFA_CACHE_DIR)) {
    this.cacheDir=new File(setup.getConfig().getOption(OPT_DFA_CACHE_DIR));
  }
}","@Override public void onSetupConfig(AppSetup setup) throws Config.BadConfigurationException {
  if (setup.getConfig().getOption(OPT_DFA_CACHE_DIR) != null) {
    this.cacheDir=new File(setup.getConfig().getOption(OPT_DFA_CACHE_DIR));
  }
}",0.9702127659574468
186770,"protected void initialize(){
  PeriodicEventHandler peh=new PeriodicEventHandler(new PriorityParameters(11),new PeriodicParameters(new RelativeTime(0,0),new RelativeTime(1000,0)),new ThreadConfiguration()){
    public void handleAsyncEvent(){
      Terminal.getTerminal().writeln(""String_Node_Str"");
    }
  }
;
}","protected void initialize(){
  PeriodicEventHandler peh=new PeriodicEventHandler(new PriorityParameters(11),new PeriodicParameters(new RelativeTime(0,0),new RelativeTime(1000,0)),new StorageParameters(0,0,0)){
    public void handleAsyncEvent(){
      Terminal.getTerminal().writeln(""String_Node_Str"");
    }
  }
;
}",0.9348171701112876
186771,"/** 
 * @param args
 */
public static void main(String[] args){
  final ScopedMemory scope=new LTMemory(0,20000L);
  final ScopedMemory inner=new LTMemory(0,10000L);
  final Runnable run=new Runnable(){
    public void run(){
      MyRunner r=new MyRunner();
      for (int i=0; i < 10; ++i) {
        Abc abc=new Abc();
        r.setAbc(abc);
        r.setOuter(scope);
        for (int j=0; j < 10; ++j) {
          inner.enter(r);
        }
      }
    }
  }
;
  System.out.println(""String_Node_Str"");
  new RtThread(10,500000){
    public void run(){
      for (; ; ) {
        for (int i=0; i < 20; ++i) {
          System.out.print(""String_Node_Str"");
          scope.enter(run);
        }
        waitForNextPeriod();
      }
    }
  }
;
  System.out.println(""String_Node_Str"");
  RtThread.startMission();
  System.out.println(""String_Node_Str"");
}","/** 
 * @param args
 */
public static void main(String[] args){
  final ScopedMemory scope=new LTMemory(20000L);
  final ScopedMemory inner=new LTMemory(10000L);
  final Runnable run=new Runnable(){
    public void run(){
      MyRunner r=new MyRunner();
      for (int i=0; i < 10; ++i) {
        Abc abc=new Abc();
        r.setAbc(abc);
        r.setOuter(scope);
        for (int j=0; j < 10; ++j) {
          inner.enter(r);
        }
      }
    }
  }
;
  System.out.println(""String_Node_Str"");
  new RtThread(10,500000){
    public void run(){
      for (; ; ) {
        for (int i=0; i < 20; ++i) {
          System.out.print(""String_Node_Str"");
          scope.enter(run);
        }
        waitForNextPeriod();
      }
    }
  }
;
  System.out.println(""String_Node_Str"");
  RtThread.startMission();
  System.out.println(""String_Node_Str"");
}",0.9976553341148886
186772,"@SCJProtected public LTMemory(SizeEstimator estimator){
  super(estimator);
}","/** 
 * This is not SCJAllowed because we don't want to instantiate these.  Safety-critical Java developers should instantiate SafetyMemory instead.
 */
@SCJProtected public LTMemory(long size){
  super(size);
}",0.3333333333333333
186773,"/** 
 * In vanilla RTSJ, enter() is not necessarily block-free because entering an LTMemory region may have to wait for the region to be finalized.  However, a complaint implementation of JSR 302 shall provide a block-free implementation of enter.  Note that JSR 302 specifies that finalization of LTMemory regions is not performed.
 */
@SCJAllowed(LEVEL_0) @SCJRestricted(maySelfSuspend=false) public void enter(Runnable logic){
}","@SCJProtected @SCJAllowed(LEVEL_0) @SCJRestricted(maySelfSuspend=false) public void enter(Runnable logic){
}",0.385899814471243
186774,"public static void startMission(Safelet scj){
  MissionSequencer ms=scj.getSequencer();
  MissionDescriptor md=ms.getInitialMission();
  md.initialize();
  Terminal.getTerminal().writeln(""String_Node_Str"");
  RtThread.startMission();
}","public static void startMission(Safelet scj){
  MissionSequencer ms=scj.getSequencer();
  MissionDescriptor md=null;
  md.initialize();
  Terminal.getTerminal().writeln(""String_Node_Str"");
  RtThread.startMission();
}",0.9424778761061948
186775,"ManagedMemory(SizeEstimator estimator){
  super(estimator);
}","ManagedMemory(long size){
  super(size);
}",0.6407766990291263
186776,"/** 
 * @param size is the amount of memory that this area can hold.
 */
MissionMemory(SizeEstimator estimator){
  super(estimator);
}","/** 
 * @param size is the amount of memory that this area can hold.
 */
MissionMemory(long size){
  super(size);
}",0.8514056224899599
186777,"public PeriodicParameters(RelativeTime start,RelativeTime period){
  this.start=start;
  this.period=period;
}","public PeriodicParameters(RelativeTime start,RelativeTime period){
  super(start,period);
  this.start=start;
  this.period=period;
}",0.9053497942386832
186778,"public PrivateMemory(SizeEstimator estimator){
  super(estimator);
}","public PrivateMemory(long size){
  super(size);
}",0.6837606837606838
186779,"/** 
 * This is a single mission so we return null for the next mission.
 */
public MissionDescriptor getNextMission(){
  return null;
}","/** 
 * This is a single mission so we return null for the next mission.
 */
public Mission getNextMission(){
  return null;
}",0.9618320610687024
186780,"public SingleMissionSequencer(PriorityParameters priority,MissionDescriptor md){
  super(priority);
  mission=md;
}","public SingleMissionSequencer(PriorityParameters priority,MissionDescriptor md){
  super(priority,null,""String_Node_Str"");
  mission=md;
}",0.9090909090909092
186781,"public Ternary isInterfaceMethod(){
  if (getMethodInfo() != null) {
    return Ternary.valueOf(methodInfo.getClassInfo().isInterface());
  }
  return classRef.isInterface();
}","public Ternary isInterfaceMethod(){
  if (methodInfo != null) {
    return Ternary.valueOf(methodInfo.getClassInfo().isInterface());
  }
  return classRef.isInterface();
}",0.9798270893371758
186782,"/** 
 * Find a 'correct' oder for the static <clinit>. Throws an error on cyclic dependencies.
 * @return the ordered list of classes
 * @throws JavaClassFormatError if a cyclic dependency has been found.
 */
public List<ClassInfo> findOrder(){
  printDependency();
  Set<ClassInfo> cliSet=clinit.keySet();
  List<ClassInfo> order=new LinkedList<ClassInfo>();
  int maxIter=cliSet.size();
  for (int i=0; i < maxIter && cliSet.size() != 0; ++i) {
    Iterator itCliSet=cliSet.iterator();
    while (itCliSet.hasNext()) {
      ClassInfo clinf=(ClassInfo)itCliSet.next();
      Set<ClassInfo> depends=clinit.get(clinf);
      if (depends.size() == 0) {
        order.add(clinf);
        for (        ClassInfo clinfInner : clinit.keySet()) {
          Set<ClassInfo> dep=clinit.get(clinfInner);
          dep.remove(clinf);
        }
        itCliSet.remove();
      }
    }
  }
  if (cliSet.size() != 0) {
    printDependency();
    throw new JavaClassFormatError(""String_Node_Str"");
  }
  return order;
}","/** 
 * Find a 'correct' oder for the static <clinit>. Throws an error on cyclic dependencies.
 * @return the ordered list of classes
 * @throws JavaClassFormatError if a cyclic dependency has been found.
 */
public List<ClassInfo> findOrder(){
  printDependency(false);
  Set<ClassInfo> cliSet=clinit.keySet();
  List<ClassInfo> order=new LinkedList<ClassInfo>();
  int maxIter=cliSet.size();
  for (int i=0; i < maxIter && cliSet.size() != 0; ++i) {
    Iterator itCliSet=cliSet.iterator();
    while (itCliSet.hasNext()) {
      ClassInfo clinf=(ClassInfo)itCliSet.next();
      Set<ClassInfo> depends=clinit.get(clinf);
      if (depends.size() == 0) {
        order.add(clinf);
        for (        ClassInfo clinfInner : clinit.keySet()) {
          Set<ClassInfo> dep=clinit.get(clinfInner);
          dep.remove(clinf);
        }
        itCliSet.remove();
      }
    }
  }
  if (cliSet.size() != 0) {
    printDependency(true);
    throw new JavaClassFormatError(""String_Node_Str"");
  }
  return order;
}",0.9955423476968795
186783,"private Set<ClassInfo> findDependencies(ClassInfo cli,MethodInfo method,boolean inRec){
  Set<ClassInfo> depends=new HashSet<ClassInfo>();
  if (method.isNative() || method.isAbstract()) {
    return depends;
  }
  ConstantPoolGen cpoolgen=cli.getConstantPoolGen();
  ConstantPool cpool=cpoolgen.getConstantPool();
  InstructionList il=method.getCode().getInstructionList();
  InstructionFinder f=new InstructionFinder(il);
  String cpInstr=""String_Node_Str"";
  for (Iterator it=f.search(cpInstr); it.hasNext(); ) {
    InstructionHandle[] match=(InstructionHandle[])it.next();
    InstructionHandle first=match[0];
    CPInstruction ii=(CPInstruction)first.getInstruction();
    int idx=ii.getIndex();
    Constant co=cpoolgen.getConstant(idx);
    ConstantClass cocl=null;
    Set addDepends=null;
    String clname;
    ClassInfo clinfo;
    MethodInfo minfo;
switch (co.getTag()) {
case Constants.CONSTANT_Class:
      cocl=(ConstantClass)co;
    clname=cocl.getBytes(cpool).replace('/','.');
  clinfo=cli.getAppInfo().getClassInfo(clname);
if (clinfo != null) {
  minfo=clinfo.getMethodInfo(""String_Node_Str"");
  if (minfo != null) {
    addDepends=findDependencies(clinfo,minfo,true);
  }
}
break;
case Constants.CONSTANT_InterfaceMethodref:
cocl=(ConstantClass)cpoolgen.getConstant(((ConstantInterfaceMethodref)co).getClassIndex());
break;
case Constants.CONSTANT_Methodref:
cocl=(ConstantClass)cpoolgen.getConstant(((ConstantMethodref)co).getClassIndex());
clname=cocl.getBytes(cpool).replace('/','.');
clinfo=cli.getAppInfo().getClassInfo(clname);
int sigidx=((ConstantMethodref)co).getNameAndTypeIndex();
ConstantNameAndType signt=(ConstantNameAndType)cpool.getConstant(sigidx);
String sigstr=signt.getName(cpool) + signt.getSignature(cpool);
if (clinfo != null) {
minfo=clinfo.getMethodInfo(sigstr);
if (minfo != null) {
addDepends=findDependencies(clinfo,minfo,true);
}
}
break;
case Constants.CONSTANT_Fieldref:
cocl=(ConstantClass)cpool.getConstant(((ConstantFieldref)co).getClassIndex());
break;
}
if (cocl != null) {
clname=cocl.getBytes(cpool).replace('/','.');
ClassInfo clinf=cli.getAppInfo().getClassInfo(clname);
if (clinf != null) {
if (clinf.getMethodInfo(clinitSig) != null) {
if (clinf != cli) {
depends.add(clinf);
}
}
}
}
if (addDepends != null) {
for (Object addDepend : addDepends) {
ClassInfo addCli=(ClassInfo)addDepend;
if (addCli == cli) {
throw new JavaClassFormatError(""String_Node_Str"");
}
depends.add(addCli);
}
}
}
il.dispose();
return depends;
}","private Set<ClassInfo> findDependencies(MethodInfo method,boolean inRec){
  Set<ClassInfo> depends=new HashSet<ClassInfo>();
  if (method.isNative() || method.isAbstract()) {
    return depends;
  }
  ConstantPoolGen cpoolgen=method.getConstantPoolGen();
  ConstantPool cpool=cpoolgen.getConstantPool();
  InstructionList il=method.getCode().getInstructionList();
  InstructionFinder f=new InstructionFinder(il);
  String cpInstr=""String_Node_Str"";
  for (Iterator it=f.search(cpInstr); it.hasNext(); ) {
    InstructionHandle[] match=(InstructionHandle[])it.next();
    InstructionHandle first=match[0];
    CPInstruction ii=(CPInstruction)first.getInstruction();
    int idx=ii.getIndex();
    Constant co=cpoolgen.getConstant(idx);
    ConstantClass cocl=null;
    Set addDepends=null;
    String clname;
    ClassInfo clinfo;
    MethodInfo minfo;
switch (co.getTag()) {
case Constants.CONSTANT_Class:
      cocl=(ConstantClass)co;
    clname=cocl.getBytes(cpool).replace('/','.');
  clinfo=method.getAppInfo().getClassInfo(clname);
if (clinfo != null) {
  minfo=clinfo.getMethodInfo(""String_Node_Str"");
  if (minfo != null) {
    addDepends=findDependencies(minfo,true);
  }
}
break;
case Constants.CONSTANT_InterfaceMethodref:
cocl=(ConstantClass)cpoolgen.getConstant(((ConstantInterfaceMethodref)co).getClassIndex());
break;
case Constants.CONSTANT_Methodref:
cocl=(ConstantClass)cpoolgen.getConstant(((ConstantMethodref)co).getClassIndex());
clname=cocl.getBytes(cpool).replace('/','.');
clinfo=method.getAppInfo().getClassInfo(clname);
int sigidx=((ConstantMethodref)co).getNameAndTypeIndex();
ConstantNameAndType signt=(ConstantNameAndType)cpool.getConstant(sigidx);
String sigstr=signt.getName(cpool) + signt.getSignature(cpool);
if (clinfo != null) {
minfo=clinfo.getMethodInfo(sigstr);
if (minfo != null) {
addDepends=findDependencies(minfo,true);
}
}
break;
case Constants.CONSTANT_Fieldref:
cocl=(ConstantClass)cpool.getConstant(((ConstantFieldref)co).getClassIndex());
break;
}
if (cocl != null) {
clname=cocl.getBytes(cpool).replace('/','.');
ClassInfo clinf=method.getAppInfo().getClassInfo(clname);
if (clinf != null) {
if (clinf.getMethodInfo(clinitSig) != null) {
if (!clinf.equals(method.getClassInfo())) {
depends.add(clinf);
}
}
}
}
if (addDepends != null) {
for (Object addDepend : addDepends) {
ClassInfo addCli=(ClassInfo)addDepend;
if (addCli.equals(method.getClassInfo())) {
throw new JavaClassFormatError(""String_Node_Str"");
}
depends.add(addCli);
}
}
}
return depends;
}",0.967703109327984
186784,"@Override public boolean visitClass(ClassInfo classInfo){
  MethodInfo mi=classInfo.getMethodInfo(clinitSig);
  if (mi != null) {
    Set<ClassInfo> depends=findDependencies(classInfo,mi,false);
    clinit.put(classInfo,depends);
  }
  return false;
}","@Override public boolean visitClass(ClassInfo classInfo){
  MethodInfo mi=classInfo.getMethodInfo(clinitSig);
  if (mi != null) {
    Set<ClassInfo> depends=findDependencies(mi,false);
    clinit.put(classInfo,depends);
  }
  return true;
}",0.8268839103869654
186785,"/** 
 * Print the dependency for debugging. Not used at the moment.
 */
private void printDependency(){
  Set<ClassInfo> cliSet=clinit.keySet();
  for (  ClassInfo clinf : cliSet) {
    System.out.println(""String_Node_Str"" + clinf.getClassName());
    Set<ClassInfo> depends=clinit.get(clinf);
    for (    ClassInfo clf : depends) {
      System.out.println(""String_Node_Str"" + clf.getClassName());
    }
  }
}","/** 
 * Print the dependency for debugging. Not used at the moment.
 * @param warn if true, print with warning level
 */
private void printDependency(boolean warn){
  Priority lvl=warn ? Level.WARN : Level.DEBUG;
  Set<ClassInfo> cliSet=clinit.keySet();
  for (  ClassInfo clinf : cliSet) {
    logger.log(lvl,""String_Node_Str"" + clinf.getClassName());
    Set<ClassInfo> depends=clinit.get(clinf);
    for (    ClassInfo clf : depends) {
      logger.log(lvl,""String_Node_Str"" + clf.getClassName());
    }
  }
}",0.8082340195016251
186786,"private boolean run(){
  try {
    project.setTopLevelLogger(exec.getExecLogger());
    exec.info(""String_Node_Str"");
    project.initialize();
    MethodInfo largestMethod=project.getWCETProcessorModel().getMethodCache().checkCache();
    int minWords=MiscUtils.bytesToWords(largestMethod.getCode().getNumberOfBytes(false));
    reportMetric(""String_Node_Str"",largestMethod.getFQMethodName(),minWords);
  }
 catch (  Exception e) {
    exec.logException(""String_Node_Str"",e);
    return false;
  }
  if (project.getProjectConfig().doObjectCacheAnalysis()) {
    ObjectCacheAnalysis oca=new ObjectCacheAnalysis(project);
    return oca.run();
  }
 else {
    return runWCETAnalysis();
  }
}","private boolean run(){
  try {
    project.setTopLevelLogger(exec.getExecLogger());
    exec.info(""String_Node_Str"");
    project.initialize();
    MethodInfo largestMethod=project.getWCETProcessorModel().getMethodCache().checkCache();
    int minWords=MiscUtils.bytesToWords(largestMethod.getCode().getNumberOfBytes());
    reportMetric(""String_Node_Str"",largestMethod.getFQMethodName(),minWords);
  }
 catch (  Exception e) {
    exec.logException(""String_Node_Str"",e);
    return false;
  }
  if (project.getProjectConfig().doObjectCacheAnalysis()) {
    ObjectCacheAnalysis oca=new ObjectCacheAnalysis(project);
    return oca.run();
  }
 else {
    return runWCETAnalysis();
  }
}",0.9963636363636365
186787,"private void doInvokeVirtual(String receiver,MethodInfo method,InstructionHandle stmt,Context context,ContextMap<CallString,Set<TypeMapping>> input,Interpreter<CallString,Set<TypeMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Set<TypeMapping>>> state,ContextMap<CallString,Set<TypeMapping>> result){
  String methodImplName=method.getClassName() + ""String_Node_Str"" + method.getMethodSignature();
  recordReceiver(stmt,context,methodImplName);
  int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
  Context c=new Context(context);
  c.stackPtr=method.getCode().getMaxLocals();
  if (method.isSynchronized()) {
    c.syncLevel=context.syncLevel + 1;
  }
  c.setMethodInfo(method);
  c.callString=c.callString.push(context.getMethodInfo(),stmt,callStringLength);
  boolean threaded=false;
  DFATool p=interpreter.getDFATool();
  if (p.getAppInfo().getClassInfo(receiver).isSubclassOf(p.getAppInfo().getClassInfo(""String_Node_Str"")) && ""String_Node_Str"".equals(method.getMethodSignature())) {
    c.createThread();
    threaded=true;
  }
  Set<TypeMapping> in=input.get(context.callString);
  Set<TypeMapping> out=new HashSet<TypeMapping>();
  ContextMap<CallString,Set<TypeMapping>> tmpresult=new ContextMap<CallString,Set<TypeMapping>>(c,new HashMap<CallString,Set<TypeMapping>>());
  tmpresult.put(c.callString,out);
  for (  TypeMapping m : in) {
    if (m.stackLoc < 0) {
      out.add(m);
    }
    if (m.stackLoc > varPtr) {
      out.add(new TypeMapping(m.stackLoc - varPtr,m.type));
    }
    if (m.stackLoc == varPtr) {
      ClassInfo staticClass=p.getAppInfo().getClassInfo(receiver);
      ClassInfo dynamicClass=null;
      try {
        p.getAppInfo().getClassInfo(m.type.split(""String_Node_Str"")[0]);
      }
 catch (      MissingClassError ex) {
        Logger.getLogger(this.getClass()).error(""String_Node_Str"" + staticClass + ""String_Node_Str""+ ex);
      }
      if (dynamicClass != null && dynamicClass.isSubclassOf(staticClass)) {
        out.add(new TypeMapping(0,m.type));
      }
    }
  }
  InstructionHandle entry=p.getEntryHandle(method);
  state.put(entry,join(state.get(entry),tmpresult));
  Map<InstructionHandle,ContextMap<CallString,Set<TypeMapping>>> r=interpreter.interpret(c,entry,state,false);
  InstructionHandle exit=p.getExitHandle(method);
  if (r.get(exit) != null) {
    Set<TypeMapping> returned=r.get(exit).get(c.callString);
    if (returned != null) {
      filterReturnSet(returned,result.get(context.callString),varPtr);
    }
  }
  if (threaded) {
    threads.put(methodImplName,new ContextMap<CallString,Set<TypeMapping>>(c,result));
    updateThreads(result,interpreter,state);
  }
}","private void doInvokeVirtual(String receiver,MethodInfo method,InstructionHandle stmt,Context context,ContextMap<CallString,Set<TypeMapping>> input,Interpreter<CallString,Set<TypeMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Set<TypeMapping>>> state,ContextMap<CallString,Set<TypeMapping>> result){
  String methodImplName=method.getClassName() + ""String_Node_Str"" + method.getMethodSignature();
  recordReceiver(stmt,context,methodImplName);
  int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
  Context c=new Context(context);
  c.stackPtr=method.getCode().getMaxLocals();
  if (method.isSynchronized()) {
    c.syncLevel=context.syncLevel + 1;
  }
  c.setMethodInfo(method);
  c.callString=c.callString.push(context.getMethodInfo(),stmt,callStringLength);
  boolean threaded=false;
  DFATool p=interpreter.getDFATool();
  if (p.getAppInfo().getClassInfo(receiver).isSubclassOf(p.getAppInfo().getClassInfo(""String_Node_Str"")) && ""String_Node_Str"".equals(method.getMethodSignature())) {
    c.createThread();
    threaded=true;
  }
  Set<TypeMapping> in=input.get(context.callString);
  Set<TypeMapping> out=new HashSet<TypeMapping>();
  ContextMap<CallString,Set<TypeMapping>> tmpresult=new ContextMap<CallString,Set<TypeMapping>>(c,new HashMap<CallString,Set<TypeMapping>>());
  tmpresult.put(c.callString,out);
  for (  TypeMapping m : in) {
    if (m.stackLoc < 0) {
      out.add(m);
    }
    if (m.stackLoc > varPtr) {
      out.add(new TypeMapping(m.stackLoc - varPtr,m.type));
    }
    if (m.stackLoc == varPtr) {
      ClassInfo staticClass=p.getAppInfo().getClassInfo(receiver);
      ClassInfo dynamicClass=null;
      try {
        dynamicClass=p.getAppInfo().getClassInfo(m.type.split(""String_Node_Str"")[0]);
      }
 catch (      MissingClassError ex) {
        logger.error(""String_Node_Str"" + staticClass + ""String_Node_Str""+ ex);
      }
      if (dynamicClass != null && dynamicClass.isSubclassOf(staticClass)) {
        out.add(new TypeMapping(0,m.type));
      }
    }
  }
  InstructionHandle entry=p.getEntryHandle(method);
  state.put(entry,join(state.get(entry),tmpresult));
  Map<InstructionHandle,ContextMap<CallString,Set<TypeMapping>>> r=interpreter.interpret(c,entry,state,false);
  InstructionHandle exit=p.getExitHandle(method);
  if (r.get(exit) != null) {
    Set<TypeMapping> returned=r.get(exit).get(c.callString);
    if (returned != null) {
      filterReturnSet(returned,result.get(context.callString),varPtr);
    }
  }
  if (threaded) {
    threads.put(methodImplName,new ContextMap<CallString,Set<TypeMapping>>(c,result));
    updateThreads(result,interpreter,state);
  }
}",0.990210843373494
186788,"/** 
 * @param args
 */
public static void main(String[] args){
  int start=0;
  int stop=0;
  int time=0;
  System.out.println(""String_Node_Str"");
  int nrCpu=Runtime.getRuntime().availableProcessors();
  if (nrCpu < 3) {
    throw new Error(""String_Node_Str"");
  }
  Runnable sender=new Runnable(){
    public void run(){
      PrivateScope scope=new PrivateScope(1000);
      Runnable r=new Runnable(){
        public void run(){
          while (NoC.isSending()) {
          }
          Native.wr(2,NoC.NOC_REG_SNDDST);
          Native.wr(CNT,NoC.NOC_REG_SNDCNT);
          for (int i=0; i < CNT; ++i) {
            Native.wr(i,NoC.NOC_REG_SNDDATA);
          }
        }
      }
;
      scope.enter(r);
    }
  }
;
  Runnable receiver=new Runnable(){
    public void run(){
      PrivateScope scope=new PrivateScope(1000);
      Runnable r=new Runnable(){
        public void run(){
          int buffer[]=new int[CNT];
          while (!NoC.isReceiving()) {
          }
          for (int i=0; i < CNT; ++i) {
            buffer[i]=Native.rd(NoC.NOC_REG_RCVDATA);
          }
          NoC.writeReset();
          finished=true;
        }
      }
;
      scope.enter(r);
    }
  }
;
  new RtThread(sender,1,1000).setProcessor(1);
  new RtThread(receiver,1,1000).setProcessor(2);
  System.out.println(""String_Node_Str"");
  RtThread.startMission();
  start=(int)System.currentTimeMillis();
  while (!finished) {
    ;
  }
  stop=(int)System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + start);
  System.out.println(""String_Node_Str"" + stop);
  time=stop - start;
  System.out.println(""String_Node_Str"" + time);
}","/** 
 * @param args
 */
public static void main(String[] args){
  int start=0;
  int stop=0;
  int time=0;
  System.out.println(""String_Node_Str"");
  int nrCpu=Runtime.getRuntime().availableProcessors();
  if (nrCpu < 3) {
    throw new Error(""String_Node_Str"");
  }
  Runnable sender=new Runnable(){
    public void run(){
      PrivateScope scope=new PrivateScope(1000);
      Runnable r=new Runnable(){
        public void run(){
          int buffer[]=new int[CNT];
          for (int i=0; i < CNT; ++i) {
            buffer[i]=i;
          }
          while (NoC.isSending()) {
          }
          Native.wr(2,NoC.NOC_REG_SNDDST);
          Native.wr(CNT,NoC.NOC_REG_SNDCNT);
          for (int i=0; i < CNT; ++i) {
            Native.wr(buffer[i],NoC.NOC_REG_SNDDATA);
          }
        }
      }
;
      scope.enter(r);
    }
  }
;
  Runnable receiver=new Runnable(){
    public void run(){
      PrivateScope scope=new PrivateScope(1000);
      Runnable r=new Runnable(){
        public void run(){
          int buffer[]=new int[CNT];
          while (!NoC.isReceiving()) {
          }
          for (int i=0; i < CNT; ++i) {
            buffer[i]=Native.rd(NoC.NOC_REG_RCVDATA);
          }
          NoC.writeReset();
          finished=true;
        }
      }
;
      scope.enter(r);
    }
  }
;
  new RtThread(sender,1,1000).setProcessor(1);
  new RtThread(receiver,1,1000).setProcessor(2);
  System.out.println(""String_Node_Str"");
  RtThread.startMission();
  start=(int)System.currentTimeMillis();
  while (!finished) {
    ;
  }
  stop=(int)System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + start);
  System.out.println(""String_Node_Str"" + stop);
  time=stop - start;
  System.out.println(""String_Node_Str"" + time);
}",0.9634218289085544
186789,"public static void main(String[] args){
  AESCsp aes=new AESCsp();
  int start=0;
  int stop=0;
  int time=0;
  System.out.println(""String_Node_Str"");
  int nrCpu=Runtime.getRuntime().availableProcessors();
  if (nrCpu < 3) {
    throw new Error(""String_Node_Str"");
  }
  new RtThread(aes.source,1,1000).setProcessor(1);
  new RtThread(aes.enc,1,1000).setProcessor(2);
  aes.reset(100);
  System.out.println(""String_Node_Str"");
  RtThread.startMission();
  start=(int)System.currentTimeMillis();
  while (!finished) {
    ;
  }
  stop=(int)System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + start);
  System.out.println(""String_Node_Str"" + stop);
  time=stop - start;
  System.out.println(""String_Node_Str"" + time);
  System.out.println(""String_Node_Str"" + aes.sink.ok);
}","public static void main(String[] args){
  AESCsp aes=new AESCsp();
  int start=0;
  int stop=0;
  int time=0;
  System.out.println(""String_Node_Str"");
  int nrCpu=Runtime.getRuntime().availableProcessors();
  if (nrCpu < 3) {
    throw new Error(""String_Node_Str"");
  }
  new RtThread(aes.source,1,1000).setProcessor(1);
  new RtThread(aes.enc,1,1000).setProcessor(2);
  aes.reset(10);
  System.out.println(""String_Node_Str"");
  RtThread.startMission();
  start=(int)System.currentTimeMillis();
  while (!finished) {
    ;
  }
  stop=(int)System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + start);
  System.out.println(""String_Node_Str"" + stop);
  time=stop - start;
  System.out.println(""String_Node_Str"" + time);
  System.out.println(""String_Node_Str"" + aes.sink.ok);
}",0.999366687777074
186790,"/** 
 * Check if this class is either an extension or an implementation of the given class or interface. <p>Note that this is slightly different from   {@code isExtensionOf() || isImplementationOf()}, because an interface is an instance of java.lang.Object, but it neither implements or extends java.lang.Object.</p>
 * @see #isExtensionOf(ClassInfo)
 * @param classInfo the super class to check.
 * @return true if this class is is a subtype of the given class.
 */
public boolean isSubclassOf(ClassInfo classInfo){
  if (!classInfo.isInterface()) {
    return classInfo.isSuperclassOf(this);
  }
  if (isInterface()) {
    return classInfo.isExtensionOf(this);
  }
 else {
    return classInfo.isImplementationOf(this);
  }
}","/** 
 * Check if this class is either an extension or an implementation of the given class or interface. <p>Note that this is slightly different from   {@code isExtensionOf() || isImplementationOf()}, because an interface is an instance of java.lang.Object, but it neither implements or extends java.lang.Object.</p>
 * @see #isExtensionOf(ClassInfo)
 * @param classInfo the super class to check.
 * @return true if this class is is a subtype of the given class.
 */
public boolean isSubclassOf(ClassInfo classInfo){
  if (!classInfo.isInterface()) {
    return classInfo.isSuperclassOf(this);
  }
  if (isInterface()) {
    return this.isExtensionOf(classInfo);
  }
 else {
    return this.isImplementationOf(classInfo);
  }
}",0.936726272352132
186791,"/** 
 * Find the class enclosing this class which is the same as or a superclass or an interface of the given class. If the given class is a subclass of this class, this returns null.
 * @param classInfo the (sub)class containing this class.
 * @param membersOnly if true, only check outer classes of member inner classes.
 * @return the found enclosing class or null if none found.
 */
public ClassInfo getEnclosingSuperClassOf(ClassInfo classInfo,boolean membersOnly){
  if (membersOnly && isLocalInnerClass()) {
    return null;
  }
  ClassInfo outer=enclosingClass;
  while (outer != null) {
    if (outer.isSubclassOf(classInfo)) {
      return outer;
    }
    if (membersOnly && outer.isLocalInnerClass()) {
      return null;
    }
 else {
      outer=outer.getEnclosingClassInfo();
    }
  }
  return null;
}","/** 
 * Find the class enclosing this class which is the same as or a superclass or an interface of the given class. If the given class is a subclass of this class, this returns null.
 * @param classInfo the (sub)class containing this class.
 * @param membersOnly if true, only check outer classes of member inner classes.
 * @return the found enclosing class or null if none found.
 */
public ClassInfo getEnclosingSuperClassOf(ClassInfo classInfo,boolean membersOnly){
  if (membersOnly && isLocalInnerClass()) {
    return null;
  }
  ClassInfo outer=enclosingClass;
  while (outer != null) {
    if (classInfo.isSubclassOf(outer)) {
      return outer;
    }
    if (membersOnly && outer.isLocalInnerClass()) {
      return null;
    }
 else {
      outer=outer.getEnclosingClassInfo();
    }
  }
  return null;
}",0.9828641370869032
186792,"private int mapIndex(int oldIndex){
  return idMap.get(oldIndex);
}","private int mapIndex(int oldIndex){
  if (oldIndex == 0)   return 0;
  return idMap.get(oldIndex);
}",0.8023952095808383
186793,"/** 
 * Find all referenced members in a class.
 * @param classInfo the class to search.
 * @param checkMembers if false, do not check fields and methods. Else check everything.
 * @return a set of class names and class member signatures found in the class.
 */
public static Set<String> findReferencedMembers(ClassInfo classInfo,boolean checkMembers){
  Set<String> members=new HashSet<String>();
  ClassMemberVisitor visitor=new ClassMemberVisitor(members);
  JavaClass javaClass=classInfo.compile();
  Set<Integer> ids=findPoolReferences(classInfo,javaClass);
  List<InvokeSite> invokes=new ArrayList<InvokeSite>();
  if (checkMembers) {
    for (    Field field : javaClass.getFields()) {
      FieldInfo fieldInfo=classInfo.getFieldInfo(field.getName());
      visitor.visitField(fieldInfo);
      ids.addAll(findPoolReferences(fieldInfo,field));
    }
    for (    Method method : javaClass.getMethods()) {
      MethodInfo methodInfo=classInfo.getMethodInfo(method.getName() + method.getSignature());
      visitor.visitMethod(methodInfo);
      ids.addAll(findPoolReferences(methodInfo,method,true));
    }
  }
  visitor.visitClass(classInfo);
  visitPoolReferences(classInfo,visitor,ids);
  return members;
}","/** 
 * Find all referenced members in a class.
 * @param classInfo the class to search.
 * @param checkMembers if false, do not check fields and methods. Else check everything.
 * @return a set of class names and class member signatures found in the class.
 */
public static Set<String> findReferencedMembers(ClassInfo classInfo,boolean checkMembers){
  Set<String> members=new HashSet<String>();
  ClassMemberVisitor visitor=new ClassMemberVisitor(members);
  JavaClass javaClass=classInfo.compile();
  Set<Integer> ids=findPoolReferences(classInfo,javaClass);
  List<InvokeSite> invokes=new ArrayList<InvokeSite>();
  if (checkMembers) {
    for (    Field field : javaClass.getFields()) {
      FieldInfo fieldInfo=classInfo.getFieldInfo(field.getName());
      visitor.visitField(fieldInfo);
      ids.addAll(findPoolReferences(fieldInfo,field));
    }
    for (    Method method : javaClass.getMethods()) {
      MethodInfo methodInfo=classInfo.getMethodInfo(method.getName() + method.getSignature());
      visitor.visitMethod(methodInfo);
      ids.addAll(findPoolReferences(methodInfo,method));
    }
  }
  visitor.visitClass(classInfo);
  visitPoolReferences(classInfo,visitor,ids);
  return members;
}",0.9081926718814328
186794,"@Override public void visitMethodCode(MethodCode methodCode){
  visitConstantUtf8(cpg.addUtf8(""String_Node_Str""));
}","@Override public void visitMethodCode(MethodCode methodCode){
  throw new AssertionError(""String_Node_Str"");
}",0.7876106194690266
186795,"/** 
 * Create a new visitor.
 * @param classInfo the classinfo which will be visited.
 * @param addInvokeSites if true, also remember all visited invocations (as well as the referenced index).
 */
public IdFinderVisitor(ClassInfo classInfo,boolean addInvokeSites){
  this.classInfo=classInfo;
  this.addInvokeSites=addInvokeSites;
  this.ids=new HashSet<Integer>();
  this.cpg=classInfo.getConstantPoolGen();
  this.cp=cpg.getConstantPool();
  this.invokeSites=new LinkedList<InvokeSite>();
  this.classTraverser=new DescendingClassTraverser(this);
}","/** 
 * Create a new visitor.
 * @param classInfo the classinfo which will be visited.
 */
public IdFinderVisitor(ClassInfo classInfo){
  this.classInfo=classInfo;
  this.ids=new HashSet<Integer>();
  this.cpg=classInfo.getConstantPoolGen();
  this.cp=cpg.getConstantPool();
  this.classTraverser=new DescendingClassTraverser(this);
}",0.3367231638418079
186796,"private static Set<Integer> findPoolReferences(FieldInfo fieldInfo,Field field){
  ClassInfo classInfo=fieldInfo.getClassInfo();
  IdFinderVisitor visitor=new IdFinderVisitor(classInfo,false);
  visitor.visitConstantUtf8(field.getNameIndex());
  visitor.visitConstantUtf8(field.getSignatureIndex());
  DescendingClassTraverser traverser=new DescendingClassTraverser(visitor);
  traverser.visitAttributes(fieldInfo,field.getAttributes());
  return visitor.getIds();
}","private static Set<Integer> findPoolReferences(FieldInfo fieldInfo,Field field){
  ClassInfo classInfo=fieldInfo.getClassInfo();
  IdFinderVisitor visitor=new IdFinderVisitor(classInfo);
  visitor.visitConstantUtf8(field.getNameIndex());
  visitor.visitConstantUtf8(field.getSignatureIndex());
  DescendingClassTraverser traverser=new DescendingClassTraverser(visitor);
  traverser.visitAttributes(fieldInfo,field.getAttributes());
  return visitor.getIds();
}",0.9935205183585312
186797,"private void visitInstructionList(MethodCode methodCode,InstructionList il){
  for (  InstructionHandle ih : il.getInstructionHandles()) {
    Instruction i=ih.getInstruction();
    if (addInvokeSites && i instanceof InvokeInstruction) {
      InvokeSite site=methodCode.getInvokeSite(ih);
      invokeSites.add(site);
    }
    if (i instanceof CPInstruction) {
      visitConstant(((CPInstruction)i).getIndex());
    }
  }
}","private void visitInstructionList(MethodCode methodCode,InstructionList il){
  for (  InstructionHandle ih : il.getInstructionHandles()) {
    Instruction i=ih.getInstruction();
    if (i instanceof CPInstruction) {
      visitConstant(((CPInstruction)i).getIndex());
    }
  }
}",0.6808510638297872
186798,"/** 
 * Rebuild the constantpool from a new, empty constantpool. <p>This updates the indices of all references in the code of all methods of this class, therefore do not call this method while modifying the code.</p> <p> Note that the ConstantPoolRebuilder implements ClassVisitor, so you can also use  {@link AppInfo#iterate(ClassVisitor)} to apply it to all classes.</p>
 * @param rebuilder the builder to use to rebuild the pool.
 */
public void rebuildConstantPool(ConstantPoolRebuilder rebuilder){
  ConstantPoolGen newPool=new ConstantPoolGen();
  Set<Integer> usedIndices=ClassReferenceFinder.findPoolReferences(this,true);
  rebuilder.createNewConstantPool(cpg,usedIndices);
  rebuilder.updateClassGen(this,classGen);
  for (  MethodInfo m : methods.values()) {
    rebuilder.updateMethodGen(m,m.getInternalMethodGen());
  }
  for (  FieldInfo f : fields.values()) {
    rebuilder.updateFieldGen(f,f.getInternalFieldGen());
  }
  cpg=newPool;
}","/** 
 * Rebuild the constantpool from a new, empty constantpool. <p>This updates the indices of all references in the code of all methods of this class, therefore do not call this method while modifying the code.</p> <p> Note that the ConstantPoolRebuilder implements ClassVisitor, so you can also use  {@link AppInfo#iterate(ClassVisitor)} to apply it to all classes.</p>
 * @param rebuilder the builder to use to rebuild the pool.
 */
public void rebuildConstantPool(ConstantPoolRebuilder rebuilder){
  ConstantPoolGen newPool=new ConstantPoolGen();
  Set<Integer> usedIndices=ConstantPoolReferenceFinder.findPoolReferences(this,true);
  rebuilder.createNewConstantPool(cpg,usedIndices);
  rebuilder.updateClassGen(this,classGen);
  for (  MethodInfo m : methods.values()) {
    rebuilder.updateMethodGen(m,m.getInternalMethodGen());
  }
  for (  FieldInfo f : fields.values()) {
    rebuilder.updateFieldGen(f,f.getInternalFieldGen());
  }
  cpg=newPool;
}",0.9921507064364208
186799,"/** 
 * Build a new InnerClasses Attribute containing entries for all inner classes referenced by the current constantpool, using the current ClassInfos or the old InnerClasses attribute to build the table.
 * @return a new InnerClasses attribute or null if this class does not reference any inner classes.
 */
public InnerClasses buildInnerClassesAttribute(){
  ConstantPoolGen cpg=classGen.getConstantPool();
  List<ClassRef> referencedClasses=new LinkedList<ClassRef>();
  for (  String name : ClassReferenceFinder.findReferencedClasses(classInfo)) {
    referencedClasses.add(classInfo.getAppInfo().getClassRef(name));
  }
  Collection<InnerClass> classes=buildInnerClasses(referencedClasses);
  if (classes.isEmpty()) {
    return null;
  }
  InnerClass[] ics=null;
  ics=classes.toArray(ics);
  int length=ics.length * 8 + 2;
  return new InnerClasses(cpg.addUtf8(""String_Node_Str""),length,ics,cpg.getConstantPool());
}","/** 
 * Build a new InnerClasses Attribute containing entries for all inner classes referenced by the current constantpool, using the current ClassInfos or the old InnerClasses attribute to build the table.
 * @return a new InnerClasses attribute or null if this class does not reference any inner classes.
 */
public InnerClasses buildInnerClassesAttribute(){
  ConstantPoolGen cpg=classGen.getConstantPool();
  List<ClassRef> referencedClasses=new LinkedList<ClassRef>();
  for (  String name : ConstantPoolReferenceFinder.findReferencedClasses(classInfo)) {
    referencedClasses.add(classInfo.getAppInfo().getClassRef(name));
  }
  Collection<InnerClass> classes=buildInnerClasses(referencedClasses);
  if (classes.isEmpty()) {
    return null;
  }
  InnerClass[] ics=null;
  ics=classes.toArray(ics);
  int length=ics.length * 8 + 2;
  return new InnerClasses(cpg.addUtf8(""String_Node_Str""),length,ics,cpg.getConstantPool());
}",0.9919224555735056
186800,"/** 
 * Remove attributes related to debugging (e.g. variable name mappings, stack maps, ..) except the linenumber table.
 */
public void removeDebugAttributes(){
  removeLocalVariables();
  for (  Attribute a : getAttributes()) {
    if (a instanceof StackMapTable || a instanceof StackMap) {
      removeAttribute(a);
    }
  }
}","/** 
 * Remove attributes related to debugging (e.g. variable name mappings, stack maps, ..) except the linenumber table.
 */
public void removeDebugAttributes(){
  removeLocalVariables();
  for (  Attribute a : getAttributes()) {
    if (a instanceof StackMapTable || a instanceof StackMap) {
      removeAttribute(a);
      continue;
    }
    ConstantUtf8 name=(ConstantUtf8)getConstantPoolGen().getConstant(a.getNameIndex());
    if (""String_Node_Str"".equals(name.getBytes())) {
      removeAttribute(a);
    }
  }
}",0.7779083431257344
186801,"/** 
 * Get the invoke instruction of the basic block (which must be the only instruction in the basic block)
 * @return the invoke instruction, or <code>null</code>, if the basic block doesn'tcontain an invoke instruction or if it is a special invoke.
 * @throws ControlFlowGraph.ControlFlowError if there is more than one invoke instruction in the block.
 * @see ProcessorModel#isSpecialInvoke(MethodInfo,Instruction)
 */
public InvokeInstruction getTheInvokeInstruction(){
  InvokeInstruction theInvInstr=null;
  for (  InstructionHandle ih : this.instructions) {
    if (!(ih.getInstruction() instanceof InvokeInstruction))     continue;
    InvokeInstruction inv=(InvokeInstruction)ih.getInstruction();
    if (this.getAppInfo().getProcessorModel().isSpecialInvoke(methodCode.getMethodInfo(),inv)) {
      continue;
    }
    if (theInvInstr != null) {
      throw new ControlFlowGraph.ControlFlowError(""String_Node_Str"");
    }
    theInvInstr=inv;
  }
  return theInvInstr;
}","/** 
 * Get the invoke instruction of the basic block (which must be the only instruction in the basic block)
 * @return the invoke instruction, or <code>null</code>, if the basic block doesn'tcontain an invoke instruction or if it is a special invoke.
 * @throws ControlFlowGraph.ControlFlowError if there is more than one invoke instruction in the block.
 * @see ProcessorModel#isSpecialInvoke(MethodInfo,Instruction)
 */
public InstructionHandle getTheInvokeInstruction(){
  InstructionHandle theInvInstr=null;
  for (  InstructionHandle ih : this.instructions) {
    if (!(ih.getInstruction() instanceof InvokeInstruction))     continue;
    InvokeInstruction inv=(InvokeInstruction)ih.getInstruction();
    if (this.getAppInfo().getProcessorModel().isSpecialInvoke(methodCode.getMethodInfo(),inv)) {
      continue;
    }
    if (theInvInstr != null) {
      throw new ControlFlowGraph.ControlFlowError(""String_Node_Str"");
    }
    theInvInstr=ih;
  }
  return theInvInstr;
}",0.9679062659195108
186802,"/** 
 * For a given non-empty callstring, find all implementations which might get called by the last invocation in the callstring, i.e. find all methods which might appear in the next entry of the callstring. <p> This does not check if the invocation is a special invoke, so if callstring length of the callgraph is zero, the results are not correct, instead use   {@link AppInfo#findImplementations(CallString)}. </p>
 * @param cs callstring of the invocation, must contain at least one invokesite.
 * @return a list of all methods which might get invoked by the top invocation of the callstring,with their callstrings.
 */
public Set<ExecutionContext> getImplementations(CallString cs){
  InvokeSite invoke=cs.top();
  Set<ExecutionContext> methods=new HashSet<ExecutionContext>();
  MethodRef invokeeRef=invoke.getInvokeeRef();
  MethodInfo invokee=invokeeRef.getMethodInfo();
  if (invokee == null) {
    logger.debug(""String_Node_Str"" + invokeeRef);
    return methods;
  }
  Set<ExecutionContext> invoker=getNodes(invoke.getMethod());
  for (  ExecutionContext invokeNode : invoker) {
    for (    ContextEdge outEdge : callGraph.outgoingEdgesOf(invokeNode)) {
      CallString cgString=outEdge.getTarget().getCallString();
      if (cgString.isEmpty()) {
        if (outEdge.getTarget().getMethodInfo().overrides(invokee,true)) {
          methods.add(outEdge.getTarget());
        }
      }
 else {
        if (cs.matches(cgString)) {
          methods.add(outEdge.getTarget());
        }
      }
    }
  }
  return methods;
}","/** 
 * For a given non-empty callstring, find all implementations which might get called by the last invocation in the callstring, i.e. find all methods which might appear in the next entry of the callstring. <p> This is only a lookup in the callgraph, and does not check if the invocation is a special invoke, so if callstring length of the callgraph is zero, the results are not correct. Instead use  {@link AppInfo#findImplementations(CallString)} which handles all special cases and falls backto the default callgraph. </p>
 * @param cs callstring of the invocation, must contain at least one invokesite.
 * @return a list of all methods which might get invoked by the top invocation of the callstring,with their callstrings.
 */
public Set<ExecutionContext> getImplementations(CallString cs){
  InvokeSite invoke=cs.top();
  Set<ExecutionContext> methods=new HashSet<ExecutionContext>();
  MethodRef invokeeRef=invoke.getInvokeeRef();
  MethodInfo invokee=invokeeRef.getMethodInfo();
  if (invokee == null) {
    logger.debug(""String_Node_Str"" + invokeeRef);
    return methods;
  }
  Set<ExecutionContext> invoker=getNodes(invoke.getMethod());
  for (  ExecutionContext invokeNode : invoker) {
    for (    ContextEdge outEdge : callGraph.outgoingEdgesOf(invokeNode)) {
      CallString cgString=outEdge.getTarget().getCallString();
      if (cgString.isEmpty()) {
        if (outEdge.getTarget().getMethodInfo().overrides(invokee,true)) {
          methods.add(outEdge.getTarget());
        }
      }
 else {
        if (cs.matches(cgString)) {
          methods.add(outEdge.getTarget());
        }
      }
    }
  }
  return methods;
}",0.9241899968543568
186803,"/** 
 * Add a basic block to this graph. The instruction list of the block must not be empty.
 * @param insertBefore insert the block at this position in the block list.
 * @param bb block to add
 * @return the new block node, either an InvokeNode, SpecialInvokeNode or BasicBlockNode, depending on thecontained instructions.
 */
public BasicBlockNode addBasicBlock(int insertBefore,BasicBlock bb){
  BasicBlockNode n;
  Instruction lastInstr=bb.getLastInstruction().getInstruction();
  InvokeInstruction theInvoke=bb.getTheInvokeInstruction();
  if (theInvoke != null) {
    n=new InvokeNode(bb,theInvoke);
  }
 else   if (appInfo.getProcessorModel().isImplementedInJava(lastInstr)) {
    MethodInfo javaImpl=appInfo.getProcessorModel().getJavaImplementation(appInfo,bb.getMethodInfo(),lastInstr);
    n=new SpecialInvokeNode(bb,javaImpl);
  }
 else {
    n=new BasicBlockNode(bb);
  }
  blocks.add(insertBefore,bb);
  graph.addVertex(n);
  return n;
}","/** 
 * Add a basic block to this graph. The instruction list of the block must not be empty.
 * @param insertBefore insert the block at this position in the block list.
 * @param bb block to add
 * @return the new block node, either an InvokeNode, SpecialInvokeNode or BasicBlockNode, depending on thecontained instructions.
 */
public BasicBlockNode addBasicBlock(int insertBefore,BasicBlock bb){
  BasicBlockNode n;
  Instruction lastInstr=bb.getLastInstruction().getInstruction();
  InstructionHandle theInvoke=bb.getTheInvokeInstruction();
  if (theInvoke != null) {
    n=new InvokeNode(bb,theInvoke);
  }
 else   if (appInfo.getProcessorModel().isImplementedInJava(lastInstr)) {
    MethodInfo javaImpl=appInfo.getProcessorModel().getJavaImplementation(appInfo,bb.getMethodInfo(),lastInstr);
    n=new SpecialInvokeNode(bb,javaImpl);
  }
 else {
    n=new BasicBlockNode(bb);
  }
  blocks.add(insertBefore,bb);
  graph.addVertex(n);
  return n;
}",0.9842602308499476
186804,"public InvokeNode(BasicBlock block,InvokeInstruction instr){
  super(block);
  this.instr=instr;
  this.referenced=methodInfo.getReferencedMethod(instr);
  this.name=""String_Node_Str"" + this.referenced + ""String_Node_Str"";
  if ((instr instanceof INVOKEINTERFACE) || (instr instanceof INVOKEVIRTUAL)) {
    receiverImpl=null;
  }
 else {
    receiverImpl=referenced.getMethodInfo();
  }
}","public InvokeNode(BasicBlock block,InstructionHandle instr){
  super(block);
  this.instr=(InvokeInstruction)instr.getInstruction();
  InvokeSite invokeSite=methodInfo.getCode().getInvokeSite(instr);
  this.referenced=invokeSite.getInvokeeRef();
  if (invokeSite.isVirtual()) {
    receiverImpl=null;
  }
 else {
    receiverImpl=referenced.getMethodInfo();
  }
  this.name=""String_Node_Str"" + this.referenced + ""String_Node_Str"";
}",0.4146341463414634
186805,"/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not the implementing class. </p>
 * @param invokee the method to resolve.
 * @return all possible implementations.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMemberSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.debug(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  boolean undefinedBaseMethod=false;
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      if (invokeeClass.isFullyKnown(true)) {
        throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
      }
 else {
        logger.debug(""String_Node_Str"" + invokee.toString());
        undefinedBaseMethod=true;
      }
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m=classInfo.getMethodInfo(methodSig);
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMemberSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  if (undefinedBaseMethod && methods.size() > 0) {
    throw new JavaClassFormatError(""String_Node_Str"" + invokee + ""String_Node_Str"");
  }
  return methods;
}","/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not of the implementing class. </p> <p>To handle invocations of super-methods correctly, use   {@link #findImplementations(InvokeSite)}instead.</p>
 * @see #findImplementations(InvokeSite)
 * @param invokee the method to resolve.
 * @return all possible implementations.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMemberSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.debug(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  boolean undefinedBaseMethod=false;
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      if (invokeeClass.isFullyKnown(true)) {
        throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
      }
 else {
        logger.debug(""String_Node_Str"" + invokee.toString());
        undefinedBaseMethod=true;
      }
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m=classInfo.getMethodInfo(methodSig);
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMemberSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  if (undefinedBaseMethod && methods.size() > 0) {
    throw new JavaClassFormatError(""String_Node_Str"" + invokee + ""String_Node_Str"");
  }
  return methods;
}",0.969435736677116
186806,"/** 
 * Build a new default callgraph using the current roots as roots for the callgraph, if the default callgraph has not yet been created.
 * @param rebuild if true, rebuild the graph if it already exists. All manual changes and optimizationsof the graph will be lost.
 * @return the default callgraph
 */
public CallGraph buildCallGraph(boolean rebuild){
  if (callGraph == null || rebuild) {
    CallgraphConfig config=new DefaultCallgraphConfig(getCallstringLength());
    callGraph=CallGraph.buildCallGraph(getMainMethod(),config);
  }
  return callGraph;
}","/** 
 * Build a new default callgraph using the current roots as roots for the callgraph, if the default callgraph has not yet been created.
 * @param rebuild if true, rebuild the graph if it already exists. All manual changes and optimizationsof the graph will be lost.
 * @return the default callgraph
 */
public CallGraph buildCallGraph(boolean rebuild){
  if (rebuild) {
    callGraph=null;
  }
  if (callGraph == null) {
    CallgraphConfig config=new DefaultCallgraphConfig(getCallstringLength());
    callGraph=CallGraph.buildCallGraph(getMainMethod(),config);
  }
  return callGraph;
}",0.9550173010380624
186807,"/** 
 * Check if this class inherits the given class member.
 * @param member the member to inherit.
 * @param checkInstanceOf if true, check if the member is defined in a superclass or interface of this class,else assume that this has already been checked.
 * @return true if this class inherits it.
 */
public boolean inherits(ClassMemberInfo member,boolean checkInstanceOf){
  ClassInfo cls=member.getClassInfo();
  if (checkInstanceOf && !isInstanceOf(cls)) {
    return false;
  }
  return canAccess(cls,member.getAccessType());
}","/** 
 * Check if this class inherits the given class member.
 * @param member the member to inherit.
 * @param checkInstanceOf if true, check if the member is defined in a superclass or interface of this class,else assume that this has already been checked.
 * @return true if this class inherits it.
 */
public boolean inherits(ClassMemberInfo member,boolean checkInstanceOf){
  ClassInfo cls=member.getClassInfo();
  if (checkInstanceOf && !isSubclassOf(cls)) {
    return false;
  }
  return canAccess(cls,member.getAccessType());
}",0.9850467289719628
186808,"/** 
 * Check if the given class is the same as this class or a subclass of this class. This does not check the implemented interfaces. For interfaces this will always return false, even if the given class implements the given interface.
 * @see #isInstanceOf(ClassInfo)
 * @see #isExtensionOf(ClassInfo)
 * @param classInfo the possible subclass of this class.
 * @return true if the given class is this class or a superclass of this class.
 */
public boolean isSuperclassOf(ClassInfo classInfo){
  ClassInfo cls=classInfo;
  while (cls != null) {
    if (this.equals(cls)) {
      return true;
    }
    cls=cls.getSuperClassInfo();
  }
  return false;
}","/** 
 * Check if the given class is the same as this class or a subclass of this class. This does not check the implemented interfaces. For interfaces this will always return false, even if the given class implements the given interface.
 * @see #isSubclassOf(ClassInfo)
 * @see #isExtensionOf(ClassInfo)
 * @param classInfo the possible subclass of this class.
 * @return true if the given class is this class or a superclass of this class.
 */
public boolean isSuperclassOf(ClassInfo classInfo){
  ClassInfo cls=classInfo;
  while (cls != null) {
    if (this.equals(cls)) {
      return true;
    }
    cls=cls.getSuperClassInfo();
  }
  return false;
}",0.9878048780487804
186809,"/** 
 * Check if this class is an extension of the given class, i.e. if this is a class, check if the given class is a superclass, if this is an interface, check if the given class is an interface and if this is an extension of the given interface.
 * @see #isInstanceOf(ClassInfo)
 * @see #isImplementationOf(ClassInfo)
 * @param classInfo the class to check.
 * @return true if the class is an extension of this class.
 */
public boolean isExtensionOf(ClassInfo classInfo){
  if (!isInterface()) {
    return !classInfo.isInterface() && classInfo.isSuperclassOf(this);
  }
  if (!classInfo.isInterface()) {
    return false;
  }
  Set<ClassInfo> interfaces=getAncestors();
  return interfaces.contains(classInfo);
}","/** 
 * Check if this class is an extension of the given class, i.e. if this is a class, check if the given class is a superclass, if this is an interface, check if the given class is an interface and if this is an extension of the given interface.
 * @see #isSubclassOf(ClassInfo)
 * @see #isImplementationOf(ClassInfo)
 * @param classInfo the class to check.
 * @return true if the class is an extension of this class.
 */
public boolean isExtensionOf(ClassInfo classInfo){
  if (!isInterface()) {
    return !classInfo.isInterface() && classInfo.isSuperclassOf(this);
  }
  if (!classInfo.isInterface()) {
    return false;
  }
  Set<ClassInfo> interfaces=getAncestors();
  return interfaces.contains(classInfo);
}",0.98884239888424
186810,"/** 
 * Find the class enclosing this class which is the same as or a superclass or an interface of the given class. If the given class is a subclass of this class, this returns null.
 * @param classInfo the (sub)class containing this class.
 * @param membersOnly if true, only check outer classes of member inner classes.
 * @return the found enclosing class or null if none found.
 */
public ClassInfo getEnclosingSuperClassOf(ClassInfo classInfo,boolean membersOnly){
  if (membersOnly && isLocalInnerClass()) {
    return null;
  }
  ClassInfo outer=enclosingClass;
  while (outer != null) {
    if (outer.isInstanceOf(classInfo)) {
      return outer;
    }
    if (membersOnly && outer.isLocalInnerClass()) {
      return null;
    }
 else {
      outer=outer.getEnclosingClassInfo();
    }
  }
  return null;
}","/** 
 * Find the class enclosing this class which is the same as or a superclass or an interface of the given class. If the given class is a subclass of this class, this returns null.
 * @param classInfo the (sub)class containing this class.
 * @param membersOnly if true, only check outer classes of member inner classes.
 * @return the found enclosing class or null if none found.
 */
public ClassInfo getEnclosingSuperClassOf(ClassInfo classInfo,boolean membersOnly){
  if (membersOnly && isLocalInnerClass()) {
    return null;
  }
  ClassInfo outer=enclosingClass;
  while (outer != null) {
    if (outer.isSubclassOf(classInfo)) {
      return outer;
    }
    if (membersOnly && outer.isLocalInnerClass()) {
      return null;
    }
 else {
      outer=outer.getEnclosingClassInfo();
    }
  }
  return null;
}",0.9902080783353732
186811,"/** 
 * Check if a member of another class with the given accessType can be accessed by this class or this class member. Note that only methods are able to access local classes.
 * @param cls the class containing the member to check.
 * @param accessType the accessType of the member to check, as returned by {@link MemberInfo#getAccessType()}.
 * @return true if this class is allowed to access members of the given accessType of the given class.
 */
public boolean canAccess(ClassInfo cls,AccessType accessType){
  if (!canAccess(cls)) {
    return false;
  }
switch (accessType) {
case ACC_PUBLIC:
    return true;
case ACC_PROTECTED:
  if (getClassInfo().isInstanceOf(cls)) {
    return true;
  }
case ACC_PACKAGE:
return getClassInfo().hasSamePackage(cls);
case ACC_PRIVATE:
return this.equals(cls) || cls.getInnerClassesInfo().isNestedClassOf(getClassInfo(),true);
}
return false;
}","/** 
 * Check if a member of another class with the given accessType can be accessed by this class or this class member. Note that only methods are able to access local classes.
 * @param cls the class containing the member to check.
 * @param accessType the accessType of the member to check, as returned by {@link MemberInfo#getAccessType()}.
 * @return true if this class is allowed to access members of the given accessType of the given class.
 */
public boolean canAccess(ClassInfo cls,AccessType accessType){
  if (!canAccess(cls)) {
    return false;
  }
switch (accessType) {
case ACC_PUBLIC:
    return true;
case ACC_PROTECTED:
  if (getClassInfo().isSubclassOf(cls)) {
    return true;
  }
case ACC_PACKAGE:
return getClassInfo().hasSamePackage(cls);
case ACC_PRIVATE:
return this.equals(cls) || cls.getInnerClassesInfo().isNestedClassOf(getClassInfo(),true);
}
return false;
}",0.990990990990991
186812,"/** 
 * Check if this method is the same as or overrides a given method.
 * @param superMethod the superMethod to check.
 * @param checkSignature if true, check if the given method has the same signature and is defined in a subclassof this method's class.
 * @return true if this method overrides the given method and can access the method.
 */
public boolean overrides(MethodInfo superMethod,boolean checkSignature){
  if (this.equals(superMethod)) {
    return true;
  }
  if (isStatic()) {
    return false;
  }
  if (superMethod.isStatic()) {
    logger.warn(""String_Node_Str"" + getSignature() + ""String_Node_Str""+ superMethod.getSignature());
  }
  if (checkSignature) {
    if (!getMemberSignature().equals(superMethod.getMemberSignature())) {
      return false;
    }
    if (!getClassInfo().isInstanceOf(superMethod.getClassInfo())) {
      return false;
    }
  }
  return getClassInfo().canAccess(superMethod);
}","/** 
 * Check if this method is the same as or overrides a given method.
 * @param superMethod the superMethod to check.
 * @param checkSignature if true, check if the given method has the same signature and is defined in a subclassof this method's class.
 * @return true if this method overrides the given method and can access the method.
 */
public boolean overrides(MethodInfo superMethod,boolean checkSignature){
  if (this.equals(superMethod)) {
    return true;
  }
  if (isStatic()) {
    return false;
  }
  if (superMethod.isStatic()) {
    logger.warn(""String_Node_Str"" + getSignature() + ""String_Node_Str""+ superMethod.getSignature());
  }
  if (checkSignature) {
    if (!getMemberSignature().equals(superMethod.getMemberSignature())) {
      return false;
    }
    if (!getClassInfo().isSubclassOf(superMethod.getClassInfo())) {
      return false;
    }
  }
  return getClassInfo().canAccess(superMethod);
}",0.8894907908992417
186813,"/** 
 * For a given non-empty callstring, find all implementations which might get called by the last invocation in the callstring, i.e. find all methods which might appear in the next entry of the callstring. 
 * @param cs callstring of the invocation, must contain at least one invokesite.
 * @return a list of all methods which might get invoked by the top invocation of the callstring,with their callstrings.
 */
public Set<ExecutionContext> getImplementations(CallString cs){
  InvokeSite invoke=cs.top();
  Set<ExecutionContext> methods=new HashSet<ExecutionContext>();
  MethodRef invokee=invoke.getInvokeeRef();
  Set<ExecutionContext> invoker=getNodes(invoke.getMethod());
  for (  ExecutionContext invokeNode : invoker) {
    for (    ContextEdge outEdge : callGraph.outgoingEdgesOf(invokeNode)) {
      CallString cgString=outEdge.getTarget().getCallString();
      if (cgString.isEmpty()) {
        if (outEdge.getTarget().getMethodInfo().overrides(invokee.getMethodInfo(),true)) {
          methods.add(outEdge.getTarget());
        }
      }
 else {
        if (cs.matches(cgString)) {
          methods.add(outEdge.getTarget());
        }
      }
    }
  }
  return methods;
}","/** 
 * For a given non-empty callstring, find all implementations which might get called by the last invocation in the callstring, i.e. find all methods which might appear in the next entry of the callstring. <p> This does not check if the invocation is a special invoke, so if callstring length of the callgraph is zero, the results are not correct, instead use   {@link AppInfo#findImplementations(CallString)}. </p>
 * @param cs callstring of the invocation, must contain at least one invokesite.
 * @return a list of all methods which might get invoked by the top invocation of the callstring,with their callstrings.
 */
public Set<ExecutionContext> getImplementations(CallString cs){
  InvokeSite invoke=cs.top();
  Set<ExecutionContext> methods=new HashSet<ExecutionContext>();
  MethodRef invokee=invoke.getInvokeeRef();
  Set<ExecutionContext> invoker=getNodes(invoke.getMethod());
  for (  ExecutionContext invokeNode : invoker) {
    for (    ContextEdge outEdge : callGraph.outgoingEdgesOf(invokeNode)) {
      CallString cgString=outEdge.getTarget().getCallString();
      if (cgString.isEmpty()) {
        if (outEdge.getTarget().getMethodInfo().overrides(invokee.getMethodInfo(),true)) {
          methods.add(outEdge.getTarget());
        }
      }
 else {
        if (cs.matches(cgString)) {
          methods.add(outEdge.getTarget());
        }
      }
    }
  }
  return methods;
}",0.9193361636433808
186814,List<ExecutionContext> getInvokedMethods(ExecutionContext context);,Set<ExecutionContext> getInvokedMethods(ExecutionContext context);,0.962406015037594
186815,"/** 
 * Build the callgraph. <p>NEW: now we also use callstrings to get a more precise call graph model</p>
 */
private void buildGraph(){
  callGraph.addGraphListener(new GraphUpdateListener());
  callGraph.addVertex(rootNode);
  if (parent == null) {
    Stack<ExecutionContext> todo=new Stack<ExecutionContext>();
    todo.push(rootNode);
    while (!todo.empty()) {
      ExecutionContext current=todo.pop();
      List<ExecutionContext> invoked=config.getInvokedMethods(current);
      for (      ExecutionContext cgn : invoked) {
        if (!callGraph.containsVertex(cgn)) {
          callGraph.addVertex(cgn);
          todo.push(cgn);
        }
        callGraph.addEdge(current,cgn);
      }
    }
  }
 else {
    cloneReachableGraph(rootNode);
  }
}","/** 
 * Build the callgraph. <p>NEW: now we also use callstrings to get a more precise call graph model</p>
 */
private void buildGraph(){
  callGraph.addGraphListener(new GraphUpdateListener());
  callGraph.addVertex(rootNode);
  if (parent == null) {
    Stack<ExecutionContext> todo=new Stack<ExecutionContext>();
    todo.push(rootNode);
    while (!todo.empty()) {
      ExecutionContext current=todo.pop();
      Set<ExecutionContext> invoked=config.getInvokedMethods(current);
      for (      ExecutionContext cgn : invoked) {
        if (!callGraph.containsVertex(cgn)) {
          callGraph.addVertex(cgn);
          todo.push(cgn);
        }
        callGraph.addEdge(current,cgn);
      }
    }
  }
 else {
    cloneReachableGraph(rootNode);
  }
}",0.9967083607636604
186816,"protected Set<MethodInfo> getInvokedMethods(ExecutionContext context,InvokeSite invokeSite){
  return AppInfo.getSingleton().findImplementations(invokeSite.getInvokeeRef());
}","protected Set<MethodInfo> getInvokedMethods(ExecutionContext context,InvokeSite invokeSite){
  return AppInfo.getSingleton().findImplementations(invokeSite,context.getCallString());
}",0.9273743016759776
186817,"/** 
 * @return a method reference to the invokee method.
 */
public MethodRef getInvokeeRef(){
  Instruction instr=instruction.getInstruction();
  AppInfo appInfo=AppInfo.getSingleton();
  if (instr instanceof InvokeInstruction) {
    return appInfo.getReferencedMethod(invoker,(InvokeInstruction)instr);
  }
  if (appInfo.getProcessorModel().isImplementedInJava(instr)) {
    return appInfo.getProcessorModel().getJavaImplementation(appInfo,invoker,instr).getMethodRef();
  }
  throw new JavaClassFormatError(""String_Node_Str"" + toString());
}","/** 
 * Get the MethodRef to the referenced method. <p>Note that this does not resolve to the super  method or does not find all implementations. Use   {@link AppInfo#findImplementations(InvokeSite)} if you want tofind the possible implementing methods of this call.</p>
 * @see AppInfo#getReferencedMethod(MethodInfo,InvokeInstruction)
 * @return a method reference to the invokee method.
 */
public MethodRef getInvokeeRef(){
  Instruction instr=instruction.getInstruction();
  AppInfo appInfo=AppInfo.getSingleton();
  if (instr instanceof InvokeInstruction) {
    return appInfo.getReferencedMethod(invoker,(InvokeInstruction)instr);
  }
  if (appInfo.getProcessorModel().isImplementedInJava(instr)) {
    return appInfo.getProcessorModel().getJavaImplementation(appInfo,invoker,instr).getMethodRef();
  }
  throw new JavaClassFormatError(""String_Node_Str"" + toString());
}",0.7665260196905767
186818,"private void handleClassLoadFailure(String message,Exception cause){
  if (exitOnMissingClass) {
    logger.error(message,cause);
    System.exit(4);
  }
 else {
    throw new MissingClassError(message,cause);
  }
}","private void handleClassLoadFailure(String message,Exception cause){
  throw new MissingClassError(message,cause);
}",0.7009063444108762
186819,"/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not the implementing class. </p>
 * @param invokee the method to resolve.
 * @return all possible implementations.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMemberSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.warn(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m=classInfo.getMethodInfo(methodSig);
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMemberSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  return methods;
}","/** 
 * Find all methods which might get invoked for a given methodRef. This does not use the callgraph to eliminate methods. If you want a more precise result, use   {@link #findImplementations(InvokeSite,CallString)} and use callgraph thinning first.<p> Note that this method is slightly different from  {@link MethodInfo#getImplementations(boolean)}, since it returns only methods for subclasses of the invokee class, not the implementing class. </p>
 * @param invokee the method to resolve.
 * @return all possible implementations.
 */
public Set<MethodInfo> findImplementations(final MethodRef invokee){
  final Set<MethodInfo> methods=new HashSet<MethodInfo>();
  final MethodInfo method=invokee.getMethodInfo();
  if (method != null && (method.isStatic() || method.isPrivate())) {
    methods.add(method);
    return methods;
  }
  final String methodSig=invokee.getMemberSignature();
  final ClassInfo invokeeClass=invokee.getClassRef().getClassInfo();
  if (invokeeClass == null) {
    logger.debug(""String_Node_Str"" + invokee.toString());
    return methods;
  }
  boolean undefinedBaseMethod=false;
  if (invokeeClass.getMethodInfo(methodSig) == null) {
    if (method != null && !method.isAbstract()) {
      methods.add(method);
    }
 else     if (method == null) {
      if (invokeeClass.isFullyKnown(true)) {
        throw new JavaClassFormatError(""String_Node_Str"" + invokee.toString());
      }
 else {
        logger.debug(""String_Node_Str"" + invokee.toString());
        undefinedBaseMethod=true;
      }
    }
  }
  ClassVisitor visitor=new ClassVisitor(){
    public boolean visitClass(    ClassInfo classInfo){
      MethodInfo m=classInfo.getMethodInfo(methodSig);
      if (m != null) {
        if (m.isPrivate() && !classInfo.equals(invokeeClass)) {
          logger.error(""String_Node_Str"" + m.getMemberSignature() + ""String_Node_Str""+ classInfo.getClassName()+ ""String_Node_Str""+ invokee.getClassName());
        }
        if (!m.isAbstract() && (method == null || m.overrides(method,false))) {
          methods.add(m);
        }
      }
      return true;
    }
    public void finishClass(    ClassInfo classInfo){
    }
  }
;
  ClassHierarchyTraverser traverser=new ClassHierarchyTraverser(visitor);
  traverser.setVisitSubclasses(true,true);
  traverser.traverseDown(invokeeClass);
  if (undefinedBaseMethod && methods.size() > 0) {
    throw new JavaClassFormatError(""String_Node_Str"" + invokee + ""String_Node_Str"");
  }
  return methods;
}",0.917227894851184
186820,"/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  if (config.hasOption(Config.PROCESSOR_MODEL)) {
    initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  }
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args.length > 0 ? args[0].replace('/','.') : null);
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    loadClassInfos();
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupAppInfo(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
}","/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  if (config.hasOption(Config.PROCESSOR_MODEL)) {
    initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args.length > 0 ? args[0].replace('/','.') : null);
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    loadClassInfos();
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupAppInfo(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
}",0.9601328903654484
186821,"private void initProcessorModel(Model model){
  ProcessorModel pm;
switch (model) {
case JOP:
    pm=new JOPModel(config);
  break;
case jamuth:
pm=new JamuthModel(config);
break;
case allocation:
pm=new AllocationModel(config);
break;
default :
throw new BadConfigurationError(""String_Node_Str"" + model);
}
appInfo.setProcessorModel(pm);
}","private void initProcessorModel(Model model){
  ProcessorModel pm;
switch (model) {
case JOP:
    pm=new JOPModel(config);
  break;
case jamuth:
pm=new JamuthModel(config);
break;
case allocation:
pm=new AllocationModel(config);
break;
default :
throw new BadConfigurationError(""String_Node_Str"" + model);
}
appInfo.setProcessorModel(pm);
for (String jvmClass : pm.getJVMClasses()) {
ClassInfo rootInfo=appInfo.loadClass(jvmClass.replaceAll(""String_Node_Str"",""String_Node_Str""));
if (rootInfo == null) {
System.err.println(""String_Node_Str"" + jvmClass + ""String_Node_Str"");
System.exit(4);
}
appInfo.addRoot(rootInfo);
}
if (appInfo.doLoadNatives()) {
for (String nativeClass : pm.getNativeClasses()) {
ClassInfo rootInfo=appInfo.loadClass(nativeClass.replaceAll(""String_Node_Str"",""String_Node_Str""));
if (rootInfo == null) {
System.err.println(""String_Node_Str"" + nativeClass + ""String_Node_Str"");
System.exit(4);
}
appInfo.addRoot(rootInfo);
}
}
}",0.5275407292474786
186822,"/** 
 * Get a set of all superclasses (including this class) and all implemented/extended interfaces.
 * @return a set of all superclasses and all interfaces of this class.
 */
public Set<ClassInfo> getAncestors(){
  Set<ClassInfo> sc=new HashSet<ClassInfo>();
  List<ClassInfo> queue=new LinkedList<ClassInfo>();
  queue.add(this);
  while (!queue.isEmpty()) {
    ClassInfo cls=queue.remove(0);
    sc.add(cls);
    ClassInfo superClass=cls.getSuperClassInfo();
    if (superClass != null && !sc.contains(superClass)) {
      queue.add(cls);
    }
    for (    ClassInfo i : cls.getInterfaces()) {
      if (!sc.contains(i)) {
        queue.add(i);
      }
    }
  }
  return sc;
}","/** 
 * Get a set of all superclasses (including this class) and all implemented/extended interfaces.
 * @return a set of all superclasses and all interfaces of this class.
 */
public Set<ClassInfo> getAncestors(){
  Set<ClassInfo> sc=new HashSet<ClassInfo>();
  List<ClassInfo> queue=new LinkedList<ClassInfo>();
  queue.add(this);
  while (!queue.isEmpty()) {
    ClassInfo cls=queue.remove(0);
    sc.add(cls);
    ClassInfo superClass=cls.getSuperClassInfo();
    if (superClass != null && !sc.contains(superClass)) {
      queue.add(superClass);
    }
    for (    ClassInfo i : cls.getInterfaces()) {
      if (!sc.contains(i)) {
        queue.add(i);
      }
    }
  }
  return sc;
}",0.9919883466860888
186823,"public MethodRef getEnclosingMethodRef(){
  for (  Attribute a : classInfo.getAttributes()) {
    if (a instanceof EnclosingMethod) {
      return ((EnclosingMethod)a).getMethodRef();
    }
  }
  return null;
}","public MethodRef getEnclosingMethodRef(){
  EnclosingMethod m=getEnclosingMethod();
  return m == null ? null : m.getMethodRef();
}",0.5630498533724341
186824,"/** 
 * Get the name of the immediatly enclosing class of this class, if this is a nested class (member or local), or null if this is not a nested class.
 * @see #getOuterClassName()
 * @return the immediatly enclosing class of this class, or null if this is a top-level class.
 */
public String getEnclosingClassName(){
  if (!aNestedClass) {
    return null;
  }
  if (enclosingClass != null) {
    return enclosingClass.getClassName();
  }
  String name=getOuterClassName();
  if (name == null) {
    MethodRef ref=getEnclosingMethodRef();
    if (ref != null) {
      return ref.getClassName();
    }
 else {
      throw new JavaClassFormatError(""String_Node_Str"" + getClassName());
    }
  }
 else {
    return name;
  }
}","/** 
 * Get the name of the immediatly enclosing class of this class, if this is a nested class (member or local), or null if this is not a nested class.
 * @see #getOuterClassName()
 * @return the immediatly enclosing class of this class, or null if this is a top-level class.
 */
public String getEnclosingClassName(){
  if (!aNestedClass) {
    return null;
  }
  if (enclosingClass != null) {
    return enclosingClass.getClassName();
  }
  String name=getOuterClassName();
  if (name == null) {
    EnclosingMethod m=getEnclosingMethod();
    if (m != null) {
      return m.getClassName();
    }
 else {
      throw new JavaClassFormatError(""String_Node_Str"" + getClassName());
    }
  }
 else {
    return name;
  }
}",0.980013783597519
186825,"public MethodRef getMethodRef(){
  return AppInfo.getSingleton().getMethodRef(getSignature());
}","public MethodRef getMethodRef(){
  return methodIndex == 0 ? null : AppInfo.getSingleton().getMethodRef(getSignature());
}",0.8807339449541285
186826,"public Signature getSignature(){
  ConstantClass cls=(ConstantClass)constant_pool.getConstant(classIndex);
  ConstantNameAndType nat=(ConstantNameAndType)constant_pool.getConstant(methodIndex);
  return new Signature(cls.getBytes(constant_pool).replace('/','.'),nat.getName(constant_pool),Descriptor.parse(nat.getSignature(constant_pool)));
}","public Signature getSignature(){
  if (methodIndex == 0) {
    return new Signature(getClassName());
  }
  ConstantNameAndType nat=(ConstantNameAndType)constant_pool.getConstant(methodIndex);
  return new Signature(getClassName(),nat.getName(constant_pool),Descriptor.parse(nat.getSignature(constant_pool)));
}",0.7085889570552147
186827,"private void visitReferences(Set<String> refs){
  for (  String signature : refs) {
    Signature sig=Signature.parse(signature,false);
    ClassInfo cls=getClassInfo(sig.getClassName());
    if (cls == null) {
      ignoreClass(sig.getClassName());
      continue;
    }
    markUsedMembers(cls,false);
    if (sig.isMethodSignature()) {
      MethodRef ref=appInfo.getMethodRef(sig);
      for (      MethodInfo method : findMethods(ref)) {
        markUsedMembers(method);
      }
    }
 else     if (sig.hasMemberName()) {
      FieldRef ref=appInfo.getFieldRef(sig);
      FieldInfo field=ref.getFieldInfo();
      if (field == null) {
        throw new JavaClassFormatError(""String_Node_Str"" + signature + ""String_Node_Str"");
      }
      markUsedMembers(field);
    }
  }
}","private void visitReferences(Set<String> refs){
  for (  String signature : refs) {
    Signature sig=Signature.parse(signature,false);
    ClassInfo cls=getClassInfo(sig);
    if (cls == null) {
      continue;
    }
    markUsedMembers(cls,false);
    if (sig.isMethodSignature()) {
      MethodRef ref=appInfo.getMethodRef(sig);
      for (      MethodInfo method : findMethods(ref)) {
        markUsedMembers(method);
      }
    }
 else     if (sig.hasMemberName()) {
      FieldRef ref=appInfo.getFieldRef(sig);
      FieldInfo field=ref.getFieldInfo();
      if (field == null) {
        throw new JavaClassFormatError(""String_Node_Str"" + signature + ""String_Node_Str"");
      }
      markUsedMembers(field);
    }
  }
}",0.9641909814323608
186828,"private ClassInfo getClassInfo(String className){
  return appInfo.getClassInfo(className);
}","private ClassInfo getClassInfo(Signature sig){
  String className;
  if (sig.isArraySignature()) {
    ArrayTypeInfo at=ArrayTypeInfo.parse(sig.getClassName());
    if (at.getElementType() instanceof ObjectTypeInfo) {
      className=((ObjectTypeInfo)at.getElementType()).getClassRef().getClassName();
    }
 else {
      return null;
    }
  }
 else {
    className=sig.getClassName();
  }
  ClassInfo classInfo=appInfo.getClassInfo(className);
  if (classInfo == null) {
    ignoreClass(className);
  }
  return classInfo;
}",0.1324717285945072
186829,"public static void main(String[] args){
  AppSetup setup=new AppSetup();
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.setVersionInfo(VERSION);
  DFATool dfaTool=new DFATool();
  WCETTool wcetTool=new WCETTool();
  JCopter jcopter=new JCopter();
  setup.registerTool(""String_Node_Str"",dfaTool,true,false);
  setup.registerTool(""String_Node_Str"",wcetTool,true,true);
  setup.registerTool(""String_Node_Str"",jcopter);
  setup.initAndLoad(args,true,true,true);
  if (setup.useTool(""String_Node_Str"")) {
    wcetTool.setDfaTool(dfaTool);
    jcopter.setDfaTool(dfaTool);
  }
  if (setup.useTool(""String_Node_Str"")) {
    jcopter.setWcetTool(wcetTool);
  }
  String[] rest=setup.setupConfig(args);
  setup.setupLogger(true);
  setup.setupAppInfo(rest,true);
  jcopter.prepare();
  jcopter.optimize();
  setup.writeClasses();
}","public static void main(String[] args){
  AppSetup setup=new AppSetup();
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.setVersionInfo(VERSION);
  DFATool dfaTool=new DFATool();
  WCETTool wcetTool=new WCETTool();
  JCopter jcopter=new JCopter();
  setup.registerTool(""String_Node_Str"",dfaTool,true,false);
  setup.registerTool(""String_Node_Str"",wcetTool,true,true);
  setup.registerTool(""String_Node_Str"",jcopter);
  setup.initAndLoad(args,true,true,true);
  if (setup.useTool(""String_Node_Str"")) {
    wcetTool.setDfaTool(dfaTool);
    jcopter.setDfaTool(dfaTool);
  }
  if (setup.useTool(""String_Node_Str"")) {
    jcopter.setWcetTool(wcetTool);
  }
  jcopter.prepare();
  jcopter.optimize();
  setup.writeClasses();
}",0.8678051865907653
186830,"private void computeOrdering(){
  Set<Transition> cycleTransitions=new TreeSet<Transition>();
  cycleTransitions=markCycles();
  Stack<Location> locStack=new Stack<Location>();
  locStack.push(template.getInitial());
  while (!locStack.empty()) {
    Location loc=locStack.pop();
    Vector<Location> todoPreds=new Stack<Location>();
    int maxPred=-1;
    for (    Transition tPred : loc.getPredecessors()) {
      if (cycleTransitions.contains(tPred))       continue;
      if (orderNumber.containsKey(tPred.getSource())) {
        maxPred=Math.max(maxPred,orderNumber.get(tPred.getSource()));
      }
 else {
        todoPreds.add(tPred.getSource());
      }
    }
    if (todoPreds.isEmpty()) {
      orderNumber.put(loc,maxPred + 1);
      for (      Transition tSucc : loc.getSuccessors()) {
        if (cycleTransitions.contains(tSucc))         continue;
        if (!orderNumber.containsKey(tSucc.getTarget())) {
          locStack.push(tSucc.getTarget());
        }
      }
    }
 else {
      locStack.addAll(todoPreds);
    }
  }
}","private void computeOrdering(){
  Set<Transition> cycleTransitions=new TreeSet<Transition>();
  cycleTransitions=markCycles();
  Stack<Location> locStack=new Stack<Location>();
  locStack.push(template.getInitial());
  while (!locStack.empty()) {
    Location loc=locStack.pop();
    List<Location> todoPreds=new Stack<Location>();
    int maxPred=-1;
    for (    Transition tPred : loc.getPredecessors()) {
      if (cycleTransitions.contains(tPred))       continue;
      if (orderNumber.containsKey(tPred.getSource())) {
        maxPred=Math.max(maxPred,orderNumber.get(tPred.getSource()));
      }
 else {
        todoPreds.add(tPred.getSource());
      }
    }
    if (todoPreds.isEmpty()) {
      orderNumber.put(loc,maxPred + 1);
      for (      Transition tSucc : loc.getSuccessors()) {
        if (cycleTransitions.contains(tSucc))         continue;
        if (!orderNumber.containsKey(tSucc.getTarget())) {
          locStack.push(tSucc.getTarget());
        }
      }
    }
 else {
      locStack.addAll(todoPreds);
    }
  }
}",0.9952015355086372
186831,"/** 
 * Remove all classInfos.
 * @param clearRoots if true, clear list of roots and main method as well, elsekeep the root classes in the class list.
 */
public void clear(boolean clearRoots){
  for (  AppEventHandler mgr : eventHandlers) {
    mgr.onClearAppInfo(this);
  }
  classes.clear();
  if (clearRoots) {
    roots.clear();
    mainMethod=null;
  }
 else {
    for (    MemberInfo root : roots) {
      classes.put(root.getClassInfo().getClassName(),root.getClassInfo());
    }
  }
}","/** 
 * Remove all classInfos.
 * @param clearRoots if true, clear list of roots and main method as well, elsekeep the root classes in the class list.
 */
public void clear(boolean clearRoots){
  for (  AppEventHandler mgr : eventHandlers) {
    mgr.onClearAppInfo(this);
  }
  classes.clear();
  if (clearRoots) {
    roots.clear();
    mainMethod=null;
  }
 else {
    for (    MemberInfo root : roots) {
      classes.put(root.getClassInfo().getClassName(),root.getClassInfo());
    }
  }
  callGraph=null;
}",0.9820717131474104
186832,"/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  if (config.hasOption(Config.PROCESSOR_MODEL)) {
    initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args.length > 0 ? args[0].replace('/','.') : null);
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    loadClassInfos();
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupAppInfo(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
}","/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  appInfo.setCallstringLength(config.getOption(Config.CALLSTRING_LENGTH).intValue());
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  if (config.hasOption(Config.PROCESSOR_MODEL)) {
    initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args.length > 0 ? args[0].replace('/','.') : null);
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    loadClassInfos();
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupAppInfo(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
}",0.9859154929577464
186833,"@Override public boolean isVertexMasked(ExecutionContext vertex){
  if (skipIsolated && callGraph.inDegreeOf(vertex) == 0 && callGraph.outDegreeOf(vertex) == 0) {
    return true;
  }
  if (skipNoImp && callGraph.inDegreeOf(vertex) == 0 && callGraph.outDegreeOf(vertex) == 1) {
    ExecutionContext target=callGraph.outgoingEdgesOf(vertex).iterator().next().getTarget();
    if (""String_Node_Str"".equals(target.getMethodInfo().getClassName()) && ""String_Node_Str"".equals(target.getMethodInfo().getShortName())) {
      return true;
    }
  }
  return false;
}","@Override public boolean isVertexMasked(MethodContainer vertex){
  if (skipIsolated && graph.inDegreeOf(vertex) == 0 && graph.outDegreeOf(vertex) == 0) {
    return true;
  }
  if (skipNoim && graph.inDegreeOf(vertex) == 0 && graph.outDegreeOf(vertex) == 1) {
    Object edge=graph.outgoingEdgesOf(vertex).iterator().next();
    MethodContainer target=graph.getEdgeTarget(edge);
    if (""String_Node_Str"".equals(target.getMethodInfo().getClassName()) && ""String_Node_Str"".equals(target.getMethodInfo().getShortName())) {
      return true;
    }
  }
  return false;
}",0.433392539964476
186834,"/** 
 * Export the callgraph as a .dot file.
 * @param w Write the graph to this writer. To improve performance, use a buffered writer.
 * @param skipIsolated if true, do not export isolated nodes.
 * @param skipNoImp if true, do not export roots with only one edge to com.jopdesign.sys.JVMHelp.noim().
 * @throws IOException if writing fails.
 */
public void exportDOT(Writer w,final boolean skipIsolated,final boolean skipNoImp) throws IOException {
  AdvancedDOTExporter<ExecutionContext,ContextEdge> exporter=new AdvancedDOTExporter<ExecutionContext,ContextEdge>();
  exporter.setGraphAttribute(""String_Node_Str"",""String_Node_Str"");
  DirectedGraph<ExecutionContext,ContextEdge> graph=callGraph;
  if (skipIsolated || skipNoImp) {
    graph=new DirectedMaskSubgraph<ExecutionContext,ContextEdge>(callGraph,new MaskFunctor<ExecutionContext,ContextEdge>(){
      @Override public boolean isEdgeMasked(      ContextEdge edge){
        return false;
      }
      @Override public boolean isVertexMasked(      ExecutionContext vertex){
        if (skipIsolated && callGraph.inDegreeOf(vertex) == 0 && callGraph.outDegreeOf(vertex) == 0) {
          return true;
        }
        if (skipNoImp && callGraph.inDegreeOf(vertex) == 0 && callGraph.outDegreeOf(vertex) == 1) {
          ExecutionContext target=callGraph.outgoingEdgesOf(vertex).iterator().next().getTarget();
          if (""String_Node_Str"".equals(target.getMethodInfo().getClassName()) && ""String_Node_Str"".equals(target.getMethodInfo().getShortName())) {
            return true;
          }
        }
        return false;
      }
    }
);
  }
  exporter.exportDOT(w,graph);
}","/** 
 * Export the callgraph as a .dot file.
 * @param w Write the graph to this writer. To improve performance, use a buffered writer.
 * @param merged if true, export the merged callgraph instead of the full graph.
 * @param skipIsolated if true, do not export isolated nodes.
 * @param skipNoImp if true, do not export roots with only one edge to com.jopdesign.sys.JVMHelp.noim().
 * @throws IOException if writing fails.
 */
public void exportDOT(Writer w,boolean merged,final boolean skipIsolated,final boolean skipNoImp) throws IOException {
  AdvancedDOTExporter<MethodContainer,Object> exporter=new AdvancedDOTExporter<MethodContainer,Object>();
  exporter.setGraphAttribute(""String_Node_Str"",""String_Node_Str"");
  if (merged && mergedCallGraph == null) {
    buildMergedGraph();
  }
  @SuppressWarnings({""String_Node_Str""}) DirectedGraph<MethodContainer,Object> graph=(DirectedGraph<MethodContainer,Object>)(merged ? mergedCallGraph : callGraph);
  if (skipIsolated || skipNoImp) {
    graph=new DirectedMaskSubgraph<MethodContainer,Object>(graph,new MethodFilter(graph,skipIsolated,skipNoImp));
  }
  exporter.exportDOT(w,graph);
}",0.5420560747663551
186835,"@Override public boolean isEdgeMasked(ContextEdge edge){
  return false;
}","@Override public boolean isEdgeMasked(Object edge){
  return false;
}",0.8951048951048951
186836,"/** 
 * Build and initialize everything, perform checks
 */
private void build(){
  logger.info(""String_Node_Str"" + rootNodes);
  this.buildGraph();
  logger.info(""String_Node_Str"");
  invalidate();
}","/** 
 * Build and initialize everything, perform checks
 */
private void build(){
  logger.info(""String_Node_Str"" + MiscUtils.toString(rootNodes,3));
  this.buildGraph();
  logger.info(""String_Node_Str"");
  invalidate();
}",0.9478672985781992
186837,"public String toStringVerbose(){
  if (this.isEmpty())   return ""String_Node_Str"";
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  boolean first=true;
  for (  InvokeSite is : callString) {
    if (first)     first=false;
 else     sb.append(""String_Node_Str"");
    sb.append(is.toString());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String toStringVerbose(boolean newlines){
  if (this.isEmpty())   return ""String_Node_Str"";
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  boolean first=true;
  for (int i=callString.length - 1; i >= 0; i--) {
    if (first)     first=false;
 else     if (newlines)     sb.append(""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    sb.append(callString[i].toString());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.8014616321559074
186838,"public String toString(){
  if (this.isEmpty())   return ""String_Node_Str"";
  long hash=hashCode();
  if (hash < 0)   hash+=Integer.MAX_VALUE;
  return String.format(""String_Node_Str"",callString.length,hash);
}","@Override public String toString(){
  if (this.isEmpty())   return ""String_Node_Str"";
  long hash=hashCode();
  if (hash < 0)   hash+=Integer.MAX_VALUE;
  return String.format(""String_Node_Str"",callString.length,hash);
}",0.9767441860465116
186839,"@Override public String toString(){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(method.getFQMethodName());
  if (!callString.isEmpty()) {
    sb.append(""String_Node_Str"");
    sb.append(callString.toString());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(method.getFQMethodName());
  if (!callString.isEmpty()) {
    sb.append(""String_Node_Str"");
    sb.append(callString.toStringVerbose(true));
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9782971619365608
186840,"/** 
 * Escape a string, s.t. it can be used as a DOT attribute value.
 * @param s   input string
 * @param mla alignment type
 * @return the string, with special characters replaced, and quoted if neccessary
 */
public static String escapedToString(String s,MultiLineAlignment mla){
  StringBuffer sb=new StringBuffer();
  boolean quote=false;
  String lineBreak=null;
switch (mla) {
case ML_ALIGN_LEFT:
    lineBreak=""String_Node_Str"";
  break;
case ML_ALIGN_CENTER:
lineBreak=""String_Node_Str"";
break;
case ML_ALIGN_RIGHT:
lineBreak=""String_Node_Str"";
break;
}
for (int i=0; i < s.length(); i++) {
char c=s.charAt(i);
switch (c) {
case '\n':
sb.append(lineBreak);
break;
case '\r':
break;
case '\t':
sb.append(""String_Node_Str"");
break;
case '""':
sb.append(""String_Node_Str"");
break;
default :
sb.append(c);
break;
}
if (!Character.isLetterOrDigit(c)) quote=true;
}
if (quote || sb.length() == 0) {
sb.insert(0,'""');
sb.append('""');
}
return sb.toString();
}","/** 
 * Escape a string, s.t. it can be used as a DOT attribute value.
 * @param s   input string
 * @param mla alignment type
 * @return the string, with special characters replaced, and quoted if neccessary
 */
public static String escapedToString(String s,MultiLineAlignment mla){
  StringBuffer sb=new StringBuffer();
  boolean quote=false;
  boolean hasBreak=false;
  String lineBreak=null;
switch (mla) {
case ML_ALIGN_LEFT:
    lineBreak=""String_Node_Str"";
  break;
case ML_ALIGN_CENTER:
lineBreak=""String_Node_Str"";
break;
case ML_ALIGN_RIGHT:
lineBreak=""String_Node_Str"";
break;
}
for (int i=0; i < s.length(); i++) {
char c=s.charAt(i);
switch (c) {
case '\n':
sb.append(lineBreak);
hasBreak=true;
break;
case '\r':
break;
case '\t':
sb.append(""String_Node_Str"");
break;
case '""':
sb.append(""String_Node_Str"");
break;
default :
sb.append(c);
break;
}
if (!Character.isLetterOrDigit(c)) quote=true;
}
if (hasBreak) sb.append(lineBreak);
if (quote || sb.length() == 0) {
sb.insert(0,'""');
sb.append('""');
}
return sb.toString();
}",0.961480740370185
186841,"/** 
 * Rebuild the constantpool from a new, empty constantpool. <p>This updates the indices of all references in the code of all methods of this class, therefore do not call this method while modifying the code.</p>
 */
public void rebuildConstantPool(){
  ConstantPoolGen newPool=new ConstantPoolGen();
  ConstantPoolRebuilder rebuilder=new ConstantPoolRebuilder(cpg);
  Set<Integer> usedIndices=ClassReferenceFinder.findPoolReferences(this,true);
  rebuilder.createNewConstantPool(usedIndices);
  rebuilder.updateClassGen(classGen);
  for (  MethodInfo m : methods.values()) {
    rebuilder.updateMethodGen(m,m.getInternalMethodGen());
  }
  for (  FieldInfo f : fields.values()) {
    rebuilder.updateFieldGen(f,f.getInternalFieldGen());
  }
  cpg=newPool;
}","/** 
 * Rebuild the constantpool from a new, empty constantpool. <p>This updates the indices of all references in the code of all methods of this class, therefore do not call this method while modifying the code.</p>
 */
public void rebuildConstantPool(){
  ConstantPoolGen newPool=new ConstantPoolGen();
  ConstantPoolRebuilder rebuilder=new ConstantPoolRebuilder(cpg);
  Set<Integer> usedIndices=ClassReferenceFinder.findPoolReferences(this,true);
  rebuilder.createNewConstantPool(usedIndices);
  rebuilder.updateClassGen(this,classGen);
  for (  MethodInfo m : methods.values()) {
    rebuilder.updateMethodGen(m,m.getInternalMethodGen());
  }
  for (  FieldInfo f : fields.values()) {
    rebuilder.updateFieldGen(f,f.getInternalFieldGen());
  }
  cpg=newPool;
}",0.9967298888162196
186842,"/** 
 * Get a reference to a field using the given signature.
 * @param classRef The class which contains the field.
 * @param signature The signature of the field. Only memberName and memberDescriptor are used.
 * @return A field reference with or without FieldInfo or ClassInfo.
 */
public FieldRef getFieldRef(ClassRef classRef,Signature signature){
  ClassInfo cls=classRef.getClassInfo();
  if (cls != null) {
    FieldInfo field=cls.getFieldInfo(signature.getMemberName());
    if (field == null) {
      return new FieldRef(cls.getClassRef(),signature.getMemberName(),signature.getMemberDescriptor().getType());
    }
 else {
      return field.getFieldRef();
    }
  }
  return new FieldRef(classRef,signature.getMemberName(),signature.getMemberDescriptor().getType());
}","/** 
 * Get a reference to a field using the given signature.
 * @param classRef The class which contains the field.
 * @param signature The signature of the field. Only memberName and memberDescriptor are used.
 * @return A field reference with or without FieldInfo or ClassInfo.
 */
public FieldRef getFieldRef(ClassRef classRef,Signature signature){
  ClassInfo cls=classRef.getClassInfo();
  if (cls != null) {
    FieldInfo field=cls.getFieldInfo(signature.getMemberName());
    if (field == null) {
      Type type=null;
      if (signature.hasMemberSignature()) {
        type=signature.getMemberDescriptor().getType();
      }
      return new FieldRef(cls.getClassRef(),signature.getMemberName(),type);
    }
 else {
      return field.getFieldRef();
    }
  }
  return new FieldRef(classRef,signature.getMemberName(),signature.getMemberDescriptor().getType());
}",0.6953361599030891
186843,"/** 
 * Build and initialize everything, perform checks
 */
private void build(){
  this.buildGraph();
  Pair<List<ExecutionContext>,List<ExecutionContext>> cycle=DirectedCycleDetector.findCycle(callGraph,rootNode);
  if (cycle != null) {
    throw new AssertionError(cyclicCallGraphMsg(cycle));
  }
  invalidate();
}","/** 
 * Build and initialize everything, perform checks
 */
private void build(){
  this.buildGraph();
  Pair<List<ExecutionContext>,List<ExecutionContext>> cycle=DirectedCycleDetector.findCycle(callGraph,rootNode);
  if (cycle != null) {
  }
  invalidate();
}",0.8492201039861352
186844,"@Override public void visitInnerClasses(ClassInfo classInfo,InnerClasses obj){
  visitConstantUtf8(obj.getNameIndex());
  for (  InnerClass ic : obj.getInnerClasses()) {
    visitConstantClass(ic.getInnerClassIndex());
    visitConstantClass(ic.getOuterClassIndex());
    visitConstantUtf8(ic.getInnerNameIndex());
  }
}","@Override public void visitInnerClasses(ClassInfo classInfo,InnerClasses obj){
  visitConstantUtf8(obj.getNameIndex());
  for (  InnerClass ic : obj.getInnerClasses()) {
    visitConstantClass(ic.getInnerClassIndex());
    if (ic.getOuterClassIndex() != 0) {
      visitConstantClass(ic.getOuterClassIndex());
    }
    if (ic.getInnerNameIndex() != 0) {
      visitConstantUtf8(ic.getInnerNameIndex());
    }
  }
}",0.8217687074829932
186845,"@Override public void visitCode(MethodInfo methodInfo,Code code){
  visitConstantUtf8(code.getNameIndex());
  InstructionList il=new InstructionList(code.getCode());
  visitInstructionList(il);
  il.dispose();
  for (  CodeException ce : code.getExceptionTable()) {
    visitConstantClass(ce.getCatchType());
  }
  new DescendingClassTraverser(this).visitAttributes(methodInfo,code.getAttributes());
}","@Override public void visitCode(MethodInfo methodInfo,Code code){
  visitConstantUtf8(code.getNameIndex());
  InstructionList il=new InstructionList(code.getCode());
  visitInstructionList(il);
  il.dispose();
  for (  CodeException ce : code.getExceptionTable()) {
    if (ce.getCatchType() != 0) {
      visitConstantClass(ce.getCatchType());
    }
  }
  new DescendingClassTraverser(this).visitAttributes(methodInfo,code.getAttributes());
}",0.9004739336492891
186846,"@Override public void visitUnknown(MemberInfo memberInfo,Unknown obj,boolean isCodeAttribute){
  throw new JavaClassFormatError(""String_Node_Str"" + obj.getName() + ""String_Node_Str""+ memberInfo+ ""String_Node_Str"");
}","@Override public void visitUnknown(MemberInfo memberInfo,Unknown obj,boolean isCodeAttribute){
  if (""String_Node_Str"".equals(obj.getName())) {
    return;
  }
  throw new JavaClassFormatError(""String_Node_Str"" + obj.getName() + ""String_Node_Str""+ memberInfo+ ""String_Node_Str"");
}",0.6639839034205232
186847,"public void updateMethodGen(MethodInfo methodInfo,MethodGen methodGen){
  methodGen.setConstantPool(newPool);
  if (!methodInfo.isAbstract()) {
    InstructionList il=methodInfo.getCode().getInstructionList();
class InstructionVisitor extends EmptyVisitor {
      @Override public void visitCPInstruction(      CPInstruction obj){
        obj.setIndex(mapIndex(obj.getIndex()));
      }
    }
    InstructionVisitor iv=new InstructionVisitor();
    for (    Instruction i : il.getInstructions()) {
      i.accept(iv);
    }
  }
  updateAttributes(methodInfo,methodGen.getAttributes());
  updateAttributes(methodInfo,methodGen.getCodeAttributes());
}","public void updateMethodGen(MethodInfo methodInfo,MethodGen methodGen){
  methodGen.setConstantPool(newPool);
  if (!methodInfo.isAbstract()) {
    InstructionList il=methodInfo.getCode().getInstructionList();
class InstructionVisitor extends EmptyVisitor {
      @Override public void visitCPInstruction(      CPInstruction obj){
        obj.setIndex(mapIndex(obj.getIndex()));
      }
    }
    InstructionVisitor iv=new InstructionVisitor();
    for (    InstructionHandle ih : il.getInstructionHandles()) {
      ih.getInstruction().accept(iv);
    }
  }
  updateAttributes(methodInfo,methodGen.getAttributes());
  updateAttributes(methodInfo,methodGen.getCodeAttributes());
}",0.9736644093303236
186848,"/** 
 * Get a set of all root methods, i.e. all root methods and all methods in all root classes.
 * @return a set of all root methods.
 */
public Collection<MethodInfo> getRootMethods(){
  Set<MethodInfo> methods=new HashSet<MethodInfo>();
  for (  MemberInfo root : roots) {
    if (root instanceof MethodInfo) {
      methods.add((MethodInfo)root);
    }
 else     if (root instanceof ClassInfo) {
      for (      MethodInfo m : ((ClassInfo)root).getMethods()) {
        methods.add(m);
      }
    }
 else {
      throw new AppInfoError(""String_Node_Str"" + root + ""String_Node_Str"");
    }
  }
  return methods;
}","/** 
 * Get a set of all root methods, i.e. all root methods and all methods in all root classes.
 * @return a set of all root methods.
 */
public Set<MethodInfo> getRootMethods(){
  Set<MethodInfo> methods=new HashSet<MethodInfo>();
  for (  MemberInfo root : roots) {
    addRootMethods(methods,root);
  }
  return methods;
}",0.6074074074074074
186849,"/** 
 * Build the callgraph. <p>NEW: now we also use callstrings to get a more precise call graph model</p>
 */
private void buildGraph(){
  callGraph.addGraphListener(new GraphUpdateListener());
  for (  ExecutionContext rootNode : rootNodes) {
    callGraph.addVertex(rootNode);
  }
  if (parent == null) {
    Stack<ExecutionContext> todo=new Stack<ExecutionContext>();
    for (    ExecutionContext rootNode : rootNodes) {
      todo.push(rootNode);
    }
    while (!todo.empty()) {
      ExecutionContext current=todo.pop();
      logger.debug(""String_Node_Str"" + current);
      Set<ExecutionContext> invoked=config.getInvokedMethods(current);
      for (      ExecutionContext cgn : invoked) {
        if (!callGraph.containsVertex(cgn)) {
          callGraph.addVertex(cgn);
          todo.push(cgn);
        }
        logger.debug(""String_Node_Str"" + cgn);
        callGraph.addEdge(current,cgn);
      }
    }
  }
 else {
    cloneReachableGraph(rootNodes);
  }
}","/** 
 * Build the callgraph. <p>NEW: now we also use callstrings to get a more precise call graph model</p>
 */
private void buildGraph(){
  callGraph.addGraphListener(new GraphUpdateListener());
  if (parent == null) {
    Stack<ExecutionContext> todo=new Stack<ExecutionContext>();
    for (    ExecutionContext rootNode : rootNodes) {
      callGraph.addVertex(rootNode);
      todo.push(rootNode);
    }
    while (!todo.empty()) {
      ExecutionContext current=todo.pop();
      logger.debug(""String_Node_Str"" + current);
      Set<ExecutionContext> invoked=config.getInvokedMethods(current);
      for (      ExecutionContext cgn : invoked) {
        if (!callGraph.containsVertex(cgn)) {
          callGraph.addVertex(cgn);
          todo.push(cgn);
        }
        logger.debug(""String_Node_Str"" + cgn);
        callGraph.addEdge(current,cgn);
      }
    }
  }
 else {
    cloneReachableGraph(rootNodes);
  }
}",0.9335443037974684
186850,"protected CallGraph(CallGraph parent,ExecutionContext rootNode,CallgraphConfig config){
  this(Collections.singleton(rootNode),config);
  this.parent=parent;
}","protected CallGraph(CallGraph parent,Collection<ExecutionContext> rootNodes,CallgraphConfig config){
  this(rootNodes,config);
  this.parent=parent;
}",0.8802588996763754
186851,"/** 
 * Build a callgraph with all root methods of AppInfo. This also adds all static initializers of all classes to the callgraph.
 * @see AppInfo#getRootMethods()
 * @param appInfo the AppInfo to use
 * @param config the config class to use to build this graph
 * @return a freshly constructed callgraph.
 */
public static CallGraph buildCallGraph(AppInfo appInfo,CallgraphConfig config){
  Collection<MethodInfo> rootMethods=appInfo.getRootMethods();
  Set<ExecutionContext> roots=new HashSet<ExecutionContext>(rootMethods.size());
  for (  MethodInfo m : rootMethods) {
    roots.add(new ExecutionContext(m));
  }
  for (  ClassInfo cls : appInfo.getClassInfos()) {
    MethodInfo clinit=cls.getMethodInfo(ClinitOrder.clinitSig);
    if (clinit != null) {
      roots.add(new ExecutionContext(clinit));
    }
  }
  CallGraph cg=new CallGraph(roots,config);
  cg.build();
  return cg;
}","/** 
 * Build a callgraph with all root methods of AppInfo. This also adds all static initializers of all classes to the callgraph.
 * @see AppInfo#getRootMethods()
 * @param appInfo the AppInfo to use
 * @param config the config class to use to build this graph
 * @return a freshly constructed callgraph.
 */
public static CallGraph buildCallGraph(AppInfo appInfo,CallgraphConfig config){
  Collection<MethodInfo> rootMethods=appInfo.getRootMethods();
  Set<ExecutionContext> roots=new HashSet<ExecutionContext>(rootMethods.size());
  for (  MethodInfo m : rootMethods) {
    roots.add(new ExecutionContext(m));
  }
  for (  MethodInfo m : appInfo.getClinitMethods()) {
    roots.add(new ExecutionContext(m));
  }
  CallGraph cg=new CallGraph(roots,config);
  cg.build();
  return cg;
}",0.8300536672629696
186852,"/** 
 * Export callgraph as .dot file
 * @param w Write the graph to this writer. To improve performance, to use a buffered writer.
 * @throws IOException if writing fails
 */
public void exportDOT(Writer w) throws IOException {
  new AdvancedDOTExporter<ExecutionContext,ContextEdge>().exportDOT(w,this.callGraph);
}","/** 
 * Export the callgraph as a .dot file.
 * @param w Write the graph to this writer. To improve performance, use a buffered writer.
 * @param skipIsolated if true, do not export isolated nodes.
 * @param skipNoImp if true, do not export roots with only one edge to com.jopdesign.sys.JVMHelp.noim().
 * @throws IOException if writing fails.
 */
public void exportDOT(Writer w,final boolean skipIsolated,final boolean skipNoImp) throws IOException {
  AdvancedDOTExporter<ExecutionContext,ContextEdge> exporter=new AdvancedDOTExporter<ExecutionContext,ContextEdge>();
  exporter.setGraphAttribute(""String_Node_Str"",""String_Node_Str"");
  DirectedGraph<ExecutionContext,ContextEdge> graph=callGraph;
  if (skipIsolated || skipNoImp) {
    graph=new DirectedMaskSubgraph<ExecutionContext,ContextEdge>(callGraph,new MaskFunctor<ExecutionContext,ContextEdge>(){
      @Override public boolean isEdgeMasked(      ContextEdge edge){
        return false;
      }
      @Override public boolean isVertexMasked(      ExecutionContext vertex){
        if (skipIsolated && callGraph.inDegreeOf(vertex) == 0 && callGraph.outDegreeOf(vertex) == 0) {
          return true;
        }
        if (skipNoImp && callGraph.inDegreeOf(vertex) == 0 && callGraph.outDegreeOf(vertex) == 1) {
          ExecutionContext target=callGraph.outgoingEdgesOf(vertex).iterator().next().getTarget();
          if (""String_Node_Str"".equals(target.getMethodInfo().getClassName()) && ""String_Node_Str"".equals(target.getMethodInfo().getShortName())) {
            return true;
          }
        }
        return false;
      }
    }
);
  }
  exporter.exportDOT(w,graph);
}",0.2747701736465781
186853,"/** 
 * Get a subgraph starting at a given node which contains all reachable nodes and edges. The subgraph is backed by this graph, so any modifications to it will be reflected in the subgraph (but not the other way round!)
 * @param root root node of the graph.
 * @return a new subgraph, or an existing subgraph which starts at the same root
 */
public CallGraph getSubGraph(ExecutionContext root){
  CallGraph subGraph=subgraphs.get(root);
  if (subGraph != null) {
    subGraph=new CallGraph(this,root,config);
    subGraph.build();
    callGraph.addGraphListener(new SubgraphUpdateListener(subGraph));
    subgraphs.put(root,subGraph);
  }
  return subGraph;
}","/** 
 * Get a subgraph starting at a given node which contains all reachable nodes and edges. The subgraph is backed by this graph, so any modifications to it will be reflected in the subgraph (but not the other way round!)
 * @param roots root nodes of the new graph.
 * @return a new subgraph, or an existing subgraph which starts at the same root
 */
public CallGraph getSubGraph(Set<ExecutionContext> roots){
  for (  CallGraph subgraph : subgraphs.keySet()) {
    if (subgraph.getRootNodes().equals(roots)) {
      return subgraph;
    }
  }
  CallGraph subGraph=new CallGraph(this,roots,config);
  subGraph.build();
  SubgraphUpdateListener listener=new SubgraphUpdateListener(subGraph);
  callGraph.addGraphListener(listener);
  subgraphs.put(subGraph,listener);
  return subGraph;
}",0.5869415807560138
186854,"/** 
 * @param args
 */
public static void main(String[] args){
  OCache oc=new OCache();
  OCache oc2=new OCache();
  int i, j;
  com.jopdesign.io.SysDevice sys=com.jopdesign.io.IOFactory.getFactory().getSysDevice();
  sys.wd=1;
  s=15;
  oc.a=1;
  i=oc.a;
  j=oc.a;
  int ref=Native.toInt(oc);
  i=Native.getField(ref,0);
  i=oc.a;
  sys.wd=0;
  oc2.a=3;
  i=oc.a;
  i=oc2.a;
  j=oc.a;
  j=oc2.a;
  sys.wd=1;
  BenchLift bl=new BenchLift();
  sys.wd=0;
  bl.perform(10);
  sys.wd=1;
}","/** 
 * @param args
 */
public static void main(String[] args){
  OCache oc=new OCache();
  OCache oc2=new OCache();
  int i, j;
  com.jopdesign.io.SysDevice sys=com.jopdesign.io.IOFactory.getFactory().getSysDevice();
  sys.wd=1;
  Basic btest=new Basic();
  sys.wd=0;
  boolean result=btest.test();
  sys.wd=1;
  System.out.println(result);
}",0.571773220747889
186855,"/** 
 * Helper to load a property file in the package of a given class.
 * @param rsClass the class for which the property file should be loaded.
 * @param filename the filename of the property file.
 * @param defaultProps default properties to use for the new properties.
 * @return the loaded property file.
 * @throws IOException on read errors.
 */
public static Properties loadResourceProps(Class rsClass,String filename,Properties defaultProps) throws IOException {
  Properties p=new Properties(defaultProps);
  InputStream is=rsClass.getResourceAsStream(filename);
  if (is == null) {
    throw new IOException(""String_Node_Str"" + filename + ""String_Node_Str""+ rsClass.getCanonicalName()+ ""String_Node_Str"");
  }
  p.load(new BufferedInputStream(is));
  return p;
}","/** 
 * Helper to load a property file in the package of a given class.
 * @param rsClass the class for which the property file should be loaded.
 * @param filename the filename of the property file.
 * @param defaultProps default properties to use for the new properties.
 * @return the loaded property file.
 * @throws IOException on read errors.
 */
public static Properties loadResourceProps(Class rsClass,String filename,Properties defaultProps) throws IOException {
  Properties p=new Properties(defaultProps);
  InputStream is=rsClass.getResourceAsStream(filename);
  if (is == null) {
    throw new IOException(""String_Node_Str"" + filename + ""String_Node_Str""+ rsClass.getCanonicalName()+ ""String_Node_Str"");
  }
  p.load(new BufferedInputStream(is));
  is.close();
  return p;
}",0.9807692307692308
186856,"/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0 || ""String_Node_Str"".equals(args[0])) {
    System.err.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
    appInfo.reloadClassHierarchy();
  }
}","/** 
 * Setup AppInfo using the config previously initialized with   {@link #setupConfig(String[])}.
 * @param args the arguments containing the name of the main method and additional roots without config options.
 * @param loadTransitiveHull if true, load the transitive hull of the root classes too.
 */
public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0 || ""String_Node_Str"".equals(args[0])) {
    System.err.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  CustomAttribute.registerDefaultReader();
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  initProcessorModel(config.getOption(Config.PROCESSOR_MODEL));
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  for (  String toolName : tools.keySet()) {
    if (useTool(toolName)) {
      AppEventHandler handler=tools.get(toolName).getEventHandler();
      if (handler != null) {
        appInfo.registerEventHandler(handler);
      }
    }
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
    appInfo.reloadClassHierarchy();
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupAppInfo(this,appInfo);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
}",0.9380820127430158
186857,"/** 
 * Load the config file, parse and check options.
 * @param args cmdline arguments to parse
 * @return arguments not consumed.
 */
public String[] setupConfig(String[] args){
  if (configFilename != null) {
    File file=findConfigFile(configFilename);
    if (file != null && file.exists()) {
      try {
        InputStream is=new BufferedInputStream(new FileInputStream(file));
        config.addProperties(is);
      }
 catch (      FileNotFoundException e) {
        System.err.println(""String_Node_Str"" + configFilename + ""String_Node_Str""+ e.getMessage());
      }
catch (      IOException e) {
        System.err.println(""String_Node_Str"" + file + ""String_Node_Str""+ e.getMessage());
        System.exit(3);
      }
    }
  }
  String[] rest=null;
  try {
    rest=config.parseArguments(args);
    config.checkOptions();
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (config.getOption(Config.SHOW_HELP)) {
    printUsage();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_VERSION)) {
    printVersion();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_CONFIG)) {
    config.printConfiguration(config.getDefaultIndent());
    System.exit(0);
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupConfig(this);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  return rest;
}","/** 
 * Load the config file, parse and check options.
 * @param args cmdline arguments to parse
 * @return arguments not consumed.
 */
public String[] setupConfig(String[] args){
  if (configFilename != null) {
    File file=findConfigFile(configFilename);
    if (file != null && file.exists()) {
      try {
        InputStream is=new BufferedInputStream(new FileInputStream(file));
        config.addProperties(is);
        is.close();
      }
 catch (      FileNotFoundException e) {
        System.err.println(""String_Node_Str"" + configFilename + ""String_Node_Str""+ e.getMessage());
      }
catch (      IOException e) {
        System.err.println(""String_Node_Str"" + file + ""String_Node_Str""+ e.getMessage());
        System.exit(3);
      }
    }
  }
  String[] rest=null;
  try {
    rest=config.parseArguments(args);
    config.checkOptions();
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (config.getOption(Config.SHOW_HELP)) {
    printUsage();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_VERSION)) {
    printVersion();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_CONFIG)) {
    config.printConfiguration(config.getDefaultIndent());
    System.exit(0);
  }
  try {
    for (    String tool : tools.keySet()) {
      if (useTool(tool)) {
        tools.get(tool).onSetupConfig(this);
      }
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  return rest;
}",0.9943374858437146
186858,"/** 
 * Called by   {@link AppSetup#setupConfig(String[])} after the configuration has been loaded.The tool should use the config values from AppSetup to check the configuration, load its options and initialize the tool.
 * @param setup the AppSetup used to initialize this app
 * @throws Config.BadConfigurationException if there is something rotten in the config orif the tool cannot be initialized
 */
void onSetupConfig(AppSetup setup) throws Config.BadConfigurationException ;","/** 
 * Called by   {@link AppSetup#setupConfig(String[])} after the configuration has been loaded.The tool should use the config values from AppSetup to check the configuration, load its options and initialize the tool. <p> Note that AppInfo is not yet initialized, accessing it here will give you errors. See {@link #onSetupAppInfo(AppSetup,AppInfo)} if you want to look up classes, methods,...</p>
 * @param setup the AppSetup used to initialize this tool
 * @throws Config.BadConfigurationException if there is something rotten in the config orif the tool cannot be initialized
 */
void onSetupConfig(AppSetup setup) throws Config.BadConfigurationException ;",0.8363954505686789
186859,"/** 
 * Get the line number of the instruction. If instruction handle attributes are not used, the positions of the instruction handles must be uptodate.
 * @see #getSourceFileName(InstructionHandle)
 * @param ih the instruction to check.
 * @return the line number of the instruction, or 0 if unknown.
 */
public int getLineNumber(InstructionHandle ih){
  if (ilTablesLoaded) {
    return (Integer)ih.getAttribute(KEY_LINENUMBER);
  }
 else {
    return getLineNumberTable().getSourceLine(ih.getPosition());
  }
}","/** 
 * Get the line number of the instruction. If instruction handle attributes are not used, the positions of the instruction handles must be uptodate.
 * @see #getSourceFileName(InstructionHandle)
 * @param ih the instruction to check.
 * @return the line number of the instruction, or 0 if unknown.
 */
public int getLineNumber(InstructionHandle ih){
  if (ilTablesLoaded) {
    Object attribute=ih.getAttribute(KEY_LINENUMBER);
    return attribute != null ? (Integer)attribute : 0;
  }
 else {
    return getLineNumberTable().getSourceLine(ih.getPosition());
  }
}",0.918819188191882
186860,"public KeyManager(){
  appInfo=AppInfo.getSingleton();
  registeredKeys=new HashMap<String,CustomKey>();
  maxStructKeyID=0;
}","private KeyManager(){
  registeredKeys=new HashMap<String,CustomKey>();
  maxStructKeyID=0;
}",0.8036529680365296
186861,"protected int parseOption(String[] args,String key,int pos) throws BadConfigurationException {
  Option spec=getOptionSpec(key);
  if (spec != null) {
    String val=null;
    if (pos + 1 < args.length) {
      if (spec.isValue(args[pos + 1])) {
        val=args[pos + 1];
      }
    }
    int i=pos;
    if (spec instanceof BooleanOption && val == null) {
      val=""String_Node_Str"";
    }
 else     if (val == null) {
      throw new Config.BadConfigurationException(""String_Node_Str"" + spec);
    }
 else {
      i++;
    }
    config.setProperty(getConfigKey(spec),val);
    return i;
  }
  if (key.startsWith(""String_Node_Str"")) {
    spec=getOptionSpec(key.substring(3));
    if (spec != null && spec instanceof BooleanOption) {
      config.setProperty(getConfigKey(spec),""String_Node_Str"");
    }
  }
 else {
    int j=key.indexOf('.');
    OptionGroup group=subGroups.get(key.substring(0,j));
    if (group != null) {
      return group.parseOption(args,key.substring(j + 1),pos);
    }
  }
  if (spec == null) {
    throw new Config.BadConfigurationException(""String_Node_Str"" + key);
  }
  return pos;
}","protected int parseOption(String[] args,String key,int pos) throws BadConfigurationException {
  Option<?> spec=getOptionSpec(key);
  if (spec != null) {
    String val=null;
    if (pos + 1 < args.length) {
      if (spec.isValue(args[pos + 1])) {
        val=args[pos + 1];
      }
    }
    int i=pos;
    if (spec instanceof BooleanOption && val == null) {
      val=""String_Node_Str"";
    }
 else     if (val == null) {
      throw new Config.BadConfigurationException(""String_Node_Str"" + spec);
    }
 else {
      i++;
    }
    config.setProperty(getConfigKey(spec),val);
    return i;
  }
  if (key.startsWith(""String_Node_Str"")) {
    spec=getOptionSpec(key.substring(3));
    if (spec != null && spec instanceof BooleanOption) {
      config.setProperty(getConfigKey(spec),""String_Node_Str"");
    }
  }
 else   if (key.contains(""String_Node_Str"")) {
    int j=key.indexOf('.');
    OptionGroup group=subGroups.get(key.substring(0,j));
    if (group != null) {
      return group.parseOption(args,key.substring(j + 1),pos);
    }
  }
  if (spec == null) {
    throw new Config.BadConfigurationException(""String_Node_Str"" + key);
  }
  return pos;
}",0.9815303430079156
186862,"@SuppressWarnings({""String_Node_Str""}) @Override public void onSetupConfig(AppSetup setup) throws BadConfigurationException {
  appInfo=setup.getAppInfo();
  Config config=setup.getConfig();
  this.projectConfig=config;
  this.projectName=projectConfig.getProjectName();
  File outDir=projectConfig.getOutDir();
  Config.checkDir(outDir,true);
  File ilpDir=new File(outDir,""String_Node_Str"");
  Config.checkDir(ilpDir,true);
  if (projectConfig.doGenerateReport()) {
    try {
      this.results=new Report(projectConfig.getConfig(),this,projectConfig.getReportDir());
    }
 catch (    IOException e) {
      throw new BadConfigurationException(""String_Node_Str"",e);
    }
    this.genWCETReport=true;
  }
 else {
    this.genWCETReport=false;
  }
  if (projectConfig.saveResults()) {
    this.resultRecord=new File(config.getOption(ProjectConfig.RESULT_FILE));
    if (!projectConfig.appendResults()) {
      recordMetric(""String_Node_Str"",this.getProjectName());
      recordMetric(""String_Node_Str"",new Date());
    }
  }
  if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new ObjectAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new HandleAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new HeaderAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new BlockAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new JamuthWCETModel(this);
  }
 else {
    try {
      this.processor=new JOPWcetModel(this);
    }
 catch (    IOException e) {
      throw new BadConfigurationException(""String_Node_Str"",e);
    }
  }
}","@SuppressWarnings({""String_Node_Str""}) @Override public void onSetupConfig(AppSetup setup) throws BadConfigurationException {
  appInfo=setup.getAppInfo();
  Config config=setup.getConfig();
  this.projectConfig=new ProjectConfig(config);
  this.projectName=projectConfig.getProjectName();
  File outDir=projectConfig.getOutDir();
  Config.checkDir(outDir,true);
  File ilpDir=new File(outDir,""String_Node_Str"");
  Config.checkDir(ilpDir,true);
  if (projectConfig.doGenerateReport()) {
    this.results=new Report(this);
    this.genWCETReport=true;
  }
 else {
    this.genWCETReport=false;
  }
  if (projectConfig.saveResults()) {
    this.resultRecord=new File(config.getOption(ProjectConfig.RESULT_FILE));
    if (!projectConfig.appendResults()) {
      recordMetric(""String_Node_Str"",this.getProjectName());
      recordMetric(""String_Node_Str"",new Date());
    }
  }
  if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new ObjectAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new HandleAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new HeaderAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new BlockAllocationModel(this);
  }
 else   if (projectConfig.getProcessorName().equals(""String_Node_Str"")) {
    this.processor=new JamuthWCETModel(this);
  }
 else {
    try {
      this.processor=new JOPWcetModel(this);
    }
 catch (    IOException e) {
      throw new BadConfigurationException(""String_Node_Str"",e);
    }
  }
}",0.3413802896904288
186863,"public boolean doWriteReport(){
  return projectConfig.getReportDir() != null;
}","public boolean doWriteReport(){
  return genWCETReport;
}",0.7591240875912408
186864,"private MethodInfo getMainMethod(String signature) throws Config.BadConfigurationException {
  Signature sMain;
  sMain=Signature.parse(signature);
  String clsName=sMain.getClassName();
  if (clsName == null) {
    throw new Config.BadConfigurationException(""String_Node_Str"");
  }
  ClassInfo clsInfo=appInfo.loadClass(clsName);
  if (clsInfo == null) {
    throw new Config.BadConfigurationException(""String_Node_Str"" + clsName + ""String_Node_Str"");
  }
  if (sMain.isMethodSignature()) {
    MethodInfo method=clsInfo.getMethodInfo(sMain.getMemberSignature());
    if (method == null) {
      throw new Config.BadConfigurationException(""String_Node_Str"" + sMain.getMemberSignature() + ""String_Node_Str""+ clsName+ ""String_Node_Str"");
    }
    return method;
  }
  String mainName=sMain.getMemberName();
  if (mainName == null) {
    mainName=config.getOption(Config.MAIN_METHOD_NAME);
  }
  Collection<MethodInfo> methods=clsInfo.getMethodByName(mainName);
  if (methods.isEmpty()) {
    throw new Config.BadConfigurationException(""String_Node_Str"" + mainName + ""String_Node_Str""+ clsName+ ""String_Node_Str"");
  }
  if (methods.size() > 1) {
    StringBuffer s=new StringBuffer(String.format(""String_Node_Str"",mainName,clsName));
    for (    MethodInfo m : methods) {
      s.append(""String_Node_Str"");
      s.append(m.getSignature());
    }
    throw new Config.BadConfigurationException(s.toString());
  }
  return methods.iterator().next();
}","private MethodInfo getMainMethod(String signature) throws Config.BadConfigurationException {
  Signature sMain;
  sMain=Signature.parse(signature,true);
  String clsName=sMain.getClassName();
  if (clsName == null) {
    throw new Config.BadConfigurationException(""String_Node_Str"");
  }
  ClassInfo clsInfo=appInfo.loadClass(clsName);
  if (clsInfo == null) {
    throw new Config.BadConfigurationException(""String_Node_Str"" + clsName + ""String_Node_Str"");
  }
  if (sMain.isMethodSignature()) {
    MethodInfo method=clsInfo.getMethodInfo(sMain.getMemberSignature());
    if (method == null) {
      throw new Config.BadConfigurationException(""String_Node_Str"" + sMain.getMemberSignature() + ""String_Node_Str""+ clsName+ ""String_Node_Str"");
    }
    return method;
  }
  String mainName=sMain.getMemberName();
  if (mainName == null) {
    mainName=config.getOption(Config.MAIN_METHOD_NAME);
  }
  Collection<MethodInfo> methods=clsInfo.getMethodByName(mainName);
  if (methods.isEmpty()) {
    throw new Config.BadConfigurationException(""String_Node_Str"" + mainName + ""String_Node_Str""+ clsName+ ""String_Node_Str"");
  }
  if (methods.size() > 1) {
    StringBuffer s=new StringBuffer(String.format(""String_Node_Str"",mainName,clsName));
    for (    MethodInfo m : methods) {
      s.append(""String_Node_Str"");
      s.append(m.getSignature());
    }
    throw new Config.BadConfigurationException(s.toString());
  }
  return methods.iterator().next();
}",0.99828001375989
186865,"private void doInvoke(String methodName,InstructionHandle stmt,Context context,Map<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state,Map<CallString,Map<Location,ValueMapping>> result){
  DFATool p=interpreter.getProgram();
  MethodInfo method=p.getMethod(methodName);
  methodName=method.getSignature().toString();
  if (method.isNative()) {
    handleNative(method,context,input,result);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getCode().getMaxLocals();
    c.constPool=method.getClassInfo().getConstantPoolGen();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=c.callString.push(p.getMethod(context.method),stmt,callStringLength);
    Map<Location,ValueMapping> in=input.get(context.callString);
    Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
    for (    Location l : in.keySet()) {
      if (l.stackLoc < 0) {
        out.put(l,in.get(l));
      }
      if (l.stackLoc >= varPtr) {
        out.put(new Location(l.stackLoc - varPtr),new ValueMapping(in.get(l),false));
      }
    }
    ContextMap<CallString,Map<Location,ValueMapping>> tmpresult=new ContextMap<CallString,Map<Location,ValueMapping>>(c,new HashMap<CallString,Map<Location,ValueMapping>>());
    tmpresult.put(c.callString,out);
    InstructionHandle entry=method.getCode().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> r=interpreter.interpret(c,entry,state,false);
    InstructionHandle exit=method.getCode().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      Map<Location,ValueMapping> returned=r.get(exit).get(c.callString);
      if (returned != null) {
        for (        Location l : returned.keySet()) {
          if (l.stackLoc < 0) {
            ValueMapping m=new ValueMapping(returned.get(l),true);
            m.join(result.get(context.callString).get(l));
            result.get(context.callString).put(l,m);
          }
          if (l.stackLoc >= 0) {
            ValueMapping m=new ValueMapping(returned.get(l),false);
            Location loc=new Location(l.stackLoc + varPtr);
            m.join(result.get(context.callString).get(loc));
            result.get(context.callString).put(loc,m);
          }
        }
      }
    }
    for (    Location l : in.keySet()) {
      if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - MethodHelper.getArgSize(method)) {
        result.get(context.callString).put(l,new ValueMapping(in.get(l),true));
      }
    }
  }
}","private void doInvoke(String methodName,InstructionHandle stmt,Context context,Map<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state,Map<CallString,Map<Location,ValueMapping>> result){
  DFATool p=interpreter.getProgram();
  MethodInfo method=p.getMethod(methodName);
  if (method.isNative()) {
    handleNative(method,context,input,result);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getCode().getMaxLocals();
    c.constPool=method.getClassInfo().getConstantPoolGen();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=method.getMethodRef();
    c.callString=c.callString.push(method,stmt,callStringLength);
    Map<Location,ValueMapping> in=input.get(context.callString);
    Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
    for (    Location l : in.keySet()) {
      if (l.stackLoc < 0) {
        out.put(l,in.get(l));
      }
      if (l.stackLoc >= varPtr) {
        out.put(new Location(l.stackLoc - varPtr),new ValueMapping(in.get(l),false));
      }
    }
    ContextMap<CallString,Map<Location,ValueMapping>> tmpresult=new ContextMap<CallString,Map<Location,ValueMapping>>(c,new HashMap<CallString,Map<Location,ValueMapping>>());
    tmpresult.put(c.callString,out);
    InstructionHandle entry=method.getCode().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> r=interpreter.interpret(c,entry,state,false);
    InstructionHandle exit=method.getCode().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      Map<Location,ValueMapping> returned=r.get(exit).get(c.callString);
      if (returned != null) {
        for (        Location l : returned.keySet()) {
          if (l.stackLoc < 0) {
            ValueMapping m=new ValueMapping(returned.get(l),true);
            m.join(result.get(context.callString).get(l));
            result.get(context.callString).put(l,m);
          }
          if (l.stackLoc >= 0) {
            ValueMapping m=new ValueMapping(returned.get(l),false);
            Location loc=new Location(l.stackLoc + varPtr);
            m.join(result.get(context.callString).get(loc));
            result.get(context.callString).put(loc,m);
          }
        }
      }
    }
    for (    Location l : in.keySet()) {
      if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - MethodHelper.getArgSize(method)) {
        result.get(context.callString).put(l,new ValueMapping(in.get(l),true));
      }
    }
  }
}",0.9840929401251116
186866,"public void printSizeResult(DFATool program){
  for (  InstructionHandle instr : sizes.keySet()) {
    ContextMap<CallString,Interval[]> r=sizes.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=program.getMethod(c.method).getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Interval[] bounds=r.get(callString);
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.toStringList()+ ""String_Node_Str"");
      System.out.println(Arrays.asList(bounds));
    }
  }
}","public void printSizeResult(DFATool program){
  for (  InstructionHandle instr : sizes.keySet()) {
    ContextMap<CallString,Interval[]> r=sizes.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=c.method.getMethodInfo().getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Interval[] bounds=r.get(callString);
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.toStringList()+ ""String_Node_Str"");
      System.out.println(Arrays.asList(bounds));
    }
  }
}",0.9782433521353748
186867,"public void printResult(DFATool program){
  for (  InstructionHandle instr : bounds.keySet()) {
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> r=bounds.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=program.getMethod(c.method).getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Pair<ValueMapping,ValueMapping> bounds=r.get(callString);
      ValueMapping first=bounds.first();
      ValueMapping second=bounds.second();
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.toStringList()+ ""String_Node_Str""+ scopes.get(instr)+ ""String_Node_Str"");
      System.out.print(""String_Node_Str"");
      System.out.println(first);
      System.out.print(""String_Node_Str"");
      System.out.println(second);
      System.out.print(""String_Node_Str"");
      int val=getBound(program,instr);
      if (val >= 0) {
        System.out.println(val);
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}","public void printResult(DFATool program){
  for (  InstructionHandle instr : bounds.keySet()) {
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> r=bounds.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=c.method.getMethodInfo().getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Pair<ValueMapping,ValueMapping> bounds=r.get(callString);
      ValueMapping first=bounds.first();
      ValueMapping second=bounds.second();
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.toStringList()+ ""String_Node_Str""+ scopes.get(instr)+ ""String_Node_Str"");
      System.out.print(""String_Node_Str"");
      System.out.println(first);
      System.out.print(""String_Node_Str"");
      System.out.println(second);
      System.out.print(""String_Node_Str"");
      int val=getBound(program,instr);
      if (val >= 0) {
        System.out.println(val);
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}",0.9867519415258108
186868,"public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  Map<Location,ValueMapping> in=(Map<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,new HashMap<CallString,Map<Location,ValueMapping>>());
  Instruction instruction=stmt.getInstruction();
  if (in == null) {
    context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
    return retval;
  }
  Map<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.LSTORE_0:
case Constants.LSTORE_1:
case Constants.LSTORE_2:
case Constants.LSTORE_3:
case Constants.LSTORE:
filterSet(in,result,context.stackPtr - 2);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Location l : in.keySet()) {
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (String arrayName : receivers) {
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Location l : in.keySet()) {
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (String fieldName : receivers) {
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Location l : in.keySet()) {
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (String fieldName : receivers) {
if (p.containsField(fieldName)) {
for (Location l : in.keySet()) {
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
break;
}
for (String name : receivers) {
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
Location loc=new Location(name);
ValueMapping val=new ValueMapping(in.get(l),false);
val.join(in.get(loc));
result.put(loc,val);
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFATool p=interpreter.getProgram();
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (String name : receivers) {
for (Location l : in.keySet()) {
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
ValueMapping v=in.get(new Location(context.stackPtr - 1));
if (v == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
recordArrayIndex(stmt,context,v.assigned);
}
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Location l : in.keySet()) {
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Location l : in.keySet()) {
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
operand.neg();
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IMUL:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.mul(operand);
m.constrained.mul(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IDIV:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.div(operand);
m.constrained.div(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IREM:
case Constants.ISHL:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(context,stmt);
result=doIf(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(context,stmt);
result=doIfIcmp(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str""+ stmt.toString(true)+ ""String_Node_Str""+ ""String_Node_Str"");
result=in;
break;
}
for (String methodName : receivers) {
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}","public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  Map<Location,ValueMapping> in=(Map<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,new HashMap<CallString,Map<Location,ValueMapping>>());
  Instruction instruction=stmt.getInstruction();
  if (in == null) {
    context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
    return retval;
  }
  Map<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.LSTORE_0:
case Constants.LSTORE_1:
case Constants.LSTORE_2:
case Constants.LSTORE_3:
case Constants.LSTORE:
filterSet(in,result,context.stackPtr - 2);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Location l : in.keySet()) {
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (String arrayName : receivers) {
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Location l : in.keySet()) {
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (String fieldName : receivers) {
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Location l : in.keySet()) {
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (String fieldName : receivers) {
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Location l : in.keySet()) {
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Location l : in.keySet()) {
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (String fieldName : receivers) {
if (p.containsField(fieldName)) {
for (Location l : in.keySet()) {
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (String fieldName : receivers) {
if (p.containsField(fieldName)) {
for (Location l : in.keySet()) {
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
break;
}
for (String name : receivers) {
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
Location loc=new Location(name);
ValueMapping val=new ValueMapping(in.get(l),false);
val.join(in.get(loc));
result.put(loc,val);
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFATool p=interpreter.getProgram();
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (String name : receivers) {
for (Location l : in.keySet()) {
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
ValueMapping v=in.get(new Location(context.stackPtr - 1));
if (v == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
recordArrayIndex(stmt,context,v.assigned);
}
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Location l : in.keySet()) {
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Location l : in.keySet()) {
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
operand.neg();
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IMUL:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.mul(operand);
m.constrained.mul(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IDIV:
{
Interval operand=new Interval();
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.div(operand);
m.constrained.div(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IREM:
case Constants.ISHL:
{
for (Location l : in.keySet()) {
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(context,stmt);
result=doIf(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(context,stmt);
result=doIfIcmp(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFATool p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str""+ stmt.toString(true)+ ""String_Node_Str""+ ""String_Node_Str"");
result=in;
break;
}
for (String methodName : receivers) {
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Location l : in.keySet()) {
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}",0.988414793053614
186869,"private void doInvoke(String methodName,InstructionHandle stmt,Context context,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state,ContextMap<CallString,SymbolicAddressMap> retval){
  DFATool p=interpreter.getProgram();
  MethodInfo method=p.getMethod(methodName);
  methodName=method.getSignature().toString();
  if (method.isNative()) {
    handleNative(method,context,input,retval);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getCode().getMaxLocals();
    c.constPool=method.getClassInfo().getConstantPoolGen();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=c.callString.push(p.getMethod(context.method),stmt,callStringLength);
    SymbolicAddressMap in=input.get(context.callString);
    SymbolicAddressMap out=in.cloneInvoke(varPtr);
    HashMap<CallString,SymbolicAddressMap> initialMap=new HashMap<CallString,SymbolicAddressMap>();
    ContextMap<CallString,SymbolicAddressMap> tmpresult=new ContextMap<CallString,SymbolicAddressMap>(c,initialMap);
    tmpresult.put(c.callString,out);
    InstructionHandle entry=method.getCode().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    if (DEBUG_PRINT) {
      System.out.println(""String_Node_Str"" + method.getSignature());
      System.out.println(String.format(""String_Node_Str"",context.stackPtr,varPtr,MethodHelper.getArgSize(method)));
    }
    Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> r=interpreter.interpret(c,entry,state,false);
    SymbolicAddressMap ctxInfo=retval.get(context.callString);
    InstructionHandle exit=method.getCode().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      SymbolicAddressMap returned=r.get(exit).get(c.callString);
      if (returned != null) {
        ctxInfo.joinReturned(returned,varPtr);
      }
 else {
        System.err.println(""String_Node_Str"");
      }
    }
 else {
      System.err.println(""String_Node_Str"" + methodName + ""String_Node_Str"");
    }
    ctxInfo.addStackUpto(in,context.stackPtr - MethodHelper.getArgSize(method));
    if (DEBUG_PRINT) {
      System.out.println(""String_Node_Str"" + method.getSignature());
      System.out.println(String.format(""String_Node_Str"",context.stackPtr,varPtr,MethodHelper.getArgSize(method)));
    }
  }
}","private void doInvoke(String methodName,InstructionHandle stmt,Context context,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state,ContextMap<CallString,SymbolicAddressMap> retval){
  DFATool p=interpreter.getProgram();
  MethodInfo method=p.getMethod(methodName);
  if (method.isNative()) {
    handleNative(method,context,input,retval);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getCode().getMaxLocals();
    c.constPool=method.getClassInfo().getConstantPoolGen();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=method.getMethodRef();
    c.callString=c.callString.push(method,stmt,callStringLength);
    SymbolicAddressMap in=input.get(context.callString);
    SymbolicAddressMap out=in.cloneInvoke(varPtr);
    HashMap<CallString,SymbolicAddressMap> initialMap=new HashMap<CallString,SymbolicAddressMap>();
    ContextMap<CallString,SymbolicAddressMap> tmpresult=new ContextMap<CallString,SymbolicAddressMap>(c,initialMap);
    tmpresult.put(c.callString,out);
    InstructionHandle entry=method.getCode().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    if (DEBUG_PRINT) {
      System.out.println(""String_Node_Str"" + method.getSignature());
      System.out.println(String.format(""String_Node_Str"",context.stackPtr,varPtr,MethodHelper.getArgSize(method)));
    }
    Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> r=interpreter.interpret(c,entry,state,false);
    SymbolicAddressMap ctxInfo=retval.get(context.callString);
    InstructionHandle exit=method.getCode().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      SymbolicAddressMap returned=r.get(exit).get(c.callString);
      if (returned != null) {
        ctxInfo.joinReturned(returned,varPtr);
      }
 else {
        System.err.println(""String_Node_Str"");
      }
    }
 else {
      System.err.println(""String_Node_Str"" + methodName + ""String_Node_Str"");
    }
    ctxInfo.addStackUpto(in,context.stackPtr - MethodHelper.getArgSize(method));
    if (DEBUG_PRINT) {
      System.out.println(""String_Node_Str"" + method.getSignature());
      System.out.println(String.format(""String_Node_Str"",context.stackPtr,varPtr,MethodHelper.getArgSize(method)));
    }
  }
}",0.9802039592081584
186870,"private Map<CallString,SymbolicAddressMap> handleNative(MethodInfo method,Context context,ContextMap<CallString,SymbolicAddressMap> input,ContextMap<CallString,SymbolicAddressMap> retval){
  String methodId=method.getSignature().toString();
  SymbolicAddressMap in=input.get(context.callString);
  SymbolicAddressMap out;
  int nextStackPtr=context.stackPtr - 1;
  if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 2);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
    out.putStack(context.stackPtr - 1,bsFactory.top());
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr + 1);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 2);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 1);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 3);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 2);
    BoundedSet<SymbolicAddress> joined=in.getStack(context.stackPtr - 3).join(in.getStack(context.stackPtr - 2));
    out.putStack(context.stackPtr - 3,joined);
  }
 else {
    out=null;
    System.err.println(""String_Node_Str"" + methodId);
    System.exit(-1);
  }
  retval.put(context.callString,out);
  return retval;
}","@SuppressWarnings({""String_Node_Str""}) private Map<CallString,SymbolicAddressMap> handleNative(MethodInfo method,Context context,ContextMap<CallString,SymbolicAddressMap> input,ContextMap<CallString,SymbolicAddressMap> retval){
  String methodId=method.getSignature().toString();
  SymbolicAddressMap in=input.get(context.callString);
  SymbolicAddressMap out;
  int nextStackPtr=context.stackPtr - 1;
  if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 2);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
    out.putStack(context.stackPtr - 1,bsFactory.top());
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr + 1);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 2);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 1);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 3);
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    out=in.cloneFilterStack(nextStackPtr - 2);
    BoundedSet<SymbolicAddress> joined=in.getStack(context.stackPtr - 3).join(in.getStack(context.stackPtr - 2));
    out.putStack(context.stackPtr - 3,joined);
  }
 else {
    out=null;
    System.err.println(""String_Node_Str"" + methodId);
    System.exit(-1);
  }
  retval.put(context.callString,out);
  return retval;
}",0.9908386187455956
186871,"public void printResult(DFATool program){
  Map<String,String> getFields=new TreeMap<String,String>();
  for (  InstructionHandle instr : usedRefs.keySet()) {
    ContextMap<CallString,BoundedSet<SymbolicAddress>> r=usedRefs.get(instr);
    Context c=r.getContext();
    MethodInfo method=program.getMethod(c.method);
    if (method == null) {
      throw new AssertionError(""String_Node_Str"" + c.method + ""String_Node_Str"");
    }
    LineNumberTable lines=method.getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (Iterator<CallString> k=r.keySet().iterator(); k.hasNext(); ) {
      CallString callString=k.next();
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString+ ""String_Node_Str""+ instr);
      BoundedSet<SymbolicAddress> symAddr=r.get(callString);
      String infoStr;
      if (instr.getInstruction() instanceof GETFIELD) {
        GETFIELD gfInstr=(GETFIELD)instr.getInstruction();
        infoStr=String.format(""String_Node_Str"",symAddr.toString(),gfInstr.getFieldName(c.constPool),gfInstr.getFieldType(c.constPool));
      }
 else       if (instr.getInstruction() instanceof ARRAYLENGTH) {
        infoStr=String.format(""String_Node_Str"",symAddr.toString());
      }
 else       if (instr.getInstruction() instanceof ArrayInstruction) {
        ArrayInstruction aInstr=(ArrayInstruction)instr.getInstruction();
        infoStr=String.format(""String_Node_Str"",aInstr.getName().toUpperCase(),symAddr.toString(),aInstr.getType(c.constPool));
      }
 else {
        infoStr=String.format(""String_Node_Str"",instr.getInstruction().getName().toUpperCase(),symAddr.toString());
      }
      if (infoStr != null) {
        String infoKey=String.format(""String_Node_Str"",c.method,sourceLine,callString);
        while (getFields.containsKey(infoKey))         infoKey+=""String_Node_Str"";
        getFields.put(infoKey,infoStr);
      }
    }
  }
  for (  Entry<String,String> entry : getFields.entrySet()) {
    System.out.println(entry.getKey());
    System.out.println(""String_Node_Str"" + entry.getValue());
  }
}","public void printResult(DFATool program){
  Map<String,String> getFields=new TreeMap<String,String>();
  for (  InstructionHandle instr : usedRefs.keySet()) {
    ContextMap<CallString,BoundedSet<SymbolicAddress>> r=usedRefs.get(instr);
    Context c=r.getContext();
    MethodInfo method=c.method.getMethodInfo();
    if (method == null) {
      throw new AssertionError(""String_Node_Str"" + c.method + ""String_Node_Str"");
    }
    LineNumberTable lines=method.getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString+ ""String_Node_Str""+ instr);
      BoundedSet<SymbolicAddress> symAddr=r.get(callString);
      String infoStr;
      if (instr.getInstruction() instanceof GETFIELD) {
        GETFIELD gfInstr=(GETFIELD)instr.getInstruction();
        infoStr=String.format(""String_Node_Str"",symAddr.toString(),gfInstr.getFieldName(c.constPool),gfInstr.getFieldType(c.constPool));
      }
 else       if (instr.getInstruction() instanceof ARRAYLENGTH) {
        infoStr=String.format(""String_Node_Str"",symAddr.toString());
      }
 else       if (instr.getInstruction() instanceof ArrayInstruction) {
        ArrayInstruction aInstr=(ArrayInstruction)instr.getInstruction();
        infoStr=String.format(""String_Node_Str"",aInstr.getName().toUpperCase(),symAddr.toString(),aInstr.getType(c.constPool));
      }
 else {
        infoStr=String.format(""String_Node_Str"",instr.getInstruction().getName().toUpperCase(),symAddr.toString());
      }
      if (infoStr != null) {
        String infoKey=String.format(""String_Node_Str"",c.method,sourceLine,callString);
        while (getFields.containsKey(infoKey))         infoKey+=""String_Node_Str"";
        getFields.put(infoKey,infoStr);
      }
    }
  }
  for (  Entry<String,String> entry : getFields.entrySet()) {
    System.out.println(entry.getKey());
    System.out.println(""String_Node_Str"" + entry.getValue());
  }
}",0.965979875419262
186872,"public LocalPointsToResult getUsedRefs(ExecutionContext scope){
  ExecuteOnceAnalysis eoAna=new ExecuteOnceAnalysis(project);
  DFATool dfa=project.getDfaProgram();
  SymbolicPointsTo spt=new SymbolicPointsTo(maxSetSize,(int)project.getProjectConfig().callstringLength(),new ExecOnceQuery(eoAna,scope));
  dfa.runLocalAnalysis(spt,scope.getMethodInfo().getFQMethodName());
  LocalPointsToResult lpt=new LocalPointsToResult(spt.getResult());
  return lpt;
}","public LocalPointsToResult getUsedRefs(ExecutionContext scope){
  ExecuteOnceAnalysis eoAna=new ExecuteOnceAnalysis(project);
  DFATool dfa=project.getDfaProgram();
  SymbolicPointsTo spt=new SymbolicPointsTo(maxSetSize,(int)project.getProjectConfig().callstringLength(),new ExecOnceQuery(eoAna,scope));
  dfa.runLocalAnalysis(spt,scope.getMethodInfo());
  LocalPointsToResult lpt=new LocalPointsToResult(spt.getResult());
  return lpt;
}",0.9798657718120806
186873,"protected StringBuilder initNumBlocks(){
  Vector<Integer> blocksPerMethod=new Vector<Integer>();
  for (int i=0; i < numMethods; i++) {
    int mBlocks=blocksOf(i);
    if (mBlocks > numBlocks()) {
      throw new AssertionError(""String_Node_Str"" + project.getAppInfo().getFlowGraph(i) + ""String_Node_Str""+ mBlocks+ ""String_Node_Str""+ numBlocks()+ ""String_Node_Str"");
    }
    blocksPerMethod.add(mBlocks);
  }
  return SystemBuilder.constArray(blocksPerMethod);
}","protected StringBuilder initNumBlocks(){
  List<Integer> blocksPerMethod=new ArrayList<Integer>();
  for (int i=0; i < numMethods; i++) {
    int mBlocks=blocksOf(i);
    if (mBlocks > numBlocks()) {
      throw new AssertionError(""String_Node_Str"" + project.getAppInfo().getFlowGraph(i) + ""String_Node_Str""+ mBlocks+ ""String_Node_Str""+ numBlocks()+ ""String_Node_Str"");
    }
    blocksPerMethod.add(mBlocks);
  }
  return SystemBuilder.constArray(blocksPerMethod);
}",0.9732047159699893
186874,"public static void main(String[] args){
  testSig(""String_Node_Str"",false);
  testSig(""String_Node_Str"",true);
  testSig(""String_Node_Str"",false);
}","public static void main(String[] args){
  testSig(""String_Node_Str"",false);
  testSig(""String_Node_Str"",true);
  testSig(""String_Node_Str"",false);
  testSig(""String_Node_Str"",true);
}",0.8942598187311178
186875,public abstract String getMemberSignature();,"/** 
 * Get the signature of this member (i.e. its simple name and its descriptor for methods).
 * @return the signature of this member without the class part.
 */
public abstract String getMemberSignature();",0.3492063492063492
186876,public abstract Signature getSignature();,"/** 
 * Get the signature object which identifies this member.
 * @return a fully qualified signature of this member.
 */
public abstract Signature getSignature();",0.4019607843137255
186877,"private void doInvoke(String methodName,InstructionHandle stmt,Context context,Map<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state,Map<CallString,Map<Location,ValueMapping>> result){
  DFAAppInfo p=interpreter.getProgram();
  MethodInfo mi=p.getMethod(methodName);
  MethodGen method=mi.getMethodGen();
  methodName=method.getClassName() + ""String_Node_Str"" + method.getName()+ method.getSignature();
  if (method.isNative()) {
    handleNative(method,context,input,result);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getMaxLocals();
    c.constPool=method.getConstantPool();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=c.callString.push(p.getMethod(context.method),stmt.getPosition(),callStringLength);
    Map<Location,ValueMapping> in=input.get(context.callString);
    Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
    for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
      Location l=k.next();
      if (l.stackLoc < 0) {
        out.put(l,in.get(l));
      }
      if (l.stackLoc >= varPtr) {
        out.put(new Location(l.stackLoc - varPtr),new ValueMapping(in.get(l),false));
      }
    }
    ContextMap<CallString,Map<Location,ValueMapping>> tmpresult=new ContextMap<CallString,Map<Location,ValueMapping>>(c,new HashMap<CallString,Map<Location,ValueMapping>>());
    tmpresult.put(c.callString,out);
    InstructionHandle entry=mi.getCode().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> r=interpreter.interpret(c,entry,state,false);
    InstructionHandle exit=mi.getCode().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      Map<Location,ValueMapping> returned=r.get(exit).get(c.callString);
      if (returned != null) {
        for (Iterator<Location> i=returned.keySet().iterator(); i.hasNext(); ) {
          Location l=i.next();
          if (l.stackLoc < 0) {
            ValueMapping m=new ValueMapping(returned.get(l),true);
            m.join(result.get(context.callString).get(l));
            result.get(context.callString).put(l,m);
          }
          if (l.stackLoc >= 0) {
            ValueMapping m=new ValueMapping(returned.get(l),false);
            Location loc=new Location(l.stackLoc + varPtr);
            m.join(result.get(context.callString).get(loc));
            result.get(context.callString).put(loc,m);
          }
        }
      }
    }
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - MethodHelper.getArgSize(method)) {
        result.get(context.callString).put(l,new ValueMapping(in.get(l),true));
      }
    }
  }
}","private void doInvoke(String methodName,InstructionHandle stmt,Context context,Map<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state,Map<CallString,Map<Location,ValueMapping>> result){
  DFAAppInfo p=interpreter.getProgram();
  MethodInfo method=p.getMethod(methodName);
  methodName=method.getSignature().toString();
  if (method.isNative()) {
    handleNative(method,context,input,result);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getMaxLocals();
    c.constPool=method.getConstantPool();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=c.callString.push(p.getMethod(context.method),stmt.getPosition(),callStringLength);
    Map<Location,ValueMapping> in=input.get(context.callString);
    Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
    for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
      Location l=k.next();
      if (l.stackLoc < 0) {
        out.put(l,in.get(l));
      }
      if (l.stackLoc >= varPtr) {
        out.put(new Location(l.stackLoc - varPtr),new ValueMapping(in.get(l),false));
      }
    }
    ContextMap<CallString,Map<Location,ValueMapping>> tmpresult=new ContextMap<CallString,Map<Location,ValueMapping>>(c,new HashMap<CallString,Map<Location,ValueMapping>>());
    tmpresult.put(c.callString,out);
    InstructionHandle entry=method.getCode().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> r=interpreter.interpret(c,entry,state,false);
    InstructionHandle exit=method.getCode().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      Map<Location,ValueMapping> returned=r.get(exit).get(c.callString);
      if (returned != null) {
        for (        Location l : returned.keySet()) {
          if (l.stackLoc < 0) {
            ValueMapping m=new ValueMapping(returned.get(l),true);
            m.join(result.get(context.callString).get(l));
            result.get(context.callString).put(l,m);
          }
          if (l.stackLoc >= 0) {
            ValueMapping m=new ValueMapping(returned.get(l),false);
            Location loc=new Location(l.stackLoc + varPtr);
            m.join(result.get(context.callString).get(loc));
            result.get(context.callString).put(loc,m);
          }
        }
      }
    }
    for (    Location l : in.keySet()) {
      if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - MethodHelper.getArgSize(method)) {
        result.get(context.callString).put(l,new ValueMapping(in.get(l),true));
      }
    }
  }
}",0.941196293176074
186878,"private Map<CallString,Map<Location,ValueMapping>> handleNative(MethodGen method,Context context,Map<CallString,Map<Location,ValueMapping>> input,Map<CallString,Map<Location,ValueMapping>> result){
  String methodId=method.getClassName() + ""String_Node_Str"" + method.getName()+ method.getSignature();
  Map<Location,ValueMapping> in=input.get(context.callString);
  Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
  if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")) {
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr - 1),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")) {
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc < context.stackPtr - 2) {
        out.put(l,in.get(l));
      }
    }
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr - 1),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc < context.stackPtr) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr - 1),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc < context.stackPtr - 3) {
        out.put(l,in.get(l));
      }
    }
  }
 else {
    System.err.println(""String_Node_Str"" + methodId);
    System.exit(-1);
  }
  result.put(context.callString,out);
  return result;
}","@SuppressWarnings({""String_Node_Str""}) private Map<CallString,Map<Location,ValueMapping>> handleNative(MethodGen method,Context context,Map<CallString,Map<Location,ValueMapping>> input,Map<CallString,Map<Location,ValueMapping>> result){
  String methodId=method.getClassName() + ""String_Node_Str"" + method.getName()+ method.getSignature();
  Map<Location,ValueMapping> in=input.get(context.callString);
  Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
  if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")) {
    for (    Location l : in.keySet()) {
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr - 1),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")|| methodId.equals(""String_Node_Str"")) {
    for (    Location l : in.keySet()) {
      if (l.stackLoc < context.stackPtr - 2) {
        out.put(l,in.get(l));
      }
    }
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    for (    Location l : in.keySet()) {
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr - 1),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    for (    Location l : in.keySet()) {
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    for (    Location l : in.keySet()) {
      if (l.stackLoc < context.stackPtr) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"")) {
    for (    Location l : in.keySet()) {
      if (l.stackLoc < context.stackPtr - 1) {
        out.put(l,in.get(l));
      }
    }
    out.put(new Location(context.stackPtr - 1),new ValueMapping());
  }
 else   if (methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"") || methodId.equals(""String_Node_Str"")) {
    for (    Location l : in.keySet()) {
      if (l.stackLoc < context.stackPtr - 3) {
        out.put(l,in.get(l));
      }
    }
  }
 else {
    System.err.println(""String_Node_Str"" + methodId);
    System.exit(-1);
  }
  result.put(context.callString,out);
  return result;
}",0.9009483667017912
186879,"public void printSizeResult(DFAAppInfo program){
  for (  InstructionHandle instr : sizes.keySet()) {
    ContextMap<CallString,Interval[]> r=sizes.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=program.getMethod(c.method).getMethod().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Interval[] bounds=r.get(callString);
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.asList()+ ""String_Node_Str"");
      System.out.println(Arrays.asList(bounds));
    }
  }
}","public void printSizeResult(DFAAppInfo program){
  for (  InstructionHandle instr : sizes.keySet()) {
    ContextMap<CallString,Interval[]> r=sizes.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=program.getMethod(c.method).getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Interval[] bounds=r.get(callString);
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.toStringList()+ ""String_Node_Str"");
      System.out.println(Arrays.asList(bounds));
    }
  }
}",0.9839486356340288
186880,"public void printResult(DFAAppInfo program){
  for (  InstructionHandle instr : bounds.keySet()) {
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> r=bounds.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=program.getMethod(c.method).getMethod().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Pair<ValueMapping,ValueMapping> bounds=r.get(callString);
      ValueMapping first=bounds.first();
      ValueMapping second=bounds.second();
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.asList()+ ""String_Node_Str""+ scopes.get(instr)+ ""String_Node_Str"");
      System.out.print(""String_Node_Str"");
      System.out.println(first);
      System.out.print(""String_Node_Str"");
      System.out.println(second);
      System.out.print(""String_Node_Str"");
      int val=getBound(program,instr);
      if (val >= 0) {
        System.out.println(val);
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}","public void printResult(DFAAppInfo program){
  for (  InstructionHandle instr : bounds.keySet()) {
    ContextMap<CallString,Pair<ValueMapping,ValueMapping>> r=bounds.get(instr);
    Context c=r.getContext();
    LineNumberTable lines=program.getMethod(c.method).getCode().getLineNumberTable();
    int sourceLine=lines.getSourceLine(instr.getPosition());
    for (    CallString callString : r.keySet()) {
      Pair<ValueMapping,ValueMapping> bounds=r.get(callString);
      ValueMapping first=bounds.first();
      ValueMapping second=bounds.second();
      System.out.println(c.method + ""String_Node_Str"" + sourceLine+ ""String_Node_Str""+ callString.toStringList()+ ""String_Node_Str""+ scopes.get(instr)+ ""String_Node_Str"");
      System.out.print(""String_Node_Str"");
      System.out.println(first);
      System.out.print(""String_Node_Str"");
      System.out.println(second);
      System.out.print(""String_Node_Str"");
      int val=getBound(program,instr);
      if (val >= 0) {
        System.out.println(val);
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}",0.9908842297174112
186881,"public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  Map<Location,ValueMapping> in=(Map<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,new HashMap<CallString,Map<Location,ValueMapping>>());
  Instruction instruction=stmt.getInstruction();
  if (in == null) {
    context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
    return retval;
  }
  Map<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.LSTORE_0:
case Constants.LSTORE_1:
case Constants.LSTORE_2:
case Constants.LSTORE_3:
case Constants.LSTORE:
filterSet(in,result,context.stackPtr - 2);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.asList() + context.method+ stmt);
}
 else {
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.asList() + context.method+ stmt);
}
 else {
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.asList() + context.method+ stmt);
}
 else {
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.asList() + context.method+ stmt);
break;
}
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - 1) {
Location loc=new Location(name);
ValueMapping val=new ValueMapping(in.get(l),false);
val.join(in.get(loc));
result.put(loc,val);
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFAAppInfo p=interpreter.getProgram();
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
ValueMapping v=in.get(new Location(context.stackPtr - 1));
if (v == null) {
System.out.println(""String_Node_Str"" + context.callString.asList() + context.method+ stmt);
}
 else {
recordArrayIndex(stmt,context,v.assigned);
}
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
operand.neg();
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IMUL:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.mul(operand);
m.constrained.mul(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IDIV:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.div(operand);
m.constrained.div(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(context,stmt);
result=doIf(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(context,stmt);
result=doIfIcmp(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str""+ stmt.toString(true)+ ""String_Node_Str""+ ""String_Node_Str"");
result=in;
break;
}
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}","public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  Map<Location,ValueMapping> in=(Map<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,new HashMap<CallString,Map<Location,ValueMapping>>());
  Instruction instruction=stmt.getInstruction();
  if (in == null) {
    context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
    return retval;
  }
  Map<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.LSTORE_0:
case Constants.LSTORE_1:
case Constants.LSTORE_2:
case Constants.LSTORE_3:
case Constants.LSTORE:
filterSet(in,result,context.stackPtr - 2);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.contains(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
break;
}
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - 1) {
Location loc=new Location(name);
ValueMapping val=new ValueMapping(in.get(l),false);
val.join(in.get(loc));
result.put(loc,val);
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFAAppInfo p=interpreter.getProgram();
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
Set<String> receivers=p.getReceivers(stmt,context.callString);
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
ValueMapping v=in.get(new Location(context.stackPtr - 1));
if (v == null) {
System.out.println(""String_Node_Str"" + context.callString.toStringList() + context.method+ stmt);
}
 else {
recordArrayIndex(stmt,context,v.assigned);
}
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
operand.neg();
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IMUL:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.mul(operand);
m.constrained.mul(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IDIV:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.div(operand);
m.constrained.div(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(context,stmt);
result=doIf(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(context,stmt);
result=doIfIcmp(stmt,edge,context,in,result);
retval.put(context.callString,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
Set<String> receivers=p.getReceivers(stmt,context.callString);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str""+ stmt.toString(true)+ ""String_Node_Str""+ ""String_Node_Str"");
result=in;
break;
}
for (Iterator<String> i=receivers.iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}",0.9989237127604615
186882,"private void setBasicBlockAttributes(BasicBlockNode n,Map<String,String> ht){
  BasicBlock codeBlock=n.getBasicBlock();
  Instruction lastInstr=codeBlock.getLastInstruction().getInstruction();
  boolean isReturn=lastInstr instanceof ReturnInstruction;
  LoopColoring<CFGNode,ControlFlowGraph.CFGEdge> loops=flowGraph.getLoopColoring();
  StringBuilder nodeInfo=new StringBuilder();
  nodeInfo.append('#');
  nodeInfo.append(n.getId());
  nodeInfo.append(' ');
  String infoHeader;
  if (n instanceof ControlFlowGraph.InvokeNode) {
    ControlFlowGraph.InvokeNode in=(ControlFlowGraph.InvokeNode)n;
    infoHeader=""String_Node_Str"" + (in.isVirtual() ? (""String_Node_Str"" + in.getReferenced()) : in.getImplementedMethod().getFQMethodName()) + ""String_Node_Str"";
  }
 else   if (isReturn) {
    infoHeader=""String_Node_Str"";
  }
 else   if (codeBlock.getBranchInstruction() != null) {
    BranchInstruction instr=codeBlock.getBranchInstruction();
    infoHeader=""String_Node_Str"" + instr.getName() + ""String_Node_Str"";
  }
 else {
    infoHeader=""String_Node_Str"";
  }
  nodeInfo.append(infoHeader);
  nodeInfo.append(""String_Node_Str"" + codeBlock.getNumberOfBytes() + ""String_Node_Str"");
  nodeInfo.append(n.getBasicBlock().getAppInfo().getWCETProcessorModel().basicBlockWCET(new ExecutionContext(codeBlock.getMethodInfo()),codeBlock) + ""String_Node_Str"");
  if (loops.getHeadOfLoops().contains(n)) {
    nodeInfo.append(""String_Node_Str"" + n.getId() + ""String_Node_Str""+ flowGraph.getLoopBounds().get(n));
  }
  nodeInfo.append(""String_Node_Str"");
  nodeInfo.append(codeBlock.dump());
  ht.put(""String_Node_Str"",nodeInfo.toString());
  if (!loops.getHeadOfLoops().isEmpty()) {
    if (flowGraph.getLoopColoring().getLoopColors().get(n) == null) {
      logger.error(""String_Node_Str"" + n + ""String_Node_Str"");
    }
 else {
      ht.put(""String_Node_Str"",""String_Node_Str"" + (1 + flowGraph.getLoopColoring().getLoopColors().get(n).size()));
    }
  }
}","private void setBasicBlockAttributes(BasicBlockNode n,Map<String,String> ht){
  BasicBlock codeBlock=n.getBasicBlock();
  ControlFlowGraph flowGraph=n.getControlFlowGraph();
  Instruction lastInstr=codeBlock.getLastInstruction().getInstruction();
  boolean isReturn=lastInstr instanceof ReturnInstruction;
  LoopColoring<CFGNode,ControlFlowGraph.CFGEdge> loops=flowGraph.getLoopColoring();
  StringBuilder nodeInfo=new StringBuilder();
  nodeInfo.append('#');
  nodeInfo.append(n.getId());
  nodeInfo.append(' ');
  String infoHeader;
  if (n instanceof ControlFlowGraph.InvokeNode) {
    ControlFlowGraph.InvokeNode in=(ControlFlowGraph.InvokeNode)n;
    infoHeader=""String_Node_Str"" + (in.isVirtual() ? (""String_Node_Str"" + in.getReferenced()) : in.getImplementedMethod().getFQMethodName()) + ""String_Node_Str"";
  }
 else   if (isReturn) {
    infoHeader=""String_Node_Str"";
  }
 else   if (codeBlock.getBranchInstruction() != null) {
    BranchInstruction instr=codeBlock.getBranchInstruction();
    infoHeader=""String_Node_Str"" + instr.getName() + ""String_Node_Str"";
  }
 else {
    infoHeader=""String_Node_Str"";
  }
  nodeInfo.append(infoHeader);
  nodeInfo.append(""String_Node_Str"" + codeBlock.getNumberOfBytes() + ""String_Node_Str"");
  addNodeLabel(n,nodeInfo);
  if (loops.getHeadOfLoops().contains(n)) {
    nodeInfo.append(""String_Node_Str"" + n.getId() + ""String_Node_Str""+ flowGraph.getLoopBounds().get(n));
  }
  nodeInfo.append(""String_Node_Str"");
  nodeInfo.append(codeBlock.dump());
  ht.put(""String_Node_Str"",nodeInfo.toString());
  if (!loops.getHeadOfLoops().isEmpty()) {
    if (flowGraph.getLoopColoring().getLoopColors().get(n) == null) {
      logger.error(""String_Node_Str"" + n + ""String_Node_Str"");
    }
 else {
      ht.put(""String_Node_Str"",""String_Node_Str"" + (1 + flowGraph.getLoopColoring().getLoopColors().get(n).size()));
    }
  }
}",0.9378768020969857
186883,"/** 
 * Get infeasible edges for certain call string
 * @return The infeasible edges
 */
public List<CFGEdge> getInfeasibleEdges(CallString cs){
  List<CFGEdge> edges=new Vector<CFGEdge>();
  for (  BasicBlock b : blocks) {
    List<CFGEdge> edge=dfaInfeasibleEdge(b,cs);
    edges.addAll(edge);
  }
  return edges;
}","/** 
 * Get infeasible edges for certain call string
 * @return The infeasible edges
 */
public List<CFGEdge> getInfeasibleEdges(CallString cs){
  List<CFGEdge> edges=new ArrayList<CFGEdge>();
  return edges;
}",0.7172675521821632
186884,"/** 
 * Get improved loopbound considering the callcontext 
 */
public LoopBound getLoopBound(CFGNode hol,CallString cs){
  LoopBound globalBound=this.annotations.get(hol);
  return this.dfaLoopBound(hol.getBasicBlock(),cs,globalBound);
}","/** 
 * Get improved loopbound considering the callcontext 
 */
public LoopBound getLoopBound(CFGNode hol,CallString cs){
  LoopBound globalBound=this.annotations.get(hol);
  return globalBound;
}",0.9032258064516128
186885,"public void exportDOT(File file,Map<CFGNode,?> nodeAnnotations,Map<CFGEdge,?> edgeAnnotations){
  CFGExport export=new CFGExport(this,nodeAnnotations,edgeAnnotations);
  try {
    FileWriter w=new FileWriter(file);
    export.exportDOT(w,graph);
    w.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void exportDOT(File file,Map<CFGNode,?> nodeAnnotations,Map<CFGEdge,?> edgeAnnotations) throws IOException {
  CFGExport export=new CFGExport(this,nodeAnnotations,edgeAnnotations);
  FileWriter w=new FileWriter(file);
  export.exportDOT(w,graph);
  w.close();
}",0.8406779661016949
186886,"public String getGraph(){
  if (graphLink == null) {
    File graphfile=generateGraph(method,key,nodeAnnotations,edgeAnnotations);
    graphLink=graphfile.getName();
  }
  return graphLink;
}","public String getGraph(){
  if (graphLink == null) {
    File graphfile;
    try {
      graphfile=generateGraph(method,key,nodeAnnotations,edgeAnnotations);
      graphLink=graphfile.getName();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + method,e);
    }
  }
  return graphLink;
}",0.7609561752988048
186887,"private File generateGraph(MethodInfo method,String key,Map<CFGNode,?> nodeAnnotations,Map<ControlFlowGraph.CFGEdge,?> edgeAnnotations){
  File cgdot=config.getOutFile(method,key + ""String_Node_Str"");
  File cgimg=config.getOutFile(method,key + ""String_Node_Str"");
  ControlFlowGraph flowGraph=method.getCode().getControlFlowGraph();
  flowGraph.exportDOT(cgdot,nodeAnnotations,edgeAnnotations);
  project.getReport().recordDot(cgdot,cgimg);
  return cgimg;
}","private File generateGraph(MethodInfo method,String key,Map<CFGNode,?> nodeAnnotations,Map<ControlFlowGraph.CFGEdge,?> edgeAnnotations) throws IOException {
  File cgdot=config.getOutFile(method,key + ""String_Node_Str"");
  File cgimg=config.getOutFile(method,key + ""String_Node_Str"");
  ControlFlowGraph flowGraph=method.getCode().getControlFlowGraph();
  if (nodeAnnotations != null || edgeAnnotations != null) {
    flowGraph.exportDOT(cgdot,nodeAnnotations,edgeAnnotations);
  }
 else {
    flowGraph.exportDOT(cgdot,new WCETNodeLabeller(project),null);
  }
  project.getReport().recordDot(cgdot,cgimg);
  return cgimg;
}",0.8476454293628809
186888,"/** 
 * Rebuild the constantpool and remove all entries marked for removal by   {@link #removeConstant(int)}as well as all duplicate entries. <p>This also updates the indices of all references in the code of all methods of this class, therefore do not call this method while modifying the code.</p>
 * @see #removeConstant(int)
 * @return true if the constantpool has been changed
 */
public boolean cleanupConstantPool(){
  ConstantPoolGen newPool=new ConstantPoolGen();
  int[] idxMap=new int[cpg.getSize()];
  boolean changed=false;
  for (int i=0; i < idxMap.length; i++) {
    if (removeIndices.contains(i)) {
      idxMap[i]=-1;
      changed=true;
      continue;
    }
    idxMap[i]=newPool.addConstant(cpg.getConstant(i),cpg);
    if (idxMap[i] != i) {
      changed=true;
    }
  }
  if (!changed) {
    return false;
  }
  classGen.setConstantPool(newPool);
  return true;
}","/** 
 * Rebuild the constantpool and remove all entries marked for removal by   {@link #removeConstant(int)}as well as all duplicate entries. <p>This also updates the indices of all references in the code of all methods of this class, therefore do not call this method while modifying the code.</p>
 * @see #removeConstant(int)
 * @return true if the constantpool has been changed
 */
public boolean cleanupConstantPool(){
  if (removeIndices.isEmpty()) {
    return false;
  }
  ConstantPoolGen newPool=new ConstantPoolGen();
  int[] idxMap=new int[cpg.getSize()];
  for (int i=0; i < idxMap.length; i++) {
    if (removeIndices.contains(i)) {
      idxMap[i]=-1;
      continue;
    }
    Constant c=cpg.getConstant(i);
    if (c == null) {
      continue;
    }
    idxMap[i]=newPool.addConstant(c,cpg);
  }
  classGen.setConstantPool(newPool);
  return true;
}",0.7478559176672385
186889,"/** 
 * Setup the logger. You may want to call   {@link #setupConfig(String[])} first toload commandline options.
 * @see LogConfig#setupLogger(Config)
 */
public void setupLogger(){
  logConfig.setupLogger(config);
}","/** 
 * Setup the logger. You may want to call   {@link #setupConfig(String[])} first toload commandline options.
 * @see LogConfig#setupLogger(Config)
 * @param addReportLoggers if true, add html-report loggers writing to {@link Config#WRITE_PATH}.
 */
public void setupLogger(boolean addReportLoggers){
  logConfig.setupLogger(config);
  if (addReportLoggers) {
    String outDir=config.getOption(Config.WRITE_PATH) + File.separator;
    try {
      logConfig.setReportLoggers(new File(outDir + ""String_Node_Str""),new File(outDir + ""String_Node_Str""));
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      System.exit(4);
    }
  }
}",0.4811529933481153
186890,"/** 
 * Setup the logger using configuration options. You may want to call   {@link #setReportLoggers(File,File)}first to define the report loggers.
 * @param config the config settings to use.
 */
public void setupLogger(Config config){
  boolean verbose=config.getOption(Config.VERBOSE);
  boolean debug=config.getOption(Config.DEBUG);
  boolean quiet=config.getOption(Config.QUIET);
  ConsoleAppender defaultAppender;
  if (verbose) {
    defaultAppender=new ConsoleAppender(new PatternLayout(""String_Node_Str""),""String_Node_Str"");
  }
 else {
    defaultAppender=new ConsoleAppender(new ConsoleLayout(""String_Node_Str""),""String_Node_Str"");
  }
  defaultAppender.setName(""String_Node_Str"");
  Level defaultLevel=Level.INFO;
  if (debug) {
    defaultLevel=Level.DEBUG;
  }
 else   if (quiet) {
    defaultLevel=Level.WARN;
  }
  defaultAppender.setThreshold(defaultLevel);
  Logger.getRootLogger().addAppender(defaultAppender);
  Logger.getRootLogger().setLevel(defaultLevel);
  PropertyConfigurator.configure(config.getProperties());
}","/** 
 * Setup the logger using configuration options. You may want to call   {@link #setReportLoggers(File,File)}first to define the report loggers.
 * @param config the config settings to use.
 */
public void setupLogger(Config config){
  boolean verbose=config.getOption(Config.VERBOSE);
  boolean debug=config.getOption(Config.DEBUG);
  boolean quiet=config.getOption(Config.QUIET);
  ConsoleAppender defaultAppender;
  if (verbose) {
    defaultAppender=new ConsoleAppender(new PatternLayout(""String_Node_Str""),""String_Node_Str"");
  }
 else {
    defaultAppender=new ConsoleAppender(new ConsoleLayout(""String_Node_Str""),""String_Node_Str"");
  }
  defaultAppender.setName(""String_Node_Str"");
  Level defaultLevel=Level.INFO;
  if (debug) {
    defaultLevel=Level.DEBUG;
  }
 else   if (quiet) {
    defaultLevel=Level.WARN;
  }
  defaultAppender.setThreshold(defaultLevel);
  Logger.getRootLogger().addAppender(defaultAppender);
  Logger.getRootLogger().setLevel(Level.ALL);
  PropertyConfigurator.configure(config.getProperties());
}",0.9898795180722892
186891,"private void processQueue(){
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"");
  }
  while (!queue.isEmpty()) {
    ClassInfo next=queue.remove(0);
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + next.getClassName());
    }
    int found=processClass(next);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + found + ""String_Node_Str""+ next.getClassName());
    }
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + newClasses.size() + ""String_Node_Str"");
  }
}","private void processQueue(){
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"");
  }
  while (!queue.isEmpty()) {
    ClassInfo next=queue.remove(0);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + next.getClassName());
    }
    int found=processClass(next);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + found + ""String_Node_Str""+ next.getClassName());
    }
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + newClasses.size() + ""String_Node_Str"");
  }
}",0.9817518248175182
186892,"public static void main(String[] args){
  ExampleTool example=new ExampleTool();
  Properties defaults=null;
  try {
    defaults=AppSetup.loadResourceProps(ExampleTool.class,""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
  }
  AppSetup setup=new AppSetup(defaults,true);
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.setVersionInfo(""String_Node_Str"");
  setup.addStandardOptions(true,true);
  setup.addWriteOptions(true);
  setup.registerModule(""String_Node_Str"",example);
  String[] rest=setup.setupConfig(args,""String_Node_Str"");
  setup.setupLogger();
  setup.setupAppInfo(rest,true);
  setup.writeClasses();
}","public static void main(String[] args){
  ExampleTool example=new ExampleTool();
  Properties defaults=null;
  try {
    defaults=AppSetup.loadResourceProps(ExampleTool.class,""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
  }
  AppSetup setup=new AppSetup(defaults,true);
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.setVersionInfo(""String_Node_Str"");
  setup.addStandardOptions(true,true);
  setup.addWriteOptions(true);
  setup.registerModule(""String_Node_Str"",example);
  String[] rest=setup.setupConfig(args,""String_Node_Str"");
  setup.setupLogger(false);
  setup.setupAppInfo(rest,true);
  setup.writeClasses();
}",0.9965349965349966
186893,"public static void main(String[] args){
  JCopter jcopter=new JCopter();
  AppSetup setup=new AppSetup(true);
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.addStandardOptions(true,true);
  setup.addPackageOptions(true);
  setup.addWriteOptions(true);
  setup.registerModule(""String_Node_Str"",jcopter);
  String[] rest=setup.setupConfig(args,""String_Node_Str"");
  setup.setupLogger();
  setup.setupAppInfo(rest,true);
  jcopter.run(setup);
  setup.writeClasses();
}","public static void main(String[] args){
  JCopter jcopter=new JCopter();
  AppSetup setup=new AppSetup(true);
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.addStandardOptions(true,true);
  setup.addPackageOptions(true);
  setup.addWriteOptions(true);
  setup.registerModule(""String_Node_Str"",jcopter);
  String[] rest=setup.setupConfig(args,""String_Node_Str"");
  setup.setupLogger(true);
  setup.setupAppInfo(rest,true);
  jcopter.run(setup);
  setup.writeClasses();
}",0.995893223819302
186894,"public static void main(String[] args){
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  final String clsName=args[0].substring(args[0].lastIndexOf(""String_Node_Str"") + 1);
  try {
    Class cls=Class.forName(args[0]);
    Method main=cls.getMethod(""String_Node_Str"",new Class[]{String[].class});
    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
    while (true) {
      System.out.print(clsName + ""String_Node_Str"");
      String s=br.readLine();
      if (s == null) {
        return;
      }
      String cmd=s.trim();
      if (""String_Node_Str"".equals(cmd)) {
        return;
      }
      String[] mainArgs=cmd.split(""String_Node_Str"");
      System.setSecurityManager(new SecurityManager(){
        @Override public void checkPermission(        Permission perm){
        }
        @Override public void checkPermission(        Permission perm,        Object context){
        }
        @Override public void checkExit(        int status){
          throw new SecurityException(clsName + ""String_Node_Str"" + status);
        }
      }
);
      try {
        main.invoke(null,new Object[]{mainArgs});
      }
 catch (      Exception e) {
        if (e.getCause() instanceof SecurityException) {
          System.out.println(e.getCause().getMessage());
        }
 else {
          e.printStackTrace();
        }
      }
 finally {
        System.setSecurityManager(null);
      }
      AppInfo.getSingleton().clear(true);
    }
  }
 catch (  ClassNotFoundException e) {
    System.out.println(""String_Node_Str"" + args[0] + ""String_Node_Str"");
    System.exit(1);
  }
catch (  NoSuchMethodException e) {
    System.out.println(""String_Node_Str"" + args[0] + ""String_Node_Str"");
    System.exit(1);
  }
catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
  }
}","public static void main(String[] args){
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  final String clsName=args[0].substring(args[0].lastIndexOf(""String_Node_Str"") + 1);
  try {
    Class cls=Class.forName(args[0]);
    Method main=cls.getMethod(""String_Node_Str"",new Class[]{String[].class});
    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
    while (true) {
      System.out.print(clsName + ""String_Node_Str"");
      String s=br.readLine();
      if (s == null) {
        return;
      }
      String cmd=s.trim();
      if (""String_Node_Str"".equals(cmd)) {
        return;
      }
      String[] mainArgs=cmd.split(""String_Node_Str"");
      System.setSecurityManager(new SecurityManager(){
        @Override public void checkPermission(        Permission perm){
        }
        @Override public void checkPermission(        Permission perm,        Object context){
        }
        @Override public void checkExit(        int status){
          throw new SecurityException(clsName + ""String_Node_Str"" + status);
        }
      }
);
      try {
        main.invoke(null,new Object[]{mainArgs});
      }
 catch (      Exception e) {
        if (e.getCause() instanceof SecurityException) {
          System.out.println(e.getCause().getMessage());
        }
 else {
          e.printStackTrace();
        }
      }
 finally {
        System.setSecurityManager(null);
      }
      AppInfo.getSingleton().clear(true);
      LogConfig.stopLogger();
    }
  }
 catch (  ClassNotFoundException e) {
    System.out.println(""String_Node_Str"" + args[0] + ""String_Node_Str""+ e.getMessage());
    System.exit(1);
  }
catch (  NoSuchMethodException e) {
    System.out.println(""String_Node_Str"" + args[0] + ""String_Node_Str""+ e.getMessage());
    System.exit(1);
  }
catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
  }
}",0.9838457529963522
186895,"private int processClass(ClassInfo classInfo){
  AppInfo appInfo=AppInfo.getSingleton();
  int cnt=0;
  int size=classInfo.getConstantPoolSize();
  for (int i=0; i < size; i++) {
    ConstantInfo constantInfo=classInfo.getConstantInfo(i);
    if (constantInfo == null) {
      continue;
    }
    ClassRef ref=constantInfo.getClassRef();
    if (ref == null) {
      continue;
    }
    ClassInfo cls=ref.getClassInfo();
    if (cls == null) {
      cls=appInfo.loadClass(ref.getClassName());
      if (cls != null) {
        newClasses.add(cls);
        cnt++;
      }
    }
    if (cls != null) {
      enqueue(cls);
    }
  }
  return cnt;
}","private int processClass(ClassInfo classInfo){
  AppInfo appInfo=AppInfo.getSingleton();
  int cnt=0;
  int size=classInfo.getConstantPoolSize();
  for (int i=0; i < size; i++) {
    ConstantInfo constantInfo=classInfo.getConstantInfo(i);
    if (constantInfo == null) {
      continue;
    }
    ClassRef ref=constantInfo.getClassRef();
    if (ref == null) {
      continue;
    }
    String className;
    if (ref.isArray()) {
      Type baseType=((ArrayType)ref.getType()).getBasicType();
      if (baseType instanceof ObjectType) {
        className=((ObjectType)baseType).getClassName();
      }
 else {
        continue;
      }
    }
 else {
      className=ref.getClassName();
    }
    ClassInfo cls;
    if (appInfo.hasClassInfo(className)) {
      cls=appInfo.getClassInfo(className);
    }
 else {
      cls=appInfo.loadClass(className);
      if (cls != null) {
        newClasses.add(cls);
        cnt++;
      }
    }
    if (cls != null) {
      enqueue(cls);
    }
  }
  return cnt;
}",0.7083839611178615
186896,"public ClassRef(String className,boolean anInterface){
  this.className=className;
  this.anInterface=anInterface ? Ternary.TRUE : Ternary.FALSE;
}","public ClassRef(String className,boolean anInterface){
  this.className=className;
  this.anInterface=anInterface ? Ternary.TRUE : Ternary.FALSE;
  arrayClass=className.startsWith(""String_Node_Str"");
}",0.8448275862068966
186897,"public ClassInfo getClassInfo(){
  if (classInfo == null) {
    classInfo=AppInfo.getSingleton().getClassInfo(className);
  }
  return classInfo;
}","public ClassInfo getClassInfo(){
  if (classInfo == null && !arrayClass) {
    classInfo=AppInfo.getSingleton().getClassInfo(className);
  }
  return classInfo;
}",0.9514563106796116
186898,"public ObjectType getType(){
  return new ObjectType(getClassName());
}","public ReferenceType getType(){
  if (arrayClass) {
    int dim=className.lastIndexOf('[') + 1;
    return new ArrayType(Type.getType(className.substring(dim)),dim);
  }
  return new ObjectType(getClassName());
}",0.254416961130742
186899,"@Override public ObjectType getType(){
  return getValue().getType();
}","@Override public ReferenceType getType(){
  return getValue().getType();
}",0.9241379310344828
186900,"@Override public ObjectType getType(){
  return getClassRef().getType();
}","@Override public Type getType(){
  return getValue().getType();
}",0.8920863309352518
186901,public abstract ClassRef getClassRef();,"/** 
 * Get a reference to the class this constant refers to if it is a class-, method- or field-constant.
 * @return the referenced class or null if no class is referenced by this constant type.
 */
public abstract ClassRef getClassRef();",0.2805755395683453
186902,"@Override public ObjectType getType(){
  return getClassRef().getType();
}","@Override public Type getType(){
  return getValue().getDescriptor().getType();
}",0.8
186903,"public Ternary isInterfaceMethod(){
  return classRef.isInterface();
}","public Ternary isInterfaceMethod(){
  if (methodInfo != null) {
    return Ternary.valueOf(methodInfo.getClassInfo().isInterface());
  }
  return classRef.isInterface();
}",0.5809128630705395
186904,"public MethodRef getMethodRef(Signature signature,boolean isInterfaceMethod){
  ClassInfo cls=getClassInfo(signature.getClassName());
  if (cls != null) {
    if (cls.isInterface() != isInterfaceMethod) {
      throw new ClassFormatException(""String_Node_Str"" + cls.getClassName() + ""String_Node_Str"");
    }
    MethodInfo method=cls.getMethodInfo(signature);
    if (method == null) {
      return new MethodRef(cls.getClassRef(),signature.getMemberName(),signature.getMemberDescriptor());
    }
 else {
      return method.getMethodRef();
    }
  }
  return new MethodRef(new ClassRef(signature.getClassName(),isInterfaceMethod),signature.getMemberName(),signature.getMemberDescriptor());
}","public MethodRef getMethodRef(Signature signature,boolean isInterfaceMethod){
  ClassInfo cls=classes.get(signature.getClassName());
  if (cls != null) {
    if (cls.isInterface() != isInterfaceMethod) {
      throw new ClassFormatException(""String_Node_Str"" + cls.getClassName() + ""String_Node_Str"");
    }
    MethodInfo method=cls.getMethodInfo(signature);
    if (method == null) {
      return new MethodRef(cls.getClassRef(),signature.getMemberName(),signature.getMemberDescriptor());
    }
 else {
      return method.getMethodRef();
    }
  }
  return new MethodRef(new ClassRef(signature.getClassName(),isInterfaceMethod),signature.getMemberName(),signature.getMemberDescriptor());
}",0.983393501805054
186905,"public FieldRef getFieldRef(Signature signature){
  ClassInfo cls=getClassInfo(signature.getClassName());
  if (cls != null) {
    FieldInfo field=cls.getFieldInfo(signature.getMemberName());
    if (field == null) {
      return new FieldRef(cls.getClassRef(),signature.getMemberName(),signature.getMemberDescriptor().getType());
    }
 else {
      return field.getFieldRef();
    }
  }
  return new FieldRef(new ClassRef(signature.getClassName()),signature.getMemberName(),signature.getMemberDescriptor().getType());
}","public FieldRef getFieldRef(Signature signature){
  ClassInfo cls=classes.get(signature.getClassName());
  if (cls != null) {
    FieldInfo field=cls.getFieldInfo(signature.getMemberName());
    if (field == null) {
      return new FieldRef(cls.getClassRef(),signature.getMemberName(),signature.getMemberDescriptor().getType());
    }
 else {
      return field.getFieldRef();
    }
  }
  return new FieldRef(new ClassRef(signature.getClassName()),signature.getMemberName(),signature.getMemberDescriptor().getType());
}",0.97790585975024
186906,"public ClassRef getClassRef(String className,boolean isInterface){
  ClassInfo cls=getClassInfo(className);
  if (cls != null) {
    if (cls.isInterface() != isInterface) {
      throw new ClassFormatException(""String_Node_Str"" + className + ""String_Node_Str"");
    }
    return cls.getClassRef();
  }
  return new ClassRef(className,isInterface);
}","public ClassRef getClassRef(String className,boolean isInterface){
  ClassInfo cls=classes.get(className);
  if (cls != null) {
    if (cls.isInterface() != isInterface) {
      throw new ClassFormatException(""String_Node_Str"" + className + ""String_Node_Str"");
    }
    return cls.getClassRef();
  }
  return new ClassRef(className,isInterface);
}",0.9670014347202296
186907,"public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0 || ""String_Node_Str"".equals(args[0])) {
    System.out.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  String[] natives=Config.splitStringList(config.getOption(Config.NATIVE_CLASSES));
  for (  String n : natives) {
    appInfo.addNative(n.replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.out.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
    appInfo.reloadClassHierarchy();
  }
}","public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0 || ""String_Node_Str"".equals(args[0])) {
    System.out.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  String[] natives=Config.splitStringList(config.getOption(Config.NATIVE_CLASSES));
  for (  String n : natives) {
    appInfo.addNative(n.replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.out.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
    appInfo.reloadClassHierarchy();
  }
}",0.9857142857142858
186908,"public MethodInfo renameMethod(Signature signature,String newName){
  return null;
}","public MethodInfo renameMethod(String memberSignature,String newName){
  MethodInfo method=methods.remove(memberSignature);
  if (method == null) {
    return null;
  }
  method.getMethodGen().setName(newName);
  methods.put(method.getMemberSignature(),method);
  return method;
}",0.3351648351648351
186909,"public MethodInfo copyMethod(Signature signature,String newName){
  return null;
}","public MethodInfo copyMethod(String memberSignature,String newName){
  MethodInfo method=methods.get(memberSignature);
  if (method == null) {
    return null;
  }
  method.compileCodeRep();
  MethodGen methodGen=new MethodGen(method.getMethod(),getClassName(),cpg);
  methodGen.setName(newName);
  MethodInfo newMethod=new MethodInfo(this,methodGen);
  methods.put(newMethod.getMemberSignature(),newMethod);
  return newMethod;
}",0.23046875
186910,"public FieldInfo renameField(String name,String newName){
  return null;
}","public FieldInfo renameField(String name,String newName){
  FieldInfo field=fields.remove(name);
  if (field == null) {
    return null;
  }
  field.getFieldGen().setName(newName);
  fields.put(newName,field);
  return field;
}",0.4053156146179402
186911,"/** 
 * Check if this class is either an extension or an implementation of the given class or interface.
 * @param classInfo the super class to check.
 * @return true if this class is is a subtype of the given class.
 */
public boolean isSubtypeOf(ClassInfo classInfo){
  if (!classInfo.isInterface()) {
    return classInfo.isSuperclassOf(this);
  }
  Set<ClassInfo> supers=getAllSuperClasses();
  return supers.contains(classInfo);
}","/** 
 * Check if this class is either an extension or an implementation of the given class or interface.
 * @param classInfo the super class to check.
 * @return true if this class is is a subtype of the given class.
 */
public boolean isSubtypeOf(ClassInfo classInfo){
  if (!classInfo.isInterface()) {
    return classInfo.isSuperclassOf(this);
  }
  Set<ClassInfo> supers=getAncestors();
  return supers.contains(classInfo);
}",0.976851851851852
186912,"public FieldInfo copyField(String name,String newName){
  return null;
}","public FieldInfo copyField(String name,String newName){
  FieldInfo field=fields.get(name);
  if (field == null) {
    return null;
  }
  FieldGen fieldGen=new FieldGen(field.getField(),cpg);
  fieldGen.setName(newName);
  FieldInfo newField=new FieldInfo(this,fieldGen);
  fields.put(newName,newField);
  return newField;
}",0.2979797979797979
186913,"/** 
 * Check if the given class is a subclass of this class.
 * @param classInfo the possible subclass of this class.
 * @return true if the given class is this class or a superclass of this class.
 */
public boolean isSuperclassOf(ClassInfo classInfo){
  ClassInfo cls=classInfo;
  while (cls != null) {
    if (this.equals(cls)) {
      return true;
    }
    cls=cls.getSuperClassInfo();
  }
  return false;
}","/** 
 * Check if the given class is the same as this class or a subclass of this class.
 * @param classInfo the possible subclass of this class.
 * @return true if the given class is this class or a superclass of this class.
 */
public boolean isSuperclassOf(ClassInfo classInfo){
  ClassInfo cls=classInfo;
  while (cls != null) {
    if (this.equals(cls)) {
      return true;
    }
    cls=cls.getSuperClassInfo();
  }
  return false;
}",0.9694835680751174
186914,"public ConstantInfo getConstantInfo(int i){
  if (i < 0 || i >= cpg.getSize()) {
    return null;
  }
  Constant c=cpg.getConstant(i);
  return ConstantInfo.createFromConstant(cpg.getConstantPool(),c);
}","public ConstantInfo getConstantInfo(int i){
  if (i < 0 || i >= cpg.getSize()) {
    return null;
  }
  Constant c=cpg.getConstant(i);
  if (c == null) {
    return null;
  }
  return ConstantInfo.createFromConstant(cpg.getConstantPool(),c);
}",0.9103139013452914
186915,"/** 
 * Check if the given class is an extension of this class, i.e. if this is a class, check if the given class is a subclass, if this is an interface, check if the given class is an interface and if this is an extension of the given interface.
 * @param classInfo the class to check.
 * @return true if the class is an extension of this class.
 */
public boolean isExtensionOf(ClassInfo classInfo){
  if (!isInterface()) {
    return isSuperclassOf(classInfo);
  }
  if (!classInfo.isInterface()) {
    return false;
  }
  Set<ClassInfo> interfaces=classInfo.getAllSuperClasses();
  return interfaces.contains(this);
}","/** 
 * Check if the given class is an extension of this class, i.e. if this is a class, check if the given class is a subclass, if this is an interface, check if the given class is an interface and if this is an extension of the given interface.
 * @param classInfo the class to check.
 * @return true if the class is an extension of this class.
 */
public boolean isExtensionOf(ClassInfo classInfo){
  if (!isInterface()) {
    return isSuperclassOf(classInfo);
  }
  if (!classInfo.isInterface()) {
    return false;
  }
  Set<ClassInfo> interfaces=classInfo.getAncestors();
  return interfaces.contains(this);
}",0.9838187702265372
186916,"public MethodGen getMethodGen(){
  compileCodeRep();
  return new MethodGen(methodGen.getMethod(),methodGen.getClassName(),methodGen.getConstantPool());
}","/** 
 * Should only be used by ClassInfo.
 * @return the internal methodGen.                           
 */
protected MethodGen getMethodGen(){
  return methodGen;
}",0.3134796238244514
186917,"/** 
 * Setup the logger using configuration options. You may want to call   {@link #setReportLoggers(File,File)}first to define the report loggers.
 * @param config the config settings to use.
 */
public void setupLogger(Config config){
  boolean verbose=config.getOption(Config.VERBOSE);
  boolean debug=config.getOption(Config.DEBUG);
  ConsoleAppender defaultAppender;
  if (verbose) {
    defaultAppender=new ConsoleAppender(new PatternLayout(""String_Node_Str""),""String_Node_Str"");
  }
 else {
    defaultAppender=new ConsoleAppender(new ConsoleLayout(""String_Node_Str""),""String_Node_Str"");
  }
  defaultAppender.setName(""String_Node_Str"");
  if (debug) {
    defaultAppender.setThreshold(verbose ? Level.DEBUG : Level.INFO);
  }
 else {
    defaultAppender.setThreshold(Level.WARN);
  }
  Logger.getRootLogger().addAppender(defaultAppender);
  PropertyConfigurator.configure(config.getProperties());
}","/** 
 * Setup the logger using configuration options. You may want to call   {@link #setReportLoggers(File,File)}first to define the report loggers.
 * @param config the config settings to use.
 */
public void setupLogger(Config config){
  boolean verbose=config.getOption(Config.VERBOSE);
  boolean debug=config.getOption(Config.DEBUG);
  boolean quiet=config.getOption(Config.QUIET);
  ConsoleAppender defaultAppender;
  if (verbose) {
    defaultAppender=new ConsoleAppender(new PatternLayout(""String_Node_Str""),""String_Node_Str"");
  }
 else {
    defaultAppender=new ConsoleAppender(new ConsoleLayout(""String_Node_Str""),""String_Node_Str"");
  }
  defaultAppender.setName(""String_Node_Str"");
  Level defaultLevel=Level.INFO;
  if (debug) {
    defaultLevel=Level.DEBUG;
  }
 else   if (quiet) {
    defaultLevel=Level.WARN;
  }
  defaultAppender.setThreshold(defaultLevel);
  Logger.getRootLogger().addAppender(defaultAppender);
  Logger.getRootLogger().setLevel(defaultLevel);
  PropertyConfigurator.configure(config.getProperties());
}",0.8612538540596094
186918,"private void processQueue(){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
  }
  while (!queue.isEmpty()) {
    ClassInfo next=queue.remove(0);
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + next.getClassName());
    }
    int found=processClass(next);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + found + ""String_Node_Str""+ next.getClassName());
    }
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + newClasses.size() + ""String_Node_Str"");
  }
}","private void processQueue(){
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"");
  }
  while (!queue.isEmpty()) {
    ClassInfo next=queue.remove(0);
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + next.getClassName());
    }
    int found=processClass(next);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + found + ""String_Node_Str""+ next.getClassName());
    }
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"" + newClasses.size() + ""String_Node_Str"");
  }
}",0.9781420765027322
186919,"private int processClass(ClassInfo classInfo){
  AppInfo appInfo=AppInfo.getSingleton();
  int cnt=0;
  int size=classInfo.getConstantPoolSize();
  for (int i=0; i < size; i++) {
    ClassRef ref=classInfo.getConstantInfo(i).getClassRef();
    if (ref == null) {
      continue;
    }
    ClassInfo cls=ref.getClassInfo();
    if (cls == null) {
      cls=appInfo.loadClass(ref.getClassName());
      if (cls != null) {
        newClasses.add(cls);
        cnt++;
      }
    }
    if (cls != null) {
      enqueue(cls);
    }
  }
  return cnt;
}","private int processClass(ClassInfo classInfo){
  AppInfo appInfo=AppInfo.getSingleton();
  int cnt=0;
  int size=classInfo.getConstantPoolSize();
  for (int i=0; i < size; i++) {
    ConstantInfo constantInfo=classInfo.getConstantInfo(i);
    if (constantInfo == null) {
      continue;
    }
    ClassRef ref=constantInfo.getClassRef();
    if (ref == null) {
      continue;
    }
    ClassInfo cls=ref.getClassInfo();
    if (cls == null) {
      cls=appInfo.loadClass(ref.getClassName());
      if (cls != null) {
        newClasses.add(cls);
        cnt++;
      }
    }
    if (cls != null) {
      enqueue(cls);
    }
  }
  return cnt;
}",0.8722689075630252
186920,"/** 
 * Create a new constantInfo from a BCEL constant. If the constantpool contains invalid data, a   {@link JavaClassFormatError} is thrown.
 * @param cp the constantpool used to resolve the index references.
 * @param constant the BCEL constant to convert
 * @return a new ConstantInfo containing the constant value.
 */
public static ConstantInfo createFromConstant(ConstantPool cp,Constant constant){
  Signature sig;
  MethodRef methodRef;
  ConstantNameAndType nRef;
  AppInfo appInfo=AppInfo.getSingleton();
  byte tag=constant.getTag();
switch (tag) {
case Constants.CONSTANT_Class:
    ClassRef classRef=appInfo.getClassRef(((ConstantClass)constant).getBytes(cp));
  return new ConstantClassInfo(classRef);
case Constants.CONSTANT_Fieldref:
ConstantFieldref fRef=(ConstantFieldref)constant;
nRef=(ConstantNameAndType)cp.getConstant(fRef.getNameAndTypeIndex());
sig=new Signature(fRef.getClass(cp),nRef.getName(cp),Descriptor.parse(nRef.getSignature(cp)));
FieldRef fieldRef=appInfo.getFieldRef(sig);
return new ConstantFieldInfo(fieldRef);
case Constants.CONSTANT_Methodref:
ConstantInterfaceMethodref mRef=(ConstantInterfaceMethodref)constant;
nRef=(ConstantNameAndType)cp.getConstant(mRef.getNameAndTypeIndex());
sig=new Signature(mRef.getClass(cp),nRef.getName(cp),Descriptor.parse(nRef.getSignature(cp)));
methodRef=appInfo.getMethodRef(sig,false);
return new ConstantMethodInfo(methodRef);
case Constants.CONSTANT_InterfaceMethodref:
ConstantInterfaceMethodref imRef=(ConstantInterfaceMethodref)constant;
nRef=(ConstantNameAndType)cp.getConstant(imRef.getNameAndTypeIndex());
sig=new Signature(imRef.getClass(cp),nRef.getName(cp),Descriptor.parse(nRef.getSignature(cp)));
methodRef=appInfo.getMethodRef(sig,true);
return new ConstantMethodInfo(methodRef);
case Constants.CONSTANT_String:
return new ConstantStringInfo(((ConstantString)constant).getBytes(cp),false);
case Constants.CONSTANT_Integer:
return new ConstantIntegerInfo(((ConstantInteger)constant).getBytes());
case Constants.CONSTANT_Float:
return new ConstantFloatInfo(((ConstantFloat)constant).getBytes());
case Constants.CONSTANT_Long:
return new ConstantLongInfo(((ConstantLong)constant).getBytes());
case Constants.CONSTANT_Double:
return new ConstantDoubleInfo(((ConstantDouble)constant).getBytes());
case Constants.CONSTANT_NameAndType:
String name=((ConstantNameAndType)constant).getName(cp);
String signature=((ConstantNameAndType)constant).getSignature(cp);
return new ConstantNameAndTypeInfo(new Signature(name,Descriptor.parse(signature)));
case Constants.CONSTANT_Utf8:
return new ConstantStringInfo(((ConstantUtf8)constant).getBytes(),true);
default :
throw new JavaClassFormatError(""String_Node_Str"" + tag);
}
}","/** 
 * Create a new constantInfo from a BCEL constant. If the constantpool contains invalid data, a   {@link JavaClassFormatError} is thrown.
 * @param cp the constantpool used to resolve the index references.
 * @param constant the BCEL constant to convert
 * @return a new ConstantInfo containing the constant value.
 */
public static ConstantInfo createFromConstant(ConstantPool cp,Constant constant){
  Signature sig;
  MethodRef methodRef;
  ConstantNameAndType nRef;
  AppInfo appInfo=AppInfo.getSingleton();
  byte tag=constant.getTag();
switch (tag) {
case Constants.CONSTANT_Class:
    ClassRef classRef=appInfo.getClassRef(((ConstantClass)constant).getBytes(cp));
  return new ConstantClassInfo(classRef);
case Constants.CONSTANT_Fieldref:
ConstantFieldref fRef=(ConstantFieldref)constant;
nRef=(ConstantNameAndType)cp.getConstant(fRef.getNameAndTypeIndex());
sig=new Signature(fRef.getClass(cp),nRef.getName(cp),Descriptor.parse(nRef.getSignature(cp)));
FieldRef fieldRef=appInfo.getFieldRef(sig);
return new ConstantFieldInfo(fieldRef);
case Constants.CONSTANT_Methodref:
ConstantMethodref mRef=(ConstantMethodref)constant;
nRef=(ConstantNameAndType)cp.getConstant(mRef.getNameAndTypeIndex());
sig=new Signature(mRef.getClass(cp),nRef.getName(cp),Descriptor.parse(nRef.getSignature(cp)));
methodRef=appInfo.getMethodRef(sig,false);
return new ConstantMethodInfo(methodRef);
case Constants.CONSTANT_InterfaceMethodref:
ConstantInterfaceMethodref imRef=(ConstantInterfaceMethodref)constant;
nRef=(ConstantNameAndType)cp.getConstant(imRef.getNameAndTypeIndex());
sig=new Signature(imRef.getClass(cp),nRef.getName(cp),Descriptor.parse(nRef.getSignature(cp)));
methodRef=appInfo.getMethodRef(sig,true);
return new ConstantMethodInfo(methodRef);
case Constants.CONSTANT_String:
return new ConstantStringInfo(((ConstantString)constant).getBytes(cp),false);
case Constants.CONSTANT_Integer:
return new ConstantIntegerInfo(((ConstantInteger)constant).getBytes());
case Constants.CONSTANT_Float:
return new ConstantFloatInfo(((ConstantFloat)constant).getBytes());
case Constants.CONSTANT_Long:
return new ConstantLongInfo(((ConstantLong)constant).getBytes());
case Constants.CONSTANT_Double:
return new ConstantDoubleInfo(((ConstantDouble)constant).getBytes());
case Constants.CONSTANT_NameAndType:
String name=((ConstantNameAndType)constant).getName(cp);
String signature=((ConstantNameAndType)constant).getSignature(cp);
return new ConstantNameAndTypeInfo(new Signature(name,Descriptor.parse(signature)));
case Constants.CONSTANT_Utf8:
return new ConstantStringInfo(((ConstantUtf8)constant).getBytes(),true);
default :
throw new JavaClassFormatError(""String_Node_Str"" + tag);
}
}",0.9966580022279984
186921,"public static void main(String[] args){
  JCopter jcopter=new JCopter();
  AppSetup setup=new AppSetup(true);
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.addStandardOptions(true,true);
  setup.addPackageOptions(true);
  setup.addWriteOptions(true);
  setup.registerModule(""String_Node_Str"",jcopter);
  String[] rest=setup.setupConfig(args);
  setup.setupLogger();
  setup.setupAppInfo(rest,true);
  jcopter.run(setup);
  setup.writeClasses();
}","public static void main(String[] args){
  JCopter jcopter=new JCopter();
  AppSetup setup=new AppSetup(true);
  setup.setUsageInfo(""String_Node_Str"",""String_Node_Str"");
  setup.addStandardOptions(true,true);
  setup.addPackageOptions(true);
  setup.addWriteOptions(true);
  setup.registerModule(""String_Node_Str"",jcopter);
  String[] rest=setup.setupConfig(args,""String_Node_Str"");
  setup.setupLogger();
  setup.setupAppInfo(rest,true);
  jcopter.run(setup);
  setup.writeClasses();
}",0.98109243697479
186922,"private void handleClassLoadFailure(String message,Exception cause){
  if (exitOnMissingClass) {
    System.out.println(message);
    System.exit(4);
  }
 else {
    throw new MissingClassError(message,cause);
  }
}","private void handleClassLoadFailure(String message,Exception cause){
  if (exitOnMissingClass) {
    logger.error(message,cause);
    System.exit(4);
  }
 else {
    throw new MissingClassError(message,cause);
  }
}",0.5627906976744186
186923,"public void printVersion(){
  if (versionInfo != null && !""String_Node_Str"".equals(versionInfo)) {
    System.out.println(versionInfo);
  }
  for (  String name : modules.keySet()) {
    versionInfo+=name + ""String_Node_Str"" + modules.get(name).getModuleVersion();
  }
}","public void printVersion(){
  if (versionInfo != null && !""String_Node_Str"".equals(versionInfo)) {
    System.out.println(versionInfo);
  }
  for (  String name : tools.keySet()) {
    System.out.println(name + ""String_Node_Str"" + tools.get(name).getToolVersion());
  }
}",0.6728280961182994
186924,"public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0 || ""String_Node_Str"".equals(args[0])) {
    System.out.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  String[] natives=Config.splitStringList(config.getOption(Config.NATIVE_CLASSES));
  for (  String n : natives) {
    appInfo.addNative(n.replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.out.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
    appInfo.reloadClassHierarchy();
  }
}","public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0 || ""String_Node_Str"".equals(args[0])) {
    System.err.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  appInfo.setExitOnMissingClass(!config.getOption(Config.VERBOSE));
  String[] natives=Config.splitStringList(config.getOption(Config.NATIVE_CLASSES));
  for (  String n : natives) {
    appInfo.addNative(n.replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.err.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
    appInfo.reloadClassHierarchy();
  }
}",0.9937862468931234
186925,"public void setUsageInfo(String prgmName,String description,String optionSyntax){
  this.prgmName=prgmName;
  usageDescription=description;
  this.optionSyntax=optionSyntax;
}","public void setUsageInfo(String programName,String description,String optionSyntax){
  this.programName=programName;
  usageDescription=description;
  this.optionSyntax=optionSyntax;
}",0.9749303621169916
186926,"public void printUsage(){
  String optionDesc;
  if (optionSyntax != null) {
    optionDesc=""String_Node_Str"" + optionSyntax;
  }
 else {
    optionDesc=""String_Node_Str"";
    if (config.getOptions().availableCommands().size() > 0) {
      optionDesc+=""String_Node_Str"";
    }
    if (handleAppInfoInit) {
      optionDesc+=""String_Node_Str"";
    }
  }
  System.out.print(""String_Node_Str"" + prgmName);
  System.out.println(optionDesc);
  System.out.println();
  if (usageDescription != null && !""String_Node_Str"".equals(usageDescription)) {
    System.out.println(usageDescription);
    System.out.println();
  }
  System.out.println(""String_Node_Str"");
  for (  Option<?> option : config.getOptions().availableOptions()) {
    System.out.println(option.toString(config.getDefaultIndent(),config.getOptions()));
  }
  System.out.println();
}","public void printUsage(){
  String optionDesc;
  if (optionSyntax != null) {
    optionDesc=""String_Node_Str"" + optionSyntax;
  }
 else {
    optionDesc=""String_Node_Str"";
    if (config.getOptions().availableCommands().size() > 0) {
      optionDesc+=""String_Node_Str"";
    }
    if (handleAppInfoInit) {
      optionDesc+=""String_Node_Str"";
    }
  }
  System.out.print(""String_Node_Str"" + (programName != null ? programName : ""String_Node_Str""));
  System.out.println(optionDesc);
  System.out.println();
  if (usageDescription != null && !""String_Node_Str"".equals(usageDescription)) {
    System.out.println(usageDescription);
    System.out.println();
  }
  System.out.println(""String_Node_Str"");
  for (  Option<?> option : config.getOptions().availableOptions()) {
    System.out.println(option.toString(config.getDefaultIndent(),config.getOptions()));
  }
  System.out.println();
  if (loadSystemProps && configFilename != null) {
    System.out.println(""String_Node_Str"" + configFilename + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else   if (configFilename != null) {
    System.out.println(""String_Node_Str"" + configFilename + ""String_Node_Str"");
  }
 else   if (loadSystemProps) {
    System.out.println(""String_Node_Str"");
  }
}",0.7908961593172119
186927,"public AppSetup(Properties defaultProps,boolean loadSystemProps){
  Properties def;
  if (loadSystemProps) {
    def=new Properties(defaultProps);
    def.putAll(System.getProperties());
  }
 else {
    def=defaultProps;
  }
  config=new Config(def);
  appInfo=AppInfo.getSingleton();
  logConfig=new LogConfig();
  modules=new HashMap<String,Module>();
}","/** 
 * Initialize a new AppSetup and set the given default properties (note that tools can add their own default config).
 * @param defaultProps defaults or the config.
 * @param loadSystemProps if true, add all JVM system properties to the default properties.  
 */
public AppSetup(Properties defaultProps,boolean loadSystemProps){
  this.loadSystemProps=loadSystemProps;
  Properties def=new Properties();
  if (defaultProps != null) {
    def.putAll(defaultProps);
  }
  if (loadSystemProps) {
    def.putAll(System.getProperties());
  }
  config=new Config(def);
  appInfo=AppInfo.getSingleton();
  logConfig=new LogConfig();
  tools=new HashMap<String,JopTool>();
}",0.4717348927875243
186928,"/** 
 * Write the AppInfo classes to the directory specified by the outDir option.
 * @param outDir the option for the classfiles output directory.
 */
public void writeClasses(Option<String> outDir){
  try {
    ClassWriter writer=new ClassWriter();
    writer.setup(config.getOptions());
    writer.write(config.getOption(outDir));
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(5);
  }
}","/** 
 * Write the AppInfo classes to the directory specified by the outDir option.
 * @param outDir the option for the classfiles output directory.
 */
public void writeClasses(Option<String> outDir){
  try {
    ClassWriter writer=new ClassWriter();
    writer.setup(config.getOptions());
    writer.write(config.getOption(outDir));
  }
 catch (  IOException e) {
    ClassWriter.logger.error(""String_Node_Str"" + e.getMessage(),e);
    System.exit(5);
  }
}",0.8458149779735683
186929,"/** 
 * Load the config file, parse and check options, and if handleApInfoInit has been set, also initialize AppInfo.
 * @param args cmdline arguments to parse
 * @param configFile filename of an optional user configuration file, will be tried to be loaded beforearguments are parsed.
 * @return arguments not consumed.
 */
public String[] setupConfig(String[] args,String configFile){
  File file=findConfigFile(configFile);
  if (file != null && file.exists()) {
    try {
      InputStream is=new BufferedInputStream(new FileInputStream(file));
      config.addProperties(is);
    }
 catch (    FileNotFoundException e) {
      System.out.println(""String_Node_Str"" + configFile + ""String_Node_Str""+ e.getMessage());
    }
catch (    IOException e) {
      System.out.println(""String_Node_Str"" + file + ""String_Node_Str""+ e.getMessage());
      System.exit(3);
    }
  }
  String[] rest=null;
  try {
    rest=config.parseArguments(args);
    config.checkOptions();
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (config.getOption(Config.SHOW_HELP) && prgmName != null) {
    printUsage();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_VERSION) && versionInfo != null) {
    printVersion();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_CONFIG)) {
    config.printConfiguration(config.getDefaultIndent());
    System.exit(0);
  }
  try {
    for (    Module module : modules.values()) {
      module.onSetupConfig(this);
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  return rest;
}","/** 
 * Load the config file, parse and check options, and if handleApInfoInit has been set, also initialize AppInfo.
 * @param args cmdline arguments to parse
 * @return arguments not consumed.
 */
public String[] setupConfig(String[] args){
  if (configFilename != null) {
    File file=findConfigFile(configFilename);
    if (file != null && file.exists()) {
      try {
        InputStream is=new BufferedInputStream(new FileInputStream(file));
        config.addProperties(is);
      }
 catch (      FileNotFoundException e) {
        System.err.println(""String_Node_Str"" + configFilename + ""String_Node_Str""+ e.getMessage());
      }
catch (      IOException e) {
        System.err.println(""String_Node_Str"" + file + ""String_Node_Str""+ e.getMessage());
        System.exit(3);
      }
    }
  }
  String[] rest=null;
  try {
    rest=config.parseArguments(args);
    config.checkOptions();
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (config.getOption(Config.SHOW_HELP)) {
    printUsage();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_VERSION)) {
    printVersion();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_CONFIG)) {
    config.printConfiguration(config.getDefaultIndent());
    System.exit(0);
  }
  try {
    for (    JopTool jopTool : tools.values()) {
      jopTool.onSetupConfig(this);
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.err.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.err.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  return rest;
}",0.8830744071954211
186930,"public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  String[] natives=Config.splitStringList(config.getOption(Config.NATIVE_CLASSES));
  for (  String n : natives) {
    appInfo.addNative(n.replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.out.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
  }
}","public void setupAppInfo(String[] args,boolean loadTransitiveHull){
  if (args.length == 0 || ""String_Node_Str"".equals(args[0])) {
    System.out.println(""String_Node_Str"");
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  appInfo.setClassPath(new ClassPath(config.getOption(Config.CLASSPATH)));
  String[] natives=Config.splitStringList(config.getOption(Config.NATIVE_CLASSES));
  for (  String n : natives) {
    appInfo.addNative(n.replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  if (config.hasOption(Config.LIBRARY_CLASSES)) {
    String[] libs=Config.splitStringList(config.getOption(Config.LIBRARY_CLASSES));
    for (    String lib : libs) {
      appInfo.addLibrary(lib.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.IGNORE_CLASSES)) {
    String[] ignore=Config.splitStringList(config.getOption(Config.IGNORE_CLASSES));
    for (    String cls : ignore) {
      appInfo.addLibrary(cls.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (config.hasOption(Config.EXCLUDE_LIBRARIES)) {
    appInfo.setLoadLibraries(!config.getOption(Config.EXCLUDE_LIBRARIES));
  }
  if (config.hasOption(Config.LOAD_NATIVES)) {
    appInfo.setLoadNatives(config.getOption(Config.LOAD_NATIVES));
  }
  String[] roots=Config.splitStringList(config.getOption(Config.ROOTS));
  for (  String root : roots) {
    ClassInfo rootInfo=appInfo.loadClass(root.replaceAll(""String_Node_Str"",""String_Node_Str""));
    if (rootInfo == null) {
      System.out.println(""String_Node_Str"" + root + ""String_Node_Str"");
      System.exit(4);
    }
    appInfo.addRoot(rootInfo);
  }
  try {
    MethodInfo main=getMainMethod(args[0].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.setMainMethod(main);
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  for (int i=1; i < args.length; i++) {
    ClassInfo clsInfo=appInfo.loadClass(args[i].replaceAll(""String_Node_Str"",""String_Node_Str""));
    appInfo.addRoot(clsInfo);
  }
  if (loadTransitiveHull) {
    new AppLoader().loadAll();
  }
}",0.9919266855771328
186931,"public void printUsage(){
  String optionDesc;
  if (optionSyntax != null) {
    optionDesc=""String_Node_Str"" + optionSyntax;
  }
 else {
    optionDesc=""String_Node_Str"";
    if (config.getOptions().availableCommands().size() > 0) {
      optionDesc+=""String_Node_Str"";
    }
    if (handleAppInfoInit) {
      optionDesc+=""String_Node_Str"";
    }
  }
  System.out.print(""String_Node_Str"" + prgmName);
  System.out.println(optionDesc);
  System.out.println();
  if (usageDescription != null && !""String_Node_Str"".equals(usageDescription)) {
    System.out.println(usageDescription);
    System.out.println();
  }
  System.out.println(""String_Node_Str"");
  for (  Option<?> option : config.getOptions().availableOptions()) {
    System.out.println(option.toString(20));
  }
}","public void printUsage(){
  String optionDesc;
  if (optionSyntax != null) {
    optionDesc=""String_Node_Str"" + optionSyntax;
  }
 else {
    optionDesc=""String_Node_Str"";
    if (config.getOptions().availableCommands().size() > 0) {
      optionDesc+=""String_Node_Str"";
    }
    if (handleAppInfoInit) {
      optionDesc+=""String_Node_Str"";
    }
  }
  System.out.print(""String_Node_Str"" + prgmName);
  System.out.println(optionDesc);
  System.out.println();
  if (usageDescription != null && !""String_Node_Str"".equals(usageDescription)) {
    System.out.println(usageDescription);
    System.out.println();
  }
  System.out.println(""String_Node_Str"");
  for (  Option<?> option : config.getOptions().availableOptions()) {
    System.out.println(option.toString(config.getDefaultIndent()));
  }
}",0.98283534647171
186932,"/** 
 * Setup the logger. You may want to call   {@link #setupConfig(String[])} first toload commandline options.
 * @see com.jopdesign.common.logger.LogConfig#setupLogger(Config)
 */
public void setupLogger(){
  logConfig.setupLogger(config);
}","/** 
 * Setup the logger. You may want to call   {@link #setupConfig(String[])} first toload commandline options.
 * @see LogConfig#setupLogger(Config)
 */
public void setupLogger(){
  logConfig.setupLogger(config);
}",0.6277056277056277
186933,"/** 
 * Load the config file, parse and check options, and if handleApInfoInit has been set, also initialize AppInfo.
 * @param args cmdline arguments to parse
 * @param configFile filename of an optional user configuration file, will be tried to be loaded beforearguments are parsed.
 * @return arguments not consumed.
 */
public String[] setupConfig(String[] args,String configFile){
  File file=findConfigFile(configFile);
  if (file != null && file.exists()) {
    try {
      InputStream is=new BufferedInputStream(new FileInputStream(file));
      config.addProperties(is);
    }
 catch (    FileNotFoundException e) {
      System.out.println(""String_Node_Str"" + configFile + ""String_Node_Str""+ e.getMessage());
    }
catch (    IOException e) {
      System.out.println(""String_Node_Str"" + file + ""String_Node_Str""+ e.getMessage());
      System.exit(3);
    }
  }
  String[] rest=null;
  try {
    rest=config.parseArguments(args);
    config.checkOptions();
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (config.getOption(Config.SHOW_HELP) && prgmName != null) {
    printUsage();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_VERSION) && versionInfo != null) {
    printVersion();
    System.exit(0);
  }
  try {
    for (    Module module : modules.values()) {
      module.onSetupConfig(this);
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  return rest;
}","/** 
 * Load the config file, parse and check options, and if handleApInfoInit has been set, also initialize AppInfo.
 * @param args cmdline arguments to parse
 * @param configFile filename of an optional user configuration file, will be tried to be loaded beforearguments are parsed.
 * @return arguments not consumed.
 */
public String[] setupConfig(String[] args,String configFile){
  File file=findConfigFile(configFile);
  if (file != null && file.exists()) {
    try {
      InputStream is=new BufferedInputStream(new FileInputStream(file));
      config.addProperties(is);
    }
 catch (    FileNotFoundException e) {
      System.out.println(""String_Node_Str"" + configFile + ""String_Node_Str""+ e.getMessage());
    }
catch (    IOException e) {
      System.out.println(""String_Node_Str"" + file + ""String_Node_Str""+ e.getMessage());
      System.exit(3);
    }
  }
  String[] rest=null;
  try {
    rest=config.parseArguments(args);
    config.checkOptions();
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  if (config.getOption(Config.SHOW_HELP) && prgmName != null) {
    printUsage();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_VERSION) && versionInfo != null) {
    printVersion();
    System.exit(0);
  }
  if (config.getOption(Config.SHOW_CONFIG)) {
    config.printConfiguration(config.getDefaultIndent());
    System.exit(0);
  }
  try {
    for (    Module module : modules.values()) {
      module.onSetupConfig(this);
    }
  }
 catch (  Config.BadConfigurationException e) {
    System.out.println(e.getMessage());
    if (config.getOptions().containsOption(Config.SHOW_HELP)) {
      System.out.println(""String_Node_Str"");
    }
    System.exit(2);
  }
  return rest;
}",0.9649698960043788
186934,"@Override protected String getDefaultsText(){
  if (optional && !defaultValue) {
    return ""String_Node_Str"";
  }
  return super.getDefaultsText();
}","@Override protected String getDefaultsText(){
  if (optional && !defaultValue) {
    return skipChecks ? ""String_Node_Str"" : ""String_Node_Str"";
  }
  return super.getDefaultsText();
}",0.9009009009009008
186935,"/** 
 * Dump configuration of all set properties for debugging purposes. To print a list of all options with their values, use   {@link OptionGroup#dumpConfiguration(int)}.
 * @param indent indent used for keys
 * @return a dump of all options with their respective values.
 */
public String dumpConfiguration(int indent){
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<Object,Object> e : props.entrySet()) {
    sb.append(String.format(""String_Node_Str"" + indent + ""String_Node_Str"",""String_Node_Str"",e.getKey(),e.getValue() == null ? ""String_Node_Str"" : e.getValue()));
  }
  return sb.toString();
}","/** 
 * Dump configuration of all set properties for debugging purposes. To print a list of all options with their values, use   {@link #printConfiguration(int)}.
 * @see #printConfiguration(int)
 * @param indent indent used for keys
 * @return a dump of all options with their respective values.
 */
public String dumpConfiguration(int indent){
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  printConfig(new PrintStream(os),indent,new HashSet<String>());
  return os.toString();
}",0.5936651583710407
186936,"public String toString(int lAdjust){
  StringBuffer s=new StringBuffer(""String_Node_Str"");
  s.append(key);
  for (int i=s.length(); i <= lAdjust; i++) {
    s.append(' ');
  }
  s.append(' ');
  s.append(descrString());
  return s.toString();
}","public String toString(int lAdjust){
  StringBuffer s=new StringBuffer(""String_Node_Str"");
  if (shortKey != SHORT_NONE) {
    s.append('-');
    s.append(shortKey);
    s.append(""String_Node_Str"");
  }
 else {
    s.append(""String_Node_Str"");
  }
  s.append(key);
  for (int i=s.length(); i <= lAdjust; i++) {
    s.append(' ');
  }
  s.append(""String_Node_Str"");
  s.append(descrString());
  return s.toString();
}",0.7322239031770046
186937,"/** 
 * Consume all command line options and turn them into properties.<br/> <p>The arguments are processed as follows: If an argument is of the form ""-option"" or ""--option"", it is considered to be an option. If an argument is an option, the next argument is considered to be the parameter, unless the option is boolean and the next argument is missing or an option as well. We add the pair to our properties, consuming both arguments. </p><p> If an argument starts with @, the rest of it is considered as a property file name, which is then loaded and added to the configuration.  The first non-option or the argument string   {@code --} terminates the option list.</p>
 * @param args The argument list
 * @return An array of unconsumed arguments
 * @throws Config.BadConfigurationException if an argument is malformed.
 */
public String[] consumeOptions(String[] args) throws Config.BadConfigurationException {
  int i=0;
  while (i < args.length) {
    if (cmds.containsKey(args[i])) {
      config.setProperty(getConfigKey(CMD_KEY),args[i]);
      OptionGroup cmdGroup=cmds.get(args[i]);
      return cmdGroup.consumeOptions(Arrays.copyOfRange(args,i + 1,args.length));
    }
    if (args[i].startsWith(""String_Node_Str"")) {
      String filename=args[i].substring(1);
      try {
        InputStream is=new BufferedInputStream(new FileInputStream(filename));
        config.addProperties(is,prefix);
      }
 catch (      FileNotFoundException e) {
        throw new Config.BadConfigurationException(""String_Node_Str"" + filename + ""String_Node_Str"",e);
      }
catch (      IOException e) {
        throw new Config.BadConfigurationException(""String_Node_Str"" + filename + ""String_Node_Str""+ e.getMessage(),e);
      }
      i++;
      continue;
    }
    if (!args[i].startsWith(""String_Node_Str""))     break;
    if (""String_Node_Str"".equals(args[i]) || ""String_Node_Str"".equals(args[i])) {
      i++;
      break;
    }
    String key;
    if (args[i].charAt(1) == '-')     key=args[i].substring(2);
 else     key=args[i].substring(1);
    Option<?> spec=getOptionSpec(key);
    if (spec != null) {
      String val=null;
      if (i + 1 < args.length) {
        try {
          spec.parse(args[i + 1]);
          val=args[i + 1];
        }
 catch (        IllegalArgumentException ignored) {
        }
      }
      if (spec instanceof BoolOption && val == null) {
        val=""String_Node_Str"";
      }
 else       if (val == null) {
        throw new Config.BadConfigurationException(""String_Node_Str"" + spec);
      }
 else {
        i++;
      }
      config.setProperty(getConfigKey(spec),val);
    }
 else     if (spec == null) {
      if (key.startsWith(""String_Node_Str"")) {
        spec=getOptionSpec(key.substring(3));
        if (spec != null && spec instanceof BoolOption) {
          config.setProperty(getConfigKey(spec),""String_Node_Str"");
        }
      }
    }
    if (spec == null) {
      throw new Config.BadConfigurationException(""String_Node_Str"" + key + ""String_Node_Str""+ optionSet.keySet().toString()+ ""String_Node_Str"");
    }
    i++;
  }
  return Arrays.copyOfRange(args,i,args.length);
}","/** 
 * Consume all command line options and turn them into properties.<br/> <p>The arguments are processed as follows: If an argument is of the form ""-option"" or ""--option"", it is considered to be an option. If an argument is an option, the next argument is considered to be the parameter, unless the option is boolean and the next argument is missing or an option as well. We add the pair to our properties, consuming both arguments. </p><p> If an argument starts with @, the rest of it is considered as a property file name, which is then loaded and added to the configuration.  The first non-option or the argument string   {@code --} terminates the option list.</p>
 * @param args The argument list
 * @return An array of unconsumed arguments
 * @throws Config.BadConfigurationException if an argument is malformed.
 */
public String[] consumeOptions(String[] args) throws Config.BadConfigurationException {
  int i=0;
  while (i < args.length) {
    if (cmds.containsKey(args[i])) {
      config.setProperty(getConfigKey(CMD_KEY),args[i]);
      OptionGroup cmdGroup=cmds.get(args[i]);
      return cmdGroup.consumeOptions(Arrays.copyOfRange(args,i + 1,args.length));
    }
    if (args[i].startsWith(""String_Node_Str"")) {
      String filename=args[i].substring(1);
      try {
        InputStream is=new BufferedInputStream(new FileInputStream(filename));
        config.addProperties(is,prefix);
      }
 catch (      FileNotFoundException e) {
        throw new Config.BadConfigurationException(""String_Node_Str"" + filename + ""String_Node_Str"",e);
      }
catch (      IOException e) {
        throw new Config.BadConfigurationException(""String_Node_Str"" + filename + ""String_Node_Str""+ e.getMessage(),e);
      }
      i++;
      continue;
    }
    if (!args[i].startsWith(""String_Node_Str""))     break;
    if (""String_Node_Str"".equals(args[i]) || ""String_Node_Str"".equals(args[i])) {
      i++;
      break;
    }
    String key;
    if (args[i].charAt(1) == '-')     key=args[i].substring(2);
 else     key=args[i].substring(1);
    Option<?> spec=getOptionSpec(key);
    if (spec != null) {
      String val=null;
      if (i + 1 < args.length) {
        try {
          spec.parse(args[i + 1]);
          val=args[i + 1];
        }
 catch (        IllegalArgumentException ignored) {
        }
      }
      if (spec instanceof BoolOption && val == null) {
        val=""String_Node_Str"";
      }
 else       if (val == null) {
        throw new Config.BadConfigurationException(""String_Node_Str"" + spec);
      }
 else {
        i++;
      }
      config.setProperty(getConfigKey(spec),val);
    }
 else     if (spec == null) {
      if (key.startsWith(""String_Node_Str"")) {
        spec=getOptionSpec(key.substring(3));
        if (spec != null && spec instanceof BoolOption) {
          config.setProperty(getConfigKey(spec),""String_Node_Str"");
        }
      }
    }
    if (spec == null) {
      throw new Config.BadConfigurationException(""String_Node_Str"" + key);
    }
    i++;
  }
  return Arrays.copyOfRange(args,i,args.length);
}",0.9886768036234228
186938,"/** 
 * @param args File containing regex pattern to be matched.
 */
public static void main(String[] args) throws IOException {
  byte[] input;
{
    byte[] buf=new byte[1 << 20];
    int read;
    int offset=0;
    int capacity=buf.length;
    while ((read=System.in.read(buf,offset,capacity)) != -1) {
      System.out.write(buf,offset,read);
      offset+=read;
      capacity-=read;
      if (capacity == 0) {
        throw new IOException();
      }
    }
    input=new byte[offset];
    System.arraycopy(buf,0,input,0,offset);
  }
  File patternFile=new File(args[0]);
  long patternFileLen=patternFile.length();
  if (patternFileLen > Integer.MAX_VALUE) {
    throw new IOException();
  }
  byte[] pattern=new byte[(int)patternFileLen];
  new FileInputStream(patternFile).read(pattern);
  Pattern p=Pattern.compile(headerPattern + new String(pattern) + trailerPattern,Pattern.DOTALL);
  System.exit(p.matcher(new String(input)).matches() ? 0 : 2);
}","/** 
 * @param args File containing regex pattern to be matched by System.in.
 */
public static void main(String[] args) throws IOException {
  byte[] input;
{
    byte[] buf=new byte[1 << 20];
    int read;
    int offset=0;
    int capacity=buf.length;
    while ((read=System.in.read(buf,offset,capacity)) != -1) {
      System.out.write(buf,offset,read);
      offset+=read;
      capacity-=read;
      if (capacity == 0) {
        throw new IOException();
      }
    }
    input=new byte[offset];
    System.arraycopy(buf,0,input,0,offset);
  }
  File patternFile=new File(args[0]);
  long patternFileLen=patternFile.length();
  if (patternFileLen > Integer.MAX_VALUE) {
    throw new IOException();
  }
  byte[] pattern=new byte[(int)patternFileLen];
  new FileInputStream(patternFile).read(pattern);
  Pattern p=Pattern.compile(headerPattern + new String(pattern) + trailerPattern,Pattern.DOTALL);
  System.exit(p.matcher(new String(input)).matches() ? 0 : 2);
}",0.9932537623248572
186939,"/** 
 * Parse the specified <code>String</code> as a <code>double</code>. The extended BNF grammar is as follows:<br> <pre> <em>DecodableString</em>: ( [ <code>-</code> | <code>+</code> ] <code>NaN</code> ) | ( [ <code>-</code> | <code>+</code> ] <code>Infinity</code> ) | ( [ <code>-</code> | <code>+</code> ] <em>FloatingPoint</em> [ <code>f</code> | <code>F</code> | <code>d</code> | <code>D</code>] ) <em>FloatingPoint</em>: ( { <em>Digit</em> }+ [ <code>.</code> { <em>Digit</em> } ] [ <em>Exponent</em> ] ) | ( <code>.</code> { <em>Digit</em> }+ [ <em>Exponent</em> ] ) <em>Exponent</em>: ( ( <code>e</code> | <code>E</code> ) [ <code>-</code> | <code>+</code> ] { <em>Digit</em> }+ ) <em>Digit</em>: <em><code>'0'</code> through <code>'9'</code></em> </pre> <p>NaN and infinity are special cases, to allow parsing of the output of toString.  Otherwise, the result is determined by calculating <em>n * 10<sup>exponent</sup></em> to infinite precision, then rounding to the nearest double. Remember that many numbers cannot be precisely represented in floating point. In case of overflow, infinity is used, and in case of underflow, signed zero is used. Unlike Integer.parseInt, this does not accept Unicode digits outside the ASCII range. <p>If an unexpected character is found in the <code>String</code>, a <code>NumberFormatException</code> will be thrown.  Leading and trailing 'whitespace' is ignored via <code>String.trim()</code>, but spaces internal to the actual number are not allowed. <p>To parse numbers according to another format, consider using  {@link java.text.NumberFormat}.
 * @XXX specify where/how we are not in accord with the spec.
 * @param str the <code>String</code> to convert
 * @return the <code>double</code> value of <code>s</code>
 * @throws NumberFormatException if <code>s</code> cannot be parsed as a<code>double</code>
 * @throws NullPointerException if <code>s</code> is null
 * @see #MIN_VALUE
 * @see #MAX_VALUE
 * @see #POSITIVE_INFINITY
 * @see #NEGATIVE_INFINITY
 * @since 1.2
 */
public static double parseDouble(String str){
  return FloatingDecimal.readJavaFormatString(str).doubleValue();
}","/** 
 * Parse the specified <code>String</code> as a <code>double</code>. The extended BNF grammar is as follows:<br> <pre> <em>DecodableString</em>: ( [ <code>-</code> | <code>+</code> ] <code>NaN</code> ) | ( [ <code>-</code> | <code>+</code> ] <code>Infinity</code> ) | ( [ <code>-</code> | <code>+</code> ] <em>FloatingPoint</em> [ <code>f</code> | <code>F</code> | <code>d</code> | <code>D</code>] ) <em>FloatingPoint</em>: ( { <em>Digit</em> }+ [ <code>.</code> { <em>Digit</em> } ] [ <em>Exponent</em> ] ) | ( <code>.</code> { <em>Digit</em> }+ [ <em>Exponent</em> ] ) <em>Exponent</em>: ( ( <code>e</code> | <code>E</code> ) [ <code>-</code> | <code>+</code> ] { <em>Digit</em> }+ ) <em>Digit</em>: <em><code>'0'</code> through <code>'9'</code></em> </pre> <p>NaN and infinity are special cases, to allow parsing of the output of toString.  Otherwise, the result is determined by calculating <em>n * 10<sup>exponent</sup></em> to infinite precision, then rounding to the nearest double. Remember that many numbers cannot be precisely represented in floating point. In case of overflow, infinity is used, and in case of underflow, signed zero is used. Unlike Integer.parseInt, this does not accept Unicode digits outside the ASCII range. <p>If an unexpected character is found in the <code>String</code>, a <code>NumberFormatException</code> will be thrown.  Leading and trailing 'whitespace' is ignored via <code>String.trim()</code>, but spaces internal to the actual number are not allowed. <p>To parse numbers according to another format, consider using  {@link java.text.NumberFormat}.
 * @XXX specify where/how we are not in accord with the spec.
 * @param str the <code>String</code> to convert
 * @return the <code>double</code> value of <code>s</code>
 * @throws NumberFormatException if <code>s</code> cannot be parsed as a<code>double</code>
 * @throws NullPointerException if <code>s</code> is null
 * @see #MIN_VALUE
 * @see #MAX_VALUE
 * @see #POSITIVE_INFINITY
 * @see #NEGATIVE_INFINITY
 * @since 1.2
 */
public static double parseDouble(String str){
  return VMFloatingDecimal.readJavaFormatString(str).doubleValue();
}",0.99953314659197
186940,"public double doubleValue(){
  int kDigits=Math.min(nDigits,maxDecimalDigits + 1);
  long lValue;
  double dValue;
  double rValue, tValue;
  if (digits == infinity || digits == notANumber) {
    if (digits == notANumber)     return Double.NaN;
 else     return (isNegative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
  }
 else {
    if (mustSetRoundDir) {
      roundDir=0;
    }
    int iValue=(int)digits[0] - (int)'0';
    int iDigits=Math.min(kDigits,intDecimalDigits);
    for (int i=1; i < iDigits; i++) {
      iValue=iValue * 10 + (int)digits[i] - (int)'0';
    }
    lValue=(long)iValue;
    for (int i=iDigits; i < kDigits; i++) {
      lValue=lValue * 10L + (long)((int)digits[i] - (int)'0');
    }
    dValue=(double)lValue;
    int exp=decExponent - kDigits;
    if (nDigits <= maxDecimalDigits) {
      if (exp == 0 || dValue == 0.0)       return (isNegative) ? -dValue : dValue;
 else       if (exp >= 0) {
        if (exp <= maxSmallTen) {
          rValue=dValue * small10pow[exp];
          if (mustSetRoundDir) {
            tValue=rValue / small10pow[exp];
            roundDir=(tValue == dValue) ? 0 : (tValue < dValue) ? 1 : -1;
          }
          return (isNegative) ? -rValue : rValue;
        }
        int slop=maxDecimalDigits - kDigits;
        if (exp <= maxSmallTen + slop) {
          dValue*=small10pow[slop];
          rValue=dValue * small10pow[exp - slop];
          if (mustSetRoundDir) {
            tValue=rValue / small10pow[exp - slop];
            roundDir=(tValue == dValue) ? 0 : (tValue < dValue) ? 1 : -1;
          }
          return (isNegative) ? -rValue : rValue;
        }
      }
 else {
        if (exp >= -maxSmallTen) {
          rValue=dValue / small10pow[-exp];
          tValue=rValue * small10pow[-exp];
          if (mustSetRoundDir) {
            roundDir=(tValue == dValue) ? 0 : (tValue < dValue) ? 1 : -1;
          }
          return (isNegative) ? -rValue : rValue;
        }
      }
    }
    if (exp > 0) {
      if (decExponent > maxDecimalExponent + 1) {
        return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
      }
      if ((exp & 15) != 0) {
        dValue*=small10pow[exp & 15];
      }
      if ((exp>>=4) != 0) {
        int j;
        for (j=0; exp > 1; j++, exp>>=1) {
          if ((exp & 1) != 0)           dValue*=big10pow[j];
        }
        double t=dValue * big10pow[j];
        if (Double.isInfinite(t)) {
          t=dValue / 2.0;
          t*=big10pow[j];
          if (Double.isInfinite(t)) {
            return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
          }
          t=Double.MAX_VALUE;
        }
        dValue=t;
      }
    }
 else     if (exp < 0) {
      exp=-exp;
      if (decExponent < minDecimalExponent - 1) {
        return (isNegative) ? -0.0 : 0.0;
      }
      if ((exp & 15) != 0) {
        dValue/=small10pow[exp & 15];
      }
      if ((exp>>=4) != 0) {
        int j;
        for (j=0; exp > 1; j++, exp>>=1) {
          if ((exp & 1) != 0)           dValue*=tiny10pow[j];
        }
        double t=dValue * tiny10pow[j];
        if (t == 0.0) {
          t=dValue * 2.0;
          t*=tiny10pow[j];
          if (t == 0.0) {
            return (isNegative) ? -0.0 : 0.0;
          }
          t=Double.MIN_VALUE;
        }
        dValue=t;
      }
    }
    FDBigInt bigD0=new FDBigInt(lValue,digits,kDigits,nDigits);
    exp=decExponent - nDigits;
    correctionLoop:     while (true) {
      FDBigInt bigB=doubleToBigInt(dValue);
      int B2, B5;
      int D2, D5;
      int Ulp2;
      if (exp >= 0) {
        B2=B5=0;
        D2=D5=exp;
      }
 else {
        B2=B5=-exp;
        D2=D5=0;
      }
      if (bigIntExp >= 0) {
        B2+=bigIntExp;
      }
 else {
        D2-=bigIntExp;
      }
      Ulp2=B2;
      int hulpbias;
      if (bigIntExp + bigIntNBits <= -expBias + 1) {
        hulpbias=bigIntExp + expBias + expShift;
      }
 else {
        hulpbias=expShift + 2 - bigIntNBits;
      }
      B2+=hulpbias;
      D2+=hulpbias;
      int common2=Math.min(B2,Math.min(D2,Ulp2));
      B2-=common2;
      D2-=common2;
      Ulp2-=common2;
      bigB=multPow52(bigB,B5,B2);
      FDBigInt bigD=multPow52(new FDBigInt(bigD0),D5,D2);
      FDBigInt diff;
      int cmpResult;
      boolean overvalue;
      if ((cmpResult=bigB.cmp(bigD)) > 0) {
        overvalue=true;
        diff=bigB.sub(bigD);
        if ((bigIntNBits == 1) && (bigIntExp > -expBias)) {
          Ulp2-=1;
          if (Ulp2 < 0) {
            Ulp2=0;
            diff.lshiftMe(1);
          }
        }
      }
 else       if (cmpResult < 0) {
        overvalue=false;
        diff=bigD.sub(bigB);
      }
 else {
        break correctionLoop;
      }
      FDBigInt halfUlp=constructPow52(B5,Ulp2);
      if ((cmpResult=diff.cmp(halfUlp)) < 0) {
        if (mustSetRoundDir) {
          roundDir=overvalue ? -1 : 1;
        }
        break correctionLoop;
      }
 else       if (cmpResult == 0) {
        dValue+=0.5 * ulp(dValue,overvalue);
        if (mustSetRoundDir) {
          roundDir=overvalue ? -1 : 1;
        }
        break correctionLoop;
      }
 else {
        dValue+=ulp(dValue,overvalue);
        if (dValue == 0.0 || dValue == Double.POSITIVE_INFINITY)         break correctionLoop;
        continue;
      }
    }
    return (isNegative) ? -dValue : dValue;
  }
}","public double doubleValue(){
  int kDigits=Math.min(nDigits,maxDecimalDigits + 1);
  long lValue;
  double dValue;
  double rValue, tValue;
  if (digits == infinity || digits == notANumber) {
    if (digits == notANumber)     return Double.NaN;
 else     return (isNegative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
  }
 else {
    if (mustSetRoundDir) {
      roundDir=0;
    }
    int iValue=(int)digits[0] - (int)'0';
    int iDigits=Math.min(kDigits,intDecimalDigits);
    for (int i=1; i < iDigits; i++) {
      iValue=iValue * 10 + (int)digits[i] - (int)'0';
    }
    lValue=(long)iValue;
    for (int i=iDigits; i < kDigits; i++) {
      lValue=lValue * 10L + (long)((int)digits[i] - (int)'0');
    }
    dValue=(double)lValue;
    int exp=decExponent - kDigits;
    if (nDigits <= maxDecimalDigits) {
      if (exp == 0 || dValue == 0.0)       return (isNegative) ? -dValue : dValue;
 else       if (exp >= 0) {
        if (exp <= maxSmallTen) {
          rValue=dValue * small10pow[exp];
          if (mustSetRoundDir) {
            tValue=rValue / small10pow[exp];
            roundDir=(tValue == dValue) ? 0 : (tValue < dValue) ? 1 : -1;
          }
          return (isNegative) ? -rValue : rValue;
        }
        int slop=maxDecimalDigits - kDigits;
        if (exp <= maxSmallTen + slop) {
          dValue*=small10pow[slop];
          rValue=dValue * small10pow[exp - slop];
          if (mustSetRoundDir) {
            tValue=rValue / small10pow[exp - slop];
            roundDir=(tValue == dValue) ? 0 : (tValue < dValue) ? 1 : -1;
          }
          return (isNegative) ? -rValue : rValue;
        }
      }
 else {
        if (exp >= -maxSmallTen) {
          rValue=dValue / small10pow[-exp];
          tValue=rValue * small10pow[-exp];
          if (mustSetRoundDir) {
            roundDir=(tValue == dValue) ? 0 : (tValue < dValue) ? 1 : -1;
          }
          return (isNegative) ? -rValue : rValue;
        }
      }
    }
    if (exp > 0) {
      if (decExponent > maxDecimalExponent + 1) {
        return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
      }
      if ((exp & 15) != 0) {
        dValue*=small10pow[exp & 15];
      }
      if ((exp>>=4) != 0) {
        int j;
        for (j=0; exp > 1; j++, exp>>=1) {
          if ((exp & 1) != 0)           dValue*=big10pow[j];
        }
        double t=dValue * big10pow[j];
        if (Double.isInfinite(t)) {
          t=dValue / 2.0;
          t*=big10pow[j];
          if (Double.isInfinite(t)) {
            return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
          }
          t=Double.MAX_VALUE;
        }
        dValue=t;
      }
    }
 else     if (exp < 0) {
      exp=-exp;
      if (decExponent < minDecimalExponent - 1) {
        return (isNegative) ? -0.0 : 0.0;
      }
      if ((exp & 15) != 0) {
        dValue/=small10pow[exp & 15];
      }
      if ((exp>>=4) != 0) {
        int j;
        for (j=0; exp > 1; j++, exp>>=1) {
          if ((exp & 1) != 0)           dValue*=tiny10pow[j];
        }
        double t=dValue * tiny10pow[j];
        if (t == 0.0) {
          t=dValue * 2.0;
          t*=tiny10pow[j];
          if (t == 0.0) {
            return (isNegative) ? -0.0 : 0.0;
          }
          t=Double.MIN_VALUE;
        }
        dValue=t;
      }
    }
    dValue=correctionLoop(kDigits,lValue,dValue);
    return (isNegative) ? -dValue : dValue;
  }
}",0.7631698455949137
186941,"public static FloatingDecimal readJavaFormatString(String in) throws NumberFormatException {
  boolean isNegative=false;
  boolean signSeen=false;
  int decExp;
  char c;
  parseNumber:   try {
    in=in.trim();
    int l=in.length();
    if (l == 0)     throw new NumberFormatException(""String_Node_Str"");
    int i=0;
switch (c=in.charAt(i)) {
case '-':
      isNegative=true;
case '+':
    i++;
  signSeen=true;
}
c=in.charAt(i);
if (c == 'N' || c == 'I') {
boolean potentialNaN=false;
char targetChars[]=null;
if (c == 'N') {
  targetChars=notANumber;
  potentialNaN=true;
}
 else {
  targetChars=infinity;
}
int j=0;
while (i < l && j < targetChars.length) {
  if (in.charAt(i) == targetChars[j]) {
    i++;
    j++;
  }
 else   break parseNumber;
}
if ((j == targetChars.length) && (i == l)) {
  return (potentialNaN ? new FloatingDecimal(false,0,notANumber,notANumber.length,true) : new FloatingDecimal(isNegative,0,infinity,notANumber.length,true));
}
 else {
  break parseNumber;
}
}
 else if (c == '0') {
if (l > i + 1) {
  char ch=in.charAt(i + 1);
  if (ch == 'x' || ch == 'X')   throw new NumberFormatException(""String_Node_Str"");
}
}
char[] digits=new char[l];
int nDigits=0;
boolean decSeen=false;
int decPt=0;
int nLeadZero=0;
int nTrailZero=0;
digitLoop: while (i < l) {
switch (c=in.charAt(i)) {
case '0':
  if (nDigits > 0) {
    nTrailZero+=1;
  }
 else {
    nLeadZero+=1;
  }
break;
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
while (nTrailZero > 0) {
digits[nDigits++]='0';
nTrailZero-=1;
}
digits[nDigits++]=c;
break;
case '.':
if (decSeen) {
throw new NumberFormatException(""String_Node_Str"");
}
decPt=i;
if (signSeen) {
decPt-=1;
}
decSeen=true;
break;
default :
break digitLoop;
}
i++;
}
if (nDigits == 0) {
digits=zero;
nDigits=1;
if (nLeadZero == 0) {
break parseNumber;
}
}
if (decSeen) {
decExp=decPt - nLeadZero;
}
 else {
decExp=nDigits + nTrailZero;
}
if ((i < l) && (((c=in.charAt(i)) == 'e') || (c == 'E'))) {
int expSign=1;
int expVal=0;
int reallyBig=Integer.MAX_VALUE / 10;
boolean expOverflow=false;
switch (in.charAt(++i)) {
case '-':
expSign=-1;
case '+':
i++;
}
int expAt=i;
expLoop: while (i < l) {
if (expVal >= reallyBig) {
expOverflow=true;
}
switch (c=in.charAt(i++)) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
expVal=expVal * 10 + ((int)c - (int)'0');
continue;
default :
i--;
break expLoop;
}
}
int expLimit=bigDecimalExponent + nDigits + nTrailZero;
if (expOverflow || (expVal > expLimit)) {
decExp=expSign * expLimit;
}
 else {
decExp=decExp + expSign * expVal;
}
if (i == expAt) break parseNumber;
}
if (i < l && ((i != l - 1) || (in.charAt(i) != 'f' && in.charAt(i) != 'F' && in.charAt(i) != 'd' && in.charAt(i) != 'D'))) {
break parseNumber;
}
return new FloatingDecimal(isNegative,decExp,digits,nDigits,false);
}
 catch (StringIndexOutOfBoundsException e) {
}
throw new NumberFormatException(""String_Node_Str"" + in + ""String_Node_Str"");
}","public static VMFloatingDecimal readJavaFormatString(String in) throws NumberFormatException {
  boolean isNegative=false;
  boolean signSeen=false;
  int decExp;
  char c;
  parseNumber:   try {
    in=in.trim();
    int l=in.length();
    if (l == 0)     throw new NumberFormatException(""String_Node_Str"");
    int i=0;
switch (c=in.charAt(i)) {
case '-':
      isNegative=true;
case '+':
    i++;
  signSeen=true;
}
c=in.charAt(i);
if (c == 'N' || c == 'I') {
boolean potentialNaN=false;
char targetChars[]=null;
if (c == 'N') {
  targetChars=notANumber;
  potentialNaN=true;
}
 else {
  targetChars=infinity;
}
int j=0;
while (i < l && j < targetChars.length) {
  if (in.charAt(i) == targetChars[j]) {
    i++;
    j++;
  }
 else   break parseNumber;
}
if ((j == targetChars.length) && (i == l)) {
  return (potentialNaN ? new VMFloatingDecimal(false,0,notANumber,notANumber.length,true) : new VMFloatingDecimal(isNegative,0,infinity,notANumber.length,true));
}
 else {
  break parseNumber;
}
}
 else if (c == '0') {
if (l > i + 1) {
  char ch=in.charAt(i + 1);
  if (ch == 'x' || ch == 'X')   throw new NumberFormatException(""String_Node_Str"");
}
}
char[] digits=new char[l];
int nDigits=0;
boolean decSeen=false;
int decPt=0;
int nLeadZero=0;
int nTrailZero=0;
digitLoop: while (i < l) {
switch (c=in.charAt(i)) {
case '0':
  if (nDigits > 0) {
    nTrailZero+=1;
  }
 else {
    nLeadZero+=1;
  }
break;
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
while (nTrailZero > 0) {
digits[nDigits++]='0';
nTrailZero-=1;
}
digits[nDigits++]=c;
break;
case '.':
if (decSeen) {
throw new NumberFormatException(""String_Node_Str"");
}
decPt=i;
if (signSeen) {
decPt-=1;
}
decSeen=true;
break;
default :
break digitLoop;
}
i++;
}
if (nDigits == 0) {
digits=zero;
nDigits=1;
if (nLeadZero == 0) {
break parseNumber;
}
}
if (decSeen) {
decExp=decPt - nLeadZero;
}
 else {
decExp=nDigits + nTrailZero;
}
if ((i < l) && (((c=in.charAt(i)) == 'e') || (c == 'E'))) {
int expSign=1;
int expVal=0;
int reallyBig=Integer.MAX_VALUE / 10;
boolean expOverflow=false;
switch (in.charAt(++i)) {
case '-':
expSign=-1;
case '+':
i++;
}
int expAt=i;
expLoop: while (i < l) {
if (expVal >= reallyBig) {
expOverflow=true;
}
switch (c=in.charAt(i++)) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
expVal=expVal * 10 + ((int)c - (int)'0');
continue;
default :
i--;
break expLoop;
}
}
int expLimit=bigDecimalExponent + nDigits + nTrailZero;
if (expOverflow || (expVal > expLimit)) {
decExp=expSign * expLimit;
}
 else {
decExp=decExp + expSign * expVal;
}
if (i == expAt) break parseNumber;
}
if (i < l && ((i != l - 1) || (in.charAt(i) != 'f' && in.charAt(i) != 'F' && in.charAt(i) != 'd' && in.charAt(i) != 'D'))) {
break parseNumber;
}
return new VMFloatingDecimal(isNegative,decExp,digits,nDigits,false);
}
 catch (StringIndexOutOfBoundsException e) {
}
throw new NumberFormatException(""String_Node_Str"" + in + ""String_Node_Str"");
}",0.9986679986679988
186942,"/** 
 * Analyze the number of references used in each scope. For the general technique, see   {@link com.jopdesign.wcet.analysis.cache.MethodCacheAnalysis#analyzeBlockUsage()}<h2>Bytecodes using object references</h2> <ul> <li/> getfield (top of stack) <li/> putfield (second on stack) <li/> arraylen (top of stack) <li/> a*load (second on stack) <li/> a*store (third on stack) </ul> <h2>Reference Analysis</h2> For each scope, we do the following: <ol> <li/> Perform a local, symbolic points-to analysis <li/> Traverse all instructions, and collect for each reference the basic blocks it might be used in. Additionally, the cost of each basic block is set to the number of TOP references accessed. <li/> For each reference, add a decision variable denoting whether it is used at all, and add corresponding constraints. </ol>
 */
public void analyzeRefUsage(){
  usedReferences=new HashMap<CallGraphNode,Long>();
  CallString emptyCallString=new CallString();
  TopologicalOrderIterator<CallGraphNode,DefaultEdge> iter=project.getCallGraph().topDownIterator();
  while (iter.hasNext()) {
    try {
      CallGraphNode scope=iter.next();
      System.out.println(""String_Node_Str"" + scope.getMethodImpl().getFQMethodName());
      DFAAppInfo dfa=project.getDfaProgram();
      SymbolicPointsTo spt=new SymbolicPointsTo(MAX_SET_SIZE);
      dfa.runLocalAnalysis(spt,scope.getMethodImpl().getFQMethodName());
      HashMap<InstructionHandle,ContextMap<CallString,BoundedSet<SymbolicAddress>>> usedRefs=spt.getResult();
      SuperGraph sg=getScopeSuperGraph(scope);
      String key=""String_Node_Str"" + scope.toString();
      ILPModelBuilder imb=new ILPModelBuilder(new IpetConfig(project.getConfig()));
      Map<CFGNode,Long> costMap=new HashMap<CFGNode,Long>();
      HashMap<SymbolicAddress,Map<CFGNode,Integer>> accessSets=new HashMap<SymbolicAddress,Map<CFGNode,Integer>>();
      for (      CFGNode n : sg.vertexSet()) {
        BasicBlock bb=n.getBasicBlock();
        long topCost=0;
        if (bb == null)         continue;
        InstructionHandle ih=bb.getFirstInstruction();
        while (ih.getNext() != null) {
          BoundedSet<SymbolicAddress> refs;
          if (usedRefs.containsKey(ih)) {
            refs=usedRefs.get(ih).get(emptyCallString);
            if (refs.isSaturated() || countNonDistinct) {
              topCost+=1;
            }
 else {
              for (              SymbolicAddress ref : refs.getSet()) {
                addAccessSite(accessSets,ref,n);
              }
            }
          }
          ih=ih.getNext();
        }
        costMap.put(n,topCost);
      }
      MaxCostFlow<CFGNode,CFGEdge> maxCostFlow=imb.buildGlobalILPModel(key,sg,new MapCostProvider<CFGNode>(costMap,0));
      for (      Entry<SymbolicAddress,Map<CFGNode,Integer>> accessEntry : accessSets.entrySet()) {
        SymbolicAddress ref=accessEntry.getKey();
        Map<CFGNode,Integer> accessSet=accessEntry.getValue();
        DecisionVariable dvar=maxCostFlow.createDecisionVariable();
        decisionVariables.put(dvar,ref);
        maxCostFlow.addDecisionCost(dvar,1);
        LinearVector<CFGEdge> ub=new LinearVector<CFGEdge>();
        for (        Entry<CFGNode,Integer> entry : accessSet.entrySet()) {
          CFGNode node=entry.getKey();
          for (          CFGEdge edge : sg.incomingEdgesOf(node)) {
            ub.add(edge,1);
          }
        }
        maxCostFlow.addDecisionUpperBound(dvar,ub);
      }
      Map<CFGEdge,Long> flowMap=new HashMap<CFGEdge,Long>();
      Map<DecisionVariable,Boolean> cacheMissMap=new HashMap<DecisionVariable,Boolean>();
      double lpCost;
      try {
        lpCost=maxCostFlow.solve(flowMap,cacheMissMap);
      }
 catch (      Exception e) {
        throw new AssertionError(""String_Node_Str"" + scope);
      }
      long accessedReferences=(long)(lpCost + 0.5);
      this.usedReferences.put(scope,accessedReferences);
    }
 catch (    NullPointerException nullex) {
      nullex.printStackTrace();
    }
  }
}","/** 
 * Analyze the number of references used in each scope. For the general technique, see   {@link com.jopdesign.wcet.analysis.cache.MethodCacheAnalysis#analyzeBlockUsage()}<h2>Bytecodes using object references</h2> <ul> <li/> getfield (top of stack) <li/> putfield (second on stack) <li/> arraylen (top of stack) <li/> a*load (second on stack) <li/> a*store (third on stack) </ul> <h2>Reference Analysis</h2> For each scope, we do the following: <ol> <li/> Perform a local, symbolic points-to analysis <li/> Traverse all instructions, and collect for each reference the basic blocks it might be used in. Additionally, the cost of each basic block is set to the number of TOP references accessed. <li/> For each reference, add a decision variable denoting whether it is used at all, and add corresponding constraints. </ol>
 */
public void analyzeRefUsage(){
  usedReferences=new HashMap<CallGraphNode,Long>();
  CallString emptyCallString=new CallString();
  TopologicalOrderIterator<CallGraphNode,DefaultEdge> iter=project.getCallGraph().topDownIterator();
  while (iter.hasNext()) {
    CallGraphNode scope=iter.next();
    System.out.println(""String_Node_Str"" + scope.getMethodImpl().getFQMethodName());
    DFAAppInfo dfa=project.getDfaProgram();
    SymbolicPointsTo spt=new SymbolicPointsTo(MAX_SET_SIZE);
    dfa.runLocalAnalysis(spt,scope.getMethodImpl().getFQMethodName());
    HashMap<InstructionHandle,ContextMap<CallString,BoundedSet<SymbolicAddress>>> usedRefs=spt.getResult();
    SuperGraph sg=getScopeSuperGraph(scope);
    String key=""String_Node_Str"" + scope.toString();
    ILPModelBuilder imb=new ILPModelBuilder(new IpetConfig(project.getConfig()));
    Map<CFGNode,Long> costMap=new HashMap<CFGNode,Long>();
    HashMap<SymbolicAddress,Map<CFGNode,Integer>> accessSets=new HashMap<SymbolicAddress,Map<CFGNode,Integer>>();
    for (    CFGNode n : sg.vertexSet()) {
      BasicBlock bb=n.getBasicBlock();
      long topCost=0;
      if (bb == null)       continue;
      InstructionHandle ih=bb.getFirstInstruction();
      while (ih.getNext() != null) {
        BoundedSet<SymbolicAddress> refs;
        if (usedRefs.containsKey(ih)) {
          refs=usedRefs.get(ih).get(emptyCallString);
          if (refs.isSaturated() || countNonDistinct) {
            topCost+=1;
          }
 else {
            for (            SymbolicAddress ref : refs.getSet()) {
              addAccessSite(accessSets,ref,n);
            }
          }
        }
        ih=ih.getNext();
      }
      costMap.put(n,topCost);
    }
    MaxCostFlow<CFGNode,CFGEdge> maxCostFlow=imb.buildGlobalILPModel(key,sg,new MapCostProvider<CFGNode>(costMap,0));
    for (    Entry<SymbolicAddress,Map<CFGNode,Integer>> accessEntry : accessSets.entrySet()) {
      SymbolicAddress ref=accessEntry.getKey();
      Map<CFGNode,Integer> accessSet=accessEntry.getValue();
      DecisionVariable dvar=maxCostFlow.createDecisionVariable();
      decisionVariables.put(dvar,ref);
      maxCostFlow.addDecisionCost(dvar,1);
      LinearVector<CFGEdge> ub=new LinearVector<CFGEdge>();
      for (      Entry<CFGNode,Integer> entry : accessSet.entrySet()) {
        CFGNode node=entry.getKey();
        for (        CFGEdge edge : sg.incomingEdgesOf(node)) {
          ub.add(edge,1);
        }
      }
      maxCostFlow.addDecisionUpperBound(dvar,ub);
    }
    Map<CFGEdge,Long> flowMap=new HashMap<CFGEdge,Long>();
    Map<DecisionVariable,Boolean> cacheMissMap=new HashMap<DecisionVariable,Boolean>();
    double lpCost;
    try {
      lpCost=maxCostFlow.solve(flowMap,cacheMissMap);
    }
 catch (    Exception e) {
      throw new AssertionError(""String_Node_Str"" + scope);
    }
    long accessedReferences=(long)(lpCost + 0.5);
    this.usedReferences.put(scope,accessedReferences);
  }
}",0.957974553399306
186943,"private List<MethodInfo> dfaReceivers(InstructionHandle ih,List<MethodInfo> staticImpls){
  if (this.receiverAnalysis != null && receiverAnalysis.containsKey(ih)) {
    ContextMap<String,String> receivers=receiverAnalysis.get(ih);
    List<MethodInfo> dynImpls=new Vector<MethodInfo>();
    Set<String> dynReceivers=receivers.keySet();
    for (    MethodInfo impl : staticImpls) {
      if (dynReceivers.contains(impl.getFQMethodName())) {
        dynReceivers.remove(impl.getFQMethodName());
        dynImpls.add(impl);
      }
 else {
        logger.info(""String_Node_Str"" + impl);
      }
    }
    if (!dynReceivers.isEmpty()) {
      throw new AssertionError(""String_Node_Str"" + dynReceivers);
    }
    return dynImpls;
  }
 else {
    return staticImpls;
  }
}","private List<MethodInfo> dfaReceivers(InstructionHandle ih,List<MethodInfo> staticImpls){
  if (this.receiverAnalysis != null && receiverAnalysis.containsKey(ih)) {
    ContextMap<String,String> receivers=receiverAnalysis.get(ih);
    List<MethodInfo> dynImpls=new Vector<MethodInfo>();
    Set<String> dynReceivers=new HashSet<String>(receivers.keySet());
    for (    MethodInfo impl : staticImpls) {
      if (dynReceivers.contains(impl.getFQMethodName())) {
        dynReceivers.remove(impl.getFQMethodName());
        dynImpls.add(impl);
      }
 else {
        logger.info(""String_Node_Str"" + impl);
      }
    }
    if (!dynReceivers.isEmpty()) {
      throw new AssertionError(""String_Node_Str"" + dynReceivers);
    }
    return dynImpls;
  }
 else {
    return staticImpls;
  }
}",0.9865125240847784
186944,"public void add(V el){
  setImpl.add(el);
  if (setImpl.size() >= limit) {
    this.isSaturated=true;
    this.setImpl=null;
  }
}","public void add(V el){
  if (this.isSaturated())   return;
  setImpl.add(el);
  if (setImpl.size() > limit) {
    setTop();
  }
}",0.6872586872586872
186945,"public int getSize(){
  if (isSaturated)   return limit;
 else   return setImpl.size();
}","public int getSize(){
  if (isSaturated)   return limit + 1;
 else   return setImpl.size();
}",0.978021978021978
186946,"public void addAll(BoundedSet<V> other){
  setImpl.addAll(other.getSet());
  if (setImpl.size() >= limit) {
    this.isSaturated=true;
    this.setImpl=null;
  }
}","public void addAll(BoundedSet<V> other){
  if (this.isSaturated())   return;
  if (other.isSaturated()) {
    setTop();
    return;
  }
  setImpl.addAll(other.getSet());
  if (setImpl.size() > limit) {
    setTop();
  }
}",0.6145833333333334
186947,"public BoundedSet<V> join(BoundedSet<V> other){
  if (this.isSaturated())   return this;
 else   if (other.isSaturated())   return other;
  HashSet<V> joinedSet=new HashSet<V>();
  joinedSet.addAll(this.getSet());
  if (other != null)   joinedSet.addAll(other.getSet());
  BoundedSetImpl r=new BoundedSetImpl(joinedSet);
  System.out.println(String.format(""String_Node_Str"",this,other,r));
  return r;
}","public BoundedSet<V> join(BoundedSet<V> other){
  if (this.isSaturated())   return this;
 else   if (other != null && other.isSaturated())   return other;
  HashSet<V> joinedSet=new HashSet<V>();
  joinedSet.addAll(this.getSet());
  if (other != null)   joinedSet.addAll(other.getSet());
  BoundedSetImpl r=new BoundedSetImpl(joinedSet);
  return r;
}",0.8859416445623343
186948,"private void doInvokeVirtual(String methodName,String receiver,InstructionHandle stmt,Context context,ContextMap<TypeMapping,TypeMapping> input,Interpreter<TypeMapping,TypeMapping> interpreter,Map<InstructionHandle,ContextMap<TypeMapping,TypeMapping>> state,ContextMap<TypeMapping,TypeMapping> result){
  DFAAppInfo p=interpreter.getProgram();
  if (p.getMethod(methodName) == null) {
    System.out.println(context.method + ""String_Node_Str"" + stmt+ ""String_Node_Str""+ methodName);
    return;
  }
  MethodGen method=p.getMethod(methodName).getMethodGen();
  String signature=method.getName() + method.getSignature();
  methodName=method.getClassName() + ""String_Node_Str"" + signature;
  recordReceiver(stmt,context,methodName);
  int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
  Context c=new Context(context);
  c.stackPtr=method.getMaxLocals();
  c.constPool=method.getConstantPool();
  if (method.isSynchronized()) {
    c.syncLevel=context.syncLevel + 1;
  }
  c.method=methodName;
  boolean threaded=false;
  try {
    if (p.cliMap.get(receiver).clazz.instanceOf(p.cliMap.get(""String_Node_Str"").clazz) && signature.equals(""String_Node_Str"")) {
      c.createThread();
      threaded=true;
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    throw new Error();
  }
  ContextMap<TypeMapping,TypeMapping> tmpresult=new ContextMap<TypeMapping,TypeMapping>(c,new HashMap<TypeMapping,TypeMapping>());
  for (Iterator<TypeMapping> k=input.keySet().iterator(); k.hasNext(); ) {
    TypeMapping m=k.next();
    if (m.stackLoc < 0) {
      tmpresult.add(m);
    }
    if (m.stackLoc > varPtr) {
      tmpresult.add(new TypeMapping(m.stackLoc - varPtr,m.type));
    }
    if (m.stackLoc == varPtr) {
      if (receiver.equals(m.type.split(""String_Node_Str"")[0])) {
        tmpresult.add(new TypeMapping(0,m.type));
      }
    }
  }
  InstructionHandle entry=method.getInstructionList().getStart();
  state.put(entry,join(tmpresult,state.get(entry)));
  Map<InstructionHandle,ContextMap<TypeMapping,TypeMapping>> r=interpreter.interpret(c,entry,state,false);
  InstructionHandle exit=method.getInstructionList().getEnd();
  if (r.get(exit) != null) {
    filterReturnSet(r.get(exit),result,varPtr);
  }
  if (threaded) {
    threads.put(methodName,new ContextMap<TypeMapping,TypeMapping>(c,result));
    updateThreads(result,interpreter,state);
  }
}","private void doInvokeVirtual(String methodName,String receiver,InstructionHandle stmt,Context context,ContextMap<TypeMapping,TypeMapping> input,Interpreter<TypeMapping,TypeMapping> interpreter,Map<InstructionHandle,ContextMap<TypeMapping,TypeMapping>> state,ContextMap<TypeMapping,TypeMapping> result){
  DFAAppInfo p=interpreter.getProgram();
  if (p.getMethod(methodName) == null) {
    System.out.println(context.method + ""String_Node_Str"" + stmt+ ""String_Node_Str""+ methodName);
    return;
  }
  MethodGen method=p.getMethod(methodName).getMethodGen();
  String signature=method.getName() + method.getSignature();
  methodName=method.getClassName() + ""String_Node_Str"" + signature;
  recordReceiver(stmt,context,methodName);
  int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
  Context c=new Context(context);
  c.stackPtr=method.getMaxLocals();
  c.constPool=method.getConstantPool();
  if (method.isSynchronized()) {
    c.syncLevel=context.syncLevel + 1;
  }
  c.method=methodName;
  boolean threaded=false;
  try {
    if (p.cliMap.get(receiver).clazz.instanceOf(p.cliMap.get(""String_Node_Str"").clazz) && signature.equals(""String_Node_Str"")) {
      c.createThread();
      threaded=true;
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    throw new Error();
  }
  ContextMap<TypeMapping,TypeMapping> tmpresult=new ContextMap<TypeMapping,TypeMapping>(c,new HashMap<TypeMapping,TypeMapping>());
  for (Iterator<TypeMapping> k=input.keySet().iterator(); k.hasNext(); ) {
    TypeMapping m=k.next();
    if (m.stackLoc < 0) {
      tmpresult.add(m);
    }
    if (m.stackLoc > varPtr) {
      tmpresult.add(new TypeMapping(m.stackLoc - varPtr,m.type));
    }
    if (m.stackLoc == varPtr) {
      ClassInfo staticClass=(ClassInfo)p.cliMap.get(receiver);
      ClassInfo dynamicClass=(ClassInfo)p.cliMap.get(m.type.split(""String_Node_Str"")[0]);
      try {
        if (dynamicClass.clazz.instanceOf(staticClass.clazz)) {
          tmpresult.add(new TypeMapping(0,m.type));
        }
      }
 catch (      ClassNotFoundException exc) {
        tmpresult.add(new TypeMapping(0,m.type));
      }
    }
  }
  InstructionHandle entry=method.getInstructionList().getStart();
  state.put(entry,join(tmpresult,state.get(entry)));
  Map<InstructionHandle,ContextMap<TypeMapping,TypeMapping>> r=interpreter.interpret(c,entry,state,false);
  InstructionHandle exit=method.getInstructionList().getEnd();
  if (r.get(exit) != null) {
    filterReturnSet(r.get(exit),result,varPtr);
  }
  if (threaded) {
    threads.put(methodName,new ContextMap<TypeMapping,TypeMapping>(c,result));
    updateThreads(result,interpreter,state);
  }
}",0.9414093428345208
186949,"public ContextMap<CallString,SymbolicAddressMap> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state){
  Context context=new Context(input.getContext());
  SymbolicAddressMap in=input.get(context.callString);
  ContextMap<CallString,SymbolicAddressMap> retval=new ContextMap<CallString,SymbolicAddressMap>(context,input);
  Instruction instruction=stmt.getInstruction();
  int newStackPtr=context.stackPtr + instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      retval.put(context.callString,in.cloneFilterStack(newStackPtr));
    }
  break;
case Constants.ACONST_NULL:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LDC:
case Constants.LDC_W:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.LDC2_W:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(instr.getIndex(),in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(instr.getIndex()));
retval.put(context.callString,result);
}
break;
case Constants.ARRAYLENGTH:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.TOP);
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
objects.put(stmt,input);
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> objectMapping=in.getStack(context.stackPtr - 1);
BoundedSet<SymbolicAddress> newMapping;
if (objectMapping == bsFactory.top()) {
newMapping=bsFactory.top();
}
 else {
newMapping=bsFactory.empty();
for (SymbolicAddress addr : objectMapping.getSet()) {
newMapping.add(addr.access(instr.getFieldName(context.constPool)));
}
}
result.putStack(context.stackPtr - 1,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.TOP);
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> newMapping=bsFactory.empty();
newMapping.add(SymbolicAddress.staticField(instr.getFieldName(context.constPool)));
result.putStack(context.stackPtr,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AASTORE:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AALOAD:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.DUP:
{
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP_X1:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr - 2);
result.putStack(context.stackPtr - 2,in.getStack(context.stackPtr - 1));
result.putStack(context.stackPtr - 1,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP2:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr + 1,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.POP:
case Constants.POP2:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IINC:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IADD:
case Constants.ISUB:
case Constants.INEG:
case Constants.IUSHR:
case Constants.ISHR:
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.MONITORENTER:
retval.put(context.callString,SymbolicAddressMap.TOP);
break;
case Constants.MONITOREXIT:
retval.put(context.callString,SymbolicAddressMap.TOP);
break;
case Constants.CHECKCAST:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INSTANCEOF:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.NEW:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.NEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.ANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.MULTIANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.GOTO:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
String errMsg=context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"";
throw new AssertionError(errMsg);
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
{
SymbolicAddressMap result=in.cloneFilterStack(0);
result.putStack(0,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
objects.put(stmt,retval);
}
break;
case Constants.RETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IRETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
default :
System.err.println(""String_Node_Str"" + stmt);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
}
if (DEBUG_PRINT) {
System.out.println(""String_Node_Str"" + context + ""String_Node_Str""+ stmt);
System.out.println(""String_Node_Str"" + context.stackPtr + ""String_Node_Str""+ newStackPtr);
retval.get(context.callString).print(System.out,4);
}
context.stackPtr=newStackPtr;
return retval;
}","public ContextMap<CallString,SymbolicAddressMap> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state){
  Context context=new Context(input.getContext());
  SymbolicAddressMap in=input.get(context.callString);
  ContextMap<CallString,SymbolicAddressMap> retval=new ContextMap<CallString,SymbolicAddressMap>(context,input);
  Instruction instruction=stmt.getInstruction();
  int newStackPtr=context.stackPtr + instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      retval.put(context.callString,in.cloneFilterStack(newStackPtr));
    }
  break;
case Constants.ACONST_NULL:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LDC:
case Constants.LDC_W:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.LDC2_W:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(instr.getIndex(),in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(instr.getIndex()));
retval.put(context.callString,result);
}
break;
case Constants.ARRAYLENGTH:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.TOP);
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
objects.put(stmt,input);
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> objectMapping=in.getStack(context.stackPtr - 1);
BoundedSet<SymbolicAddress> newMapping;
if (objectMapping.isSaturated()) {
newMapping=bsFactory.top();
}
 else {
newMapping=bsFactory.empty();
for (SymbolicAddress addr : objectMapping.getSet()) {
newMapping.add(addr.access(instr.getFieldName(context.constPool)));
}
}
result.putStack(context.stackPtr - 1,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.TOP);
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> newMapping=bsFactory.empty();
newMapping.add(SymbolicAddress.staticField(instr.getFieldName(context.constPool)));
result.putStack(context.stackPtr,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AASTORE:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AALOAD:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.DUP:
{
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP_X1:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr - 2);
result.putStack(context.stackPtr - 2,in.getStack(context.stackPtr - 1));
result.putStack(context.stackPtr - 1,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP2:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr + 1,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.POP:
case Constants.POP2:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IINC:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IADD:
case Constants.ISUB:
case Constants.INEG:
case Constants.IUSHR:
case Constants.ISHR:
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.MONITORENTER:
retval.put(context.callString,SymbolicAddressMap.TOP);
break;
case Constants.MONITOREXIT:
retval.put(context.callString,SymbolicAddressMap.TOP);
break;
case Constants.CHECKCAST:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INSTANCEOF:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.NEW:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.NEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.ANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.MULTIANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.GOTO:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
String errMsg=context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"";
throw new AssertionError(errMsg);
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
{
SymbolicAddressMap result=in.cloneFilterStack(0);
result.putStack(0,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
objects.put(stmt,retval);
}
break;
case Constants.RETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IRETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
default :
System.err.println(""String_Node_Str"" + stmt);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
}
if (DEBUG_PRINT) {
System.out.println(""String_Node_Str"" + context + ""String_Node_Str""+ stmt);
System.out.println(""String_Node_Str"" + context.stackPtr + ""String_Node_Str""+ newStackPtr);
System.out.println(""String_Node_Str"");
input.get(context.callString).print(System.out,4);
System.out.println(""String_Node_Str"");
retval.get(context.callString).print(System.out,4);
}
context.stackPtr=newStackPtr;
return retval;
}",0.9910176476804397
186950,"public boolean isSubset(BoundedSet<V> otherEntry){
  if (otherEntry.isTop())   return true;
 else   if (this.isTop())   return false;
  return otherEntry.getSet().containsAll(this.getSet());
}","public boolean isSubset(BoundedSet<V> otherEntry){
  if (otherEntry.isSaturated())   return true;
 else   if (this.isSaturated())   return false;
  return otherEntry.getSet().containsAll(this.getSet());
}",0.9393939393939394
186951,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  BoundedSetImpl other=(BoundedSetImpl)obj;
  if (this.getSize() != other.getSize())   return false;
  if (this.isSaturated)   return other.isSaturated;
 else   return setImpl.equals(other.setImpl);
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  BoundedSetImpl other=(BoundedSetImpl)obj;
  if (this.isSaturated)   return other.isSaturated;
  if (this.getSize() != other.getSize())   return false;
 else   return setImpl.equals(other.setImpl);
}",0.8579234972677595
186952,"private BoundedSetImpl(HashSet<V> joinedSet){
  setImpl=joinedSet;
}","private BoundedSetImpl(HashSet<V> set){
  if (set.size() > limit) {
    this.isSaturated=true;
  }
 else {
    setImpl=set;
  }
}",0.5482233502538071
186953,"public BoundedSet<V> join(BoundedSet<V> other){
  HashSet<V> joinedSet=new HashSet<V>();
  joinedSet.addAll(this.getSet());
  if (other == null)   return new BoundedSetImpl(joinedSet);
  joinedSet.addAll(other.getSet());
  if (joinedSet.size() >= limit) {
    return top;
  }
 else {
    return new BoundedSetImpl(joinedSet);
  }
}","public BoundedSet<V> join(BoundedSet<V> other){
  if (this.isSaturated())   return this;
 else   if (other.isSaturated())   return other;
  HashSet<V> joinedSet=new HashSet<V>();
  joinedSet.addAll(this.getSet());
  if (other != null)   joinedSet.addAll(other.getSet());
  BoundedSetImpl r=new BoundedSetImpl(joinedSet);
  System.out.println(String.format(""String_Node_Str"",this,other,r));
  return r;
}",0.5095367847411444
186954,"public boolean isSubset(SymbolicAddressMap other){
  if (other == TOP)   return true;
 else   if (this == TOP)   return false;
 else   if (other == null)   return false;
  for (  Location l : this.map.keySet()) {
    BoundedSet<SymbolicAddress> thisEntry=map.get(l);
    BoundedSet<SymbolicAddress> otherEntry=other.map.get(l);
    if (otherEntry == null)     return false;
    if (!thisEntry.isSubset(otherEntry))     return false;
  }
  return true;
}","public boolean isSubset(SymbolicAddressMap other){
  if (other.isTop())   return true;
 else   if (this.isTop())   return false;
 else   if (other == null)   return false;
  for (  Location l : this.map.keySet()) {
    BoundedSet<SymbolicAddress> thisEntry=map.get(l);
    BoundedSet<SymbolicAddress> otherEntry=other.map.get(l);
    if (otherEntry == null)     return false;
    if (!thisEntry.isSubset(otherEntry))     return false;
  }
  return true;
}",0.8986784140969163
186955,"public BoundedSet<SymbolicAddress> getTopOfStack(){
  if (this == TOP)   return bsFactory.top();
  return map.get(new Location(topOfStack));
}","public BoundedSet<SymbolicAddress> getTopOfStack(){
  if (this.isTop())   return bsFactory.top();
  return map.get(new Location(topOfStack));
}",0.9543859649122808
186956,"public void put(Location l,BoundedSet<SymbolicAddress> bs){
  if (this == TOP)   return;
  if (!l.isHeapLoc() && l.stackLoc > this.topOfStack) {
    this.topOfStack=l.stackLoc;
  }
  this.map.put(l,bs);
}","public void put(Location l,BoundedSet<SymbolicAddress> bs){
  if (this.isTop())   return;
  if (!l.isHeapLoc() && l.stackLoc > this.topOfStack) {
    this.topOfStack=l.stackLoc;
  }
  this.map.put(l,bs);
}",0.9682151589242054
186957,"/** 
 * Clone address map, but only those stack variables below   {@code bound} 
 */
public SymbolicAddressMap cloneFilterStack(int bound){
  if (this == TOP)   return this;
  SymbolicAddressMap copy=new SymbolicAddressMap(this.bsFactory);
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : map.entrySet()) {
    Location loc=entry.getKey();
    if (loc.isHeapLoc() || loc.stackLoc < bound) {
      copy.put(loc,entry.getValue());
    }
  }
  return copy;
}","/** 
 * Clone address map, but only those stack variables below   {@code bound} 
 */
public SymbolicAddressMap cloneFilterStack(int bound){
  if (this.isTop())   return this;
  SymbolicAddressMap copy=new SymbolicAddressMap(this.bsFactory);
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : map.entrySet()) {
    Location loc=entry.getKey();
    if (loc.isHeapLoc() || loc.stackLoc < bound) {
      copy.put(loc,entry.getValue());
    }
  }
  return copy;
}",0.986096256684492
186958,"public void putStack(int index,BoundedSet<SymbolicAddress> bs){
  if (this == TOP)   return;
  this.put(new Location(index),bs);
}","public void putStack(int index,BoundedSet<SymbolicAddress> bs){
  if (this.isTop())   return;
  this.put(new Location(index),bs);
}",0.950191570881226
186959,"/** 
 * Print results
 * @param indent Indentation (amount of leading whitespace)
 */
public void print(PrintStream out,int indent){
  StringBuffer indentstr=new StringBuffer();
  for (int i=0; i < indent; i++)   indentstr.append(' ');
  out.print(indentstr.toString());
  if (this == TOP) {
    out.println(""String_Node_Str"");
    return;
  }
  out.println(""String_Node_Str"" + map.size() + ""String_Node_Str"");
  indentstr.append(' ');
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : map.entrySet()) {
    out.print(indentstr.toString());
    out.print(entry.getKey());
    out.print(""String_Node_Str"");
    out.print(entry.getValue());
    out.print(""String_Node_Str"");
  }
}","/** 
 * Print results
 * @param indent Indentation (amount of leading whitespace)
 */
public void print(PrintStream out,int indent){
  StringBuffer indentstr=new StringBuffer();
  for (int i=0; i < indent; i++)   indentstr.append(' ');
  out.print(indentstr.toString());
  if (this.isTop()) {
    out.println(""String_Node_Str"");
    return;
  }
  out.println(""String_Node_Str"" + map.size() + ""String_Node_Str"");
  indentstr.append(' ');
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : map.entrySet()) {
    out.print(indentstr.toString());
    out.print(entry.getKey());
    out.print(""String_Node_Str"");
    out.print(entry.getValue());
    out.print(""String_Node_Str"");
  }
}",0.990572878897752
186960,"/** 
 * Clone address map, but only those stack variables with index greater than or equal to  {@code framePtr}. The stack variables are move down to the beginning of the stack. 
 */
public SymbolicAddressMap cloneInvoke(int framePtr){
  if (this == TOP)   return this;
  SymbolicAddressMap copy=new SymbolicAddressMap(this.bsFactory);
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : map.entrySet()) {
    Location loc=entry.getKey();
    if (loc.isHeapLoc()) {
      copy.put(loc,entry.getValue());
    }
 else     if (loc.stackLoc >= framePtr) {
      copy.putStack(loc.stackLoc - framePtr,entry.getValue());
    }
  }
  return copy;
}","/** 
 * Clone address map, but only those stack variables with index greater than or equal to  {@code framePtr}. The stack variables are move down to the beginning of the stack. 
 */
public SymbolicAddressMap cloneInvoke(int framePtr){
  if (this.isTop())   return this;
  SymbolicAddressMap copy=new SymbolicAddressMap(this.bsFactory);
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : map.entrySet()) {
    Location loc=entry.getKey();
    if (loc.isHeapLoc()) {
      copy.put(loc,entry.getValue());
    }
 else     if (loc.stackLoc >= framePtr) {
      copy.putStack(loc.stackLoc - framePtr,entry.getValue());
    }
  }
  return copy;
}",0.9900076863950809
186961,"/** 
 * Merge in df info from returned method 
 */
public void joinReturned(SymbolicAddressMap returned,int framePtr){
  if (this == TOP)   return;
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : returned.map.entrySet()) {
    Location loc=entry.getKey();
    BoundedSet<SymbolicAddress> currentSet=map.get(loc);
    BoundedSet<SymbolicAddress> returnedSet=returned.map.get(loc);
    if (loc.isHeapLoc()) {
      put(loc,returnedSet.join(currentSet));
    }
 else {
      putStack(loc.stackLoc + framePtr,returnedSet.join(currentSet));
    }
  }
}","/** 
 * Merge in df info from returned method. 
 */
public void joinReturned(SymbolicAddressMap returned,int framePtr){
  if (returned == null) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (this.isTop())   return;
 else   if (returned.isTop()) {
    setTop();
    return;
  }
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : returned.map.entrySet()) {
    Location locReturnedFrame=entry.getKey();
    Location locCallerFrame;
    if (locReturnedFrame.isHeapLoc()) {
      locCallerFrame=locReturnedFrame;
    }
 else {
      locCallerFrame=new Location(locReturnedFrame.stackLoc + framePtr);
    }
    BoundedSet<SymbolicAddress> callerSet=map.get(locCallerFrame);
    BoundedSet<SymbolicAddress> returnedSet=returned.map.get(locReturnedFrame);
    put(locCallerFrame,returnedSet.join(callerSet));
  }
}",0.4385334291876347
186962,"@Override public int hashCode(){
  if (this == TOP)   return 1;
 else   return 2 + map.hashCode();
}","@Override public int hashCode(){
  if (isTop())   return 1;
 else   return 2 + map.hashCode();
}",0.9387755102040816
186963,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  SymbolicAddressMap other=(SymbolicAddressMap)obj;
  if (map == null || other.map == null)   return false;
  return map.equals(other.map);
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  SymbolicAddressMap other=(SymbolicAddressMap)obj;
  if (this.isTop() || other.isTop())   return (this.isTop() && other.isTop());
  return map.equals(other.map);
}",0.7660910518053375
186964,"@Override protected SymbolicAddressMap clone() throws CloneNotSupportedException {
  if (this == TOP)   return this;
  return new SymbolicAddressMap(this);
}","@Override protected SymbolicAddressMap clone(){
  if (this.isTop())   return this;
  return new SymbolicAddressMap(this);
}",0.8285714285714286
186965,"public BoundedSet<SymbolicAddress> getStack(int index){
  if (this == TOP)   return bsFactory.top();
  Location stackLoc=new Location(index);
  BoundedSet<SymbolicAddress> val=map.get(stackLoc);
  if (val == null)   throw new AssertionError(""String_Node_Str"" + index);
  return val;
}","public BoundedSet<SymbolicAddress> getStack(int index){
  if (this.isTop())   return bsFactory.top();
  Location stackLoc=new Location(index);
  BoundedSet<SymbolicAddress> val=map.get(stackLoc);
  if (val == null)   throw new AssertionError(""String_Node_Str"" + index);
  return val;
}",0.9771528998242532
186966,"/** 
 * Set stack info from other other map, upto bound. Used to restore stack frames when returning from a method 
 */
public void addStackUpto(SymbolicAddressMap in,int bound){
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : map.entrySet()) {
    Location loc=entry.getKey();
    if (!loc.isHeapLoc() && loc.stackLoc < bound) {
      map.put(loc,in.getStack(loc.stackLoc));
    }
  }
}","/** 
 * Set stack info from other other map, upto bound. Used to restore stack frames when returning from a method 
 */
public void addStackUpto(SymbolicAddressMap in,int bound){
  if (in == null) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (this.isTop())   return;
  if (in.isTop()) {
    setTop();
    return;
  }
  for (  Entry<Location,BoundedSet<SymbolicAddress>> entry : in.map.entrySet()) {
    Location loc=entry.getKey();
    if (!loc.isHeapLoc() && loc.stackLoc < bound) {
      map.put(loc,in.getStack(loc.stackLoc));
    }
  }
}",0.8368200836820083
186967,"public void join(SymbolicAddressMap b){
  joinReturned(b,0);
}","public void join(SymbolicAddressMap b){
  if (b == null)   return;
  joinReturned(b,0);
}",0.8211920529801324
186968,"public ContextMap<CallString,SymbolicAddressMap> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state){
  Context context=new Context(input.getContext());
  SymbolicAddressMap in=input.get(context.callString);
  ContextMap<CallString,SymbolicAddressMap> retval=new ContextMap<CallString,SymbolicAddressMap>(context,input);
  Instruction instruction=stmt.getInstruction();
  int newStackPtr=context.stackPtr + instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      retval.put(context.callString,in.cloneFilterStack(newStackPtr));
    }
  break;
case Constants.ACONST_NULL:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LDC:
case Constants.LDC_W:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.LDC2_W:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(instr.getIndex(),in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(instr.getIndex()));
retval.put(context.callString,result);
}
break;
case Constants.ARRAYLENGTH:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.TOP);
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
objects.put(stmt,input);
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> objectMapping=in.getStack(context.stackPtr - 1);
BoundedSet<SymbolicAddress> newMapping;
if (objectMapping.isSaturated()) {
newMapping=bsFactory.top();
}
 else {
newMapping=bsFactory.empty();
for (SymbolicAddress addr : objectMapping.getSet()) {
newMapping.add(addr.access(instr.getFieldName(context.constPool)));
}
}
result.putStack(context.stackPtr - 1,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.TOP);
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> newMapping=bsFactory.empty();
newMapping.add(SymbolicAddress.staticField(instr.getFieldName(context.constPool)));
result.putStack(context.stackPtr,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AASTORE:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AALOAD:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.DUP:
{
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP_X1:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr - 2);
result.putStack(context.stackPtr - 2,in.getStack(context.stackPtr - 1));
result.putStack(context.stackPtr - 1,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP2:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr + 1,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.POP:
case Constants.POP2:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IINC:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IADD:
case Constants.ISUB:
case Constants.INEG:
case Constants.IUSHR:
case Constants.ISHR:
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.MONITORENTER:
retval.put(context.callString,SymbolicAddressMap.TOP);
break;
case Constants.MONITOREXIT:
retval.put(context.callString,SymbolicAddressMap.TOP);
break;
case Constants.CHECKCAST:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INSTANCEOF:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.NEW:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.NEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.ANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.MULTIANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.TOP);
}
break;
case Constants.GOTO:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
String errMsg=context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"";
throw new AssertionError(errMsg);
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
{
SymbolicAddressMap result=in.cloneFilterStack(0);
result.putStack(0,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
objects.put(stmt,retval);
}
break;
case Constants.RETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IRETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
default :
System.err.println(""String_Node_Str"" + stmt);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
}
if (DEBUG_PRINT) {
System.out.println(""String_Node_Str"" + context + ""String_Node_Str""+ stmt);
System.out.println(""String_Node_Str"" + context.stackPtr + ""String_Node_Str""+ newStackPtr);
System.out.println(""String_Node_Str"");
input.get(context.callString).print(System.out,4);
System.out.println(""String_Node_Str"");
retval.get(context.callString).print(System.out,4);
}
context.stackPtr=newStackPtr;
return retval;
}","public ContextMap<CallString,SymbolicAddressMap> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state){
  Context context=new Context(input.getContext());
  SymbolicAddressMap in=input.get(context.callString);
  ContextMap<CallString,SymbolicAddressMap> retval=new ContextMap<CallString,SymbolicAddressMap>(context,input);
  Instruction instruction=stmt.getInstruction();
  int newStackPtr=context.stackPtr + instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      retval.put(context.callString,in.cloneFilterStack(newStackPtr));
    }
  break;
case Constants.ACONST_NULL:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LDC:
case Constants.LDC_W:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.LDC2_W:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(instr.getIndex(),in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(instr.getIndex()));
retval.put(context.callString,result);
}
break;
case Constants.ARRAYLENGTH:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.top());
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
objects.put(stmt,input);
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> objectMapping=in.getStack(context.stackPtr - 1);
BoundedSet<SymbolicAddress> newMapping;
if (objectMapping.isSaturated()) {
newMapping=bsFactory.top();
}
 else {
newMapping=bsFactory.empty();
for (SymbolicAddress addr : objectMapping.getSet()) {
newMapping.add(addr.access(instr.getFieldName(context.constPool)));
}
}
result.putStack(context.stackPtr - 1,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
retval.put(context.callString,SymbolicAddressMap.top());
}
 else {
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
if (instr.getFieldType(context.constPool) instanceof ReferenceType) {
BoundedSet<SymbolicAddress> newMapping=bsFactory.empty();
newMapping.add(SymbolicAddress.staticField(instr.getFieldName(context.constPool)));
result.putStack(context.stackPtr,newMapping);
}
retval.put(context.callString,result);
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AASTORE:
{
retval.put(context.callString,SymbolicAddressMap.top());
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.AALOAD:
{
retval.put(context.callString,SymbolicAddressMap.top());
}
break;
case Constants.DUP:
{
SymbolicAddressMap result=in.cloneFilterStack(newStackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP_X1:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr - 2);
result.putStack(context.stackPtr - 2,in.getStack(context.stackPtr - 1));
result.putStack(context.stackPtr - 1,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.DUP2:
{
SymbolicAddressMap result=in.cloneFilterStack(context.stackPtr);
result.putStack(context.stackPtr,in.getStack(context.stackPtr - 2));
result.putStack(context.stackPtr + 1,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
}
break;
case Constants.POP:
case Constants.POP2:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IINC:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IADD:
case Constants.ISUB:
case Constants.INEG:
case Constants.IUSHR:
case Constants.ISHR:
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.MONITORENTER:
retval.put(context.callString,SymbolicAddressMap.top());
break;
case Constants.MONITOREXIT:
retval.put(context.callString,SymbolicAddressMap.top());
break;
case Constants.CHECKCAST:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INSTANCEOF:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.NEW:
{
retval.put(context.callString,SymbolicAddressMap.top());
}
break;
case Constants.NEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.top());
}
break;
case Constants.ANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.top());
}
break;
case Constants.MULTIANEWARRAY:
{
retval.put(context.callString,SymbolicAddressMap.top());
}
break;
case Constants.GOTO:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
retval.put(context.callString,new SymbolicAddressMap(bsFactory));
if (receivers == null) {
String errMsg=context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"";
throw new AssertionError(errMsg);
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
{
SymbolicAddressMap result=in.cloneFilterStack(0);
result.putStack(0,in.getStack(context.stackPtr - 1));
retval.put(context.callString,result);
objects.put(stmt,retval);
}
break;
case Constants.RETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
case Constants.IRETURN:
{
objects.put(stmt,input);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
}
break;
default :
System.err.println(""String_Node_Str"" + stmt);
retval.put(context.callString,in.cloneFilterStack(newStackPtr));
break;
}
if (DEBUG_PRINT) {
System.out.println(""String_Node_Str"" + context + ""String_Node_Str""+ stmt);
System.out.println(""String_Node_Str"" + context.stackPtr + ""String_Node_Str""+ newStackPtr);
System.out.println(""String_Node_Str"");
input.get(context.callString).print(System.out,4);
System.out.println(""String_Node_Str"");
retval.get(context.callString).print(System.out,4);
}
context.stackPtr=newStackPtr;
return retval;
}",0.9923704013377926
186969,"private void doInvoke(String methodName,InstructionHandle stmt,Context context,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state,ContextMap<CallString,SymbolicAddressMap> retval){
  DFAAppInfo p=interpreter.getProgram();
  MethodInfo mi=p.getMethod(methodName);
  MethodGen method=mi.getMethodGen();
  methodName=method.getClassName() + ""String_Node_Str"" + method.getName()+ method.getSignature();
  if (method.isNative()) {
    handleNative(method,context,input,retval);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getMaxLocals();
    c.constPool=method.getConstantPool();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=c.callString.push(p.getMethod(context.method),stmt.getPosition(),CALLSTRING_LENGTH);
    SymbolicAddressMap in=input.get(context.callString);
    SymbolicAddressMap out=in.cloneInvoke(varPtr);
    HashMap<CallString,SymbolicAddressMap> initialMap=new HashMap<CallString,SymbolicAddressMap>();
    ContextMap<CallString,SymbolicAddressMap> tmpresult=new ContextMap<CallString,SymbolicAddressMap>(c,initialMap);
    tmpresult.put(c.callString,out);
    InstructionHandle entry=mi.getMethodGen().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> r=interpreter.interpret(c,entry,state,false);
    SymbolicAddressMap ctxInfo=retval.get(context.callString);
    InstructionHandle exit=mi.getMethodGen().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      SymbolicAddressMap returned=r.get(exit).get(c.callString);
      if (returned != null) {
        ctxInfo.joinReturned(returned,varPtr);
      }
    }
    ctxInfo.addStackUpto(in,context.stackPtr - MethodHelper.getArgSize(method));
  }
}","private void doInvoke(String methodName,InstructionHandle stmt,Context context,ContextMap<CallString,SymbolicAddressMap> input,Interpreter<CallString,SymbolicAddressMap> interpreter,Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> state,ContextMap<CallString,SymbolicAddressMap> retval){
  DFAAppInfo p=interpreter.getProgram();
  MethodInfo mi=p.getMethod(methodName);
  MethodGen method=mi.getMethodGen();
  methodName=method.getClassName() + ""String_Node_Str"" + method.getName()+ method.getSignature();
  if (method.isNative()) {
    handleNative(method,context,input,retval);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getMaxLocals();
    c.constPool=method.getConstantPool();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=c.callString.push(p.getMethod(context.method),stmt.getPosition(),CALLSTRING_LENGTH);
    SymbolicAddressMap in=input.get(context.callString);
    SymbolicAddressMap out=in.cloneInvoke(varPtr);
    HashMap<CallString,SymbolicAddressMap> initialMap=new HashMap<CallString,SymbolicAddressMap>();
    ContextMap<CallString,SymbolicAddressMap> tmpresult=new ContextMap<CallString,SymbolicAddressMap>(c,initialMap);
    tmpresult.put(c.callString,out);
    InstructionHandle entry=mi.getMethodGen().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    Map<InstructionHandle,ContextMap<CallString,SymbolicAddressMap>> r=interpreter.interpret(c,entry,state,false);
    SymbolicAddressMap ctxInfo=retval.get(context.callString);
    InstructionHandle exit=mi.getMethodGen().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      SymbolicAddressMap returned=r.get(exit).get(c.callString);
      if (returned != null) {
        ctxInfo.joinReturned(returned,varPtr);
      }
 else {
        System.err.println(""String_Node_Str"");
      }
    }
 else {
      System.err.println(""String_Node_Str"");
    }
    ctxInfo.addStackUpto(in,context.stackPtr - MethodHelper.getArgSize(method));
  }
}",0.9707293666026872
186970,"public BoundedSet<SymbolicAddress> getTopOfStack(){
  return map.get(new Location(topOfStack));
}","public BoundedSet<SymbolicAddress> getTopOfStack(){
  if (this == TOP)   return bsFactory.top();
  return map.get(new Location(topOfStack));
}",0.8117154811715481
186971,"public void put(Location l,BoundedSet<SymbolicAddress> bs){
  if (!l.isHeapLoc() && l.stackLoc > this.topOfStack) {
    this.topOfStack=l.stackLoc;
  }
  this.map.put(l,bs);
}","public void put(Location l,BoundedSet<SymbolicAddress> bs){
  if (this == TOP)   return;
  if (!l.isHeapLoc() && l.stackLoc > this.topOfStack) {
    this.topOfStack=l.stackLoc;
  }
  this.map.put(l,bs);
}",0.9234828496042216
186972,"public void putStack(int index,BoundedSet<SymbolicAddress> bs){
  this.put(new Location(index),bs);
}","public void putStack(int index,BoundedSet<SymbolicAddress> bs){
  if (this == TOP)   return;
  this.put(new Location(index),bs);
}",0.8744588744588745
186973,"public BoundedSet<SymbolicAddress> getStack(int index){
  if (this == TOP)   throw new AssertionError(""String_Node_Str"");
  Location stackLoc=new Location(index);
  BoundedSet<SymbolicAddress> val=map.get(stackLoc);
  if (val == null)   throw new AssertionError(""String_Node_Str"" + index);
  return val;
}","public BoundedSet<SymbolicAddress> getStack(int index){
  if (this == TOP)   return bsFactory.top();
  Location stackLoc=new Location(index);
  BoundedSet<SymbolicAddress> val=map.get(stackLoc);
  if (val == null)   throw new AssertionError(""String_Node_Str"" + index);
  return val;
}",0.4617996604414261
186974,"private void checkScope(InstructionHandle stmt){
  if (scopes.get(stmt) == null) {
    ValueMapping.scope=++ValueMapping.scopeCnt;
    scopes.put(stmt,new Integer(ValueMapping.scope));
  }
}","private void checkScope(Context context,InstructionHandle stmt){
  if (scopes.get(stmt) == null) {
    scopes.put(stmt,new ContextMap<CallString,Integer>(context,new HashMap<CallString,Integer>()));
  }
  if (scopes.get(stmt).get(context.callString) == null) {
    ValueMapping.scope=++ValueMapping.scopeCnt;
    scopes.get(stmt).put(context.callString,new Integer(ValueMapping.scope));
  }
}",0.6254295532646048
186975,"public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  HashMap<Location,ValueMapping> in=(HashMap<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,input);
  HashMap<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
  Instruction instruction=stmt.getInstruction();
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name),new ValueMapping(in.get(l),false));
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(stmt);
doIf(stmt,edge,context,in,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(stmt);
doIfIcmp(stmt,edge,context,in,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"");
result=in;
break;
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}","public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  HashMap<Location,ValueMapping> in=(HashMap<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,input);
  HashMap<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
  Instruction instruction=stmt.getInstruction();
  if (stmt.hasTargeters() && context.method.startsWith(""String_Node_Str"")) {
    for (int i=0; i < stmt.getTargeters().length; i++) {
      InstructionTargeter targeter=stmt.getTargeters()[i];
      if (targeter instanceof BranchInstruction) {
        checkScope(context,stmt);
        break;
      }
    }
  }
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name),new ValueMapping(in.get(l),false));
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(context,stmt);
doIf(stmt,edge,context,in,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(context,stmt);
doIfIcmp(stmt,edge,context,in,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"");
result=in;
break;
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}",0.9917605515385908
186976,"public int getBound(DFAAppInfo program,InstructionHandle instr){
  ContextMap<CallString,Pair<ValueMapping>> r=bounds.get(instr);
  if (r == null) {
    return -1;
  }
  int maxValue=-1;
  for (Iterator<CallString> k=r.keySet().iterator(); k.hasNext(); ) {
    CallString callString=k.next();
    Pair<ValueMapping> bounds=r.get(callString);
    LoopBounds.ValueMapping first=bounds.getFirst();
    LoopBounds.ValueMapping second=bounds.getSecond();
    if (scopes.get(instr).intValue() <= first.defscope || scopes.get(instr).intValue() <= second.defscope) {
      return -1;
    }
    int val=ValueMapping.computeBound(first,second);
    if (val < 0) {
      return -1;
    }
 else {
      maxValue=Math.max(maxValue,val);
    }
  }
  return maxValue;
}","public int getBound(DFAAppInfo program,InstructionHandle instr){
  ContextMap<CallString,Pair<ValueMapping>> r=bounds.get(instr);
  if (r == null) {
    return -1;
  }
  int maxValue=-1;
  for (Iterator<CallString> k=r.keySet().iterator(); k.hasNext(); ) {
    CallString callString=k.next();
    Pair<ValueMapping> bounds=r.get(callString);
    LoopBounds.ValueMapping first=bounds.getFirst();
    LoopBounds.ValueMapping second=bounds.getSecond();
    InstructionHandle target=((BranchInstruction)instr.getInstruction()).getTarget();
    if (scopes.get(target) != null) {
      if (scopes.get(target).get(callString).intValue() <= first.defscope || scopes.get(target).get(callString).intValue() <= second.defscope) {
        return -1;
      }
    }
    if (scopes.get(instr).get(callString).intValue() <= first.defscope || scopes.get(instr).get(callString).intValue() <= second.defscope) {
      return -1;
    }
    int val=ValueMapping.computeBound(first,second);
    if (val < 0) {
      return -1;
    }
 else {
      maxValue=Math.max(maxValue,val);
    }
  }
  return maxValue;
}",0.7242128121606949
186977,"public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  HashMap<Location,ValueMapping> in=(HashMap<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,input);
  HashMap<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
  Instruction instruction=stmt.getInstruction();
  if (stmt.hasTargeters() && context.method.startsWith(""String_Node_Str"")) {
    for (int i=0; i < stmt.getTargeters().length; i++) {
      InstructionTargeter targeter=stmt.getTargeters()[i];
      if (targeter instanceof BranchInstruction) {
        checkScope(context,stmt);
        break;
      }
    }
  }
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name),new ValueMapping(in.get(l),false));
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(context,stmt);
doIf(stmt,edge,context,in,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(context,stmt);
doIfIcmp(stmt,edge,context,in,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"");
result=in;
break;
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}","public ContextMap<CallString,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<CallString,Map<Location,ValueMapping>> input,Interpreter<CallString,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<CallString,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  HashMap<Location,ValueMapping> in=(HashMap<Location,ValueMapping>)input.get(context.callString);
  ContextMap<CallString,Map<Location,ValueMapping>> retval=new ContextMap<CallString,Map<Location,ValueMapping>>(context,input);
  HashMap<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
  Instruction instruction=stmt.getInstruction();
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name),new ValueMapping(in.get(l),false));
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
Interval[] size=new Interval[dim];
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
boolean valid=false;
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
if (size[i - 1] != null) {
size[i - 1].join(in.get(l).assigned);
}
 else {
size[i - 1]=in.get(l).assigned;
}
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
size[i - 1]=v.assigned;
}
}
recordSize(stmt,context,size);
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(context,stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(context,stmt);
doIf(stmt,edge,context,in,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(context,stmt);
doIfIcmp(stmt,edge,context,in,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"");
result=in;
break;
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}",0.9925349847579272
186978,"public List<Type> getObjectFields(String className){
  List<Type> l=new LinkedList<Type>();
  ClassInfo cli=project.getWcetAppInfo().getClassInfo(className);
  if (cli.superClass != null) {
    l.addAll(getObjectFields(cli.superClass.toString()));
  }
  Field[] f=cli.clazz.getFields();
  for (int i=0; i < f.length; i++) {
    l.add(f[i].getType());
  }
  return l;
}","public List<Type> getObjectFields(String className){
  List<Type> l=new LinkedList<Type>();
  ClassInfo cli=project.getWcetAppInfo().getClassInfo(className);
  if (cli.superClass != null) {
    l.addAll(getObjectFields(cli.superClass.toString()));
  }
  Field[] f=cli.clazz.getFields();
  for (int i=0; i < f.length; i++) {
    if (!f[i].isStatic()) {
      l.add(f[i].getType());
    }
  }
  return l;
}",0.9533678756476685
186979,"private void doInvoke(String methodName,InstructionHandle stmt,Context context,Map<List<HashedString>,Map<Location,ValueMapping>> input,Interpreter<List<HashedString>,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<List<HashedString>,Map<Location,ValueMapping>>> state,Map<List<HashedString>,Map<Location,ValueMapping>> result){
  DFAAppInfo p=interpreter.getProgram();
  MethodInfo mi=p.getMethod(methodName);
  MethodGen method=mi.getMethodGen();
  methodName=method.getClassName() + ""String_Node_Str"" + method.getName()+ method.getSignature();
  if (method.isNative()) {
    handleNative(method,context,input,result);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getMaxLocals();
    c.constPool=method.getConstantPool();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=new LinkedList<HashedString>(context.callString);
    c.callString.add(new HashedString(context.method + ""String_Node_Str"" + stmt.getPosition()));
    while (c.callString.size() > CALLSTRING_LENGTH) {
      c.callString.removeFirst();
    }
    Map<Location,ValueMapping> in=input.get(context.callString);
    Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
    for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
      Location l=k.next();
      if (l.stackLoc < 0) {
        out.put(l,in.get(l));
      }
      if (l.stackLoc >= varPtr) {
        out.put(new Location(l.stackLoc - varPtr),new ValueMapping(in.get(l),false));
      }
    }
    ContextMap<List<HashedString>,Map<Location,ValueMapping>> tmpresult=new ContextMap<List<HashedString>,Map<Location,ValueMapping>>(c,new HashMap<List<HashedString>,Map<Location,ValueMapping>>());
    tmpresult.put(c.callString,out);
    InstructionHandle entry=mi.getMethodGen().getInstructionList().getStart();
    state.put(entry,join(tmpresult,state.get(entry)));
    Map<InstructionHandle,ContextMap<List<HashedString>,Map<Location,ValueMapping>>> r=interpreter.interpret(c,entry,state,false);
    InstructionHandle exit=mi.getMethodGen().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      Map<Location,ValueMapping> returned=r.get(exit).get(c.callString);
      if (returned != null) {
        for (Iterator<Location> i=returned.keySet().iterator(); i.hasNext(); ) {
          Location l=i.next();
          if (l.stackLoc < 0) {
            ValueMapping m=new ValueMapping(returned.get(l),true);
            m.join(result.get(context.callString).get(l));
            result.get(context.callString).put(l,m);
          }
          if (l.stackLoc >= 0) {
            ValueMapping m=new ValueMapping(returned.get(l),false);
            Location loc=new Location(l.stackLoc + varPtr);
            m.join(result.get(context.callString).get(loc));
            result.get(context.callString).put(loc,m);
          }
        }
      }
    }
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - MethodHelper.getArgSize(method)) {
        result.get(context.callString).put(l,new ValueMapping(in.get(l),true));
      }
    }
  }
}","private void doInvoke(String methodName,InstructionHandle stmt,Context context,Map<List<HashedString>,Map<Location,ValueMapping>> input,Interpreter<List<HashedString>,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<List<HashedString>,Map<Location,ValueMapping>>> state,Map<List<HashedString>,Map<Location,ValueMapping>> result){
  DFAAppInfo p=interpreter.getProgram();
  MethodInfo mi=p.getMethod(methodName);
  MethodGen method=mi.getMethodGen();
  methodName=method.getClassName() + ""String_Node_Str"" + method.getName()+ method.getSignature();
  if (method.isNative()) {
    handleNative(method,context,input,result);
  }
 else {
    int varPtr=context.stackPtr - MethodHelper.getArgSize(method);
    Context c=new Context(context);
    c.stackPtr=method.getMaxLocals();
    c.constPool=method.getConstantPool();
    if (method.isSynchronized()) {
      c.syncLevel=context.syncLevel + 1;
    }
    c.method=methodName;
    c.callString=new LinkedList<HashedString>(context.callString);
    c.callString.add(new HashedString(context.method + ""String_Node_Str"" + stmt.getPosition()));
    while (c.callString.size() > CALLSTRING_LENGTH) {
      c.callString.removeFirst();
    }
    Map<Location,ValueMapping> in=input.get(context.callString);
    Map<Location,ValueMapping> out=new HashMap<Location,ValueMapping>();
    for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
      Location l=k.next();
      if (l.stackLoc < 0) {
        out.put(l,in.get(l));
      }
      if (l.stackLoc >= varPtr) {
        out.put(new Location(l.stackLoc - varPtr),new ValueMapping(in.get(l),false));
      }
    }
    ContextMap<List<HashedString>,Map<Location,ValueMapping>> tmpresult=new ContextMap<List<HashedString>,Map<Location,ValueMapping>>(c,new HashMap<List<HashedString>,Map<Location,ValueMapping>>());
    tmpresult.put(c.callString,out);
    InstructionHandle entry=mi.getMethodGen().getInstructionList().getStart();
    state.put(entry,join(state.get(entry),tmpresult));
    Map<InstructionHandle,ContextMap<List<HashedString>,Map<Location,ValueMapping>>> r=interpreter.interpret(c,entry,state,false);
    InstructionHandle exit=mi.getMethodGen().getInstructionList().getEnd();
    if (r.get(exit) != null) {
      Map<Location,ValueMapping> returned=r.get(exit).get(c.callString);
      if (returned != null) {
        for (Iterator<Location> i=returned.keySet().iterator(); i.hasNext(); ) {
          Location l=i.next();
          if (l.stackLoc < 0) {
            ValueMapping m=new ValueMapping(returned.get(l),true);
            m.join(result.get(context.callString).get(l));
            result.get(context.callString).put(l,m);
          }
          if (l.stackLoc >= 0) {
            ValueMapping m=new ValueMapping(returned.get(l),false);
            Location loc=new Location(l.stackLoc + varPtr);
            m.join(result.get(context.callString).get(loc));
            result.get(context.callString).put(loc,m);
          }
        }
      }
    }
    for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
      Location l=i.next();
      if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - MethodHelper.getArgSize(method)) {
        result.get(context.callString).put(l,new ValueMapping(in.get(l),true));
      }
    }
  }
}",0.996964177292046
186980,"public ContextMap<List<HashedString>,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<List<HashedString>,Map<Location,ValueMapping>> input,Interpreter<List<HashedString>,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<List<HashedString>,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  HashMap<Location,ValueMapping> in=(HashMap<Location,ValueMapping>)input.get(context.callString);
  ContextMap<List<HashedString>,Map<Location,ValueMapping>> retval=new ContextMap<List<HashedString>,Map<Location,ValueMapping>>(context,input);
  HashMap<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
  Instruction instruction=stmt.getInstruction();
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(0));
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name),new ValueMapping(in.get(l),false));
}
}
}
}
break;
case Constants.AASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
}
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
}
}
break;
case Constants.POP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
}
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
}
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
}
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
}
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - dim) {
result.put(l,in.get(l));
}
}
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
}
}
}
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
if (scopes.get(stmt) == null) {
ValueMapping.scope=++ValueMapping.scopeCnt;
scopes.put(stmt,new Integer(ValueMapping.scope));
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
}
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
if (scopes.get(stmt) == null) {
ValueMapping.scope=++ValueMapping.scopeCnt;
scopes.put(stmt,new Integer(ValueMapping.scope));
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
}
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
if (scopes.get(stmt) == null) {
ValueMapping.scope=++ValueMapping.scopeCnt;
scopes.put(stmt,new Integer(ValueMapping.scope));
}
doIf(stmt,edge,context,in,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
if (scopes.get(stmt) == null) {
ValueMapping.scope=++ValueMapping.scopeCnt;
scopes.put(stmt,new Integer(ValueMapping.scope));
}
doIfIcmp(stmt,edge,context,in,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"");
break;
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < 0) {
result.put(l,in.get(l));
}
}
}
break;
case Constants.IRETURN:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < 0) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}","public ContextMap<List<HashedString>,Map<Location,ValueMapping>> transfer(InstructionHandle stmt,FlowEdge edge,ContextMap<List<HashedString>,Map<Location,ValueMapping>> input,Interpreter<List<HashedString>,Map<Location,ValueMapping>> interpreter,Map<InstructionHandle,ContextMap<List<HashedString>,Map<Location,ValueMapping>>> state){
  Context context=new Context(input.getContext());
  HashMap<Location,ValueMapping> in=(HashMap<Location,ValueMapping>)input.get(context.callString);
  ContextMap<List<HashedString>,Map<Location,ValueMapping>> retval=new ContextMap<List<HashedString>,Map<Location,ValueMapping>>(context,input);
  HashMap<Location,ValueMapping> result=new HashMap<Location,ValueMapping>();
  retval.put(context.callString,result);
  Instruction instruction=stmt.getInstruction();
switch (instruction.getOpcode()) {
case Constants.ICONST_M1:
case Constants.ICONST_0:
case Constants.ICONST_1:
case Constants.ICONST_2:
case Constants.ICONST_3:
case Constants.ICONST_4:
case Constants.ICONST_5:
case Constants.BIPUSH:
case Constants.SIPUSH:
{
      ConstantPushInstruction instr=(ConstantPushInstruction)instruction;
      result=new HashMap<Location,ValueMapping>(in);
      retval.put(context.callString,result);
      int value=instr.getValue().intValue();
      result.put(new Location(context.stackPtr),new ValueMapping(value));
    }
  break;
case Constants.ACONST_NULL:
result=in;
retval.put(context.callString,result);
break;
case Constants.LDC:
case Constants.LDC_W:
{
LDC instr=(LDC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
Type type=instr.getType(context.constPool);
if (type.equals(Type.INT)) {
Integer value=(Integer)instr.getValue(context.constPool);
result.put(new Location(context.stackPtr),new ValueMapping(value.intValue()));
}
 else if (type.equals(Type.STRING)) {
String value=(String)instr.getValue(context.constPool);
String name=""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
result.put(new Location(name + ""String_Node_Str""),new ValueMapping(value.length()));
}
}
break;
case Constants.LDC2_W:
result=in;
retval.put(context.callString,result);
break;
case Constants.ISTORE_0:
case Constants.ISTORE_1:
case Constants.ISTORE_2:
case Constants.ISTORE_3:
case Constants.ISTORE:
{
StoreInstruction instr=(StoreInstruction)instruction;
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1 && l.stackLoc != index) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
ValueMapping v=new ValueMapping(in.get(l),true);
if (in.get(l).source == null || in.get(l).source.stackLoc != index) {
v.defscope=ValueMapping.scope;
}
result.put(new Location(index),v);
}
}
}
break;
case Constants.ASTORE_0:
case Constants.ASTORE_1:
case Constants.ASTORE_2:
case Constants.ASTORE_3:
case Constants.ASTORE:
result=in;
retval.put(context.callString,result);
break;
case Constants.ILOAD_0:
case Constants.ILOAD_1:
case Constants.ILOAD_2:
case Constants.ILOAD_3:
case Constants.ILOAD:
{
LoadInstruction instr=(LoadInstruction)instruction;
filterSet(in,result,context.stackPtr);
int index=instr.getIndex();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.source=l;
result.put(new Location(context.stackPtr),m);
}
}
}
break;
case Constants.ALOAD_0:
case Constants.ALOAD_1:
case Constants.ALOAD_2:
case Constants.ALOAD_3:
case Constants.ALOAD:
result=in;
retval.put(context.callString,result);
break;
case Constants.ARRAYLENGTH:
{
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String arrayName=i.next();
ValueMapping m=in.get(new Location(arrayName + ""String_Node_Str""));
if (m != null) {
ValueMapping value=new ValueMapping(m,false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 1),new ValueMapping());
}
}
break;
case Constants.PUTFIELD:
{
PUTFIELD instr=(PUTFIELD)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 1 - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETFIELD:
{
GETFIELD instr=(GETFIELD)instruction;
filterSet(in,result,context.stackPtr - 1);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 1);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
String f=fieldName.substring(fieldName.lastIndexOf(""String_Node_Str""),fieldName.length());
String strippedName;
if (fieldName.indexOf(""String_Node_Str"") >= 0) {
strippedName=fieldName.split(""String_Node_Str"")[0] + f;
}
 else {
strippedName=fieldName;
}
if (p.containsField(strippedName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(0));
}
}
break;
case Constants.PUTSTATIC:
{
PUTSTATIC instr=(PUTSTATIC)instruction;
int fieldSize=instr.getFieldType(context.constPool).getSize();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - fieldSize) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc < 0 && !receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(fieldName),new ValueMapping(in.get(l),false));
}
}
}
}
}
break;
case Constants.GETSTATIC:
{
GETSTATIC instr=(GETSTATIC)instruction;
result=new HashMap<Location,ValueMapping>(in);
retval.put(context.callString,result);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr);
boolean valid=false;
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String fieldName=i.next();
if (p.containsField(fieldName)) {
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(fieldName)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid && !(instr.getFieldType(context.constPool) instanceof ReferenceType)) {
result.put(new Location(context.stackPtr),new ValueMapping());
}
}
break;
case Constants.IASTORE:
case Constants.CASTORE:
case Constants.SASTORE:
case Constants.BASTORE:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc >= 0 && l.stackLoc < context.stackPtr - 3) {
result.put(l,in.get(l));
}
}
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (!receivers.containsKey(l.heapLoc)) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name),new ValueMapping(in.get(l),false));
}
}
}
}
break;
case Constants.AASTORE:
{
filterSet(in,result,context.stackPtr - 3);
}
break;
case Constants.IALOAD:
case Constants.CALOAD:
case Constants.SALOAD:
case Constants.BALOAD:
{
filterSet(in,result,context.stackPtr - 2);
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
Location location=new Location(context.stackPtr - 2);
boolean valid=false;
if (receivers != null) {
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String name=i.next();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.heapLoc.equals(name)) {
ValueMapping value=new ValueMapping(in.get(l),false);
value.join(result.get(location));
result.put(location,value);
valid=true;
}
}
}
}
if (!valid) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(0));
}
}
break;
case Constants.AALOAD:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.DUP:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP_X1:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr - 2),new ValueMapping(in.get(l),true));
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr - 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.DUP2:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
result.put(l,in.get(l));
if (l.stackLoc == context.stackPtr - 2) {
result.put(new Location(context.stackPtr),new ValueMapping(in.get(l),true));
}
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(context.stackPtr + 1),new ValueMapping(in.get(l),true));
}
}
}
break;
case Constants.POP:
{
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.POP2:
{
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IINC:
{
IINC instr=(IINC)instruction;
int index=instr.getIndex();
int increment=instr.getIncrement();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr) {
result.put(l,in.get(l));
}
if (l.stackLoc == index) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(increment);
m.constrained.add(increment);
Interval operand=new Interval(increment,increment);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.IADD:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.add(operand);
m.constrained.add(operand);
if (m.increment != null && !m.softinc) {
m.increment.join(operand);
}
 else if (m.increment != null && m.softinc) {
if ((m.increment.getLb() < 0 && operand.getUb() > 0) || (m.increment.getUb() > 0 && operand.getLb() < 0)) {
m.increment.join(operand);
}
 else {
m.increment=operand;
}
m.softinc=false;
}
 else {
m.increment=operand;
m.softinc=false;
}
result.put(l,m);
}
}
}
break;
case Constants.ISUB:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.sub(operand);
m.constrained.sub(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.INEG:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 1) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 1) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.neg();
m.constrained.neg();
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IUSHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.ushr(operand);
m.constrained.ushr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.ISHR:
{
Interval operand=new Interval();
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
operand=in.get(l).assigned;
}
}
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping(in.get(l),true);
m.assigned.shr(operand);
m.constrained.shr(operand);
m.increment=new Interval();
result.put(l,m);
}
}
}
break;
case Constants.IAND:
case Constants.IOR:
case Constants.IXOR:
case Constants.IMUL:
case Constants.IDIV:
case Constants.IREM:
case Constants.ISHL:
{
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc < context.stackPtr - 2) {
result.put(l,in.get(l));
}
 else if (l.stackLoc == context.stackPtr - 2) {
ValueMapping m=new ValueMapping();
result.put(l,m);
}
}
}
break;
case Constants.I2B:
case Constants.I2C:
case Constants.I2S:
result=in;
retval.put(context.callString,result);
break;
case Constants.MONITORENTER:
result=in;
retval.put(context.callString,result);
context.syncLevel++;
break;
case Constants.MONITOREXIT:
result=in;
retval.put(context.callString,result);
context.syncLevel--;
if (context.syncLevel < 0) {
System.err.println(""String_Node_Str"");
System.exit(-1);
}
break;
case Constants.CHECKCAST:
result=in;
retval.put(context.callString,result);
break;
case Constants.INSTANCEOF:
{
filterSet(in,result,context.stackPtr - 1);
ValueMapping bool=new ValueMapping();
bool.assigned.setLb(0);
bool.assigned.setUb(1);
result.put(new Location(context.stackPtr - 1),bool);
}
break;
case Constants.NEW:
{
result=in;
retval.put(context.callString,result);
}
break;
case Constants.NEWARRAY:
{
NEWARRAY instr=(NEWARRAY)instruction;
String name=instr.getType().toString();
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.ANEWARRAY:
{
ANEWARRAY instr=(ANEWARRAY)instruction;
String name=instr.getType(context.constPool).toString() + ""String_Node_Str"";
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
filterSet(in,result,context.stackPtr - 1);
boolean valid=false;
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
recordSize(stmt,context,in.get(l).assigned);
valid=true;
}
}
if (!valid) {
ValueMapping v=new ValueMapping();
result.put(new Location(name + ""String_Node_Str""),v);
recordSize(stmt,context,v.assigned);
}
}
break;
case Constants.MULTIANEWARRAY:
{
MULTIANEWARRAY instr=(MULTIANEWARRAY)instruction;
int dim=instr.getDimensions();
filterSet(in,result,context.stackPtr - dim);
String type=instr.getType(context.constPool).toString();
type=type.substring(0,type.indexOf(""String_Node_Str""));
for (int i=1; i <= dim; i++) {
String name=type;
for (int k=0; k < i; k++) {
name+=""String_Node_Str"";
}
name+=""String_Node_Str"" + context.method + ""String_Node_Str""+ stmt.getPosition();
for (Iterator<Location> k=in.keySet().iterator(); k.hasNext(); ) {
Location l=k.next();
if (l.stackLoc == context.stackPtr - i) {
result.put(new Location(name + ""String_Node_Str""),in.get(l));
}
}
}
}
break;
case Constants.GOTO:
result=in;
retval.put(context.callString,result);
break;
case Constants.IFNULL:
case Constants.IFNONNULL:
{
checkScope(stmt);
filterSet(in,result,context.stackPtr - 1);
}
break;
case Constants.IF_ACMPEQ:
case Constants.IF_ACMPNE:
{
checkScope(stmt);
filterSet(in,result,context.stackPtr - 2);
}
break;
case Constants.IFEQ:
case Constants.IFNE:
case Constants.IFLT:
case Constants.IFGE:
case Constants.IFLE:
case Constants.IFGT:
checkScope(stmt);
doIf(stmt,edge,context,in,result);
break;
case Constants.IF_ICMPEQ:
case Constants.IF_ICMPNE:
case Constants.IF_ICMPLT:
case Constants.IF_ICMPGE:
case Constants.IF_ICMPGT:
case Constants.IF_ICMPLE:
checkScope(stmt);
doIfIcmp(stmt,edge,context,in,result);
break;
case Constants.LOOKUPSWITCH:
case Constants.TABLESWITCH:
result=in;
retval.put(context.callString,result);
break;
case Constants.INVOKEVIRTUAL:
case Constants.INVOKEINTERFACE:
case Constants.INVOKESTATIC:
case Constants.INVOKESPECIAL:
{
DFAAppInfo p=interpreter.getProgram();
ContextMap<String,String> receivers=p.getReceivers().get(stmt);
if (receivers == null) {
System.out.println(context.method + ""String_Node_Str"" + instruction.toString(context.constPool.getConstantPool())+ ""String_Node_Str"");
result=in;
break;
}
for (Iterator<String> i=receivers.keySet().iterator(); i.hasNext(); ) {
String methodName=i.next();
doInvoke(methodName,stmt,context,input,interpreter,state,retval);
}
}
break;
case Constants.ARETURN:
case Constants.RETURN:
{
filterSet(in,result,0);
}
break;
case Constants.IRETURN:
{
filterSet(in,result,0);
for (Iterator<Location> i=in.keySet().iterator(); i.hasNext(); ) {
Location l=i.next();
if (l.stackLoc == context.stackPtr - 1) {
result.put(new Location(0),new ValueMapping(in.get(l),false));
}
}
}
break;
default :
result=in;
retval.put(context.callString,result);
break;
}
context.stackPtr+=instruction.produceStack(context.constPool) - instruction.consumeStack(context.constPool);
return retval;
}",0.924980482150039
186981,"public int getExecutionTime(MethodInfo context,InstructionHandle ih){
  int opcode=ih.getInstruction().getOpcode();
  if (opcode == Constants.NEW) {
    NEW insn=(NEW)ih.getInstruction();
    ObjectType type=insn.getLoadClassType(context.getConstantPoolGen());
    return computeObjectSize(getFieldSize(getObjectFields(type.getClassName())));
  }
 else   if (opcode == Constants.NEWARRAY || opcode == Constants.ANEWARRAY) {
    int srcLine=context.getMethod().getLineNumberTable().getSourceLine(ih.getPosition());
    LoopBound annotated=null;
    try {
      Map<Integer,LoopBound> annots=project.getAnnotations(context.getCli());
      annotated=annots.get(new Integer(srcLine));
      if (annotated == null) {
        Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
      }
    }
 catch (    Exception exc) {
      Project.logger.warn(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
    }
    Interval analyzed=null;
    if (sizes == null && project.getDfaLoopBounds() != null) {
      sizes=project.getDfaLoopBounds().getArraySizes();
    }
    if (sizes == null) {
      Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
    }
 else {
      List<HashedString> callString=new LinkedList<HashedString>();
      analyzed=sizes.get(ih).get(callString);
      if (analyzed == null) {
        Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
      }
    }
    if (analyzed.hasUb()) {
      if (annotated != null) {
        if (annotated.getUpperBound() > analyzed.getUb()) {
          Project.logger.warn(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
        }
        if (annotated.getUpperBound() < analyzed.getUb()) {
          Project.logger.warn(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
        }
        if (annotated.getUpperBound() == analyzed.getUb()) {
          Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
        }
        return computeArraySize(Math.max(annotated.getUpperBound(),analyzed.getUb()));
      }
 else {
        return computeArraySize(analyzed.getUb());
      }
    }
 else {
      if (annotated != null) {
        return computeArraySize(annotated.getUpperBound());
      }
 else {
        Project.logger.error(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine+ ""String_Node_Str"");
        return computeArraySize(4096);
      }
    }
  }
 else {
    return 0;
  }
}","public int getExecutionTime(MethodInfo context,InstructionHandle ih){
  int opcode=ih.getInstruction().getOpcode();
  if (opcode == Constants.NEW) {
    NEW insn=(NEW)ih.getInstruction();
    ObjectType type=insn.getLoadClassType(context.getConstantPoolGen());
    return computeObjectSize(getFieldSize(getObjectFields(type.getClassName())));
  }
 else   if (opcode == Constants.NEWARRAY || opcode == Constants.ANEWARRAY) {
    int srcLine=context.getMethod().getLineNumberTable().getSourceLine(ih.getPosition());
    LoopBound annotated=null;
    try {
      Map<Integer,LoopBound> annots=project.getAnnotations(context.getCli());
      annotated=annots.get(new Integer(srcLine));
      if (annotated == null) {
        Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
      }
    }
 catch (    Exception exc) {
      Project.logger.warn(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
    }
    Interval analyzed=null;
    if (sizes == null && project.getDfaLoopBounds() != null) {
      sizes=project.getDfaLoopBounds().getArraySizes();
    }
    if (sizes == null) {
      Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
    }
 else {
      List<HashedString> callString=new LinkedList<HashedString>();
      ContextMap<List<HashedString>,Interval> t=sizes.get(ih);
      if (t == null) {
        Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
      }
 else {
        analyzed=t.get(callString);
        if (analyzed == null) {
          Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
        }
      }
    }
    if (analyzed != null && analyzed.hasUb()) {
      if (annotated != null) {
        if (annotated.getUpperBound() > analyzed.getUb()) {
          Project.logger.warn(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
        }
        if (annotated.getUpperBound() < analyzed.getUb()) {
          Project.logger.warn(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
        }
        if (annotated.getUpperBound() == analyzed.getUb()) {
          Project.logger.info(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine);
        }
        return computeArraySize(Math.max(annotated.getUpperBound(),analyzed.getUb()));
      }
 else {
        return computeArraySize(analyzed.getUb());
      }
    }
 else {
      if (annotated != null) {
        return computeArraySize(annotated.getUpperBound());
      }
 else {
        Project.logger.error(""String_Node_Str"" + context + ""String_Node_Str""+ srcLine+ ""String_Node_Str"");
        return computeArraySize(4096);
      }
    }
  }
 else {
    return 0;
  }
}",0.9535651836020984
186982,"private static int f_multianewarray(){
  JVMHelp.wr(""String_Node_Str"");
  JVMHelp.wr(""String_Node_Str"");
  int ret=0;
  int i, j;
  int sp=Native.getSP();
  int fp=sp - 4;
  int pc=Native.rdIntMem(fp + 1);
  pc+=2;
  int mp=Native.rdIntMem(fp + 4);
  int start=Native.rdMem(mp) >>> 10;
  int dim=Native.rdMem(start + (pc >> 2));
  for (i=(pc & 0x03); i < 3; ++i)   dim>>=8;
  dim&=0xff;
  Native.wrIntMem(pc + 1,fp + 1);
  sp=Native.rdIntMem(fp);
  sp-=dim;
  Native.wrIntMem(sp,fp);
  if (dim != 2) {
    System.out.print(dim);
    System.out.println(""String_Node_Str"");
    JVMHelp.noim();
  }
  int cnt=Native.rdIntMem(sp + 1);
  int cnt2=Native.rdIntMem(sp + 2);
  ret=f_anewarray(cnt,0);
  int ref=Native.rdMem(ret);
  for (i=0; i < cnt; ++i) {
    Native.wrMem(f_newarray(cnt2,10),ref + i);
  }
  return ret;
}","private static int f_multianewarray(){
  JVMHelp.wr(""String_Node_Str"");
  JVMHelp.wr(""String_Node_Str"");
  int ret=0;
  int i, j;
  int sp=Native.getSP();
  int fp=sp - 4;
  int pc=Native.rdIntMem(fp + 1);
  pc+=2;
  int mp=Native.rdIntMem(fp + 4);
  int start=Native.rdMem(mp) >>> 10;
  int dim=Native.rdMem(start + (pc >> 2));
  for (i=(pc & 0x03); i < 3; ++i)   dim>>=8;
  dim&=0xff;
  Native.wrIntMem(pc + 1,fp + 1);
  sp=Native.rdIntMem(fp);
  sp-=dim;
  Native.wrIntMem(sp,fp);
  if (dim != 2) {
    System.out.print(dim);
    System.out.println(""String_Node_Str"");
    JVMHelp.noim();
  }
  int cnt=Native.rdIntMem(sp + 1);
  int cnt2=Native.rdIntMem(sp + 2);
  ret=f_anewarray(cnt,0);
  for (i=0; i < cnt; ++i) {
    int arr=f_newarray(cnt2,10);
synchronized (GC.mutex) {
      Native.wrMem(arr,Native.rdMem(ret) + i);
    }
  }
  return ret;
}",0.9160671462829736
186983,"/** 
 * Remove problematic characters from a method name  Note that fully qualified methods might become non-unique, so use an additional unique identifier if you need unique names. 
 */
public static String sanitizeFileName(String str){
  StringBuffer sanitized=new StringBuffer(str.length());
  for (int i=0; i < str.length(); i++) {
    if (Character.isLetterOrDigit(str.charAt(i)) || str.charAt(i) == '.') {
      sanitized.append(str.charAt(i));
    }
 else {
      sanitized.append('_');
    }
  }
  return sanitized.toString();
}","/** 
 * Remove problematic characters from a method name Note that fully qualified methods might become non-unique, so use an additional unique identifier if you need unique names. 
 */
public static String sanitizeFileName(String str){
  StringBuffer sanitized=new StringBuffer(str.length());
  for (int i=0; i < str.length(); i++) {
    if (Character.isLetterOrDigit(str.charAt(i)) || str.charAt(i) == '.') {
      sanitized.append(str.charAt(i));
    }
 else {
      sanitized.append('_');
    }
  }
  return sanitized.toString();
}",0.9990662931839402
186984,"public static <V,E>List<V> topologicalOrder(DirectedGraph<V,E> acyclicGraph){
  TopologicalOrderIterator<V,E> topo=new TopologicalOrderIterator<V,E>(acyclicGraph);
  List<V> topoList=new ArrayList<V>();
  while (topo.hasNext()) {
    topoList.add(topo.next());
  }
  return topoList;
}","public static <V,E>List<V> topologicalOrder(DirectedGraph<V,E> acyclicGraph){
  List<V> topoList=new ArrayList<V>();
  if (acyclicGraph.vertexSet().size() > 0) {
    TopologicalOrderIterator<V,E> topo=new TopologicalOrderIterator<V,E>(acyclicGraph);
    while (topo.hasNext()) {
      topoList.add(topo.next());
    }
  }
  return topoList;
}",0.5645933014354066
186985,"public int hashCode(){
  return method.getMethod().hashCode();
}","public int hashCode(){
  return method.hashCode();
}",0.896551724137931
186986,"private void build() throws MethodNotFoundException {
  this.buildGraph();
  classInfos=new HashSet<ClassInfo>();
  for (  CallGraphNode cgn : callGraph.vertexSet()) {
    classInfos.add(cgn.getReferencedMethod().getReceiver());
  }
  Pair<List<CallGraphNode>,List<CallGraphNode>> cycle=DirectedCycleDetector.findCycle(callGraph,rootNode);
  if (cycle != null) {
    throw new AssertionError(cyclicCallGraphMsg(cycle));
  }
  invalidate();
}","private void build() throws MethodNotFoundException {
  this.buildGraph();
  classInfos=new HashSet<ClassInfo>();
  for (  CallGraphNode cgn : callGraph.vertexSet()) {
    classInfos.add(cgn.getReferencedMethod().getReceiver());
  }
  Pair<List<CallGraphNode>,List<CallGraphNode>> cycle=DirectedCycleDetector.findCycle(callGraph,rootNode);
  if (cycle != null) {
    for (    DefaultEdge e : callGraph.edgeSet()) {
      CallGraphNode src=callGraph.getEdgeSource(e);
      CallGraphNode target=callGraph.getEdgeTarget(e);
      System.err.println(""String_Node_Str"" + src + ""String_Node_Str""+ target);
    }
    throw new AssertionError(cyclicCallGraphMsg(cycle));
  }
  invalidate();
}",0.783303730017762
186987,"public boolean equals(Object that){
  return (that instanceof CallGraphNode) ? (method.getMethod().equals(((CallGraphNode)that).method.getMethod())) : false;
}","public boolean equals(Object that){
  return (that instanceof CallGraphNode) ? (method.equals(((CallGraphNode)that).method)) : false;
}",0.9183673469387756
186988,"/** 
 * Method getFunctionOutput, which will return the functional output for point p.
 * @param p - the point index
 * @param parallel - true if to be done in parallel
 * @return the functinal output
 */
static float getFunctionOutputFloat(int p,boolean parallel){
  float functionalOutput_fp=0;
  SVMHelp.p=p;
  if (parallel) {
    SVMHelp.functionalOutput_fp=0.0f;
    ParallelExecutor pe=new ParallelExecutor();
    System.out.print(""String_Node_Str"");
    System.out.println(m);
    pe.executeParallel(new SVMHelp(),m);
    SVMHelp.functionalOutput_fp-=bias_fp;
    functionalOutput_fp=SVMHelp.functionalOutput_fp;
  }
 else {
    for (int i=0; i < m; i++) {
      if (alph[i] > 0) {
        functionalOutput_fp+=target[i] * alph[i] * getKernelOutputFloat(i,p);
      }
    }
    functionalOutput_fp-=bias_fp;
  }
  return functionalOutput_fp;
}","/** 
 * Method getFunctionOutput, which will return the functional output for point p.
 * @param p - the point index
 * @param parallel - true if to be done in parallel
 * @return the functinal output
 */
static float getFunctionOutputFloat(int p,boolean parallel){
  float functionalOutput_fp=0;
  SVMHelp.p=p;
  if (parallel) {
    SVMHelp.functionalOutput_fp=0.0f;
    System.out.print(""String_Node_Str"");
    System.out.println(m);
    pe.executeParallel(new SVMHelp(),m);
    SVMHelp.functionalOutput_fp-=bias_fp;
    functionalOutput_fp=SVMHelp.functionalOutput_fp;
  }
 else {
    for (int i=0; i < m; i++) {
      if (alph[i] > 0) {
        functionalOutput_fp+=target[i] * alph[i] * getKernelOutputFloat(i,p);
      }
    }
    functionalOutput_fp-=bias_fp;
  }
  return functionalOutput_fp;
}",0.9709443099273608
186989,"public void read(){
  for (int i=0; i < aDat.length; i++) {
    aDat[i]=(i + 30) % SIZE;
  }
}","public void read(){
  for (i=0; i < aDat.length; i++) {
    aDat[i]=(i + 30) % SIZE;
  }
}",0.9782608695652174
186990,"public void sort(){
  i=0;
  while (i < aDat.length) {
    j=aDat.length - 1;
    while (j >= i) {
      cond=aDat[j] < aDat[j - 1];
      temp=aDat[j];
      aDat[j]=Native.condMove(aDat[j - 1],aDat[j],cond);
      aDat[j - 1]=Native.condMove(temp,aDat[j - 1],cond);
      j=j - 1;
    }
    i=i + 1;
  }
}","public void sort(){
  i=0;
  while (i < aDat.length) {
    j=aDat.length - 1;
    while (j > i) {
      cond=aDat[j] < aDat[j - 1];
      temp=aDat[j];
      aDat[j]=Native.condMove(aDat[j - 1],aDat[j],cond);
      aDat[j - 1]=Native.condMove(temp,aDat[j - 1],cond);
      j=j - 1;
    }
    i=i + 1;
  }
}",0.99836867862969
186991,"public void write(){
}","public void write(){
  for (i=0; i < aDat.length; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ aDat[i]+ ""String_Node_Str"");
  }
}",0.2458100558659217
186992,"/** 
 * Called recursive to build the VTs top down.
 * @param clazz
 */
private void buildVT(JavaClass clazz){
  int i, j;
  JopClassInfo cli;
  cli=(JopClassInfo)ai.cliMap.get(clazz.getClassName());
  JopClassInfo.ClVT supVt=null;
  JopClassInfo.ClFT supFt=null;
  if (clazz.getClassName().equals(clazz.getSuperclassName())) {
    ;
  }
 else {
    ClassInfo clisup=(ClassInfo)ai.cliMap.get(clazz.getSuperclassName());
    JavaClass superClazz=clisup.clazz;
    String superName=superClazz.getClassName();
    if (mapClVT.get(superName) == null) {
      buildVT(superClazz);
    }
    supVt=(JopClassInfo.ClVT)mapClVT.get(superName);
    supFt=(JopClassInfo.ClFT)mapClFT.get(superName);
  }
  String clazzName=clazz.getClassName();
  if (mapClVT.get(clazzName) != null) {
    return;
  }
  JopClassInfo.ClVT clvt=cli.getClVT();
  JopClassInfo.ClFT clft=cli.getClFT();
  mapClVT.put(clazzName,clvt);
  mapClFT.put(clazzName,clft);
  Method m[]=clazz.getMethods();
  int methodCount=m.length;
  int maxLen=methodCount;
  if (supVt != null)   maxLen+=supVt.len;
  clvt.len=0;
  clvt.key=new String[maxLen];
  clvt.mi=new JopMethodInfo[maxLen];
  Field f[]=clazz.getFields();
  maxLen=f.length;
  clft.len=0;
  clft.key=new String[maxLen];
  clft.idx=new int[maxLen];
  clft.size=new int[maxLen];
  clft.isStatic=new boolean[maxLen];
  clft.isReference=new boolean[maxLen];
  if (supVt != null) {
    for (i=0; i < supVt.len; ++i) {
      clvt.key[i]=supVt.key[i];
      clvt.mi[i]=supVt.mi[i];
    }
    clvt.len=supVt.len;
  }
  for (i=0; i < methodCount; i++) {
    Method meth=m[i];
    String methodId=meth.getName() + meth.getSignature();
    JopMethodInfo mi=(JopMethodInfo)cli.getMethodInfo(methodId);
    for (j=0; j < clvt.len; ++j) {
      if (clvt.key[j].equals(methodId)) {
        clvt.mi[j]=mi;
        break;
      }
    }
    if (j == clvt.len) {
      clvt.key[clvt.len]=methodId;
      clvt.mi[clvt.len]=mi;
      ++clvt.len;
    }
  }
  int nextFieldIndex=0;
  int nextStaticIndex=0;
  if (supFt != null) {
    nextFieldIndex=supFt.instSize;
    for (i=0; i < supFt.len; ++i) {
      if (supFt.isStatic[i]) {
        if (supFt.idx[i] >= nextStaticIndex) {
          nextStaticIndex=supFt.idx[i] + 1;
        }
      }
    }
  }
  for (i=0; i < f.length; ++i) {
    Field field=f[i];
    int size=field.getType().getSize();
    String fieldId=field.getName() + field.getSignature();
    clft.key[clft.len]=fieldId;
    clft.size[clft.len]=size;
    clft.isReference[clft.len]=field.getType() instanceof ReferenceType;
    if (field.isStatic()) {
      clft.idx[clft.len]=nextStaticIndex;
      clft.isStatic[clft.len]=true;
      nextStaticIndex+=size;
    }
 else {
      clft.idx[clft.len]=nextFieldIndex;
      clft.isStatic[clft.len]=false;
      nextFieldIndex+=size;
    }
    clft.len++;
  }
  clft.instSize=nextFieldIndex;
  cli.setInstanceSize(nextFieldIndex);
}","/** 
 * Called recursive to build the VTs top down.
 * @param clazz
 */
private void buildVT(JavaClass clazz){
  int i, j;
  JopClassInfo cli;
  cli=(JopClassInfo)ai.cliMap.get(clazz.getClassName());
  JopClassInfo.ClVT supVt=null;
  JopClassInfo.ClFT supFt=null;
  if (clazz.getClassName().equals(clazz.getSuperclassName())) {
    ;
  }
 else {
    ClassInfo clisup=(ClassInfo)ai.cliMap.get(clazz.getSuperclassName());
    JavaClass superClazz=clisup.clazz;
    String superName=superClazz.getClassName();
    if (mapClVT.get(superName) == null) {
      buildVT(superClazz);
    }
    supVt=(JopClassInfo.ClVT)mapClVT.get(superName);
    supFt=(JopClassInfo.ClFT)mapClFT.get(superName);
  }
  String clazzName=clazz.getClassName();
  if (mapClVT.get(clazzName) != null) {
    return;
  }
  JopClassInfo.ClVT clvt=cli.getClVT();
  JopClassInfo.ClFT clft=cli.getClFT();
  mapClVT.put(clazzName,clvt);
  mapClFT.put(clazzName,clft);
  Method m[]=clazz.getMethods();
  int methodCount=m.length;
  int maxLen=methodCount;
  if (supVt != null)   maxLen+=supVt.len;
  for (  JavaClass cl : clazz.getInterfaces()) {
    maxLen+=cl.getMethods().length;
  }
  clvt.len=0;
  clvt.key=new String[maxLen];
  clvt.mi=new JopMethodInfo[maxLen];
  Field f[]=clazz.getFields();
  maxLen=f.length;
  clft.len=0;
  clft.key=new String[maxLen];
  clft.idx=new int[maxLen];
  clft.size=new int[maxLen];
  clft.isStatic=new boolean[maxLen];
  clft.isReference=new boolean[maxLen];
  if (supVt != null) {
    for (i=0; i < supVt.len; ++i) {
      clvt.key[i]=supVt.key[i];
      clvt.mi[i]=supVt.mi[i];
    }
    clvt.len=supVt.len;
  }
  for (i=0; i < methodCount; i++) {
    Method meth=m[i];
    String methodId=meth.getName() + meth.getSignature();
    JopMethodInfo mi=(JopMethodInfo)cli.getMethodInfo(methodId);
    for (j=0; j < clvt.len; ++j) {
      if (clvt.key[j].equals(methodId)) {
        clvt.mi[j]=mi;
        break;
      }
    }
    if (j == clvt.len) {
      clvt.key[clvt.len]=methodId;
      clvt.mi[clvt.len]=mi;
      ++clvt.len;
    }
  }
  for (i=0; i < clazz.getInterfaces().length; i++) {
    ClassInfo icli=ai.cliMap.get(clazz.getInterfaces()[i].getClassName());
    for (    String methodId : icli.methods.keySet()) {
      for (j=0; j < clvt.len; ++j) {
        if (clvt.key[j].equals(methodId)) {
          break;
        }
      }
      if (j == clvt.len) {
        clvt.key[clvt.len]=methodId;
        clvt.mi[clvt.len]=(JopMethodInfo)icli.methods.get(methodId);
        ++clvt.len;
      }
    }
  }
  int nextFieldIndex=0;
  int nextStaticIndex=0;
  if (supFt != null) {
    nextFieldIndex=supFt.instSize;
    for (i=0; i < supFt.len; ++i) {
      if (supFt.isStatic[i]) {
        if (supFt.idx[i] >= nextStaticIndex) {
          nextStaticIndex=supFt.idx[i] + 1;
        }
      }
    }
  }
  for (i=0; i < f.length; ++i) {
    Field field=f[i];
    int size=field.getType().getSize();
    String fieldId=field.getName() + field.getSignature();
    clft.key[clft.len]=fieldId;
    clft.size[clft.len]=size;
    clft.isReference[clft.len]=field.getType() instanceof ReferenceType;
    if (field.isStatic()) {
      clft.idx[clft.len]=nextStaticIndex;
      clft.isStatic[clft.len]=true;
      nextStaticIndex+=size;
    }
 else {
      clft.idx[clft.len]=nextFieldIndex;
      clft.isStatic[clft.len]=false;
      nextFieldIndex+=size;
    }
    clft.len++;
  }
  clft.instSize=nextFieldIndex;
  cli.setInstanceSize(nextFieldIndex);
}",0.8238080202083992
186993,"private boolean implementsInterface(String ifname){
  ClassInfo cli=this;
  do {
    String[] interfaces=cli.clazz.getInterfaceNames();
    for (int i=0; i < interfaces.length; i++) {
      if (ifname.equals(interfaces[i])) {
        return true;
      }
 else {
        boolean match=((JopClassInfo)appInfo.cliMap.get(interfaces[i])).implementsInterface(ifname);
        if (match) {
          return true;
        }
      }
    }
    cli=(ClassInfo)cli.superClass;
  }
 while (cli != null);
  return false;
}","private boolean implementsInterface(String ifname){
  ClassInfo cli=this;
  do {
    String[] interfaces=cli.clazz.getInterfaceNames();
    for (int i=0; i < interfaces.length; i++) {
      if (ifname.equals(interfaces[i])) {
        return true;
      }
 else {
        JopClassInfo superCli=(JopClassInfo)appInfo.cliMap.get(interfaces[i]);
        boolean match=superCli.implementsInterface(ifname);
        if (match) {
          return true;
        }
      }
    }
    cli=(ClassInfo)cli.superClass;
  }
 while (cli != null);
  return false;
}",0.8714555765595463
186994,"public void Start(){
  final int max_mac_size=10000;
  final int max_cycles=100000;
  int[] array1=new int[max_mac_size];
  int[] array2=new int[max_mac_size];
  System.out.println(""String_Node_Str"");
  mac_coprocessor m=new mac_coprocessor();
  int ts=Native.rdMem(Const.IO_CNT);
  int te=Native.rdMem(Const.IO_CNT);
  int to=te - ts;
  int icount=0;
  for (int mac_size=1; mac_size < max_mac_size; icount++) {
    int i, j, time, out, expect=0;
    boolean error=false;
    int max_time=0;
    int min_time=1 << 30;
    int total_time=0;
    for (i=0; i < mac_size; i++) {
      array1[i]=mac_size + 123 + (i * 99)+ (i * i * 12);
      array2[i]=mac_size + 456 + (i * 78)+ (i * i * 9);
      expect+=array1[i] * array2[i];
    }
    System.out.print(mac_size);
    System.out.print(""String_Node_Str"");
    out=m.mac1(mac_size,array1,array2);
    for (i=0; i < max_cycles; i++) {
      ts=Native.rdMem(Const.IO_CNT);
      out=m.mac1(mac_size,array1,array2);
      te=Native.rdMem(Const.IO_CNT);
      time=te - ts - to;
      if (time > max_time) {
        max_time=time;
      }
      if (time < min_time) {
        min_time=time;
      }
      total_time+=time;
      if (out != expect) {
        error=true;
        break;
      }
    }
    if (error) {
      System.out.println(""String_Node_Str"");
      break;
    }
    System.out.print(min_time);
    System.out.print(""String_Node_Str"");
    System.out.print(total_time / max_cycles);
    System.out.print(""String_Node_Str"");
    System.out.println(max_time);
    mac_size++;
    if (icount > 100) {
      mac_size+=mac_size / 4;
    }
  }
  System.out.println(""String_Node_Str"");
}","public void Start(){
  array1=new int[max_mac_size + 1];
  array2=new int[max_mac_size + 1];
  System.out.println(""String_Node_Str"");
  m=new mac_coprocessor();
  int icount=0;
  boolean error=false;
  for (int mac_size=1; (mac_size < max_mac_size) && !error; icount++) {
    error=Measure(mac_size);
    mac_size++;
    if (icount > 100) {
      mac_size+=mac_size / 4;
    }
  }
  if (!error) {
    Measure(max_mac_size);
  }
  System.out.println(""String_Node_Str"");
}",0.0853080568720379
186995,"public int search_max(int size,int[] data){
  int max=0;
  for (int i=0; i < size; i++) {
    int d=data[i];
    if (d > max)     max=d;
  }
  return max;
}","public int search_max(int size,int[] data){
  int max=0;
  int one=1;
  for (int i=0; i < size; i+=one) {
    int d=data[i];
    if (d > max)     max=d;
  }
  return max;
}",0.945121951219512
186996,"public boolean HWM_SW_Measure(int test_size){
  int ts=Native.rdMem(Const.IO_CNT);
  int te=Native.rdMem(Const.IO_CNT);
  int to=te - ts;
  boolean error=false;
  System.out.print(test_size);
  test_vector[test_size]=0x7fffffff;
  int bc1=bit_count1(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  bit_count1(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  System.out.print(""String_Node_Str"");
  System.out.print(te - ts - to);
  int bc2=bit_count2(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  bit_count2(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  System.out.print(""String_Node_Str"");
  System.out.print(te - ts - to);
  int sm=search_max(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  search_max(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  System.out.print(""String_Node_Str"");
  System.out.print(te - ts - to);
  int bchw1=bcms.bitcount(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  int bchw2=bcms.bitcount(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  int bchw_time=te - ts - to;
  int smhw1=bcms.maxsearch(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  int smhw2=bcms.maxsearch(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  int smhw_time=te - ts - to;
  System.out.print(""String_Node_Str"");
  System.out.print(bchw_time);
  System.out.println(""String_Node_Str"");
  if (smhw_time != bchw_time) {
    System.out.print(""String_Node_Str"");
    System.out.print(bchw_time);
    System.out.print(""String_Node_Str"");
    System.out.print(smhw_time);
    System.out.println(""String_Node_Str"");
    error=true;
  }
  if ((bc1 != bc2) || (bc1 != bchw1) || (bc1 != bchw2)) {
    System.out.print(""String_Node_Str"");
    System.out.print(bc1);
    System.out.print(""String_Node_Str"");
    System.out.print(bc2);
    System.out.print(""String_Node_Str"");
    System.out.print(bchw1);
    System.out.print(""String_Node_Str"");
    System.out.print(bchw2);
    System.out.println(""String_Node_Str"");
    error=true;
  }
  if ((sm != smhw1) || (sm != smhw2)) {
    System.out.print(""String_Node_Str"");
    System.out.print(sm);
    System.out.print(""String_Node_Str"");
    System.out.print(smhw1);
    System.out.print(""String_Node_Str"");
    System.out.print(smhw2);
    System.out.println(""String_Node_Str"");
    error=true;
  }
  return error;
}","public boolean HWM_SW_Measure(int test_size){
  int ts=Native.rdMem(Const.IO_CNT);
  int te=Native.rdMem(Const.IO_CNT);
  int to=te - ts;
  boolean error=false;
  System.out.print(test_size);
  test_vector[test_size]=0x7fffffff;
  mac(test_size,test_vector,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  mac(test_size,test_vector,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  System.out.print(""String_Node_Str"");
  System.out.print(te - ts - to);
  int bc1=bit_count1(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  bit_count1(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  System.out.print(""String_Node_Str"");
  System.out.print(te - ts - to);
  int bc2=bit_count2(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  bit_count2(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  System.out.print(""String_Node_Str"");
  System.out.print(te - ts - to);
  int sm=search_max(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  search_max(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  System.out.print(""String_Node_Str"");
  System.out.print(te - ts - to);
  int bchw1=bcms.bitcount(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  int bchw2=bcms.bitcount(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  int bchw_time=te - ts - to;
  int smhw1=bcms.maxsearch(test_size,test_vector);
  ts=Native.rdMem(Const.IO_CNT);
  int smhw2=bcms.maxsearch(test_size,test_vector);
  te=Native.rdMem(Const.IO_CNT);
  int smhw_time=te - ts - to;
  System.out.print(""String_Node_Str"");
  System.out.print(bchw_time);
  System.out.println(""String_Node_Str"");
  if (smhw_time != bchw_time) {
    System.out.print(""String_Node_Str"");
    System.out.print(bchw_time);
    System.out.print(""String_Node_Str"");
    System.out.print(smhw_time);
    System.out.println(""String_Node_Str"");
    error=true;
  }
  if ((bc1 != bc2) || (bc1 != bchw1) || (bc1 != bchw2)) {
    System.out.print(""String_Node_Str"");
    System.out.print(bc1);
    System.out.print(""String_Node_Str"");
    System.out.print(bc2);
    System.out.print(""String_Node_Str"");
    System.out.print(bchw1);
    System.out.print(""String_Node_Str"");
    System.out.print(bchw2);
    System.out.println(""String_Node_Str"");
    error=true;
  }
  if ((sm != smhw1) || (sm != smhw2)) {
    System.out.print(""String_Node_Str"");
    System.out.print(sm);
    System.out.print(""String_Node_Str"");
    System.out.print(smhw1);
    System.out.print(""String_Node_Str"");
    System.out.print(smhw2);
    System.out.println(""String_Node_Str"");
    error=true;
  }
  return error;
}",0.9549403919983837
186997,"public int bit_count2(int size,int[] data){
  int count=0;
  for (int i=0; i < size; i++) {
    int d=data[i];
    for (int j=0; j < 4; j++) {
      count+=lut[d & 255];
      d=d >> 8;
    }
  }
  return count;
}","public int bit_count2(int size,int[] data){
  int count=0;
  int one=1;
  for (int i=0; i < size; i+=one) {
    int d=data[i];
    for (int j=0; j < 4; j+=one) {
      count+=lut[d & 255];
      d=d >> 8;
    }
  }
  return count;
}",0.9483146067415732
186998,"public int bit_count1(int size,int[] data){
  int count=0;
  for (int i=0; i < size; i++) {
    int d=data[i];
    for (int j=0; j < 32; j++) {
      if ((d & 1) == 1)       count++;
      d=d >> 1;
    }
  }
  return count;
}","public int bit_count1(int size,int[] data){
  int count=0;
  int one=1;
  for (int i=0; i < size; i+=one) {
    int d=data[i];
    for (int j=0; j < 32; j+=one) {
      if ((d & 1) == 1)       count+=one;
      d=d >> 1;
    }
  }
  return count;
}",0.7763713080168776
186999,"public static int measure(){
  int val=-expect;
  for (int i=0; i < mac_size; i++) {
    val+=array1[i] * array2[i];
  }
  return val;
}","public static void measure(){
  hwm.mac(hwm.max_test_size,hwm.test_vector,hwm.test_vector);
}",0.3580786026200873
187000,"public static void main(String[] args){
  measure();
}","public static void main(String[] args){
  hwm=new HWMethTest();
  hwm.Prepare_Noisy_Vector(hwm.max_test_size);
  measure();
}",0.6033519553072626
