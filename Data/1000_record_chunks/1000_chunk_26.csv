record_number,buggy_code,fixed_code,code_similarity
25001,"private static void jj_la1_init_2(){
  jj_la1_2=new int[]{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0xffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x20ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0xffffff,0xffffff,0x0,0x0,0xfffe,0xff0000,0x0,0x20ffffff};
}","private static void jj_la1_init_2(){
  jj_la1_2=new int[]{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0xc0000000,0x0,0xc0000000,0x0,0xc8ffffff,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0xc0000000,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0xc0000000,0xc8000000,0x0,0xc0ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0xc8000000,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0xc8ffffff,0x0,0x0,0x0,0x0,0xc0000000,0xc0000000,0xc0000000,0xc0000000,0x1,0x0,0x0,0x80ffffff,0xc0ffffff,0x0,0x0,0xfffe,0xff0000,0x0,0xc8ffffff};
}",0.2688638334778838
25002,"private static void jj_la1_init_3(){
  jj_la1_3=new int[]{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x0,0x3,0x0,0x3b,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x23,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x38,0x30,0x0,0x0,0x3b,0x3,0x0,0x3b,0x0,0x0,0x0,0x0,0x0,0x0,0x3b,0x0,0x0,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3b,0x0,0x0,0x0,0x0,0x0,0x0,0x3b,0x0,0x0,0x0,0x0,0x3,0x3,0x3,0x3,0x0,0x0,0x0,0x2,0x3b,0x0,0x0,0x0,0x0,0x0,0x3b};
}","private static void jj_la1_init_3(){
  jj_la1_3=new int[]{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0xc,0x0,0x0,0xe,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0xe};
}",0.218102508178844
25003,"public ADQLObject next(){
  if (!subQueryGot) {
    subQueryGot=true;
    return subQuery;
  }
 else   throw new NoSuchElementException();
}","@Override public ADQLObject next(){
  if (!subQueryGot) {
    subQueryGot=true;
    return subQuery;
  }
 else   throw new NoSuchElementException();
}",0.9655172413793104
25004,"public String getName(){
  return hasAlias() ? alias : (isSubQuery() ? ""String_Node_Str"" : getTableName());
}","@Override public String getName(){
  return hasAlias() ? alias : (isSubQuery() ? ""String_Node_Str"" : getTableName());
}",0.956140350877193
25005,"public ArrayList<ADQLTable> getTablesByAlias(final String alias,final boolean caseSensitive){
  ArrayList<ADQLTable> tables=new ArrayList<ADQLTable>();
  if (hasAlias()) {
    if (!caseSensitive) {
      if (getAlias().equalsIgnoreCase(alias))       tables.add(this);
    }
 else {
      if (IdentifierField.ALIAS.isCaseSensitive(caseSensitivity)) {
        if (getAlias().equals(alias))         tables.add(this);
      }
 else {
        if (getAlias().toLowerCase().equals(alias))         tables.add(this);
      }
    }
  }
  return tables;
}","@Override public ArrayList<ADQLTable> getTablesByAlias(final String alias,final boolean caseSensitive){
  ArrayList<ADQLTable> tables=new ArrayList<ADQLTable>();
  if (hasAlias()) {
    if (!caseSensitive) {
      if (getAlias().equalsIgnoreCase(alias))       tables.add(this);
    }
 else {
      if (IdentifierField.ALIAS.isCaseSensitive(caseSensitivity)) {
        if (getAlias().equals(alias))         tables.add(this);
      }
 else {
        if (getAlias().toLowerCase().equals(alias))         tables.add(this);
      }
    }
  }
  return tables;
}",0.9908925318761383
25006,"public void replace(ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
  if (!subQueryGot)   throw new IllegalStateException(""String_Node_Str"");
  if (replacer == null)   remove();
  if (replacer instanceof ADQLQuery)   subQuery=(ADQLQuery)replacer;
 else   throw new UnsupportedOperationException(""String_Node_Str"" + subQuery.toADQL() + ""String_Node_Str""+ replacer.getClass().getName()+ ""String_Node_Str""+ replacer.toADQL()+ ""String_Node_Str"");
}","@Override public void replace(ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
  if (!subQueryGot)   throw new IllegalStateException(""String_Node_Str"");
  if (replacer == null)   remove();
  if (replacer instanceof ADQLQuery)   subQuery=(ADQLQuery)replacer;
 else   throw new UnsupportedOperationException(""String_Node_Str"" + subQuery.toADQL() + ""String_Node_Str""+ replacer.getClass().getName()+ ""String_Node_Str""+ replacer.toADQL()+ ""String_Node_Str"");
}",0.9896694214876032
25007,"public ADQLIterator adqlIterator(){
  return new ADQLIterator(){
    private boolean subQueryGot=!isSubQuery();
    public ADQLObject next(){
      if (!subQueryGot) {
        subQueryGot=true;
        return subQuery;
      }
 else       throw new NoSuchElementException();
    }
    public boolean hasNext(){
      return !subQueryGot;
    }
    public void replace(    ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
      if (!subQueryGot)       throw new IllegalStateException(""String_Node_Str"");
      if (replacer == null)       remove();
      if (replacer instanceof ADQLQuery)       subQuery=(ADQLQuery)replacer;
 else       throw new UnsupportedOperationException(""String_Node_Str"" + subQuery.toADQL() + ""String_Node_Str""+ replacer.getClass().getName()+ ""String_Node_Str""+ replacer.toADQL()+ ""String_Node_Str"");
    }
    public void remove(){
      if (!subQueryGot)       throw new IllegalStateException(""String_Node_Str"");
 else       throw new UnsupportedOperationException(""String_Node_Str"" + toADQL() + ""String_Node_Str"");
    }
  }
;
}","@Override public ADQLIterator adqlIterator(){
  return new ADQLIterator(){
    private boolean subQueryGot=!isSubQuery();
    @Override public ADQLObject next(){
      if (!subQueryGot) {
        subQueryGot=true;
        return subQuery;
      }
 else       throw new NoSuchElementException();
    }
    @Override public boolean hasNext(){
      return !subQueryGot;
    }
    @Override public void replace(    ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
      if (!subQueryGot)       throw new IllegalStateException(""String_Node_Str"");
      if (replacer == null)       remove();
      if (replacer instanceof ADQLQuery)       subQuery=(ADQLQuery)replacer;
 else       throw new UnsupportedOperationException(""String_Node_Str"" + subQuery.toADQL() + ""String_Node_Str""+ replacer.getClass().getName()+ ""String_Node_Str""+ replacer.toADQL()+ ""String_Node_Str"");
    }
    @Override public void remove(){
      if (!subQueryGot)       throw new IllegalStateException(""String_Node_Str"");
 else       throw new UnsupportedOperationException(""String_Node_Str"" + toADQL() + ""String_Node_Str"");
    }
  }
;
}",0.977538185085355
25008,"/** 
 * <p>Sets the   {@link DBTable} corresponding to this {@link ADQLTable}.</p> <p><i> <u>Note:</u> This function will do nothing if this   {@link ADQLTable} is a sub query.</i></p>
 * @param dbLink Its corresponding {@link DBTable}.
 */
public final void setDBLink(DBTable dbLink){
  if (!isSubQuery())   this.dbLink=dbLink;
}","/** 
 * Sets the   {@link DBTable} corresponding to this {@link ADQLTable}.
 * @param dbLink Its corresponding {@link DBTable}.
 */
public final void setDBLink(DBTable dbLink){
  this.dbLink=dbLink;
}",0.3660377358490566
25009,"/** 
 * Sets the position at which this   {@link ADQLTable} has been found in the original ADQL query string.
 * @param pos	Position of this {@link ADQLTable}.
 */
public final void setPosition(final TextPosition pos){
  position=pos;
}","/** 
 * Sets the position at which this   {@link ADQLTable} has been found in the original ADQL query string.
 * @param pos	Position of this {@link ADQLTable}.
 */
@Override public final void setPosition(final TextPosition pos){
  position=pos;
}",0.979253112033195
25010,"public void remove(){
  if (!subQueryGot)   throw new IllegalStateException(""String_Node_Str"");
 else   throw new UnsupportedOperationException(""String_Node_Str"" + toADQL() + ""String_Node_Str"");
}","@Override public void remove(){
  if (!subQueryGot)   throw new IllegalStateException(""String_Node_Str"");
 else   throw new UnsupportedOperationException(""String_Node_Str"" + toADQL() + ""String_Node_Str"");
}",0.9751243781094528
25011,"public ArrayList<ADQLTable> getTables(){
  ArrayList<ADQLTable> tables=new ArrayList<ADQLTable>();
  tables.add(this);
  return tables;
}","@Override public ArrayList<ADQLTable> getTables(){
  ArrayList<ADQLTable> tables=new ArrayList<ADQLTable>();
  tables.add(this);
  return tables;
}",0.9647887323943662
25012,"public ADQLObject getCopy() throws Exception {
  return new ADQLTable(this);
}","@Override public ADQLObject getCopy() throws Exception {
  return new ADQLTable(this);
}",0.9397590361445785
25013,"public String toADQL(){
  return (isSubQuery() ? (""String_Node_Str"" + subQuery.toADQL() + ""String_Node_Str"") : getFullTableName()) + ((alias == null) ? ""String_Node_Str"" : (""String_Node_Str"" + (isCaseSensitive(IdentifierField.ALIAS) ? (""String_Node_Str"" + alias + ""String_Node_Str"") : alias)));
}","@Override public String toADQL(){
  return (isSubQuery() ? (""String_Node_Str"" + subQuery.toADQL() + ""String_Node_Str"") : getFullTableName()) + ((alias == null) ? ""String_Node_Str"" : (""String_Node_Str"" + (isCaseSensitive(IdentifierField.ALIAS) ? (""String_Node_Str"" + alias + ""String_Node_Str"") : alias)));
}",0.9833887043189368
25014,"public SearchColumnList getDBColumns(){
  SearchColumnList list=new SearchColumnList();
  if (isSubQuery() && dbLink == null)   refreshDBLink();
  if (dbLink != null) {
    for (    DBColumn dbCol : dbLink)     list.add(dbCol);
  }
  return list;
}","@Override public SearchColumnList getDBColumns(){
  SearchColumnList list=new SearchColumnList();
  if (isSubQuery() && dbLink == null)   refreshDBLink();
  if (dbLink != null) {
    for (    DBColumn dbCol : dbLink)     list.add(dbCol);
  }
  return list;
}",0.9802371541501976
25015,"public boolean hasNext(){
  return !subQueryGot;
}","@Override public boolean hasNext(){
  return !subQueryGot;
}",0.9090909090909092
25016,"/** 
 * Gets the position in the original ADQL query string.
 * @return	The position of this {@link ADQLTable}.
 */
public final TextPosition getPosition(){
  return position;
}","/** 
 * Gets the position in the original ADQL query string.
 * @return	The position of this {@link ADQLTable}.
 */
@Override public final TextPosition getPosition(){
  return position;
}",0.9725274725274724
25017,"@Override public String translate(final RegionFunction region) throws TranslationException {
  return getDefaultADQLFunction(region);
}","@Override public String translate(MathFunction fct) throws TranslationException {
switch (fct.getType()) {
case TRUNCATE:
    return ""String_Node_Str"" + ((fct.getNbParameters() >= 2) ? (translate(fct.getParameter(0)) + ""String_Node_Str"" + translate(fct.getParameter(1))) : ""String_Node_Str"") + ""String_Node_Str"";
case MOD:
  return ((fct.getNbParameters() >= 2) ? (translate(fct.getParameter(0)) + ""String_Node_Str"" + translate(fct.getParameter(1))) : ""String_Node_Str"");
default :
return getDefaultADQLFunction(fct);
}
}",0.3323170731707317
25018,"/** 
 * <p>Format the given column value.</p> <p> This function should be overwritten if a different or additional formatting should be performed before, after or instead of the one implemented here by default. </p> <p>By default, the following function performs the following formatting:</p> <ul> <li><b>If   {@link Timestamp}:</b> the date-time is converted into a string with the ISO8601 format (see   {@link ISO8601Format}).</li> <li><b>If a single CHAR is declared and a String is given:</b> only the first character is returned as a   {@link Character} object.</li><li><b>If the value is declared as a Geometry:</b> the geometry is formatted as a STC-S expression.</li> </ul>
 * @param colValue	A column value as provided by a {@link ResultSet}.
 * @return	The formatted column value.
 * @throws DataReadException	In case a formatting can not be performed.
 * @since 2.1
 */
protected Object formatColValue(Object colValue) throws DataReadException {
  if (colValue != null) {
    DBType colType=getColType();
    if (colValue instanceof Timestamp)     colValue=ISO8601Format.format(((Timestamp)colValue).getTime());
 else     if (colType != null && colValue != null && colType.type == DBDatatype.CHAR && (colType.length == 1 || colType.length <= 0) && colValue instanceof String)     colValue=((String)colValue).charAt(0);
 else     if (translator != null && colType != null && colType.isGeometry()) {
      try {
        Region region=translator.translateGeometryFromDB(colValue);
        if (region != null)         colValue=region.toSTCS();
      }
 catch (      ParseException pe) {
        throw new DataReadException(pe.getMessage());
      }
    }
  }
  return colValue;
}","/** 
 * <p>Format the given column value.</p> <p> This function should be overwritten if a different or additional formatting should be performed before, after or instead of the one implemented here by default. </p> <p>By default, the following function performs the following formatting:</p> <ul> <li><b>If   {@link Timestamp}:</b> the date-time is converted into a string with the ISO8601 format (see   {@link ISO8601Format}).</li> <li><b>If a single CHAR is declared and a String is given:</b> only the first character is returned as a   {@link Character} object.</li><li><b>If the value is declared as a Geometry:</b> the geometry is formatted as a STC-S expression.</li> </ul>
 * @param colValue	A column value as provided by a {@link ResultSet}.
 * @return	The formatted column value.
 * @throws DataReadException	In case a formatting can not be performed.
 * @since 2.1
 */
protected Object formatColValue(Object colValue) throws DataReadException {
  if (colValue != null) {
    DBType colType=getColType();
    if (colValue instanceof Timestamp)     colValue=ISO8601Format.format(((Timestamp)colValue).getTime());
 else     if (colValue instanceof Boolean)     colValue=((Boolean)colValue) ? 1 : 0;
 else     if (colType != null && colValue != null && colType.type == DBDatatype.CHAR && (colType.length == 1 || colType.length <= 0) && colValue instanceof String)     colValue=((String)colValue).charAt(0);
 else     if (translator != null && colType != null && colType.isGeometry()) {
      try {
        Region region=translator.translateGeometryFromDB(colValue);
        if (region != null)         colValue=region.toSTCS();
      }
 catch (      ParseException pe) {
        throw new DataReadException(pe.getMessage());
      }
    }
  }
  return colValue;
}",0.9754122071159964
25019,"@Override public void logUWS(LogLevel level,Object obj,String event,String message,Throwable error){
  if (level == null)   level=(error != null) ? LogLevel.ERROR : LogLevel.INFO;
  if (!canLog(level))   return;
  String report=null;
  if (event != null && event.equalsIgnoreCase(""String_Node_Str"") && obj != null && obj.getClass().getName().equals(""String_Node_Str"")) {
    int[] backupReport=(int[])obj;
    report=""String_Node_Str"" + backupReport[0] + ""String_Node_Str""+ backupReport[1]+ ""String_Node_Str""+ backupReport[2]+ ""String_Node_Str""+ backupReport[3]+ ""String_Node_Str"";
  }
 else   if (event != null && event.equalsIgnoreCase(""String_Node_Str"") && obj != null && obj.getClass().getName().equals(""String_Node_Str"")) {
    int[] restoreReport=(int[])obj;
    report=""String_Node_Str"" + restoreReport[0] + ""String_Node_Str""+ restoreReport[1]+ ""String_Node_Str""+ restoreReport[2]+ ""String_Node_Str""+ restoreReport[3]+ ""String_Node_Str"";
  }
  log(level,""String_Node_Str"",event,null,message,report,error);
}","@Override public void logUWS(LogLevel level,Object obj,String event,String message,Throwable error){
  if (level == null)   level=(error != null) ? LogLevel.ERROR : LogLevel.INFO;
  if (!canLog(level))   return;
  String report=null;
  if (event != null && event.equalsIgnoreCase(""String_Node_Str"") && obj != null && obj.getClass().getName().equals(""String_Node_Str"")) {
    int[] backupReport=(int[])obj;
    if (backupReport.length == 2)     report=""String_Node_Str"" + backupReport[0] + ""String_Node_Str""+ backupReport[1]+ ""String_Node_Str"";
 else     report=""String_Node_Str"" + backupReport[0] + ""String_Node_Str""+ backupReport[1]+ ""String_Node_Str""+ backupReport[2]+ ""String_Node_Str""+ backupReport[3]+ ""String_Node_Str"";
  }
 else   if (event != null && event.equalsIgnoreCase(""String_Node_Str"") && obj != null && obj.getClass().getName().equals(""String_Node_Str"")) {
    int[] restoreReport=(int[])obj;
    report=""String_Node_Str"" + restoreReport[0] + ""String_Node_Str""+ restoreReport[1]+ ""String_Node_Str""+ restoreReport[2]+ ""String_Node_Str""+ restoreReport[3]+ ""String_Node_Str"";
  }
  log(level,""String_Node_Str"",event,null,message,report,error);
}",0.8664825046040515
25020,"/** 
 * @deprecated since 1.4 ; Former version's mistake: an ORDER BY item is either a regular/delimited column name or an integer, not a qualified column name ; Replaced by {@link #createOrder(Identifier,boolean)} ; This function is no longer used by ADQLParser. 
 */
@Deprecated public ADQLOrder createOrder(final IdentifierItems idItems,final boolean desc) throws Exception {
  ADQLOrder order=new ADQLOrder(idItems.join(""String_Node_Str""),desc);
  if (order != null)   order.setCaseSensitive(idItems.getColumnCaseSensitivity());
  return order;
}","/** 
 * @deprecated since 1.4 ; Former version's mistake: an ORDER BY item is either a regular/delimited column name or an integer, not a qualified column name ; Replaced by {@link #createOrder(IdentifierItem,boolean)} ; This function is no longer used by ADQLParser. 
 */
@Deprecated public ADQLOrder createOrder(final IdentifierItems idItems,final boolean desc) throws Exception {
  ADQLOrder order=new ADQLOrder(idItems.join(""String_Node_Str""),desc);
  if (order != null)   order.setCaseSensitive(idItems.getColumnCaseSensitivity());
  return order;
}",0.9963768115942028
25021,"/** 
 * Sets the position at which this   {@link ADQLList} has been found in the original ADQL query string.
 * @param pos	Position of this {@link ADQLList}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}","/** 
 * Sets the position at which this   {@link ADQLList} has been found in the original ADQL query string.
 * @param position	Position of this {@link ADQLList}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}",0.9905838041431262
25022,"/** 
 * Sets the position at which this   {@link NegativeOperand} has been found in the original ADQL query string.
 * @param pos	Position of this {@link NegativeOperand}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}","/** 
 * Sets the position at which this   {@link NegativeOperand} has been found in the original ADQL query string.
 * @param position	Position of this {@link NegativeOperand}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}",0.9910554561717352
25023,"/** 
 * Sets the position at which this   {@link NumericConstant} has been found in the original ADQL query string.
 * @param pos	Position of this {@link NumericConstant}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}","/** 
 * Sets the position at which this   {@link NumericConstant} has been found in the original ADQL query string.
 * @param position	Position of this {@link NumericConstant}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}",0.9910554561717352
25024,"/** 
 * Sets the position at which this   {@link WrappedOperand} has been found in the original ADQL query string.
 * @param pos	Position of this {@link WrappedOperand}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}","/** 
 * Sets the position at which this   {@link WrappedOperand} has been found in the original ADQL query string.
 * @param position	Position of this {@link WrappedOperand}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}",0.990990990990991
25025,"/** 
 * Sets the position at which this   {@link StringConstant} has been found in the original ADQL query string.
 * @param pos	Position of this {@link StringConstant}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}","/** 
 * Sets the position at which this   {@link StringConstant} has been found in the original ADQL query string.
 * @param position	Position of this {@link StringConstant}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}",0.990990990990991
25026,"/** 
 * Sets the position at which this   {@link WrappedOperand} has been found in the original ADQL query string.
 * @param pos	Position of this {@link WrappedOperand}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}","/** 
 * Sets the position at which this   {@link WrappedOperand} has been found in the original ADQL query string.
 * @param position	Position of this {@link WrappedOperand}.
 * @since 1.4
 */
public final void setPosition(final TextPosition position){
  this.position=position;
}",0.990990990990991
25027,"@Override public synchronized TableIterator executeQuery(final ADQLQuery adqlQuery) throws DBException {
  resetCancel();
  String sql=null;
  ResultSet result=null;
  try {
    if (logger != null)     logger.logDB(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + adqlQuery.toADQL().replaceAll(""String_Node_Str"",""String_Node_Str""),null);
    sql=translator.translate(adqlQuery);
    if (supportsFetchSize && fetchSize > 0) {
      try {
        connection.setAutoCommit(false);
      }
 catch (      SQLException se) {
        if (!isCancelled()) {
          supportsFetchSize=false;
          if (logger != null)           logger.logDB(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"",null);
        }
      }
    }
    getStatement();
    if (supportsFetchSize) {
      try {
        stmt.setFetchSize(fetchSize);
      }
 catch (      SQLException se) {
        if (!isCancelled()) {
          supportsFetchSize=false;
          if (logger != null)           logger.logDB(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"",null);
        }
      }
    }
    if (logger != null)     logger.logDB(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + sql.replaceAll(""String_Node_Str"",""String_Node_Str""),null);
    result=stmt.executeQuery(sql);
    if (logger != null)     logger.logDB(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + (supportsFetchSize ? ""String_Node_Str"" + fetchSize : ""String_Node_Str"") + ""String_Node_Str"",null);
    return createTableIterator(result,adqlQuery.getResultingColumns());
  }
 catch (  SQLException se) {
    close(result);
    closeStatement();
    if (!isCancelled() && logger != null)     logger.logDB(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"",null);
    throw new DBException(""String_Node_Str"" + se.getMessage(),se);
  }
catch (  TranslationException te) {
    close(result);
    closeStatement();
    if (logger != null)     logger.logDB(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"",null);
    throw new DBException(""String_Node_Str"" + te.getMessage(),te);
  }
catch (  DataReadException dre) {
    close(result);
    closeStatement();
    if (logger != null)     logger.logDB(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"",null);
    throw new DBException(""String_Node_Str"" + dre.getMessage(),dre);
  }
}","@Override public synchronized TableIterator executeQuery(final ADQLQuery adqlQuery) throws DBException {
  resetCancel();
  String sql=null;
  ResultSet result=null;
  try {
    if (logger != null)     logger.logDB(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + adqlQuery.toADQL().replaceAll(""String_Node_Str"",""String_Node_Str""),null);
    sql=translator.translate(adqlQuery);
    if (supportsTransaction && supportsFetchSize && fetchSize > 0) {
      try {
        connection.setAutoCommit(false);
      }
 catch (      SQLException se) {
        if (!isCancelled()) {
          supportsFetchSize=false;
          if (logger != null)           logger.logDB(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"",null);
        }
      }
    }
    getStatement();
    if (supportsFetchSize) {
      try {
        stmt.setFetchSize(fetchSize);
      }
 catch (      SQLException se) {
        if (!isCancelled()) {
          supportsFetchSize=false;
          if (logger != null)           logger.logDB(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"",null);
        }
      }
    }
    if (logger != null)     logger.logDB(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + sql.replaceAll(""String_Node_Str"",""String_Node_Str""),null);
    result=stmt.executeQuery(sql);
    if (logger != null)     logger.logDB(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + (supportsFetchSize ? ""String_Node_Str"" + fetchSize : ""String_Node_Str"") + ""String_Node_Str"",null);
    return createTableIterator(result,adqlQuery.getResultingColumns());
  }
 catch (  SQLException se) {
    close(result);
    closeStatement();
    if (!isCancelled() && logger != null)     logger.logDB(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"",null);
    throw new DBException(""String_Node_Str"" + se.getMessage(),se);
  }
catch (  TranslationException te) {
    close(result);
    closeStatement();
    if (logger != null)     logger.logDB(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"",null);
    throw new DBException(""String_Node_Str"" + te.getMessage(),te);
  }
catch (  DataReadException dre) {
    close(result);
    closeStatement();
    if (logger != null)     logger.logDB(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"",null);
    throw new DBException(""String_Node_Str"" + dre.getMessage(),dre);
  }
 finally {
    if (supportsFetchSize && fetchSize > 0) {
      rollback();
      endTransaction();
    }
  }
}",0.9722689075630252
25028,"/** 
 * <p>Process the ADQL query.</p> <p>This function calls the following function (in the same order):</p> <ol> <li>  {@link TAPFactory#getConnection(String)}</li> <li>  {@link #uploadTables()}</li> <li>  {@link #parseADQL()}</li> <li>  {@link #executeADQL(ADQLQuery)}</li> <li>  {@link #writeResult(TableIterator)}</li> <li>  {@link #dropUploadedTables()}</li> <li>  {@link TAPFactory#freeConnection(DBConnection)}</li> </ol> <p> The execution report is updated gradually. Besides a job parameter - progression - is set at each step of the process in order to notify the user of the progression of the query execution. This parameter is removed at the end of the execution if it is successful. </p> <p>The ""interrupted"" flag of the associated thread is often tested so that stopping the execution as soon as possible.</p>
 * @return	The updated execution report.
 * @throws TAPException			If any error occurs while executing the ADQL query.
 * @throws UWSException			If any error occurs while executing the ADQL query.
 * @throws IOException			If an error happens while writing the result in the specified {@link HttpServletResponse}. <i>That kind of error can be thrown only in synchronous mode. In asynchronous, the error is stored as job error report and is never propagated.</i>
 * @throws InterruptedException	If the job has been interrupted (by the user or a time-out).
 */
protected final TAPExecutionReport start() throws TAPException, UWSException, IOException, InterruptedException {
  logger.logTAP(LogLevel.INFO,report,""String_Node_Str"",(report.synchronous ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"",null);
  long start=System.currentTimeMillis();
  TableIterator queryResult=null;
  try {
    initDBConnection(report.jobID);
    if (tapParams.getUploadedTables() != null && tapParams.getUploadedTables().length > 0) {
      startStep(ExecutionProgression.UPLOADING);
      uploadTables();
      endStep();
    }
    if (thread.isInterrupted())     throw new InterruptedException();
    startStep(ExecutionProgression.PARSING);
    ADQLQuery adqlQuery=null;
    try {
      adqlQuery=parseADQL();
    }
 catch (    ParseException pe) {
      if (report.synchronous)       throw new TAPException(""String_Node_Str"" + pe.getMessage(),pe,UWSException.BAD_REQUEST,tapParams.getQuery(),progression);
 else       throw new UWSException(UWSException.BAD_REQUEST,pe,""String_Node_Str"" + pe.getMessage());
    }
    report.resultingColumns=adqlQuery.getResultingColumns();
    endStep();
    if (thread.isInterrupted())     throw new InterruptedException();
    startStep(ExecutionProgression.EXECUTING_ADQL);
    queryResult=executeADQL(adqlQuery);
    endStep();
    if (thread.isInterrupted())     throw new InterruptedException();
    startStep(ExecutionProgression.WRITING_RESULT);
    writeResult(queryResult);
    endStep();
    tapParams.remove(TAPJob.PARAM_PROGRESSION);
    report.success=true;
    report.setTotalDuration(System.currentTimeMillis() - start);
    logger.logTAP(LogLevel.INFO,report,""String_Node_Str"",""String_Node_Str"",null);
    return report;
  }
  finally {
    if (queryResult != null) {
      try {
        queryResult.close();
      }
 catch (      DataReadException dre) {
        logger.logTAP(LogLevel.WARNING,report,""String_Node_Str"",""String_Node_Str"",dre);
      }
    }
    try {
      dropUploadedTables();
    }
 catch (    TAPException e) {
      logger.logTAP(LogLevel.WARNING,report,""String_Node_Str"",""String_Node_Str"",e);
    }
    if (dbConn != null) {
      dbConn.cancel(true);
      service.getFactory().freeConnection(dbConn);
      dbConn=null;
    }
  }
}","/** 
 * <p>Process the ADQL query.</p> <p>This function calls the following function (in the same order):</p> <ol> <li>  {@link TAPFactory#getConnection(String)}</li> <li>  {@link #uploadTables()}</li> <li>  {@link #parseADQL()}</li> <li>  {@link #executeADQL(ADQLQuery)}</li> <li>  {@link #writeResult(TableIterator)}</li> <li>  {@link #dropUploadedTables()}</li> <li>  {@link TAPFactory#freeConnection(DBConnection)}</li> </ol> <p> The execution report is updated gradually. Besides a job parameter - progression - is set at each step of the process in order to notify the user of the progression of the query execution. This parameter is removed at the end of the execution if it is successful. </p> <p>The ""interrupted"" flag of the associated thread is often tested so that stopping the execution as soon as possible.</p>
 * @return	The updated execution report.
 * @throws TAPException			If any error occurs while executing the ADQL query.
 * @throws UWSException			If any error occurs while executing the ADQL query.
 * @throws IOException			If an error happens while writing the result in the specified {@link HttpServletResponse}. <i>That kind of error can be thrown only in synchronous mode. In asynchronous, the error is stored as job error report and is never propagated.</i>
 * @throws InterruptedException	If the job has been interrupted (by the user or a time-out).
 */
protected final TAPExecutionReport start() throws TAPException, UWSException, IOException, InterruptedException {
  logger.logTAP(LogLevel.INFO,report,""String_Node_Str"",(report.synchronous ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"",null);
  long start=System.currentTimeMillis();
  TableIterator queryResult=null;
  try {
    initDBConnection(report.jobID);
    if (tapParams.getUploadedTables() != null && tapParams.getUploadedTables().length > 0) {
      startStep(ExecutionProgression.UPLOADING);
      uploadTables();
      endStep();
    }
    if (thread.isInterrupted())     throw new InterruptedException();
    startStep(ExecutionProgression.PARSING);
    ADQLQuery adqlQuery=null;
    try {
      adqlQuery=parseADQL();
    }
 catch (    ParseException pe) {
      if (report.synchronous)       throw new TAPException(""String_Node_Str"" + pe.getMessage(),pe,UWSException.BAD_REQUEST,tapParams.getQuery(),progression);
 else       throw new UWSException(UWSException.BAD_REQUEST,pe,""String_Node_Str"" + pe.getMessage());
    }
    report.resultingColumns=adqlQuery.getResultingColumns();
    endStep();
    if (thread.isInterrupted())     throw new InterruptedException();
    startStep(ExecutionProgression.EXECUTING_ADQL);
    queryResult=executeADQL(adqlQuery);
    endStep();
    if (thread.isInterrupted())     throw new InterruptedException();
    startStep(ExecutionProgression.WRITING_RESULT);
    writeResult(queryResult);
    endStep();
    tapParams.remove(TAPJob.PARAM_PROGRESSION);
    report.success=true;
    report.setTotalDuration(System.currentTimeMillis() - start);
    logger.logTAP(LogLevel.INFO,report,""String_Node_Str"",""String_Node_Str"",null);
    return report;
  }
  finally {
    if (queryResult != null) {
      try {
        queryResult.close();
      }
 catch (      DataReadException dre) {
        logger.logTAP(LogLevel.WARNING,report,""String_Node_Str"",""String_Node_Str"",dre);
      }
    }
    try {
      dropUploadedTables();
    }
 catch (    TAPException e) {
      logger.logTAP(LogLevel.WARNING,report,""String_Node_Str"",""String_Node_Str"",e);
    }
    if (dbConn != null) {
      service.getFactory().freeConnection(dbConn);
      dbConn=null;
    }
  }
}",0.9849260129995852
25029,"@Override public void freeConnection(DBConnection conn){
  try {
    conn.cancel(true);
    ((JDBCConnection)conn).getInnerConnection().close();
  }
 catch (  SQLException se) {
    service.getLogger().error(""String_Node_Str"" + conn.getID() + ""String_Node_Str"",se);
  }
}","@Override public void freeConnection(DBConnection conn){
  try {
    conn.endQuery();
    ((JDBCConnection)conn).getInnerConnection().close();
  }
 catch (  SQLException se) {
    service.getLogger().error(""String_Node_Str"" + conn.getID() + ""String_Node_Str"",se);
  }
}",0.9703703703703704
25030,"@Override public Object nextCol() throws NoSuchElementException, IllegalStateException, DataReadException {
  if (!hasNextCol())   throw new NoSuchElementException(""String_Node_Str"");
  try {
    Object o=data.getObject(++colIndex);
    if (o != null) {
      DBType colType=getColType();
      if (o instanceof Timestamp)       o=ISO8601Format.format(((Timestamp)o).getTime());
 else       if (translator != null && colType != null && colType.isGeometry()) {
        Region region=translator.translateGeometryFromDB(o);
        if (region != null)         o=region.toSTCS();
      }
    }
    return o;
  }
 catch (  SQLException se) {
    throw new DataReadException(""String_Node_Str"" + colIndex + ""String_Node_Str"",se);
  }
catch (  ParseException pe) {
    throw new DataReadException(pe.getMessage());
  }
}","@Override public Object nextCol() throws NoSuchElementException, IllegalStateException, DataReadException {
  if (!hasNextCol())   throw new NoSuchElementException(""String_Node_Str"");
  try {
    Object o=data.getObject(++colIndex);
    if (o != null) {
      DBType colType=getColType();
      if (o instanceof Timestamp)       o=ISO8601Format.format(((Timestamp)o).getTime());
 else       if (colType != null && o != null && colType.type == DBDatatype.CHAR && (colType.length == 1 || colType.length <= 0) && o instanceof String)       o=((String)o).charAt(0);
 else       if (translator != null && colType != null && colType.isGeometry()) {
        Region region=translator.translateGeometryFromDB(o);
        if (region != null)         o=region.toSTCS();
      }
    }
    return o;
  }
 catch (  SQLException se) {
    throw new DataReadException(""String_Node_Str"" + colIndex + ""String_Node_Str"",se);
  }
catch (  ParseException pe) {
    throw new DataReadException(pe.getMessage());
  }
}",0.8987271721084671
25031,"/** 
 * <p>Tells whether this type is a geometrical region.</p> <p><i>Concerned types:  {@link DBDatatype#POINT POINT} and {@link DBDatatype#REGION REGION}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.That's why, this function will also returned <code>true</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a geometry, <code>false</code> otherwise.
 */
public boolean isGeometry(){
  return (type == DBDatatype.POINT || type == DBDatatype.REGION || type == DBDatatype.UNKNOWN);
}","/** 
 * <p>Tells whether this type is a geometrical region.</p> <p><i>Concerned types:  {@link DBDatatype#POINT POINT} and {@link DBDatatype#REGION REGION}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.But, in order to avoid incorrect operation while expecting a geometry although the type is unknown and is in fact not really a geometry, this function will return <code>false</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a geometry, <code>false</code> otherwise.
 */
public boolean isGeometry(){
  return (type == DBDatatype.POINT || type == DBDatatype.REGION);
}",0.8470066518847007
25032,"/** 
 * <p>Tells whether this type is a numeric.</p> <p><i>Concerned types:  {@link DBDatatype#SMALLINT SMALLINT},   {@link DBDatatype#INTEGER INTEGER},   {@link DBDatatype#BIGINT BIGINT},  {@link DBDatatype#REAL REAL},   {@link DBDatatype#DOUBLE DOUBLE},   {@link DBDatatype#BINARY BINARY},  {@link DBDatatype#VARBINARY VARBINARY} and {@link DBDatatype#BLOB BLOB}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.That's why, this function will also returned <code>true</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a numeric, <code>false</code> otherwise.
 */
public boolean isNumeric(){
switch (type) {
case SMALLINT:
case INTEGER:
case BIGINT:
case REAL:
case DOUBLE:
case BINARY:
case VARBINARY:
case BLOB:
case UNKNOWN:
    return true;
default :
  return false;
}
}","/** 
 * <p>Tells whether this type is a numeric.</p> <p><i>Concerned types:  {@link DBDatatype#SMALLINT SMALLINT},   {@link DBDatatype#INTEGER INTEGER},   {@link DBDatatype#BIGINT BIGINT},  {@link DBDatatype#REAL REAL},   {@link DBDatatype#DOUBLE DOUBLE},   {@link DBDatatype#BINARY BINARY},  {@link DBDatatype#VARBINARY VARBINARY} and {@link DBDatatype#BLOB BLOB}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.But, in order to avoid incorrect operation while expecting a numeric although the type is unknown and is in fact not really a numeric, this function will return <code>false</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a numeric, <code>false</code> otherwise.
 */
public boolean isNumeric(){
switch (type) {
case SMALLINT:
case INTEGER:
case BIGINT:
case REAL:
case DOUBLE:
case BINARY:
case VARBINARY:
case BLOB:
    return true;
default :
  return false;
}
}",0.8621219887237315
25033,"/** 
 * <p>Tells whether this type is a list of bytes.</p> <p><i>Concerned types:  {@link DBDatatype#BINARY BINARY},   {@link DBDatatype#VARBINARY VARBINARY} and {@link DBDatatype#BLOB BLOB}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.That's why, this function will also returned <code>true</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a binary, <code>false</code> otherwise.
 */
public boolean isBinary(){
switch (type) {
case BINARY:
case VARBINARY:
case BLOB:
case UNKNOWN:
    return true;
default :
  return false;
}
}","/** 
 * <p>Tells whether this type is a list of bytes.</p> <p><i>Concerned types:  {@link DBDatatype#BINARY BINARY},   {@link DBDatatype#VARBINARY VARBINARY} and {@link DBDatatype#BLOB BLOB}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.But, in order to avoid incorrect operation while expecting a binary although the type is unknown and is in fact not really a binary, this function will return <code>false</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a binary, <code>false</code> otherwise.
 */
public boolean isBinary(){
switch (type) {
case BINARY:
case VARBINARY:
case BLOB:
    return true;
default :
  return false;
}
}",0.8232081911262799
25034,"/** 
 * <p>Tells whether this type is about characters.</p> <p><i>Concerned types:  {@link DBDatatype#CHAR CHAR},   {@link DBDatatype#VARCHAR VARCHAR},   {@link DBDatatype#CLOB CLOB}and   {@link DBDatatype#TIMESTAMP TIMESTAMP}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.That's why, this function will also returned <code>true</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a string, <code>false</code> otherwise.
 */
public boolean isString(){
switch (type) {
case CHAR:
case VARCHAR:
case CLOB:
case TIMESTAMP:
case UNKNOWN:
    return true;
default :
  return false;
}
}","/** 
 * <p>Tells whether this type is about characters.</p> <p><i>Concerned types:  {@link DBDatatype#CHAR CHAR},   {@link DBDatatype#VARCHAR VARCHAR},   {@link DBDatatype#CLOB CLOB}and   {@link DBDatatype#TIMESTAMP TIMESTAMP}. </i></p> <p><i><b>Important note</b>: Since   {@link DBDatatype#UNKNOWN UNKNOWN} is an unresolved type, it can potentially be anything.But, in order to avoid incorrect operation while expecting a string although the type is unknown and is in fact not really a string, this function will return <code>false</code> if the type is {@link DBDatatype#UNKNOWN UNKNOWN}. </i></p>
 * @return	<code>true</code> if this type is a string, <code>false</code> otherwise.
 */
public boolean isString(){
switch (type) {
case CHAR:
case VARCHAR:
case CLOB:
case TIMESTAMP:
    return true;
default :
  return false;
}
}",0.8327994875080077
25035,"public FunctionDef(final String fctName,final DBType returnType,final FunctionParam[] params){
  if (fctName == null)   throw new NullPointerException(""String_Node_Str"");
  this.name=fctName;
  this.params=(params == null || params.length == 0) ? null : params;
  this.nbParams=(params == null) ? 0 : params.length;
  this.returnType=(returnType != null) ? returnType : new DBType(DBDatatype.UNKNOWN);
  isUnknown=this.returnType.isUnknown();
  isNumeric=isUnknown || this.returnType.isNumeric();
  isString=isUnknown || this.returnType.isString();
  isGeometry=isUnknown || this.returnType.isGeometry();
  StringBuffer bufSer=new StringBuffer(name), bufCmp=new StringBuffer(name.toLowerCase());
  bufSer.append('(');
  for (int i=0; i < nbParams; i++) {
    bufSer.append(params[i].name).append(' ').append(params[i].type);
    bufCmp.append(params[i].type.isNumeric() ? '1' : '0').append(params[i].type.isString() ? '1' : '0').append(params[i].type.isGeometry() ? '1' : '0');
    if (i + 1 < nbParams)     bufSer.append(""String_Node_Str"");
  }
  bufSer.append(')');
  if (returnType != null)   bufSer.append(""String_Node_Str"").append(returnType);
  serializedForm=bufSer.toString();
  compareForm=bufCmp.toString();
}","public FunctionDef(final String fctName,final DBType returnType,final FunctionParam[] params){
  if (fctName == null)   throw new NullPointerException(""String_Node_Str"");
  this.name=fctName;
  this.params=(params == null || params.length == 0) ? null : params;
  this.nbParams=(params == null) ? 0 : params.length;
  this.returnType=(returnType != null) ? returnType : new DBType(DBDatatype.UNKNOWN);
  isUnknown=this.returnType.isUnknown();
  isNumeric=this.returnType.isNumeric();
  isString=this.returnType.isString();
  isGeometry=this.returnType.isGeometry();
  StringBuffer bufSer=new StringBuffer(name), bufCmp=new StringBuffer(name.toLowerCase());
  bufSer.append('(');
  for (int i=0; i < nbParams; i++) {
    bufSer.append(params[i].name).append(' ').append(params[i].type);
    bufCmp.append(params[i].type.isNumeric() ? '1' : '0').append(params[i].type.isString() ? '1' : '0').append(params[i].type.isGeometry() ? '1' : '0');
    if (i + 1 < nbParams)     bufSer.append(""String_Node_Str"");
  }
  bufSer.append(')');
  if (returnType != null)   bufSer.append(""String_Node_Str"").append(returnType);
  serializedForm=bufSer.toString();
  compareForm=bufCmp.toString();
}",0.98374322634431
25036,"/** 
 * <p>Compare this function definition with the given ADQL function item.</p> <p> The comparison is done only on the function name and on rough type of the parameters. ""Rough type"" means here that just the kind of type is tested: numeric, string or geometry. Anyway, the return type is never tested by this function, since such information is usually not part of a function signature. </p> <p>The notion of ""greater"" and ""less"" are defined here according to the three following test steps:</p> <ol> <li><b>Name test:</b> if the name of both function are equals, next steps are evaluated, otherwise the standard string comparison (case insensitive) result is returned.</li> <li><b>Parameters test:</b> parameters are compared individually. Each time parameters (at the same position in both functions) are equals the next parameter can be tested, and so on until two parameters are different or the end of the parameters' list is reached. Just the kind of type is used for parameter comparison. Each kind of type is tested in the following order: numeric, string and geometry. When a kind of type is not equal for both parameters, the function exits with the appropriate value (1 if the parameter of this function definition is of the kind of type, -1 otherwise).</li> <li><b>Number of parameters test:</b> in the case where this function definition has N parameters and the given ADQL function has M parameters, and that the L (= min(N,M)) first parameters have the same type in both functions, the value returns by this function will be N-M. Thus, if this function definition has more parameters than the given function, a positive value will be returned. Otherwise a negative value will be returned, or 0 if the number of parameters is the same.</li> </ol>
 * @param fct	ADQL function item to compare with this function definition.
 * @return	A positive value if this function definition is ""greater"" than the given {@link ADQLFunction}, 0 if they are perfectly matching, or a negative value if this function definition is ""less"" than the given   {@link ADQLFunction}.
 */
public int compareTo(final ADQLFunction fct){
  if (fct == null)   throw new NullPointerException(""String_Node_Str"");
  int comp=name.compareToIgnoreCase(fct.getName());
  if (comp == 0) {
    for (int i=0; comp == 0 && i < nbParams && i < fct.getNbParameters(); i++) {
      if (fct.getParameter(i).isNumeric() && fct.getParameter(i).isString() && fct.getParameter(i).isGeometry())       comp=0;
 else       if (params[i].type.isNumeric() == fct.getParameter(i).isNumeric()) {
        if (params[i].type.isString() == fct.getParameter(i).isString()) {
          if (params[i].type.isGeometry() == fct.getParameter(i).isGeometry())           comp=0;
 else           comp=params[i].type.isGeometry() ? 1 : -1;
        }
 else         comp=params[i].type.isString() ? 1 : -1;
      }
 else       comp=params[i].type.isNumeric() ? 1 : -1;
    }
    if (comp == 0 && nbParams != fct.getNbParameters())     comp=nbParams - fct.getNbParameters();
  }
  return comp;
}","/** 
 * <p>Compare this function definition with the given ADQL function item.</p> <p> The comparison is done only on the function name and on rough type of the parameters. ""Rough type"" means here that just the kind of type is tested: numeric, string or geometry. Anyway, the return type is never tested by this function, since such information is usually not part of a function signature. </p> <p>The notions of ""greater"" and ""less"" are defined here according to the three following test steps:</p> <ol> <li><b>Name test:</b> if the name of both function are equals, next steps are evaluated, otherwise the standard string comparison (case insensitive) result is returned.</li> <li><b>Parameters test:</b> parameters are compared individually. Each time parameters (at the same position in both functions) are equals the next parameter can be tested, and so on until two parameters are different or the end of the parameters' list is reached. Just the kind of type is used for parameter comparison. Each kind of type is tested in the following order: numeric, string and geometry. When a kind of type is not equal for both parameters, the function exits with the appropriate value (1 if the parameter of this function definition is of the kind of type, -1 otherwise).</li> <li><b>Number of parameters test:</b> in the case where this function definition has N parameters and the given ADQL function has M parameters, and that the L (= min(N,M)) first parameters have the same type in both functions, the value returns by this function will be N-M. Thus, if this function definition has more parameters than the given function, a positive value will be returned. Otherwise a negative value will be returned, or 0 if the number of parameters is the same.</li> </ol> <p><i><b>Note:</b> If one of the tested types (i.e. parameters types) is unknown, the match should return 0 (i.e. equality). The notion of ""unknown"" is different in function of the tested item. A   {@link DBType} is unknown if its function{@link DBType#isUnknown()} returns <code>true</code> ; thus, its other functions such as {@link DBType#isNumeric()} willreturn <code>false</code>. On the contrary, an  {@link ADQLOperand} does not have any isUnknown()function. However, when the type of a such is unknown, all its functions isNumeric(), isString() and isGeometry() return <code>true</code>. </i></p>
 * @param fct	ADQL function item to compare with this function definition.
 * @return	A positive value if this function definition is ""greater"" than the given {@link ADQLFunction}, 0 if they are perfectly matching or one of the tested types (i.e. parameters types) is unknown, or a negative value if this function definition is ""less"" than the given   {@link ADQLFunction}.
 */
public int compareTo(final ADQLFunction fct){
  if (fct == null)   throw new NullPointerException(""String_Node_Str"");
  int comp=name.compareToIgnoreCase(fct.getName());
  if (comp == 0) {
    for (int i=0; comp == 0 && i < nbParams && i < fct.getNbParameters(); i++) {
      if (params[i].type.isUnknown() || (fct.getParameter(i).isNumeric() && fct.getParameter(i).isString() && fct.getParameter(i).isGeometry()))       comp=0;
 else       if (params[i].type.isNumeric() == fct.getParameter(i).isNumeric()) {
        if (params[i].type.isString() == fct.getParameter(i).isString()) {
          if (params[i].type.isGeometry() == fct.getParameter(i).isGeometry())           comp=0;
 else           comp=params[i].type.isGeometry() ? 1 : -1;
        }
 else         comp=params[i].type.isString() ? 1 : -1;
      }
 else       comp=params[i].type.isNumeric() ? 1 : -1;
    }
    if (comp == 0 && nbParams != fct.getNbParameters())     comp=nbParams - fct.getNbParameters();
  }
  return comp;
}",0.8967856089649071
25037,"@Override public boolean isGeometry(){
  return (dbLink == null || dbLink.getDatatype() == null || dbLink.getDatatype().isGeometry());
}","@Override public boolean isGeometry(){
  return (dbLink == null || dbLink.getDatatype() == null || dbLink.getDatatype().isUnknown() || dbLink.getDatatype().isGeometry());
}",0.8831168831168831
25038,"@Override public boolean isString(){
  return (dbLink == null || dbLink.getDatatype() == null || dbLink.getDatatype().isString());
}","@Override public boolean isString(){
  return (dbLink == null || dbLink.getDatatype() == null || dbLink.getDatatype().isUnknown() || dbLink.getDatatype().isString());
}",0.88
25039,"@Override public boolean isNumeric(){
  return (dbLink == null || dbLink.getDatatype() == null || dbLink.getDatatype().isNumeric());
}","@Override public boolean isNumeric(){
  return (dbLink == null || dbLink.getDatatype() == null || dbLink.getDatatype().isUnknown() || dbLink.getDatatype().isNumeric());
}",0.881578947368421
25040,"/** 
 * Try to get or otherwise to build appropriate metadata using those extracted from the ADQL query and those extracted from the result.
 * @param typeFromQuery		Metadata extracted/guessed from the ADQL query.
 * @param typeFromResult	Metadata extracted/guessed from the result.
 * @return	The most appropriate metadata.
 */
protected TAPColumn getValidColMeta(final DBColumn typeFromQuery,final TAPColumn typeFromResult){
  if (typeFromQuery != null && typeFromQuery instanceof TAPColumn) {
    TAPColumn colMeta=(TAPColumn)typeFromQuery;
    if (colMeta.getDatatype().type == DBDatatype.UNKNOWN && typeFromResult != null && typeFromResult.getDatatype().type != DBDatatype.UNKNOWN)     colMeta.setDatatype(typeFromResult.getDatatype());
    return colMeta;
  }
 else   if (typeFromResult != null) {
    if (typeFromQuery != null)     return (TAPColumn)typeFromResult.copy(typeFromQuery.getDBName(),typeFromQuery.getADQLName(),null);
 else     return (TAPColumn)typeFromResult.copy();
  }
 else   return new TAPColumn((typeFromQuery != null) ? typeFromQuery.getADQLName() : ""String_Node_Str"",new DBType(DBDatatype.VARCHAR),""String_Node_Str"");
}","/** 
 * Try to get or otherwise to build appropriate metadata using those extracted from the ADQL query and those extracted from the result.
 * @param typeFromQuery		Metadata extracted/guessed from the ADQL query.
 * @param typeFromResult	Metadata extracted/guessed from the result.
 * @return	The most appropriate metadata.
 */
protected TAPColumn getValidColMeta(final DBColumn typeFromQuery,final TAPColumn typeFromResult){
  if (typeFromQuery != null && typeFromQuery instanceof TAPColumn) {
    TAPColumn colMeta=(TAPColumn)typeFromQuery;
    if (colMeta.getDatatype().isUnknown() && typeFromResult != null && !typeFromResult.getDatatype().isUnknown())     colMeta.setDatatype(typeFromResult.getDatatype());
    return colMeta;
  }
 else   if (typeFromResult != null) {
    if (typeFromQuery != null)     return (TAPColumn)typeFromResult.copy(typeFromQuery.getDBName(),typeFromQuery.getADQLName(),null);
 else     return (TAPColumn)typeFromResult.copy();
  }
 else   return new TAPColumn((typeFromQuery != null) ? typeFromQuery.getADQLName() : ""String_Node_Str"",new DBType(DBDatatype.VARCHAR),""String_Node_Str"");
}",0.968681076312307
25041,"/** 
 * Try to get or otherwise to build appropriate metadata using those extracted from the ADQL query and those extracted from the result.
 * @param typeFromQuery		Metadata extracted/guessed from the ADQL query.
 * @param typeFromResult	Metadata extracted/guessed from the result.
 * @return	The most appropriate metadata.
 */
protected static final TAPColumn getValidColMeta(final DBColumn typeFromQuery,final TAPColumn typeFromResult){
  if (typeFromQuery != null && typeFromQuery instanceof TAPColumn) {
    TAPColumn colMeta=(TAPColumn)typeFromQuery;
    if (colMeta.getDatatype().type == DBDatatype.UNKNOWN && typeFromResult != null && typeFromResult.getDatatype().type != DBDatatype.UNKNOWN)     colMeta.setDatatype(typeFromResult.getDatatype());
    return colMeta;
  }
 else   if (typeFromResult != null) {
    if (typeFromQuery != null)     return (TAPColumn)typeFromResult.copy(typeFromQuery.getDBName(),typeFromQuery.getADQLName(),null);
 else     return (TAPColumn)typeFromResult.copy();
  }
 else   return new TAPColumn((typeFromQuery != null) ? typeFromQuery.getADQLName() : ""String_Node_Str"",new DBType(DBDatatype.VARCHAR),""String_Node_Str"");
}","/** 
 * Try to get or otherwise to build appropriate metadata using those extracted from the ADQL query and those extracted from the result.
 * @param typeFromQuery		Metadata extracted/guessed from the ADQL query.
 * @param typeFromResult	Metadata extracted/guessed from the result.
 * @return	The most appropriate metadata.
 */
protected static final TAPColumn getValidColMeta(final DBColumn typeFromQuery,final TAPColumn typeFromResult){
  if (typeFromQuery != null && typeFromQuery instanceof TAPColumn) {
    TAPColumn colMeta=(TAPColumn)typeFromQuery;
    if (colMeta.getDatatype().isUnknown() && typeFromResult != null && !typeFromResult.getDatatype().isUnknown())     colMeta.setDatatype(typeFromResult.getDatatype());
    return colMeta;
  }
 else   if (typeFromResult != null) {
    if (typeFromQuery != null)     return (TAPColumn)typeFromResult.copy(typeFromQuery.getDBName(),typeFromQuery.getADQLName(),null);
 else     return (TAPColumn)typeFromResult.copy();
  }
 else   return new TAPColumn((typeFromQuery != null) ? typeFromQuery.getADQLName() : ""String_Node_Str"",new DBType(DBDatatype.VARCHAR),""String_Node_Str"");
}",0.9690361971216748
25042,"@Test public void testIsNumeric(){
  for (  DBDatatype type : DBDatatype.values()) {
switch (type) {
case CHAR:
case VARCHAR:
case TIMESTAMP:
case POINT:
case REGION:
case CLOB:
      assertFalse(new FunctionDef(""String_Node_Str"",new DBType(type)).isNumeric);
    break;
default :
  assertTrue(new FunctionDef(""String_Node_Str"",new DBType(type)).isNumeric);
}
}
}","@Test public void testIsNumeric(){
  for (  DBDatatype type : DBDatatype.values()) {
switch (type) {
case CHAR:
case VARCHAR:
case TIMESTAMP:
case POINT:
case REGION:
case CLOB:
case UNKNOWN:
      assertFalse(new FunctionDef(""String_Node_Str"",new DBType(type)).isNumeric);
    break;
default :
  assertTrue(new FunctionDef(""String_Node_Str"",new DBType(type)).isNumeric);
}
}
}",0.981081081081081
25043,"@Test public void testIsString(){
  for (  DBDatatype type : DBDatatype.values()) {
switch (type) {
case CHAR:
case VARCHAR:
case TIMESTAMP:
case CLOB:
case UNKNOWN:
      assertTrue(new FunctionDef(""String_Node_Str"",new DBType(type)).isString);
    break;
default :
  assertFalse(new FunctionDef(""String_Node_Str"",new DBType(type)).isString);
}
}
}","@Test public void testIsString(){
  for (  DBDatatype type : DBDatatype.values()) {
switch (type) {
case CHAR:
case VARCHAR:
case TIMESTAMP:
case CLOB:
      assertTrue(new FunctionDef(""String_Node_Str"",new DBType(type)).isString);
    break;
default :
  assertFalse(new FunctionDef(""String_Node_Str"",new DBType(type)).isString);
}
}
}",0.97953216374269
25044,"@Test public void testParse(){
  final String WRONG_FULL_SYNTAX=""String_Node_Str"";
  final String WRONG_PARAM_SYNTAX=""String_Node_Str"";
  try {
    FunctionDef.parse(null);
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof NullPointerException);
    assertEquals(""String_Node_Str"",ex.getMessage());
  }
  try {
    FunctionDef.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof ParseException);
    assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
  }
  try {
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
  try {
    for (    DBDatatype t : DBDatatype.values()) {
switch (t) {
case CHAR:
case VARCHAR:
case BINARY:
case VARBINARY:
        assertEquals(""String_Node_Str"" + t.toString() + ""String_Node_Str"",FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
      break;
default :
    assertEquals(""String_Node_Str"" + t.toString(),FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
}
}
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(""String_Node_Str"",ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertTrue(fct.isString);
assertTrue(fct.isNumeric);
assertTrue(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertTrue(fct.isString);
assertTrue(fct.isNumeric);
assertTrue(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertTrue(fct.getParam(0).type.isString());
assertTrue(fct.getParam(0).type.isNumeric());
assertTrue(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertTrue(fct.getParam(0).type.isString());
assertTrue(fct.getParam(0).type.isNumeric());
assertTrue(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
}","@Test public void testParse(){
  final String WRONG_FULL_SYNTAX=""String_Node_Str"";
  final String WRONG_PARAM_SYNTAX=""String_Node_Str"";
  try {
    FunctionDef.parse(null);
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof NullPointerException);
    assertEquals(""String_Node_Str"",ex.getMessage());
  }
  try {
    FunctionDef.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof ParseException);
    assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
  }
  try {
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
  try {
    for (    DBDatatype t : DBDatatype.values()) {
switch (t) {
case CHAR:
case VARCHAR:
case BINARY:
case VARBINARY:
        assertEquals(""String_Node_Str"" + t.toString() + ""String_Node_Str"",FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
      break;
default :
    assertEquals(""String_Node_Str"" + t.toString(),FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
}
}
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(""String_Node_Str"",ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertFalse(fct.isString);
assertFalse(fct.isNumeric);
assertFalse(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertFalse(fct.isString);
assertFalse(fct.isNumeric);
assertFalse(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertFalse(fct.getParam(0).type.isString());
assertFalse(fct.getParam(0).type.isNumeric());
assertFalse(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertFalse(fct.getParam(0).type.isString());
assertFalse(fct.getParam(0).type.isNumeric());
assertFalse(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
}",0.98364312267658
25045,"@Test public void testIsGeometry(){
  for (  DBDatatype type : DBDatatype.values()) {
switch (type) {
case POINT:
case REGION:
case UNKNOWN:
      assertTrue(new FunctionDef(""String_Node_Str"",new DBType(type)).isGeometry);
    break;
default :
  assertFalse(new FunctionDef(""String_Node_Str"",new DBType(type)).isGeometry);
}
}
}","@Test public void testIsGeometry(){
  for (  DBDatatype type : DBDatatype.values()) {
switch (type) {
case POINT:
case REGION:
      assertTrue(new FunctionDef(""String_Node_Str"",new DBType(type)).isGeometry);
    break;
default :
  assertFalse(new FunctionDef(""String_Node_Str"",new DBType(type)).isGeometry);
}
}
}",0.9781931464174456
25046,"public void testForFctDef(){
  try {
    FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
    assertTrue(fct.isUnknown());
    assertTrue(fct.isString());
    assertTrue(fct.isNumeric());
    assertTrue(fct.isGeometry());
    assertEquals(""String_Node_Str"",fct.returnType.type.toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
  try {
    FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
    assertTrue(fct.getParam(0).type.isUnknown());
    assertTrue(fct.getParam(0).type.isString());
    assertTrue(fct.getParam(0).type.isNumeric());
    assertTrue(fct.getParam(0).type.isGeometry());
    assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
}","public void testForFctDef(){
  try {
    FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
    assertTrue(fct.isUnknown());
    assertFalse(fct.isString());
    assertFalse(fct.isNumeric());
    assertFalse(fct.isGeometry());
    assertEquals(""String_Node_Str"",fct.returnType.type.toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
  try {
    FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
    assertTrue(fct.getParam(0).type.isUnknown());
    assertFalse(fct.getParam(0).type.isString());
    assertFalse(fct.getParam(0).type.isNumeric());
    assertFalse(fct.getParam(0).type.isGeometry());
    assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
}",0.939903846153846
25047,"@Test public void testForColumns(){
  final String QUERY_TXT=""String_Node_Str"";
  try {
    ADQLParser parser=new ADQLParser();
    DefaultDBTable table1=new DefaultDBTable(""String_Node_Str"");
    table1.addColumn(new DefaultDBColumn(""String_Node_Str"",table1));
    table1.addColumn(new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.UNKNOWN),table1));
    Collection<DBTable> tList=Arrays.asList(new DBTable[]{table1});
    DBColumn col=table1.getColumn(""String_Node_Str"",true);
    assertNotNull(col);
    assertNull(col.getDatatype());
    col=table1.getColumn(""String_Node_Str"",true);
    assertNotNull(col);
    assertNotNull(col.getDatatype());
    assertTrue(col.getDatatype().isUnknown());
    assertTrue(col.getDatatype().isNumeric());
    assertTrue(col.getDatatype().isString());
    assertTrue(col.getDatatype().isGeometry());
    assertEquals(""String_Node_Str"",col.getDatatype().toString());
    FunctionDef udf1=FunctionDef.parse(""String_Node_Str"");
    Collection<FunctionDef> udfList=Arrays.asList(new FunctionDef[]{udf1});
    Collection<String> geoList=null;
    Collection<String> csList=null;
    QueryChecker checker=new DBChecker(tList,udfList,geoList,csList);
    ADQLQuery pq=parser.parseQuery(QUERY_TXT);
    checker.check(pq);
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
}","@Test public void testForColumns(){
  final String QUERY_TXT=""String_Node_Str"";
  try {
    ADQLParser parser=new ADQLParser();
    DefaultDBTable table1=new DefaultDBTable(""String_Node_Str"");
    table1.addColumn(new DefaultDBColumn(""String_Node_Str"",table1));
    table1.addColumn(new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.UNKNOWN),table1));
    table1.addColumn(new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.VARCHAR),table1));
    Collection<DBTable> tList=Arrays.asList(new DBTable[]{table1});
    DBColumn col=table1.getColumn(""String_Node_Str"",true);
    assertNotNull(col);
    assertNull(col.getDatatype());
    col=table1.getColumn(""String_Node_Str"",true);
    assertNotNull(col);
    assertNotNull(col.getDatatype());
    assertTrue(col.getDatatype().isUnknown());
    assertFalse(col.getDatatype().isNumeric());
    assertFalse(col.getDatatype().isString());
    assertFalse(col.getDatatype().isGeometry());
    assertEquals(""String_Node_Str"",col.getDatatype().toString());
    FunctionDef udf1=FunctionDef.parse(""String_Node_Str"");
    Collection<FunctionDef> udfList=Arrays.asList(new FunctionDef[]{udf1});
    Collection<String> geoList=null;
    Collection<String> csList=null;
    QueryChecker checker=new DBChecker(tList,udfList,geoList,csList);
    ADQLQuery pq=parser.parseQuery(QUERY_TXT);
    checker.check(pq);
    assertTrue(pq.getSelect().get(0).getOperand().isNumeric());
    assertFalse(pq.getSelect().get(0).getOperand().isString());
    assertFalse(pq.getSelect().get(0).getOperand().isGeometry());
    assertTrue(pq.getSelect().get(1).getOperand().isNumeric());
    assertFalse(pq.getSelect().get(1).getOperand().isString());
    assertFalse(pq.getSelect().get(1).getOperand().isGeometry());
    assertTrue(pq.getSelect().get(2).getOperand().isNumeric());
    assertTrue(pq.getSelect().get(2).getOperand().isString());
    assertTrue(pq.getSelect().get(2).getOperand().isGeometry());
    assertTrue(pq.getSelect().get(3).getOperand().isNumeric());
    assertTrue(pq.getSelect().get(3).getOperand().isString());
    assertTrue(pq.getSelect().get(3).getOperand().isGeometry());
    assertFalse(pq.getSelect().get(4).getOperand().isNumeric());
    assertTrue(pq.getSelect().get(4).getOperand().isString());
    assertFalse(pq.getSelect().get(4).getOperand().isGeometry());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
}",0.7134194568942789
25048,"@Override protected final void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String uwsAction=null;
  JobOwner user=null;
  final String reqID=generateRequestID(req);
  req.setAttribute(UWS.REQ_ATTRIBUTE_ID,reqID);
  try {
    req.setAttribute(UWS.REQ_ATTRIBUTE_PARAMETERS,requestParser.parse(req));
  }
 catch (  UWSException ue) {
    logger.log(LogLevel.WARNING,""String_Node_Str"",""String_Node_Str"",ue);
  }
  logger.logHttp(LogLevel.INFO,req,reqID,null,null);
  try {
    String method=req.getMethod();
    if (urlInterpreter == null)     setUrlInterpreter(new UWSUrl(req));
    UWSUrl requestUrl=new UWSUrl(this.urlInterpreter);
    requestUrl.load(req);
    user=UWSToolBox.getUser(req,userIdentifier);
    resp.setCharacterEncoding(UWSToolBox.DEFAULT_CHAR_ENCODING);
    if (method.equals(""String_Node_Str"")) {
      if (!requestUrl.hasJobList()) {
        uwsAction=UWSAction.HOME_PAGE;
        writeHomePage(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && !requestUrl.hasJob()) {
        uwsAction=UWSAction.LIST_JOBS;
        doListJob(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && !requestUrl.hasAttribute()) {
        uwsAction=UWSAction.JOB_SUMMARY;
        doJobSummary(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJobList() && requestUrl.hasAttribute()) {
        uwsAction=UWSAction.GET_JOB_PARAM;
        doGetJobParam(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     if (method.equals(""String_Node_Str"")) {
      if (!requestUrl.hasJobList()) {
        uwsAction=UWSAction.HOME_PAGE;
        writeHomePage(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && !requestUrl.hasJob()) {
        uwsAction=UWSAction.ADD_JOB;
        doAddJob(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && requestUrl.getAttributes().length == 1 && requestUrl.getAttributes()[0].toLowerCase().matches(UWSParameters.UWS_RW_PARAMETERS_REGEXP) && UWSToolBox.hasParameter(requestUrl.getAttributes()[0],req,false)) {
        uwsAction=UWSAction.SET_UWS_PARAMETER;
        doSetUWSParameter(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && (!requestUrl.hasAttribute() || requestUrl.getAttributes().length == 1 && requestUrl.getAttributes()[0].equalsIgnoreCase(UWSJob.PARAM_PARAMETERS))&& UWSToolBox.getNbParameters(req) > 0) {
        uwsAction=UWSAction.SET_JOB_PARAM;
        doSetJobParam(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && UWSToolBox.hasParameter(UWSJob.PARAM_ACTION,UWSJob.ACTION_DELETE,req,false)) {
        uwsAction=UWSAction.DESTROY_JOB;
        doDestroyJob(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     if (method.equals(""String_Node_Str"")) {
      if (requestUrl.hasJobList() && requestUrl.hasJob() && requestUrl.getAttributes().length >= 2 && requestUrl.getAttributes()[0].equalsIgnoreCase(UWSJob.PARAM_PARAMETERS)) {
        uwsAction=UWSAction.SET_JOB_PARAM;
        if (!UWSToolBox.hasParameter(requestUrl.getAttributes()[1],req,false))         throw new UWSException(UWSException.BAD_REQUEST,""String_Node_Str"" + requestUrl.getAttributes()[1]);
        doSetJobParam(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && requestUrl.getAttributes().length == 1 && requestUrl.getAttributes()[0].toLowerCase().matches(UWSParameters.UWS_RW_PARAMETERS_REGEXP) && UWSToolBox.hasParameter(requestUrl.getAttributes()[0],req,false)) {
        uwsAction=UWSAction.SET_UWS_PARAMETER;
        doSetUWSParameter(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     if (method.equals(""String_Node_Str"")) {
      if (requestUrl.hasJobList() && requestUrl.hasJob() && req.getMethod().equalsIgnoreCase(""String_Node_Str"")) {
        uwsAction=UWSAction.DESTROY_JOB;
        doDestroyJob(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    resp.flushBuffer();
    logger.logHttp(LogLevel.INFO,resp,reqID,user,""String_Node_Str"" + uwsAction + ""String_Node_Str"",null);
  }
 catch (  IOException ioe) {
    logger.logHttp(LogLevel.INFO,resp,reqID,user,""String_Node_Str"" + uwsAction + ""String_Node_Str"",null);
  }
catch (  UWSException ex) {
    sendError(ex,req,reqID,user,uwsAction,resp);
  }
catch (  IllegalStateException ise) {
    errorWriter.writeError(ise,resp,req,reqID,user,uwsAction);
    getLogger().logHttp(LogLevel.FATAL,resp,reqID,user,""String_Node_Str"" + uwsAction + ""String_Node_Str"",(ise.getCause() != null) ? ise.getCause() : ise);
  }
catch (  Throwable t) {
    sendError(t,req,reqID,user,uwsAction,resp);
  }
 finally {
    UWSToolBox.deleteUploads(req);
  }
}","@Override protected final void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String uwsAction=null;
  JobOwner user=null;
  final String reqID=generateRequestID(req);
  req.setAttribute(UWS.REQ_ATTRIBUTE_ID,reqID);
  try {
    req.setAttribute(UWS.REQ_ATTRIBUTE_PARAMETERS,requestParser.parse(req));
  }
 catch (  UWSException ue) {
    logger.log(LogLevel.WARNING,""String_Node_Str"",""String_Node_Str"",ue);
  }
  logger.logHttp(LogLevel.INFO,req,reqID,null,null);
  try {
    String method=req.getMethod();
    if (urlInterpreter == null)     setUrlInterpreter(new UWSUrl(req));
    UWSUrl requestUrl=new UWSUrl(this.urlInterpreter);
    requestUrl.load(req);
    user=UWSToolBox.getUser(req,userIdentifier);
    resp.setCharacterEncoding(UWSToolBox.DEFAULT_CHAR_ENCODING);
    if (method.equals(""String_Node_Str"")) {
      if (!requestUrl.hasJobList()) {
        uwsAction=UWSAction.HOME_PAGE;
        writeHomePage(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && !requestUrl.hasJob()) {
        uwsAction=UWSAction.LIST_JOBS;
        doListJob(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && !requestUrl.hasAttribute()) {
        uwsAction=UWSAction.JOB_SUMMARY;
        doJobSummary(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJobList() && requestUrl.hasAttribute()) {
        uwsAction=UWSAction.GET_JOB_PARAM;
        doGetJobParam(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     if (method.equals(""String_Node_Str"")) {
      if (!requestUrl.hasJobList()) {
        uwsAction=UWSAction.HOME_PAGE;
        writeHomePage(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && !requestUrl.hasJob()) {
        uwsAction=UWSAction.ADD_JOB;
        doAddJob(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && requestUrl.getAttributes().length == 1 && requestUrl.getAttributes()[0].toLowerCase().matches(UWSParameters.UWS_RW_PARAMETERS_REGEXP) && UWSToolBox.hasParameter(requestUrl.getAttributes()[0],req,false)) {
        uwsAction=UWSAction.SET_UWS_PARAMETER;
        doSetUWSParameter(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && UWSToolBox.hasParameter(UWSJob.PARAM_ACTION,UWSJob.ACTION_DELETE,req,false)) {
        uwsAction=UWSAction.DESTROY_JOB;
        doDestroyJob(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && (!requestUrl.hasAttribute() || requestUrl.getAttributes().length == 1 && requestUrl.getAttributes()[0].equalsIgnoreCase(UWSJob.PARAM_PARAMETERS))&& UWSToolBox.getNbParameters(req) > 0) {
        uwsAction=UWSAction.SET_JOB_PARAM;
        doSetJobParam(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     if (method.equals(""String_Node_Str"")) {
      if (requestUrl.hasJobList() && requestUrl.hasJob() && requestUrl.getAttributes().length >= 2 && requestUrl.getAttributes()[0].equalsIgnoreCase(UWSJob.PARAM_PARAMETERS)) {
        uwsAction=UWSAction.SET_JOB_PARAM;
        if (!UWSToolBox.hasParameter(requestUrl.getAttributes()[1],req,false))         throw new UWSException(UWSException.BAD_REQUEST,""String_Node_Str"" + requestUrl.getAttributes()[1]);
        doSetJobParam(requestUrl,req,resp,user);
      }
 else       if (requestUrl.hasJobList() && requestUrl.hasJob() && requestUrl.getAttributes().length == 1 && requestUrl.getAttributes()[0].toLowerCase().matches(UWSParameters.UWS_RW_PARAMETERS_REGEXP) && UWSToolBox.hasParameter(requestUrl.getAttributes()[0],req,false)) {
        uwsAction=UWSAction.SET_UWS_PARAMETER;
        doSetUWSParameter(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     if (method.equals(""String_Node_Str"")) {
      if (requestUrl.hasJobList() && requestUrl.hasJob() && req.getMethod().equalsIgnoreCase(""String_Node_Str"")) {
        uwsAction=UWSAction.DESTROY_JOB;
        doDestroyJob(requestUrl,req,resp,user);
      }
 else       throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    }
 else     throw new UWSException(UWSException.NOT_IMPLEMENTED,""String_Node_Str"");
    resp.flushBuffer();
    logger.logHttp(LogLevel.INFO,resp,reqID,user,""String_Node_Str"" + uwsAction + ""String_Node_Str"",null);
  }
 catch (  IOException ioe) {
    logger.logHttp(LogLevel.INFO,resp,reqID,user,""String_Node_Str"" + uwsAction + ""String_Node_Str"",null);
  }
catch (  UWSException ex) {
    sendError(ex,req,reqID,user,uwsAction,resp);
  }
catch (  IllegalStateException ise) {
    errorWriter.writeError(ise,resp,req,reqID,user,uwsAction);
    getLogger().logHttp(LogLevel.FATAL,resp,reqID,user,""String_Node_Str"" + uwsAction + ""String_Node_Str"",(ise.getCause() != null) ? ise.getCause() : ise);
  }
catch (  Throwable t) {
    sendError(t,req,reqID,user,uwsAction,resp);
  }
 finally {
    UWSToolBox.deleteUploads(req);
  }
}",0.9321936227429888
25049,"/** 
 * <p>Create an instance of the specified class. The class name is expected to be surrounded by {} in the given value.</p> <p><b>IMPORTANT:</b> The instance is created using the constructor whose the declaration matches exactly with the given list of parameter types. The number and types of given parameters MUST match exactly to the list of parameter types. </p>
 * @param propValue		Value which is supposed to contain the class name between brackets (see {@link #isClassName(String)} for more details)
 * @param propName		Name of the property associated with the parameter ""value"".
 * @param expectedType	Type of the class expected to be returned ; it is also the type which parameterizes this function: C.
 * @param pTypes		List of each constructor parameter type. Each type MUST be exactly the type declared in the class constructor to select. <i>NULL or empty array if no parameter.</i>
 * @param parameters	List of all constructor parameters. The number of object MUST match exactly the number of classes provided in the parameter pTypes. <i>NULL or empty array if no parameter.</i>
 * @return	The corresponding instance.
 * @throws TAPException	If the class name is incorrector if its type is not compatible with the parameterized type C (represented by the parameter ""expectedType"") or if the constructor with the specified parameters can not be found or if an error occurred while calling this constructor.
 * @see #isClassName(String)
 * @see #fetchClass(String,String,Class)
 */
public final static <C>C newInstance(final String propValue,final String propName,final Class<C> expectedType,final Class<?>[] pTypes,final Object[] parameters) throws TAPException {
  if (!isClassName(propValue))   throw new TAPException(""String_Node_Str"" + propName + ""String_Node_Str""+ propValue+ ""String_Node_Str""+ expectedType.getName()+ ""String_Node_Str"");
  Class<? extends C> classObj=null;
  try {
    classObj=fetchClass(propValue,propName,expectedType);
    Constructor<? extends C> constructor=classObj.getConstructor((pTypes == null) ? new Class<?>[0] : pTypes);
    return constructor.newInstance((parameters == null) ? new Object[0] : parameters);
  }
 catch (  NoSuchMethodException e) {
    StringBuffer pTypesStr=new StringBuffer();
    for (int i=0; i < pTypes.length; i++) {
      if (pTypesStr.length() > 0)       pTypesStr.append(""String_Node_Str"");
      if (pTypes[i] == null)       pTypesStr.append(""String_Node_Str"");
      pTypesStr.append(pTypes[i].getName());
    }
    throw new TAPException(""String_Node_Str"" + classObj.getName() + ""String_Node_Str""+ pTypesStr.toString()+ ""String_Node_Str""+ propValue+ ""String_Node_Str""+ propName+ ""String_Node_Str"");
  }
catch (  InstantiationException ie) {
    throw new TAPException(""String_Node_Str"" + classObj.getName() + ""String_Node_Str""+ propValue+ ""String_Node_Str""+ propName+ ""String_Node_Str"");
  }
catch (  InvocationTargetException ite) {
    if (ite.getCause() != null) {
      if (ite.getCause() instanceof TAPException)       throw (TAPException)ite.getCause();
 else       throw new TAPException(ite.getCause());
    }
 else     throw new TAPException(ite);
  }
catch (  TAPException te) {
    throw te;
  }
catch (  Exception ex) {
    throw new TAPException(""String_Node_Str"" + expectedType.getName() + ""String_Node_Str""+ propName+ ""String_Node_Str""+ propValue+ ""String_Node_Str"",ex);
  }
}","/** 
 * <p>Create an instance of the specified class. The class name is expected to be surrounded by {} in the given value.</p> <p><b>IMPORTANT:</b> The instance is created using the constructor whose the declaration matches exactly with the given list of parameter types. The number and types of given parameters MUST match exactly to the list of parameter types. </p>
 * @param propValue		Value which is supposed to contain the class name between brackets (see {@link #isClassName(String)} for more details)
 * @param propName		Name of the property associated with the parameter ""value"".
 * @param expectedType	Type of the class expected to be returned ; it is also the type which parameterizes this function: C.
 * @param pTypes		List of each constructor parameter type. Each type MUST be exactly the type declared in the class constructor to select. <i>NULL or empty array if no parameter.</i>
 * @param parameters	List of all constructor parameters. The number of object MUST match exactly the number of classes provided in the parameter pTypes. <i>NULL or empty array if no parameter.</i>
 * @return	The corresponding instance.
 * @throws TAPException	If the class name is incorrector if its type is not compatible with the parameterized type C (represented by the parameter ""expectedType"") or if the constructor with the specified parameters can not be found or if an error occurred while calling this constructor.
 * @see #isClassName(String)
 * @see #fetchClass(String,String,Class)
 */
public final static <C>C newInstance(final String propValue,final String propName,final Class<C> expectedType,final Class<?>[] pTypes,final Object[] parameters) throws TAPException {
  if (!isClassName(propValue))   throw new TAPException(""String_Node_Str"" + propName + ""String_Node_Str""+ propValue+ ""String_Node_Str""+ expectedType.getName()+ ""String_Node_Str"");
  Class<? extends C> classObj=null;
  try {
    classObj=fetchClass(propValue,propName,expectedType);
    Constructor<? extends C> constructor=classObj.getConstructor((pTypes == null) ? new Class<?>[0] : pTypes);
    return constructor.newInstance((parameters == null) ? new Object[0] : parameters);
  }
 catch (  NoSuchMethodException e) {
    StringBuffer pTypesStr=new StringBuffer();
    if (pTypes != null) {
      for (int i=0; i < pTypes.length; i++) {
        if (pTypesStr.length() > 0)         pTypesStr.append(""String_Node_Str"");
        if (pTypes[i] == null)         pTypesStr.append(""String_Node_Str"");
        pTypesStr.append(pTypes[i].getName());
      }
    }
    throw new TAPException(""String_Node_Str"" + classObj.getName() + ""String_Node_Str""+ pTypesStr.toString()+ ""String_Node_Str""+ propValue+ ""String_Node_Str""+ propName+ ""String_Node_Str"");
  }
catch (  InstantiationException ie) {
    throw new TAPException(""String_Node_Str"" + classObj.getName() + ""String_Node_Str""+ propValue+ ""String_Node_Str""+ propName+ ""String_Node_Str"");
  }
catch (  InvocationTargetException ite) {
    if (ite.getCause() != null) {
      if (ite.getCause() instanceof TAPException)       throw (TAPException)ite.getCause();
 else       throw new TAPException(ite.getCause());
    }
 else     throw new TAPException(ite);
  }
catch (  TAPException te) {
    throw te;
  }
catch (  Exception ex) {
    throw new TAPException(""String_Node_Str"" + expectedType.getName() + ""String_Node_Str""+ propName+ ""String_Node_Str""+ propValue+ ""String_Node_Str"",ex);
  }
}",0.993223335297584
25050,"/** 
 * <p>Let parsing the serialized form of a function definition.</p> <p>The expected syntax is <i>(items between brackets are optional)</i>:</p> <pre>{fctName}([{param1Name} {param1Type}, ...])[ -> {returnType}]</pre> <p> Allowed parameter types and return types should be one the types listed by the UPLOAD section of the TAP recommendation document. These types are listed in the enumeration object   {@link DBType}. However, other types should be accepted like the common database types...but it should be better to not rely on that since the conversion of those types to TAP types should not be exactly what is expected. </p>
 * @param strDefinition	Serialized function definition to parse.
 * @return	The object representation of the given string definition.
 * @throws ParseException	If the given string has a wrong syntax or uses unknown types.
 */
public static FunctionDef parse(final String strDefinition) throws ParseException {
  if (strDefinition == null)   throw new NullPointerException(""String_Node_Str"");
  Matcher m=fctPattern.matcher(strDefinition);
  if (m.matches()) {
    String fctName=m.group(1);
    DBType returnType=null;
    if (m.group(3) != null) {
      returnType=parseType(m.group(5),(m.group(7) == null) ? DBType.NO_LENGTH : Integer.parseInt(m.group(7)));
      if (returnType == null) {
        returnType=new DBType(DBDatatype.UNKNOWN);
        returnType.type.setCustomType(m.group(4));
      }
    }
    String paramsList=m.group(2);
    FunctionParam[] params=null;
    if (paramsList != null && paramsList.trim().length() > 0) {
      if (!paramsList.matches(fctParamsRegExp))       throw new ParseException(""String_Node_Str"");
      String[] paramsSplit=paramsList.split(""String_Node_Str"");
      params=new FunctionParam[paramsSplit.length];
      DBType paramType;
      for (int i=0; i < params.length; i++) {
        m=paramPattern.matcher(paramsSplit[i]);
        if (m.matches()) {
          paramType=parseType(m.group(2),(m.group(4) == null) ? DBType.NO_LENGTH : Integer.parseInt(m.group(4)));
          if (paramType == null) {
            paramType=new DBType(DBDatatype.UNKNOWN);
            paramType.type.setCustomType(m.group(2) + ((m.group(3) == null) ? ""String_Node_Str"" : m.group(3)));
          }
          params[i]=new FunctionParam(m.group(1),paramType);
        }
 else         throw new ParseException(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ paramsSplit[i].trim()+ ""String_Node_Str"");
      }
    }
    return new FunctionDef(fctName,returnType,params);
  }
 else   throw new ParseException(""String_Node_Str"");
}","/** 
 * <p>Let parsing the serialized form of a function definition.</p> <p>The expected syntax is <i>(items between brackets are optional)</i>:</p> <pre>{fctName}([{param1Name} {param1Type}, ...])[ -> {returnType}]</pre> <p> <em>This function must be able to parse functions as defined by TAPRegExt (section 2.3).</em> Hence, allowed parameter types and return types should be one of the types listed by the UPLOAD section of the TAP recommendation document. These types are listed in the enumeration object   {@link DBType}. However, other types should be accepted like the common database types...but it should be better to not rely on that since the conversion of those types to TAP types should not be exactly what is expected (because depending from the used DBMS); a default interpretation of database types is nevertheless processed by this parser. </p>
 * @param strDefinition	Serialized function definition to parse.
 * @return	The object representation of the given string definition.
 * @throws ParseException	If the given string has a wrong syntax or uses unknown types.
 */
public static FunctionDef parse(final String strDefinition) throws ParseException {
  if (strDefinition == null)   throw new NullPointerException(""String_Node_Str"");
  Matcher m=fctPattern.matcher(strDefinition);
  if (m.matches()) {
    String fctName=m.group(1);
    DBType returnType=null;
    if (m.group(3) != null) {
      returnType=parseType(m.group(5),(m.group(7) == null) ? DBType.NO_LENGTH : Integer.parseInt(m.group(7)));
      if (returnType == null) {
        returnType=new DBType(DBDatatype.UNKNOWN);
        returnType.type.setCustomType(m.group(4));
      }
    }
    String paramsList=m.group(2);
    FunctionParam[] params=null;
    if (paramsList != null && paramsList.trim().length() > 0) {
      if (!paramsList.matches(fctParamsRegExp))       throw new ParseException(""String_Node_Str"");
      String[] paramsSplit=paramsList.split(""String_Node_Str"");
      params=new FunctionParam[paramsSplit.length];
      DBType paramType;
      for (int i=0; i < params.length; i++) {
        m=paramPattern.matcher(paramsSplit[i]);
        if (m.matches()) {
          paramType=parseType(m.group(2),(m.group(4) == null) ? DBType.NO_LENGTH : Integer.parseInt(m.group(4)));
          if (paramType == null) {
            paramType=new DBType(DBDatatype.UNKNOWN);
            paramType.type.setCustomType(m.group(2) + ((m.group(3) == null) ? ""String_Node_Str"" : m.group(3)));
          }
          params[i]=new FunctionParam(m.group(1),paramType);
        }
 else         throw new ParseException(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ paramsSplit[i].trim()+ ""String_Node_Str"");
      }
    }
    return new FunctionDef(fctName,returnType,params);
  }
 else   throw new ParseException(""String_Node_Str"");
}",0.957824639289678
25051,"/** 
 * Parse the given string representation of a datatype.
 * @param datatype	String representation of a datatype.<i>Note: This string must not contain the length parameter or any other parameter. These latter should have been separated from the datatype before calling this function.</i>
 * @param length	Length of this datatype.<i>Note: This length will be used only for binary (BINARY and VARBINARY) and character (CHAR and VARCHAR) types.</i> 
 * @return	The object representation of the specified datatypeor NULL if the specified datatype can not be resolved.
 */
private static DBType parseType(String datatype,int length){
  if (datatype == null)   return null;
  try {
    DBDatatype dbDatatype=DBDatatype.valueOf(datatype.toUpperCase());
    length=(length <= 0) ? DBType.NO_LENGTH : length;
switch (dbDatatype) {
case CHAR:
case VARCHAR:
case BINARY:
case VARBINARY:
      return new DBType(dbDatatype,length);
default :
    return new DBType(dbDatatype);
}
}
 catch (IllegalArgumentException iae) {
datatype=datatype.toLowerCase();
if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.SMALLINT);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.SMALLINT);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.INTEGER);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.BIGINT);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.REAL);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.DOUBLE);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.BINARY,length);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.VARBINARY,length);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.CHAR,length);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.VARCHAR,length);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.BLOB);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.CLOB);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.TIMESTAMP);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.POINT);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.REGION);
 else return null;
}
}","/** 
 * Parse the given string representation of a datatype.
 * @param datatype	String representation of a datatype.<i>Note: This string must not contain the length parameter or any other parameter. These latter should have been separated from the datatype before calling this function. It can however contain space(s) in first, last or intern position.</i>
 * @param length	Length of this datatype.<i>Note: This length will be used only for binary (BINARY and VARBINARY) and character (CHAR and VARCHAR) types.</i> 
 * @return	The object representation of the specified datatypeor NULL if the specified datatype can not be resolved.
 */
private static DBType parseType(String datatype,int length){
  if (datatype == null)   return null;
  datatype=datatype.trim().replaceAll(""String_Node_Str"",""String_Node_Str"");
  try {
    DBDatatype dbDatatype=DBDatatype.valueOf(datatype.toUpperCase());
    length=(length <= 0) ? DBType.NO_LENGTH : length;
switch (dbDatatype) {
case CHAR:
case VARCHAR:
case BINARY:
case VARBINARY:
      return new DBType(dbDatatype,length);
default :
    return new DBType(dbDatatype);
}
}
 catch (IllegalArgumentException iae) {
datatype=datatype.toLowerCase();
if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.SMALLINT);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.INTEGER);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.BIGINT);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.REAL);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.DOUBLE);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.BINARY,length);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.VARBINARY,length);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.CHAR,length);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.VARCHAR,length);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.BLOB);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.CLOB);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")|| datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.TIMESTAMP);
 else if (datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.POINT);
 else if (datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"") || datatype.equals(""String_Node_Str"")) return new DBType(DBDatatype.REGION);
 else return null;
}
}",0.8846832397754611
25052,"/** 
 * <p>Get the signature of the function given in parameter.</p> <p> In this signature, just the name and the type of all the parameters are written. The return type is never part of a function signature. </p> <p><i>Note 1: A parameter type can be either ""NUMERIC"", ""STRING"" or ""GEOMETRY"". In order to be the most generic has possible, no more precision about a type is returned here. If the parameter is none of these type kinds, ""???"" is returned. </i></p> <p><i>Note 2: If the given object is NULL, an empty string is returned. </i></p>
 * @param fct	Function whose the signature must be returned.
 * @return	The corresponding signature.
 */
public static String getFctSignature(final ADQLFunction fct){
  if (fct == null)   return ""String_Node_Str"";
  StringBuffer buf=new StringBuffer(fct.getName().toLowerCase());
  buf.append('(');
  for (int i=0; i < fct.getNbParameters(); i++) {
    if (fct.getParameter(i).isNumeric())     buf.append(""String_Node_Str"");
 else     if (fct.getParameter(i).isString())     buf.append(""String_Node_Str"");
 else     if (fct.getParameter(i).isGeometry())     buf.append(""String_Node_Str"");
 else     buf.append(""String_Node_Str"");
    if ((i + 1) < fct.getNbParameters())     buf.append(""String_Node_Str"");
  }
  buf.append(')');
  return buf.toString();
}","/** 
 * <p>Get the signature of the function given in parameter.</p> <p> In this signature, just the name and the type of all the parameters are written. The return type is never part of a function signature. </p> <p><i>Note 1: A parameter type can be either ""NUMERIC"", ""STRING"" or ""GEOMETRY"". In order to be the most generic has possible, no more precision about a type is returned here. If the parameter is none of these type kinds, ""param"" suffixed by the parameter index (e.g. ""param1"") is returned. </i></p> <p><i>Note 2: If the given object is NULL, an empty string is returned. </i></p>
 * @param fct	Function whose the signature must be returned.
 * @return	The corresponding signature.
 */
public static String getFctSignature(final ADQLFunction fct){
  if (fct == null)   return ""String_Node_Str"";
  StringBuffer buf=new StringBuffer(fct.getName().toLowerCase());
  buf.append('(');
  for (int i=0; i < fct.getNbParameters(); i++) {
    if (fct.getParameter(i).isNumeric() && fct.getParameter(i).isString() && fct.getParameter(i).isGeometry())     buf.append(""String_Node_Str"").append(i + 1);
 else     if (fct.getParameter(i).isNumeric())     buf.append(""String_Node_Str"");
 else     if (fct.getParameter(i).isString())     buf.append(""String_Node_Str"");
 else     if (fct.getParameter(i).isGeometry())     buf.append(""String_Node_Str"");
 else     buf.append(""String_Node_Str"").append(i + 1);
    if ((i + 1) < fct.getNbParameters())     buf.append(""String_Node_Str"");
  }
  buf.append(')');
  return buf.toString();
}",0.9115983026874116
25053,"@Test public void testUDFManagement(){
  ADQLParser parser=new ADQLParser(new DBChecker(tables,new ArrayList<FunctionDef>(0)));
  try {
    assertNotNull(parser.parseQuery(""String_Node_Str""));
  }
 catch (  ParseException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
  FunctionDef[] udfs=new FunctionDef[]{new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.VARCHAR)),new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.INTEGER))};
  parser=new ADQLParser(new DBChecker(tables,Arrays.asList(udfs)));
  try {
    assertNotNull(parser.parseQuery(""String_Node_Str""));
    assertNotNull(parser.parseQuery(""String_Node_Str""));
  }
 catch (  ParseException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
  udfs=new FunctionDef[]{new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.VARCHAR),new FunctionParam[]{new FunctionParam(""String_Node_Str"",new DBType(DBDatatype.VARCHAR))})};
  udfs[0].setUDFClass(UDFToto.class);
  parser=new ADQLParser(new DBChecker(tables,Arrays.asList(udfs)));
  try {
    ADQLQuery query=parser.parseQuery(""String_Node_Str"");
    assertNotNull(query);
    Iterator<ADQLObject> it=query.search(new SimpleSearchHandler(){
      @Override protected boolean match(      ADQLObject obj){
        return (obj instanceof UserDefinedFunction) && ((UserDefinedFunction)obj).getName().equals(""String_Node_Str"");
      }
    }
);
    assertTrue(it.hasNext());
    assertEquals(UDFToto.class.getName(),it.next().getClass().getName());
    assertFalse(it.hasNext());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
  udfs=new FunctionDef[]{new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.VARCHAR),new FunctionParam[]{new FunctionParam(""String_Node_Str"",new DBType(DBDatatype.VARCHAR))})};
  udfs[0].setUDFClass(WrongUDFToto.class);
  parser=new ADQLParser(new DBChecker(tables,Arrays.asList(udfs)));
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
}","@Test public void testUDFManagement(){
  ADQLParser parser=new ADQLParser(new DBChecker(tables,new ArrayList<FunctionDef>(0)));
  try {
    assertNotNull(parser.parseQuery(""String_Node_Str""));
  }
 catch (  ParseException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
  FunctionDef[] udfs=new FunctionDef[]{new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.VARCHAR)),new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.INTEGER))};
  parser=new ADQLParser(new DBChecker(tables,Arrays.asList(udfs)));
  try {
    assertNotNull(parser.parseQuery(""String_Node_Str""));
    assertNotNull(parser.parseQuery(""String_Node_Str""));
  }
 catch (  ParseException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(2,ex.getNbErrors());
    Iterator<ParseException> errors=ex.getErrors();
    assertEquals(""String_Node_Str"",errors.next().getMessage());
    assertEquals(""String_Node_Str"",errors.next().getMessage());
  }
  udfs=new FunctionDef[]{new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.VARCHAR),new FunctionParam[]{new FunctionParam(""String_Node_Str"",new DBType(DBDatatype.VARCHAR))})};
  udfs[0].setUDFClass(UDFToto.class);
  parser=new ADQLParser(new DBChecker(tables,Arrays.asList(udfs)));
  try {
    ADQLQuery query=parser.parseQuery(""String_Node_Str"");
    assertNotNull(query);
    Iterator<ADQLObject> it=query.search(new SimpleSearchHandler(){
      @Override protected boolean match(      ADQLObject obj){
        return (obj instanceof UserDefinedFunction) && ((UserDefinedFunction)obj).getName().equals(""String_Node_Str"");
      }
    }
);
    assertTrue(it.hasNext());
    assertEquals(UDFToto.class.getName(),it.next().getClass().getName());
    assertFalse(it.hasNext());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
  udfs=new FunctionDef[]{new FunctionDef(""String_Node_Str"",new DBType(DBDatatype.VARCHAR),new FunctionParam[]{new FunctionParam(""String_Node_Str"",new DBType(DBDatatype.VARCHAR))})};
  udfs[0].setUDFClass(WrongUDFToto.class);
  parser=new ADQLParser(new DBChecker(tables,Arrays.asList(udfs)));
  try {
    parser.parseQuery(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e instanceof UnresolvedIdentifiersException);
    UnresolvedIdentifiersException ex=(UnresolvedIdentifiersException)e;
    assertEquals(1,ex.getNbErrors());
    assertEquals(""String_Node_Str"",ex.getErrors().next().getMessage());
  }
}",0.8893923240938166
25054,"@Test public void testParse(){
  final String WRONG_FULL_SYNTAX=""String_Node_Str"";
  final String WRONG_PARAM_SYNTAX=""String_Node_Str"";
  try {
    FunctionDef.parse(null);
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof NullPointerException);
    assertEquals(""String_Node_Str"",ex.getMessage());
  }
  try {
    FunctionDef.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof ParseException);
    assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
  }
  try {
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
  try {
    for (    DBDatatype t : DBDatatype.values()) {
switch (t) {
case CHAR:
case VARCHAR:
case BINARY:
case VARBINARY:
        assertEquals(""String_Node_Str"" + t.toString() + ""String_Node_Str"",FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
      break;
default :
    assertEquals(""String_Node_Str"" + t.toString(),FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
}
}
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(""String_Node_Str"",ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertTrue(fct.isString);
assertTrue(fct.isNumeric);
assertTrue(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertTrue(fct.isString);
assertTrue(fct.isNumeric);
assertTrue(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertTrue(fct.getParam(0).type.isString());
assertTrue(fct.getParam(0).type.isNumeric());
assertTrue(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertTrue(fct.getParam(0).type.isString());
assertTrue(fct.getParam(0).type.isNumeric());
assertTrue(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
}","@Test public void testParse(){
  final String WRONG_FULL_SYNTAX=""String_Node_Str"";
  final String WRONG_PARAM_SYNTAX=""String_Node_Str"";
  try {
    FunctionDef.parse(null);
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof NullPointerException);
    assertEquals(""String_Node_Str"",ex.getMessage());
  }
  try {
    FunctionDef.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception ex) {
    assertTrue(ex instanceof ParseException);
    assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
  }
  try {
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
    assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
  }
 catch (  Exception ex) {
    ex.printStackTrace(System.err);
    fail(""String_Node_Str"");
  }
  try {
    for (    DBDatatype t : DBDatatype.values()) {
switch (t) {
case CHAR:
case VARCHAR:
case BINARY:
case VARBINARY:
        assertEquals(""String_Node_Str"" + t.toString() + ""String_Node_Str"",FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
      break;
default :
    assertEquals(""String_Node_Str"" + t.toString(),FunctionDef.parse(""String_Node_Str"" + t.toString() + ""String_Node_Str"").toString());
}
}
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
assertEquals(""String_Node_Str"",FunctionDef.parse(""String_Node_Str"").toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(""String_Node_Str"",ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertTrue(fct.isString);
assertTrue(fct.isNumeric);
assertTrue(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.isUnknown);
assertTrue(fct.isString);
assertTrue(fct.isNumeric);
assertTrue(fct.isGeometry);
assertEquals(""String_Node_Str"",fct.returnType.type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_FULL_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef.parse(""String_Node_Str"");
fail(""String_Node_Str"");
}
 catch (Exception ex) {
assertTrue(ex instanceof ParseException);
assertEquals(WRONG_PARAM_SYNTAX,ex.getMessage());
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertTrue(fct.getParam(0).type.isString());
assertTrue(fct.getParam(0).type.isNumeric());
assertTrue(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
try {
FunctionDef fct=FunctionDef.parse(""String_Node_Str"");
assertTrue(fct.getParam(0).type.isUnknown());
assertTrue(fct.getParam(0).type.isString());
assertTrue(fct.getParam(0).type.isNumeric());
assertTrue(fct.getParam(0).type.isGeometry());
assertEquals(""String_Node_Str"",fct.getParam(0).type.toString());
}
 catch (Exception ex) {
ex.printStackTrace(System.err);
fail(""String_Node_Str"");
}
}",0.934786917740337
25055,"/** 
 * Resolve the given table, that's to say search for the corresponding   {@link DBTable}.
 * @param table	The table to resolve.
 * @return		The corresponding {@link DBTable} if found, <i>null</i> otherwise.
 * @throws ParseException	An {@link UnresolvedTableException} if the given table can't be resolved.
 */
protected DBTable resolveTable(final ADQLTable table) throws ParseException {
  ArrayList<DBTable> tables=lstTables.search(table);
  if (tables.size() == 1)   return tables.get(0);
 else   if (tables.size() > 1)   throw new UnresolvedTableException(table,tables.get(0).getADQLSchemaName() + ""String_Node_Str"" + tables.get(0).getADQLName(),tables.get(1).getADQLSchemaName() + ""String_Node_Str"" + tables.get(1).getADQLName());
 else   throw new UnresolvedTableException(table);
}","/** 
 * Resolve the given table, that's to say search for the corresponding   {@link DBTable}.
 * @param table	The table to resolve.
 * @return		The corresponding {@link DBTable} if found, <i>null</i> otherwise.
 * @throws ParseException	An {@link UnresolvedTableException} if the given table can't be resolved.
 */
protected DBTable resolveTable(final ADQLTable table) throws ParseException {
  ArrayList<DBTable> tables=lstTables.search(table);
  if (tables.size() == 1)   return tables.get(0);
 else   if (tables.size() > 1)   throw new UnresolvedTableException(table,(tables.get(0).getADQLSchemaName() == null ? ""String_Node_Str"" : tables.get(0).getADQLSchemaName() + ""String_Node_Str"") + tables.get(0).getADQLName(),(tables.get(1).getADQLSchemaName() == null ? ""String_Node_Str"" : tables.get(1).getADQLSchemaName() + ""String_Node_Str"") + tables.get(1).getADQLName());
 else   throw new UnresolvedTableException(table);
}",0.920838183934808
25056,"/** 
 * Builds a default   {@link DBColumn} with the given DB name, DB table and ADQL name.
 * @param dbName	Database column name.<b>Only the column name is expected. Contrary to  {@link DefaultDBTable}, if a whole column reference is given, no split will be done.</b>
 * @param adqlName	Column name used in ADQL queries.<b>Only the column name is expected. Contrary to  {@link DefaultDBTable}, if a whole column reference is given, no split will be done.</b>
 * @param type		Type of the column.<i>Note: there is no default value. Consequently if this parameter is NULL, the type should be considered as unknown. It means that any comparison with any type will always return 'true'.</i>
 * @param table		DB table which contains this column.
 * @since 1.3
 */
public DefaultDBColumn(final String dbName,final String adqlName,final DBType type,final DBTable table){
  this.dbName=dbName;
  this.adqlName=adqlName;
  this.type=type;
  this.table=table;
}","/** 
 * Builds a default   {@link DBColumn} with the given DB name, DB table and ADQL name.
 * @param dbName	Database column name.<b>Only the column name is expected. Contrary to  {@link DefaultDBTable}, if a whole column reference is given, no split will be done.</b> <b>REQUIRED parameter: it must be not NULL.</b> 
 * @param adqlName	Column name used in ADQL queries.<b>Only the column name is expected. Contrary to  {@link DefaultDBTable}, if a whole column reference is given, no split will be done.</b> <em>If NULL, it will be set to dbName.</em>
 * @param type		Type of the column.<i>Note: there is no default value. Consequently if this parameter is NULL, the type should be considered as unknown. It means that any comparison with any type will always return 'true'.</i>
 * @param table		DB table which contains this column.
 * @since 1.3
 */
public DefaultDBColumn(final String dbName,final String adqlName,final DBType type,final DBTable table){
  if (dbName == null || dbName.length() == 0)   throw new NullPointerException(""String_Node_Str"");
  this.dbName=dbName;
  this.adqlName=(adqlName == null) ? dbName : adqlName;
  this.type=type;
  this.table=table;
}",0.6751412429378532
25057,"/** 
 * Builds default   {@link DBTable} with the DB and ADQL names for the catalog, schema and table.
 * @param dbCatName		Database catalog name.
 * @param adqlCatName	Catalog name used in ADQL queries.
 * @param dbSchemName	Database schema name.
 * @param adqlSchemName	Schema name used in ADQL queries.
 * @param dbName		Database table name.
 * @param adqlName		Table name used in ADQL queries.
 */
public DefaultDBTable(final String dbCatName,final String adqlCatName,final String dbSchemName,final String adqlSchemName,final String dbName,final String adqlName){
  if (dbName == null || dbName.length() == 0)   throw new NullPointerException(""String_Node_Str"");
  this.dbName=dbName;
  this.adqlName=adqlName;
  dbSchemaName=dbSchemName;
  adqlSchemaName=adqlSchemName;
  dbCatalogName=dbCatName;
  adqlCatalogName=adqlCatName;
}","/** 
 * Builds default   {@link DBTable} with the DB and ADQL names for the catalog, schema and table.
 * @param dbCatName		Database catalog name.
 * @param adqlCatName	Catalog name used in ADQL queries.<em>If NULL, it will be set to dbCatName.</em>
 * @param dbSchemName	Database schema name.
 * @param adqlSchemName	Schema name used in ADQL queries.<em>If NULL, it will be set to dbSchemName.</em>
 * @param dbName		Database table name.
 * @param adqlName		Table name used in ADQL queries.<em>If NULL, it will be set to dbName.</em>
 */
public DefaultDBTable(final String dbCatName,final String adqlCatName,final String dbSchemName,final String adqlSchemName,final String dbName,final String adqlName){
  if (dbName == null || dbName.length() == 0)   throw new NullPointerException(""String_Node_Str"");
  this.dbName=dbName;
  this.adqlName=(adqlName == null) ? dbName : adqlName;
  dbSchemaName=dbSchemName;
  adqlSchemaName=(adqlSchemName == null) ? dbSchemName : adqlSchemName;
  dbCatalogName=dbCatName;
  adqlCatalogName=(adqlCatName == null) ? dbCatName : adqlCatName;
}",0.8728414442700158
25058,"/** 
 * Searches all   {@link DBColumn} elements which have the given catalog, schema, table and column name, with the specified case sensitivity.
 * @param catalog			Catalog name.
 * @param schema			Schema name.
 * @param table				Table name.
 * @param column			Column name.
 * @param caseSensitivity	Case sensitivity for each column parts (one bit by part ; 0=sensitive,1=insensitive ; see {@link IdentifierField} for more details).
 * @return					The list of all matching {@link DBColumn} elements.
 * @see IdentifierField
 */
public ArrayList<DBColumn> search(final String catalog,final String schema,final String table,final String column,final byte caseSensitivity){
  ArrayList<DBColumn> tmpResult=get(column,IdentifierField.COLUMN.isCaseSensitive(caseSensitivity));
  if (table != null) {
    String tableName=null;
    ArrayList<String> aliasMatches=null;
    if (IdentifierField.TABLE.isCaseSensitive(caseSensitivity)) {
      tableName=tableAliases.get(table);
      if (tableName == null)       tableName=table;
    }
 else {
      aliasMatches=mapAliases.get(table.toLowerCase());
      if (aliasMatches == null || aliasMatches.isEmpty())       tableName=table;
    }
    ArrayList<DBColumn> result=new ArrayList<DBColumn>();
    for (    DBColumn match : tmpResult) {
      Iterator<DBTable> itMatchTables;
      if (ADQLJoin.isCommonColumn(match))       itMatchTables=((DBCommonColumn)match).getCoveredTables();
 else       itMatchTables=new SingleIterator<DBTable>(match.getTable());
      DBTable matchTable;
      while (itMatchTables.hasNext()) {
        matchTable=itMatchTables.next();
        if (aliasMatches == null) {
          if (IdentifierField.TABLE.isCaseSensitive(caseSensitivity)) {
            if (!matchTable.getADQLName().equals(tableName))             continue;
          }
 else {
            if (!matchTable.getADQLName().equalsIgnoreCase(tableName))             continue;
          }
        }
 else {
          boolean foundAlias=false;
          String temp;
          for (int a=0; !foundAlias && a < aliasMatches.size(); a++) {
            temp=tableAliases.get(aliasMatches.get(a));
            if (temp != null)             foundAlias=matchTable.getADQLName().equalsIgnoreCase(temp);
          }
          if (!foundAlias)           continue;
        }
        if (schema != null && matchTable.getADQLSchemaName() != null) {
          if (IdentifierField.SCHEMA.isCaseSensitive(caseSensitivity)) {
            if (!matchTable.getADQLSchemaName().equals(schema))             continue;
          }
 else {
            if (!matchTable.getADQLSchemaName().equalsIgnoreCase(schema))             continue;
          }
          if (catalog != null) {
            if (IdentifierField.CATALOG.isCaseSensitive(caseSensitivity)) {
              if (!matchTable.getADQLCatalogName().equals(catalog))               continue;
            }
 else {
              if (!matchTable.getADQLCatalogName().equalsIgnoreCase(catalog))               continue;
            }
          }
        }
        DBColumn goodMatch=matchTable.getColumn(match.getADQLName(),true);
        result.add(goodMatch);
      }
    }
    return result;
  }
 else {
    if (tmpResult.size() > 1) {
      ArrayList<DBColumn> result=new ArrayList<DBColumn>(tmpResult.size());
      for (int i=0; i < tmpResult.size(); i++) {
        if (ADQLJoin.isCommonColumn(tmpResult.get(i))) {
          DBCommonColumn commonColumn=(DBCommonColumn)tmpResult.remove(i);
          result.add(commonColumn);
          Iterator<DBTable> itCoveredTables=commonColumn.getCoveredTables();
          while (itCoveredTables.hasNext())           tmpResult.add(itCoveredTables.next().getColumn(column,true));
        }
      }
      if (result.size() == 1)       return result;
    }
    return tmpResult;
  }
}","/** 
 * Searches all   {@link DBColumn} elements which have the given catalog, schema, table and column name, with the specified case sensitivity.
 * @param catalog			Catalog name.
 * @param schema			Schema name.
 * @param table				Table name.
 * @param column			Column name.
 * @param caseSensitivity	Case sensitivity for each column parts (one bit by part ; 0=sensitive,1=insensitive ; see {@link IdentifierField} for more details).
 * @return					The list of all matching {@link DBColumn} elements.
 * @see IdentifierField
 */
public ArrayList<DBColumn> search(final String catalog,final String schema,final String table,final String column,final byte caseSensitivity){
  ArrayList<DBColumn> tmpResult=get(column,IdentifierField.COLUMN.isCaseSensitive(caseSensitivity));
  if (table != null) {
    String tableName=null;
    ArrayList<String> aliasMatches=null;
    if (IdentifierField.TABLE.isCaseSensitive(caseSensitivity)) {
      tableName=tableAliases.get(table);
      if (tableName == null)       tableName=table;
    }
 else {
      aliasMatches=mapAliases.get(table.toLowerCase());
      if (aliasMatches == null || aliasMatches.isEmpty())       tableName=table;
    }
    ArrayList<DBColumn> result=new ArrayList<DBColumn>();
    for (    DBColumn match : tmpResult) {
      Iterator<DBTable> itMatchTables;
      if (ADQLJoin.isCommonColumn(match))       itMatchTables=((DBCommonColumn)match).getCoveredTables();
 else       itMatchTables=new SingleIterator<DBTable>(match.getTable());
      DBTable matchTable;
      while (itMatchTables.hasNext()) {
        matchTable=itMatchTables.next();
        if (aliasMatches == null) {
          if (IdentifierField.TABLE.isCaseSensitive(caseSensitivity)) {
            if (!matchTable.getADQLName().equals(tableName))             continue;
          }
 else {
            if (!matchTable.getADQLName().equalsIgnoreCase(tableName))             continue;
          }
        }
 else {
          boolean foundAlias=false;
          String temp;
          for (int a=0; !foundAlias && a < aliasMatches.size(); a++) {
            temp=tableAliases.get(aliasMatches.get(a));
            if (temp != null)             foundAlias=matchTable.getADQLName().equalsIgnoreCase(temp);
          }
          if (!foundAlias)           continue;
        }
        if (schema != null) {
          if (matchTable.getADQLSchemaName() == null)           continue;
          if (IdentifierField.SCHEMA.isCaseSensitive(caseSensitivity)) {
            if (!matchTable.getADQLSchemaName().equals(schema))             continue;
          }
 else {
            if (!matchTable.getADQLSchemaName().equalsIgnoreCase(schema))             continue;
          }
          if (catalog != null) {
            if (matchTable.getADQLCatalogName() == null)             continue;
            if (IdentifierField.CATALOG.isCaseSensitive(caseSensitivity)) {
              if (!matchTable.getADQLCatalogName().equals(catalog))               continue;
            }
 else {
              if (!matchTable.getADQLCatalogName().equalsIgnoreCase(catalog))               continue;
            }
          }
        }
        DBColumn goodMatch=matchTable.getColumn(match.getADQLName(),true);
        result.add(goodMatch);
      }
    }
    return result;
  }
 else {
    if (tmpResult.size() > 1) {
      ArrayList<DBColumn> result=new ArrayList<DBColumn>(tmpResult.size());
      for (int i=0; i < tmpResult.size(); i++) {
        if (ADQLJoin.isCommonColumn(tmpResult.get(i))) {
          DBCommonColumn commonColumn=(DBCommonColumn)tmpResult.remove(i);
          result.add(commonColumn);
          Iterator<DBTable> itCoveredTables=commonColumn.getCoveredTables();
          while (itCoveredTables.hasNext())           tmpResult.add(itCoveredTables.next().getColumn(column,true));
        }
      }
      if (result.size() == 1)       return result;
    }
    return tmpResult;
  }
}",0.9821823384055144
25059,"/** 
 * Searches all   {@link DBTable} elements which have the given catalog, schema, and table name, with the specified case sensitivity.
 * @param catalog			Catalog name.
 * @param schema			Schema name.
 * @param table				Table name.
 * @param caseSensitivity	Case sensitivity for each table parts (one bit by part ; 0=sensitive,1=insensitive ; see {@link IdentifierField} for more details).
 * @return					The list of all matching {@link DBTable} elements.
 * @see IdentifierField
 */
public ArrayList<DBTable> search(final String catalog,final String schema,final String table,final byte caseSensitivity){
  ArrayList<DBTable> tmpResult=get(table,IdentifierField.TABLE.isCaseSensitive(caseSensitivity));
  if (schema != null) {
    ArrayList<DBTable> result=new ArrayList<DBTable>();
    for (    DBTable match : tmpResult) {
      if (match.getADQLSchemaName() != null) {
        if (IdentifierField.SCHEMA.isCaseSensitive(caseSensitivity)) {
          if (!match.getADQLSchemaName().equals(schema))           continue;
        }
 else {
          if (!match.getADQLSchemaName().equalsIgnoreCase(schema))           continue;
        }
        if (catalog != null && match.getADQLCatalogName() != null) {
          if (IdentifierField.CATALOG.isCaseSensitive(caseSensitivity)) {
            if (!match.getADQLCatalogName().equals(catalog))             continue;
          }
 else {
            if (!match.getADQLCatalogName().equalsIgnoreCase(catalog))             continue;
          }
        }
      }
      result.add(match);
    }
    return result;
  }
 else   return tmpResult;
}","/** 
 * Searches all   {@link DBTable} elements which have the given catalog, schema, and table name, with the specified case sensitivity.
 * @param catalog			Catalog name.
 * @param schema			Schema name.
 * @param table				Table name.
 * @param caseSensitivity	Case sensitivity for each table parts (one bit by part ; 0=sensitive,1=insensitive ; see {@link IdentifierField} for more details).
 * @return					The list of all matching {@link DBTable} elements.
 * @see IdentifierField
 */
public ArrayList<DBTable> search(final String catalog,final String schema,final String table,final byte caseSensitivity){
  ArrayList<DBTable> tmpResult=get(table,IdentifierField.TABLE.isCaseSensitive(caseSensitivity));
  if (schema != null) {
    ArrayList<DBTable> result=new ArrayList<DBTable>();
    for (    DBTable match : tmpResult) {
      if (match.getADQLSchemaName() == null)       continue;
      if (IdentifierField.SCHEMA.isCaseSensitive(caseSensitivity)) {
        if (!match.getADQLSchemaName().equals(schema))         continue;
      }
 else {
        if (!match.getADQLSchemaName().equalsIgnoreCase(schema))         continue;
      }
      if (catalog != null) {
        if (match.getADQLCatalogName() == null)         continue;
        if (IdentifierField.CATALOG.isCaseSensitive(caseSensitivity)) {
          if (!match.getADQLCatalogName().equals(catalog))           continue;
        }
 else {
          if (!match.getADQLCatalogName().equalsIgnoreCase(catalog))           continue;
        }
      }
      result.add(match);
    }
    return result;
  }
 else   return tmpResult;
}",0.9591451917033312
25060,"@BeforeClass public static void setUpBeforeClass() throws Exception {
  tables=new ArrayList<DBTable>();
  DefaultDBTable fooTable=new DefaultDBTable(""String_Node_Str"");
  DBColumn col=new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.VARCHAR),fooTable);
  fooTable.addColumn(col);
  col=new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.INTEGER),fooTable);
  fooTable.addColumn(col);
  col=new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.POINT),fooTable);
  fooTable.addColumn(col);
  tables.add(fooTable);
}","@BeforeClass public static void setUpBeforeClass() throws Exception {
  tables=new ArrayList<DBTable>();
  DefaultDBTable fooTable=new DefaultDBTable(null,""String_Node_Str"",""String_Node_Str"");
  DBColumn col=new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.VARCHAR),fooTable);
  fooTable.addColumn(col);
  col=new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.INTEGER),fooTable);
  fooTable.addColumn(col);
  col=new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.POINT),fooTable);
  fooTable.addColumn(col);
  tables.add(fooTable);
  DefaultDBTable fooTable2=new DefaultDBTable(null,null,""String_Node_Str"");
  col=new DefaultDBColumn(""String_Node_Str"",new DBType(DBDatatype.BIGINT),fooTable2);
  fooTable2.addColumn(col);
  tables.add(fooTable2);
}",0.8196969696969697
25061,"final public ColumnReference ColumnRef() throws ParseException {
  trace_call(""String_Node_Str"");
  try {
    IdentifierItems identifiers=null;
    Token ind=null;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case DELIMITED_IDENTIFIER:
case REGULAR_IDENTIFIER:
      identifiers=ColumnName();
    break;
case UNSIGNED_INTEGER:
  ind=jj_consume_token(UNSIGNED_INTEGER);
break;
default :
jj_la1[20]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
try {
ColumnReference colRef=null;
if (identifiers != null) colRef=queryFactory.createColRef(identifiers);
 else colRef=queryFactory.createColRef(Integer.parseInt(ind.image),new TextPosition(ind));
{
if (true) return colRef;
}
}
 catch (Exception ex) {
{
if (true) throw generateParseException(ex);
}
}
throw new Error(""String_Node_Str"");
}
  finally {
trace_return(""String_Node_Str"");
}
}","final public ColumnReference ColumnRef() throws ParseException {
  trace_call(""String_Node_Str"");
  try {
    IdentifierItem identifier=null;
    Token ind=null;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case DELIMITED_IDENTIFIER:
case REGULAR_IDENTIFIER:
      identifier=Identifier();
    break;
case UNSIGNED_INTEGER:
  ind=jj_consume_token(UNSIGNED_INTEGER);
break;
default :
jj_la1[20]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
try {
ColumnReference colRef=null;
if (identifier != null) colRef=queryFactory.createColRef(identifier);
 else colRef=queryFactory.createColRef(Integer.parseInt(ind.image),new TextPosition(ind));
{
if (true) return colRef;
}
}
 catch (Exception ex) {
{
if (true) throw generateParseException(ex);
}
}
throw new Error(""String_Node_Str"");
}
  finally {
trace_return(""String_Node_Str"");
}
}",0.9709887507400828
25062,"final public ADQLOrder OrderItem() throws ParseException {
  trace_call(""String_Node_Str"");
  try {
    IdentifierItems identifiers=null;
    Token ind=null, desc=null;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case DELIMITED_IDENTIFIER:
case REGULAR_IDENTIFIER:
      identifiers=ColumnName();
    break;
case UNSIGNED_INTEGER:
  ind=jj_consume_token(UNSIGNED_INTEGER);
break;
default :
jj_la1[21]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ASC:
case DESC:
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ASC:
jj_consume_token(ASC);
break;
case DESC:
desc=jj_consume_token(DESC);
break;
default :
jj_la1[22]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
break;
default :
jj_la1[23]=jj_gen;
;
}
try {
ADQLOrder order=null;
if (identifiers != null) {
order=queryFactory.createOrder(identifiers,desc != null);
order.setPosition(identifiers.getPosition());
}
 else {
order=queryFactory.createOrder(Integer.parseInt(ind.image),desc != null);
order.setPosition(new TextPosition(ind));
}
{
if (true) return order;
}
}
 catch (Exception ex) {
{
if (true) throw generateParseException(ex);
}
}
throw new Error(""String_Node_Str"");
}
  finally {
trace_return(""String_Node_Str"");
}
}","final public ADQLOrder OrderItem() throws ParseException {
  trace_call(""String_Node_Str"");
  try {
    IdentifierItem identifier=null;
    Token ind=null, desc=null;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case DELIMITED_IDENTIFIER:
case REGULAR_IDENTIFIER:
      identifier=Identifier();
    break;
case UNSIGNED_INTEGER:
  ind=jj_consume_token(UNSIGNED_INTEGER);
break;
default :
jj_la1[21]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ASC:
case DESC:
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ASC:
jj_consume_token(ASC);
break;
case DESC:
desc=jj_consume_token(DESC);
break;
default :
jj_la1[22]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
break;
default :
jj_la1[23]=jj_gen;
;
}
try {
ADQLOrder order=null;
if (identifier != null) {
order=queryFactory.createOrder(identifier,desc != null);
order.setPosition(identifier.position);
}
 else {
order=queryFactory.createOrder(Integer.parseInt(ind.image),desc != null);
order.setPosition(new TextPosition(ind));
}
{
if (true) return order;
}
}
 catch (Exception ex) {
{
if (true) throw generateParseException(ex);
}
}
throw new Error(""String_Node_Str"");
}
  finally {
trace_return(""String_Node_Str"");
}
}",0.9717244125846276
25063,"public ADQLOrder createOrder(final IdentifierItems idItems,final boolean desc) throws Exception {
  ADQLOrder order=new ADQLOrder(idItems.join(""String_Node_Str""),desc);
  if (order != null)   order.setCaseSensitive(idItems.getColumnCaseSensitivity());
  return order;
}","/** 
 * @deprecated since 1.4 ; Former version's mistake: an ORDER BY item is either a regular/delimited column name or an integer, not a qualified column name ; Replaced by {@link #createOrder(Identifier,boolean)} ; This function is no longer used by ADQLParser. 
 */
@Deprecated public ADQLOrder createOrder(final IdentifierItems idItems,final boolean desc) throws Exception {
  ADQLOrder order=new ADQLOrder(idItems.join(""String_Node_Str""),desc);
  if (order != null)   order.setCaseSensitive(idItems.getColumnCaseSensitivity());
  return order;
}",0.6568986568986569
25064,"@Override public void init(final ServletConfig config) throws ServletException {
  if (tap != null)   return;
  String tapConfPath=config.getInitParameter(TAP_CONF_PARAMETER);
  if (tapConfPath == null || tapConfPath.trim().length() == 0)   tapConfPath=null;
  InputStream input=null;
  if (tapConfPath == null)   input=searchFile(DEFAULT_TAP_CONF_FILE,config);
 else {
    File f=new File(tapConfPath);
    if (f.exists()) {
      try {
        input=new FileInputStream(f);
      }
 catch (      IOException ioe) {
        throw new ServletException(""String_Node_Str"" + tapConfPath + ""String_Node_Str"",ioe);
      }
    }
 else     input=searchFile(tapConfPath,config);
  }
  if (input == null)   throw new ServletException(""String_Node_Str"" + ((tapConfPath == null) ? DEFAULT_TAP_CONF_FILE : tapConfPath) + ""String_Node_Str""+ TAP_CONF_PARAMETER+ ""String_Node_Str""+ DEFAULT_TAP_CONF_FILE+ ""String_Node_Str"");
  Properties tapConf=new Properties();
  try {
    tapConf.load(input);
  }
 catch (  IOException ioe) {
    throw new ServletException(""String_Node_Str"" + tapConfPath + ""String_Node_Str"",ioe);
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException ioe2) {
    }
  }
  ServiceConnection serviceConn=null;
  try {
    serviceConn=new ConfigurableServiceConnection(tapConf,config.getServletContext().getRealPath(""String_Node_Str""));
    tap=new TAP(serviceConn);
  }
 catch (  Exception ex) {
    tap=null;
    if (ex instanceof TAPException)     throw new ServletException(ex.getMessage(),ex.getCause());
 else     throw new ServletException(""String_Node_Str"",ex);
  }
  String propValue=getProperty(tapConf,KEY_HOME_PAGE);
  if (propValue != null) {
    if (isClassName(propValue)) {
      try {
        tap.setHomePage(newInstance(propValue,KEY_HOME_PAGE,HomePage.class,new Class<?>[]{TAP.class},new Object[]{tap}));
      }
 catch (      TAPException te) {
        throw new ServletException(te.getMessage(),te.getCause());
      }
    }
 else {
      tap.setHomePageURI(propValue);
      propValue=getProperty(tapConf,KEY_HOME_PAGE_MIME_TYPE);
      if (propValue != null)       tap.setHomePageMimeType(propValue);
    }
  }
  propValue=getProperty(tapConf,KEY_ADD_TAP_RESOURCES);
  if (propValue != null) {
    String[] lstResources=propValue.split(""String_Node_Str"");
    for (    String addRes : lstResources) {
      addRes=addRes.trim();
      if (addRes.length() > 0) {
        try {
          TAPResource newRes=newInstance(addRes,KEY_ADD_TAP_RESOURCES,TAPResource.class,new Class<?>[]{TAP.class},new Object[]{tap});
          if (newRes.getName() == null || newRes.getName().trim().length() == 0)           throw new TAPException(""String_Node_Str"" + addRes + ""String_Node_Str""+ KEY_ADD_TAP_RESOURCES+ ""String_Node_Str"");
          tap.addResource(newRes);
        }
 catch (        TAPException te) {
          throw new ServletException(te.getMessage(),te.getCause());
        }
      }
    }
  }
  super.init(config);
  serviceConn.setAvailable(true,""String_Node_Str"");
}","@Override public void init(final ServletConfig config) throws ServletException {
  if (tap != null)   return;
  String tapConfPath=config.getInitParameter(TAP_CONF_PARAMETER);
  if (tapConfPath == null || tapConfPath.trim().length() == 0)   tapConfPath=null;
  InputStream input=null;
  if (tapConfPath == null)   input=searchFile(DEFAULT_TAP_CONF_FILE,config);
 else {
    File f=new File(tapConfPath);
    if (f.exists()) {
      try {
        input=new FileInputStream(f);
      }
 catch (      IOException ioe) {
        throw new ServletException(""String_Node_Str"" + tapConfPath + ""String_Node_Str"",ioe);
      }
    }
 else     input=searchFile(tapConfPath,config);
  }
  if (input == null)   throw new ServletException(""String_Node_Str"" + ((tapConfPath == null) ? DEFAULT_TAP_CONF_FILE : tapConfPath) + ""String_Node_Str""+ TAP_CONF_PARAMETER+ ""String_Node_Str""+ DEFAULT_TAP_CONF_FILE+ ""String_Node_Str"");
  Properties tapConf=new Properties();
  try {
    tapConf.load(input);
  }
 catch (  IOException ioe) {
    throw new ServletException(""String_Node_Str"" + tapConfPath + ""String_Node_Str"",ioe);
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException ioe2) {
    }
  }
  ServiceConnection serviceConn=null;
  try {
    serviceConn=new ConfigurableServiceConnection(tapConf,config.getServletContext().getRealPath(""String_Node_Str""));
    tap=new TAP(serviceConn);
  }
 catch (  Exception ex) {
    tap=null;
    if (ex instanceof TAPException)     throw new ServletException(ex.getMessage(),ex.getCause());
 else     throw new ServletException(""String_Node_Str"",ex);
  }
  String propValue=getProperty(tapConf,KEY_HOME_PAGE);
  if (propValue != null) {
    if (isClassName(propValue)) {
      try {
        tap.setHomePage(newInstance(propValue,KEY_HOME_PAGE,HomePage.class,new Class<?>[]{TAP.class},new Object[]{tap}));
      }
 catch (      TAPException te) {
        throw new ServletException(te.getMessage(),te.getCause());
      }
    }
 else {
      tap.setHomePageURI(propValue);
      propValue=getProperty(tapConf,KEY_HOME_PAGE_MIME_TYPE);
      if (propValue != null)       tap.setHomePageMimeType(propValue);
    }
  }
  propValue=getProperty(tapConf,KEY_ADD_TAP_RESOURCES);
  if (propValue != null) {
    String[] lstResources=propValue.split(""String_Node_Str"");
    for (    String addRes : lstResources) {
      addRes=addRes.trim();
      if (addRes.length() > 0) {
        try {
          TAPResource newRes=newInstance(addRes,KEY_ADD_TAP_RESOURCES,TAPResource.class,new Class<?>[]{TAP.class},new Object[]{tap});
          if (newRes.getName() == null || newRes.getName().trim().length() == 0)           throw new TAPException(""String_Node_Str"" + addRes + ""String_Node_Str""+ KEY_ADD_TAP_RESOURCES+ ""String_Node_Str"");
          tap.addResource(newRes);
        }
 catch (        TAPException te) {
          throw new ServletException(te.getMessage(),te.getCause());
        }
      }
    }
  }
  super.init(config);
  tap.init(config);
  serviceConn.setAvailable(true,""String_Node_Str"");
}",0.9966953073364178
25065,"@Override public void run(){
  try {
    tb.streamStarTable(input,sink,null);
  }
 catch (  IOException e) {
    if (e.getMessage() != null && !e.getMessage().equals(""String_Node_Str""))     e.printStackTrace();
  }
}","@Override public void run(){
  try {
    tb.streamStarTable(input,sink,null);
  }
 catch (  IOException e) {
    if (e.getMessage() != null && !e.getMessage().equals(STREAM_ABORTED_MESSAGE))     e.printStackTrace();
  }
}",0.919908466819222
25066,"/** 
 * Build a TableIterator able to read rows and columns inside the given VOTable input stream.
 * @param input	Input stream over a VOTable document.
 * @throws NullPointerException	If NULL is given in parameter.
 * @throws DataReadException	If the given VOTable can not be parsed.
 */
public VOTableIterator(final InputStream input) throws DataReadException {
  if (input == null)   throw new NullPointerException(""String_Node_Str"");
  this.input=input;
  try {
    final TableBuilder tb=(new StarTableFactory()).getTableBuilder(""String_Node_Str"");
    sink=new StreamVOTableSink();
    Thread streamThread=new Thread(){
      @Override public void run(){
        try {
          tb.streamStarTable(input,sink,null);
        }
 catch (        IOException e) {
          if (e.getMessage() != null && !e.getMessage().equals(""String_Node_Str""))           e.printStackTrace();
        }
      }
    }
;
    streamThread.start();
  }
 catch (  Exception ex) {
    throw new DataReadException(""String_Node_Str"",ex);
  }
}","/** 
 * Build a TableIterator able to read rows and columns inside the given VOTable input stream.
 * @param input	Input stream over a VOTable document.
 * @throws NullPointerException	If NULL is given in parameter.
 * @throws DataReadException	If the given VOTable can not be parsed.
 */
public VOTableIterator(final InputStream input) throws DataReadException {
  if (input == null)   throw new NullPointerException(""String_Node_Str"");
  this.input=input;
  try {
    final TableBuilder tb=(new StarTableFactory()).getTableBuilder(""String_Node_Str"");
    sink=new StreamVOTableSink();
    Thread streamThread=new Thread(){
      @Override public void run(){
        try {
          tb.streamStarTable(input,sink,null);
        }
 catch (        IOException e) {
          if (e.getMessage() != null && !e.getMessage().equals(STREAM_ABORTED_MESSAGE))           e.printStackTrace();
        }
      }
    }
;
    streamThread.start();
  }
 catch (  Exception ex) {
    throw new DataReadException(""String_Node_Str"",ex);
  }
}",0.8332518337408313
25067,"@Override public synchronized void acceptRow(final Object[] row) throws IOException {
  try {
    while (!endReached && pendingRow != null)     wait();
    if (endReached)     throw new IOException(""String_Node_Str"");
    pendingRow=row;
    if (pendingRow == null)     endReached=true;
  }
 catch (  InterruptedException ie) {
    pendingRow=null;
    endReached=true;
  }
 finally {
    notifyAll();
  }
}","@Override public synchronized void acceptRow(final Object[] row) throws IOException {
  try {
    while (!endReached && pendingRow != null)     wait();
    if (endReached)     throw new IOException(STREAM_ABORTED_MESSAGE);
    pendingRow=row;
    if (pendingRow == null)     endReached=true;
  }
 catch (  InterruptedException ie) {
    pendingRow=null;
    endReached=true;
  }
 finally {
    notifyAll();
  }
}",0.9621489621489622
25068,"/** 
 * <p>Upload all the given VOTable inputs.</p> <p><i>Note: The   {@link TAPTable} objects representing the uploaded tables will be associated with the TAP_UPLOAD schema specified at the creation of this {@link Uploader}. If no such schema was specified, a default one (whose DB name will be equals to the ADQL name, that's to say   {@link STDSchema#UPLOADSCHEMA}) is created, will be associated with the uploaded tables and will be returned by this function. </i></p>
 * @param uploads	Array of tables to upload.
 * @return	A {@link TAPSchema} containing the list and the description of all uploaded tables.
 * @throws TAPException	If any error occurs while reading the VOTable inputs or while uploading the table into the ""database"".
 * @see DBConnection#addUploadedTable(TAPTable,tap.data.TableIterator)
 */
public TAPSchema upload(final DALIUpload[] uploads) throws TAPException {
  InputStream votable=null;
  String tableName=null;
  try {
    for (    DALIUpload upl : uploads) {
      tableName=upl.label;
      votable=upl.open();
      TableIterator dataIt=new LimitedTableIterator(VOTableIterator.class,votable,limitUnit,limit);
      TAPColumn[] columns=dataIt.getMetadata();
      TAPTable table=new TAPTable(tableName);
      table.setDBName(tableName + ""String_Node_Str"" + System.currentTimeMillis());
      for (      TAPColumn col : columns)       table.addColumn(col);
      uploadSchema.addTable(table);
      dbConn.addUploadedTable(table,dataIt);
      votable.close();
      votable=null;
    }
  }
 catch (  DataReadException dre) {
    if (dre.getCause() instanceof ExceededSizeException)     throw dre;
 else     throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str""+ dre.getMessage(),dre,UWSException.BAD_REQUEST);
  }
catch (  IOException ioe) {
    throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str"",ioe);
  }
catch (  UnsupportedURIProtocolException e) {
    throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str"",e);
  }
 finally {
    try {
      if (votable != null)       votable.close();
    }
 catch (    IOException ioe) {
      ;
    }
  }
  return uploadSchema;
}","/** 
 * <p>Upload all the given VOTable inputs.</p> <p><i>Note: The   {@link TAPTable} objects representing the uploaded tables will be associated with the TAP_UPLOAD schema specified at the creation of this {@link Uploader}. If no such schema was specified, a default one (whose DB name will be equals to the ADQL name, that's to say   {@link STDSchema#UPLOADSCHEMA}) is created, will be associated with the uploaded tables and will be returned by this function. </i></p>
 * @param uploads	Array of tables to upload.
 * @return	A {@link TAPSchema} containing the list and the description of all uploaded tables.
 * @throws TAPException	If any error occurs while reading the VOTable inputs or while uploading the table into the ""database"".
 * @see DBConnection#addUploadedTable(TAPTable,tap.data.TableIterator)
 */
public TAPSchema upload(final DALIUpload[] uploads) throws TAPException {
  TableIterator dataIt=null;
  InputStream votable=null;
  String tableName=null;
  try {
    for (    DALIUpload upl : uploads) {
      tableName=upl.label;
      votable=upl.open();
      dataIt=new LimitedTableIterator(VOTableIterator.class,votable,limitUnit,limit);
      TAPColumn[] columns=dataIt.getMetadata();
      TAPTable table=new TAPTable(tableName);
      table.setDBName(tableName + ""String_Node_Str"" + System.currentTimeMillis());
      for (      TAPColumn col : columns)       table.addColumn(col);
      uploadSchema.addTable(table);
      dbConn.addUploadedTable(table,dataIt);
      dataIt.close();
      votable.close();
      votable=null;
    }
  }
 catch (  DataReadException dre) {
    if (dre.getCause() instanceof ExceededSizeException)     throw dre;
 else     throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str""+ dre.getMessage(),dre,UWSException.BAD_REQUEST);
  }
catch (  IOException ioe) {
    throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str"",ioe);
  }
catch (  UnsupportedURIProtocolException e) {
    throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str"",e);
  }
 finally {
    try {
      if (dataIt != null)       dataIt.close();
      if (votable != null)       votable.close();
    }
 catch (    IOException ioe) {
      ;
    }
  }
  return uploadSchema;
}",0.9743938363924768
25069,"@Override public synchronized void endRows() throws IOException {
  pendingRow=null;
  endReached=true;
  notifyAll();
}","@Override public synchronized void endRows() throws IOException {
  try {
    while (!endReached && pendingRow != null)     wait();
  }
 catch (  InterruptedException ie) {
  }
 finally {
    pendingRow=null;
    endReached=true;
    notifyAll();
  }
}",0.510752688172043
25070,"public void run(){
  try {
    tb.streamStarTable(input,sink,null);
  }
 catch (  IOException e) {
    if (e.getMessage() != null && !e.getMessage().equals(""String_Node_Str""))     e.printStackTrace();
  }
}","@Override public void run(){
  try {
    tb.streamStarTable(input,sink,null);
  }
 catch (  IOException e) {
    if (e.getMessage() != null && !e.getMessage().equals(""String_Node_Str""))     e.printStackTrace();
  }
}",0.976303317535545
25071,"/** 
 * <p>Get the last accepted row.</p> <p><i>Note: This function is blocking until a row has been accepted or the end of the stream has been reached. A Thread interruption will also make this function returning. </i></p>
 * @return
 */
public synchronized Object[] getRow(){
  try {
    while (!endReached && pendingRow == null)     wait();
    if (endReached)     return null;
    Object[] row=pendingRow;
    pendingRow=null;
    return row;
  }
 catch (  InterruptedException ie) {
    endReached=true;
    return null;
  }
 finally {
    notifyAll();
  }
}","/** 
 * <p>Get the last accepted row.</p> <p><i>Note: This function is blocking until a row has been accepted or the end of the stream has been reached. A Thread interruption will also make this function returning. </i></p>
 * @return
 */
public synchronized Object[] getRow(){
  try {
    while (!endReached && pendingRow == null)     wait();
    if (endReached && pendingRow == null)     return null;
    Object[] row=pendingRow;
    pendingRow=null;
    return row;
  }
 catch (  InterruptedException ie) {
    endReached=true;
    return null;
  }
 finally {
    notifyAll();
  }
}",0.980836236933798
25072,"/** 
 * Build a TableIterator able to read rows and columns inside the given VOTable input stream.
 * @param input	Input stream over a VOTable document.
 * @throws NullPointerException	If NULL is given in parameter.
 * @throws DataReadException	If the given VOTable can not be parsed.
 */
public VOTableIterator(final InputStream input) throws DataReadException {
  if (input == null)   throw new NullPointerException(""String_Node_Str"");
  this.input=input;
  try {
    final TableBuilder tb=(new StarTableFactory()).getTableBuilder(""String_Node_Str"");
    sink=new StreamVOTableSink();
    Thread streamThread=new Thread(){
      public void run(){
        try {
          tb.streamStarTable(input,sink,null);
        }
 catch (        IOException e) {
          if (e.getMessage() != null && !e.getMessage().equals(""String_Node_Str""))           e.printStackTrace();
        }
      }
    }
;
    streamThread.start();
  }
 catch (  Exception ex) {
    throw new DataReadException(""String_Node_Str"",ex);
  }
}","/** 
 * Build a TableIterator able to read rows and columns inside the given VOTable input stream.
 * @param input	Input stream over a VOTable document.
 * @throws NullPointerException	If NULL is given in parameter.
 * @throws DataReadException	If the given VOTable can not be parsed.
 */
public VOTableIterator(final InputStream input) throws DataReadException {
  if (input == null)   throw new NullPointerException(""String_Node_Str"");
  this.input=input;
  try {
    final TableBuilder tb=(new StarTableFactory()).getTableBuilder(""String_Node_Str"");
    sink=new StreamVOTableSink();
    Thread streamThread=new Thread(){
      @Override public void run(){
        try {
          tb.streamStarTable(input,sink,null);
        }
 catch (        IOException e) {
          if (e.getMessage() != null && !e.getMessage().equals(""String_Node_Str""))           e.printStackTrace();
        }
      }
    }
;
    streamThread.start();
  }
 catch (  Exception ex) {
    throw new DataReadException(""String_Node_Str"",ex);
  }
}",0.9950738916256158
25073,"@Override @SuppressWarnings(""String_Node_Str"") public final Map<String,Object> parse(final HttpServletRequest request) throws UWSException {
  LinkedHashMap<String,Object> parameters=new LinkedHashMap<String,Object>();
  MultipartRequest multipart=null;
  try {
    multipart=new MultipartRequest(request,UWSFileManager.TMP_UPLOAD_DIR.getPath(),(SIZE_LIMIT < 0 ? DEFAULT_SIZE_LIMIT : SIZE_LIMIT),new FileRenamePolicy(){
      @Override public File rename(      File file){
        Object reqID=request.getAttribute(UWS.REQ_ATTRIBUTE_ID);
        if (reqID == null || !(reqID instanceof String))         reqID=(new Date()).getTime();
        char uniq='A';
        File f=new File(file.getParentFile(),""String_Node_Str"" + reqID + uniq+ ""String_Node_Str""+ file.getName());
        while (f.exists()) {
          uniq++;
          f=new File(file.getParentFile(),""String_Node_Str"" + reqID + ""String_Node_Str""+ file.getName());
        }
        return f;
      }
    }
);
    String param;
    Enumeration<String> e=multipart.getParameterNames();
    while (e.hasMoreElements()) {
      param=e.nextElement();
      for (      String occurence : multipart.getParameterValues(param))       consumeParameter(param,occurence,parameters);
    }
    e=multipart.getFileNames();
    if (!allowUpload && e.hasMoreElements())     throw new UWSException(UWSException.BAD_REQUEST,""String_Node_Str"");
    while (e.hasMoreElements()) {
      param=e.nextElement();
      UploadFile lob=new UploadFile(param,multipart.getOriginalFileName(param),multipart.getFile(param).toURI().toString(),fileManager);
      lob.mimeType=multipart.getContentType(param);
      lob.length=multipart.getFile(param).length();
      consumeParameter(param,lob,parameters);
    }
  }
 catch (  IOException ioe) {
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,ioe,""String_Node_Str"");
  }
catch (  IllegalArgumentException iae) {
    String confError=iae.getMessage();
    if (UWSFileManager.TMP_UPLOAD_DIR == null)     confError=""String_Node_Str"";
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,iae,""String_Node_Str"" + confError);
  }
  return parameters;
}","@Override @SuppressWarnings(""String_Node_Str"") public final Map<String,Object> parse(final HttpServletRequest request) throws UWSException {
  LinkedHashMap<String,Object> parameters=new LinkedHashMap<String,Object>();
  MultipartRequest multipart=null;
  try {
    multipart=new MultipartRequest(request,UWSFileManager.TMP_UPLOAD_DIR.getPath(),(SIZE_LIMIT < 0 ? DEFAULT_SIZE_LIMIT : SIZE_LIMIT),new FileRenamePolicy(){
      @Override public File rename(      File file){
        Object reqID=request.getAttribute(UWS.REQ_ATTRIBUTE_ID);
        if (reqID == null || !(reqID instanceof String))         reqID=(new Date()).getTime();
        char uniq='A';
        File f=new File(file.getParentFile(),""String_Node_Str"" + reqID + uniq+ ""String_Node_Str""+ file.getName());
        while (f.exists()) {
          uniq++;
          f=new File(file.getParentFile(),""String_Node_Str"" + reqID + ""String_Node_Str""+ file.getName());
        }
        return f;
      }
    }
);
    String param;
    Enumeration<String> e=multipart.getParameterNames();
    while (e.hasMoreElements()) {
      param=e.nextElement();
      for (      String occurence : multipart.getParameterValues(param))       consumeParameter(param,occurence,parameters);
    }
    e=multipart.getFileNames();
    if (!allowUpload && e.hasMoreElements())     throw new UWSException(UWSException.BAD_REQUEST,""String_Node_Str"");
    while (e.hasMoreElements()) {
      param=e.nextElement();
      if (multipart.getFile(param) == null)       continue;
      UploadFile lob=new UploadFile(param,multipart.getOriginalFileName(param),multipart.getFile(param).toURI().toString(),fileManager);
      lob.mimeType=multipart.getContentType(param);
      lob.length=multipart.getFile(param).length();
      consumeParameter(param,lob,parameters);
    }
  }
 catch (  IOException ioe) {
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,ioe,""String_Node_Str"");
  }
catch (  IllegalArgumentException iae) {
    String confError=iae.getMessage();
    if (UWSFileManager.TMP_UPLOAD_DIR == null)     confError=""String_Node_Str"";
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,iae,""String_Node_Str"" + confError);
  }
  return parameters;
}",0.9862385321100916
25074,"/** 
 * <p>Start the execution of this job in order to execute the given ADQL query.</p> <p>The execution itself will be processed by an   {@link ADQLExecutor} inside a thread ({@link SyncThread}).</p> <p><b>Important:</b> No error should be written in this function. If any error occurs it should be thrown, in order to be manager on a top level. </p>
 * @param response	Response in which the result must be written.
 * @return	<i>true</i> if the execution was successful, <i>false</i> otherwise.
 * @throws IllegalStateException	If this synchronous job has already been started before.
 * @throws TAPException				If any error occurs while executing the ADQL query.
 * @see SyncThread
 */
public synchronized boolean start(final HttpServletResponse response) throws IllegalStateException, TAPException {
  if (startedAt != null)   throw new IllegalStateException(""String_Node_Str"");
  service.getLogger().logTAP(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",null);
  ADQLExecutor executor;
  try {
    executor=service.getFactory().createADQLExecutor();
  }
 catch (  TAPException e) {
    service.getLogger().logTAP(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str"",e);
    return false;
  }
  thread=new SyncThread(executor,ID,tapParams,response);
  thread.start();
  boolean timeout=false;
  try {
    thread.join(tapParams.getExecutionDuration());
    if (thread.isAlive()) {
      timeout=true;
      thread.interrupt();
      thread.join(waitForStop);
    }
  }
 catch (  InterruptedException ie) {
  }
 finally {
    execReport=thread.getExecutionReport();
  }
  Throwable error=thread.getError();
  if (timeout && error != null && error instanceof InterruptedException) {
    if (thread.isAlive())     service.getLogger().logTAP(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"" + tapParams.getExecutionDuration() + ""String_Node_Str""+ ID+ ""String_Node_Str"",null);
 else     service.getLogger().logTAP(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + tapParams.getExecutionDuration() + ""String_Node_Str""+ ID+ ""String_Node_Str"",null);
    throw new TAPException(""String_Node_Str"" + tapParams.getExecutionDuration() + ""String_Node_Str"",UWSException.ACCEPTED_BUT_NOT_COMPLETE);
  }
 else   if (!thread.isSuccess()) {
    if (error instanceof InterruptedException) {
      service.getLogger().logTAP(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",error);
      throw new TAPException(""String_Node_Str"" + ID + ""String_Node_Str"",UWSException.ACCEPTED_BUT_NOT_COMPLETE);
    }
 else     if (error instanceof TAPException) {
      service.getLogger().logTAP(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",error);
      throw (TAPException)error;
    }
 else {
      service.getLogger().logTAP(LogLevel.FATAL,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",error);
      if (error instanceof Error)       throw (Error)error;
 else       throw new TAPException(error);
    }
  }
 else   service.getLogger().logTAP(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",null);
  return thread.isSuccess();
}","/** 
 * <p>Start the execution of this job in order to execute the given ADQL query.</p> <p>The execution itself will be processed by an   {@link ADQLExecutor} inside a thread ({@link SyncThread}).</p> <p><b>Important:</b> No error should be written in this function. If any error occurs it should be thrown, in order to be manager on a top level. </p>
 * @param response	Response in which the result must be written.
 * @return	<i>true</i> if the execution was successful, <i>false</i> otherwise.
 * @throws IllegalStateException	If this synchronous job has already been started before.
 * @throws TAPException				If any error occurs while executing the ADQL query.
 * @see SyncThread
 */
public synchronized boolean start(final HttpServletResponse response) throws IllegalStateException, TAPException {
  if (startedAt != null)   throw new IllegalStateException(""String_Node_Str"");
  service.getLogger().logTAP(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",null);
  ADQLExecutor executor;
  try {
    executor=service.getFactory().createADQLExecutor();
  }
 catch (  TAPException e) {
    service.getLogger().logTAP(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str"",e);
    return false;
  }
  thread=new SyncThread(executor,ID,tapParams,response);
  thread.start();
  boolean timeout=false;
  try {
    thread.join(tapParams.getExecutionDuration() * 1000);
    if (thread.isAlive()) {
      timeout=true;
      thread.interrupt();
      thread.join(waitForStop);
    }
  }
 catch (  InterruptedException ie) {
  }
 finally {
    execReport=thread.getExecutionReport();
  }
  Throwable error=thread.getError();
  if (timeout && error != null && error instanceof InterruptedException) {
    if (thread.isAlive())     service.getLogger().logTAP(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"" + tapParams.getExecutionDuration() + ""String_Node_Str""+ ID+ ""String_Node_Str"",null);
 else     service.getLogger().logTAP(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + tapParams.getExecutionDuration() + ""String_Node_Str""+ ID+ ""String_Node_Str"",null);
    throw new TAPException(""String_Node_Str"" + tapParams.getExecutionDuration() + ""String_Node_Str"",UWSException.ACCEPTED_BUT_NOT_COMPLETE);
  }
 else   if (!thread.isSuccess()) {
    if (error instanceof InterruptedException) {
      service.getLogger().logTAP(LogLevel.WARNING,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",error);
      throw new TAPException(""String_Node_Str"" + ID + ""String_Node_Str"",UWSException.ACCEPTED_BUT_NOT_COMPLETE);
    }
 else     if (error instanceof TAPException) {
      service.getLogger().logTAP(LogLevel.ERROR,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",error);
      throw (TAPException)error;
    }
 else {
      service.getLogger().logTAP(LogLevel.FATAL,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",error);
      if (error instanceof Error)       throw (Error)error;
 else       throw new TAPException(error);
    }
  }
 else   service.getLogger().logTAP(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"" + ID + ""String_Node_Str"",null);
  return thread.isSuccess();
}",0.9989084671760486
25075,"@Override public void logTAP(final LogLevel level,final Object obj,final String event,final String message,final Throwable error){
  String jobId=null, msgAppend=null;
  try {
    if (event != null && obj != null) {
      if (event.equals(""String_Node_Str""))       msgAppend=""String_Node_Str"" + ((TAPParameters)obj).getQuery().replaceAll(""String_Node_Str"",""String_Node_Str"");
 else       if (event.equals(""String_Node_Str""))       jobId=((TAPSyncJob)obj).getID();
 else       if (obj instanceof TAPExecutionReport) {
        TAPExecutionReport report=(TAPExecutionReport)obj;
        jobId=report.jobID;
        msgAppend=(report.synchronous ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + report.getTotalDuration()+ ""String_Node_Str""+ report.getUploadDuration()+ ""String_Node_Str""+ report.getParsingDuration()+ ""String_Node_Str""+ report.getExecutionDuration()+ ""String_Node_Str""+ report.parameters.getFormat()+ ""String_Node_Str""+ report.getFormattingDuration()+ ""String_Node_Str"";
      }
    }
    if (msgAppend != null)     msgAppend=""String_Node_Str"" + msgAppend;
  }
 catch (  Throwable t) {
    error(""String_Node_Str"",t);
  }
  log(level,""String_Node_Str"",event,jobId,message + msgAppend,error);
}","@Override public void logTAP(final LogLevel level,final Object obj,final String event,final String message,final Throwable error){
  String jobId=null, msgAppend=null;
  try {
    if (event != null && obj != null) {
      if (event.equals(""String_Node_Str""))       msgAppend=""String_Node_Str"" + ((TAPParameters)obj).getQuery().replaceAll(""String_Node_Str"",""String_Node_Str"");
 else       if (event.equals(""String_Node_Str""))       jobId=((TAPSyncJob)obj).getID();
 else       if (obj instanceof TAPExecutionReport) {
        TAPExecutionReport report=(TAPExecutionReport)obj;
        jobId=report.jobID;
        msgAppend=(report.synchronous ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + report.getTotalDuration()+ ""String_Node_Str""+ report.getUploadDuration()+ ""String_Node_Str""+ report.getParsingDuration()+ ""String_Node_Str""+ report.getExecutionDuration()+ ""String_Node_Str""+ report.parameters.getFormat()+ ""String_Node_Str""+ report.getFormattingDuration()+ ""String_Node_Str"";
      }
    }
    if (msgAppend != null)     msgAppend=""String_Node_Str"" + msgAppend;
  }
 catch (  Throwable t) {
    error(""String_Node_Str"",t);
  }
  log(level,""String_Node_Str"",event,jobId,message + (msgAppend != null ? msgAppend : ""String_Node_Str""),error);
}",0.9758064516129032
25076,"/** 
 * <p>Get all uploads specified in the DALI parameter ""UPLOAD"" from the given request parameters.</p> <p><i>Note: This function is case INsensitive for the ""UPLOAD"" parameter. </i></p> <p><b>WARNING:</b> Calling this function modifies the given map ONLY IF the ""UPLOAD"" parameter (whatever is its case) is found. In such case, the following modifications are applied: </p> <ul> <li> All ""UPLOAD"" parameters will be removed and then added again in the map with their corresponding   {@link DALIUpload} item (not any more a String).</li> <li> If <i>allowTAPSyntax</i> is <i>true</i>, several uploads may be specified in the same ""UPLOAD"" parameter value. For more clarity for the user (once the parameters listed), this list of uploads will be split in the same number of ""UPLOAD"" parameters. That's to say, there will be only one ""UPLOAD"" item in the Map, but its value will be an array containing every specified uploads: <i>an array of  {@link DALIUpload} objects</i>.</li> <li> If there is at least one ""UPLOAD"" parameter, all uploaded files (parameters associated with instances of  {@link UploadFile}) will be removed from the map (and also from the file system). They are indeed not useful for a DALI service since all interesting uploads have already been listed. </li> </ul> <p><i>Note: This function can be called several times on the same map. After a first call, this function will just gathers into a List all found   {@link DALIUpload} objects. Of course, only uploads specified in the ""UPLOAD"" parameter(s) will be returned and others will be removedas explained above. </i></p> <h3>DALI and TAP syntax</h3> <p> The ""UPLOAD"" parameter lists all files to consider as uploaded. The syntax for one item is the following: ""{name},{uri}"", where {uri} is ""param:{param-ref}"" when the file is provided inline in the parameter named {param-ref}, otherwise, it can be any valid URI (http:..., ftp:..., vos:..., ivo:..., etc...). </p> <p> The parameter <i>allowTAPSyntax</i> lets switch between the DALI and TAP syntax. The only difference between them, is in the way to list multiple uploads. In TAP, they can be given as a semicolon separated list in a single parameter, whereas in DALI, there must be submitted as several individual parameters. For instance: </p> <ul> <li><b>In TAP:</b> ""UPLOAD=tableA,param:foo;tableB,http://..."" =&gt; only 1 parameter</li> <li><b>In DALI:</b> ""UPLOAD=tableA,param:foo"" and ""UPLOAD=tableB,http://..."" =&gt; 2 parameters</li> </ul> <p><i>Note: Because of the possible presence of a semicolon in a URI (which is also used as separator of uploads in the TAP syntax), there could be a problem while splitting the uploads specified in ""UPLOAD"". In that case, it is strongly recommended to either encode the URI (in UTF-8) (i.e. "";"" becomes ""%3B"") or to merely restrict the syntax to the DALI one. In this last case, the parameter  {@link #allowTAPSyntax} should be set to <i>false</i> and then all parameters should be submitted individually.</i></p>
 * @param requestParams		All parameters extracted from an HTTP request by a {@link RequestParser}.
 * @param allowTAPSyntax	<i>true</i> to allow a list of several upload items in one ""UPLOAD"" parameter value (each item separated by a semicolon),<i>false</i> to forbid it (and so, multiple upload items shall be submitted individually).
 * @param fileManager		The file manager to use in order to build a {@link DALIUpload} objects from a URI.<i>(a link to the file manager will be set in the  {@link DALIUpload} object in order to open itwhenever it will asked after its creation)</i>
 * @return	List of all uploads specified with the DALI or TAP syntax.
 * @throws TAPException	If the syntax of an ""UPLOAD"" parameter is wrong.
 * @see {@link RequestParser#parse(javax.servlet.http.HttpServletRequest)}
 */
public final static List<DALIUpload> getDALIUploads(final Map<String,Object> requestParams,final boolean allowTAPSyntax,final UWSFileManager fileManager) throws TAPException {
  ArrayList<DALIUpload> uploads=new ArrayList<DALIUpload>(3);
  ArrayList<String> usedFiles=new ArrayList<String>(3);
  Iterator<Map.Entry<String,Object>> it=requestParams.entrySet().iterator();
  Map.Entry<String,Object> entry;
  Object value;
  while (it.hasNext()) {
    entry=it.next();
    if (entry.getKey() != null && entry.getKey().toLowerCase().equals(TAPJob.PARAM_UPLOAD)) {
      value=entry.getValue();
      if (value != null) {
        if (value instanceof DALIUpload) {
          DALIUpload upl=(DALIUpload)value;
          uploads.add(upl);
          if (!upl.isByReference())           usedFiles.add(upl.file.paramName);
        }
 else         if (value instanceof String)         fetchDALIUploads(uploads,usedFiles,(String)value,requestParams,allowTAPSyntax,fileManager);
 else         if (value.getClass().isArray()) {
          Object[] objects=(Object[])value;
          for (          Object o : objects) {
            if (o != null) {
              if (o instanceof DALIUpload)               uploads.add((DALIUpload)o);
 else               if (o instanceof String)               fetchDALIUploads(uploads,usedFiles,(String)o,requestParams,allowTAPSyntax,fileManager);
            }
          }
        }
      }
      it.remove();
    }
  }
  if (uploads.size() > 0) {
    it=requestParams.entrySet().iterator();
    while (it.hasNext()) {
      entry=it.next();
      value=entry.getValue();
      if (value == null)       it.remove();
 else       if (value instanceof UploadFile && !usedFiles.contains(entry.getKey())) {
        try {
          ((UploadFile)value).deleteFile();
        }
 catch (        IOException ioe) {
        }
        it.remove();
      }
 else       if (value.getClass().isArray()) {
        Object[] objects=(Object[])value;
        int cnt=objects.length;
        for (int i=0; i < objects.length; i++) {
          if (objects[i] == null) {
            objects[i]=null;
            cnt--;
          }
 else           if (objects[i] instanceof UploadFile && !usedFiles.contains(entry.getKey())) {
            try {
              ((UploadFile)objects[i]).deleteFile();
            }
 catch (            IOException ioe) {
            }
            objects[i]=null;
            cnt--;
          }
        }
        if (cnt == 0)         it.remove();
      }
    }
  }
  requestParams.put(""String_Node_Str"",uploads.toArray(new DALIUpload[uploads.size()]));
  return uploads;
}","/** 
 * <p>Get all uploads specified in the DALI parameter ""UPLOAD"" from the given request parameters.</p> <p><i>Note: This function is case INsensitive for the ""UPLOAD"" parameter. </i></p> <p><b>WARNING:</b> Calling this function modifies the given map ONLY IF the ""UPLOAD"" parameter (whatever is its case) is found. In such case, the following modifications are applied: </p> <ul> <li> All ""UPLOAD"" parameters will be removed and then added again in the map with their corresponding   {@link DALIUpload} item (not any more a String).</li> <li> If <i>allowTAPSyntax</i> is <i>true</i>, several uploads may be specified in the same ""UPLOAD"" parameter value. For more clarity for the user (once the parameters listed), this list of uploads will be split in the same number of ""UPLOAD"" parameters. That's to say, there will be only one ""UPLOAD"" item in the Map, but its value will be an array containing every specified uploads: <i>an array of  {@link DALIUpload} objects</i>.</li> <li> If there is at least one ""UPLOAD"" parameter, all uploaded files (parameters associated with instances of  {@link UploadFile}) will be removed from the map (and also from the file system). They are indeed not useful for a DALI service since all interesting uploads have already been listed. </li> </ul> <p><i>Note: This function can be called several times on the same map. After a first call, this function will just gathers into a List all found   {@link DALIUpload} objects. Of course, only uploads specified in the ""UPLOAD"" parameter(s) will be returned and others will be removedas explained above. </i></p> <h3>DALI and TAP syntax</h3> <p> The ""UPLOAD"" parameter lists all files to consider as uploaded. The syntax for one item is the following: ""{name},{uri}"", where {uri} is ""param:{param-ref}"" when the file is provided inline in the parameter named {param-ref}, otherwise, it can be any valid URI (http:..., ftp:..., vos:..., ivo:..., etc...). </p> <p> The parameter <i>allowTAPSyntax</i> lets switch between the DALI and TAP syntax. The only difference between them, is in the way to list multiple uploads. In TAP, they can be given as a semicolon separated list in a single parameter, whereas in DALI, there must be submitted as several individual parameters. For instance: </p> <ul> <li><b>In TAP:</b> ""UPLOAD=tableA,param:foo;tableB,http://..."" =&gt; only 1 parameter</li> <li><b>In DALI:</b> ""UPLOAD=tableA,param:foo"" and ""UPLOAD=tableB,http://..."" =&gt; 2 parameters</li> </ul> <p><i>Note: Because of the possible presence of a semicolon in a URI (which is also used as separator of uploads in the TAP syntax), there could be a problem while splitting the uploads specified in ""UPLOAD"". In that case, it is strongly recommended to either encode the URI (in UTF-8) (i.e. "";"" becomes ""%3B"") or to merely restrict the syntax to the DALI one. In this last case, the parameter  {@link #allowTAPSyntax} should be set to <i>false</i> and then all parameters should be submitted individually.</i></p>
 * @param requestParams		All parameters extracted from an HTTP request by a {@link RequestParser}.
 * @param allowTAPSyntax	<i>true</i> to allow a list of several upload items in one ""UPLOAD"" parameter value (each item separated by a semicolon),<i>false</i> to forbid it (and so, multiple upload items shall be submitted individually).
 * @param fileManager		The file manager to use in order to build a {@link DALIUpload} objects from a URI.<i>(a link to the file manager will be set in the  {@link DALIUpload} object in order to open itwhenever it will asked after its creation)</i>
 * @return	List of all uploads specified with the DALI or TAP syntax.
 * @throws TAPException	If the syntax of an ""UPLOAD"" parameter is wrong.
 * @see {@link RequestParser#parse(javax.servlet.http.HttpServletRequest)}
 */
public final static List<DALIUpload> getDALIUploads(final Map<String,Object> requestParams,final boolean allowTAPSyntax,final UWSFileManager fileManager) throws TAPException {
  ArrayList<DALIUpload> uploads=new ArrayList<DALIUpload>(3);
  ArrayList<String> usedFiles=new ArrayList<String>(3);
  Iterator<Map.Entry<String,Object>> it=requestParams.entrySet().iterator();
  Map.Entry<String,Object> entry;
  Object value;
  while (it.hasNext()) {
    entry=it.next();
    if (entry.getKey() != null && entry.getKey().toLowerCase().equals(TAPJob.PARAM_UPLOAD)) {
      value=entry.getValue();
      if (value != null) {
        if (value instanceof DALIUpload) {
          DALIUpload upl=(DALIUpload)value;
          uploads.add(upl);
          if (!upl.isByReference())           usedFiles.add(upl.file.paramName);
        }
 else         if (value instanceof String)         fetchDALIUploads(uploads,usedFiles,(String)value,requestParams,allowTAPSyntax,fileManager);
 else         if (value.getClass().isArray()) {
          Object[] objects=(Object[])value;
          for (          Object o : objects) {
            if (o != null) {
              if (o instanceof DALIUpload)               uploads.add((DALIUpload)o);
 else               if (o instanceof String)               fetchDALIUploads(uploads,usedFiles,(String)o,requestParams,allowTAPSyntax,fileManager);
            }
          }
        }
      }
      it.remove();
    }
  }
  if (uploads.size() > 0) {
    it=requestParams.entrySet().iterator();
    while (it.hasNext()) {
      entry=it.next();
      value=entry.getValue();
      if (value == null)       it.remove();
 else       if (value instanceof UploadFile && !usedFiles.contains(entry.getKey())) {
        try {
          ((UploadFile)value).deleteFile();
        }
 catch (        IOException ioe) {
        }
        it.remove();
      }
 else       if (value.getClass().isArray()) {
        Object[] objects=(Object[])value;
        int cnt=objects.length;
        for (int i=0; i < objects.length; i++) {
          if (objects[i] == null) {
            objects[i]=null;
            cnt--;
          }
 else           if (objects[i] instanceof UploadFile && !usedFiles.contains(entry.getKey())) {
            try {
              ((UploadFile)objects[i]).deleteFile();
            }
 catch (            IOException ioe) {
            }
            objects[i]=null;
            cnt--;
          }
        }
        if (cnt == 0)         it.remove();
      }
    }
  }
  if (uploads.size() > 0)   requestParams.put(""String_Node_Str"",uploads.toArray(new DALIUpload[uploads.size()]));
  return uploads;
}",0.9979725514660012
25077,"@Override public TAPColumn[] getMetadata(){
  return innerIt.getMetadata();
}","@Override public TAPColumn[] getMetadata() throws DataReadException {
  return innerIt.getMetadata();
}",0.8555555555555555
25078,"/** 
 * <p>Get all the metadata column that have been successfully extracted at the creation of this iterator.</p> <p><b>Important:</b> This function should be callable at any moment from the creation of the iterator until the end of the table dataset has been reached.</p> <p><i>Note: This function MAY BE NOT IMPLEMENTED or the metadata can not be fetched. In this case, NULL will be returned.</i></p> <p><i><b>Warning:</b> If the metadata part of the original document is corrupted (i.e. false number of columns), the column type information should be fetched thanks to   {@link #getColType()} while iterating over rows and columns.</i></p>
 * @return	An array of {@link TAPColumn} objects (each for a column of any row),or NULL if this function is not implemented OR if it was not possible to get these metadata.
 * @see #getColType()
 */
public TAPColumn[] getMetadata();","/** 
 * <p>Get all the metadata column that have been successfully extracted at the creation of this iterator.</p> <p><b>Important:</b> This function should be callable at any moment from the creation of the iterator until the end of the table dataset has been reached.</p> <p><i>Note: This function MAY BE NOT IMPLEMENTED or the metadata can not be fetched. In this case, NULL will be returned.</i></p> <p><i><b>Warning:</b> If the metadata part of the original document is corrupted (i.e. false number of columns), the column type information should be fetched thanks to   {@link #getColType()} while iterating over rows and columns.</i></p>
 * @return	An array of {@link TAPColumn} objects (each for a column of any row),or NULL if this function is not implemented OR if it was not possible to get these metadata.
 * @see #getColType()
 */
public TAPColumn[] getMetadata() throws DataReadException ;",0.9853768278965128
25079,"/** 
 * <p>Gets the list of columns (database metadata) selected by this query.</p> <p><i><u>Note:</u> The list is generated on the fly !</i></p>
 * @return	Selected columns metadata.
 */
public DBColumn[] getResultingColumns(){
  ArrayList<DBColumn> columns=new ArrayList<DBColumn>(select.size());
  for (  SelectItem item : select) {
    ADQLOperand operand=item.getOperand();
    if (item instanceof SelectAllColumns) {
      try {
        columns.addAll(from.getDBColumns());
      }
 catch (      ParseException pe) {
      }
    }
 else {
      DBColumn col=null;
      if (item.hasAlias()) {
        if (operand instanceof ADQLColumn && ((ADQLColumn)operand).getDBLink() != null) {
          col=((ADQLColumn)operand).getDBLink();
          col=col.copy(col.getDBName(),item.getAlias(),col.getTable());
        }
 else         col=new DefaultDBColumn(item.getAlias(),null);
      }
 else {
        if (operand instanceof ADQLColumn && ((ADQLColumn)operand).getDBLink() != null)         col=((ADQLColumn)operand).getDBLink();
        if (col == null)         col=new DefaultDBColumn(item.getName(),null);
      }
      columns.add(col);
    }
  }
  DBColumn[] resColumns=new DBColumn[columns.size()];
  return columns.toArray(resColumns);
}","/** 
 * <p>Gets the list of columns (database metadata) selected by this query.</p> <p><i><u>Note:</u> The list is generated on the fly !</i></p>
 * @return	Selected columns metadata.
 */
public DBColumn[] getResultingColumns(){
  ArrayList<DBColumn> columns=new ArrayList<DBColumn>(select.size());
  for (  SelectItem item : select) {
    ADQLOperand operand=item.getOperand();
    if (item instanceof SelectAllColumns) {
      try {
        if (((SelectAllColumns)item).getAdqlTable() != null)         columns.addAll(((SelectAllColumns)item).getAdqlTable().getDBColumns());
 else         columns.addAll(from.getDBColumns());
      }
 catch (      ParseException pe) {
      }
    }
 else {
      DBColumn col=null;
      if (item.hasAlias()) {
        if (operand instanceof ADQLColumn && ((ADQLColumn)operand).getDBLink() != null) {
          col=((ADQLColumn)operand).getDBLink();
          col=col.copy(col.getDBName(),item.getAlias(),col.getTable());
        }
 else         col=new DefaultDBColumn(item.getAlias(),null);
      }
 else {
        if (operand instanceof ADQLColumn && ((ADQLColumn)operand).getDBLink() != null)         col=((ADQLColumn)operand).getDBLink();
        if (col == null)         col=new DefaultDBColumn(item.getName(),null);
      }
      columns.add(col);
    }
  }
  DBColumn[] resColumns=new DBColumn[columns.size()];
  return columns.toArray(resColumns);
}",0.9442970822281168
25080,"public ADQLObject next() throws NoSuchElementException {
  if (tableGot)   throw new NoSuchElementException();
  tableGot=true;
  return adqlTable;
}","@Override public ADQLObject next() throws NoSuchElementException {
  if (tableGot)   throw new NoSuchElementException();
  tableGot=true;
  return adqlTable;
}",0.9675324675324676
25081,"public void replace(ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
  if (replacer == null)   remove();
 else   if (!tableGot)   throw new IllegalStateException(""String_Node_Str"");
 else   if (!(replacer instanceof ADQLTable))   throw new IllegalStateException(""String_Node_Str"" + replacer.getClass().getName() + ""String_Node_Str"");
 else   adqlTable=(ADQLTable)replacer;
}","@Override public void replace(ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
  if (replacer == null)   remove();
 else   if (!tableGot)   throw new IllegalStateException(""String_Node_Str"");
 else   if (!(replacer instanceof ADQLTable))   throw new IllegalStateException(""String_Node_Str"" + replacer.getClass().getName() + ""String_Node_Str"");
 else   adqlTable=(ADQLTable)replacer;
}",0.9878934624697336
25082,"@Override public final ADQLIterator adqlIterator(){
  return new ADQLIterator(){
    private boolean tableGot=(adqlTable == null);
    public ADQLObject next() throws NoSuchElementException {
      if (tableGot)       throw new NoSuchElementException();
      tableGot=true;
      return adqlTable;
    }
    public boolean hasNext(){
      return !tableGot;
    }
    public void replace(    ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
      if (replacer == null)       remove();
 else       if (!tableGot)       throw new IllegalStateException(""String_Node_Str"");
 else       if (!(replacer instanceof ADQLTable))       throw new IllegalStateException(""String_Node_Str"" + replacer.getClass().getName() + ""String_Node_Str"");
 else       adqlTable=(ADQLTable)replacer;
    }
    public void remove(){
      if (!tableGot)       throw new IllegalStateException(""String_Node_Str"");
 else       throw new UnsupportedOperationException(""String_Node_Str"" + adqlTable.toADQL() + ""String_Node_Str""+ toADQL()+ ""String_Node_Str"");
    }
  }
;
}","@Override public final ADQLIterator adqlIterator(){
  return new ADQLIterator(){
    private boolean tableGot=(adqlTable == null);
    @Override public ADQLObject next() throws NoSuchElementException {
      if (tableGot)       throw new NoSuchElementException();
      tableGot=true;
      return adqlTable;
    }
    @Override public boolean hasNext(){
      return !tableGot;
    }
    @Override public void replace(    ADQLObject replacer) throws UnsupportedOperationException, IllegalStateException {
      if (replacer == null)       remove();
 else       if (!tableGot)       throw new IllegalStateException(""String_Node_Str"");
 else       if (!(replacer instanceof ADQLTable))       throw new IllegalStateException(""String_Node_Str"" + replacer.getClass().getName() + ""String_Node_Str"");
 else       adqlTable=(ADQLTable)replacer;
    }
    @Override public void remove(){
      if (!tableGot)       throw new IllegalStateException(""String_Node_Str"");
 else       throw new UnsupportedOperationException(""String_Node_Str"" + adqlTable.toADQL() + ""String_Node_Str""+ toADQL()+ ""String_Node_Str"");
    }
  }
;
}",0.9817184643510056
25083,"public boolean hasNext(){
  return !tableGot;
}","@Override public boolean hasNext(){
  return !tableGot;
}",0.903846153846154
25084,"public void remove(){
  if (!tableGot)   throw new IllegalStateException(""String_Node_Str"");
 else   throw new UnsupportedOperationException(""String_Node_Str"" + adqlTable.toADQL() + ""String_Node_Str""+ toADQL()+ ""String_Node_Str"");
}","@Override public void remove(){
  if (!tableGot)   throw new IllegalStateException(""String_Node_Str"");
 else   throw new UnsupportedOperationException(""String_Node_Str"" + adqlTable.toADQL() + ""String_Node_Str""+ toADQL()+ ""String_Node_Str"");
}",0.978902953586498
25085,"/** 
 * Sets the table whose all columns must be selected.
 * @param table	An {@link ADQLTable} (MUST NOT BE NULL).
 */
public final void setAdqlTable(final ADQLTable table){
  if (table == null) {
    adqlTable=table;
    query=null;
  }
}","/** 
 * Sets the table whose all columns must be selected.
 * @param table	An {@link ADQLTable} (MUST NOT BE NULL).
 */
public final void setAdqlTable(final ADQLTable table){
  if (table != null) {
    adqlTable=table;
    query=null;
  }
}",0.9958333333333332
25086,"/** 
 * <p><i>Note: Unless the standard implementation -   {@link ADQLExecutor} - does not fit exactly your needs,it should not be necessary to extend this class and to extend this function (implemented here by default). </i></p>
 * @see tap.TAPFactory#createADQLExecutor()
 */
@Override public ADQLExecutor createADQLExecutor() throws TAPException {
  return new ADQLExecutor(service);
}","/** 
 * <p><i>Note: Unless the standard implementation -   {@link ADQLExecutor} - does not fit exactly your needs,it should not be necessary to extend this class and to extend this function (implemented here by default). </i></p>
 */
@Override public ADQLExecutor createADQLExecutor() throws TAPException {
  return new ADQLExecutor(service);
}",0.76775956284153
25087,"/** 
 * <p>This implementation provides a basic   {@link TAPJob} instance.</p><p> If you need to add or modify the behavior of some functions of a  {@link TAPJob}, you must override this function and return your own extension of   {@link TAPJob}. </p>
 * @see tap.TAPFactory#createTAPJob(javax.servlet.http.HttpServletRequest,uws.job.user.JobOwner)
 */
@Override protected TAPJob createTAPJob(final String jobId,final JobOwner owner,final TAPParameters params,final long quote,final long startTime,final long endTime,final List<Result> results,final ErrorSummary error) throws UWSException {
  try {
    return new TAPJob(jobId,owner,params,quote,startTime,endTime,results,error);
  }
 catch (  TAPException te) {
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,te,""String_Node_Str"");
  }
}","/** 
 * <p>This implementation provides a basic   {@link TAPJob} instance.</p><p> If you need to add or modify the behavior of some functions of a  {@link TAPJob}, you must override this function and return your own extension of   {@link TAPJob}. </p>
 */
@Override protected TAPJob createTAPJob(final String jobId,final JobOwner owner,final TAPParameters params,final long quote,final long startTime,final long endTime,final List<Result> results,final ErrorSummary error) throws UWSException {
  try {
    return new TAPJob(jobId,owner,params,quote,startTime,endTime,results,error);
  }
 catch (  TAPException te) {
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,te,""String_Node_Str"");
  }
}",0.9358041032428857
25088,"/** 
 * <p>Create an object able to check the consistency between the ADQL query and the database. That's to say, it checks whether the tables and columns used in the query really exist in the database.</p> <p><i>Note: This implementation just create a   {@link DBChecker} instance with the list given in parameter.</i></p>
 * @param tables	List of all available tables (and indirectly, columns).
 * @return	A new ADQL query checker.
 * @throws TAPException	If any error occurs while creating the query checker.
 * @see DBChecker
 */
protected QueryChecker createQueryChecker(final Collection<TAPTable> tables) throws TAPException {
  return new DBChecker(tables);
}","/** 
 * <p>Create an object able to check the consistency between the ADQL query and the database. That's to say, it checks whether the tables and columns used in the query really exist in the database.</p> <p><i>Note: This implementation just create a   {@link DBChecker} instance with the list given in parameter.</i></p>
 * @param tables	List of all available tables (and indirectly, columns).
 * @return	A new ADQL query checker.
 * @throws TAPException	If any error occurs while creating the query checker.
 */
protected QueryChecker createQueryChecker(final Collection<TAPTable> tables) throws TAPException {
  return new DBChecker(tables);
}",0.9863013698630136
25089,"/** 
 * <p>This implementation extracts standard TAP parameters from the given request.</p> <p> Non-standard TAP parameters are added in a map inside the returned   {@link TAPParameters} objectand are accessible with  {@link TAPParameters#get(String)} and {@link TAPParameters#getAdditionalParameters()}. However, if you want to manage them in another way, you must extend   {@link TAPParameters} and overridethis function in order to return an instance of your extension. </p>
 * @see tap.TAPFactory#createTAPParameters(javax.servlet.http.HttpServletRequest)
 */
@Override public TAPParameters createTAPParameters(final Map<String,Object> params) throws TAPException {
  try {
    return new TAPParameters(service,params,getExpectedAdditionalParameters(),getInputParamControllers());
  }
 catch (  UWSException ue) {
    throw new TAPException(ue);
  }
}","/** 
 * <p>This implementation extracts standard TAP parameters from the given request.</p> <p> Non-standard TAP parameters are added in a map inside the returned   {@link TAPParameters} objectand are accessible with  {@link TAPParameters#get(String)} and {@link TAPParameters#getAdditionalParameters()}. However, if you want to manage them in another way, you must extend   {@link TAPParameters} and overridethis function in order to return an instance of your extension. </p>
 */
@Override public TAPParameters createTAPParameters(final Map<String,Object> params) throws TAPException {
  try {
    return new TAPParameters(service,params,getExpectedAdditionalParameters(),getInputParamControllers());
  }
 catch (  UWSException ue) {
    throw new TAPException(ue);
  }
}",0.9496314496314496
25090,"/** 
 * <p>This implementation does not provided a backup manager. It means that no asynchronous job will be restored and backuped.</p> <p>You must override this function if you want enable the backup feature.</p>
 * @see tap.TAPFactory#createUWSBackupManager(uws.service.UWSService)
 */
@Override public UWSBackupManager createUWSBackupManager(final UWSService uws) throws TAPException {
  return null;
}","/** 
 * <p>This implementation does not provided a backup manager. It means that no asynchronous job will be restored and backuped.</p> <p>You must override this function if you want enable the backup feature.</p>
 */
@Override public UWSBackupManager createUWSBackupManager(final UWSService uws) throws TAPException {
  return null;
}",0.9054054054054054
25091,"/** 
 * <p><i>Note: This function should be extended if you have customized the creation of any  {@link ADQLQuery} part ; it could be the addition of one or several user defined functionor the modification of any ADQL function or clause specific to your implementation. </i></p>
 * @see tap.TAPFactory#createQueryFactory()
 */
@Override public ADQLQueryFactory createQueryFactory() throws TAPException {
  return new ADQLQueryFactory();
}","/** 
 * <p><i>Note: This function should be extended if you have customized the creation of any  {@link ADQLQuery} part ; it could be the addition of one or several user defined functionor the modification of any ADQL function or clause specific to your implementation. </i></p>
 */
@Override public ADQLQueryFactory createQueryFactory() throws TAPException {
  return new ADQLQueryFactory();
}",0.9471153846153846
25092,"/** 
 * <p>This implementation just create an   {@link Uploader} instance with the given database connection.</p><p><i>Note: This function should be overrided if the way user tables are interpreted and then created into the database does not fit yours needs. </i></p>
 * @see tap.TAPFactory#createUploader(tap.db.DBConnection)
 * @see Uploader
 */
@Override public Uploader createUploader(final DBConnection dbConn) throws TAPException {
  return new Uploader(service,dbConn);
}","/** 
 * <p>This implementation just create an   {@link Uploader} instance with the given database connection.</p><p><i>Note: This function should be overrided if you need to change the DB name of the TAP_UPLOAD schema. Indeed, by overriding this function you can specify a given TAPSchema to use as TAP_UPLOAD schema in the constructor of  {@link Uploader}. But do not forget that this   {@link TAPSchema} instance MUST havean ADQL name equals to ""TAP_UPLOAD"", otherwise, a TAPException will be thrown. </i></p>
 */
@Override public Uploader createUploader(final DBConnection dbConn) throws TAPException {
  return new Uploader(service,dbConn);
}",0.5498220640569395
25093,"/** 
 * <p>This implementation just create a   {@link UWSService} instance.</p><p><i>Note: This implementation is largely enough for a TAP service. It is not recommended to override this function. </i></p>
 * @see tap.TAPFactory#createUWS()
 */
@Override public UWSService createUWS() throws TAPException {
  UWSService uws=new UWSService(this,this.service.getFileManager(),this.service.getLogger());
  uws.setErrorWriter(errorWriter);
  return uws;
}","/** 
 * <p>This implementation just create a   {@link UWSService} instance.</p><p><i>Note: This implementation is largely enough for a TAP service. It is not recommended to override this function. </i></p>
 */
@Override public UWSService createUWS() throws TAPException {
  UWSService uws=new UWSService(this,this.service.getFileManager(),this.service.getLogger());
  uws.setErrorWriter(errorWriter);
  return uws;
}",0.9596309111880046
25094,"/** 
 * <p>Upload all the given VOTable inputs.</p> <p><i>Note: The   {@link TAPTable} objects representing the uploaded tables will be associated with the TAP_UPLOAD schema defined in the TAP metadata.If no such schema is defined, a default one (whose DB name will be equals to the ADQL name, that's to say  {@link STDSchema#UPLOADSCHEMA}) is created and added into the TAP metadata. The corresponding schema should be then created in the database automatically by the   {@link DBConnection}. </i></p>
 * @param loaders	Array of tables to upload.
 * @return	A {@link TAPSchema} containing the list and the description of all uploaded tables.
 * @throws TAPException	If any error occurs while reading the VOTable inputs or while uploading the table into the ""database"".
 * @see DBConnection#addUploadedTable(TAPTable,tap.data.TableIterator)
 */
public TAPSchema upload(final TableLoader[] loaders) throws TAPException {
  TAPSchema uploadSchema=service.getTAPMetadata().getUploadSchema();
  if (uploadSchema == null) {
    uploadSchema=new TAPSchema(STDSchema.UPLOADSCHEMA.label);
    service.getTAPMetadata().setUploadSchema(uploadSchema);
  }
  InputStream votable=null;
  String tableName=null;
  try {
    for (    TableLoader loader : loaders) {
      tableName=loader.tableName;
      votable=loader.openStream();
      TableIterator dataIt=new LimitedTableIterator(VOTableIterator.class,votable,limitUnit,limit);
      TAPColumn[] columns=dataIt.getMetadata();
      TAPTable table=new TAPTable(tableName);
      table.setDBName(tableName + ""String_Node_Str"" + System.currentTimeMillis());
      for (      TAPColumn col : columns)       table.addColumn(col);
      uploadSchema.addTable(table);
      dbConn.addUploadedTable(table,dataIt);
      votable.close();
      votable=null;
    }
  }
 catch (  DataReadException dre) {
    if (dre.getCause() instanceof ExceededSizeException)     throw dre;
 else     throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str""+ dre.getMessage(),dre,UWSException.BAD_REQUEST);
  }
catch (  IOException ioe) {
    throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str"",ioe);
  }
 finally {
    try {
      if (votable != null)       votable.close();
    }
 catch (    IOException ioe) {
      ;
    }
  }
  return uploadSchema;
}","/** 
 * <p>Upload all the given VOTable inputs.</p> <p><i>Note: The   {@link TAPTable} objects representing the uploaded tables will be associated with the TAP_UPLOAD schema specified at the creation of this {@link Uploader}. If no such schema was specified, a default one (whose DB name will be equals to the ADQL name, that's to say   {@link STDSchema#UPLOADSCHEMA}) is created, will be associated with the uploaded tables and will be returned by this function. </i></p>
 * @param loaders	Array of tables to upload.
 * @return	A {@link TAPSchema} containing the list and the description of all uploaded tables.
 * @throws TAPException	If any error occurs while reading the VOTable inputs or while uploading the table into the ""database"".
 * @see DBConnection#addUploadedTable(TAPTable,tap.data.TableIterator)
 */
public TAPSchema upload(final TableLoader[] loaders) throws TAPException {
  InputStream votable=null;
  String tableName=null;
  try {
    for (    TableLoader loader : loaders) {
      tableName=loader.tableName;
      votable=loader.openStream();
      TableIterator dataIt=new LimitedTableIterator(VOTableIterator.class,votable,limitUnit,limit);
      TAPColumn[] columns=dataIt.getMetadata();
      TAPTable table=new TAPTable(tableName);
      table.setDBName(tableName + ""String_Node_Str"" + System.currentTimeMillis());
      for (      TAPColumn col : columns)       table.addColumn(col);
      uploadSchema.addTable(table);
      dbConn.addUploadedTable(table,dataIt);
      votable.close();
      votable=null;
    }
  }
 catch (  DataReadException dre) {
    if (dre.getCause() instanceof ExceededSizeException)     throw dre;
 else     throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str""+ dre.getMessage(),dre,UWSException.BAD_REQUEST);
  }
catch (  IOException ioe) {
    throw new TAPException(""String_Node_Str"" + tableName + ""String_Node_Str"",ioe);
  }
 finally {
    try {
      if (votable != null)       votable.close();
    }
 catch (    IOException ioe) {
      ;
    }
  }
  return uploadSchema;
}",0.8769195507678204
25095,"/** 
 * Build an   {@link Uploader} object.
 * @param service	Specification of the TAP service using this uploader.
 * @param dbConn	A valid (open) connection to the ""database"".
 * @throws TAPException	If any error occurs while building this {@link Uploader}.
 */
public Uploader(final ServiceConnection service,final DBConnection dbConn) throws TAPException {
  if (service == null)   throw new NullPointerException(""String_Node_Str"");
  if (dbConn == null)   throw new NullPointerException(""String_Node_Str"");
  this.service=service;
  this.dbConn=dbConn;
  if (this.service.uploadEnabled()) {
    if (this.service.getUploadLimitType()[1] != null && this.service.getUploadLimit()[1] > 0) {
      limit=this.service.getUploadLimit()[1];
      limitUnit=this.service.getUploadLimitType()[1];
    }
 else {
      limit=-1;
      limitUnit=null;
    }
  }
 else   throw new TAPException(""String_Node_Str"");
}","/** 
 * Build an   {@link Uploader} object.
 * @param service	Specification of the TAP service using this uploader.
 * @param dbConn	A valid (open) connection to the ""database"".
 * @throws TAPException	If any error occurs while building this {@link Uploader}.
 * @since 2.0
 */
public Uploader(final ServiceConnection service,final DBConnection dbConn,final TAPSchema uplSchema) throws TAPException {
  if (service == null)   throw new NullPointerException(""String_Node_Str"");
  if (dbConn == null)   throw new NullPointerException(""String_Node_Str"");
  this.service=service;
  this.dbConn=dbConn;
  if (uplSchema != null) {
    if (!uplSchema.getADQLName().equalsIgnoreCase(TAPMetadata.STDSchema.UPLOADSCHEMA.label))     throw new TAPException(""String_Node_Str"" + TAPMetadata.STDSchema.UPLOADSCHEMA.label + ""String_Node_Str""+ uplSchema.getADQLName()+ ""String_Node_Str"",UWSException.INTERNAL_SERVER_ERROR);
 else     this.uploadSchema=uplSchema;
  }
 else   this.uploadSchema=new TAPSchema(TAPMetadata.STDSchema.UPLOADSCHEMA.label,""String_Node_Str"");
  if (this.service.uploadEnabled()) {
    if (this.service.getUploadLimitType()[1] != null && this.service.getUploadLimit()[1] > 0) {
      limit=this.service.getUploadLimit()[1];
      limitUnit=this.service.getUploadLimitType()[1];
    }
 else {
      limit=-1;
      limitUnit=null;
    }
  }
 else   throw new TAPException(""String_Node_Str"");
}",0.786117136659436
25096,"protected void doGetJobParam(UWSUrl requestUrl,HttpServletRequest req,HttpServletResponse resp,JobOwner user) throws UWSException, ServletException, IOException {
  UWSJob job=getJob(requestUrl,user);
  String[] attributes=requestUrl.getAttributes();
  if (attributes[0].equalsIgnoreCase(UWSJob.PARAM_RESULTS) && attributes.length > 1) {
    Result result=job.getResult(attributes[1]);
    if (result == null)     throw new UWSException(UWSException.NOT_FOUND,""String_Node_Str"" + attributes[1] + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"");
 else     if (result.getHref() != null && !result.getHref().trim().isEmpty() && !result.getHref().equalsIgnoreCase(req.getRequestURL().toString()))     redirect(result.getHref(),req,user,UWSAction.GET_JOB_PARAM,resp);
 else {
      InputStream input=null;
      try {
        input=getFileManager().getResultInput(result,job);
        UWSToolBox.write(input,result.getMimeType(),result.getSize(),resp);
      }
 catch (      IOException ioe) {
        getLogger().logUWS(LogLevel.ERROR,result,""String_Node_Str"",""String_Node_Str"" + result.getId() + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"",ioe);
        throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,ioe,""String_Node_Str"" + result.getId() + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"");
      }
 finally {
        if (input != null)         input.close();
      }
    }
  }
 else   if (attributes[0].equalsIgnoreCase(UWSJob.PARAM_ERROR_SUMMARY) && attributes.length > 1 && attributes[1].equalsIgnoreCase(""String_Node_Str"")) {
    ErrorSummary error=job.getErrorSummary();
    if (error == null)     throw new UWSException(UWSException.NOT_FOUND,""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
 else {
      InputStream input=null;
      try {
        input=getFileManager().getErrorInput(error,job);
        UWSToolBox.write(input,""String_Node_Str"",getFileManager().getErrorSize(error,job),resp);
      }
 catch (      IOException ioe) {
        getLogger().logUWS(LogLevel.ERROR,error,""String_Node_Str"",""String_Node_Str"" + job.getJobId() + ""String_Node_Str"",ioe);
        throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,ioe,""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
      }
 finally {
        if (input != null)         input.close();
      }
    }
  }
 else {
    UWSSerializer serializer=getSerializer(req.getHeader(""String_Node_Str""));
    String uwsField=attributes[0];
    boolean jobSerialization=false;
    if (uwsField == null || uwsField.trim().isEmpty() || (attributes.length <= 1 && (uwsField.equalsIgnoreCase(UWSJob.PARAM_ERROR_SUMMARY) || uwsField.equalsIgnoreCase(UWSJob.PARAM_RESULTS) || uwsField.equalsIgnoreCase(UWSJob.PARAM_PARAMETERS)))) {
      resp.setContentType(serializer.getMimeType());
      jobSerialization=true;
    }
 else     resp.setContentType(""String_Node_Str"");
    try {
      job.serialize(resp.getOutputStream(),attributes,serializer);
    }
 catch (    Exception e) {
      if (!(e instanceof UWSException)) {
        String errorMsgPart=(jobSerialization ? ""String_Node_Str"" + job.getJobId() + ""String_Node_Str"" : ""String_Node_Str"" + uwsField + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"");
        getLogger().logUWS(LogLevel.ERROR,requestUrl,""String_Node_Str"",""String_Node_Str"" + errorMsgPart + ""String_Node_Str"",e);
        throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,e,""String_Node_Str"" + errorMsgPart + ""String_Node_Str"");
      }
 else       throw (UWSException)e;
    }
  }
}","protected void doGetJobParam(UWSUrl requestUrl,HttpServletRequest req,HttpServletResponse resp,JobOwner user) throws UWSException, ServletException, IOException {
  UWSJob job=getJob(requestUrl,user);
  String[] attributes=requestUrl.getAttributes();
  if (attributes[0].equalsIgnoreCase(UWSJob.PARAM_RESULTS) && attributes.length > 1) {
    Result result=job.getResult(attributes[1]);
    if (result == null)     throw new UWSException(UWSException.NOT_FOUND,""String_Node_Str"" + attributes[1] + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"");
 else     if (result.getHref() != null && !result.getHref().trim().isEmpty() && !result.getHref().equalsIgnoreCase(req.getRequestURL().toString()))     redirect(result.getHref(),req,user,UWSAction.GET_JOB_PARAM,resp);
 else {
      InputStream input=null;
      try {
        input=getFileManager().getResultInput(result,job);
        UWSToolBox.write(input,result.getMimeType(),result.getSize(),resp);
      }
 catch (      IOException ioe) {
        getLogger().logUWS(LogLevel.ERROR,result,""String_Node_Str"",""String_Node_Str"" + result.getId() + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"",ioe);
        throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,ioe,""String_Node_Str"" + result.getId() + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"");
      }
 finally {
        if (input != null)         input.close();
      }
    }
  }
 else   if (attributes[0].equalsIgnoreCase(UWSJob.PARAM_ERROR_SUMMARY) && attributes.length > 1 && attributes[1].equalsIgnoreCase(""String_Node_Str"")) {
    ErrorSummary error=job.getErrorSummary();
    if (error == null)     throw new UWSException(UWSException.NOT_FOUND,""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
 else {
      InputStream input=null;
      try {
        input=getFileManager().getErrorInput(error,job);
        UWSToolBox.write(input,errorWriter.getErrorDetailsMIMEType(),getFileManager().getErrorSize(error,job),resp);
      }
 catch (      IOException ioe) {
        getLogger().logUWS(LogLevel.ERROR,error,""String_Node_Str"",""String_Node_Str"" + job.getJobId() + ""String_Node_Str"",ioe);
        throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,ioe,""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
      }
 finally {
        if (input != null)         input.close();
      }
    }
  }
 else {
    UWSSerializer serializer=getSerializer(req.getHeader(""String_Node_Str""));
    String uwsField=attributes[0];
    boolean jobSerialization=false;
    if (uwsField == null || uwsField.trim().isEmpty() || (attributes.length <= 1 && (uwsField.equalsIgnoreCase(UWSJob.PARAM_ERROR_SUMMARY) || uwsField.equalsIgnoreCase(UWSJob.PARAM_RESULTS) || uwsField.equalsIgnoreCase(UWSJob.PARAM_PARAMETERS)))) {
      resp.setContentType(serializer.getMimeType());
      jobSerialization=true;
    }
 else     resp.setContentType(""String_Node_Str"");
    try {
      job.serialize(resp.getOutputStream(),attributes,serializer);
    }
 catch (    Exception e) {
      if (!(e instanceof UWSException)) {
        String errorMsgPart=(jobSerialization ? ""String_Node_Str"" + job.getJobId() + ""String_Node_Str"" : ""String_Node_Str"" + uwsField + ""String_Node_Str""+ job.getJobId()+ ""String_Node_Str"");
        getLogger().logUWS(LogLevel.ERROR,requestUrl,""String_Node_Str"",""String_Node_Str"" + errorMsgPart + ""String_Node_Str"",e);
        throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,e,""String_Node_Str"" + errorMsgPart + ""String_Node_Str"");
      }
 else       throw (UWSException)e;
    }
  }
}",0.992336077206926
25097,"/** 
 * <p>This function lets generating a unique ID.</p> <p><i><b>By default:</b> System.currentTimeMillis()+UpperCharacter (UpperCharacter: one upper-case character: A, B, C, ....)</i></p> <p><i><u>note: </u> DO NOT USE in this function any of the following functions:   {@link #getLogger()},  {@link #getFileManager()} and {@link #getFactory()}. All of them will return NULL, because this job does not yet know its jobs list (which is needed to know the UWS and so, all of the objects returned by these functions).</i></p>
 * @return	A unique job identifier.
 */
protected String generateJobId(){
  String generatedId=System.currentTimeMillis() + ""String_Node_Str"";
  if (lastId != null) {
    while (lastId.equals(generatedId))     generatedId=generatedId.substring(0,generatedId.length() - 1) + (char)(generatedId.charAt(generatedId.length() - 1) + 1);
  }
  lastId=generatedId;
  return generatedId;
}","/** 
 * <p>This function lets generating a unique ID.</p> <p><i><b>By default:</b> System.currentTimeMillis()+UpperCharacter (UpperCharacter: one upper-case character: A, B, C, ....)</i></p> <p><i><u>note: </u> DO NOT USE in this function any of the following functions:   {@link #getLogger()},  {@link #getFileManager()} and {@link #getFactory()}. All of them will return NULL, because this job does not yet know its jobs list (which is needed to know the UWS and so, all of the objects returned by these functions).</i></p>
 * @return	A unique job identifier.
 */
protected String generateJobId(){
synchronized (lastId) {
    String generatedId=System.currentTimeMillis() + ""String_Node_Str"";
    if (lastId != null) {
      while (lastId.equals(generatedId))       generatedId=generatedId.substring(0,generatedId.length() - 1) + (char)(generatedId.charAt(generatedId.length() - 1) + 1);
    }
    lastId=generatedId;
    return generatedId;
  }
}",0.9773706896551724
25098,"/** 
 * Build a basic TAPFactory. Nothing is done except setting the service connection.
 * @param service	Configuration of the TAP service. <i>MUST NOT be NULL</i>
 * @throws NullPointerException	If the given {@link ServiceConnection} is NULL.
 * @see {@link TAPFactory#TAPFactory(ServiceConnection)}
 */
protected AbstractTAPFactory(ServiceConnection service) throws NullPointerException {
  super(service);
}","/** 
 * <p>Build a basic TAPFactory. Nothing is done except setting the service connection and the given error writer.</p> <p>Then the error writer will be used when creating a UWS service and a job thread.</p>
 * @param service		Configuration of the TAP service. <i>MUST NOT be NULL</i>
 * @param errorWriter	Object to use to format and write the errors for the user.
 * @throws NullPointerException	If the given {@link ServiceConnection} is NULL.
 * @see {@link TAPFactory#TAPFactory(ServiceConnection)}
 */
protected AbstractTAPFactory(final ServiceConnection service,final ServiceErrorWriter errorWriter) throws NullPointerException {
  super(service);
  this.errorWriter=errorWriter;
}",0.7465940054495913
25099,"/** 
 * <p>This implementation just create a   {@link UWSService} instance.</p><p><i>Note: This implementation is largely enough for a TAP service. It is not recommended to override this function. </i></p>
 * @see tap.TAPFactory#createUWS()
 */
@Override public UWSService createUWS() throws TAPException {
  return new UWSService(this,this.service.getFileManager(),this.service.getLogger());
}","/** 
 * <p>This implementation just create a   {@link UWSService} instance.</p><p><i>Note: This implementation is largely enough for a TAP service. It is not recommended to override this function. </i></p>
 * @see tap.TAPFactory#createUWS()
 */
@Override public UWSService createUWS() throws TAPException {
  UWSService uws=new UWSService(this,this.service.getFileManager(),this.service.getLogger());
  uws.setErrorWriter(errorWriter);
  return uws;
}",0.9112426035502958
25100,"public AsyncThread(TAPJob j,ADQLExecutor executor) throws UWSException {
  super(j,""String_Node_Str"" + j.getJobId());
  this.executor=executor;
}","/** 
 * Build a TAP asynchronous job execution.
 * @param j				Description of the job to execute.
 * @param executor		The object to use for the ADQL execution itself.
 * @param errorWriter	The object to use to format and to write an execution error for the user.
 * @throws NullPointerException	If the job parameter is missing.
 */
public AsyncThread(final TAPJob j,final ADQLExecutor executor,final ServiceErrorWriter errorWriter) throws NullPointerException {
  super(j,""String_Node_Str"" + j.getJobId(),errorWriter);
  this.executor=executor;
}",0.4109985528219971
25101,"public final TAPJob getTAPJob(){
  return (TAPJob)job;
}","/** 
 * Get the description of the job that this thread is executing.
 * @return	The executed job.
 */
public final TAPJob getTAPJob(){
  return (TAPJob)job;
}",0.5209302325581395
25102,"/** 
 * <p>Create the thread which will execute the task described by the given UWSJob instance.</p> <p> This function is definitely implemented here and can not be overrided. The processing of an ADQL query must always be the same in a TAP service ; it is completely done by   {@link AsyncThread}. </p>
 * @see uws.service.UWSFactory#createJobThread(uws.job.UWSJob)
 * @see AsyncThread
 */
@Override public final JobThread createJobThread(final UWSJob job) throws UWSException {
  try {
    return new AsyncThread((TAPJob)job,createADQLExecutor());
  }
 catch (  TAPException te) {
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,te,""String_Node_Str"");
  }
}","/** 
 * <p>Create the thread which will execute the task described by the given UWSJob instance.</p> <p> This function is definitely implemented here and can not be overridden. The processing of an ADQL query must always be the same in a TAP service ; it is completely done by   {@link AsyncThread}. </p>
 * @see uws.service.UWSFactory#createJobThread(uws.job.UWSJob)
 * @see AsyncThread
 */
@Override public final JobThread createJobThread(final UWSJob job) throws UWSException {
  try {
    return new AsyncThread((TAPJob)job,createADQLExecutor(),getErrorWriter());
  }
 catch (  TAPException te) {
    throw new UWSException(UWSException.INTERNAL_SERVER_ERROR,te,""String_Node_Str"");
  }
}",0.9838709677419356
25103,"@Override public void writeError(final String message,final ErrorType type,final int httpErrorCode,final HttpServletResponse response,final HttpServletRequest request,final String reqID,final JobOwner user,final String action) throws IOException {
  if (message == null || response == null)   return;
  response.reset();
  response.setStatus((httpErrorCode <= 0) ? 500 : httpErrorCode);
  response.setContentType(""String_Node_Str"");
  HashMap<String,String> addInfos=new HashMap<String,String>();
  if (reqID != null)   addInfos.put(""String_Node_Str"",reqID);
  if (type != null)   addInfos.put(""String_Node_Str"",type.toString());
  if (user != null)   addInfos.put(""String_Node_Str"",user.getID() + ((user.getPseudo() == null) ? ""String_Node_Str"" : ""String_Node_Str"" + user.getPseudo() + ""String_Node_Str""));
  if (action != null)   addInfos.put(""String_Node_Str"",action);
  formatter.writeError(message,addInfos,response.getWriter());
}","@Override public void writeError(Throwable t,ErrorSummary error,UWSJob job,OutputStream output) throws IOException {
  String message;
  if (error != null && error.getMessage() != null)   message=error.getMessage();
 else   if (t != null)   message=(t.getMessage() == null) ? t.getClass().getName() : t.getMessage();
 else   message=""String_Node_Str"";
  HashMap<String,String> addInfos=new HashMap<String,String>();
  if (job != null) {
    addInfos.put(""String_Node_Str"",job.getJobId());
    if (job.getOwner() != null)     addInfos.put(""String_Node_Str"",job.getOwner().getID() + ((job.getOwner().getPseudo() == null) ? ""String_Node_Str"" : ""String_Node_Str"" + job.getOwner().getPseudo() + ""String_Node_Str""));
  }
  if (error != null && error.getType() != null)   addInfos.put(""String_Node_Str"",error.getType().toString());
  addInfos.put(""String_Node_Str"",""String_Node_Str"");
  formatter.writeError(message,addInfos,new PrintWriter(output));
}",0.1435406698564593
25104,"/** 
 * Build a HOME resource of a TAP service whose the description is given in parameter. All the other TAP resources will be created and configured here thanks to the given   {@link ServiceConnection}. 
 * @param serviceConnection	Description of the TAP service.
 * @throws UWSException	If an error occurs while creating the /async resource.
 * @throws TAPException	If any other error occurs.
 */
public TAP(ServiceConnection serviceConnection) throws UWSException, TAPException {
  service=serviceConnection;
  resources=new HashMap<String,TAPResource>();
  errorWriter=new DefaultTAPErrorWriter(service);
  TAPResource res=new Availability(service);
  resources.put(res.getName(),res);
  res=new Capabilities(this);
  resources.put(res.getName(),res);
  res=new Sync(service,(Capabilities)res);
  resources.put(res.getName(),res);
  res=new ASync(service);
  resources.put(res.getName(),res);
  getUWS().setErrorWriter(errorWriter);
  TAPMetadata metadata=service.getTAPMetadata();
  if (metadata != null)   resources.put(metadata.getName(),metadata);
}","/** 
 * Build a HOME resource of a TAP service whose the description is given in parameter. All the other TAP resources will be created and configured here thanks to the given   {@link ServiceConnection}. 
 * @param serviceConnection	Description of the TAP service.
 * @throws UWSException	If an error occurs while creating the /async resource.
 * @throws TAPException	If any other error occurs.
 */
public TAP(ServiceConnection serviceConnection) throws UWSException, TAPException {
  service=serviceConnection;
  resources=new HashMap<String,TAPResource>();
  errorWriter=new DefaultTAPErrorWriter(service);
  TAPResource res=new Availability(service);
  resources.put(res.getName(),res);
  res=new Capabilities(this);
  resources.put(res.getName(),res);
  res=new Sync(service,(Capabilities)res);
  resources.put(res.getName(),res);
  res=new ASync(service);
  resources.put(res.getName(),res);
  TAPMetadata metadata=service.getTAPMetadata();
  if (metadata != null)   resources.put(metadata.getName(),metadata);
}",0.9807321772639692
25105,"@Override public boolean next() throws IOException {
  irow++;
  try {
    if (maxrec <= 0 || irow < maxrec) {
      boolean hasNext=tableIt.nextRow();
      if (hasNext) {
        for (int i=0; i < nbCol && tableIt.hasNextCol(); i++)         row[i]=tableIt.nextCol();
      }
 else       row=null;
      return hasNext;
    }
 else {
      overflow=tableIt.nextRow();
      row=null;
      return false;
    }
  }
 catch (  DataReadException dre) {
    if (dre.getCause() != null && dre.getCause() instanceof IOException)     throw (IOException)(dre.getCause());
 else     throw new IOException(dre);
  }
}","@Override public boolean next() throws IOException {
  irow++;
  try {
    if (maxrec < 0 || irow < maxrec) {
      boolean hasNext=tableIt.nextRow();
      if (hasNext) {
        for (int i=0; i < nbCol && tableIt.hasNextCol(); i++)         row[i]=tableIt.nextCol();
      }
 else       row=null;
      return hasNext;
    }
 else {
      overflow=tableIt.nextRow();
      row=null;
      return false;
    }
  }
 catch (  DataReadException dre) {
    if (dre.getCause() != null && dre.getCause() instanceof IOException)     throw (IOException)(dre.getCause());
 else     throw new IOException(dre);
  }
}",0.9991755976916736
25106,"@Override public RowSequence getRowSequence() throws IOException {
  overflow=false;
  row=new Object[nbCol];
  return new RowSequence(){
    long irow=-1;
    @Override public boolean next() throws IOException {
      irow++;
      try {
        if (maxrec <= 0 || irow < maxrec) {
          boolean hasNext=tableIt.nextRow();
          if (hasNext) {
            for (int i=0; i < nbCol && tableIt.hasNextCol(); i++)             row[i]=tableIt.nextCol();
          }
 else           row=null;
          return hasNext;
        }
 else {
          overflow=tableIt.nextRow();
          row=null;
          return false;
        }
      }
 catch (      DataReadException dre) {
        if (dre.getCause() != null && dre.getCause() instanceof IOException)         throw (IOException)(dre.getCause());
 else         throw new IOException(dre);
      }
    }
    @Override public Object[] getRow() throws IOException {
      return row;
    }
    @Override public Object getCell(    int cellIndex) throws IOException {
      return row[cellIndex];
    }
    @Override public void close() throws IOException {
    }
  }
;
}","@Override public RowSequence getRowSequence() throws IOException {
  overflow=false;
  row=new Object[nbCol];
  return new RowSequence(){
    long irow=-1;
    @Override public boolean next() throws IOException {
      irow++;
      try {
        if (maxrec < 0 || irow < maxrec) {
          boolean hasNext=tableIt.nextRow();
          if (hasNext) {
            for (int i=0; i < nbCol && tableIt.hasNextCol(); i++)             row[i]=tableIt.nextCol();
          }
 else           row=null;
          return hasNext;
        }
 else {
          overflow=tableIt.nextRow();
          row=null;
          return false;
        }
      }
 catch (      DataReadException dre) {
        if (dre.getCause() != null && dre.getCause() instanceof IOException)         throw (IOException)(dre.getCause());
 else         throw new IOException(dre);
      }
    }
    @Override public Object[] getRow() throws IOException {
      return row;
    }
    @Override public Object getCell(    int cellIndex) throws IOException {
      return row[cellIndex];
    }
    @Override public void close() throws IOException {
    }
  }
;
}",0.9995529727313366
25107,"/** 
 * Followed algorithm: <pre> Map&lt;DBTable,ADQLTable&gt; mapTables; For each ADQLTable t if (t.isSubQuery()) dbTable = generateDBTable(t.getSubQuery, t.getAlias()); else dbTable = resolveTable(t); t.setDBLink(dbTable); dbTables.put(t, dbTable); End For each SelectAllColumns c table = c.getAdqlTable(); if (table != null){ dbTable = resolveTable(table); if (dbTable == null) dbTable = query.getFrom().getTablesByAlias(table.getTableName(), table.isCaseSensitive(IdentifierField.TABLE)); if (dbTable == null) throw new UnresolvedTableException(table); table.setDBLink(dbTable); } End SearchColumnList list = query.getFrom().getDBColumns(); For each ADQLColumn c dbColumn = resolveColumn(c, list); c.setDBLink(dbColumn); c.setAdqlTable(mapTables.get(dbColumn.getTable())); End For each ColumnReference colRef checkColumnReference(colRef, query.getSelect(), list); End </pre>
 * @param query			The query to check.
 * @param fathersList	List of all columns available in the father query.
 * @throws UnresolvedIdentifiersException	An {@link UnresolvedIdentifiersException} if some tables or columns can not be resolved.
 * @since 1.2
 * @see #resolveTable(ADQLTable)
 * @see #generateDBTable(ADQLQuery,String)
 * @see #resolveColumn(ADQLColumn,SearchColumnList,Stack)
 * @see #checkColumnReference(ColumnReference,ClauseSelect,SearchColumnList)
 */
protected void check(final ADQLQuery query,Stack<SearchColumnList> fathersList) throws UnresolvedIdentifiersException {
  UnresolvedIdentifiersException errors=new UnresolvedIdentifiersException();
  HashMap<DBTable,ADQLTable> mapTables=new HashMap<DBTable,ADQLTable>();
  ISearchHandler sHandler;
  sHandler=new SearchTableHandler();
  sHandler.search(query.getFrom());
  for (  ADQLObject result : sHandler) {
    try {
      ADQLTable table=(ADQLTable)result;
      DBTable dbTable=null;
      if (table.isSubQuery()) {
        check(table.getSubQuery(),fathersList);
        dbTable=generateDBTable(table.getSubQuery(),table.getAlias());
      }
 else {
        dbTable=resolveTable(table);
        if (table.hasAlias())         dbTable=dbTable.copy(dbTable.getDBName(),table.getAlias());
      }
      table.setDBLink(dbTable);
      mapTables.put(dbTable,table);
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchWildCardHandler();
  sHandler.search(query.getSelect());
  for (  ADQLObject result : sHandler) {
    try {
      SelectAllColumns wildcard=(SelectAllColumns)result;
      ADQLTable table=wildcard.getAdqlTable();
      DBTable dbTable=null;
      if (table.getTableName() != null && table.getSchemaName() == null) {
        ArrayList<ADQLTable> tables=query.getFrom().getTablesByAlias(table.getTableName(),table.isCaseSensitive(IdentifierField.TABLE));
        if (tables.size() == 1)         dbTable=tables.get(0).getDBLink();
      }
      if (dbTable == null)       dbTable=resolveTable(table);
      wildcard.setAdqlTable(mapTables.get(dbTable));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  SearchColumnList list;
  try {
    list=query.getFrom().getDBColumns();
  }
 catch (  ParseException pe) {
    errors.addException(pe);
    list=new SearchColumnList();
  }
  sHandler=new SearchColumnHandler();
  sHandler.search(query);
  for (  ADQLObject result : sHandler) {
    try {
      ADQLColumn adqlColumn=(ADQLColumn)result;
      DBColumn dbColumn=resolveColumn(adqlColumn,list,fathersList);
      adqlColumn.setDBLink(dbColumn);
      adqlColumn.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchColReferenceHandler();
  sHandler.search(query);
  ClauseSelect select=query.getSelect();
  for (  ADQLObject result : sHandler) {
    try {
      ColumnReference colRef=(ColumnReference)result;
      DBColumn dbColumn=checkColumnReference(colRef,select,list);
      colRef.setDBLink(dbColumn);
      if (dbColumn != null)       colRef.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchSubQueryHandler();
  sHandler.search(query);
  if (sHandler.getNbMatch() > 0) {
    if (fathersList == null)     fathersList=new Stack<SearchColumnList>();
    fathersList.push(list);
    for (    ADQLObject result : sHandler) {
      try {
        check((ADQLQuery)result,fathersList);
      }
 catch (      UnresolvedIdentifiersException uie) {
        Iterator<ParseException> itPe=uie.getErrors();
        while (itPe.hasNext())         errors.addException(itPe.next());
      }
    }
    fathersList.pop();
  }
  if (errors.getNbErrors() > 0)   throw errors;
}","/** 
 * Followed algorithm: <pre> Map&lt;DBTable,ADQLTable&gt; mapTables; For each ADQLTable t if (t.isSubQuery()) dbTable = generateDBTable(t.getSubQuery, t.getAlias()); else dbTable = resolveTable(t); t.setDBLink(dbTable); dbTables.put(t, dbTable); End For each SelectAllColumns c table = c.getAdqlTable(); if (table != null){ dbTable = resolveTable(table); if (dbTable == null) dbTable = query.getFrom().getTablesByAlias(table.getTableName(), table.isCaseSensitive(IdentifierField.TABLE)); if (dbTable == null) throw new UnresolvedTableException(table); table.setDBLink(dbTable); } End SearchColumnList list = query.getFrom().getDBColumns(); For each ADQLColumn c dbColumn = resolveColumn(c, list); c.setDBLink(dbColumn); c.setAdqlTable(mapTables.get(dbColumn.getTable())); End For each ColumnReference colRef checkColumnReference(colRef, query.getSelect(), list); End </pre>
 * @param query			The query to check.
 * @param fathersList	List of all columns available in the father query.
 * @throws UnresolvedIdentifiersException	An {@link UnresolvedIdentifiersException} if some tables or columns can not be resolved.
 * @since 1.2
 * @see #resolveTable(ADQLTable)
 * @see #generateDBTable(ADQLQuery,String)
 * @see #resolveColumn(ADQLColumn,SearchColumnList,Stack)
 * @see #checkColumnReference(ColumnReference,ClauseSelect,SearchColumnList)
 */
protected void check(final ADQLQuery query,Stack<SearchColumnList> fathersList) throws UnresolvedIdentifiersException {
  UnresolvedIdentifiersException errors=new UnresolvedIdentifiersException();
  HashMap<DBTable,ADQLTable> mapTables=new HashMap<DBTable,ADQLTable>();
  ISearchHandler sHandler;
  sHandler=new SearchTableHandler();
  sHandler.search(query.getFrom());
  for (  ADQLObject result : sHandler) {
    try {
      ADQLTable table=(ADQLTable)result;
      DBTable dbTable=null;
      if (table.isSubQuery()) {
        check(table.getSubQuery(),fathersList);
        dbTable=generateDBTable(table.getSubQuery(),table.getAlias());
      }
 else {
        dbTable=resolveTable(table);
        if (table.hasAlias())         dbTable=dbTable.copy(null,table.getAlias());
      }
      table.setDBLink(dbTable);
      mapTables.put(dbTable,table);
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchWildCardHandler();
  sHandler.search(query.getSelect());
  for (  ADQLObject result : sHandler) {
    try {
      SelectAllColumns wildcard=(SelectAllColumns)result;
      ADQLTable table=wildcard.getAdqlTable();
      DBTable dbTable=null;
      if (table.getTableName() != null && table.getSchemaName() == null) {
        ArrayList<ADQLTable> tables=query.getFrom().getTablesByAlias(table.getTableName(),table.isCaseSensitive(IdentifierField.TABLE));
        if (tables.size() == 1)         dbTable=tables.get(0).getDBLink();
      }
      if (dbTable == null)       dbTable=resolveTable(table);
      wildcard.setAdqlTable(mapTables.get(dbTable));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  SearchColumnList list;
  try {
    list=query.getFrom().getDBColumns();
  }
 catch (  ParseException pe) {
    errors.addException(pe);
    list=new SearchColumnList();
  }
  sHandler=new SearchColumnHandler();
  sHandler.search(query);
  for (  ADQLObject result : sHandler) {
    try {
      ADQLColumn adqlColumn=(ADQLColumn)result;
      DBColumn dbColumn=resolveColumn(adqlColumn,list,fathersList);
      adqlColumn.setDBLink(dbColumn);
      adqlColumn.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchColReferenceHandler();
  sHandler.search(query);
  ClauseSelect select=query.getSelect();
  for (  ADQLObject result : sHandler) {
    try {
      ColumnReference colRef=(ColumnReference)result;
      DBColumn dbColumn=checkColumnReference(colRef,select,list);
      colRef.setDBLink(dbColumn);
      if (dbColumn != null)       colRef.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchSubQueryHandler();
  sHandler.search(query);
  if (sHandler.getNbMatch() > 0) {
    if (fathersList == null)     fathersList=new Stack<SearchColumnList>();
    fathersList.push(list);
    for (    ADQLObject result : sHandler) {
      try {
        check((ADQLQuery)result,fathersList);
      }
 catch (      UnresolvedIdentifiersException uie) {
        Iterator<ParseException> itPe=uie.getErrors();
        while (itPe.hasNext())         errors.addException(itPe.next());
      }
    }
    fathersList.pop();
  }
  if (errors.getNbErrors() > 0)   throw errors;
}",0.9975570897503984
25108,"/** 
 * Makes a copy of this instance of   {@link DBTable}, with the possibility to change the DB and ADQL names.
 * @param dbName	Its new DB name.
 * @param adqlName	Its new ADQL name.
 * @return			A modified copy of this {@link DBTable}.
 */
public DBTable copy(final String dbName,final String adqlName);","/** 
 * <p>Makes a copy of this instance of   {@link DBTable}, with the possibility to change the DB and ADQL names.</p> <p><b>IMPORTANT:</b> <b>The given DB and ADQL name may be NULL.</b> If NULL, the copy will contain exactly the same full name (DB and/or ADQL).<br/> <b>And they may be qualified</b> (that's to say: prefixed by the schema name or by the catalog and schema name). It means that it is possible to change the catalog, schema and table name in the copy.<br/> For instance: </p> <ul> <li><i>.copy(null, ""foo"") =></i> a copy with the same full DB name, but with no ADQL catalog and schema name and with an ADQL table name equals to ""foo""</li> <li><i>.copy(""schema.table"", ) =></i> a copy with the same full ADQL name, but with no DB catalog name, with a DB schema name equals to ""schema"" and with a DB table name equals to ""table""</li> </ul>
 * @param dbName	Its new DB name.It may be qualified. It may also be NULL ; if so, the full DB name won't be different in the copy.
 * @param adqlName	Its new ADQL name.It may be qualified. It may also be NULL ; if so, the full DB name won't be different in the copy.
 * @return			A modified copy of this {@link DBTable}.
 */
public DBTable copy(final String dbName,final String adqlName);",0.3956185567010309
25109,"@Override public DBTable copy(final String dbName,final String adqlName){
  DefaultDBTable copy=new DefaultDBTable(dbName,adqlName);
  for (  DBColumn col : this) {
    if (col instanceof DBCommonColumn)     copy.addColumn(new DBCommonColumn((DBCommonColumn)col,col.getDBName(),col.getADQLName()));
 else     copy.addColumn(col.copy(col.getDBName(),col.getADQLName(),copy));
  }
  return copy;
}","@Override public DBTable copy(String dbName,String adqlName){
  dbName=(dbName == null) ? joinTableName(new String[]{dbCatalogName,dbSchemaName,this.dbName}) : dbName;
  adqlName=(adqlName == null) ? joinTableName(new String[]{adqlCatalogName,adqlSchemaName,this.adqlName}) : adqlName;
  DefaultDBTable copy=new DefaultDBTable(dbName,adqlName);
  for (  DBColumn col : this) {
    if (col instanceof DBCommonColumn)     copy.addColumn(new DBCommonColumn((DBCommonColumn)col,col.getDBName(),col.getADQLName()));
 else     copy.addColumn(col.copy(col.getDBName(),col.getADQLName(),copy));
  }
  return copy;
}",0.7644710578842315
25110,"/** 
 * <p>Write the given error message as VOTable document.</p> <p><i>Note: In the TAP protocol, all errors must be returned as VOTable. The class   {@link DefaultTAPErrorWriter} is in charge of the managementand reporting of all errors. It is calling this function while the error message to display to the user is ready and must be written in the HTTP response. </i></p> <p>Here is the XML format of this VOTable error:</p> <pre> &lt;VOTABLE version=""..."" xmlns=""..."" &gt; &lt;RESOURCE type=""results""&gt; &lt;INFO name=""QUERY_STATUS"" value=""ERROR&gt; ... &lt;/INFO&gt; &lt;INFO name=""PROVIDER"" value=""...""&gt;...&lt;/INFO&gt; &lt;!-- other optional INFOs (e.g. request parameters) --&gt; &lt;/RESOURCE&gt; &lt;/VOTABLE&gt; </pre>
 * @param message	Error message to display to the user.
 * @param otherInfo	List of other additional information to display. <i>optional</i>
 * @param out		Stream in which the VOTable error must be written.
 * @throws IOException	If any error occurs while writing in the given output.
 * @since 2.0
 */
public void writeError(final String message,final Map<String,String> otherInfo,final PrintWriter writer) throws IOException {
  BufferedWriter out=new BufferedWriter(writer);
  out.write(""String_Node_Str"" + VOSerializer.formatAttribute(""String_Node_Str"",votVersion.getVersionNumber()) + VOSerializer.formatAttribute(""String_Node_Str"",votVersion.getXmlNamespace())+ ""String_Node_Str"");
  out.newLine();
  out.write(""String_Node_Str"");
  out.newLine();
  out.write(""String_Node_Str"" + VOSerializer.formatText(message) + ""String_Node_Str"");
  out.newLine();
  if (service.getProviderName() != null) {
    out.write(""String_Node_Str"" + VOSerializer.formatAttribute(""String_Node_Str"",service.getProviderName()) + ""String_Node_Str""+ ((service.getProviderDescription() == null) ? ""String_Node_Str"" : VOSerializer.formatText(service.getProviderDescription()))+ ""String_Node_Str"");
    out.newLine();
  }
  if (otherInfo != null) {
    Iterator<Map.Entry<String,String>> it=otherInfo.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<String,String> entry=it.next();
      out.write(""String_Node_Str"" + VOSerializer.formatAttribute(""String_Node_Str"",entry.getKey()) + ""String_Node_Str""+ VOSerializer.formatText(entry.getValue())+ ""String_Node_Str"");
      out.newLine();
    }
  }
  out.flush();
  out.write(""String_Node_Str"");
  out.newLine();
  out.write(""String_Node_Str"");
  out.newLine();
  out.flush();
}","/** 
 * <p>Write the given error message as VOTable document.</p> <p><i>Note: In the TAP protocol, all errors must be returned as VOTable. The class   {@link DefaultTAPErrorWriter} is in charge of the managementand reporting of all errors. It is calling this function while the error message to display to the user is ready and must be written in the HTTP response. </i></p> <p>Here is the XML format of this VOTable error:</p> <pre> &lt;VOTABLE version=""..."" xmlns=""..."" &gt; &lt;RESOURCE type=""results""&gt; &lt;INFO name=""QUERY_STATUS"" value=""ERROR&gt; ... &lt;/INFO&gt; &lt;INFO name=""PROVIDER"" value=""...""&gt;...&lt;/INFO&gt; &lt;!-- other optional INFOs (e.g. request parameters) --&gt; &lt;/RESOURCE&gt; &lt;/VOTABLE&gt; </pre>
 * @param message	Error message to display to the user.
 * @param otherInfo	List of other additional information to display. <i>optional</i>
 * @param out		Stream in which the VOTable error must be written.
 * @throws IOException	If any error occurs while writing in the given output.
 * @since 2.0
 */
public void writeError(final String message,final Map<String,String> otherInfo,final PrintWriter writer) throws IOException {
  BufferedWriter out=new BufferedWriter(writer);
  out.write(""String_Node_Str"" + VOSerializer.formatAttribute(""String_Node_Str"",votVersion.getVersionNumber()) + VOSerializer.formatAttribute(""String_Node_Str"",votVersion.getXmlNamespace())+ ""String_Node_Str"");
  out.newLine();
  out.write(""String_Node_Str"");
  out.newLine();
  out.write(""String_Node_Str"" + (message == null ? ""String_Node_Str"" : VOSerializer.formatText(message)) + ""String_Node_Str"");
  out.newLine();
  if (service.getProviderName() != null) {
    out.write(""String_Node_Str"" + VOSerializer.formatAttribute(""String_Node_Str"",service.getProviderName()) + ""String_Node_Str""+ ((service.getProviderDescription() == null) ? ""String_Node_Str"" : VOSerializer.formatText(service.getProviderDescription()))+ ""String_Node_Str"");
    out.newLine();
  }
  if (otherInfo != null) {
    Iterator<Map.Entry<String,String>> it=otherInfo.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<String,String> entry=it.next();
      out.write(""String_Node_Str"" + VOSerializer.formatAttribute(""String_Node_Str"",entry.getKey()) + ""String_Node_Str""+ VOSerializer.formatText(entry.getValue())+ ""String_Node_Str"");
      out.newLine();
    }
  }
  out.flush();
  out.write(""String_Node_Str"");
  out.newLine();
  out.write(""String_Node_Str"");
  out.newLine();
  out.flush();
}",0.9919126566922766
25111,"@Override public boolean executeResource(final HttpServletRequest request,final HttpServletResponse response) throws IOException, TAPException {
  if (!request.getMethod().equalsIgnoreCase(""String_Node_Str""))   throw new TAPException(""String_Node_Str"",HttpServletResponse.SC_METHOD_NOT_ALLOWED);
  response.setContentType(""String_Node_Str"");
  PrintWriter pw=response.getWriter();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(service.isAvailable());
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(VOSerializer.formatText(service.getAvailability()));
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.flush();
  return true;
}","@Override public boolean executeResource(final HttpServletRequest request,final HttpServletResponse response) throws IOException, TAPException {
  if (!request.getMethod().equalsIgnoreCase(""String_Node_Str""))   throw new TAPException(""String_Node_Str"",HttpServletResponse.SC_METHOD_NOT_ALLOWED);
  response.setContentType(""String_Node_Str"");
  PrintWriter pw=response.getWriter();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(service.isAvailable());
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  if (service.getAvailability() != null)   pw.print(VOSerializer.formatText(service.getAvailability()));
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.flush();
  return true;
}",0.972937293729373
25112,"@Override public String getCapability(){
  StringBuffer xml=new StringBuffer();
  xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",getStandardID())).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(VOSerializer.formatText(getAccessURL())).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  Iterator<OutputFormat> itFormats=service.getOutputFormats();
  OutputFormat formatter;
  while (itFormats.hasNext()) {
    formatter=itFormats.next();
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(VOSerializer.formatText(formatter.getMimeType())).append(""String_Node_Str"");
    if (formatter.getShortMimeType() != null)     xml.append(""String_Node_Str"").append(VOSerializer.formatText(formatter.getShortMimeType())).append(""String_Node_Str"");
    if (formatter.getDescription() != null)     xml.append(""String_Node_Str"").append(VOSerializer.formatText(formatter.getDescription())).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  int[] retentionPeriod=service.getRetentionPeriod();
  if (retentionPeriod != null && retentionPeriod.length >= 2) {
    if (retentionPeriod[0] > -1 || retentionPeriod[1] > -1) {
      xml.append(""String_Node_Str"");
      if (retentionPeriod[0] > -1)       xml.append(""String_Node_Str"").append(retentionPeriod[0]).append(""String_Node_Str"");
      if (retentionPeriod[1] > -1)       xml.append(""String_Node_Str"").append(retentionPeriod[1]).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
  }
  int[] executionDuration=service.getExecutionDuration();
  if (executionDuration != null && executionDuration.length >= 2) {
    if (executionDuration[0] > -1 || executionDuration[1] > -1) {
      xml.append(""String_Node_Str"");
      if (executionDuration[0] > -1)       xml.append(""String_Node_Str"").append(executionDuration[0]).append(""String_Node_Str"");
      if (executionDuration[1] > -1)       xml.append(""String_Node_Str"").append(executionDuration[1]).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
  }
  int[] outputLimit=service.getOutputLimit();
  LimitUnit[] outputLimitType=service.getOutputLimitType();
  if (outputLimit != null && outputLimit.length >= 2 && outputLimitType != null && outputLimitType.length >= 2) {
    if (outputLimit[0] > -1 || outputLimit[1] > -1) {
      xml.append(""String_Node_Str"");
      if (outputLimit[0] > -1)       xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",outputLimitType[0].toString())).append(""String_Node_Str"").append(outputLimit[0]).append(""String_Node_Str"");
      if (outputLimit[1] > -1)       xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",outputLimitType[1].toString())).append(""String_Node_Str"").append(outputLimit[1]).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
  }
  if (service.uploadEnabled()) {
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    int[] uploadLimit=service.getUploadLimit();
    LimitUnit[] uploadLimitType=service.getUploadLimitType();
    if (uploadLimit != null && uploadLimit.length >= 2 && uploadLimitType != null && uploadLimitType.length >= 2) {
      if (uploadLimit[0] > -1 || uploadLimit[1] > -1) {
        xml.append(""String_Node_Str"");
        if (uploadLimit[0] > -1)         xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",uploadLimitType[0].toString())).append(""String_Node_Str"").append(uploadLimit[0]).append(""String_Node_Str"");
        if (uploadLimit[1] > -1)         xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",uploadLimitType[1].toString())).append(""String_Node_Str"").append(uploadLimit[1]).append(""String_Node_Str"");
        xml.append(""String_Node_Str"");
      }
    }
  }
  xml.append(""String_Node_Str"");
  return xml.toString();
}","@Override public String getCapability(){
  StringBuffer xml=new StringBuffer();
  xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",getStandardID())).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append((getAccessURL() == null) ? ""String_Node_Str"" : VOSerializer.formatText(getAccessURL())).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  Iterator<OutputFormat> itFormats=service.getOutputFormats();
  OutputFormat formatter;
  while (itFormats.hasNext()) {
    formatter=itFormats.next();
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(VOSerializer.formatText(formatter.getMimeType())).append(""String_Node_Str"");
    if (formatter.getShortMimeType() != null)     xml.append(""String_Node_Str"").append(VOSerializer.formatText(formatter.getShortMimeType())).append(""String_Node_Str"");
    if (formatter.getDescription() != null)     xml.append(""String_Node_Str"").append(VOSerializer.formatText(formatter.getDescription())).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  int[] retentionPeriod=service.getRetentionPeriod();
  if (retentionPeriod != null && retentionPeriod.length >= 2) {
    if (retentionPeriod[0] > -1 || retentionPeriod[1] > -1) {
      xml.append(""String_Node_Str"");
      if (retentionPeriod[0] > -1)       xml.append(""String_Node_Str"").append(retentionPeriod[0]).append(""String_Node_Str"");
      if (retentionPeriod[1] > -1)       xml.append(""String_Node_Str"").append(retentionPeriod[1]).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
  }
  int[] executionDuration=service.getExecutionDuration();
  if (executionDuration != null && executionDuration.length >= 2) {
    if (executionDuration[0] > -1 || executionDuration[1] > -1) {
      xml.append(""String_Node_Str"");
      if (executionDuration[0] > -1)       xml.append(""String_Node_Str"").append(executionDuration[0]).append(""String_Node_Str"");
      if (executionDuration[1] > -1)       xml.append(""String_Node_Str"").append(executionDuration[1]).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
  }
  int[] outputLimit=service.getOutputLimit();
  LimitUnit[] outputLimitType=service.getOutputLimitType();
  if (outputLimit != null && outputLimit.length >= 2 && outputLimitType != null && outputLimitType.length >= 2) {
    if (outputLimit[0] > -1 || outputLimit[1] > -1) {
      xml.append(""String_Node_Str"");
      if (outputLimit[0] > -1)       xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",outputLimitType[0].toString())).append(""String_Node_Str"").append(outputLimit[0]).append(""String_Node_Str"");
      if (outputLimit[1] > -1)       xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",outputLimitType[1].toString())).append(""String_Node_Str"").append(outputLimit[1]).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
  }
  if (service.uploadEnabled()) {
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    int[] uploadLimit=service.getUploadLimit();
    LimitUnit[] uploadLimitType=service.getUploadLimitType();
    if (uploadLimit != null && uploadLimit.length >= 2 && uploadLimitType != null && uploadLimitType.length >= 2) {
      if (uploadLimit[0] > -1 || uploadLimit[1] > -1) {
        xml.append(""String_Node_Str"");
        if (uploadLimit[0] > -1)         xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",uploadLimitType[0].toString())).append(""String_Node_Str"").append(uploadLimit[0]).append(""String_Node_Str"");
        if (uploadLimit[1] > -1)         xml.append(""String_Node_Str"").append(VOSerializer.formatAttribute(""String_Node_Str"",uploadLimitType[1].toString())).append(""String_Node_Str"").append(uploadLimit[1]).append(""String_Node_Str"");
        xml.append(""String_Node_Str"");
      }
    }
  }
  xml.append(""String_Node_Str"");
  return xml.toString();
}",0.9890883491728264
25113,"/** 
 * <p>Execute the given request in the TAP service by forwarding it to the appropriate resource.</p> <h3>Home page</h3> <p> If the appropriate resource is the home page, the request is not propagated and this class/resource displays directly the home page in the given response by calling   {@link #writeHomePage(HttpServletResponse,JobOwner)}. The default implementation of this function takes 2 cases into account: </p> <ol> <li><b>A custom home page has been specified</b> using   {@link #setHomePageURI(String)}. In this case, the content of the URL or file path will be directly copied into the HTTP response. The content type of the response must be specified by  {@link #setHomePageMimeType(String)} ; by default, it is ""text/html"".</li><li><b>Default home page.</b> When no custom home page has been specified, a default content is displayed. It is an HTML document which merely lists all resources available in this TAP service.</li> </ol> <h3>Error/Exception management</h3> <p> Only this resource (the root) should write any errors in the response. For that, it catches any  {@link Throwable} andwrite an appropriate message in the HTTP response. The format and the content of this message is designed by the  {@link ServiceErrorWriter}set in this class. By changing it, it is then possible to change, for instance, the format of the error responses. </p> <h3>Request ID &amp; Log</h3> <p> Each request is identified by a unique identifier (see   {@link #generateRequestID(HttpServletRequest)}). This ID is used only for logging purpose. Request and jobs/threads can then be associated more easily in the logs. Besides, every requests and their response are logged as INFO with this ID. </p>
 * @param request	Request of the user to execute in this TAP service.
 * @param response	Object in which the result of the request must be written.
 * @throws ServletException	If any grave/fatal error occurs.
 * @throws IOException		If any error occurs while reading or writing from or into a stream (and particularly the given request or response).
 */
public void executeRequest(final HttpServletRequest request,final HttpServletResponse response) throws ServletException, IOException {
  if (request == null || response == null)   return;
  final String reqID=generateRequestID(request);
  String[] resourcePath=(request.getPathInfo() == null) ? null : request.getPathInfo().split(""String_Node_Str"");
  final String resourceName=(resourcePath == null || resourcePath.length < 1) ? ""String_Node_Str"" : resourcePath[1].trim().toLowerCase();
  if (!resourceName.equalsIgnoreCase(ASync.RESOURCE_NAME))   getLogger().logHttp(LogLevel.INFO,request,reqID,null,null);
  if (tapBaseURL == null) {
    setTAPBaseURL(request);
    getLogger().logUWS(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"",null);
  }
  JobOwner owner=null;
  try {
    try {
      if (service.getUserIdentifier() != null)       owner=service.getUserIdentifier().extractUserId(new UWSUrl(request),request);
    }
 catch (    UWSException ue) {
      throw new TAPException(ue);
    }
    if (resourceName.equals(""String_Node_Str""))     writeHomePage(response,owner);
 else {
      TAPResource res=resources.get(resourceName);
      if (res != null)       res.executeResource(request,response);
 else       throw new TAPException(""String_Node_Str"" + resourceName + ""String_Node_Str"",UWSException.NOT_IMPLEMENTED);
    }
    response.flushBuffer();
    if (!resourceName.equalsIgnoreCase(ASync.RESOURCE_NAME))     getLogger().logHttp(LogLevel.INFO,response,reqID,owner,""String_Node_Str"" + UWSException.OK + ""String_Node_Str""+ resourceName+ ""String_Node_Str"",null);
  }
 catch (  Throwable t) {
    errorWriter.writeError(t,response,request,reqID,owner,resourceName);
    getLogger().logHttp(LogLevel.ERROR,response,reqID,owner,""String_Node_Str"" + response.getStatus() + ""String_Node_Str""+ resourceName+ ""String_Node_Str""+ t.getMessage(),t);
  }
 finally {
    if (resourceName.equalsIgnoreCase(Sync.RESOURCE_NAME) && service.getFactory().countFreeConnections() >= 1)     getASync().freeConnectionAvailable();
  }
}","/** 
 * <p>Execute the given request in the TAP service by forwarding it to the appropriate resource.</p> <h3>Home page</h3> <p> If the appropriate resource is the home page, the request is not propagated and this class/resource displays directly the home page in the given response by calling   {@link #writeHomePage(HttpServletResponse,JobOwner)}. The default implementation of this function takes 2 cases into account: </p> <ol> <li><b>A custom home page has been specified</b> using   {@link #setHomePageURI(String)}. In this case, the content of the URL or file path will be directly copied into the HTTP response. The content type of the response must be specified by  {@link #setHomePageMimeType(String)} ; by default, it is ""text/html"".</li><li><b>Default home page.</b> When no custom home page has been specified, a default content is displayed. It is an HTML document which merely lists all resources available in this TAP service.</li> </ol> <h3>Error/Exception management</h3> <p> Only this resource (the root) should write any errors in the response. For that, it catches any  {@link Throwable} andwrite an appropriate message in the HTTP response. The format and the content of this message is designed by the  {@link ServiceErrorWriter}set in this class. By changing it, it is then possible to change, for instance, the format of the error responses. </p> <h3>Request ID &amp; Log</h3> <p> Each request is identified by a unique identifier (see   {@link #generateRequestID(HttpServletRequest)}). This ID is used only for logging purpose. Request and jobs/threads can then be associated more easily in the logs. Besides, every requests and their response are logged as INFO with this ID. </p>
 * @param request	Request of the user to execute in this TAP service.
 * @param response	Object in which the result of the request must be written.
 * @throws ServletException	If any grave/fatal error occurs.
 * @throws IOException		If any error occurs while reading or writing from or into a stream (and particularly the given request or response).
 */
public void executeRequest(final HttpServletRequest request,final HttpServletResponse response) throws ServletException, IOException {
  if (request == null || response == null)   return;
  final String reqID=generateRequestID(request);
  String[] resourcePath=(request.getPathInfo() == null) ? null : request.getPathInfo().split(""String_Node_Str"");
  final String resourceName=(resourcePath == null || resourcePath.length < 1) ? ""String_Node_Str"" : resourcePath[1].trim().toLowerCase();
  if (!resourceName.equalsIgnoreCase(ASync.RESOURCE_NAME))   getLogger().logHttp(LogLevel.INFO,request,reqID,null,null);
  if (tapBaseURL == null) {
    setTAPBaseURL(request);
    getLogger().logUWS(LogLevel.INFO,this,""String_Node_Str"",""String_Node_Str"",null);
  }
  JobOwner owner=null;
  try {
    try {
      if (service.getUserIdentifier() != null)       owner=service.getUserIdentifier().extractUserId(new UWSUrl(request),request);
    }
 catch (    UWSException ue) {
      throw new TAPException(ue);
    }
    if (resourceName.equals(""String_Node_Str""))     writeHomePage(response,owner);
 else {
      TAPResource res=resources.get(resourceName);
      if (res != null)       res.executeResource(request,response);
 else       throw new TAPException(""String_Node_Str"" + resourceName + ""String_Node_Str"",UWSException.NOT_IMPLEMENTED);
    }
    response.flushBuffer();
    if (!resourceName.equalsIgnoreCase(ASync.RESOURCE_NAME))     getLogger().logHttp(LogLevel.INFO,response,reqID,owner,""String_Node_Str"" + UWSException.OK + ""String_Node_Str""+ resourceName+ ""String_Node_Str"",null);
  }
 catch (  Throwable t) {
    errorWriter.writeError(t,response,request,reqID,owner,resourceName);
    getLogger().logHttp(LogLevel.ERROR,response,reqID,owner,""String_Node_Str"" + response.getStatus() + ""String_Node_Str""+ resourceName+ ""String_Node_Str"",t);
  }
 finally {
    if (resourceName.equalsIgnoreCase(Sync.RESOURCE_NAME) && service.getFactory().countFreeConnections() >= 1)     getASync().freeConnectionAvailable();
  }
}",0.9980416156670746
25114,"/** 
 * @param datatype		A datatype (ex: char, int, long, ...). <b>Null value forbidden</b>
 * @param arraysize		A non-null positive integer. (any value &le; 0 will be considered as an undetermined arraysize).
 * @param xtype			A special type (ex: adql:POINT, adql:TIMESTAMP, ...). Null value allowed.
 */
public VotType(final String datatype,final int arraysize,final String xtype){
  if (datatype == null)   throw new NullPointerException(""String_Node_Str"");
  this.datatype=datatype;
  this.arraysize=arraysize;
  this.xtype=xtype;
}","/** 
 * @param datatype		A datatype (ex: char, int, long, ...). <b>Null value forbidden</b>
 * @param arraysize		A non-null positive integer. (any value &le; 0 will be considered as an undetermined arraysize).
 * @param xtype			A special type (ex: adql:POINT, adql:TIMESTAMP, ...). Null value allowed.
 */
public VotType(final String datatype,final int arraysize,final String xtype){
  if (datatype == null)   throw new NullPointerException(""String_Node_Str"");
  this.datatype=datatype;
  this.arraysize=arraysize;
  this.xtype=(xtype != null && xtype.trim().length() <= 0) ? null : xtype;
}",0.9511978704525288
25115,"protected final String getFullDBName(final TAPTable table){
  return (table.getSchema() != null) ? (table.getSchema().getDBName() + ""String_Node_Str"") : ""String_Node_Str"";
}","protected final String getFullDBName(final TAPTable table){
  return ((table.getSchema() != null) ? (table.getSchema().getDBName() + ""String_Node_Str"") : ""String_Node_Str"") + table.getDBName();
}",0.9402173913043478
25116,"@Override public void connectionClosed(DBConnection connection){
}","@Override public void connectionClosed(DBConnection connection){
  dbActivity(""String_Node_Str"");
}",0.8
25117,public void connectionOpened(final DBConnection connection);,"public void connectionOpened(final DBConnection connection,final String dbName);",0.8571428571428571
25118,"@Override public final Object getDefault(){
  if (service.getOutputLimit() != null && service.getOutputLimit().length >= 2 && service.getOutputLimitType() != null && service.getOutputLimitType().length == service.getOutputLimit().length) {
    if (service.getOutputLimit()[0] > 0 && service.getOutputLimitType()[0] == LimitUnit.rows)     return service.getOutputLimit()[0];
  }
  return getMaxOutputLimit();
}","@Override public final Object getDefault(){
  if (service.getOutputLimit() != null && service.getOutputLimit().length >= 2 && service.getOutputLimitType() != null && service.getOutputLimitType().length == service.getOutputLimit().length) {
    if (service.getOutputLimit()[0] > 0 && service.getOutputLimitType()[0] == LimitUnit.rows)     return service.getOutputLimit()[0];
  }
  return TAPJob.UNLIMITED_MAX_REC;
}",0.9501822600243012
25119,"@Override public Object check(Object value) throws UWSException {
  if (value == null)   return getDefault();
  int maxOutputLimit=getMaxOutputLimit();
  Integer defaultOutputLimit=(Integer)getDefault(), maxRec=null;
  if (value instanceof Integer)   maxRec=(Integer)value;
 else   if (value instanceof String) {
    String strValue=(String)value;
    try {
      maxRec=Integer.parseInt(strValue);
    }
 catch (    NumberFormatException nfe) {
      throw UWSExceptionFactory.badFormat(null,TAPJob.PARAM_MAX_REC,strValue,null,""String_Node_Str"" + TAPJob.UNLIMITED_MAX_REC + ""String_Node_Str""+ maxOutputLimit+ ""String_Node_Str""+ defaultOutputLimit+ ""String_Node_Str"");
    }
  }
 else   throw UWSExceptionFactory.badFormat(null,TAPJob.PARAM_MAX_REC,null,value.getClass().getName(),""String_Node_Str"" + TAPJob.UNLIMITED_MAX_REC + ""String_Node_Str""+ maxOutputLimit+ ""String_Node_Str""+ defaultOutputLimit+ ""String_Node_Str"");
  if (maxRec < TAPJob.UNLIMITED_MAX_REC)   maxRec=TAPJob.UNLIMITED_MAX_REC;
  if (maxOutputLimit > TAPJob.UNLIMITED_MAX_REC && maxRec > maxOutputLimit)   throw new UWSException(UWSException.BAD_REQUEST,""String_Node_Str"" + maxOutputLimit + ""String_Node_Str"");
  return maxRec;
}","@Override public Object check(Object value) throws UWSException {
  if (value == null)   return null;
  int maxOutputLimit=getMaxOutputLimit();
  Integer defaultOutputLimit=(Integer)getDefault(), maxRec=null;
  if (value instanceof Integer)   maxRec=(Integer)value;
 else   if (value instanceof String) {
    String strValue=(String)value;
    try {
      maxRec=Integer.parseInt(strValue);
    }
 catch (    NumberFormatException nfe) {
      throw UWSExceptionFactory.badFormat(null,TAPJob.PARAM_MAX_REC,strValue,null,""String_Node_Str"" + TAPJob.UNLIMITED_MAX_REC + ""String_Node_Str""+ maxOutputLimit+ ""String_Node_Str""+ defaultOutputLimit+ ""String_Node_Str"");
    }
  }
 else   throw UWSExceptionFactory.badFormat(null,TAPJob.PARAM_MAX_REC,null,value.getClass().getName(),""String_Node_Str"" + TAPJob.UNLIMITED_MAX_REC + ""String_Node_Str""+ maxOutputLimit+ ""String_Node_Str""+ defaultOutputLimit+ ""String_Node_Str"");
  if (maxRec < TAPJob.UNLIMITED_MAX_REC)   maxRec=TAPJob.UNLIMITED_MAX_REC;
  if (maxRec == TAPJob.UNLIMITED_MAX_REC || maxRec > maxOutputLimit)   maxRec=maxOutputLimit;
  return maxRec;
}",0.9413298565840938
25120,"/** 
 * Checks whether the given column reference corresponds to a selected item (column or an expression with an alias) or to an existing column.
 * @param colRef			The column reference which must be checked.
 * @param select			The SELECT clause of the ADQL query.
 * @param dbColumns			The list of all available {@link DBColumn}s.
 * @return 					The corresponding {@link DBColumn} if this reference is actually the name of a column, <i>null</i> otherwise.
 * @throws ParseException	An {@link UnresolvedColumnException} if the given column can't be resolvedor an  {@link UnresolvedTableException} if its table reference can't be resolved.
 * @see ClauseSelect#searchByAlias(String)
 * @see #resolveColumn(ADQLColumn,SearchColumnList)
 */
protected DBColumn checkColumnReference(final ColumnReference colRef,final ClauseSelect select,final SearchColumnList dbColumns) throws ParseException {
  if (colRef.isIndex()) {
    int index=colRef.getColumnIndex();
    if (index > 0 && index <= select.size()) {
      SelectItem item=select.get(index - 1);
      if (item.getOperand() instanceof ADQLColumn)       return ((ADQLColumn)item.getOperand()).getDBLink();
 else       return null;
    }
 else     throw new ParseException(""String_Node_Str"" + index + ""String_Node_Str""+ select.size()+ ""String_Node_Str"");
  }
 else {
    ADQLColumn col=new ADQLColumn(colRef.getColumnName());
    col.setCaseSensitive(colRef.isCaseSensitive());
    if (col.getTableName() == null) {
      ArrayList<SelectItem> founds=select.searchByAlias(colRef.getColumnName(),colRef.isCaseSensitive());
      if (founds.size() == 1)       return null;
 else       if (founds.size() > 1)       throw new UnresolvedColumnException(col,founds.get(0).getAlias(),founds.get(1).getAlias());
    }
    return resolveColumn(col,dbColumns);
  }
}","/** 
 * Checks whether the given column reference corresponds to a selected item (column or an expression with an alias) or to an existing column.
 * @param colRef			The column reference which must be checked.
 * @param select			The SELECT clause of the ADQL query.
 * @param dbColumns			The list of all available {@link DBColumn}s.
 * @return 					The corresponding {@link DBColumn} if this reference is actually the name of a column, <i>null</i> otherwise.
 * @throws ParseException	An {@link UnresolvedColumnException} if the given column can't be resolvedor an  {@link UnresolvedTableException} if its table reference can't be resolved.
 * @see ClauseSelect#searchByAlias(String)
 * @see #resolveColumn(ADQLColumn,SearchColumnList,SearchColumnList)
 */
protected DBColumn checkColumnReference(final ColumnReference colRef,final ClauseSelect select,final SearchColumnList dbColumns) throws ParseException {
  if (colRef.isIndex()) {
    int index=colRef.getColumnIndex();
    if (index > 0 && index <= select.size()) {
      SelectItem item=select.get(index - 1);
      if (item.getOperand() instanceof ADQLColumn)       return ((ADQLColumn)item.getOperand()).getDBLink();
 else       return null;
    }
 else     throw new ParseException(""String_Node_Str"" + index + ""String_Node_Str""+ select.size()+ ""String_Node_Str"");
  }
 else {
    ADQLColumn col=new ADQLColumn(colRef.getColumnName());
    col.setCaseSensitive(colRef.isCaseSensitive());
    if (col.getTableName() == null) {
      ArrayList<SelectItem> founds=select.searchByAlias(colRef.getColumnName(),colRef.isCaseSensitive());
      if (founds.size() == 1)       return null;
 else       if (founds.size() > 1)       throw new UnresolvedColumnException(col,founds.get(0).getAlias(),founds.get(1).getAlias());
    }
    return resolveColumn(col,dbColumns,null);
  }
}",0.993952721275426
25121,"/** 
 * Resolves the given column, that's to say searches for the corresponding   {@link DBColumn}.
 * @param column		The column to resolve.
 * @param dbColumns		List of all available {@link DBColumn}s.
 * @return				The corresponding {@link DBColumn} if found, <i>null</i> otherwise.
 * @throws ParseException	An {@link UnresolvedColumnException} if the given column can't be resolvedor an  {@link UnresolvedTableException} if its table reference can't be resolved.
 */
protected DBColumn resolveColumn(final ADQLColumn column,final SearchColumnList dbColumns) throws ParseException {
  ArrayList<DBColumn> foundColumns=dbColumns.search(column);
  if (foundColumns.size() == 1)   return foundColumns.get(0);
 else   if (foundColumns.size() > 1) {
    if (column.getTableName() == null)     throw new UnresolvedColumnException(column,(foundColumns.get(0).getTable() == null) ? ""String_Node_Str"" : (foundColumns.get(0).getTable().getADQLName() + ""String_Node_Str"" + foundColumns.get(0).getADQLName()),(foundColumns.get(1).getTable() == null) ? ""String_Node_Str"" : (foundColumns.get(1).getTable().getADQLName() + ""String_Node_Str"" + foundColumns.get(1).getADQLName()));
 else     throw new UnresolvedTableException(column,(foundColumns.get(0).getTable() == null) ? ""String_Node_Str"" : foundColumns.get(0).getTable().getADQLName(),(foundColumns.get(1).getTable() == null) ? ""String_Node_Str"" : foundColumns.get(1).getTable().getADQLName());
  }
 else   throw new UnresolvedColumnException(column);
}","/** 
 * <p>Resolves the given column, that's to say searches for the corresponding   {@link DBColumn}.</p> <p>The third parameter is used only if this function is called inside a subquery. In this case, column is tried to be resolved with the first list (dbColumns). If no match is found, the resolution is tried with the father columns list (fatherColumns).</p>
 * @param column		The column to resolve.
 * @param dbColumns		List of all available {@link DBColumn}s.
 * @param fathersList	List of all columns available in the father query ; a list for each father-level.
 * @return 				The corresponding {@link DBColumn} if found. Otherwise an exception is thrown.
 * @throws ParseException	An {@link UnresolvedColumnException} if the given column can't be resolvedor an  {@link UnresolvedTableException} if its table reference can't be resolved.
 */
protected DBColumn resolveColumn(final ADQLColumn column,final SearchColumnList dbColumns,Stack<SearchColumnList> fathersList) throws ParseException {
  ArrayList<DBColumn> foundColumns=dbColumns.search(column);
  if (foundColumns.size() == 1)   return foundColumns.get(0);
 else   if (foundColumns.size() > 1) {
    if (column.getTableName() == null)     throw new UnresolvedColumnException(column,(foundColumns.get(0).getTable() == null) ? ""String_Node_Str"" : (foundColumns.get(0).getTable().getADQLName() + ""String_Node_Str"" + foundColumns.get(0).getADQLName()),(foundColumns.get(1).getTable() == null) ? ""String_Node_Str"" : (foundColumns.get(1).getTable().getADQLName() + ""String_Node_Str"" + foundColumns.get(1).getADQLName()));
 else     throw new UnresolvedTableException(column,(foundColumns.get(0).getTable() == null) ? ""String_Node_Str"" : foundColumns.get(0).getTable().getADQLName(),(foundColumns.get(1).getTable() == null) ? ""String_Node_Str"" : foundColumns.get(1).getTable().getADQLName());
  }
 else {
    if (fathersList == null || fathersList.isEmpty())     throw new UnresolvedColumnException(column);
 else {
      Stack<SearchColumnList> subStack=new Stack<SearchColumnList>();
      subStack.addAll(fathersList.subList(0,fathersList.size() - 1));
      return resolveColumn(column,fathersList.peek(),subStack);
    }
  }
}",0.800108489286683
25122,"@Override public boolean match(final ADQLObject obj){
  return (obj instanceof ColumnReference);
}","@Override protected boolean match(ADQLObject obj){
  return (obj instanceof ADQLQuery);
}",0.8128342245989305
25123,"/** 
 * Followed algorithm: <pre> Map&lt;DBTable,ADQLTable&gt; mapTables; For each ADQLTable t if (t.isSubQuery()) dbTable = generateDBTable(t.getSubQuery, t.getAlias()); else dbTable = resolveTable(t); t.setDBLink(dbTable); dbTables.put(t, dbTable); End For each SelectAllColumns c table = c.getAdqlTable(); if (table != null){ dbTable = resolveTable(table); if (dbTable == null) dbTable = query.getFrom().getTablesByAlias(table.getTableName(), table.isCaseSensitive(IdentifierField.TABLE)); if (dbTable == null) throw new UnresolvedTableException(table); table.setDBLink(dbTable); } End SearchColumnList list = query.getFrom().getDBColumns(); For each ADQLColumn c dbColumn = resolveColumn(c, list); c.setDBLink(dbColumn); c.setAdqlTable(mapTables.get(dbColumn.getTable())); End For each ColumnReference colRef checkColumnReference(colRef, query.getSelect(), list); End </pre>
 * @param query				The query to check.
 * @throws ParseException	An {@link UnresolvedIdentifiersException} if some tables or columns can not be resolved.
 * @see #resolveTable(ADQLTable)
 * @see #generateDBTable(ADQLQuery,String)
 * @see #resolveColumn(ADQLColumn,SearchColumnList)
 * @see #checkColumnReference(ColumnReference,ClauseSelect,SearchColumnList)
 */
@Override public void check(final ADQLQuery query) throws ParseException {
  UnresolvedIdentifiersException errors=new UnresolvedIdentifiersException();
  HashMap<DBTable,ADQLTable> mapTables=new HashMap<DBTable,ADQLTable>();
  ISearchHandler sHandler;
  sHandler=new SearchTableHandler();
  sHandler.search(query.getFrom());
  for (  ADQLObject result : sHandler) {
    try {
      ADQLTable table=(ADQLTable)result;
      DBTable dbTable=null;
      if (table.isSubQuery()) {
        dbTable=generateDBTable(table.getSubQuery(),table.getAlias());
      }
 else {
        dbTable=resolveTable(table);
        if (table.hasAlias())         dbTable=dbTable.copy(dbTable.getDBName(),table.getAlias());
      }
      table.setDBLink(dbTable);
      mapTables.put(dbTable,table);
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchWildCardHandler();
  sHandler.search(query.getSelect());
  for (  ADQLObject result : sHandler) {
    try {
      SelectAllColumns wildcard=(SelectAllColumns)result;
      ADQLTable table=wildcard.getAdqlTable();
      DBTable dbTable=null;
      if (table.getTableName() != null && table.getSchemaName() == null) {
        ArrayList<ADQLTable> tables=query.getFrom().getTablesByAlias(table.getTableName(),table.isCaseSensitive(IdentifierField.TABLE));
        if (tables.size() == 1)         dbTable=tables.get(0).getDBLink();
      }
      if (dbTable == null)       dbTable=resolveTable(table);
      wildcard.setAdqlTable(mapTables.get(dbTable));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  SearchColumnList list;
  try {
    list=query.getFrom().getDBColumns();
  }
 catch (  ParseException pe) {
    errors.addException(pe);
    list=new SearchColumnList();
  }
  sHandler=new SearchColumnHandler();
  sHandler.search(query);
  for (  ADQLObject result : sHandler) {
    try {
      ADQLColumn adqlColumn=(ADQLColumn)result;
      DBColumn dbColumn=resolveColumn(adqlColumn,list);
      adqlColumn.setDBLink(dbColumn);
      adqlColumn.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchColReferenceHandler();
  sHandler.search(query);
  ClauseSelect select=query.getSelect();
  for (  ADQLObject result : sHandler) {
    try {
      ColumnReference colRef=(ColumnReference)result;
      DBColumn dbColumn=checkColumnReference(colRef,select,list);
      colRef.setDBLink(dbColumn);
      if (dbColumn != null)       colRef.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  if (errors.getNbErrors() > 0)   throw errors;
}","/** 
 * Followed algorithm: <pre> Map&lt;DBTable,ADQLTable&gt; mapTables; For each ADQLTable t if (t.isSubQuery()) dbTable = generateDBTable(t.getSubQuery, t.getAlias()); else dbTable = resolveTable(t); t.setDBLink(dbTable); dbTables.put(t, dbTable); End For each SelectAllColumns c table = c.getAdqlTable(); if (table != null){ dbTable = resolveTable(table); if (dbTable == null) dbTable = query.getFrom().getTablesByAlias(table.getTableName(), table.isCaseSensitive(IdentifierField.TABLE)); if (dbTable == null) throw new UnresolvedTableException(table); table.setDBLink(dbTable); } End SearchColumnList list = query.getFrom().getDBColumns(); For each ADQLColumn c dbColumn = resolveColumn(c, list); c.setDBLink(dbColumn); c.setAdqlTable(mapTables.get(dbColumn.getTable())); End For each ColumnReference colRef checkColumnReference(colRef, query.getSelect(), list); End </pre>
 * @param query			The query to check.
 * @param fathersList	List of all columns available in the father query.
 * @throws UnresolvedIdentifiersException	An {@link UnresolvedIdentifiersException} if some tables or columns can not be resolved.
 * @since 1.2
 * @see #resolveTable(ADQLTable)
 * @see #generateDBTable(ADQLQuery,String)
 * @see #resolveColumn(ADQLColumn,SearchColumnList)
 * @see #checkColumnReference(ColumnReference,ClauseSelect,SearchColumnList)
 */
protected void check(final ADQLQuery query,Stack<SearchColumnList> fathersList) throws UnresolvedIdentifiersException {
  UnresolvedIdentifiersException errors=new UnresolvedIdentifiersException();
  HashMap<DBTable,ADQLTable> mapTables=new HashMap<DBTable,ADQLTable>();
  ISearchHandler sHandler;
  sHandler=new SearchTableHandler();
  sHandler.search(query.getFrom());
  for (  ADQLObject result : sHandler) {
    try {
      ADQLTable table=(ADQLTable)result;
      DBTable dbTable=null;
      if (table.isSubQuery()) {
        check(table.getSubQuery(),fathersList);
        dbTable=generateDBTable(table.getSubQuery(),table.getAlias());
      }
 else {
        dbTable=resolveTable(table);
        if (table.hasAlias())         dbTable=dbTable.copy(dbTable.getDBName(),table.getAlias());
      }
      table.setDBLink(dbTable);
      mapTables.put(dbTable,table);
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchWildCardHandler();
  sHandler.search(query.getSelect());
  for (  ADQLObject result : sHandler) {
    try {
      SelectAllColumns wildcard=(SelectAllColumns)result;
      ADQLTable table=wildcard.getAdqlTable();
      DBTable dbTable=null;
      if (table.getTableName() != null && table.getSchemaName() == null) {
        ArrayList<ADQLTable> tables=query.getFrom().getTablesByAlias(table.getTableName(),table.isCaseSensitive(IdentifierField.TABLE));
        if (tables.size() == 1)         dbTable=tables.get(0).getDBLink();
      }
      if (dbTable == null)       dbTable=resolveTable(table);
      wildcard.setAdqlTable(mapTables.get(dbTable));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  SearchColumnList list;
  try {
    list=query.getFrom().getDBColumns();
  }
 catch (  ParseException pe) {
    errors.addException(pe);
    list=new SearchColumnList();
  }
  sHandler=new SearchColumnHandler();
  sHandler.search(query);
  for (  ADQLObject result : sHandler) {
    try {
      ADQLColumn adqlColumn=(ADQLColumn)result;
      DBColumn dbColumn=resolveColumn(adqlColumn,list,fathersList);
      adqlColumn.setDBLink(dbColumn);
      adqlColumn.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchColReferenceHandler();
  sHandler.search(query);
  ClauseSelect select=query.getSelect();
  for (  ADQLObject result : sHandler) {
    try {
      ColumnReference colRef=(ColumnReference)result;
      DBColumn dbColumn=checkColumnReference(colRef,select,list);
      colRef.setDBLink(dbColumn);
      if (dbColumn != null)       colRef.setAdqlTable(mapTables.get(dbColumn.getTable()));
    }
 catch (    ParseException pe) {
      errors.addException(pe);
    }
  }
  sHandler=new SearchSubQueryHandler();
  sHandler.search(query);
  if (sHandler.getNbMatch() > 0) {
    if (fathersList == null)     fathersList=new Stack<SearchColumnList>();
    fathersList.push(list);
    for (    ADQLObject result : sHandler) {
      try {
        check((ADQLQuery)result,fathersList);
      }
 catch (      UnresolvedIdentifiersException uie) {
        Iterator<ParseException> itPe=uie.getErrors();
        while (itPe.hasNext())         errors.addException(itPe.next());
      }
    }
    fathersList.pop();
  }
  if (errors.getNbErrors() > 0)   throw errors;
}",0.9013142725386212
25124,"/** 
 * <p>Gets the error (if any) which has occurred during the job execution.</p> <p><i><u>Note:</u> In the case an error summary can not have been published, the job has no error summary. However the last   {@link UWSException} caught during the execution of a {@link JobThread} is saved and is available thanks to {@link JobThread#getError()}. In that case, the   {@link UWSJob#getWorkError() getWorkError()} method can be used to get back the occurred error.</i></p>
 * @return	The error which interrupts the thread or <i>null</i> if there was no error or if the job is still running.
 */
public final UWSException getWorkError(){
  return (thread == null && !thread.isAlive()) ? null : thread.getError();
}","/** 
 * <p>Gets the error (if any) which has occurred during the job execution.</p> <p><i><u>Note:</u> In the case an error summary can not have been published, the job has no error summary. However the last   {@link UWSException} caught during the execution of a {@link JobThread} is saved and is available thanks to {@link JobThread#getError()}. In that case, the   {@link UWSJob#getWorkError() getWorkError()} method can be used to get back the occurred error.</i></p>
 * @return	The error which interrupts the thread or <i>null</i> if there was no error or if the job is still running.
 */
public final UWSException getWorkError(){
  return (thread == null || !thread.isAlive()) ? null : thread.getError();
}",0.9971910112359552
25125,"public String getName(){
  return ""String_Node_Str"";
}","@Override public String getName(){
  return ""String_Node_Str"";
}",0.9152542372881356
25126,"public ADQLObject getCopy() throws Exception {
  return new RegionFunction(this);
}","@Override public ADQLObject getCopy() throws Exception {
  return new RegionFunction(this);
}",0.9431818181818182
25127,"public boolean isNumeric(){
  return false;
}","@Override public boolean isNumeric(){
  return false;
}",0.9
25128,"@Override public ADQLOperand setParameter(int index,ADQLOperand replacer) throws ArrayIndexOutOfBoundsException, NullPointerException, Exception {
  if (index == 0) {
    if (replacer == null)     throw new NullPointerException(""String_Node_Str"" + getName() + ""String_Node_Str"");
 else     if (replacer instanceof ADQLOperand) {
      ADQLOperand replaced=parameter;
      parameter=replaced;
      return replaced;
    }
 else     throw new Exception(""String_Node_Str"" + replacer.getClass().getName() + ""String_Node_Str""+ replacer.toADQL()+ ""String_Node_Str"");
  }
 else   throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + index + ""String_Node_Str""+ getName()+ ""String_Node_Str"");
}","@Override public ADQLOperand setParameter(int index,ADQLOperand replacer) throws ArrayIndexOutOfBoundsException, NullPointerException, Exception {
  if (index == 0) {
    if (replacer == null)     throw new NullPointerException(""String_Node_Str"" + getName() + ""String_Node_Str"");
 else     if (replacer instanceof ADQLOperand) {
      ADQLOperand replaced=parameter;
      parameter=replacer;
      return replaced;
    }
 else     throw new Exception(""String_Node_Str"" + replacer.getClass().getName() + ""String_Node_Str""+ replacer.toADQL()+ ""String_Node_Str"");
  }
 else   throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + index + ""String_Node_Str""+ getName()+ ""String_Node_Str"");
}",0.9985590778097982
25129,"public boolean isString(){
  return true;
}","@Override public boolean isString(){
  return true;
}",0.8958333333333334
25130,"@Override protected vehRecord doInBackground(Object... params){
  this.vehView=(vehRecView)params[0];
  BufferedReader inBuffer=null;
  String url=""String_Node_Str"" + this.vehView.Param;
  vehRecord result;
  try {
    HttpClient httpClient=new DefaultHttpClient();
    HttpGet request=new HttpGet(url);
    HttpResponse httpResponse=httpClient.execute(request);
    inBuffer=new BufferedReader(new InputStreamReader(httpResponse.getEntity().getContent()));
    StringBuffer stringBuffer=new StringBuffer(""String_Node_Str"");
    String line=""String_Node_Str"";
    String newLine=System.getProperty(""String_Node_Str"");
    while ((line=inBuffer.readLine()) != null) {
      stringBuffer.append(line + newLine);
    }
    inBuffer.close();
    JSONObject json=new JSONObject(stringBuffer.toString());
    vehRecord vehicle=new vehRecord();
    Log.i(""String_Node_Str"",json.toString());
    getVehicle(json,vehicle);
    result=vehicle;
  }
 catch (  Exception e) {
    Log.i(""String_Node_Str"",e.getMessage());
    result=new vehRecord();
  }
 finally {
    if (inBuffer != null) {
      try {
        inBuffer.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return result;
}","@Override protected vehRecord doInBackground(Object... params){
  this.vehView=(vehRecView)params[0];
  if (this.vehView.Param.length() == 0) {
    vehRecord result=new vehRecord();
    result.VRM=""String_Node_Str"";
    return result;
  }
  BufferedReader inBuffer=null;
  String url=""String_Node_Str"" + this.vehView.Param;
  vehRecord result;
  try {
    HttpClient httpClient=new DefaultHttpClient();
    HttpGet request=new HttpGet(url);
    HttpResponse httpResponse=httpClient.execute(request);
    inBuffer=new BufferedReader(new InputStreamReader(httpResponse.getEntity().getContent()));
    StringBuffer stringBuffer=new StringBuffer(""String_Node_Str"");
    String line=""String_Node_Str"";
    String newLine=System.getProperty(""String_Node_Str"");
    while ((line=inBuffer.readLine()) != null) {
      stringBuffer.append(line + newLine);
    }
    inBuffer.close();
    JSONObject json=new JSONObject(stringBuffer.toString());
    vehRecord vehicle=new vehRecord();
    Log.i(""String_Node_Str"",json.toString());
    getVehicle(json,vehicle);
    result=vehicle;
  }
 catch (  Exception e) {
    Log.i(""String_Node_Str"",e.getMessage());
    result=new vehRecord();
  }
 finally {
    if (inBuffer != null) {
      try {
        inBuffer.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return result;
}",0.9468786351298952
25131,"public DateTime getMOT(){
  return MOT;
}","public DateTime getMOT(){
  if (MOT != null) {
    return MOT;
  }
 else {
    return new DateTime(1900,1,1,1,1);
  }
}",0.5125
25132,"public Boolean getInsured(){
  return Insured;
}","public Boolean getInsured(){
  if (Insured != null) {
    return Insured;
  }
 else {
    return false;
  }
}",0.6114649681528662
25133,"public DateTime getFirstReg(){
  return FirstReg;
}","public DateTime getFirstReg(){
  if (FirstReg != null) {
    return FirstReg;
  }
 else {
    return new DateTime(1900,1,1,1,1);
  }
}",0.5513513513513514
25134,"public DateTime getTax(){
  return Tax;
}","public DateTime getTax(){
  if (Tax != null) {
    return Tax;
  }
 else {
    return new DateTime(1900,1,1,1,1);
  }
}",0.5125
25135,"/** 
 * Gets the most correct UUID for the   {@link Player} in the least expensiveway possible. Note however, if there is no UUID information about the player on the server (e.g., they never played before), it will send a blocking web request to Mojang's servers
 * @since 0.1.0
 * @version 0.1.0
 * @param name The name of the {@link Player}
 * @return The {@link UUID} for that player
 */
public static UUID getUUID(String name){
  if (Bukkit.getServer().getOnlineMode()) {
    OfflinePlayer op=Bukkit.getOfflinePlayer(name);
    if (op.hasPlayedBefore() || op.isOnline()) {
      return op.getUniqueId();
    }
  }
  try {
    return UUIDFetcher.getUUIDOf(name);
  }
 catch (  IOException|ParseException|InterruptedException ex) {
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
}","/** 
 * Gets the most correct UUID for the   {@link Player} in the least expensiveway possible. Note however, if there is no UUID information about the player on the server (e.g., they never played before), it will send a blocking web request to Mojang's servers
 * @since 0.1.0
 * @version 0.1.0
 * @param name The name of the {@link Player}
 * @return The {@link UUID} for that player
 */
public static UUID getUUID(String name){
  if (Bukkit.getServer().getOnlineMode()) {
    OfflinePlayer op=Bukkit.getOfflinePlayer(name);
    if (op.hasPlayedBefore() || op.isOnline()) {
      return op.getUniqueId();
    }
  }
  try {
    return UUIDFetcher.getUUIDOf(name);
  }
 catch (  IOException|ParseException|InterruptedException ex) {
    throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"",ex);
  }
}",0.9834254143646408
25136,"/** 
 * Checks to make sure the connection is active to the MySQL server
 * @since 0.1.0
 * @version 0.1.0
 * @return true if connected, false otherwise
 */
public boolean checkConnection(){
  return this.query((rs) -> {
    return rs.first();
  }
,""String_Node_Str"");
}","/** 
 * Checks to make sure the connection is active to the MySQL server
 * @since 0.1.0
 * @version 0.1.0
 * @return true if connected, false otherwise
 */
public boolean checkConnection(){
  try {
    ResultSet rs=this.prepare(""String_Node_Str"").executeQuery();
    return rs.first();
  }
 catch (  SQLException ex) {
    return false;
  }
}",0.7275693311582382
25137,"/** 
 * Executes a query, and applies the resulting   {@link ResultSet} to thepassed  {@link SQLConsumer}
 * @since 0.1.0
 * @version 0.1.0
 * @param oper The operation to apply to the {@link ResultSet}
 * @param sql The SQL statement to execute
 * @param params Any {@link PreparedStatement} parameters
 * @return An {@link SQLResponse} containing any required information
 */
@SuppressWarnings(""String_Node_Str"") default public SQLResponse query(SQLConsumer<? super ResultSet> oper,String sql,Object... params){
  SQLResponse resp=new SQLResponse();
  PreparedStatement stmt=null;
  try {
    stmt=this.prepare(sql);
    for (int i=0; i < params.length; i++) {
      stmt.setObject(i + 1,params[i]);
    }
    ResultSet rs=stmt.executeQuery();
    oper.accept(rs);
    Databases.close(rs);
  }
 catch (  SQLException ex) {
    Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
  }
 finally {
    Databases.close(stmt);
  }
  return resp;
}","/** 
 * Executes a query, and applies the resulting   {@link ResultSet} to thepassed  {@link SQLConsumer}
 * @since 0.1.0
 * @version 0.1.0
 * @param oper The operation to apply to the {@link ResultSet}
 * @param sql The SQL statement to execute
 * @param params Any {@link PreparedStatement} parameters
 * @return An {@link SQLResponse} containing any required information
 */
@SuppressWarnings(""String_Node_Str"") default public SQLResponse query(SQLConsumer<? super ResultSet> oper,String sql,Object... params){
  SQLResponse resp=new SQLResponse();
  PreparedStatement stmt=null;
  try {
    stmt=this.prepare(sql);
    for (int i=0; i < params.length; i++) {
      stmt.setObject(i + 1,params[i]);
    }
    ResultSet rs=stmt.executeQuery();
    oper.accept(rs);
    Databases.close(rs);
  }
 catch (  SQLException ex) {
    if (this.isSendingErrorOutput()) {
      Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
    }
  }
 finally {
    Databases.close(stmt);
  }
  return resp;
}",0.9761300152361604
25138,"/** 
 * Executes a batch update on a database, and maps passed parameters based upon 0-indexed   {@code paramMappers} for each parameter. An example ofa usage would be: <br><br> {@code //A collection of objects to apply to each batch Collection<SomeObject> yourCollection; SQLDataType#batchUpdate(""<SQL Query>"", 500, yourCollection, (s) -> s.getName(), (s) -> s.getID(), (s) -> s.getLastName()); );}<br><br> In the above example, the   {@link PreparedStatement} parameters wouldmap each object so that ""Parameter 1"" would be the result of {@code SomeObject#getName}, and parameter 2 would be the result of  {@code SomeObject#getID}, and so on
 * @since 0.1.0
 * @version 0.1.0
 * @param < T > The type of the objects being batch committed
 * @param query The SQL query to execute
 * @param batchSize The size of each batch
 * @param params The objects to use in each batch
 * @param paramMappers A series of functions for mapping objects to params
 */
default public <T>void batchUpdate(String query,int batchSize,Collection<T> params,Function<T,?>... paramMappers){
  PreparedStatement stmt=null;
  try {
    stmt=this.prepare(query);
    this.setAutoCommit(false);
    Iterator<T> itr=params.iterator();
    for (int i=1; itr.hasNext(); i++) {
      T val=itr.next();
      for (int w=0; w < paramMappers.length; w++) {
        stmt.setObject(w + 1,paramMappers[w].apply(val));
      }
      stmt.addBatch();
      if (i >= batchSize) {
        stmt.executeBatch();
        this.commit();
        i=1;
      }
    }
    stmt.executeBatch();
    this.commit();
    this.setAutoCommit(true);
  }
 catch (  SQLException ex) {
    Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
  }
 finally {
    if (stmt != null) {
      Databases.close(stmt);
    }
  }
}","/** 
 * Executes a batch update on a database, and maps passed parameters based upon 0-indexed   {@code paramMappers} for each parameter. An example ofa usage would be: <br><br> {@code //A collection of objects to apply to each batch Collection<SomeObject> yourCollection; SQLDataType#batchUpdate(""<SQL Query>"", 500, yourCollection, (s) -> s.getName(), (s) -> s.getID(), (s) -> s.getLastName()); );}<br><br> In the above example, the   {@link PreparedStatement} parameters wouldmap each object so that ""Parameter 1"" would be the result of {@code SomeObject#getName}, and parameter 2 would be the result of  {@code SomeObject#getID}, and so on
 * @since 0.1.0
 * @version 0.1.0
 * @param < T > The type of the objects being batch committed
 * @param query The SQL query to execute
 * @param batchSize The size of each batch
 * @param params The objects to use in each batch
 * @param paramMappers A series of functions for mapping objects to params
 */
default public <T>void batchUpdate(String query,int batchSize,Collection<T> params,Function<T,?>... paramMappers){
  PreparedStatement stmt=null;
  try {
    stmt=this.prepare(query);
    this.setAutoCommit(false);
    Iterator<T> itr=params.iterator();
    for (int i=1; itr.hasNext(); i++) {
      T val=itr.next();
      for (int w=0; w < paramMappers.length; w++) {
        stmt.setObject(w + 1,paramMappers[w].apply(val));
      }
      stmt.addBatch();
      if (i >= batchSize) {
        stmt.executeBatch();
        this.commit();
        i=1;
      }
    }
    stmt.executeBatch();
    this.commit();
    this.setAutoCommit(true);
  }
 catch (  SQLException ex) {
    if (this.isSendingErrorOutput()) {
      Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
    }
  }
 finally {
    if (stmt != null) {
      Databases.close(stmt);
    }
  }
}",0.986955315015265
25139,"/** 
 * Executes a query that can change values
 * @since 0.1.0
 * @version 0.1.0
 * @param query The string query to execute
 * @param params Any {@link PreparedStatement} parameters
 * @return 0 for no returned results, or the number of returned rows
 */
@SuppressWarnings(""String_Node_Str"") default public SQLResponse update(String query,Object... params){
  SQLResponse resp=new SQLResponse();
  PreparedStatement stmt=null;
  int back=0;
  try {
    stmt=this.prepare(query);
    for (int i=0; i < params.length; i++) {
      stmt.setObject(i + 1,params[i]);
    }
    back=stmt.executeUpdate();
  }
 catch (  SQLException ex) {
    Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
  }
 finally {
    if (stmt != null) {
      Databases.close(stmt);
    }
  }
  resp.setUpdatedRows(back);
  return resp;
}","/** 
 * Executes a query that can change values
 * @since 0.1.0
 * @version 0.1.0
 * @param query The string query to execute
 * @param params Any {@link PreparedStatement} parameters
 * @return 0 for no returned results, or the number of returned rows
 */
@SuppressWarnings(""String_Node_Str"") default public SQLResponse update(String query,Object... params){
  SQLResponse resp=new SQLResponse();
  PreparedStatement stmt=null;
  int back=0;
  try {
    stmt=this.prepare(query);
    for (int i=0; i < params.length; i++) {
      stmt.setObject(i + 1,params[i]);
    }
    back=stmt.executeUpdate();
  }
 catch (  SQLException ex) {
    if (this.isSendingErrorOutput()) {
      Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
    }
  }
 finally {
    if (stmt != null) {
      Databases.close(stmt);
    }
  }
  resp.setUpdatedRows(back);
  return resp;
}",0.9724985371562316
25140,"/** 
 * Runs a   {@link PreparedStatement} using the provided {@code sql} parameter.The following  {@link SQLFunction} will then be run using this constructedstatement. This is typically more-so for use in one-time executed statements
 * @since 0.1.0
 * @version 0.1.0
 * @param < R > The type of the return value
 * @param oper The {@link SQLFunction} operation to use
 * @param sql The SQL statement to execute
 * @param params Parameters to pass to the {@link PreparedStatement}
 * @return The returned result of the {@link SQLFunction}
 */
default public <R>SQLResponse<R> operate(SQLFunction<? super PreparedStatement,R> oper,String sql,Object... params){
  SQLResponse<R> back=new SQLResponse<>();
  PreparedStatement stmt=null;
  try {
    stmt=this.prepare(sql);
    for (int i=0; i < params.length; i++) {
      stmt.setObject(i + 1,params[i]);
    }
    back.setResponse(oper.apply(stmt));
  }
 catch (  SQLException ex) {
    Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
  }
 finally {
    if (stmt != null) {
      Databases.close(stmt);
    }
  }
  return back;
}","/** 
 * Runs a   {@link PreparedStatement} using the provided {@code sql} parameter.The following  {@link SQLFunction} will then be run using this constructedstatement. This is typically more-so for use in one-time executed statements
 * @since 0.1.0
 * @version 0.1.0
 * @param < R > The type of the return value
 * @param oper The {@link SQLFunction} operation to use
 * @param sql The SQL statement to execute
 * @param params Parameters to pass to the {@link PreparedStatement}
 * @return The returned result of the {@link SQLFunction}
 */
default public <R>SQLResponse<R> operate(SQLFunction<? super PreparedStatement,R> oper,String sql,Object... params){
  SQLResponse<R> back=new SQLResponse<>();
  PreparedStatement stmt=null;
  try {
    stmt=this.prepare(sql);
    for (int i=0; i < params.length; i++) {
      stmt.setObject(i + 1,params[i]);
    }
    back.setResponse(oper.apply(stmt));
  }
 catch (  SQLException ex) {
    if (this.isSendingErrorOutput()) {
      Debugger.error(ex,""String_Node_Str"",Databases.simpleErrorOutput(ex));
    }
  }
 finally {
    if (stmt != null) {
      Databases.close(stmt);
    }
  }
  return back;
}",0.9791018230324589
25141,"/** 
 * Called from Bukkit to indicate an executed command <br><br>   {@inheritDoc}
 * @since 0.1.0
 * @version 0.1.0
 * @param sender {@inheritDoc}
 * @param command {@inheritDoc}
 * @param label {@inheritDoc}
 * @param args {@inheritDoc}
 * @return {@code true} if the returned {@link CommandStatus} was not a{@link CommandStatus#FAILED}
 */
@Override public final boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  Exceptions.illegalPluginAccess(Reflections.accessedFromBukkit(),""String_Node_Str"");
  CommandNode<? extends Plugin> child=this.getClosestChild(args);
  int start=0;
  for (int i=0; i < args.length; i++) {
    if (args[i].equalsIgnoreCase(child.getName())) {
      start=i + 1;
      break;
    }
  }
  CommandStatus stat;
  try {
    stat=this.verifyState(sender,args);
    if (stat == null) {
      stat=child.execute(sender,Arrays.copyOfRange(args,start,args.length));
    }
  }
 catch (  Throwable ex) {
    stat=CommandStatus.FAILED;
    child.plugin.getLogger().log(Level.SEVERE,String.format(""String_Node_Str"",label,StringUtils.join(args,""String_Node_Str"")),ex);
  }
  try {
    stat.handle(sender,child.format,child);
  }
 catch (  NullPointerException ex) {
    throw new IllegalReturnException(""String_Node_Str"",ex);
  }
  return stat != CommandStatus.FAILED;
}","/** 
 * Called from Bukkit to indicate an executed command <br><br>   {@inheritDoc}
 * @since 0.1.0
 * @version 0.1.0
 * @param sender {@inheritDoc}
 * @param command {@inheritDoc}
 * @param label {@inheritDoc}
 * @param args {@inheritDoc}
 * @return {@code true} if the returned {@link CommandStatus} was not a{@link CommandStatus#FAILED}
 */
@Override public final boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  Exceptions.illegalPluginAccess(Reflections.accessedFromBukkit(),""String_Node_Str"");
  CommandNode<? extends Plugin> child=this.getClosestChild(args);
  int start=0;
  if (args.length > 0) {
    for (int i=0; i < args.length; i++) {
      if (args[i].equalsIgnoreCase(child.getName())) {
        start=i + 1;
        break;
      }
    }
    args=Arrays.copyOfRange(args,start,args.length);
  }
  CommandStatus stat;
  try {
    stat=this.verifyState(child,sender,args);
    if (stat == null) {
      stat=child.execute(sender,args);
    }
  }
 catch (  Throwable ex) {
    stat=CommandStatus.FAILED;
    child.plugin.getLogger().log(Level.SEVERE,String.format(""String_Node_Str"",label,StringUtils.join(args,""String_Node_Str"")),ex);
  }
  try {
    stat.handle(sender,child.format,child);
  }
 catch (  NullPointerException ex) {
    throw new IllegalReturnException(""String_Node_Str"",ex);
  }
  return stat != CommandStatus.FAILED;
}",0.880354505169867
25142,"private CommandStatus verifyState(CommandSender sender,String... args){
  if (this.restriction != null && !this.restriction.verifySender(sender)) {
    return this.restriction;
  }
  if (!this.allowProxies && sender instanceof ProxiedCommandSender) {
    return CommandStatus.NO_PROXIES;
  }
  if (args.length < this.minArgs) {
    return CommandStatus.BAD_ARGS;
  }
  return null;
}","private CommandStatus verifyState(CommandNode<?> child,CommandSender sender,String... args){
  if (child.restriction != null && !child.restriction.verifySender(sender)) {
    return this.restriction;
  }
  if (!child.allowProxies && sender instanceof ProxiedCommandSender) {
    return CommandStatus.NO_PROXIES;
  }
  if (args.length < child.minArgs) {
    return CommandStatus.BAD_ARGS;
  }
  return null;
}",0.9279393173198482
25143,"public <K1 extends K,V1 extends V>Builder<K1,V1> onExpiry(Consumer<? extends ExpiringEntry<? super K,? super V>> expired){
  this.onExpire=expired;
  return (Builder<K1,V1>)this;
}","public <K1 extends K,V1 extends V>Builder<K1,V1> onExpiry(Consumer<? extends ExpiringEntry<? super K,? super V>> expired){
  return (Builder<K1,V1>)this;
}",0.9253731343283582
25144,"@Override public void onDisable(){
  Scheduler.cancelAllTasks();
}","@Override public void onDisable(){
  Scheduler.cancelAllTasks();
  Scheduler.getService().shutdown();
}",0.7810650887573964
25145,"/** 
 * Runs a Callable
 * @since 0.1.0
 * @version 0.1.0
 * @param c The callable to execute
 * @param delay Time (in seconds) to wait before execution
 * @return The scheduled Task
 */
public static ScheduledFuture<?> runCallable(Callable<?> c,long delay){
  ScheduledFuture<?> sch=Scheduler.es.schedule(c,delay,TimeUnit.SECONDS);
  Scheduler.executives.add(sch);
  return sch;
}","/** 
 * Runs a Callable
 * @since 0.1.0
 * @version 0.1.0
 * @param c The callable to execute
 * @param delay Time (in seconds) to wait before execution
 * @return The scheduled Task
 */
public static ScheduledFuture<?> runCallable(Callable<?> c,long delay){
  ScheduledFuture<?> sch=Scheduler.getService().schedule(c,delay,TimeUnit.SECONDS);
  Scheduler.executives.add(sch);
  return sch;
}",0.9818652849740932
25146,"/** 
 * Cancels all running tasks/threads and clears the cached queue.
 * @since 0.1.0
 * @version 0.1.0
 */
public static void cancelAllTasks(){
  Scheduler.executives.forEach(s -> s.cancel(false));
  Scheduler.executives.clear();
  try {
    Scheduler.getService().awaitTermination(1,TimeUnit.SECONDS);
    Scheduler.getService().shutdown();
  }
 catch (  InterruptedException ex) {
    DebugUtil.error(""String_Node_Str"",ex);
  }
}","/** 
 * Cancels all running tasks/threads and clears the cached queue.
 * @since 0.1.0
 * @version 0.1.0
 */
public static void cancelAllTasks(){
  Scheduler.executives.forEach(s -> s.cancel(false));
  Scheduler.executives.clear();
  try {
    Scheduler.getService().awaitTermination(2,TimeUnit.SECONDS);
  }
 catch (  InterruptedException ex) {
    DebugUtil.error(""String_Node_Str"",ex);
  }
}",0.9504232164449818
25147,"/** 
 * Runs a repeating asynchronous task
 * @since 0.1.0
 * @version 0.1.0
 * @param r The runnable to execute
 * @param startAfter Time (in seconds) to wait before execution
 * @param delay Time (in seconds) between execution to wait
 * @return The scheduled Task
 */
public static ScheduledFuture<?> runAsyncTaskRepeat(Runnable r,long startAfter,long delay){
  ScheduledFuture<?> sch=Scheduler.es.scheduleWithFixedDelay(r,startAfter,delay,TimeUnit.SECONDS);
  Scheduler.executives.add(sch);
  return sch;
}","/** 
 * Runs a repeating asynchronous task
 * @since 0.1.0
 * @version 0.1.0
 * @param r The runnable to execute
 * @param startAfter Time (in seconds) to wait before execution
 * @param delay Time (in seconds) between execution to wait
 * @return The scheduled Task
 */
public static ScheduledFuture<?> runAsyncTaskRepeat(Runnable r,long startAfter,long delay){
  ScheduledFuture<?> sch=Scheduler.getService().scheduleWithFixedDelay(r,startAfter,delay,TimeUnit.SECONDS);
  Scheduler.executives.add(sch);
  return sch;
}",0.9864077669902912
25148,"/** 
 * Returns the underlying   {@link ScheduledExecutorService} used for thisutility class
 * @since 0.1.0
 * @version 0.1.0
 * @return The underlying {@link ScheduledExecutorService}
 */
public static ScheduledExecutorService getService(){
  return Scheduler.es;
}","/** 
 * Returns the underlying   {@link ScheduledExecutorService} used for thisutility class
 * @since 0.1.0
 * @version 0.1.0
 * @return The underlying {@link ScheduledExecutorService}
 */
public static ScheduledExecutorService getService(){
  if (Scheduler.es.isShutdown()) {
    Scheduler.es=Executors.newScheduledThreadPool(10);
  }
  return Scheduler.es;
}",0.7898089171974523
25149,"/** 
 * Runs a single asynchronous task
 * @since 0.1.0
 * @version 0.1.0
 * @param r The runnable to execute
 * @param delay Time (in seconds) to wait before execution
 * @return The scheduled Task
 */
public static ScheduledFuture<?> runAsyncTask(Runnable r,long delay){
  ScheduledFuture<?> sch=Scheduler.es.schedule(r,delay,TimeUnit.SECONDS);
  Scheduler.executives.add(sch);
  return sch;
}","/** 
 * Runs a single asynchronous task
 * @since 0.1.0
 * @version 0.1.0
 * @param r The runnable to execute
 * @param delay Time (in seconds) to wait before execution
 * @return The scheduled Task
 */
public static ScheduledFuture<?> runAsyncTask(Runnable r,long delay){
  ScheduledFuture<?> sch=Scheduler.getService().schedule(r,delay,TimeUnit.SECONDS);
  Scheduler.executives.add(sch);
  return sch;
}",0.9825
25150,"/** 
 * Returns the save location for passed   {@link PluginFile} argument
 * @since 0.1.0
 * @version 0.1.0
 * @param clazz
 * @return 
 */
public static File getFileLocation(Class<? extends PluginFile> clazz){
  if (!(AnnotationUtil.hasAnnotation(clazz,PluginClass.class) && AnnotationUtil.hasAnnotation(clazz,RelativePath.class))) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new File(AnnotationUtil.getPlugin(clazz).getDataFolder(),clazz.getAnnotation(RelativePath.class).value());
}","/** 
 * Returns the save location for passed   {@link PluginFile} argument
 * @since 0.1.0
 * @version 0.1.0
 * @param clazz
 * @return 
 */
public static File getFileLocation(Class<? extends PluginFile> clazz){
  if (!(AnnotationUtil.hasAnnotation(clazz,PluginClass.class) && AnnotationUtil.hasAnnotation(clazz,RelativePath.class))) {
    throw new IllegalStateException(""String_Node_Str"" + clazz.getName() + ""String_Node_Str"");
  }
  return new File(AnnotationUtil.getPlugin(clazz).getDataFolder(),clazz.getAnnotation(RelativePath.class).value());
}",0.9642857142857144
25151,"protected final String generateSeed(int length){
  StringBuilder sb=new StringBuilder();
  ChatColor[] vals=ChatColor.values();
  Random rand=new Random();
  for (int i=0; i < length; i++) {
    sb.append('&').append(vals[rand.nextInt(vals.length)]);
  }
  return ChatColor.translateAlternateColorCodes('&',sb.toString());
}","protected final String generateSeed(int length){
  StringBuilder sb=new StringBuilder();
  ChatColor[] vals=ChatColor.values();
  Random rand=new Random();
  for (int i=0; i < length; i++) {
    sb.append(vals[rand.nextInt(vals.length)]);
  }
  return sb.toString();
}",0.9054054054054054
25152,"@Override public void run(){
  CoverageUtil.marks.entrySet().forEach((ent) -> {
    try {
      File data=new File(ent.getKey().getDataFolder(),""String_Node_Str"" + File.separator);
      File log=new File(data,""String_Node_Str"");
      if (log.exists()) {
        Files.move(log,new File(data,""String_Node_Str"" + log.lastModified() + ""String_Node_Str""));
      }
      try (FileWriter f=new FileWriter(log)){
        f.write(CoverageUtil.serialize(ent.getValue()));
      }
     }
 catch (    IOException ex) {
      DebugUtil.error(String.format(""String_Node_Str"",ent.getKey().getName()),ex);
    }
  }
);
}","@Override public void run(){
  System.out.println(""String_Node_Str"");
  CoverageUtil.marks.entrySet().forEach((ent) -> {
    System.out.println(""String_Node_Str"" + ent.getKey().getName() + ""String_Node_Str"");
    try {
      File data=new File(ent.getKey().getDataFolder(),""String_Node_Str"" + File.separator);
      data.mkdirs();
      File log=new File(data,""String_Node_Str"");
      if (log.exists()) {
        Files.move(log,new File(data,""String_Node_Str"" + log.lastModified() + ""String_Node_Str""));
      }
      try (FileWriter f=new FileWriter(log)){
        f.write(CoverageUtil.serialize(ent.getValue()));
      }
     }
 catch (    IOException ex) {
      System.out.println(String.format(""String_Node_Str"",ent.getKey().getName()));
      ex.printStackTrace();
    }
  }
);
}",0.8507890961262554
25153,"private static String serialize(PluginMarker mark){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (int i=mark.getPlugin().getName().length(); i > 0; i--) {
    sb.append('=');
  }
  sb.append('\n');
  sb.append(""String_Node_Str"");
  sb.append(mark.getPlugin().getName());
  sb.append(""String_Node_Str"");
  for (int i=mark.getPlugin().getName().length(); i > 0; i--) {
    sb.append('=');
  }
  sb.append(""String_Node_Str"");
  StringBuilder mb=new StringBuilder();
  mb.append(""String_Node_Str"");
  Single<Integer> hit=new Single<>(0);
  mark.getClassMarkers().forEach((c) -> {
    c.getMethodMarkers().forEach((m) -> {
      m.getMarkers().stream().filter(m::isHit).forEach((mk) -> {
        mb.append(String.format(""String_Node_Str"",c.getName(),m.getName(),mk.getLine()));
        hit.setValue(hit.getValue() + 1);
      }
);
    }
);
  }
);
  mb.append('\n');
  mb.append(""String_Node_Str"");
  Single<Integer> missed=new Single<>(0);
  mark.getClassMarkers().forEach((c) -> {
    c.getMethodMarkers().forEach((m) -> {
      mb.append(String.format(""String_Node_Str"",c.getName(),m.getName(),m.getMissed()));
      missed.setValue(missed.getValue() + m.getMissed());
    }
);
  }
);
  mb.append(""String_Node_Str"");
  mb.append(""String_Node_Str"");
  mark.getClassMarkers().forEach((c) -> {
    c.getMethodMarkers().forEach((m) -> {
      mb.append(String.format(""String_Node_Str"",mark.getPlugin().getName(),c.getName(),m.getName(),-1,m.getNumber()));
      m.getMarkers().stream().forEach((mk) -> {
        mb.append(String.format(""String_Node_Str"",mark.getPlugin().getName(),c.getName(),m.getName(),mk.getLine(),mk.isHit()));
      }
);
    }
);
  }
);
  sb.append(""String_Node_Str"").append(hit.getValue()).append('\n');
  sb.append(""String_Node_Str"").append(missed.getValue()).append('\n');
  sb.append(""String_Node_Str"").append(((double)hit.getValue()) / ((double)(hit.getValue() + missed.getValue()))).append(""String_Node_Str"");
  sb.append('\n');
  sb.append(mb);
  return sb.toString();
}","private static String serialize(PluginMarker mark){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (int i=mark.getPlugin().getName().length(); i > 0; i--) {
    sb.append('=');
  }
  sb.append('\n');
  sb.append(""String_Node_Str"");
  sb.append(mark.getPlugin().getName());
  sb.append('\n');
  sb.append(""String_Node_Str"");
  for (int i=mark.getPlugin().getName().length(); i > 0; i--) {
    sb.append('=');
  }
  sb.append(""String_Node_Str"");
  StringBuilder mb=new StringBuilder();
  mb.append(""String_Node_Str"");
  Single<Integer> hit=new Single<>(0);
  mark.getClassMarkers().forEach((c) -> {
    c.getMethodMarkers().forEach((m) -> {
      m.getMarkers().stream().filter(m::isHit).forEach((mk) -> {
        mb.append(String.format(""String_Node_Str"",c.getName(),m.getName(),mk.getLine()));
        hit.setValue(hit.getValue() + 1);
      }
);
    }
);
  }
);
  mb.append('\n');
  mb.append(""String_Node_Str"");
  Single<Integer> missed=new Single<>(0);
  mark.getClassMarkers().forEach((c) -> {
    c.getMethodMarkers().forEach((m) -> {
      mb.append(String.format(""String_Node_Str"",c.getName(),m.getName(),m.getMissed()));
      missed.setValue(missed.getValue() + m.getMissed());
    }
);
  }
);
  mb.append('\n');
  mb.append(""String_Node_Str"");
  mb.append(""String_Node_Str"");
  mark.getClassMarkers().forEach((c) -> {
    c.getMethodMarkers().forEach((m) -> {
      mb.append(String.format(""String_Node_Str"",mark.getPlugin().getName(),c.getName(),m.getName(),-1,m.getNumber()));
      m.getMarkers().stream().forEach((mk) -> {
        mb.append(String.format(""String_Node_Str"",mark.getPlugin().getName(),c.getName(),m.getName(),mk.getLine(),mk.isHit()));
      }
);
    }
);
  }
);
  sb.append(""String_Node_Str"").append(hit.getValue()).append('\n');
  sb.append(""String_Node_Str"").append(missed.getValue()).append('\n');
  sb.append(""String_Node_Str"").append(String.format(""String_Node_Str"",((double)hit.getValue()) / ((double)(hit.getValue() + missed.getValue())) * 100)).append(""String_Node_Str"");
  sb.append('\n');
  sb.append(mb);
  return sb.toString();
}",0.9812057603124236
25154,"/** 
 * Loads datasets into platform. Uploads given datasets and their manifests to staging area and triggers ETL pull. The call is asynchronous returning   {@link com.gooddata.FutureResult} to let caller wait for results.Uploaded files are deleted from staging area when finished.
 * @param project  project to which dataset belongs
 * @param datasets map dataset manifests
 * @return {@link com.gooddata.FutureResult} of the task, which can throw {@link com.gooddata.dataset.DatasetException}in case the ETL pull task fails
 * @throws com.gooddata.dataset.DatasetException if there is a problem to serialize manifest or upload dataset
 * @see <a href=""https://developer.gooddata.com/article/multiload-of-csv-data"">batch upload reference</a>
 */
public FutureResult<Void> loadDatasets(final Project project,final Collection<DatasetManifest> datasets){
  notNull(project,""String_Node_Str"");
  validateUploadManifests(datasets);
  final List<String> datasetsNames=new ArrayList<>(datasets.size());
  try {
    final Path dirPath=Paths.get(""String_Node_Str"",project.getId() + ""String_Node_Str"" + RandomStringUtils.randomAlphabetic(3),""String_Node_Str"");
    for (    DatasetManifest datasetManifest : datasets) {
      datasetsNames.add(datasetManifest.getDataSet());
      dataStoreService.upload(dirPath.resolve(datasetManifest.getFile()).toString(),datasetManifest.getSource());
    }
    final String manifestJson=mapper.writeValueAsString(new DatasetManifests(datasets));
    final ByteArrayInputStream inputStream=new ByteArrayInputStream(manifestJson.getBytes(UTF_8));
    dataStoreService.upload(dirPath.resolve(MANIFEST_FILE_NAME).toString(),inputStream);
    return pullLoad(project,dirPath.toString(),datasetsNames);
  }
 catch (  IOException e) {
    throw new DatasetException(""String_Node_Str"",datasetsNames,e);
  }
catch (  DataStoreException|GoodDataRestException|RestClientException e) {
    throw new DatasetException(""String_Node_Str"",datasetsNames,e);
  }
}","/** 
 * Loads datasets into platform. Uploads given datasets and their manifests to staging area and triggers ETL pull. The call is asynchronous returning   {@link com.gooddata.FutureResult} to let caller wait for results.Uploaded files are deleted from staging area when finished.
 * @param project  project to which dataset belongs
 * @param datasets map dataset manifests
 * @return {@link com.gooddata.FutureResult} of the task, which can throw {@link com.gooddata.dataset.DatasetException}in case the ETL pull task fails
 * @throws com.gooddata.dataset.DatasetException if there is a problem to serialize manifest or upload dataset
 * @see <a href=""https://developer.gooddata.com/article/multiload-of-csv-data"">batch upload reference</a>
 */
public FutureResult<Void> loadDatasets(final Project project,final Collection<DatasetManifest> datasets){
  notNull(project,""String_Node_Str"");
  validateUploadManifests(datasets);
  final List<String> datasetsNames=new ArrayList<>(datasets.size());
  try {
    final String dirPath=""String_Node_Str"" + project.getId() + ""String_Node_Str""+ RandomStringUtils.randomAlphabetic(3)+ ""String_Node_Str"";
    for (    DatasetManifest datasetManifest : datasets) {
      datasetsNames.add(datasetManifest.getDataSet());
      dataStoreService.upload(dirPath + datasetManifest.getFile(),datasetManifest.getSource());
    }
    final String manifestJson=mapper.writeValueAsString(new DatasetManifests(datasets));
    final ByteArrayInputStream inputStream=new ByteArrayInputStream(manifestJson.getBytes(UTF_8));
    dataStoreService.upload(dirPath + MANIFEST_FILE_NAME,inputStream);
    return pullLoad(project,dirPath,datasetsNames);
  }
 catch (  IOException e) {
    throw new DatasetException(""String_Node_Str"",datasetsNames,e);
  }
catch (  DataStoreException|GoodDataRestException|RestClientException e) {
    throw new DatasetException(""String_Node_Str"",datasetsNames,e);
  }
}",0.9753593429158112
25155,"@Override public void handleError(ClientHttpResponse response){
  ErrorStructure error=null;
  try {
    error=gdcErrorExtractor.extractData(response);
  }
 catch (  RestClientException|IOException ignored) {
  }
  final String requestId=response.getHeaders().getFirst(GDC_REQUEST_ID_HEADER);
  int statusCode;
  try {
    statusCode=response.getRawStatusCode();
  }
 catch (  IOException e) {
    statusCode=0;
  }
  String statusText;
  try {
    statusText=response.getStatusText();
  }
 catch (  IOException e) {
    statusText=null;
  }
  throw new GoodDataRestException(statusCode,requestId,statusText,error);
}","@Override public void handleError(ClientHttpResponse response){
  ErrorStructure error=null;
  try {
    error=gdcErrorExtractor.extractData(response);
  }
 catch (  RestClientException|IOException|HttpMessageConversionException ignored) {
  }
  final String requestId=response.getHeaders().getFirst(GDC_REQUEST_ID_HEADER);
  int statusCode;
  try {
    statusCode=response.getRawStatusCode();
  }
 catch (  IOException e) {
    statusCode=0;
  }
  String statusText;
  try {
    statusText=response.getStatusText();
  }
 catch (  IOException e) {
    statusText=null;
  }
  throw new GoodDataRestException(statusCode,requestId,statusText,error);
}",0.9754940711462452
25156,"/** 
 * Construct a GoodDataRestException with specified details.
 * @param statusCode the HTTP status code of the response
 * @param requestId  the GoodData request ID (from header)
 * @param statusText the HTTP status text of the response
 * @param error      the GoodData REST API error structure
 */
public GoodDataRestException(int statusCode,String requestId,String statusText,GdcError error){
  this(statusCode,error != null && error.getRequestId() != null ? error.getRequestId() : requestId,error != null && error.getMessage() != null ? error.getFormattedMessage() : statusText,error != null ? error.getComponent() : null,error != null ? error.getErrorClass() : null,error != null ? error.getErrorCode() : null);
}","/** 
 * Construct a GoodDataRestException with specified details.
 * @param statusCode the HTTP status code of the response
 * @param requestId  the GoodData request ID (from header)
 * @param statusText the HTTP status text of the response
 * @param error      the GoodData REST API error structure
 */
public GoodDataRestException(int statusCode,String requestId,String statusText,ErrorStructure error){
  this(statusCode,error != null && error.getRequestId() != null ? error.getRequestId() : requestId,error != null && error.getMessage() != null ? error.getFormattedMessage() : statusText,error != null ? error.getComponent() : null,error != null ? error.getErrorClass() : null,error != null ? error.getErrorCode() : null);
}",0.986206896551724
25157,"public ResponseErrorHandler(List<HttpMessageConverter<?>> messageConverters){
  gdcErrorExtractor=new HttpMessageConverterExtractor<>(GdcError.class,noNullElements(messageConverters,""String_Node_Str""));
}","public ResponseErrorHandler(List<HttpMessageConverter<?>> messageConverters){
  gdcErrorExtractor=new HttpMessageConverterExtractor<>(ErrorStructure.class,noNullElements(messageConverters,""String_Node_Str""));
}",0.9468599033816424
25158,"@Override public void handleError(ClientHttpResponse response){
  GdcError error=null;
  try {
    error=gdcErrorExtractor.extractData(response);
  }
 catch (  RestClientException|IOException ignored) {
  }
  final String requestId=response.getHeaders().getFirst(GDC_REQUEST_ID_HEADER);
  int statusCode;
  try {
    statusCode=response.getRawStatusCode();
  }
 catch (  IOException e) {
    statusCode=0;
  }
  String statusText;
  try {
    statusText=response.getStatusText();
  }
 catch (  IOException e) {
    statusText=null;
  }
  throw new GoodDataRestException(statusCode,requestId,statusText,error);
}","@Override public void handleError(ClientHttpResponse response){
  ErrorStructure error=null;
  try {
    error=gdcErrorExtractor.extractData(response);
  }
 catch (  RestClientException|IOException ignored) {
  }
  final String requestId=response.getHeaders().getFirst(GDC_REQUEST_ID_HEADER);
  int statusCode;
  try {
    statusCode=response.getRawStatusCode();
  }
 catch (  IOException e) {
    statusCode=0;
  }
  String statusText;
  try {
    statusText=response.getStatusText();
  }
 catch (  IOException e) {
    statusText=null;
  }
  throw new GoodDataRestException(statusCode,requestId,statusText,error);
}",0.982084690553746
25159,"/** 
 * Account creation constructor
 */
public Account(String email,String password,String firstName,String lastName){
  this(email,email,password,password,firstName,lastName,null);
}","/** 
 * Account creation constructor
 * @param email email
 * @param firstName first name
 * @param lastName last name
 * @param password password
 */
public Account(String email,String password,String firstName,String lastName){
  this(email,email,password,password,firstName,lastName,null);
}",0.7698744769874477
25160,"/** 
 * Get account for given account id
 * @param id to search for
 * @return account for id
 * @throws AccountNotFoundException when account for given id can't be found
 * @throws GoodDataException
 */
public Account getAccountById(String id){
  try {
    return restTemplate.getForObject(Account.URI,Account.class,id);
  }
 catch (  GoodDataRestException e) {
    if (HttpStatus.NOT_FOUND.value() == e.getStatusCode()) {
      throw new AccountNotFoundException(Account.TEMPLATE.expand(id).toString(),e);
    }
 else {
      throw e;
    }
  }
catch (  RestClientException e) {
    throw new GoodDataException(""String_Node_Str"",e);
  }
}","/** 
 * Get account for given account id
 * @param id to search for
 * @return account for id
 * @throws AccountNotFoundException when account for given id can't be found
 * @throws GoodDataException when different error occurs
 */
public Account getAccountById(String id){
  try {
    return restTemplate.getForObject(Account.URI,Account.class,id);
  }
 catch (  GoodDataRestException e) {
    if (HttpStatus.NOT_FOUND.value() == e.getStatusCode()) {
      throw new AccountNotFoundException(Account.TEMPLATE.expand(id).toString(),e);
    }
 else {
      throw e;
    }
  }
catch (  RestClientException e) {
    throw new GoodDataException(""String_Node_Str"",e);
  }
}",0.9785932721712538
25161,"/** 
 * Get account for given account id
 * @param uri to search for
 * @return account for uri
 * @throws AccountNotFoundException when account for given uri can't be found
 * @throws GoodDataException
 */
public Account getAccountByUri(String uri){
  return getAccountById(Account.getId(uri));
}","/** 
 * Get account for given account id
 * @param uri to search for
 * @return account for uri
 * @throws AccountNotFoundException when account for given uri can't be found
 * @throws GoodDataException when different error occurs
 */
public Account getAccountByUri(String uri){
  return getAccountById(Account.getId(uri));
}",0.954983922829582
25162,"/** 
 * @deprecated for backward compatibility only. Do not use this method, it always returns null.
 */
@Deprecated public List<String> getVals(){
  return null;
}","/** 
 * @return list of values
 * @deprecated for backward compatibility only. Do not use this method, it always returns null.
 */
@Deprecated public List<String> getVals(){
  return null;
}",0.9265536723163842
25163,"/** 
 * Returns list of IDs. IDs are primary property of this param.
 */
public List<String> getIds(){
  return ids;
}","/** 
 * @return list of IDs. IDs are primary property of this param.
 */
public List<String> getIds(){
  return ids;
}",0.9830508474576272
25164,"/** 
 * Returns list of values. Values have only informative character and are connected to IDs.
 * @see #getIds()
 */
public List<String> getVals(){
  return vals;
}","/** 
 * @return list of values. Values have only informative character and are connected to IDs.
 * @see #getIds()
 */
public List<String> getVals(){
  return vals;
}",0.9879518072289156
25165,"/** 
 * Remove given user from warehouse instance
 * @param user to remove from warehouse
 * @throws WarehouseUserNotFoundException when user for removal can't be found
 * @throws GoodDataException any other reason
 */
public FutureResult<Void> removeUserFromWarehouse(final WarehouseUser user){
  notNull(user,""String_Node_Str"");
  final WarehouseTask task;
  try {
    task=restTemplate.exchange(user.getUri(),HttpMethod.DELETE,null,WarehouseTask.class).getBody();
  }
 catch (  GoodDataRestException e) {
    if (HttpStatus.NOT_FOUND.value() == e.getStatusCode()) {
      throw new WarehouseUserNotFoundException(user.getUri(),e);
    }
 else {
      throw e;
    }
  }
catch (  RestClientException e) {
    throw new GoodDataException(""String_Node_Str"" + user.getUri(),e);
  }
  if (task == null) {
    throw new GoodDataException(""String_Node_Str"");
  }
  return new PollResult<>(this,new AbstractPollHandler<WarehouseTask,Void>(task.getPollUri(),WarehouseTask.class,Void.class){
    @Override public boolean isFinished(    ClientHttpResponse response) throws IOException {
      return HttpStatus.CREATED.equals(response.getStatusCode());
    }
    @Override public void handlePollResult(    WarehouseTask pollResult){
      setResult(null);
    }
    @Override public void handlePollException(    final GoodDataRestException e){
      throw new GoodDataException(""String_Node_Str"",e);
    }
  }
);
}","/** 
 * Remove given user from warehouse instance
 * @param user to remove from warehouse
 * @return empty future result
 * @throws WarehouseUserNotFoundException when user for removal can't be found
 * @throws GoodDataException any other reason
 */
public FutureResult<Void> removeUserFromWarehouse(final WarehouseUser user){
  notNull(user,""String_Node_Str"");
  final WarehouseTask task;
  try {
    task=restTemplate.exchange(user.getUri(),HttpMethod.DELETE,null,WarehouseTask.class).getBody();
  }
 catch (  GoodDataRestException e) {
    if (HttpStatus.NOT_FOUND.value() == e.getStatusCode()) {
      throw new WarehouseUserNotFoundException(user.getUri(),e);
    }
 else {
      throw e;
    }
  }
catch (  RestClientException e) {
    throw new GoodDataException(""String_Node_Str"" + user.getUri(),e);
  }
  if (task == null) {
    throw new GoodDataException(""String_Node_Str"");
  }
  return new PollResult<>(this,new AbstractPollHandler<WarehouseTask,Void>(task.getPollUri(),WarehouseTask.class,Void.class){
    @Override public boolean isFinished(    ClientHttpResponse response) throws IOException {
      return HttpStatus.CREATED.equals(response.getStatusCode());
    }
    @Override public void handlePollResult(    WarehouseTask pollResult){
      setResult(null);
    }
    @Override public void handlePollException(    final GoodDataRestException e){
      throw new GoodDataException(""String_Node_Str"",e);
    }
  }
);
}",0.9890960253253606
25166,"@Test public void shouldZipDirWithoutRoot() throws Exception {
  Path toZipDir=temporaryFolder.resolve(""String_Node_Str"");
  toZipDir.toFile().mkdirs();
  File toZipFile=toZipDir.resolve(""String_Node_Str"").toFile();
  toZipFile.getParentFile().mkdirs();
  toZipFile.createNewFile();
  try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(toZipDir.toFile(),output);
    output.close();
    verifyZipContent(output,""String_Node_Str"");
  }
 }","@Test public void shouldZipDirWithoutRoot() throws Exception {
  Path toZipDir=temporaryFolder.resolve(""String_Node_Str"");
  toZipDir.toFile().mkdirs();
  File toZipFile=toZipDir.resolve(SOME_FILE_PATH).toFile();
  toZipFile.getParentFile().mkdirs();
  toZipFile.createNewFile();
  try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(toZipDir.toFile(),output);
    output.close();
    verifyZipContent(output,Paths.get(""String_Node_Str"",""String_Node_Str"",SOME_FILE).toString());
  }
 }",0.9174311926605504
25167,"@Test public void shouldNotZipAlreadyZipped() throws Exception {
  final File file=temporaryFolder.resolve(""String_Node_Str"").toFile();
  file.createNewFile();
  final File zipped=temporaryFolder.resolve(""String_Node_Str"").toFile();
  try (FileOutputStream zipStream=new FileOutputStream(zipped)){
    ZipUtils.zip(file,zipStream);
    zipStream.close();
  }
   try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(zipped,output);
    output.close();
    verifyZipContent(output,""String_Node_Str"");
  }
 }","@Test public void shouldNotZipAlreadyZipped() throws Exception {
  final File file=temporaryFolder.resolve(SOME_FILE).toFile();
  file.createNewFile();
  final File zipped=temporaryFolder.resolve(""String_Node_Str"").toFile();
  try (FileOutputStream zipStream=new FileOutputStream(zipped)){
    ZipUtils.zip(file,zipStream);
    zipStream.close();
  }
   try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(zipped,output);
    output.close();
    verifyZipContent(output,SOME_FILE);
  }
 }",0.299047619047619
25168,"@Test public void shouldZipSingleFile() throws Exception {
  final File file=temporaryFolder.resolve(""String_Node_Str"").toFile();
  file.createNewFile();
  try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(file,output);
    output.close();
    verifyZipContent(output,""String_Node_Str"");
  }
 }","@Test public void shouldZipSingleFile() throws Exception {
  final File file=temporaryFolder.resolve(SOME_FILE).toFile();
  file.createNewFile();
  try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(file,output);
    output.close();
    verifyZipContent(output,SOME_FILE);
  }
 }",0.3564668769716088
25169,"@Test public void shouldZipDir() throws Exception {
  Path toZipDir=temporaryFolder.resolve(""String_Node_Str"");
  toZipDir.toFile().mkdirs();
  File toZipFile=toZipDir.resolve(""String_Node_Str"").toFile();
  toZipFile.getParentFile().mkdirs();
  toZipFile.createNewFile();
  try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(toZipDir.toFile(),output,true);
    output.close();
    verifyZipContent(output,""String_Node_Str"");
  }
 }","@Test public void shouldZipDir() throws Exception {
  Path toZipDir=temporaryFolder.resolve(""String_Node_Str"");
  toZipDir.toFile().mkdirs();
  File toZipFile=toZipDir.resolve(SOME_FILE_PATH).toFile();
  toZipFile.getParentFile().mkdirs();
  toZipFile.createNewFile();
  try (ByteArrayOutputStream output=new ByteArrayOutputStream()){
    ZipUtils.zip(toZipDir.toFile(),output,true);
    output.close();
    verifyZipContent(output,Paths.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",SOME_FILE).toString());
  }
 }",0.8996960486322189
25170,"@Test public void shouldSetUploadModeForAllParts() throws Exception {
  final DatasetManifest manifest=new DatasetManifest(""String_Node_Str"",""String_Node_Str"",asList(new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),1,null),new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),1,null)));
  manifest.setUploadMode(UploadMode.INCREMENTAL);
  assertThat(manifest.getParts().get(0).getUploadMode(),is(""String_Node_Str""));
  assertThat(manifest.getParts().get(1).getUploadMode(),is(""String_Node_Str""));
}","@Test public void shouldSetUploadModeForAllParts() throws Exception {
  final DatasetManifest manifest=new DatasetManifest(""String_Node_Str"",""String_Node_Str"",asList(new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),true,null),new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),true,null)));
  manifest.setUploadMode(UploadMode.INCREMENTAL);
  assertThat(manifest.getParts().get(0).getUploadMode(),is(""String_Node_Str""));
  assertThat(manifest.getParts().get(1).getUploadMode(),is(""String_Node_Str""));
}",0.987783595113438
25171,"@Test public void shouldSetMapping() throws Exception {
  final DatasetManifest manifest=new DatasetManifest(""String_Node_Str"",""String_Node_Str"",asList(new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),1,null),new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),1,null)));
  manifest.setMapping(""String_Node_Str"",""String_Node_Str"");
  manifest.setMapping(""String_Node_Str"",""String_Node_Str"");
  assertThat(manifest.getParts().get(0).getColumnName(),is(""String_Node_Str""));
  assertThat(manifest.getParts().get(1).getColumnName(),is(""String_Node_Str""));
}","@Test public void shouldSetMapping() throws Exception {
  final DatasetManifest manifest=new DatasetManifest(""String_Node_Str"",""String_Node_Str"",asList(new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),true,null),new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str""),true,null)));
  manifest.setMapping(""String_Node_Str"",""String_Node_Str"");
  manifest.setMapping(""String_Node_Str"",""String_Node_Str"");
  assertThat(manifest.getParts().get(0).getColumnName(),is(""String_Node_Str""));
  assertThat(manifest.getParts().get(1).getColumnName(),is(""String_Node_Str""));
}",0.9920508744038156
25172,"@Test(expectedExceptions=IllegalStateException.class) public void shouldFailOnMultiPopulates() throws Exception {
  final DatasetManifest manifest=new DatasetManifest(""String_Node_Str"",""String_Node_Str"",asList(new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str"",""String_Node_Str""),1,null)));
  manifest.setMapping(""String_Node_Str"",""String_Node_Str"");
}","@Test(expectedExceptions=IllegalStateException.class) public void shouldFailOnMultiPopulates() throws Exception {
  final DatasetManifest manifest=new DatasetManifest(""String_Node_Str"",""String_Node_Str"",asList(new DatasetManifest.Part(""String_Node_Str"",""String_Node_Str"",asList(""String_Node_Str"",""String_Node_Str""),true,null)));
  manifest.setMapping(""String_Node_Str"",""String_Node_Str"");
}",0.9935649935649936
25173,"@JsonCreator protected ErrorStructure(@JsonProperty(""String_Node_Str"") String errorClass,@JsonProperty(""String_Node_Str"") String component,@JsonProperty(""String_Node_Str"") String[] parameters,@JsonProperty(""String_Node_Str"") String message,@JsonProperty(""String_Node_Str"") String errorCode,@JsonProperty(""String_Node_Str"") String errorId,@JsonProperty(""String_Node_Str"") String trace,@JsonProperty(""String_Node_Str"") String requestId){
  this.errorClass=errorClass;
  this.component=component;
  this.parameters=parameters;
  this.message=notNull(message,""String_Node_Str"");
  this.errorCode=errorCode;
  this.errorId=errorId;
  this.trace=trace;
  this.requestId=requestId;
}","@JsonCreator protected ErrorStructure(@JsonProperty(""String_Node_Str"") String errorClass,@JsonProperty(""String_Node_Str"") String component,@JsonProperty(""String_Node_Str"") Object[] parameters,@JsonProperty(""String_Node_Str"") String message,@JsonProperty(""String_Node_Str"") String errorCode,@JsonProperty(""String_Node_Str"") String errorId,@JsonProperty(""String_Node_Str"") String trace,@JsonProperty(""String_Node_Str"") String requestId){
  this.errorClass=errorClass;
  this.component=component;
  this.parameters=parameters;
  this.message=notNull(message,""String_Node_Str"");
  this.errorCode=errorCode;
  this.errorId=errorId;
  this.trace=trace;
  this.requestId=requestId;
}",0.9911242603550297
25174,"public String[] getParameters(){
  return parameters == null ? null : copyOf(parameters,parameters.length);
}","public Object[] getParameters(){
  return parameters == null ? null : copyOf(parameters,parameters.length);
}",0.9541284403669724
25175,"@Test public void testDeserialization() throws Exception {
  final InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
  final ErrorStructure errStructure=new ObjectMapper().readValue(inputStream,ErrorStructure.class);
  assertThat(errStructure,is(notNullValue()));
  assertThat(errStructure.getErrorClass(),is(""String_Node_Str""));
  assertThat(errStructure.getTrace(),is(""String_Node_Str""));
  assertThat(errStructure.getMessage(),is(""String_Node_Str""));
  assertThat(errStructure.getComponent(),is(""String_Node_Str""));
  assertThat(errStructure.getErrorId(),is(""String_Node_Str""));
  assertThat(errStructure.getErrorCode(),is(""String_Node_Str""));
  assertThat(errStructure.getRequestId(),is(""String_Node_Str""));
  assertThat(errStructure.getParameters(),is(notNullValue()));
  assertThat(errStructure.getParameters().length,is(2));
  assertThat(errStructure.getParameters()[0],is(""String_Node_Str""));
  assertThat(errStructure.getParameters()[1],is(""String_Node_Str""));
}","@Test public void testDeserialization() throws Exception {
  final InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
  final ErrorStructure errStructure=new ObjectMapper().readValue(inputStream,ErrorStructure.class);
  assertThat(errStructure,is(notNullValue()));
  assertThat(errStructure.getErrorClass(),is(""String_Node_Str""));
  assertThat(errStructure.getTrace(),is(""String_Node_Str""));
  assertThat(errStructure.getMessage(),is(""String_Node_Str""));
  assertThat(errStructure.getComponent(),is(""String_Node_Str""));
  assertThat(errStructure.getErrorId(),is(""String_Node_Str""));
  assertThat(errStructure.getErrorCode(),is(""String_Node_Str""));
  assertThat(errStructure.getRequestId(),is(""String_Node_Str""));
  assertThat(errStructure.getParameters(),is(notNullValue()));
  assertThat(errStructure.getParameters().length,is(3));
  assertThat(errStructure.getParameters()[0].toString(),is(""String_Node_Str""));
  assertThat(errStructure.getParameters()[1].toString(),is(""String_Node_Str""));
  assertThat(errStructure.getParameters()[2].toString(),is(""String_Node_Str""));
  assertThat(errStructure.getFormattedMessage(),is(""String_Node_Str""));
}",0.9187442289935364
25176,"@Test public void testDeserialization() throws Exception {
  final InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
  final GdcError err=new ObjectMapper().readValue(inputStream,GdcError.class);
  assertThat(err,is(notNullValue()));
  assertThat(err.getErrorClass(),is(""String_Node_Str""));
  assertThat(err.getTrace(),is(""String_Node_Str""));
  assertThat(err.getMessage(),is(""String_Node_Str""));
  assertThat(err.getComponent(),is(""String_Node_Str""));
  assertThat(err.getErrorId(),is(""String_Node_Str""));
  assertThat(err.getErrorCode(),is(""String_Node_Str""));
  assertThat(err.getRequestId(),is(""String_Node_Str""));
  assertThat(err.getParameters(),is(notNullValue()));
  assertThat(err.getParameters().length,is(2));
  assertThat(err.getParameters()[0],is(""String_Node_Str""));
  assertThat(err.getParameters()[1],is(""String_Node_Str""));
}","@Test public void testDeserialization() throws Exception {
  final InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
  final GdcError err=new ObjectMapper().readValue(inputStream,GdcError.class);
  assertThat(err,is(notNullValue()));
  assertThat(err.getErrorClass(),is(""String_Node_Str""));
  assertThat(err.getTrace(),is(""String_Node_Str""));
  assertThat(err.getMessage(),is(""String_Node_Str""));
  assertThat(err.getComponent(),is(""String_Node_Str""));
  assertThat(err.getErrorId(),is(""String_Node_Str""));
  assertThat(err.getErrorCode(),is(""String_Node_Str""));
  assertThat(err.getRequestId(),is(""String_Node_Str""));
  assertThat(err.getParameters(),is(notNullValue()));
  assertThat(err.getParameters().length,is(2));
  assertThat(err.getParameters()[0].toString(),is(""String_Node_Str""));
  assertThat(err.getParameters()[1].toString(),is(""String_Node_Str""));
}",0.9874715261958996
25177,"/** 
 * This method compresses the input file to zip format. If the given file is a directory, it recursively packs the directory into the output.
 * @param file file to be zipped
 * @param output stream where the output will be written
 * @param includeRoot if root dir should be included
 */
public static void zip(File file,OutputStream output,boolean includeRoot) throws IOException {
  notNull(file,""String_Node_Str"");
  notNull(output,""String_Node_Str"");
  try (ZipOutputStream zos=new ZipOutputStream(output)){
    if (file.isDirectory()) {
      zipDir(includeRoot ? file.getParentFile().toPath() : file.toPath(),file,zos);
    }
 else {
      zipFile(file.getParentFile().toPath(),file,zos);
    }
  }
 }","/** 
 * This method compresses the input file to zip format. If the given file is a directory, it recursively packs the directory into the output.
 * @param file file to be zipped
 * @param output stream where the output will be written
 * @param includeRoot if root dir should be included
 * @throws IOException if zip creation fails
 */
public static void zip(File file,OutputStream output,boolean includeRoot) throws IOException {
  notNull(file,""String_Node_Str"");
  notNull(output,""String_Node_Str"");
  try (ZipOutputStream zos=new ZipOutputStream(output)){
    if (file.isDirectory()) {
      zipDir(includeRoot ? file.getParentFile().toPath() : file.toPath(),file,zos);
    }
 else {
      zipFile(file.getParentFile().toPath(),file,zos);
    }
  }
 }",0.8660774983004759
25178,"/** 
 * Get list of URIs of the given   {@link Obj}s
 * @param objs metadata objects
 * @return list of URIs
 */
@SafeVarargs protected static <T extends Obj>String[] uris(T... objs){
  noNullElements(objs,""String_Node_Str"");
  final String[] uris=new String[objs.length];
  for (int i=0; i < objs.length; i++) {
    uris[i]=objs[i].getUri();
  }
  return uris;
}","/** 
 * Get list of URIs of the given   {@link Obj}s
 * @param objs metadata objects
 * @param < T > Obj type
 * @return list of URIs
 */
@SafeVarargs protected static <T extends Obj>String[] uris(T... objs){
  noNullElements(objs,""String_Node_Str"");
  final String[] uris=new String[objs.length];
  for (int i=0; i < objs.length; i++) {
    uris[i]=objs[i].getUri();
  }
  return uris;
}",0.966711051930759
25179,"/** 
 * Returns desired target state of project model
 */
public String getTargetModel(){
  return targetModel;
}","/** 
 * Returns desired target state of project model
 * @return desired target state of project model
 */
public String getTargetModel(){
  return targetModel;
}",0.8218181818181818
25180,"/** 
 * Returns several variants of MAQL DDL evolution scripts that should be executed to update the source model to the target state. Individual variants differ in their side-effects (truncation of loaded data, drops of related objects...) <p/> Will be empty for empty diff.
 */
List<UpdateScript> getUpdateScripts(){
  return unmodifiableList(updateScripts);
}","/** 
 * Returns several variants of MAQL DDL evolution scripts that should be executed to update the source model to the target state. Individual variants differ in their side-effects (truncation of loaded data, drops of related objects...) <p> Will be empty for empty diff.
 */
List<UpdateScript> getUpdateScripts(){
  return unmodifiableList(updateScripts);
}",0.9986168741355465
25181,"/** 
 * Returns MAQL DDL update script that should be executed to update the source model to the target state. <p/> It picks the best possible variant by it's side-effects (truncation of loaded data, drops of related objects). It returns first present variant by order: <ol> <li>preserve data + no cascade drops</li> <li>no preserve data + no cascade drops</li> <li>preserve data + cascade drops</li> <li>no preserve data + cascade drops</li> </ol> <p/> Returned list will be empty if there are no differences.
 * @return MAQL DDL update scripts. Empty list if there are no differences.
 */
public List<String> getUpdateMaql(){
  if (updateScripts.isEmpty()) {
    return emptyList();
  }
  UpdateScript chosenScript;
  if ((chosenScript=getUpdateScriptByFlags(true,false)) != null) {
    return unmodifiableList(chosenScript.getMaqlChunks());
  }
  if ((chosenScript=getUpdateScriptByFlags(false,false)) != null) {
    return unmodifiableList(chosenScript.getMaqlChunks());
  }
  if ((chosenScript=getUpdateScriptByFlags(true,true)) != null) {
    return unmodifiableList(chosenScript.getMaqlChunks());
  }
  return unmodifiableList(updateScripts.get(0).getMaqlChunks());
}","/** 
 * Returns MAQL DDL update script that should be executed to update the source model to the target state. <p> It picks the best possible variant by it's side-effects (truncation of loaded data, drops of related objects). It returns first present variant by order: <ol> <li>preserve data + no cascade drops</li> <li>no preserve data + no cascade drops</li> <li>preserve data + cascade drops</li> <li>no preserve data + cascade drops</li> </ol> Returned list will be empty if there are no differences.
 * @return MAQL DDL update scripts. Empty list if there are no differences.
 */
public List<String> getUpdateMaql(){
  if (updateScripts.isEmpty()) {
    return emptyList();
  }
  UpdateScript chosenScript;
  if ((chosenScript=getUpdateScriptByFlags(true,false)) != null) {
    return unmodifiableList(chosenScript.getMaqlChunks());
  }
  if ((chosenScript=getUpdateScriptByFlags(false,false)) != null) {
    return unmodifiableList(chosenScript.getMaqlChunks());
  }
  if ((chosenScript=getUpdateScriptByFlags(true,true)) != null) {
    return unmodifiableList(chosenScript.getMaqlChunks());
  }
  return unmodifiableList(updateScripts.get(0).getMaqlChunks());
}",0.9974380871050385
25182,"public String[] getParameters(){
  return parameters;
}","public String[] getParameters(){
  return parameters == null ? null : copyOf(parameters,parameters.length);
}",0.6707317073170732
25183,"/** 
 * Restore session from previous instance of lens server.
 * @param sessionHandle the session handle
 * @param userName      the user name
 * @param password      the password
 * @throws LensException the lens exception
 */
void restoreSession(LensSessionHandle sessionHandle,String userName,String password) throws LensException ;","/** 
 * Restore session from previous instance of lens server.
 * @param sessionHandle the session handle
 * @param userName      the user name
 * @param password      the password
 * @throws LensException the lens exception
 */
void restoreSession(LensSessionHandle sessionHandle,String userName,String password,Map<String,String> configuration) throws LensException ;",0.9531914893617022
25184,"/** 
 * Restore session from previous instance of lens server.
 * @param sessionHandle the session handle
 * @param userName      the user name
 * @param password      the password
 * @throws LensException the lens exception
 */
public void restoreSession(LensSessionHandle sessionHandle,String userName,String password) throws LensException {
  HandleIdentifier handleIdentifier=new HandleIdentifier(sessionHandle.getPublicId(),sessionHandle.getSecretId());
  SessionHandle hiveSessionHandle=new SessionHandle(new TSessionHandle(handleIdentifier.toTHandleIdentifier()));
  try {
    cliService.createSessionWithSessionHandle(hiveSessionHandle,userName,password,new HashMap<String,String>());
    LensSessionHandle restoredSession=new LensSessionHandle(hiveSessionHandle.getHandleIdentifier().getPublicId(),hiveSessionHandle.getHandleIdentifier().getSecretId());
    SESSION_MAP.put(restoredSession.getPublicId().toString(),restoredSession);
    SessionUser sessionUser=SESSION_USER_INSTANCE_MAP.get(userName);
    if (sessionUser == null) {
      sessionUser=new SessionUser(userName);
      SESSION_USER_INSTANCE_MAP.put(userName,sessionUser);
    }
    updateSessionsPerUser(userName);
  }
 catch (  HiveSQLException e) {
    throw new LensException(""String_Node_Str"" + sessionHandle,e);
  }
}","/** 
 * Restore session from previous instance of lens server.
 * @param sessionHandle the session handle
 * @param userName      the user name
 * @param password      the password
 * @throws LensException the lens exception
 */
public void restoreSession(LensSessionHandle sessionHandle,String userName,String password,Map<String,String> configuration) throws LensException {
  HandleIdentifier handleIdentifier=new HandleIdentifier(sessionHandle.getPublicId(),sessionHandle.getSecretId());
  SessionHandle hiveSessionHandle=new SessionHandle(new TSessionHandle(handleIdentifier.toTHandleIdentifier()));
  try {
    cliService.createSessionWithSessionHandle(hiveSessionHandle,userName,password,new HashMap<>());
    LensSessionHandle restoredSession=new LensSessionHandle(hiveSessionHandle.getHandleIdentifier().getPublicId(),hiveSessionHandle.getHandleIdentifier().getSecretId());
    SESSION_MAP.put(restoredSession.getPublicId().toString(),restoredSession);
    String loggedinUser=userName;
    if (configuration != null) {
      loggedinUser=configuration.getOrDefault(LensConfConstants.SESSION_LOGGEDIN_USER,userName);
    }
    SessionUser sessionUser=SESSION_USER_INSTANCE_MAP.get(loggedinUser);
    if (sessionUser == null) {
      sessionUser=new SessionUser(loggedinUser);
      SESSION_USER_INSTANCE_MAP.put(loggedinUser,sessionUser);
    }
    updateSessionsPerUser(loggedinUser);
  }
 catch (  HiveSQLException e) {
    throw new LensException(""String_Node_Str"" + sessionHandle,e);
  }
}",0.8942101501072195
25185,"@Override public synchronized void start(){
  super.start();
  sessionExpiryThread=Executors.newSingleThreadScheduledExecutor(runnable -> new Thread(runnable,""String_Node_Str""));
  int sessionExpiryInterval=getSessionExpiryInterval();
  sessionExpiryThread.scheduleWithFixedDelay(sessionExpiryRunnable,sessionExpiryInterval,sessionExpiryInterval,TimeUnit.SECONDS);
  if (restorableSessions == null || restorableSessions.size() <= 0) {
    log.info(""String_Node_Str"");
    return;
  }
  for (  LensSessionImpl.LensSessionPersistInfo persistInfo : restorableSessions) {
    try {
      LensSessionHandle sessionHandle=persistInfo.getSessionHandle();
      restoreSession(sessionHandle,persistInfo.getUsername(),persistInfo.getPassword());
      LensSessionImpl session=getSession(sessionHandle);
      session.getLensSessionPersistInfo().setLastAccessTime(persistInfo.getLastAccessTime());
      session.getLensSessionPersistInfo().setConfig(persistInfo.getConfig());
      session.getLensSessionPersistInfo().setResources(persistInfo.getResources());
      session.setCurrentDatabase(persistInfo.getDatabase());
      session.getLensSessionPersistInfo().setMarkedForClose(persistInfo.isMarkedForClose());
      for (      LensSessionImpl.ResourceEntry resourceEntry : session.getResources()) {
        try {
          addResourceUponRestart(sessionHandle,resourceEntry);
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + session + ""String_Node_Str""+ resourceEntry,e);
        }
      }
      try {
        setSessionParametersOnRestore(sessionHandle,session.getConfig());
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + session.getConfig() + ""String_Node_Str""+ session,e);
      }
      log.info(""String_Node_Str"" + persistInfo.getSessionHandle().getPublicId());
      notifyEvent(new SessionRestored(System.currentTimeMillis(),sessionHandle));
    }
 catch (    LensException e) {
      throw new RuntimeException(e);
    }
  }
  log.info(""String_Node_Str"" + restorableSessions.size() + ""String_Node_Str"");
}","@Override public synchronized void start(){
  super.start();
  sessionExpiryThread=Executors.newSingleThreadScheduledExecutor(runnable -> new Thread(runnable,""String_Node_Str""));
  int sessionExpiryInterval=getSessionExpiryInterval();
  sessionExpiryThread.scheduleWithFixedDelay(sessionExpiryRunnable,sessionExpiryInterval,sessionExpiryInterval,TimeUnit.SECONDS);
  if (restorableSessions == null || restorableSessions.size() <= 0) {
    log.info(""String_Node_Str"");
    return;
  }
  for (  LensSessionImpl.LensSessionPersistInfo persistInfo : restorableSessions) {
    try {
      LensSessionHandle sessionHandle=persistInfo.getSessionHandle();
      restoreSession(sessionHandle,persistInfo.getUsername(),persistInfo.getPassword(),persistInfo.getConfig());
      LensSessionImpl session=getSession(sessionHandle);
      session.getLensSessionPersistInfo().setLastAccessTime(persistInfo.getLastAccessTime());
      session.getLensSessionPersistInfo().setConfig(persistInfo.getConfig());
      session.getLensSessionPersistInfo().setResources(persistInfo.getResources());
      session.setCurrentDatabase(persistInfo.getDatabase());
      session.getLensSessionPersistInfo().setMarkedForClose(persistInfo.isMarkedForClose());
      for (      LensSessionImpl.ResourceEntry resourceEntry : session.getResources()) {
        try {
          addResourceUponRestart(sessionHandle,resourceEntry);
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + session + ""String_Node_Str""+ resourceEntry,e);
        }
      }
      try {
        setSessionParametersOnRestore(sessionHandle,session.getConfig());
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + session.getConfig() + ""String_Node_Str""+ session,e);
      }
      log.info(""String_Node_Str"" + persistInfo.getSessionHandle().getPublicId());
      notifyEvent(new SessionRestored(System.currentTimeMillis(),sessionHandle));
    }
 catch (    LensException e) {
      throw new RuntimeException(e);
    }
  }
  log.info(""String_Node_Str"" + restorableSessions.size() + ""String_Node_Str"");
}",0.9942252165543792
25186,"private void replacePickedExpressions(DimHQLContext sc) throws LensException {
  QueryAST queryAST=sc.getQueryAst();
  replaceAST(cubeql,queryAST.getSelectAST());
  if (sc.getStorageCandidate() != null) {
    replaceAST(cubeql,sc.getQueryAst().getWhereAST());
  }
 else {
    replaceAST(cubeql,queryAST.getWhereAST());
  }
  replaceAST(cubeql,queryAST.getJoinAST());
  replaceAST(cubeql,queryAST.getGroupByAST());
  if (queryAST.getHavingAST() != null) {
    replaceAST(cubeql,queryAST.getHavingAST());
  }
 else {
    replaceAST(cubeql,cubeql.getHavingAST());
  }
  replaceAST(cubeql,queryAST.getOrderByAST());
}","private void replacePickedExpressions(DimHQLContext sc) throws LensException {
  QueryAST queryAST=sc.getQueryAst();
  replaceAST(cubeql,queryAST.getSelectAST());
  if (sc.getStorageCandidate() != null) {
    replaceAST(cubeql,sc.getQueryAst().getWhereAST());
  }
 else {
    replaceAST(cubeql,queryAST.getWhereAST());
  }
  replaceAST(cubeql,queryAST.getJoinAST());
  replaceAST(cubeql,queryAST.getGroupByAST());
  if (queryAST.getHavingAST() != null) {
    replaceAST(cubeql,queryAST.getHavingAST());
  }
 else   if (cubeql.getHavingAST() != null) {
    replaceAST(cubeql,cubeql.getHavingAST());
    queryAST.setHavingAST(MetastoreUtil.copyAST(cubeql.getHavingAST()));
  }
  replaceAST(cubeql,queryAST.getOrderByAST());
}",0.9176646706586826
25187,"private ASTNode processOrderbyExpression(ASTNode astNode) throws LensException {
  if (astNode == null) {
    return null;
  }
  ASTNode outerExpression=new ASTNode(astNode);
  for (  Node node : astNode.getChildren()) {
    ASTNode child=(ASTNode)node;
    ASTNode outerOrderby=new ASTNode(child);
    ASTNode tokNullsChild=(ASTNode)child.getChild(0);
    ASTNode outerTokNullsChild=new ASTNode(tokNullsChild);
    outerTokNullsChild.addChild(innerToOuterSelectASTs.get(new HQLParser.HashableASTNode((ASTNode)tokNullsChild)));
    outerOrderby.addChild(outerTokNullsChild);
    outerExpression.addChild(outerOrderby);
  }
  return outerExpression;
}","private ASTNode processOrderbyExpression(ASTNode astNode) throws LensException {
  if (astNode == null) {
    return null;
  }
  ASTNode outerExpression=new ASTNode(astNode);
  for (  Node node : astNode.getChildren()) {
    ASTNode child=(ASTNode)node;
    ASTNode outerOrderby=new ASTNode(child);
    ASTNode tokNullsChild=(ASTNode)child.getChild(0);
    ASTNode outerTokNullsChild=new ASTNode(tokNullsChild);
    if (((ASTNode)tokNullsChild.getChild(0)).getToken().getType() == HiveParser.DOT) {
      outerTokNullsChild.addChild(innerToOuterSelectASTs.get(new HQLParser.HashableASTNode((ASTNode)tokNullsChild)));
    }
 else {
      outerTokNullsChild.addChild(tokNullsChild);
    }
    outerOrderby.addChild(outerTokNullsChild);
    outerExpression.addChild(outerOrderby);
  }
  return outerExpression;
}",0.8910212474297464
25188,"/** 
 * Set having, order by and limit clauses to null for inner queries being constructed from StorageCandidate.
 */
private void updateAsts(){
  for (  StorageCandidateHQLContext sc : storageCandidates) {
    storageCandidateToSelectAstMap.put(sc.getStorageCandidate().toString(),new ASTNode(new CommonToken(TOK_SELECT,""String_Node_Str"")));
    sc.getQueryAst().setHavingAST(null);
    sc.getQueryAst().setOrderByAST(null);
    sc.getQueryAst().setLimitValue(null);
  }
}","/** 
 * Set having, order by and limit clauses to null for inner queries being constructed from StorageCandidate.
 */
private void updateAsts(){
  for (  StorageCandidateHQLContext sc : storageCandidates) {
    storageCandidateToSelectAstMap.put(sc.getStorageCandidate().toString(),new ASTNode(new CommonToken(TOK_SELECT,""String_Node_Str"")));
    if (sc.getQueryAst().getHavingAST() != null) {
      cubeql.setHavingAST(sc.getQueryAst().getHavingAST());
    }
    sc.getQueryAst().setHavingAST(null);
    sc.getQueryAst().setOrderByAST(null);
    sc.getQueryAst().setLimitValue(null);
  }
}",0.8805268109125117
25189,"private ASTNode getOuterAST(ASTNode astNode,ASTNode innerSelectAST,AliasDecider aliasDecider,StorageCandidate sc,boolean isSelectAst,Set<String> dimensionSet) throws LensException {
  if (astNode == null) {
    return null;
  }
  Set<String> msrCols=new HashSet<>();
  getAllColumnsOfNode(astNode,msrCols);
  msrCols.removeAll(dimensionSet);
  if (isAggregateAST(astNode) && sc.getColumns().containsAll(msrCols)) {
    return processAggregate(astNode,innerSelectAST,aliasDecider,isSelectAst);
  }
 else   if (isAggregateAST(astNode) && !sc.getColumns().containsAll(msrCols)) {
    ASTNode outerAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
    ASTNode exprCopy=MetastoreUtil.copyAST(astNode);
    setDefaultValueInExprForAggregateNodes(exprCopy,sc);
    outerAST.addChild(getOuterAST(getSelectExpr(exprCopy,null,true),innerSelectAST,aliasDecider,sc,isSelectAst,dimensionSet));
    return outerAST;
  }
 else {
    if (hasAggregate(astNode)) {
      ASTNode outerAST=new ASTNode(astNode);
      for (      Node child : astNode.getChildren()) {
        ASTNode childAST=(ASTNode)child;
        if (hasAggregate(childAST) && sc.getColumns().containsAll(msrCols)) {
          outerAST.addChild(getOuterAST(childAST,innerSelectAST,aliasDecider,sc,isSelectAst,dimensionSet));
        }
 else         if (hasAggregate(childAST) && !sc.getColumns().containsAll(msrCols)) {
          childAST.replaceChildren(1,1,getSelectExpr(null,null,true));
          outerAST.addChild(getOuterAST(childAST,innerSelectAST,aliasDecider,sc,isSelectAst,dimensionSet));
        }
 else {
          outerAST.addChild(childAST);
        }
      }
      return outerAST;
    }
 else {
      ASTNode innerSelectASTWithoutAlias=MetastoreUtil.copyAST(astNode);
      ASTNode innerSelectExprAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
      innerSelectExprAST.addChild(innerSelectASTWithoutAlias);
      String alias=aliasDecider.decideAlias(astNode);
      ASTNode aliasNode=new ASTNode(new CommonToken(Identifier,alias));
      innerSelectExprAST.addChild(aliasNode);
      innerSelectAST.addChild(innerSelectExprAST);
      if (astNode.getText().equals(DEFAULT_MEASURE)) {
        ASTNode outerAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
        outerAST.addChild(astNode);
        return outerAST;
      }
 else {
        ASTNode outerAST=getDotAST(cubeql.getCube().getName(),alias);
        (isSelectAst ? innerToOuterSelectASTs : innerToOuterHavingASTs).put(new HashableASTNode(innerSelectASTWithoutAlias),outerAST);
        return outerAST;
      }
    }
  }
}","private ASTNode getOuterAST(ASTNode astNode,ASTNode innerSelectAST,AliasDecider aliasDecider,StorageCandidate sc,boolean isSelectAst,Set<String> dimensionSet) throws LensException {
  if (astNode == null) {
    return null;
  }
  Set<String> msrCols=new HashSet<>();
  getAllColumnsOfNode(astNode,msrCols);
  msrCols.removeAll(dimensionSet);
  if (isAggregateAST(astNode) && sc.getColumns().containsAll(msrCols)) {
    return processAggregate(astNode,innerSelectAST,aliasDecider,isSelectAst);
  }
 else   if (isAggregateAST(astNode) && !sc.getColumns().containsAll(msrCols)) {
    ASTNode outerAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
    ASTNode exprCopy=MetastoreUtil.copyAST(astNode);
    setDefaultValueInExprForAggregateNodes(exprCopy,sc);
    outerAST.addChild(getOuterAST(getSelectExpr(exprCopy,null,true),innerSelectAST,aliasDecider,sc,isSelectAst,dimensionSet));
    return outerAST;
  }
 else {
    if (hasAggregate(astNode)) {
      ASTNode outerAST=new ASTNode(astNode);
      for (      Node child : astNode.getChildren()) {
        ASTNode childAST=(ASTNode)child;
        if (hasAggregate(childAST) && sc.getColumns().containsAll(msrCols)) {
          outerAST.addChild(getOuterAST(childAST,innerSelectAST,aliasDecider,sc,isSelectAst,dimensionSet));
        }
 else         if (hasAggregate(childAST) && !sc.getColumns().containsAll(msrCols)) {
          childAST.replaceChildren(1,1,getSelectExpr(null,null,true));
          outerAST.addChild(getOuterAST(childAST,innerSelectAST,aliasDecider,sc,isSelectAst,dimensionSet));
        }
 else {
          outerAST.addChild(childAST);
        }
      }
      return outerAST;
    }
 else {
      ASTNode innerSelectASTWithoutAlias=MetastoreUtil.copyAST(astNode);
      ASTNode innerSelectExprAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
      innerSelectExprAST.addChild(innerSelectASTWithoutAlias);
      String alias=aliasDecider.decideAlias(astNode);
      ASTNode aliasNode=new ASTNode(new CommonToken(Identifier,alias));
      innerSelectExprAST.addChild(aliasNode);
      innerSelectAST.addChild(innerSelectExprAST);
      if (astNode.getText().equals(DEFAULT_MEASURE)) {
        ASTNode outerAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
        outerAST.addChild(astNode);
        return outerAST;
      }
 else {
        ASTNode outerAST=getDotAST(cubeql.getCube().getName(),alias);
        HashableASTNode innerAST=new HashableASTNode(innerSelectASTWithoutAlias);
        if (isSelectAst && !innerToOuterSelectASTs.containsKey(innerAST)) {
          innerToOuterSelectASTs.put(innerAST,outerAST);
        }
 else         if (!isSelectAst && !innerToOuterHavingASTs.containsKey(innerAST)) {
          innerToOuterHavingASTs.put(innerAST,outerAST);
        }
        return outerAST;
      }
    }
  }
}",0.9192139737991266
25190,"private ASTNode processAggregate(ASTNode astNode,ASTNode innerSelectAST,AliasDecider aliasDecider,boolean isSelectAst){
  ASTNode innerSelectASTWithoutAlias=MetastoreUtil.copyAST(astNode);
  ASTNode innerSelectExprAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
  innerSelectExprAST.addChild(innerSelectASTWithoutAlias);
  String alias=aliasDecider.decideAlias(astNode);
  ASTNode aliasNode=new ASTNode(new CommonToken(Identifier,alias));
  innerSelectExprAST.addChild(aliasNode);
  innerSelectAST.addChild(innerSelectExprAST);
  ASTNode dotAST=getDotAST(cubeql.getCube().getName(),alias);
  ASTNode outerAST=new ASTNode(new CommonToken(TOK_FUNCTION,""String_Node_Str""));
  outerAST.addChild(new ASTNode(new CommonToken(Identifier,astNode.getChild(0).getText())));
  outerAST.addChild(dotAST);
  (isSelectAst ? innerToOuterSelectASTs : innerToOuterHavingASTs).put(new HashableASTNode(innerSelectASTWithoutAlias),outerAST);
  return outerAST;
}","private ASTNode processAggregate(ASTNode astNode,ASTNode innerSelectAST,AliasDecider aliasDecider,boolean isSelectAst){
  ASTNode innerSelectASTWithoutAlias=MetastoreUtil.copyAST(astNode);
  ASTNode innerSelectExprAST=new ASTNode(new CommonToken(HiveParser.TOK_SELEXPR,""String_Node_Str""));
  innerSelectExprAST.addChild(innerSelectASTWithoutAlias);
  String alias=aliasDecider.decideAlias(astNode);
  ASTNode aliasNode=new ASTNode(new CommonToken(Identifier,alias));
  innerSelectExprAST.addChild(aliasNode);
  innerSelectAST.addChild(innerSelectExprAST);
  ASTNode dotAST=getDotAST(cubeql.getCube().getName(),alias);
  ASTNode outerAST=new ASTNode(new CommonToken(TOK_FUNCTION,""String_Node_Str""));
  outerAST.addChild(new ASTNode(new CommonToken(Identifier,astNode.getChild(0).getText())));
  outerAST.addChild(dotAST);
  HashableASTNode innerAST=new HashableASTNode(innerSelectASTWithoutAlias);
  if (isSelectAst && !innerToOuterSelectASTs.containsKey(innerAST)) {
    innerToOuterSelectASTs.put(innerAST,outerAST);
  }
 else   if (!isSelectAst && !innerToOuterHavingASTs.containsKey(innerAST)) {
    innerToOuterHavingASTs.put(innerAST,outerAST);
  }
  return outerAST;
}",0.8283582089552238
25191,"@Override public String getTimeRangeWhereClause(CubeQueryContext cubeQueryContext,String tableName,Set<FactPartition> rangeParts) throws LensException {
  if (rangeParts.size() == 0) {
    return ""String_Node_Str"";
  }
  boolean useBetweenOnly=cubeQueryContext.getConf().getBoolean(CubeQueryConfUtil.BETWEEN_ONLY_TIME_RANGE_WRITER,CubeQueryConfUtil.DEFAULT_BETWEEN_ONLY_TIME_RANGE_WRITER);
  StringBuilder partStr=new StringBuilder();
  if (!useBetweenOnly && rangeParts.size() == 1) {
    partStr.append(""String_Node_Str"");
    String partFilter=TimeRangeUtils.getTimeRangePartitionFilter(rangeParts.iterator().next(),cubeQueryContext,tableName);
    partStr.append(partFilter);
    partStr.append(""String_Node_Str"");
  }
 else {
    TreeSet<FactPartition> parts=new TreeSet<>();
    FactPartition first=null;
    for (    FactPartition part : rangeParts) {
      if (part.hasContainingPart()) {
        throw new LensException(LensCubeErrorCode.CANNOT_USE_TIMERANGE_WRITER.getLensErrorInfo(),""String_Node_Str"");
      }
      if (first == null) {
        first=part;
      }
 else {
        if (!first.getPartCol().equalsIgnoreCase(part.getPartCol())) {
          throw new LensException(LensCubeErrorCode.CANNOT_USE_TIMERANGE_WRITER.getLensErrorInfo(),""String_Node_Str"");
        }
        if (!first.getPeriod().equals(part.getPeriod())) {
          throw new LensException(LensCubeErrorCode.CANNOT_USE_TIMERANGE_WRITER.getLensErrorInfo(),""String_Node_Str"");
        }
      }
      parts.add(part);
    }
    FactPartition start=parts.first();
    FactPartition end=parts.last();
    String partCol=start.getPartCol();
    if (cubeQueryContext != null && !cubeQueryContext.shouldReplaceTimeDimWithPart()) {
      partCol=cubeQueryContext.getTimeDimOfPartitionColumn(partCol);
    }
    partStr.append(""String_Node_Str"").append(tableName).append(""String_Node_Str"").append(partCol).append(""String_Node_Str"").append(start.getFormattedPartSpec()).append(""String_Node_Str"").append(end.getFormattedPartSpec()).append(""String_Node_Str"");
  }
  return partStr.toString();
}","@Override public String getTimeRangeWhereClause(CubeQueryContext cubeQueryContext,String tableName,Set<FactPartition> rangeParts) throws LensException {
  if (rangeParts.size() == 0) {
    return ""String_Node_Str"";
  }
  boolean useBetweenOnly=cubeQueryContext.getConf().getBoolean(CubeQueryConfUtil.BETWEEN_ONLY_TIME_RANGE_WRITER,CubeQueryConfUtil.DEFAULT_BETWEEN_ONLY_TIME_RANGE_WRITER);
  BoundType startBound=BoundType.valueOf(cubeQueryContext.getConf().get(CubeQueryConfUtil.START_DATE_BOUND_TYPE,CubeQueryConfUtil.DEFAULT_START_BOUND_TYPE));
  BoundType endBound=BoundType.valueOf(cubeQueryContext.getConf().get(CubeQueryConfUtil.END_DATE_BOUND_TYPE,CubeQueryConfUtil.DEFAULT_END_BOUND_TYPE));
  StringBuilder partStr=new StringBuilder();
  if (!useBetweenOnly && rangeParts.size() == 1) {
    partStr.append(""String_Node_Str"");
    String partFilter=TimeRangeUtils.getTimeRangePartitionFilter(rangeParts.iterator().next(),cubeQueryContext,tableName);
    partStr.append(partFilter);
    partStr.append(""String_Node_Str"");
  }
 else {
    TreeSet<FactPartition> parts=new TreeSet<>();
    FactPartition first=null;
    for (    FactPartition part : rangeParts) {
      if (part.hasContainingPart()) {
        throw new LensException(LensCubeErrorCode.CANNOT_USE_TIMERANGE_WRITER.getLensErrorInfo(),""String_Node_Str"");
      }
      if (first == null) {
        first=part;
      }
 else {
        if (!first.getPartCol().equalsIgnoreCase(part.getPartCol())) {
          throw new LensException(LensCubeErrorCode.CANNOT_USE_TIMERANGE_WRITER.getLensErrorInfo(),""String_Node_Str"");
        }
        if (!first.getPeriod().equals(part.getPeriod())) {
          throw new LensException(LensCubeErrorCode.CANNOT_USE_TIMERANGE_WRITER.getLensErrorInfo(),""String_Node_Str"");
        }
      }
      parts.add(part);
    }
    FactPartition start=parts.first();
    FactPartition end=parts.last();
    if (startBound.equals(BoundType.OPEN)) {
      start=start.previous();
    }
    if (endBound.equals(BoundType.OPEN)) {
      end=end.next();
    }
    String partCol=start.getPartCol();
    if (cubeQueryContext != null && !cubeQueryContext.shouldReplaceTimeDimWithPart()) {
      partCol=cubeQueryContext.getTimeDimOfPartitionColumn(partCol);
    }
    partStr.append(""String_Node_Str"").append(tableName).append(""String_Node_Str"").append(partCol).append(""String_Node_Str"").append(start.getFormattedPartSpec()).append(""String_Node_Str"").append(end.getFormattedPartSpec()).append(""String_Node_Str"");
  }
  return partStr.toString();
}",0.8996088657105606
25192,"/** 
 * Analyze internal.
 * @throws SemanticException the semantic exception
 */
public void analyzeInternal(Configuration conf,HiveConf hconf) throws SemanticException {
  CubeSemanticAnalyzer c1=new CubeSemanticAnalyzer(conf,hconf);
  QB qb=new QB(null,null,false);
  if (!c1.doPhase1(ast,qb,c1.initPhase1Ctx(),null)) {
    return;
  }
  if (!qb.getSubqAliases().isEmpty()) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new SemanticException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  TreeSet<String> ks=new TreeSet<String>(qb.getParseInfo().getClauseNames());
  String clauseName=ks.first();
  if (qb.getParseInfo().getJoinExpr() != null) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new SemanticException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  if (qb.getParseInfo().getWhrForClause(clauseName) != null) {
    this.whereAST=qb.getParseInfo().getWhrForClause(clauseName);
  }
  if (qb.getParseInfo().getHavingForClause(clauseName) != null) {
    this.havingAST=qb.getParseInfo().getHavingForClause(clauseName);
  }
  if (qb.getParseInfo().getOrderByForClause(clauseName) != null) {
    this.orderByAST=qb.getParseInfo().getOrderByForClause(clauseName);
  }
  if (qb.getParseInfo().getGroupByForClause(clauseName) != null) {
    this.groupByAST=qb.getParseInfo().getGroupByForClause(clauseName);
  }
  if (qb.getParseInfo().getSelForClause(clauseName) != null) {
    this.selectAST=qb.getParseInfo().getSelForClause(clauseName);
  }
  this.fromAST=HQLParser.findNodeByPath(ast,TOK_FROM);
}","/** 
 * Analyze internal.
 * @throws SemanticException the semantic exception
 */
public void analyzeInternal(Configuration conf,HiveConf hconf) throws SemanticException {
  CubeSemanticAnalyzer c1=new CubeSemanticAnalyzer(conf,hconf);
  QB qb=new QB(null,null,false);
  if (!c1.doPhase1(ast,qb,c1.initPhase1Ctx(),null)) {
    return;
  }
  if (!qb.getSubqAliases().isEmpty()) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new SemanticException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  TreeSet<String> ks=new TreeSet<String>(qb.getParseInfo().getClauseNames());
  String clauseName=ks.first();
  if (qb.getParseInfo().getJoinExpr() != null) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new SemanticException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  if (qb.getParseInfo().getWhrForClause(clauseName) != null) {
    this.whereAST=qb.getParseInfo().getWhrForClause(clauseName);
  }
  if (qb.getParseInfo().getGroupByForClause(clauseName) != null) {
    this.groupByAST=qb.getParseInfo().getGroupByForClause(clauseName);
  }
  if (qb.getParseInfo().getSelForClause(clauseName) != null) {
    this.selectAST=qb.getParseInfo().getSelForClause(clauseName);
  }
  if (qb.getParseInfo().getHavingForClause(clauseName) != null) {
    this.havingAST=qb.getParseInfo().getHavingForClause(clauseName);
  }
  if (qb.getParseInfo().getOrderByForClause(clauseName) != null) {
    this.orderByAST=qb.getParseInfo().getOrderByForClause(clauseName);
  }
  this.fromAST=HQLParser.findNodeByPath(ast,TOK_FROM);
}",0.8210191082802548
25193,"/** 
 * Builds the query.
 * @throws SemanticException
 */
public void buildDruidQuery(Configuration conf,HiveConf hconf) throws SemanticException, LensException {
  analyzeInternal(conf,hconf);
  if (resolveNativeTables) {
    replaceWithUnderlyingStorage(hconf);
  }
  String limit=getLimitClause(ast);
  ArrayList<String> filters=new ArrayList<>();
  getWhereString(whereAST,filters);
  constructQuery(HQLParser.getString(selectAST,HQLParser.AppendMode.DEFAULT),filters,HQLParser.getString(groupByAST,HQLParser.AppendMode.DEFAULT),HQLParser.getString(havingAST,HQLParser.AppendMode.DEFAULT),HQLParser.getString(orderByAST,HQLParser.AppendMode.DEFAULT),limit);
}","/** 
 * Builds the query.
 * @throws SemanticException
 */
public void buildDruidQuery(Configuration conf,HiveConf hconf) throws SemanticException, LensException {
  analyzeInternal(conf,hconf);
  if (resolveNativeTables) {
    replaceWithUnderlyingStorage(hconf);
  }
  String limit=getLimitClause(ast);
  ArrayList<String> filters=new ArrayList<>();
  getWhereString(whereAST,filters);
  String havingTree=null;
  String orderbyTree=null;
  if (isHavingSupported) {
    havingTree=HQLParser.getString(havingAST,HQLParser.AppendMode.DEFAULT);
  }
  if (isOrderBySupported) {
    orderbyTree=HQLParser.getString(orderByAST,HQLParser.AppendMode.DEFAULT);
  }
  constructQuery(HQLParser.getString(selectAST,HQLParser.AppendMode.DEFAULT),filters,HQLParser.getString(groupByAST,HQLParser.AppendMode.DEFAULT),havingTree,orderbyTree,limit);
}",0.8226666666666667
25194,"/** 
 * Construct final query using all trees
 * @param selecttree   the selecttree
 * @param whereFilters the wheretree
 * @param groupbytree  the groupbytree
 * @param havingtree   the havingtree
 * @param orderbytree  the orderbytree
 * @param limit        the limit
 */
private void constructQuery(String selecttree,ArrayList<String> whereFilters,String groupbytree,String havingtree,String orderbytree,String limit){
  log.info(""String_Node_Str"");
  rewrittenQuery.append(""String_Node_Str"").append(selecttree.replaceAll(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
  String factNameAndAlias=getFactNameAlias(fromAST);
  rewrittenQuery.append(factNameAndAlias);
  if (!whereFilters.isEmpty()) {
    rewrittenQuery.append(""String_Node_Str"").append(StringUtils.join(whereFilters,""String_Node_Str""));
  }
  if (StringUtils.isNotBlank(groupbytree)) {
    rewrittenQuery.append(""String_Node_Str"").append(groupbytree);
  }
  if (StringUtils.isNotBlank(havingtree)) {
    rewrittenQuery.append(""String_Node_Str"").append(havingtree);
  }
  if (StringUtils.isNotBlank(orderbytree)) {
    rewrittenQuery.append(""String_Node_Str"").append(orderbytree);
  }
  if (StringUtils.isNotBlank(limit)) {
    rewrittenQuery.append(""String_Node_Str"").append(limit);
  }
}","/** 
 * Construct final query using all trees
 * @param selectTree   the selecttree
 * @param whereFilters the wheretree
 * @param groupbyTree  the groupbytree
 * @param havingTree   the havingtree
 * @param orderbyTree  the orderbytree
 * @param limit        the limit
 */
private void constructQuery(String selectTree,ArrayList<String> whereFilters,String groupbyTree,String havingTree,String orderbyTree,String limit){
  log.info(""String_Node_Str"");
  rewrittenQuery.append(""String_Node_Str"").append(selectTree.replaceAll(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
  String factNameAndAlias=getFactNameAlias(fromAST);
  rewrittenQuery.append(factNameAndAlias);
  if (!whereFilters.isEmpty()) {
    rewrittenQuery.append(""String_Node_Str"").append(StringUtils.join(whereFilters,""String_Node_Str""));
  }
  if (StringUtils.isNotBlank(groupbyTree)) {
    rewrittenQuery.append(""String_Node_Str"").append(groupbyTree);
  }
  if (StringUtils.isNotBlank(havingTree)) {
    rewrittenQuery.append(""String_Node_Str"").append(havingTree);
  }
  if (StringUtils.isNotBlank(orderbyTree)) {
    rewrittenQuery.append(""String_Node_Str"").append(orderbyTree);
  }
  if (StringUtils.isNotBlank(limit)) {
    rewrittenQuery.append(""String_Node_Str"").append(limit);
  }
}",0.9882168106834248
25195,"public String rewrite(ASTNode currNode,Configuration conf,HiveConf metastoreConf,boolean resolveNativeTables) throws LensException {
  this.resolveNativeTables=resolveNativeTables;
  rewrittenQuery.setLength(0);
  reset();
  this.ast=currNode;
  ASTNode fromNode=HQLParser.findNodeByPath(currNode,TOK_FROM);
  if (fromNode != null) {
    if (fromNode.getChild(0).getType() == TOK_SUBQUERY) {
      log.warn(""String_Node_Str"",this,this.query);
      throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
    }
 else     if (isOfTypeJoin(fromNode.getChild(0).getType())) {
      log.warn(""String_Node_Str"",this,this.query);
      throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
    }
  }
  if (currNode.getToken().getType() == TOK_UNIONALL) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  String rewritternQueryText=rewrittenQuery.toString();
  if (currNode.getToken().getType() == TOK_QUERY) {
    try {
      buildDruidQuery(conf,metastoreConf);
      rewritternQueryText=rewrittenQuery.toString();
      log.info(""String_Node_Str"" + rewritternQueryText);
    }
 catch (    SemanticException e) {
      throw new LensException(e);
    }
  }
  return rewritternQueryText;
}","public String rewrite(ASTNode currNode,Configuration conf,HiveConf metastoreConf,boolean resolveNativeTables) throws LensException {
  this.resolveNativeTables=resolveNativeTables;
  rewrittenQuery.setLength(0);
  reset();
  this.ast=currNode;
  isHavingSupported=conf.getBoolean(JDBCDriverConfConstants.JDBC_IS_HAVING_SUPPORTED,JDBCDriverConfConstants.DEFAULT_JDBC_IS_HAVING_SUPPORTED);
  isOrderBySupported=conf.getBoolean(JDBCDriverConfConstants.JDBC_IS_ORDERBY_SUPPORTED,JDBCDriverConfConstants.DEFAULT_JDBC_IS_ORDERBY_SUPPORTED);
  ASTNode fromNode=HQLParser.findNodeByPath(currNode,TOK_FROM);
  if (fromNode != null) {
    if (fromNode.getChild(0).getType() == TOK_SUBQUERY) {
      log.warn(""String_Node_Str"",this,this.query);
      throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
    }
 else     if (isOfTypeJoin(fromNode.getChild(0).getType())) {
      log.warn(""String_Node_Str"",this,this.query);
      throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
    }
  }
  if (currNode.getToken().getType() == TOK_UNIONALL) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  if (!isHavingSupported && HQLParser.findNodeByPath(currNode,HiveParser.TOK_INSERT,HiveParser.TOK_HAVING) != null) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  if (!isOrderBySupported && HQLParser.findNodeByPath(currNode,HiveParser.TOK_INSERT,HiveParser.TOK_ORDERBY) != null) {
    log.warn(""String_Node_Str"",this,this.query);
    throw new LensException(""String_Node_Str"" + this + ""String_Node_Str""+ this.query);
  }
  String rewritternQueryText=rewrittenQuery.toString();
  if (currNode.getToken().getType() == TOK_QUERY) {
    try {
      buildDruidQuery(conf,metastoreConf);
      rewritternQueryText=rewrittenQuery.toString();
      log.info(""String_Node_Str"" + rewritternQueryText);
    }
 catch (    SemanticException e) {
      throw new LensException(e);
    }
  }
  return rewritternQueryText;
}",0.7670601785200115
25196,"/** 
 * Prepare statment on the database server
 * @param pContext query context
 * @param calledForEstimate set this to true if this call will use the estimate connection pool
 * @param checkConfigured set this to true if this call needs to check whether JDBC driver is configured
 * @param metricCallStack stack for metrics API
 * @return prepared statement
 * @throws LensException
 */
private PreparedStatement prepareInternal(AbstractQueryContext pContext,boolean calledForEstimate,boolean checkConfigured,String metricCallStack) throws LensException {
  if (checkConfigured) {
    if (pContext.getDriverQuery(this) == null) {
      throw new NullPointerException(""String_Node_Str"" + pContext.getUserQuery());
    }
    checkConfigured();
  }
  MethodMetricsContext sqlRewriteGauge=MethodMetricsFactory.createMethodGauge(pContext.getDriverConf(this),true,metricCallStack + COLUMNAR_SQL_REWRITE_GAUGE);
  String rewrittenQuery=rewriteQuery(pContext);
  sqlRewriteGauge.markSuccess();
  MethodMetricsContext jdbcPrepareGauge=MethodMetricsFactory.createMethodGauge(pContext.getDriverConf(this),true,metricCallStack + JDBC_PREPARE_GAUGE);
  PreparedStatement stmt=null;
  Connection conn=null;
  try {
    conn=calledForEstimate ? getEstimateConnection() : getConnection();
    stmt=conn.prepareStatement(rewrittenQuery);
    if (stmt.getWarnings() != null) {
      throw new LensException(stmt.getWarnings());
    }
  }
 catch (  SQLException sql) {
    handleJDBCSQLException(sql);
  }
 finally {
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException e) {
        log.error(""String_Node_Str"",rewrittenQuery,e);
      }
    }
    jdbcPrepareGauge.markSuccess();
  }
  log.info(""String_Node_Str"",rewrittenQuery);
  return stmt;
}","/** 
 * Prepare statment on the database server
 * @param pContext query context
 * @param calledForEstimate set this to true if this call will use the estimate connection pool
 * @param checkConfigured set this to true if this call needs to check whether JDBC driver is configured
 * @param metricCallStack stack for metrics API
 * @return prepared statement
 * @throws LensException
 */
private PreparedStatement prepareInternal(AbstractQueryContext pContext,boolean calledForEstimate,boolean checkConfigured,String metricCallStack) throws LensException {
  if (checkConfigured) {
    if (pContext.getDriverQuery(this) == null) {
      throw new NullPointerException(""String_Node_Str"" + pContext.getUserQuery());
    }
    checkConfigured();
  }
  MethodMetricsContext sqlRewriteGauge=MethodMetricsFactory.createMethodGauge(pContext.getDriverConf(this),true,metricCallStack + COLUMNAR_SQL_REWRITE_GAUGE);
  String rewrittenQuery=rewriteQuery(pContext);
  sqlRewriteGauge.markSuccess();
  MethodMetricsContext jdbcPrepareGauge=MethodMetricsFactory.createMethodGauge(pContext.getDriverConf(this),true,metricCallStack + JDBC_PREPARE_GAUGE);
  PreparedStatement stmt=null;
  Connection conn=null;
  try {
    conn=calledForEstimate ? getEstimateConnection() : getConnection();
    stmt=conn.prepareStatement(rewrittenQuery);
    if (!pContext.getDriverConf(this).getBoolean(JDBC_VALIDATE_SKIP_WARNINGS,DEFAULT_JDBC_VALIDATE_SKIP_WARNINGS) && stmt.getWarnings() != null) {
      throw new LensException(stmt.getWarnings());
    }
  }
 catch (  SQLException sql) {
    handleJDBCSQLException(sql);
  }
 finally {
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException e) {
        log.error(""String_Node_Str"",rewrittenQuery,e);
      }
    }
    jdbcPrepareGauge.markSuccess();
  }
  log.info(""String_Node_Str"",rewrittenQuery);
  return stmt;
}",0.9032081162599396
25197,"private ASTNode transform(CubeQueryContext cubeql,ASTNode parent,ASTNode node,int nodePos) throws LensException {
  if (node == null) {
    return node;
  }
  int nodeType=node.getToken().getType();
  if (!(HQLParser.isAggregateAST(node))) {
    if (nodeType == HiveParser.TOK_TABLE_OR_COL || nodeType == HiveParser.DOT) {
      ASTNode wrapped=wrapAggregate(cubeql,node);
      if (wrapped != node) {
        if (parent != null) {
          parent.setChild(nodePos,wrapped);
          ASTNode sibling=HQLParser.findNodeByPath(parent,Identifier);
          String expr;
          if (sibling != null) {
            expr=HQLParser.getString(parent);
          }
 else {
            expr=HQLParser.getString(wrapped);
          }
          cubeql.addAggregateExpr(expr.trim());
        }
 else {
          return wrapped;
        }
      }
    }
 else {
      for (int i=0; i < node.getChildCount(); i++) {
        transform(cubeql,node,(ASTNode)node.getChild(i),i);
      }
    }
  }
  return node;
}","private ASTNode transform(CubeQueryContext cubeql,ASTNode parent,ASTNode node,int nodePos) throws LensException {
  if (node == null) {
    return node;
  }
  int nodeType=node.getToken().getType();
  if (!(HQLParser.isAggregateAST(node))) {
    if (nodeType == HiveParser.TOK_TABLE_OR_COL || nodeType == HiveParser.DOT) {
      ASTNode wrapped=wrapAggregate(cubeql,node);
      if (wrapped != node) {
        if (parent != null) {
          parent.setChild(nodePos,wrapped);
        }
 else {
          return wrapped;
        }
      }
    }
 else {
      for (int i=0; i < node.getChildCount(); i++) {
        transform(cubeql,node,(ASTNode)node.getChild(i),i);
      }
    }
  }
  return node;
}",0.823321554770318
25198,"static void extractTabAliasForCol(CubeQueryContext cubeql,TrackQueriedColumns tqc) throws LensException {
  Map<String,String> colToTableAlias=cubeql.getColToTableAlias();
  Set<String> columns=tqc.getTblAliasToColumns().get(CubeQueryContext.DEFAULT_TABLE);
  if (columns == null) {
    return;
  }
  for (  String col : columns) {
    boolean inCube=false;
    if (cubeql.getCube() != null) {
      Set<String> cols=cubeql.getCube().getAllFieldNames();
      if (cols.contains(col.toLowerCase())) {
        String cubeAlias=cubeql.getAliasForTableName(cubeql.getCube().getName());
        colToTableAlias.put(col.toLowerCase(),cubeAlias);
        tqc.addColumnsQueried(cubeAlias,col.toLowerCase());
        inCube=true;
      }
    }
    for (    Dimension dim : cubeql.getDimensions()) {
      if (dim.getAllFieldNames().contains(col.toLowerCase())) {
        if (!inCube) {
          String prevDim=colToTableAlias.get(col.toLowerCase());
          if (prevDim != null && !prevDim.equals(dim.getName())) {
            throw new LensException(LensCubeErrorCode.AMBIGOUS_DIM_COLUMN.getLensErrorInfo(),col,prevDim,dim.getName());
          }
          String dimAlias=cubeql.getAliasForTableName(dim.getName());
          colToTableAlias.put(col.toLowerCase(),dimAlias);
          tqc.addColumnsQueried(dimAlias,col.toLowerCase());
        }
 else {
          throw new LensException(LensCubeErrorCode.AMBIGOUS_CUBE_COLUMN.getLensErrorInfo(),col,cubeql.getCube().getName(),dim.getName());
        }
      }
    }
    if (colToTableAlias.get(col.toLowerCase()) == null) {
      throw new LensException(LensCubeErrorCode.COLUMN_NOT_FOUND.getLensErrorInfo(),col);
    }
  }
}","static void extractTabAliasForCol(Map<String,String> colToTableAlias,TrackQueriedColumns tqc) throws LensException {
  Set<String> columns=tqc.getTblAliasToColumns().get(CubeQueryContext.DEFAULT_TABLE);
  if (columns == null) {
    return;
  }
  for (  String col : columns) {
    tqc.addColumnsQueried(colToTableAlias.get(col.toLowerCase()),col.toLowerCase());
    if (colToTableAlias.get(col.toLowerCase()) == null) {
      throw new LensException(LensCubeErrorCode.COLUMN_NOT_FOUND.getLensErrorInfo(),col);
    }
  }
}",0.3985408116735066
25199,"@Override public void rewriteContext(CubeQueryContext cubeql) throws LensException {
  Map<String,String> colToTableAlias=cubeql.getColToTableAlias();
  extractTabAliasForCol(cubeql);
  findDimAttributesAndMeasures(cubeql);
  if (colToTableAlias.isEmpty()) {
    return;
  }
  replaceAliases(cubeql.getSelectAST(),0,colToTableAlias);
  replaceAliases(cubeql.getHavingAST(),0,colToTableAlias);
  replaceAliases(cubeql.getOrderByAST(),0,colToTableAlias);
  replaceAliases(cubeql.getGroupByAST(),0,colToTableAlias);
  replaceAliases(cubeql.getWhereAST(),0,colToTableAlias);
  replaceAliases(cubeql.getJoinAST(),0,colToTableAlias);
  AggregateResolver.updateAggregates(cubeql.getSelectAST(),cubeql);
  AggregateResolver.updateAggregates(cubeql.getHavingAST(),cubeql);
  updateAliasMap(cubeql.getSelectAST(),cubeql);
}","@Override public void rewriteContext(CubeQueryContext cubeql) throws LensException {
  Map<String,String> colToTableAlias=cubeql.getColToTableAlias();
  extractTabAliasForCol(cubeql);
  for (  QueriedPhraseContext qur : cubeql.getQueriedPhrases()) {
    extractTabAliasForCol(colToTableAlias,qur);
  }
  findExpressionsAndMeasures(cubeql);
  if (colToTableAlias.isEmpty()) {
    return;
  }
  replaceAliases(cubeql.getSelectAST(),0,colToTableAlias);
  replaceAliases(cubeql.getHavingAST(),0,colToTableAlias);
  replaceAliases(cubeql.getOrderByAST(),0,colToTableAlias);
  replaceAliases(cubeql.getGroupByAST(),0,colToTableAlias);
  replaceAliases(cubeql.getWhereAST(),0,colToTableAlias);
  replaceAliases(cubeql.getJoinAST(),0,colToTableAlias);
}",0.7894736842105263
25200,"/** 
 * Update the ASTs to include only the fields queried from this fact, in all the expressions
 * @param cubeql
 * @throws LensException
 */
public void updateASTs(CubeQueryContext cubeql) throws LensException {
  int currentChild=0;
  for (int i=0; i < cubeql.getSelectAST().getChildCount(); i++) {
    ASTNode selectExpr=(ASTNode)this.selectAST.getChild(currentChild);
    Set<String> exprCols=HQLParser.getColsInExpr(cubeql.getAliasForTableName(cubeql.getCube()),selectExpr);
    if (getColumns().containsAll(exprCols)) {
      selectIndices.add(i);
      if (exprCols.isEmpty() || (!containsAny(cubeql.getCube().getMeasureNames(),exprCols))) {
        dimFieldIndices.add(i);
      }
      ASTNode aliasNode=HQLParser.findNodeByPath(selectExpr,Identifier);
      String alias=cubeql.getSelectAlias(i);
      if (aliasNode != null) {
        String queryAlias=aliasNode.getText();
        if (!queryAlias.equals(alias)) {
          ASTNode newAliasNode=new ASTNode(new CommonToken(HiveParser.Identifier,alias));
          this.selectAST.getChild(currentChild).replaceChildren(selectExpr.getChildCount() - 1,selectExpr.getChildCount() - 1,newAliasNode);
        }
      }
 else {
        ASTNode newAliasNode=new ASTNode(new CommonToken(HiveParser.Identifier,alias));
        this.selectAST.getChild(currentChild).addChild(newAliasNode);
      }
    }
 else {
      this.selectAST.deleteChild(currentChild);
      currentChild--;
    }
    currentChild++;
  }
}","/** 
 * Update the ASTs to include only the fields queried from this fact, in all the expressions
 * @param cubeql
 * @throws LensException
 */
public void updateASTs(CubeQueryContext cubeql) throws LensException {
  int currentChild=0;
  for (int i=0; i < cubeql.getSelectAST().getChildCount(); i++) {
    ASTNode selectExpr=(ASTNode)this.selectAST.getChild(currentChild);
    Set<String> exprCols=HQLParser.getColsInExpr(cubeql.getAliasForTableName(cubeql.getCube()),selectExpr);
    if (getColumns().containsAll(exprCols)) {
      selectIndices.add(i);
      if (exprCols.isEmpty() || (!containsAny(cubeql.getCube().getMeasureNames(),exprCols))) {
        dimFieldIndices.add(i);
      }
      ASTNode aliasNode=HQLParser.findNodeByPath(selectExpr,Identifier);
      String alias=cubeql.getSelectPhrases().get(i).getSelectAlias();
      if (aliasNode != null) {
        String queryAlias=aliasNode.getText();
        if (!queryAlias.equals(alias)) {
          ASTNode newAliasNode=new ASTNode(new CommonToken(HiveParser.Identifier,alias));
          this.selectAST.getChild(currentChild).replaceChildren(selectExpr.getChildCount() - 1,selectExpr.getChildCount() - 1,newAliasNode);
        }
      }
 else {
        ASTNode newAliasNode=new ASTNode(new CommonToken(HiveParser.Identifier,alias));
        this.selectAST.getChild(currentChild).addChild(newAliasNode);
      }
    }
 else {
      this.selectAST.deleteChild(currentChild);
      currentChild--;
    }
    currentChild++;
  }
}",0.9868109570510653
25201,"public static ASTNode parseExpr(String expr) throws LensException {
  ParseDriver driver=new ParseDriver();
  ASTNode tree;
  try {
    tree=driver.parseExpression(expr);
  }
 catch (  ParseException e) {
    throw new LensException(COULD_NOT_PARSE_EXPRESSION.getLensErrorInfo(),e,e.getMessage());
  }
  return ParseUtils.findRootNonNullToken(tree);
}","public static ASTNode parseExpr(String expr) throws LensException {
  ParseDriver driver=new ParseDriver();
  ASTNode tree;
  try {
    tree=driver.parseExpression(expr);
  }
 catch (  ParseException e) {
    throw new LensException(COULD_NOT_PARSE_EXPRESSION.getLensErrorInfo(),e,expr);
  }
  return ParseUtils.findRootNonNullToken(tree);
}",0.976878612716763
25202,"@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  if (!this.getServiceState().equals(STATE.STARTED)) {
    details.append(""String_Node_Str"");
    isHealthy=false;
  }
  if (getTotalFailedQueries() / (float)getTotalAcceptedQueries() > 0.3) {
    details.append(""String_Node_Str"");
    isHealthy=false;
  }
  if (!isHealthy) {
    log.error(details.toString());
  }
  return isHealthy ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,details.toString());
}","@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  if (!this.getServiceState().equals(STATE.STARTED)) {
    details.append(""String_Node_Str"");
    isHealthy=false;
  }
  if (!isHealthy) {
    log.error(details.toString());
  }
  return isHealthy ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,details.toString());
}",0.5819327731092437
25203,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  LensServerTestUtil.createTable(""String_Node_Str"",target(),RestAPITestUtil.openFooBarSession(target(),defaultMT),defaultMT);
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.5227272727272727
25204,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  cubeObjectFactory=new ObjectFactory();
  metastoreService=LensServices.get().getService(CubeMetastoreService.NAME);
  lensSessionId=metastoreService.openSession(""String_Node_Str"",""String_Node_Str"",new HashMap<String,String>());
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.375
25205,"@AfterTest public void tearDown() throws Exception {
  metastoreService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.7551020408163265
25206,"@AfterTest public void tearDown() throws Exception {
  LensServerTestUtil.dropTable(TestQueryService.TEST_TABLE,target(),lensSessionId,defaultMT);
  metastoreService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.5103448275862069
25207,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  metastoreService=LensServices.get().getService(CubeMetastoreService.NAME);
  lensSessionId=metastoreService.openSession(""String_Node_Str"",""String_Node_Str"",new HashMap<String,String>());
  methodMetricsMap=metricsSvc.getMethodMetricsFactory().getMethodMetricsMap();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2929936305732484
25208,"/** 
 * Setup.
 * @throws Exception the exception
 */
@BeforeTest public void setup() throws Exception {
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  service=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(service);
  log.info(""String_Node_Str"",service);
}","/** 
 * Setup.
 * @throws Exception the exception
 */
@BeforeClass public void setup() throws Exception {
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  service=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(service);
  log.info(""String_Node_Str"",service);
}",0.9886792452830188
25209,"@AfterTest public void tearDown() throws Exception {
  wiser.stop();
  dropTable(TEST_TABLE);
  queryService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.6351931330472103
25210,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  wiser=new Wiser();
  wiser.setHostname(""String_Node_Str"");
  wiser.setPort(25000);
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  Map<String,String> sessionconf=new HashMap<>();
  sessionconf.put(""String_Node_Str"",""String_Node_Str"");
  sessionconf.put(LensConfConstants.QUERY_MAIL_NOTIFY,""String_Node_Str"");
  sessionconf.put(LensConfConstants.QUERY_RESULT_EMAIL_CC,""String_Node_Str"");
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",sessionconf);
  createTable(TEST_TABLE);
  loadData(TEST_TABLE,TestResourceFile.TEST_DATA2_FILE.getValue());
  wiser.start();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.1820580474934037
25211,"@AfterTest public void cleanup() throws Exception {
  Path dir=new Path(conf.get(LensConfConstants.RESULT_SET_PARENT_DIR));
  FileSystem fs=dir.getFileSystem(conf);
  fs.delete(dir,true);
}","@AfterClass public void cleanup() throws Exception {
  Path dir=new Path(conf.get(LensConfConstants.RESULT_SET_PARENT_DIR));
  FileSystem fs=dir.getFileSystem(conf);
  fs.delete(dir,true);
}",0.9815303430079156
25212,"/** 
 * Test query result purger
 * @throws InterruptedException the interrupted exception
 * @throws IOException          Signals that an I/O exception has occurred.
 */
@BeforeTest public void setUp() throws IOException {
  String resultsetPath=""String_Node_Str"" + getClass().getSimpleName();
  conf=new Configuration();
  conf.set(LensConfConstants.RESULT_SET_PARENT_DIR,resultsetPath);
  conf.set(LensConfConstants.QUERY_HDFS_OUTPUT_PATH,""String_Node_Str"");
  conf.set(LensConfConstants.QUERY_RESULTSET_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.HDFS_OUTPUT_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.RESULTSET_PURGE_INTERVAL_IN_SECONDS,""String_Node_Str"");
  createTestFiles();
}","/** 
 * Test query result purger
 * @throws InterruptedException the interrupted exception
 * @throws IOException          Signals that an I/O exception has occurred.
 */
@BeforeClass public void setUp() throws IOException {
  String resultsetPath=""String_Node_Str"" + getClass().getSimpleName();
  conf=new Configuration();
  conf.set(LensConfConstants.RESULT_SET_PARENT_DIR,resultsetPath);
  conf.set(LensConfConstants.QUERY_HDFS_OUTPUT_PATH,""String_Node_Str"");
  conf.set(LensConfConstants.QUERY_RESULTSET_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.HDFS_OUTPUT_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.RESULTSET_PURGE_INTERVAL_IN_SECONDS,""String_Node_Str"");
  createTestFiles();
}",0.9937106918238994
25213,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  Map<String,String> sessionconf=new HashMap<>();
  sessionconf.put(""String_Node_Str"",""String_Node_Str"");
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",sessionconf);
  createTable(TEST_TABLE);
  loadData(TEST_TABLE,TestResourceFile.TEST_DATA2_FILE.getValue());
  createHSQLTableAndLoadData();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2296173044925124
25214,"@AfterTest public void tearDown() throws Exception {
  dropTable(TEST_TABLE);
  queryService.closeSession(lensSessionId);
  for (  LensDriver driver : queryService.getDrivers()) {
    if (driver instanceof HiveDriver) {
      assertFalse(((HiveDriver)driver).hasLensSession(lensSessionId));
    }
  }
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.3737373737373737
25215,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",new HashMap<String,String>());
  createTable(testTable,target(),lensSessionId,""String_Node_Str"",defaultMT);
  loadDataFromClasspath(testTable,TestResourceFile.TEST_DATA2_FILE.getValue(),target(),lensSessionId,defaultMT);
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2705882352941176
25216,"@AfterTest public void tearDown() throws Exception {
  dropTable(testTable,target(),lensSessionId,defaultMT);
  queryService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.5943775100401606
25217,"@AfterTest public void tearDown() throws Exception {
  super.tearDown();
  queryService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.6981132075471698
25218,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  savedQueryService=LensServices.get().getService(SavedQueryService.NAME);
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  Map<String,String> sessionconf=Maps.newHashMap();
  sessionconf.put(""String_Node_Str"",""String_Node_Str"");
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",sessionconf);
  SessionState.start(new HiveConf());
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2342954159592529
25219,"@BeforeTest public void setup() throws LensException {
  Configuration conf=new Configuration();
  conf.set(LensConfConstants.QUERY_PHASE1_REWRITERS,Rewriter1.class.getName() + ""String_Node_Str"" + Rewriter2.class.getName());
  rewriter=new UserQueryToCubeQueryRewriter(conf);
}","@BeforeClass public void setup() throws LensException {
  Configuration conf=new Configuration();
  conf.set(LensConfConstants.QUERY_PHASE1_REWRITERS,Rewriter1.class.getName() + ""String_Node_Str"" + Rewriter2.class.getName());
  rewriter=new UserQueryToCubeQueryRewriter(conf);
}",0.9837837837837838
25220,"@BeforeTest public void setUp(){
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  eventService=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(eventService);
  alarmService=LensServices.get().getService(AlarmService.NAME);
  assertNotNull(alarmService);
  eventService.addListenerForType(alarmEventListener,SchedulerAlarmEvent.class);
}","@BeforeClass public void setUp(){
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  eventService=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(eventService);
  alarmService=LensServices.get().getService(AlarmService.NAME);
  assertNotNull(alarmService);
  eventService.addListenerForType(alarmEventListener,SchedulerAlarmEvent.class);
}",0.9904963041182682
25221,"@BeforeTest public void setUp() throws Exception {
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  LensServices.get().getLogSegregationContext().setLogSegregationId(""String_Node_Str"");
  super.setUp();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.4742268041237113
25222,"@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  if (!this.getServiceState().equals(STATE.STARTED)) {
    details.append(""String_Node_Str"");
    isHealthy=false;
  }
  if (getTotalFailedQueries() / (float)getTotalAcceptedQueries() > 0.3) {
    details.append(""String_Node_Str"");
    isHealthy=false;
  }
  if (!isHealthy) {
    log.error(details.toString());
  }
  return isHealthy ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,details.toString());
}","@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  if (!this.getServiceState().equals(STATE.STARTED)) {
    details.append(""String_Node_Str"");
    isHealthy=false;
  }
  if (!isHealthy) {
    log.error(details.toString());
  }
  return isHealthy ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,details.toString());
}",0.5819327731092437
25223,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  LensServerTestUtil.createTable(""String_Node_Str"",target(),RestAPITestUtil.openFooBarSession(target(),defaultMT),defaultMT);
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.5227272727272727
25224,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  cubeObjectFactory=new ObjectFactory();
  metastoreService=LensServices.get().getService(CubeMetastoreService.NAME);
  lensSessionId=metastoreService.openSession(""String_Node_Str"",""String_Node_Str"",new HashMap<String,String>());
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.375
25225,"@AfterTest public void tearDown() throws Exception {
  metastoreService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.7551020408163265
25226,"@AfterTest public void tearDown() throws Exception {
  LensServerTestUtil.dropTable(TestQueryService.TEST_TABLE,target(),lensSessionId,defaultMT);
  metastoreService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.5103448275862069
25227,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  metastoreService=LensServices.get().getService(CubeMetastoreService.NAME);
  lensSessionId=metastoreService.openSession(""String_Node_Str"",""String_Node_Str"",new HashMap<String,String>());
  methodMetricsMap=metricsSvc.getMethodMetricsFactory().getMethodMetricsMap();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2929936305732484
25228,"/** 
 * Setup.
 * @throws Exception the exception
 */
@BeforeTest public void setup() throws Exception {
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  service=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(service);
  log.info(""String_Node_Str"",service);
}","/** 
 * Setup.
 * @throws Exception the exception
 */
@BeforeClass public void setup() throws Exception {
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  service=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(service);
  log.info(""String_Node_Str"",service);
}",0.9886792452830188
25229,"@AfterTest public void tearDown() throws Exception {
  wiser.stop();
  dropTable(TEST_TABLE);
  queryService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.6351931330472103
25230,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  wiser=new Wiser();
  wiser.setHostname(""String_Node_Str"");
  wiser.setPort(25000);
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  Map<String,String> sessionconf=new HashMap<>();
  sessionconf.put(""String_Node_Str"",""String_Node_Str"");
  sessionconf.put(LensConfConstants.QUERY_MAIL_NOTIFY,""String_Node_Str"");
  sessionconf.put(LensConfConstants.QUERY_RESULT_EMAIL_CC,""String_Node_Str"");
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",sessionconf);
  createTable(TEST_TABLE);
  loadData(TEST_TABLE,TestResourceFile.TEST_DATA2_FILE.getValue());
  wiser.start();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.1820580474934037
25231,"@AfterTest public void cleanup() throws Exception {
  Path dir=new Path(conf.get(LensConfConstants.RESULT_SET_PARENT_DIR));
  FileSystem fs=dir.getFileSystem(conf);
  fs.delete(dir,true);
}","@AfterClass public void cleanup() throws Exception {
  Path dir=new Path(conf.get(LensConfConstants.RESULT_SET_PARENT_DIR));
  FileSystem fs=dir.getFileSystem(conf);
  fs.delete(dir,true);
}",0.9815303430079156
25232,"/** 
 * Test query result purger
 * @throws InterruptedException the interrupted exception
 * @throws IOException          Signals that an I/O exception has occurred.
 */
@BeforeTest public void setUp() throws IOException {
  String resultsetPath=""String_Node_Str"" + getClass().getSimpleName();
  conf=new Configuration();
  conf.set(LensConfConstants.RESULT_SET_PARENT_DIR,resultsetPath);
  conf.set(LensConfConstants.QUERY_HDFS_OUTPUT_PATH,""String_Node_Str"");
  conf.set(LensConfConstants.QUERY_RESULTSET_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.HDFS_OUTPUT_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.RESULTSET_PURGE_INTERVAL_IN_SECONDS,""String_Node_Str"");
  createTestFiles();
}","/** 
 * Test query result purger
 * @throws InterruptedException the interrupted exception
 * @throws IOException          Signals that an I/O exception has occurred.
 */
@BeforeClass public void setUp() throws IOException {
  String resultsetPath=""String_Node_Str"" + getClass().getSimpleName();
  conf=new Configuration();
  conf.set(LensConfConstants.RESULT_SET_PARENT_DIR,resultsetPath);
  conf.set(LensConfConstants.QUERY_HDFS_OUTPUT_PATH,""String_Node_Str"");
  conf.set(LensConfConstants.QUERY_RESULTSET_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.HDFS_OUTPUT_RETENTION,""String_Node_Str"");
  conf.set(LensConfConstants.RESULTSET_PURGE_INTERVAL_IN_SECONDS,""String_Node_Str"");
  createTestFiles();
}",0.9937106918238994
25233,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  Map<String,String> sessionconf=new HashMap<>();
  sessionconf.put(""String_Node_Str"",""String_Node_Str"");
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",sessionconf);
  createTable(TEST_TABLE);
  loadData(TEST_TABLE,TestResourceFile.TEST_DATA2_FILE.getValue());
  createHSQLTableAndLoadData();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2296173044925124
25234,"@AfterTest public void tearDown() throws Exception {
  dropTable(TEST_TABLE);
  queryService.closeSession(lensSessionId);
  for (  LensDriver driver : queryService.getDrivers()) {
    if (driver instanceof HiveDriver) {
      assertFalse(((HiveDriver)driver).hasLensSession(lensSessionId));
    }
  }
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.3737373737373737
25235,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",new HashMap<String,String>());
  createTable(testTable,target(),lensSessionId,""String_Node_Str"",defaultMT);
  loadDataFromClasspath(testTable,TestResourceFile.TEST_DATA2_FILE.getValue(),target(),lensSessionId,defaultMT);
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2705882352941176
25236,"@AfterTest public void tearDown() throws Exception {
  dropTable(testTable,target(),lensSessionId,defaultMT);
  queryService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.5943775100401606
25237,"@AfterTest public void tearDown() throws Exception {
  super.tearDown();
  queryService.closeSession(lensSessionId);
  super.tearDown();
}","@AfterTest public void tearDown() throws Exception {
  super.tearDown();
}",0.6981132075471698
25238,"@BeforeTest public void setUp() throws Exception {
  super.setUp();
  savedQueryService=LensServices.get().getService(SavedQueryService.NAME);
  queryService=LensServices.get().getService(QueryExecutionService.NAME);
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  Map<String,String> sessionconf=Maps.newHashMap();
  sessionconf.put(""String_Node_Str"",""String_Node_Str"");
  lensSessionId=queryService.openSession(""String_Node_Str"",""String_Node_Str"",sessionconf);
  SessionState.start(new HiveConf());
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.2342954159592529
25239,"@BeforeTest public void setup() throws LensException {
  Configuration conf=new Configuration();
  conf.set(LensConfConstants.QUERY_PHASE1_REWRITERS,Rewriter1.class.getName() + ""String_Node_Str"" + Rewriter2.class.getName());
  rewriter=new UserQueryToCubeQueryRewriter(conf);
}","@BeforeClass public void setup() throws LensException {
  Configuration conf=new Configuration();
  conf.set(LensConfConstants.QUERY_PHASE1_REWRITERS,Rewriter1.class.getName() + ""String_Node_Str"" + Rewriter2.class.getName());
  rewriter=new UserQueryToCubeQueryRewriter(conf);
}",0.9837837837837838
25240,"@BeforeTest public void setUp(){
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  eventService=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(eventService);
  alarmService=LensServices.get().getService(AlarmService.NAME);
  assertNotNull(alarmService);
  eventService.addListenerForType(alarmEventListener,SchedulerAlarmEvent.class);
}","@BeforeClass public void setUp(){
  System.setProperty(LensConfConstants.CONFIG_LOCATION,""String_Node_Str"");
  LensServices.get().init(LensServerConf.getHiveConf());
  LensServices.get().start();
  eventService=LensServices.get().getService(LensEventService.NAME);
  assertNotNull(eventService);
  alarmService=LensServices.get().getService(AlarmService.NAME);
  assertNotNull(alarmService);
  eventService.addListenerForType(alarmEventListener,SchedulerAlarmEvent.class);
}",0.9904963041182682
25241,"@BeforeTest public void setUp() throws Exception {
  metricsSvc=LensServices.get().getService(MetricsService.NAME);
  LensServices.get().getLogSegregationContext().setLogSegregationId(""String_Node_Str"");
  super.setUp();
}","@BeforeTest public void setUp() throws Exception {
  super.setUp();
}",0.4742268041237113
25242,"@Override public void updateStatus(QueryContext context) throws LensException {
  log.debug(""String_Node_Str"",context.getQueryHandle());
  if (context.getDriverStatus().isFinished()) {
    return;
  }
  OperationHandle hiveHandle=getHiveHandle(context.getQueryHandle());
  ByteArrayInputStream in=null;
  try {
    log.debug(""String_Node_Str"",hiveHandle);
    fetchLogs(hiveHandle);
    OperationStatus opStatus=getClient().getOperationStatus(hiveHandle);
    log.debug(""String_Node_Str"",hiveHandle,opStatus.getState().name());
switch (opStatus.getState()) {
case CANCELED:
      context.getDriverStatus().setState(DriverQueryState.CANCELED);
    context.getDriverStatus().setStatusMessage(""String_Node_Str"");
  break;
case CLOSED:
context.getDriverStatus().setState(DriverQueryState.CLOSED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case ERROR:
context.getDriverStatus().setState(DriverQueryState.FAILED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setErrorMessage(""String_Node_Str"" + opStatus.getOperationException().getErrorCode() + ""String_Node_Str""+ opStatus.getOperationException().getMessage());
break;
case FINISHED:
context.getDriverStatus().setState(DriverQueryState.SUCCESSFUL);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setResultSetAvailable(hiveHandle.hasResultSet());
break;
case INITIALIZED:
context.getDriverStatus().setState(DriverQueryState.INITIALIZED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case RUNNING:
context.getDriverStatus().setState(DriverQueryState.RUNNING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case PENDING:
context.getDriverStatus().setState(DriverQueryState.PENDING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case UNKNOWN:
default :
throw new LensException(""String_Node_Str"");
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String errorMsg=null;
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskDisplay> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskDisplay>>(){
}
);
int completedTasks=0;
StringBuilder errorMessage=new StringBuilder();
for (TaskDisplay taskStat : taskStatuses) {
Task.TaskState tstate=taskStat.taskState;
if (tstate == Task.TaskState.FINISHED) {
completedTasks++;
}
if (taskStat.getErrorMsg() != null) {
appendTaskIds(errorMessage,taskStat);
errorMessage.append(""String_Node_Str"");
}
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
errorMsg=errorMessage.toString();
}
 else {
log.warn(""String_Node_Str"");
}
String error=null;
if (StringUtils.isNotBlank(errorMsg)) {
error=errorMsg;
}
 else if (opStatus.getState().equals(OperationState.ERROR)) {
error=context.getDriverStatus().getStatusMessage();
}
context.getDriverStatus().setErrorMessage(error);
context.getDriverStatus().setProgressMessage(jsonTaskStatus);
context.getDriverStatus().setProgress(progress);
context.getDriverStatus().setDriverStartTime(opStatus.getOperationStarted());
context.getDriverStatus().setDriverFinishTime(opStatus.getOperationCompleted());
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
handleHiveServerError(context,e);
throw new LensException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
log.error(""String_Node_Str"",e);
}
}
}
}","@Override public void updateStatus(QueryContext context) throws LensException {
  log.debug(""String_Node_Str"",context.getQueryHandle());
  if (context.getDriverStatus().isFinished()) {
    return;
  }
  OperationHandle hiveHandle=getHiveHandle(context.getQueryHandle());
  ByteArrayInputStream in=null;
  try {
    log.debug(""String_Node_Str"",hiveHandle);
    fetchLogs(hiveHandle);
    OperationStatus opStatus=getClient().getOperationStatus(hiveHandle);
    log.debug(""String_Node_Str"",hiveHandle,opStatus.getState().name());
switch (opStatus.getState()) {
case CANCELED:
      context.getDriverStatus().setState(DriverQueryState.CANCELED);
    context.getDriverStatus().setStatusMessage(""String_Node_Str"");
  break;
case CLOSED:
context.getDriverStatus().setState(DriverQueryState.CLOSED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case ERROR:
context.getDriverStatus().setState(DriverQueryState.FAILED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setErrorMessage(""String_Node_Str"" + opStatus.getOperationException().getErrorCode() + ""String_Node_Str""+ opStatus.getOperationException().getMessage());
break;
case FINISHED:
context.getDriverStatus().setState(DriverQueryState.SUCCESSFUL);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setResultSetAvailable(hiveHandle.hasResultSet());
break;
case INITIALIZED:
context.getDriverStatus().setState(DriverQueryState.INITIALIZED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case RUNNING:
context.getDriverStatus().setState(DriverQueryState.RUNNING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case PENDING:
context.getDriverStatus().setState(DriverQueryState.PENDING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case UNKNOWN:
default :
throw new LensException(""String_Node_Str"");
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String errorMsg=null;
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskDisplay> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskDisplay>>(){
}
);
int completedTasks=0;
StringBuilder errorMessage=new StringBuilder();
for (TaskDisplay taskStat : taskStatuses) {
Task.TaskState tstate=taskStat.taskState;
if (tstate == Task.TaskState.FINISHED) {
completedTasks++;
}
if ((taskStat.getReturnValue() != null && taskStat.getReturnValue() != 0) || taskStat.getErrorMsg() != null) {
appendTaskIds(errorMessage,taskStat);
errorMessage.append(""String_Node_Str"");
}
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
errorMsg=errorMessage.toString();
}
 else {
log.warn(""String_Node_Str"");
}
String error=null;
if (StringUtils.isNotBlank(errorMsg)) {
error=errorMsg;
}
 else if (opStatus.getState().equals(OperationState.ERROR)) {
error=context.getDriverStatus().getStatusMessage();
}
context.getDriverStatus().setErrorMessage(error);
context.getDriverStatus().setProgressMessage(jsonTaskStatus);
context.getDriverStatus().setProgress(progress);
context.getDriverStatus().setDriverStartTime(opStatus.getOperationStarted());
context.getDriverStatus().setDriverFinishTime(opStatus.getOperationCompleted());
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
handleHiveServerError(context,e);
throw new LensException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
log.error(""String_Node_Str"",e);
}
}
}
}",0.9899849087666348
25243,"@Override public void updateStatus(QueryContext context) throws LensException {
  log.debug(""String_Node_Str"",context.getQueryHandle());
  if (context.getDriverStatus().isFinished()) {
    return;
  }
  OperationHandle hiveHandle=getHiveHandle(context.getQueryHandle());
  ByteArrayInputStream in=null;
  try {
    log.debug(""String_Node_Str"",hiveHandle);
    fetchLogs(hiveHandle);
    OperationStatus opStatus=getClient().getOperationStatus(hiveHandle);
    log.debug(""String_Node_Str"",hiveHandle,opStatus.getState().name());
switch (opStatus.getState()) {
case CANCELED:
      context.getDriverStatus().setState(DriverQueryState.CANCELED);
    context.getDriverStatus().setStatusMessage(""String_Node_Str"");
  break;
case CLOSED:
context.getDriverStatus().setState(DriverQueryState.CLOSED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case ERROR:
context.getDriverStatus().setState(DriverQueryState.FAILED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setErrorMessage(""String_Node_Str"" + opStatus.getOperationException().getErrorCode() + ""String_Node_Str""+ opStatus.getOperationException().getMessage());
break;
case FINISHED:
context.getDriverStatus().setState(DriverQueryState.SUCCESSFUL);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setResultSetAvailable(hiveHandle.hasResultSet());
break;
case INITIALIZED:
context.getDriverStatus().setState(DriverQueryState.INITIALIZED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case RUNNING:
context.getDriverStatus().setState(DriverQueryState.RUNNING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case PENDING:
context.getDriverStatus().setState(DriverQueryState.PENDING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case UNKNOWN:
default :
throw new LensException(""String_Node_Str"");
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String errorMsg=null;
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskDisplay> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskDisplay>>(){
}
);
int completedTasks=0;
StringBuilder errorMessage=new StringBuilder();
for (TaskDisplay taskStat : taskStatuses) {
Task.TaskState tstate=taskStat.taskState;
if (tstate == Task.TaskState.FINISHED) {
completedTasks++;
}
if ((taskStat.getReturnValue() != null && taskStat.getReturnValue() != 0) || taskStat.getErrorMsg() != null) {
appendTaskIds(errorMessage,taskStat);
errorMessage.append(""String_Node_Str"");
}
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
errorMsg=errorMessage.toString();
}
 else {
log.warn(""String_Node_Str"");
}
String error=null;
if (StringUtils.isNotBlank(errorMsg)) {
error=errorMsg;
}
 else if (opStatus.getState().equals(OperationState.ERROR)) {
error=context.getDriverStatus().getStatusMessage();
}
context.getDriverStatus().setErrorMessage(error);
context.getDriverStatus().setProgressMessage(jsonTaskStatus);
context.getDriverStatus().setProgress(progress);
context.getDriverStatus().setDriverStartTime(opStatus.getOperationStarted());
context.getDriverStatus().setDriverFinishTime(opStatus.getOperationCompleted());
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
handleHiveServerError(context,e);
throw new LensException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
log.error(""String_Node_Str"",e);
}
}
}
}","@Override public void updateStatus(QueryContext context) throws LensException {
  log.debug(""String_Node_Str"",context.getQueryHandle());
  if (context.getDriverStatus().isFinished()) {
    return;
  }
  OperationHandle hiveHandle=getHiveHandle(context.getQueryHandle());
  ByteArrayInputStream in=null;
  try {
    log.debug(""String_Node_Str"",hiveHandle);
    fetchLogs(hiveHandle);
    OperationStatus opStatus=getClient().getOperationStatus(hiveHandle);
    log.debug(""String_Node_Str"",hiveHandle,opStatus.getState().name());
switch (opStatus.getState()) {
case CANCELED:
      context.getDriverStatus().setState(DriverQueryState.CANCELED);
    context.getDriverStatus().setStatusMessage(""String_Node_Str"");
  break;
case CLOSED:
context.getDriverStatus().setState(DriverQueryState.CLOSED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case ERROR:
context.getDriverStatus().setState(DriverQueryState.FAILED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setErrorMessage(""String_Node_Str"" + opStatus.getOperationException().getErrorCode() + ""String_Node_Str""+ opStatus.getOperationException().getMessage());
break;
case FINISHED:
context.getDriverStatus().setState(DriverQueryState.SUCCESSFUL);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
context.getDriverStatus().setResultSetAvailable(hiveHandle.hasResultSet());
break;
case INITIALIZED:
context.getDriverStatus().setState(DriverQueryState.INITIALIZED);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case RUNNING:
context.getDriverStatus().setState(DriverQueryState.RUNNING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case PENDING:
context.getDriverStatus().setState(DriverQueryState.PENDING);
context.getDriverStatus().setStatusMessage(""String_Node_Str"");
break;
case UNKNOWN:
default :
throw new LensException(""String_Node_Str"");
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String errorMsg=null;
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskDisplay> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskDisplay>>(){
}
);
int completedTasks=0;
StringBuilder errorMessage=new StringBuilder();
for (TaskDisplay taskStat : taskStatuses) {
Task.TaskState tstate=taskStat.taskState;
if (tstate == Task.TaskState.FINISHED) {
completedTasks++;
}
if ((taskStat.getReturnValue() != null && taskStat.getReturnValue() != 0) || taskStat.getErrorMsg() != null) {
appendTaskIds(errorMessage,taskStat);
errorMessage.append(""String_Node_Str"");
}
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
errorMsg=errorMessage.toString();
}
 else {
log.warn(""String_Node_Str"");
}
String error=null;
if (StringUtils.isNotBlank(errorMsg)) {
error=errorMsg;
}
 else if (opStatus.getState().equals(OperationState.ERROR)) {
error=context.getDriverStatus().getErrorMessage();
}
context.getDriverStatus().setErrorMessage(error);
context.getDriverStatus().setProgressMessage(jsonTaskStatus);
context.getDriverStatus().setProgress(progress);
context.getDriverStatus().setDriverStartTime(opStatus.getOperationStarted());
context.getDriverStatus().setDriverFinishTime(opStatus.getOperationCompleted());
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
handleHiveServerError(context,e);
throw new LensException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
log.error(""String_Node_Str"",e);
}
}
}
}",0.9985056378209484
25244,"private ASTNode wrapAggregate(CubeQueryContext cubeql,ASTNode node) throws LensException {
  String tabname=null;
  String colname;
  if (node.getToken().getType() == HiveParser.TOK_TABLE_OR_COL) {
    colname=node.getChild(0).getText();
  }
 else {
    ASTNode tabident=HQLParser.findNodeByPath(node,TOK_TABLE_OR_COL,Identifier);
    ASTNode colIdent=(ASTNode)node.getChild(1);
    colname=colIdent.getText();
    tabname=tabident.getText();
  }
  String msrname=StringUtils.isBlank(tabname) ? colname : tabname + ""String_Node_Str"" + colname;
  if (cubeql.isCubeMeasure(msrname)) {
    if (cubeql.getQueriedExprs().contains(colname)) {
      String alias=cubeql.getAliasForTableName(cubeql.getCube().getName());
      for (      ASTNode exprNode : cubeql.getExprCtx().getExpressionContext(colname,alias).getAllASTNodes()) {
        transform(cubeql,null,exprNode,0);
      }
      return node;
    }
 else {
      CubeMeasure measure=cubeql.getCube().getMeasureByName(colname);
      String aggregateFn=measure.getAggregate();
      if (StringUtils.isBlank(aggregateFn)) {
        throw new LensException(LensCubeErrorCode.NO_DEFAULT_AGGREGATE.getLensErrorInfo(),colname);
      }
      ASTNode fnroot=new ASTNode(new CommonToken(HiveParser.TOK_FUNCTION));
      ASTNode fnIdentNode=new ASTNode(new CommonToken(HiveParser.Identifier,aggregateFn));
      fnroot.addChild(fnIdentNode);
      fnroot.addChild(node);
      return fnroot;
    }
  }
 else {
    return node;
  }
}","private ASTNode wrapAggregate(CubeQueryContext cubeql,ASTNode node) throws LensException {
  String tabname=null;
  String colname;
  if (node.getToken().getType() == HiveParser.TOK_TABLE_OR_COL) {
    colname=node.getChild(0).getText();
  }
 else {
    ASTNode tabident=HQLParser.findNodeByPath(node,TOK_TABLE_OR_COL,Identifier);
    ASTNode colIdent=(ASTNode)node.getChild(1);
    colname=colIdent.getText().toLowerCase();
    tabname=tabident.getText().toLowerCase();
  }
  String msrname=StringUtils.isBlank(tabname) ? colname : tabname + ""String_Node_Str"" + colname;
  if (cubeql.isCubeMeasure(msrname)) {
    if (cubeql.getQueriedExprs().contains(colname)) {
      String alias=cubeql.getAliasForTableName(cubeql.getCube().getName());
      for (      ASTNode exprNode : cubeql.getExprCtx().getExpressionContext(colname,alias).getAllASTNodes()) {
        transform(cubeql,null,exprNode,0);
      }
      return node;
    }
 else {
      CubeMeasure measure=cubeql.getCube().getMeasureByName(colname);
      String aggregateFn=measure.getAggregate();
      if (StringUtils.isBlank(aggregateFn)) {
        throw new LensException(LensCubeErrorCode.NO_DEFAULT_AGGREGATE.getLensErrorInfo(),colname);
      }
      ASTNode fnroot=new ASTNode(new CommonToken(HiveParser.TOK_FUNCTION));
      ASTNode fnIdentNode=new ASTNode(new CommonToken(HiveParser.Identifier,aggregateFn));
      fnroot.addChild(fnIdentNode);
      fnroot.addChild(node);
      return fnroot;
    }
  }
 else {
    return node;
  }
}",0.9905977165883144
25245,"private void extractColumns(CubeQueryContext cubeql) throws LensException {
  ASTNode selTree=cubeql.getSelectAST();
  if (selTree.getChildCount() == 1) {
    ASTNode star=HQLParser.findNodeByPath(selTree,TOK_SELEXPR,TOK_ALLCOLREF);
    if (star == null) {
      star=HQLParser.findNodeByPath(selTree,TOK_SELEXPR,TOK_FUNCTIONSTAR);
    }
    if (star != null) {
      int starType=star.getToken().getType();
      if (TOK_FUNCTIONSTAR == starType || TOK_ALLCOLREF == starType) {
        throw new LensException(LensCubeErrorCode.ALL_COLUMNS_NOT_SUPPORTED.getLensErrorInfo());
      }
    }
  }
  getColsForSelectTree(cubeql);
  getColsForWhereTree(cubeql);
  getColsForTree(cubeql,cubeql.getJoinAST(),cubeql);
  getColsForTree(cubeql,cubeql.getGroupByAST(),cubeql);
  getColsForTree(cubeql,cubeql.getHavingAST(),cubeql);
  getColsForTree(cubeql,cubeql.getOrderByAST(),cubeql);
  for (  String table : cubeql.getTblAliasToColumns().keySet()) {
    if (!CubeQueryContext.DEFAULT_TABLE.equalsIgnoreCase(table)) {
      if (!cubeql.addQueriedTable(table)) {
        throw new LensException(LensCubeErrorCode.NEITHER_CUBE_NOR_DIMENSION.getLensErrorInfo());
      }
    }
  }
}","private void extractColumns(CubeQueryContext cubeql) throws LensException {
  ASTNode selTree=cubeql.getSelectAST();
  if (selTree.getChildCount() == 1) {
    ASTNode star=HQLParser.findNodeByPath(selTree,TOK_SELEXPR,TOK_ALLCOLREF);
    if (star == null) {
      star=HQLParser.findNodeByPath(selTree,TOK_SELEXPR,TOK_FUNCTIONSTAR);
    }
    if (star != null) {
      int starType=star.getToken().getType();
      if (TOK_FUNCTIONSTAR == starType || TOK_ALLCOLREF == starType) {
        throw new LensException(LensCubeErrorCode.ALL_COLUMNS_NOT_SUPPORTED.getLensErrorInfo());
      }
    }
  }
  getColsForSelectTree(cubeql);
  getColsForWhereTree(cubeql);
  getColsForTree(cubeql,cubeql.getJoinAST(),cubeql,true);
  getColsForTree(cubeql,cubeql.getGroupByAST(),cubeql,true);
  getColsForTree(cubeql,cubeql.getHavingAST(),cubeql,true);
  getColsForTree(cubeql,cubeql.getOrderByAST(),cubeql,true);
  for (  String table : cubeql.getTblAliasToColumns().keySet()) {
    if (!CubeQueryContext.DEFAULT_TABLE.equalsIgnoreCase(table)) {
      if (!cubeql.addQueriedTable(table)) {
        throw new LensException(LensCubeErrorCode.NEITHER_CUBE_NOR_DIMENSION.getLensErrorInfo());
      }
    }
  }
}",0.991532599491956
25246,"@Override public void visit(TreeNode visited){
  ASTNode node=visited.getNode();
  ASTNode parent=null;
  if (visited.getParent() != null) {
    parent=visited.getParent().getNode();
  }
  if (node.getToken().getType() == TOK_TABLE_OR_COL && (parent != null && parent.getToken().getType() != DOT)) {
    ASTNode ident=(ASTNode)node.getChild(0);
    String column=ident.getText().toLowerCase();
    if (cubeql.getExprToAliasMap().values().contains(column)) {
      return;
    }
    tqc.addColumnsQueried(CubeQueryContext.DEFAULT_TABLE,column);
  }
 else   if (node.getToken().getType() == DOT) {
    ASTNode tabident=HQLParser.findNodeByPath(node,TOK_TABLE_OR_COL,Identifier);
    ASTNode colIdent=(ASTNode)node.getChild(1);
    String column=colIdent.getText().toLowerCase();
    String table=tabident.getText().toLowerCase();
    tqc.addColumnsQueried(table,column);
  }
}","@Override public void visit(TreeNode visited){
  ASTNode node=visited.getNode();
  ASTNode parent=null;
  if (visited.getParent() != null) {
    parent=visited.getParent().getNode();
  }
  if (node.getToken().getType() == TOK_TABLE_OR_COL && (parent != null && parent.getToken().getType() != DOT)) {
    ASTNode ident=(ASTNode)node.getChild(0);
    String column=ident.getText().toLowerCase();
    if (skipAliases && cubeql.getExprToAliasMap().values().contains(column)) {
      return;
    }
    tqc.addColumnsQueried(CubeQueryContext.DEFAULT_TABLE,column);
  }
 else   if (node.getToken().getType() == DOT) {
    ASTNode tabident=HQLParser.findNodeByPath(node,TOK_TABLE_OR_COL,Identifier);
    ASTNode colIdent=(ASTNode)node.getChild(1);
    String column=colIdent.getText().toLowerCase();
    String table=tabident.getText().toLowerCase();
    tqc.addColumnsQueried(table,column);
  }
}",0.99149177538287
25247,"private void getColsForSelectTree(final CubeQueryContext cubeql) throws LensException {
  int exprInd=1;
  for (int i=0; i < cubeql.getSelectAST().getChildCount(); i++) {
    ASTNode selectExpr=(ASTNode)cubeql.getSelectAST().getChild(i);
    Set<String> cols=new HashSet<String>();
    addColumnsForSelectExpr(cubeql,selectExpr,cubeql.getSelectAST(),cols);
    ASTNode alias=HQLParser.findNodeByPath(selectExpr,Identifier);
    String selectAlias;
    String selectFinalAlias=null;
    if (alias != null) {
      cubeql.addExprToAlias(selectExpr,alias);
      if (HQLParser.hasSpaces(alias.getText())) {
        selectFinalAlias=alias.getText();
        selectAlias=SELECT_ALIAS_PREFIX + exprInd;
      }
 else {
        selectAlias=alias.getText().trim();
      }
    }
 else     if (cols.size() == 1) {
      selectAlias=cols.iterator().next().toLowerCase();
    }
 else {
      selectAlias=SELECT_ALIAS_PREFIX + exprInd;
    }
    exprInd++;
    cubeql.addSelectAlias(selectAlias,selectFinalAlias);
  }
}","private void getColsForSelectTree(final CubeQueryContext cubeql) throws LensException {
  int exprInd=1;
  for (int i=0; i < cubeql.getSelectAST().getChildCount(); i++) {
    ASTNode selectExpr=(ASTNode)cubeql.getSelectAST().getChild(i);
    ASTNode selectExprChild=(ASTNode)selectExpr.getChild(0);
    Set<String> cols=new HashSet<>();
    addColumnsForSelectExpr(cubeql,selectExpr,cubeql.getSelectAST(),cols);
    ASTNode alias=HQLParser.findNodeByPath(selectExpr,Identifier);
    String selectAlias;
    String selectFinalAlias=null;
    if (alias != null) {
      cubeql.addExprToAlias(selectExpr,alias);
      selectFinalAlias=alias.getText();
      selectAlias=SELECT_ALIAS_PREFIX + exprInd;
    }
 else     if (cols.size() == 1 && (selectExprChild.getToken().getType() == TOK_TABLE_OR_COL || selectExprChild.getToken().getType() == DOT)) {
      selectAlias=cols.iterator().next().toLowerCase();
    }
 else {
      selectAlias=SELECT_ALIAS_PREFIX + exprInd;
      selectFinalAlias=HQLParser.getString(selectExprChild);
    }
    exprInd++;
    cubeql.addSelectAlias(selectAlias,selectFinalAlias);
  }
}",0.6178554558337269
25248,"static void getColsForTree(final CubeQueryContext cubeql,ASTNode tree,final TrackQueriedColumns tqc) throws LensException {
  if (tree == null) {
    return;
  }
  HQLParser.bft(tree,new ASTNodeVisitor(){
    @Override public void visit(    TreeNode visited){
      ASTNode node=visited.getNode();
      ASTNode parent=null;
      if (visited.getParent() != null) {
        parent=visited.getParent().getNode();
      }
      if (node.getToken().getType() == TOK_TABLE_OR_COL && (parent != null && parent.getToken().getType() != DOT)) {
        ASTNode ident=(ASTNode)node.getChild(0);
        String column=ident.getText().toLowerCase();
        if (cubeql.getExprToAliasMap().values().contains(column)) {
          return;
        }
        tqc.addColumnsQueried(CubeQueryContext.DEFAULT_TABLE,column);
      }
 else       if (node.getToken().getType() == DOT) {
        ASTNode tabident=HQLParser.findNodeByPath(node,TOK_TABLE_OR_COL,Identifier);
        ASTNode colIdent=(ASTNode)node.getChild(1);
        String column=colIdent.getText().toLowerCase();
        String table=tabident.getText().toLowerCase();
        tqc.addColumnsQueried(table,column);
      }
    }
  }
);
}","static void getColsForTree(final CubeQueryContext cubeql,ASTNode tree,final TrackQueriedColumns tqc,final boolean skipAliases) throws LensException {
  if (tree == null) {
    return;
  }
  HQLParser.bft(tree,new ASTNodeVisitor(){
    @Override public void visit(    TreeNode visited){
      ASTNode node=visited.getNode();
      ASTNode parent=null;
      if (visited.getParent() != null) {
        parent=visited.getParent().getNode();
      }
      if (node.getToken().getType() == TOK_TABLE_OR_COL && (parent != null && parent.getToken().getType() != DOT)) {
        ASTNode ident=(ASTNode)node.getChild(0);
        String column=ident.getText().toLowerCase();
        if (skipAliases && cubeql.getExprToAliasMap().values().contains(column)) {
          return;
        }
        tqc.addColumnsQueried(CubeQueryContext.DEFAULT_TABLE,column);
      }
 else       if (node.getToken().getType() == DOT) {
        ASTNode tabident=HQLParser.findNodeByPath(node,TOK_TABLE_OR_COL,Identifier);
        ASTNode colIdent=(ASTNode)node.getChild(1);
        String column=colIdent.getText().toLowerCase();
        String table=tabident.getText().toLowerCase();
        tqc.addColumnsQueried(table,column);
      }
    }
  }
);
}",0.982923781757601
25249,"void resolveColumns(CubeQueryContext cubeql) throws LensException {
  ColumnResolver.getColsForTree(cubeql,finalAST,this);
}","void resolveColumns(CubeQueryContext cubeql) throws LensException {
  ColumnResolver.getColsForTree(cubeql,finalAST,this,false);
}",0.9763779527559056
25250,"private void createBaseAndDerivedCubes(CubeMetastoreClient client) throws HiveException, ParseException, LensException {
  Set<CubeMeasure> cubeMeasures2=new HashSet<>(cubeMeasures);
  Set<CubeDimAttribute> cubeDimensions2=new HashSet<>(cubeDimensions);
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",null,""String_Node_Str"",""String_Node_Str""));
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",null,""String_Node_Str"",null));
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",null,""String_Node_Str"",null));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  Map<String,String> cubeProperties=new HashMap<>();
  cubeProperties.put(MetastoreUtil.getCubeTimedDimensionListKey(BASE_CUBE_NAME),""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_RELATION + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_RELATION + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.CUBE_ALL_FIELDS_QUERIABLE,""String_Node_Str"");
  Map<String,JoinChain> joinChainMap=new HashMap<>();
  addCubeChains(joinChainMap,""String_Node_Str"");
  joinChainMap.get(""String_Node_Str"").addPath(new ArrayList<TableReference>(){
{
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
  joinChainMap.get(""String_Node_Str"").addPath(new ArrayList<TableReference>(){
{
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
  joinChainMap.get(""String_Node_Str"").addPath(new ArrayList<TableReference>(){
{
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
  Set<JoinChain> joinChains=Sets.newHashSet(joinChainMap.values());
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  Set<ExprColumn> baseExprs=new HashSet<>(exprs);
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  client.createCube(BASE_CUBE_NAME,cubeMeasures2,cubeDimensions2,baseExprs,joinChains,cubeProperties);
  Map<String,String> derivedProperties=new HashMap<>();
  derivedProperties.put(MetastoreConstants.CUBE_ALL_FIELDS_QUERIABLE,""String_Node_Str"");
  Set<String> measures=new HashSet<>();
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  Set<String> dimensions=new HashSet<>();
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  client.createDerivedCube(BASE_CUBE_NAME,DERIVED_CUBE_NAME1,measures,dimensions,derivedProperties,5L);
  measures=new HashSet<>();
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  dimensions=new HashSet<>();
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  client.createDerivedCube(BASE_CUBE_NAME,DERIVED_CUBE_NAME2,measures,dimensions,derivedProperties,10L);
  measures=new HashSet<>();
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  dimensions=new HashSet<>();
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  client.createDerivedCube(BASE_CUBE_NAME,DERIVED_CUBE_NAME3,measures,dimensions,derivedProperties,20L);
  createBaseCubeFacts(client);
}","private void createBaseAndDerivedCubes(CubeMetastoreClient client) throws HiveException, ParseException, LensException {
  Set<CubeMeasure> cubeMeasures2=new HashSet<>(cubeMeasures);
  Set<CubeDimAttribute> cubeDimensions2=new HashSet<>(cubeDimensions);
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",null,""String_Node_Str"",""String_Node_Str""));
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",null,""String_Node_Str"",null));
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",null,""String_Node_Str"",null));
  cubeMeasures2.add(new ColumnMeasure(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",null,""String_Node_Str"",null));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new BaseDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  Map<String,String> cubeProperties=new HashMap<>();
  cubeProperties.put(MetastoreUtil.getCubeTimedDimensionListKey(BASE_CUBE_NAME),""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_TO_PART_MAPPING_PFX + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_RELATION + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.TIMEDIM_RELATION + ""String_Node_Str"",""String_Node_Str"");
  cubeProperties.put(MetastoreConstants.CUBE_ALL_FIELDS_QUERIABLE,""String_Node_Str"");
  Map<String,JoinChain> joinChainMap=new HashMap<>();
  addCubeChains(joinChainMap,""String_Node_Str"");
  joinChainMap.get(""String_Node_Str"").addPath(new ArrayList<TableReference>(){
{
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
  joinChainMap.get(""String_Node_Str"").addPath(new ArrayList<TableReference>(){
{
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
  joinChainMap.get(""String_Node_Str"").addPath(new ArrayList<TableReference>(){
{
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
      add(new TableReference(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
  Set<JoinChain> joinChains=Sets.newHashSet(joinChainMap.values());
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  joinChains.add(new JoinChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
{
      addPath(new ArrayList<TableReference>(){
{
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str"",true));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
          add(new TableReference(""String_Node_Str"",""String_Node_Str""));
        }
      }
);
    }
  }
);
  cubeDimensions2.add(new ReferencedDimAttribute(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null,null));
  Set<ExprColumn> baseExprs=new HashSet<>(exprs);
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  baseExprs.add(new ExprColumn(new FieldSchema(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",new ExprSpec(""String_Node_Str"",null,null),new ExprSpec(""String_Node_Str"",null,null)));
  client.createCube(BASE_CUBE_NAME,cubeMeasures2,cubeDimensions2,baseExprs,joinChains,cubeProperties);
  Map<String,String> derivedProperties=new HashMap<>();
  derivedProperties.put(MetastoreConstants.CUBE_ALL_FIELDS_QUERIABLE,""String_Node_Str"");
  Set<String> measures=new HashSet<>();
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  Set<String> dimensions=new HashSet<>();
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  client.createDerivedCube(BASE_CUBE_NAME,DERIVED_CUBE_NAME1,measures,dimensions,derivedProperties,5L);
  measures=new HashSet<>();
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  dimensions=new HashSet<>();
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  client.createDerivedCube(BASE_CUBE_NAME,DERIVED_CUBE_NAME2,measures,dimensions,derivedProperties,10L);
  measures=new HashSet<>();
  measures.add(""String_Node_Str"");
  measures.add(""String_Node_Str"");
  dimensions=new HashSet<>();
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  dimensions.add(""String_Node_Str"");
  client.createDerivedCube(BASE_CUBE_NAME,DERIVED_CUBE_NAME3,measures,dimensions,derivedProperties,20L);
  createBaseCubeFacts(client);
}",0.9852507374631267
25251,"/** 
 * Returns the contents of this object in the form of a pretty formatted string.
 * @return
 */
String toPrettyString();","/** 
 * Returns the contents of this object in the form of a pretty formatted string.
 * @return contents as formatted String
 */
String toPrettyString();",0.8960573476702509
25252,"/** 
 * Converts the input path to appropriate File/URI path. Also removes erroneously appended prefix for URI's. Takes additional properties for special URI handling.
 * @param path
 * @param shouldBeDirectory
 * @param shouldExist
 * @return
 */
public String getValidPath(File path,boolean shouldBeDirectory,boolean shouldExist){
  if (path.getPath().indexOf(""String_Node_Str"") > 0) {
    return removePrefixBeforeURI(path.getPath());
  }
  if (shouldExist && !path.exists()) {
    throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  if (shouldBeDirectory && !path.isDirectory()) {
    throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  if (!shouldBeDirectory && path.isDirectory()) {
    throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  return path.getAbsolutePath();
}","/** 
 * Converts the input path to appropriate File/URI path. Also removes erroneously appended prefix for URI's. Takes additional properties for special URI handling.
 * @param path input path
 * @param shouldBeDirectory should be a directory
 * @param shouldExist should exist
 * @return converted path
 */
public String getValidPath(File path,boolean shouldBeDirectory,boolean shouldExist){
  if (path.getPath().indexOf(""String_Node_Str"") > 0) {
    return removePrefixBeforeURI(path.getPath());
  }
  if (shouldExist && !path.exists()) {
    throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  if (shouldBeDirectory && !path.isDirectory()) {
    throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  if (!shouldBeDirectory && path.isDirectory()) {
    throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  return path.getAbsolutePath();
}",0.96578799775659
25253,"/** 
 * The CLI erroneously appends absolute path for URI's. It also replaces the double slashes to single slashes. Eg. /home/some/path/file:/home/git/lens/target/tempdata_*.txt This Util method removes the erroneously appended absolute path for URI's. And appends :/// for the URI's. Paths with hdfs/s3/s3n are appended with double slashes :// Any new URI's have to be handled appropriately
 * @param path
 * @return
 */
public String removePrefixBeforeURI(String path){
  path=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
  path=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (path.startsWith(""String_Node_Str"")) {
    path=path.replaceFirst(""String_Node_Str"",System.getProperty(""String_Node_Str""));
  }
  String projectDir=Paths.get(""String_Node_Str"").toAbsolutePath().toString();
  int indexOfUriInit=path.indexOf(""String_Node_Str"");
  int currDirLen=projectDir.length();
  String escapedSlashes=""String_Node_Str"";
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher match=pattern.matcher(path);
  if (match.find() && config.getProperties().get(PATH_PREFIX + match.group(1)) != null) {
    escapedSlashes=config.getProperties().get(PATH_PREFIX + match.group(1));
  }
  if (path.startsWith(projectDir) && indexOfUriInit != -1) {
    path=path.substring(currDirLen + 1,path.length());
  }
  indexOfUriInit=path.indexOf(""String_Node_Str"");
  if (indexOfUriInit != -1 && !path.contains(""String_Node_Str"")) {
    path=path.substring(0,indexOfUriInit) + escapedSlashes + path.substring(indexOfUriInit + 2);
  }
  return path;
}","/** 
 * The CLI erroneously appends absolute path for URI's. It also replaces the double slashes to single slashes. Eg. /home/some/path/file:/home/git/lens/target/tempdata_*.txt This Util method removes the erroneously appended absolute path for URI's. And appends :/// for the URI's. Paths with hdfs/s3/s3n are appended with double slashes :// Any new URI's have to be handled appropriately
 * @param path input path
 * @return cleaned up path
 */
public String removePrefixBeforeURI(String path){
  path=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
  path=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (path.startsWith(""String_Node_Str"")) {
    path=path.replaceFirst(""String_Node_Str"",System.getProperty(""String_Node_Str""));
  }
  String projectDir=Paths.get(""String_Node_Str"").toAbsolutePath().toString();
  int indexOfUriInit=path.indexOf(""String_Node_Str"");
  int currDirLen=projectDir.length();
  String escapedSlashes=""String_Node_Str"";
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher match=pattern.matcher(path);
  if (match.find() && config.getProperties().get(PATH_PREFIX + match.group(1)) != null) {
    escapedSlashes=config.getProperties().get(PATH_PREFIX + match.group(1));
  }
  if (path.startsWith(projectDir) && indexOfUriInit != -1) {
    path=path.substring(currDirLen + 1,path.length());
  }
  indexOfUriInit=path.indexOf(""String_Node_Str"");
  if (indexOfUriInit != -1 && !path.contains(""String_Node_Str"")) {
    path=path.substring(0,indexOfUriInit) + escapedSlashes + path.substring(indexOfUriInit + 2);
  }
  return path;
}",0.9914094813872096
25254,"/** 
 * Explain query.
 * @param sql      the sql
 * @param location the location
 * @return the string
 * @throws LensAPIException
 * @throws UnsupportedEncodingException the unsupported encoding exception
 */
@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"" + ""String_Node_Str"") public String explainQuery(@CliOption(key={""String_Node_Str"",""String_Node_Str""},mandatory=true,help=""String_Node_Str"") String sql,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final File path) throws IOException, LensAPIException {
  PrettyPrintable cliOutput;
  try {
    QueryPlan plan=getClient().getQueryPlan(sql).getData();
    if (path != null && StringUtils.isNotBlank(path.getPath())) {
      String validPath=getValidPath(path,false,false);
      try (OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(validPath),Charset.defaultCharset())){
        osw.write(plan.getPlanString());
      }
       return ""String_Node_Str"" + validPath;
    }
    return plan.getPlanString();
  }
 catch (  final LensAPIException e) {
    BriefError briefError=new BriefError(e.getLensAPIErrorCode(),e.getLensAPIErrorMessage());
    cliOutput=new IdBriefErrorTemplate(IdBriefErrorTemplateKey.REQUEST_ID,e.getLensAPIRequestId(),briefError);
  }
catch (  final LensBriefErrorException e) {
    cliOutput=e.getIdBriefErrorTemplate();
  }
  return cliOutput.toPrettyString();
}","/** 
 * Explain query.
 * @param sql      the sql
 * @return the string
 * @throws LensAPIException
 * @throws UnsupportedEncodingException the unsupported encoding exception
 */
@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"" + ""String_Node_Str"") public String explainQuery(@CliOption(key={""String_Node_Str"",""String_Node_Str""},mandatory=true,help=""String_Node_Str"") String sql,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final File path) throws IOException, LensAPIException {
  PrettyPrintable cliOutput;
  try {
    QueryPlan plan=getClient().getQueryPlan(sql).getData();
    if (path != null && StringUtils.isNotBlank(path.getPath())) {
      String validPath=getValidPath(path,false,false);
      try (OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(validPath),Charset.defaultCharset())){
        osw.write(plan.getPlanString());
      }
       return ""String_Node_Str"" + validPath;
    }
    return plan.getPlanString();
  }
 catch (  final LensAPIException e) {
    BriefError briefError=new BriefError(e.getLensAPIErrorCode(),e.getLensAPIErrorMessage());
    cliOutput=new IdBriefErrorTemplate(IdBriefErrorTemplateKey.REQUEST_ID,e.getLensAPIRequestId(),briefError);
  }
catch (  final LensBriefErrorException e) {
    cliOutput=e.getIdBriefErrorTemplate();
  }
  return cliOutput.toPrettyString();
}",0.9884393063583816
25255,"/** 
 * @inheritDoc
 */
@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  try {
    Hive.get(LensServerConf.getHiveConf()).getAllDatabases();
  }
 catch (  HiveException e) {
    isHealthy=false;
    details.append(""String_Node_Str"");
    log.error(""String_Node_Str"",e);
  }
  if (!this.getServiceState().equals(STATE.STARTED)) {
    isHealthy=false;
    details.append(""String_Node_Str"");
    log.error(""String_Node_Str"");
  }
  return isHealthy ? new HealthStatus(isHealthy,""String_Node_Str"") : new HealthStatus(isHealthy,details.toString());
}","/** 
 * {@inheritDoc}
 */
@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  try {
    Hive.get(LensServerConf.getHiveConf()).getAllDatabases();
  }
 catch (  HiveException e) {
    isHealthy=false;
    details.append(""String_Node_Str"");
    log.error(""String_Node_Str"",e);
  }
  if (!this.getServiceState().equals(STATE.STARTED)) {
    isHealthy=false;
    details.append(""String_Node_Str"");
    log.error(""String_Node_Str"");
  }
  return isHealthy ? new HealthStatus(isHealthy,""String_Node_Str"") : new HealthStatus(isHealthy,details.toString());
}",0.9983844911147012
25256,"/** 
 * @inheritDoc
 */
@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  if (!this.getServiceState().equals(STATE.STARTED)) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.statusPoller.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.prepareQueryPurger.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.queryPurger.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.querySubmitter.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (this.estimatePool.isShutdown() || this.estimatePool.isTerminated()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (querySubmitterRunnable.pausedForTest) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (null != this.queryResultPurger && !this.queryResultPurger.isHealthy()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!isHealthy) {
    log.error(details.toString());
  }
  return isHealthy ? new HealthStatus(isHealthy,""String_Node_Str"") : new HealthStatus(isHealthy,details.toString());
}","/** 
 * {@inheritDoc}
 */
@Override public HealthStatus getHealthStatus(){
  boolean isHealthy=true;
  StringBuilder details=new StringBuilder();
  if (!this.getServiceState().equals(STATE.STARTED)) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.statusPoller.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.prepareQueryPurger.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.queryPurger.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!this.querySubmitter.isAlive()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (this.estimatePool.isShutdown() || this.estimatePool.isTerminated()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (querySubmitterRunnable.pausedForTest) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (null != this.queryResultPurger && !this.queryResultPurger.isHealthy()) {
    isHealthy=false;
    details.append(""String_Node_Str"");
  }
  if (!isHealthy) {
    log.error(details.toString());
  }
  return isHealthy ? new HealthStatus(isHealthy,""String_Node_Str"") : new HealthStatus(isHealthy,details.toString());
}",0.99919935948759
25257,"/** 
 * Creates the saved query table
 * @throws LensException
 */
public void createSavedQueryTableIfNotExists() throws LensException {
  try {
    runner.update(dialect.getCreateTableSyntax());
  }
 catch (  SQLException e) {
    throw new LensException(""String_Node_Str"",e);
  }
}","/** 
 * Creates the saved query table
 * @throws LensException cannot create saved query table
 */
public void createSavedQueryTableIfNotExists() throws LensException {
  try {
    runner.update(dialect.getCreateTableSyntax());
  }
 catch (  SQLException e) {
    throw new LensException(""String_Node_Str"",e);
  }
}",0.9464882943143812
25258,"/** 
 * Saves the query passed
 * @param savedQuery
 * @return
 * @throws LensException
 */
public long saveQuery(SavedQuery savedQuery) throws LensException {
  try {
    final ECMAEscapedSavedQuery ecmaEscaped=ECMAEscapedSavedQuery.getFor(savedQuery);
    runner.update(""String_Node_Str"" + SAVED_QUERY_TABLE_NAME + ""String_Node_Str""+ dialect.getAutoIncrementId(runner)+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getDescription()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getQuery()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getParameters()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return dialect.getLastInsertedID(runner);
  }
 catch (  SQLException e) {
    throw new LensException(""String_Node_Str"",e);
  }
}","/** 
 * Saves the query passed
 * @param savedQuery
 * @return insert id
 * @throws LensException
 */
public long saveQuery(SavedQuery savedQuery) throws LensException {
  try {
    final ECMAEscapedSavedQuery ecmaEscaped=ECMAEscapedSavedQuery.getFor(savedQuery);
    runner.update(""String_Node_Str"" + SAVED_QUERY_TABLE_NAME + ""String_Node_Str""+ dialect.getAutoIncrementId(runner)+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getDescription()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getQuery()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ecmaEscaped.getParameters()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return dialect.getLastInsertedID(runner);
  }
 catch (  SQLException e) {
    throw new LensException(""String_Node_Str"",e);
  }
}",0.9946808510638298
25259,"/** 
 * @inheritDoc
 */
@Override public HealthStatus getHealthStatus(){
  return this.getServiceState().equals(STATE.STARTED) ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public HealthStatus getHealthStatus(){
  return this.getServiceState().equals(STATE.STARTED) ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,""String_Node_Str"");
}",0.9953917050691244
25260,"/** 
 * @inheritDoc
 */
@Override public HealthStatus getHealthStatus(){
  return this.getServiceState().equals(STATE.STARTED) ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public HealthStatus getHealthStatus(){
  return this.getServiceState().equals(STATE.STARTED) ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,""String_Node_Str"");
}",0.9953917050691244
25261,"/** 
 * @inheritDoc
 */
@Override public HealthStatus getHealthStatus(){
  return this.getServiceState().equals(STATE.STARTED) ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public HealthStatus getHealthStatus(){
  return this.getServiceState().equals(STATE.STARTED) ? new HealthStatus(true,""String_Node_Str"") : new HealthStatus(false,""String_Node_Str"");
}",0.9953917050691244
25262,"private void createContinuousFactData() throws Exception {
  Class.forName(""String_Node_Str"");
  Connection con=DriverManager.getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  con.setAutoCommit(true);
  Statement statement=con.createStatement();
  try {
    Date date=new Date(System.currentTimeMillis());
    SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    String nowTime=format.format(date);
    statement.execute(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + nowTime + ""String_Node_Str""+ nowTime+ ""String_Node_Str"");
  }
  finally {
    statement.close();
    con.close();
  }
}","private void createContinuousFactData() throws Exception {
  Class.forName(""String_Node_Str"");
  Connection con=DriverManager.getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  con.setAutoCommit(true);
  Statement statement=con.createStatement();
  try {
    statement.execute(INSERT_QUERY);
  }
  finally {
    statement.close();
    con.close();
  }
}",0.5606207565470417
25263,"public void testScannedPathsRecursive() throws Exception {
  ScannedPaths sc;
  Iterator<String> iter=null;
  String tempPath=""String_Node_Str"";
  String fileRegex=tempPath + ""String_Node_Str"";
  try {
    createTempDirStructure2(tempPath);
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),6,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    File orderFile=createNewPath(tempPath,""String_Node_Str"");
    PrintWriter writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),6,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(""String_Node_Str""));
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}","public void testScannedPathsRecursive() throws Exception {
  ScannedPaths sc;
  String tempPath=""String_Node_Str"";
  String fileRegex=tempPath + ""String_Node_Str"";
  try {
    createTempDirStructure2(tempPath);
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    assertUnOrdered(sc,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    File orderFile=createNewPath(tempPath,""String_Node_Str"");
    PrintWriter writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    assertUnOrdered(sc,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}",0.3223140495867768
25264,"public void testScannedPathsJarGlobOrder() throws Exception {
  File fileA=null, fileB=null, fileC=null;
  File jarFile=null, globFile=null;
  String filenameA, filenameB, filenameC, fileRegex;
  String tempPath=""String_Node_Str"";
  ScannedPaths sc;
  Iterator<String> iter=null;
  PrintWriter writer;
  try {
    filenameA=""String_Node_Str"";
    filenameB=""String_Node_Str"";
    filenameC=""String_Node_Str"";
    fileRegex=tempPath;
    fileA=createNewPath(tempPath + filenameA);
    fileB=createNewPath(tempPath + filenameB);
    fileC=createNewPath(tempPath + filenameC);
    jarFile=createNewPath(tempPath + ""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameB);
    writer.println(filenameA);
    writer.close();
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),2,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(filenameB));
    Assert.assertTrue(iter.next().contains(filenameA));
    if (jarFile != null) {
      jarFile.delete();
    }
    globFile=createNewPath(tempPath + ""String_Node_Str"");
    writer=new PrintWriter(globFile,""String_Node_Str"");
    writer.println(filenameB);
    writer.println(filenameA);
    writer.println(filenameC);
    writer.close();
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),3,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(filenameB));
    Assert.assertTrue(iter.next().contains(filenameA));
    Assert.assertTrue(iter.next().contains(filenameC));
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}","public void testScannedPathsJarGlobOrder() throws Exception {
  File jarFile, globFile;
  String filenameA, filenameB, filenameC, fileRegex;
  String tempPath=""String_Node_Str"";
  ScannedPaths sc;
  Iterator<String> iter=null;
  PrintWriter writer;
  try {
    filenameA=""String_Node_Str"";
    filenameB=""String_Node_Str"";
    filenameC=""String_Node_Str"";
    fileRegex=tempPath;
    createNewPath(tempPath + filenameA);
    createNewPath(tempPath + filenameB);
    createNewPath(tempPath + filenameC);
    jarFile=createNewPath(tempPath + ""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameB);
    writer.println(filenameA);
    writer.close();
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    assertOrdered(sc,filenameB,filenameA);
    if (jarFile != null) {
      jarFile.delete();
    }
    globFile=createNewPath(tempPath + ""String_Node_Str"");
    writer=new PrintWriter(globFile,""String_Node_Str"");
    writer.println(filenameB);
    writer.println(filenameA);
    writer.println(filenameC);
    writer.close();
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    assertOrdered(sc,filenameB,filenameA,filenameC);
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}",0.1720498880716341
25265,"/** 
 * Private method used by testScannedPathsMultipleJarGlobOrder. Creates temp dir structure with files. Dir structure created: sourceDirPath/tempfiles/tempdata_a.jar sourceDirPath/tempfiles/tempdata_c.jar sourceDirPath/tempfiles/dir1/tempdata_a.jar sourceDirPath/tempfiles/dir1/tempdata_b.jar sourceDirPath/tempfiles/dir1/tempdata_c.data sourceDirPath/tempfiles/dir2/tempdata_a.data sourceDirPath/tempfiles/dir2/tempdata_b.data sourceDirPath/tempfiles/dir2/tempdata_c.jar sourceDirPath/tempfiles/dir3/tempdata_a.jar sourceDirPath/tempfiles/dir3/tempdata_b.data sourceDirPath/tempfiles/dir3/tempdata_c-duplicate.jar sourceDirPath/tempfiles/dir3/tempdata_c.jar // Additional regex checks for regex in jar_order/glob_order sourceDirPath/tempfiles/dir3/innerDirA/inceptionLevel2/tempdata_c.jar sourceDirPath/tempfiles/dir3/innerDirA/inceptionLevel2/tempdata_c-duplicate.jar sourceDirPath/tempfiles/dir3/innerDirB/inceptionLevel2/tempdata_c-duplicate-2.jar
 * @param sourceDirPath
 */
private void createTempDirStructure1(String sourceDirPath){
  File jarFile=null, globFile=null;
  String filenameA, filenameB, filenameC;
  String tempPath=sourceDirPath + ""String_Node_Str"";
  FileUtils.deleteQuietly(new File(tempPath));
  String jarExtension=""String_Node_Str"";
  String dataExtension=""String_Node_Str"";
  String dir1=""String_Node_Str"", dir2=""String_Node_Str"", dir3=""String_Node_Str"";
  filenameA=""String_Node_Str"";
  filenameB=""String_Node_Str"";
  filenameC=""String_Node_Str"";
  PrintWriter writer;
  try {
    createNewPath(tempPath,filenameC,jarExtension);
    createNewPath(tempPath,filenameA,jarExtension);
    createNewPath(tempPath,dir1,filenameA,jarExtension);
    createNewPath(tempPath,dir1,filenameB,jarExtension);
    createNewPath(tempPath,dir1,filenameC,dataExtension);
    createNewPath(tempPath,dir2,filenameA,dataExtension);
    createNewPath(tempPath,dir2,filenameB,dataExtension);
    createNewPath(tempPath,dir2,filenameC,jarExtension);
    createNewPath(tempPath,dir3,filenameA,jarExtension);
    createNewPath(tempPath,dir3,filenameB,dataExtension);
    createNewPath(tempPath,dir3,filenameC,jarExtension);
    createNewPath(tempPath,dir3,filenameC,""String_Node_Str"",jarExtension);
    createNewPath(tempPath,dir3,""String_Node_Str"",filenameC,jarExtension);
    createNewPath(tempPath,dir3,""String_Node_Str"",filenameC,""String_Node_Str"",jarExtension);
    createNewPath(tempPath,dir3,""String_Node_Str"",filenameC,""String_Node_Str"",jarExtension);
    jarFile=createNewPath(tempPath,dir1,""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameB + jarExtension);
    writer.println(filenameA + jarExtension);
    writer.close();
    jarFile=createNewPath(tempPath,dir2,""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameC + jarExtension);
    writer.close();
    jarFile=createNewPath(tempPath,dir3,""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameC + ""String_Node_Str"" + jarExtension);
    writer.println(filenameA + jarExtension);
    writer.close();
    globFile=createNewPath(tempPath,dir1,""String_Node_Str"");
    writer=new PrintWriter(globFile,""String_Node_Str"");
    writer.println(filenameC + dataExtension);
    writer.println(filenameB + jarExtension);
    writer.println(filenameA + jarExtension);
    writer.close();
    globFile=createNewPath(tempPath,dir3,""String_Node_Str"");
    writer=new PrintWriter(globFile,""String_Node_Str"");
    writer.println(filenameC + jarExtension);
    writer.println(filenameC + ""String_Node_Str"" + jarExtension);
    writer.println(""String_Node_Str"" + filenameC + ""String_Node_Str""+ jarExtension);
    writer.close();
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Private method used by testScannedPathsMultipleJarGlobOrder. Creates temp dir structure with files. Dir structure created: sourceDirPath/tempfiles/tempdata_a.jar sourceDirPath/tempfiles/tempdata_c.jar sourceDirPath/tempfiles/dir1/tempdata_a.jar sourceDirPath/tempfiles + ""-duplicate""/dir1/tempdata_b.jar sourceDirPath/tempfiles/dir1/tempdata_c.data sourceDirPath/tempfiles/dir2/tempdata_a.data sourceDirPath/tempfiles/dir2/tempdata_b.data sourceDirPath/tempfiles/dir2/tempdata_c.jar sourceDirPath/tempfiles/dir3/tempdata_a.jar sourceDirPath/tempfiles/dir3/tempdata_b.data sourceDirPath/tempfiles/dir3/tempdata_c-duplicate.jar sourceDirPath/tempfiles/dir3/tempdata_c.jar // Additional regex checks for regex in jar_order/glob_order sourceDirPath/tempfiles/dir3/innerDirA/inceptionLevel2/tempdata_c.jar sourceDirPath/tempfiles/dir3/innerDirA/inceptionLevel2/tempdata_c-duplicate.jar sourceDirPath/tempfiles/dir3/innerDirB/inceptionLevel2/tempdata_c-duplicate-2.jar
 * @param sourceDirPath
 */
private void createTempDirStructure1(String sourceDirPath){
  File jarFile, globFile;
  String filenameA, filenameB, filenameC;
  String tempPath=sourceDirPath + ""String_Node_Str"";
  FileUtils.deleteQuietly(new File(tempPath));
  String jarExtension=""String_Node_Str"";
  String dataExtension=""String_Node_Str"";
  String dir1=""String_Node_Str"", dir2=""String_Node_Str"", dir3=""String_Node_Str"";
  filenameA=""String_Node_Str"";
  filenameB=""String_Node_Str"";
  filenameC=""String_Node_Str"";
  PrintWriter writer;
  try {
    createNewPath(tempPath,filenameC,jarExtension);
    createNewPath(tempPath,filenameA,jarExtension);
    createNewPath(tempPath,dir1,filenameA,jarExtension);
    createNewPath(tempPath,dir1,filenameB,jarExtension);
    createNewPath(tempPath,dir1,filenameC,dataExtension);
    createNewPath(tempPath,dir2,filenameA,dataExtension);
    createNewPath(tempPath,dir2,filenameB,dataExtension);
    createNewPath(tempPath,dir2,filenameC,jarExtension);
    createNewPath(tempPath,dir3,filenameA,jarExtension);
    createNewPath(tempPath,dir3,filenameB,dataExtension);
    createNewPath(tempPath,dir3,filenameC,jarExtension);
    createNewPath(tempPath,dir3,filenameC,""String_Node_Str"",jarExtension);
    createNewPath(tempPath,dir3,""String_Node_Str"",filenameC,jarExtension);
    createNewPath(tempPath,dir3,""String_Node_Str"",filenameC,""String_Node_Str"",jarExtension);
    createNewPath(tempPath,dir3,""String_Node_Str"",filenameC,""String_Node_Str"",jarExtension);
    jarFile=createNewPath(tempPath,dir1,""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameB + jarExtension);
    writer.println(filenameA + jarExtension);
    writer.close();
    jarFile=createNewPath(tempPath,dir2,""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameC + jarExtension);
    writer.close();
    jarFile=createNewPath(tempPath,dir3,""String_Node_Str"");
    writer=new PrintWriter(jarFile,""String_Node_Str"");
    writer.println(filenameC + ""String_Node_Str"" + jarExtension);
    writer.println(filenameA + jarExtension);
    writer.close();
    globFile=createNewPath(tempPath,dir1,""String_Node_Str"");
    writer=new PrintWriter(globFile,""String_Node_Str"");
    writer.println(filenameC + dataExtension);
    writer.println(filenameB + jarExtension);
    writer.println(filenameA + jarExtension);
    writer.close();
    globFile=createNewPath(tempPath,dir3,""String_Node_Str"");
    writer=new PrintWriter(globFile,""String_Node_Str"");
    writer.println(filenameC + jarExtension);
    writer.println(filenameC + ""String_Node_Str"" + jarExtension);
    writer.println(""String_Node_Str"" + filenameC + ""String_Node_Str""+ jarExtension);
    writer.close();
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"" + ex.getMessage());
  }
}",0.9967298888162196
25266,"public void testScannedPathsMultipleJarGlobOrder() throws Exception {
  ScannedPaths sc;
  Iterator<String> iter=null;
  String tempPath=""String_Node_Str"";
  String filenameA=""String_Node_Str"";
  String filenameB=""String_Node_Str"";
  String filenameC=""String_Node_Str"";
  String fileRegex1=tempPath + ""String_Node_Str"";
  String fileRegex2=tempPath + ""String_Node_Str"";
  try {
    createTempDirStructure1(tempPath);
    sc=new ScannedPaths(fileRegex1,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),2,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameA));
    sc=new ScannedPaths(fileRegex2,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),7,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(filenameB));
    Assert.assertTrue(iter.next().contains(filenameA));
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameC + ""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(filenameA));
    Assert.assertTrue(iter.next().contains(filenameA));
    FileUtils.deleteQuietly(new File(tempPath + ""String_Node_Str""));
    FileUtils.deleteQuietly(new File(tempPath + ""String_Node_Str""));
    FileUtils.deleteQuietly(new File(tempPath + ""String_Node_Str""));
    sc=new ScannedPaths(fileRegex1,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),2,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameA));
    sc=new ScannedPaths(fileRegex2,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),12,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameB));
    Assert.assertTrue(iter.next().contains(filenameA));
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameB));
    Assert.assertTrue(iter.next().contains(filenameA));
    Assert.assertTrue(iter.next().contains(filenameC));
    Assert.assertTrue(iter.next().contains(filenameC + ""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(filenameC + ""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(filenameC + ""String_Node_Str""));
    Assert.assertTrue(iter.next().contains(filenameA));
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}","public void testScannedPathsMultipleJarGlobOrder() throws Exception {
  ScannedPaths sc;
  String tempPath=""String_Node_Str"";
  String filenameAJar=""String_Node_Str"";
  String filenameBJar=""String_Node_Str"";
  String filenameCJar=""String_Node_Str"";
  String filenameCDupJar=""String_Node_Str"";
  String filenameCDupJar2=""String_Node_Str"";
  String filenameAData=""String_Node_Str"";
  String filenameBData=""String_Node_Str"";
  String filenameCData=""String_Node_Str"";
  String fileRegex1=tempPath + ""String_Node_Str"";
  String fileRegex2=tempPath + ""String_Node_Str"";
  try {
    createTempDirStructure1(tempPath);
    sc=new ScannedPaths(fileRegex1,""String_Node_Str"");
    assertUnOrdered(sc,filenameCJar,filenameAJar);
    sc=new ScannedPaths(fileRegex2,""String_Node_Str"");
    assertUnOrdered(sc,filenameBJar,filenameAJar,filenameCJar,filenameCJar,filenameCDupJar,filenameAJar,filenameAJar);
    FileUtils.deleteQuietly(new File(tempPath + ""String_Node_Str""));
    FileUtils.deleteQuietly(new File(tempPath + ""String_Node_Str""));
    FileUtils.deleteQuietly(new File(tempPath + ""String_Node_Str""));
    sc=new ScannedPaths(fileRegex1,""String_Node_Str"");
    assertUnOrdered(sc,filenameCJar,filenameAJar);
    sc=new ScannedPaths(fileRegex2,""String_Node_Str"");
    assertUnOrdered(sc,filenameCData,filenameBJar,filenameAJar,filenameCJar,filenameCJar,filenameBData,filenameAData,filenameCJar,filenameCDupJar,filenameCDupJar2,filenameCDupJar,filenameAJar);
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}",0.4597069597069597
25267,"public void testScannedPaths() throws Exception {
  File fileA=null, fileB=null;
  String filenameA, filenameB, fileRegex;
  String tempPath=""String_Node_Str"";
  ScannedPaths sc;
  Iterator<String> iter=null;
  try {
    filenameA=""String_Node_Str"";
    filenameB=""String_Node_Str"";
    fileRegex=tempPath + ""String_Node_Str"";
    fileA=createNewPath(tempPath + filenameA);
    fileB=createNewPath(tempPath + filenameB);
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    Assert.assertEquals(Iterators.size(sc.iterator()),2,""String_Node_Str"");
    iter=sc.iterator();
    Assert.assertTrue(iter.next().contains(filenameA));
    Assert.assertTrue(iter.next().contains(filenameB));
    fileRegex=tempPath + ""String_Node_Str"";
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    Assert.assertFalse(sc.iterator().hasNext(),""String_Node_Str"");
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}","public void testScannedPaths() throws Exception {
  String filenameA, filenameB, fileRegex;
  String tempPath=""String_Node_Str"";
  ScannedPaths sc;
  try {
    filenameA=""String_Node_Str"";
    filenameB=""String_Node_Str"";
    fileRegex=tempPath + ""String_Node_Str"";
    createNewPath(tempPath + filenameA);
    createNewPath(tempPath + filenameB);
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    assertUnOrdered(sc,filenameA,filenameB);
    fileRegex=tempPath + ""String_Node_Str"";
    sc=new ScannedPaths(fileRegex,""String_Node_Str"");
    Assert.assertFalse(sc.iterator().hasNext(),""String_Node_Str"");
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    FileUtils.deleteQuietly(new File(tempPath));
  }
}",0.4473386183465458
25268,"/** 
 * Private method used by testScannedPathsRecursive. Creates temp dir structure with files. Dir structure created: sourceDirPath/tempfiles/a_dir/jar_1 sourceDirPath/tempfiles/a_dir/jar_2 sourceDirPath/tempfiles/a_dir/jar_order (*1\n*2) sourceDirPath/tempfiles/b_dir/jar_3 sourceDirPath/tempfiles/b_dir/jar_4 sourceDirPath/tempfiles/b_dir/glob_order (*4\n*3) sourceDirPath/tempfiles/c_dir/jar_5 sourceDirPath/tempfiles/c_dir/jar_6 sourceDirPath/tempfiles/jar_order (a*\nb*\nc*)
 * @param sourceDirPath
 */
private void createTempDirStructure2(String sourceDirPath){
  File orderFile=null;
  String filenameA, filenameB, filenameC;
  String tempPath=sourceDirPath + ""String_Node_Str"";
  FileUtils.deleteQuietly(new File(tempPath));
  PrintWriter writer;
  try {
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    orderFile=createNewPath(tempPath,""String_Node_Str"");
    writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
    orderFile=createNewPath(tempPath,""String_Node_Str"");
    writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
    orderFile=createNewPath(tempPath,""String_Node_Str"");
    writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Private method used by testScannedPathsRecursive. Creates temp dir structure with files. Dir structure created: sourceDirPath/tempfiles/a_dir/jar_1 sourceDirPath/tempfiles/a_dir/jar_2 sourceDirPath/tempfiles/a_dir/jar_order (*1\n*2) sourceDirPath/tempfiles/b_dir/jar_3 sourceDirPath/tempfiles/b_dir/jar_4 sourceDirPath/tempfiles/b_dir/glob_order (*4\n*3) sourceDirPath/tempfiles/c_dir/jar_5 sourceDirPath/tempfiles/c_dir/jar_6 sourceDirPath/tempfiles/jar_order (a*\nb*\nc*)
 * @param sourceDirPath
 */
private void createTempDirStructure2(String sourceDirPath){
  File orderFile;
  String tempPath=sourceDirPath + ""String_Node_Str"";
  FileUtils.deleteQuietly(new File(tempPath));
  PrintWriter writer;
  try {
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    createNewPath(tempPath,""String_Node_Str"");
    orderFile=createNewPath(tempPath,""String_Node_Str"");
    writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
    orderFile=createNewPath(tempPath,""String_Node_Str"");
    writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
    orderFile=createNewPath(tempPath,""String_Node_Str"");
    writer=new PrintWriter(orderFile,""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.close();
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"" + ex.getMessage());
  }
}",0.9868531468531468
25269,"@Override protected DateFormat initialValue(){
  DateFormat dateFormat=DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL);
  dateFormat.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  return dateFormat;
}","@Override protected DateFormat initialValue(){
  DateFormat dateFormat=DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.US);
  dateFormat.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  return dateFormat;
}",0.9782608695652174
25270,"private static void functionString(ASTNode root,StringBuilder buf){
  if (findNodeByPath(root,KW_CASE) != null) {
    buf.append(""String_Node_Str"");
    toInfixString((ASTNode)root.getChild(1),buf);
    ArrayList<Node> caseChildren=root.getChildren();
    int from=2;
    int nchildren=caseChildren.size();
    int to=nchildren % 2 == 1 ? nchildren - 1 : nchildren;
    for (int i=from; i < to; i+=2) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i + 1),buf);
    }
    if (nchildren % 2 == 1) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(nchildren - 1),buf);
    }
    buf.append(""String_Node_Str"");
  }
 else   if (findNodeByPath(root,KW_WHEN) != null) {
    buf.append(""String_Node_Str"");
    ArrayList<Node> caseChildren=root.getChildren();
    int from=1;
    int nchildren=caseChildren.size();
    int to=nchildren % 2 == 1 ? nchildren : nchildren - 1;
    for (int i=from; i < to; i+=2) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i + 1),buf);
    }
    if (nchildren % 2 == 0) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(nchildren - 1),buf);
    }
    buf.append(""String_Node_Str"");
  }
 else   if (findNodeByPath(root,TOK_ISNULL) != null) {
    toInfixString((ASTNode)root.getChild(1),buf);
    buf.append(""String_Node_Str"");
  }
 else   if (findNodeByPath(root,TOK_ISNOTNULL) != null) {
    toInfixString((ASTNode)root.getChild(1),buf);
    buf.append(""String_Node_Str"");
  }
 else   if (((ASTNode)root.getChild(0)).getToken().getType() == Identifier && ((ASTNode)root.getChild(0)).getToken().getText().equalsIgnoreCase(""String_Node_Str"")) {
    ASTNode tokTrue=findNodeByPath(root,KW_TRUE);
    ASTNode tokFalse=findNodeByPath(root,KW_FALSE);
    if (tokTrue != null) {
      toInfixString((ASTNode)root.getChild(2),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(3),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(4),buf);
    }
 else     if (tokFalse != null) {
      toInfixString((ASTNode)root.getChild(2),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(3),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(4),buf);
    }
  }
 else   if (findNodeByPath(root,KW_IN) != null) {
    toInfixString((ASTNode)root.getChild(1),buf);
    ASTNode rootParent=(ASTNode)root.getParent();
    if (rootParent != null && rootParent.getToken().getType() == KW_NOT) {
      buf.append(""String_Node_Str"");
    }
    buf.append(""String_Node_Str"");
    for (int i=2; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i < root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
  }
 else {
    String fname=((ASTNode)root.getChild(0)).getText();
    buf.append(fname.toLowerCase()).append(""String_Node_Str"");
    for (int i=1; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i != root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
  }
}","private static void functionString(ASTNode root,StringBuilder buf){
  if (findNodeByPath(root,KW_CASE) != null) {
    buf.append(""String_Node_Str"");
    toInfixString((ASTNode)root.getChild(1),buf);
    ArrayList<Node> caseChildren=root.getChildren();
    int from=2;
    int nchildren=caseChildren.size();
    int to=nchildren % 2 == 1 ? nchildren - 1 : nchildren;
    for (int i=from; i < to; i+=2) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i + 1),buf);
    }
    if (nchildren % 2 == 1) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(nchildren - 1),buf);
    }
    buf.append(""String_Node_Str"");
  }
 else   if (findNodeByPath(root,KW_WHEN) != null) {
    buf.append(""String_Node_Str"");
    ArrayList<Node> caseChildren=root.getChildren();
    int from=1;
    int nchildren=caseChildren.size();
    int to=nchildren % 2 == 1 ? nchildren : nchildren - 1;
    for (int i=from; i < to; i+=2) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(i + 1),buf);
    }
    if (nchildren % 2 == 0) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)caseChildren.get(nchildren - 1),buf);
    }
    buf.append(""String_Node_Str"");
  }
 else   if (findNodeByPath(root,TOK_ISNULL) != null) {
    toInfixString((ASTNode)root.getChild(1),buf);
    buf.append(""String_Node_Str"");
  }
 else   if (findNodeByPath(root,TOK_ISNOTNULL) != null) {
    toInfixString((ASTNode)root.getChild(1),buf);
    buf.append(""String_Node_Str"");
  }
 else   if (((ASTNode)root.getChild(0)).getToken().getType() == Identifier && ((ASTNode)root.getChild(0)).getToken().getText().equalsIgnoreCase(""String_Node_Str"")) {
    ASTNode tokTrue=findNodeByPath(root,KW_TRUE);
    ASTNode tokFalse=findNodeByPath(root,KW_FALSE);
    if (tokTrue != null) {
      toInfixString((ASTNode)root.getChild(2),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(3),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(4),buf);
    }
 else     if (tokFalse != null) {
      toInfixString((ASTNode)root.getChild(2),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(3),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(4),buf);
    }
  }
 else   if (findNodeByPath(root,KW_IN) != null) {
    toInfixString((ASTNode)root.getChild(1),buf);
    ASTNode rootParent=(ASTNode)root.getParent();
    if (rootParent != null && rootParent.getToken().getType() == KW_NOT) {
      buf.append(""String_Node_Str"");
    }
    buf.append(""String_Node_Str"");
    for (int i=2; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i < root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
  }
 else   if (findNodeByPath(root,KW_CAST) != null) {
    buf.append(""String_Node_Str"");
    toInfixString((ASTNode)root.getChild(1),buf);
    buf.append(""String_Node_Str"");
    toInfixString((ASTNode)root.getChild(0),buf);
  }
 else {
    int rootType=((ASTNode)root.getChild(0)).getToken().getType();
    if (PRIMITIVE_TYPES.contains(rootType)) {
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(1),buf);
      buf.append(""String_Node_Str"");
      toInfixString((ASTNode)root.getChild(0),buf);
      buf.append(""String_Node_Str"");
    }
 else {
      String fname=((ASTNode)root.getChild(0)).getText();
      buf.append(fname.toLowerCase()).append(""String_Node_Str"");
      for (int i=1; i < root.getChildCount(); i++) {
        toInfixString((ASTNode)root.getChild(i),buf);
        if (i != root.getChildCount() - 1) {
          buf.append(""String_Node_Str"");
        }
      }
      buf.append(""String_Node_Str"");
    }
  }
}",0.904226859283039
25271,"/** 
 * Recursively reconstruct query string given a query AST
 * @param root
 * @param buf  preallocated builder where the reconstructed string will be written
 */
public static void toInfixString(ASTNode root,StringBuilder buf){
  if (root == null) {
    return;
  }
  int rootType=root.getToken().getType();
  String rootText=root.getText();
  if (Identifier == rootType || Number == rootType || StringLiteral == rootType || KW_TRUE == rootType || KW_FALSE == rootType || KW_FORMATTED == rootType || KW_EXTENDED == rootType || KW_DEPENDENCY == rootType) {
    if (StringLiteral == rootType) {
      buf.append(' ').append(rootText).append(' ');
    }
 else     if (KW_TRUE == rootType) {
      buf.append(""String_Node_Str"");
    }
 else     if (KW_FALSE == rootType) {
      buf.append(""String_Node_Str"");
    }
 else     if (Identifier == rootType && TOK_SELEXPR == ((ASTNode)root.getParent()).getToken().getType() && hasSpaces(rootText)) {
      buf.append(""String_Node_Str"").append(rootText).append(""String_Node_Str"");
    }
 else     if (Identifier == rootType && TOK_FUNCTIONSTAR == ((ASTNode)root.getParent()).getToken().getType()) {
      buf.append(""String_Node_Str"").append(rootText == null ? ""String_Node_Str"" : rootText.toLowerCase());
    }
 else {
      buf.append(""String_Node_Str"").append(rootText == null ? ""String_Node_Str"" : rootText.toLowerCase()).append(""String_Node_Str"");
    }
  }
 else   if (TOK_ALLCOLREF == rootType) {
    if (root.getChildCount() > 0) {
      for (int i=0; i < root.getChildCount(); i++) {
        toInfixString((ASTNode)root.getChild(i),buf);
      }
      buf.append(""String_Node_Str"");
    }
    buf.append(""String_Node_Str"");
  }
 else   if (TOK_FUNCTIONSTAR == rootType) {
    if (root.getChildCount() > 0) {
      for (int i=0; i < root.getChildCount(); i++) {
        toInfixString((ASTNode)root.getChild(i),buf);
      }
    }
    buf.append(""String_Node_Str"");
  }
 else   if (UNARY_OPERATORS.contains(Integer.valueOf(rootType))) {
    if (KW_NOT == rootType) {
      if (!(findNodeByPath(root,TOK_FUNCTION,KW_IN) != null)) {
        buf.append(""String_Node_Str"");
      }
    }
 else     if (TILDE == rootType) {
      buf.append(""String_Node_Str"");
    }
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else   if (BINARY_OPERATORS.contains(Integer.valueOf(root.getToken().getType()))) {
    buf.append(""String_Node_Str"");
    if (MINUS == rootType && root.getChildCount() == 1) {
      buf.append(' ').append(rootText.toLowerCase()).append(' ');
      toInfixString((ASTNode)root.getChild(0),buf);
    }
 else {
      toInfixString((ASTNode)root.getChild(0),buf);
      if (root.getToken().getType() != DOT) {
        buf.append(' ').append(rootText.toLowerCase()).append(' ');
      }
 else {
        buf.append(rootText.toLowerCase());
      }
      toInfixString((ASTNode)root.getChild(1),buf);
    }
    buf.append(""String_Node_Str"");
  }
 else   if (LSQUARE == rootType) {
    toInfixString((ASTNode)root.getChild(0),buf);
    buf.append(""String_Node_Str"");
    toInfixString((ASTNode)root.getChild(1),buf);
    buf.append(""String_Node_Str"");
  }
 else   if (TOK_FUNCTION == root.getToken().getType()) {
    functionString(root,buf);
  }
 else   if (TOK_FUNCTIONDI == rootType) {
    String fname=((ASTNode)root.getChild(0)).getText();
    buf.append(fname.toLowerCase()).append(""String_Node_Str"");
    for (int i=1; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i != root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
  }
 else   if (TOK_TABSORTCOLNAMEDESC == rootType || TOK_TABSORTCOLNAMEASC == rootType) {
    for (int i=0; i < root.getChildCount(); i++) {
      StringBuilder orderByCol=new StringBuilder();
      toInfixString((ASTNode)root.getChild(i),orderByCol);
      String colStr=orderByCol.toString().trim();
      if (colStr.startsWith(""String_Node_Str"") && colStr.endsWith(""String_Node_Str"")) {
        colStr=colStr.substring(1,colStr.length() - 1);
      }
      buf.append(colStr);
      buf.append(""String_Node_Str"");
    }
    if (TOK_TABSORTCOLNAMEDESC == rootType) {
      buf.append(""String_Node_Str"");
    }
 else     if (TOK_TABSORTCOLNAMEASC == rootType) {
      buf.append(""String_Node_Str"");
    }
  }
 else   if (TOK_SELECT == rootType || TOK_ORDERBY == rootType || TOK_GROUPBY == rootType) {
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i != root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
  }
 else   if (TOK_SELECTDI == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i != root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
  }
 else   if (TOK_DIR == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else   if (TOK_LOCAL_DIR == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else   if (TOK_TAB == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else {
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
}","/** 
 * Recursively reconstruct query string given a query AST
 * @param root
 * @param buf  preallocated builder where the reconstructed string will be written
 */
public static void toInfixString(ASTNode root,StringBuilder buf){
  if (root == null) {
    return;
  }
  int rootType=root.getToken().getType();
  String rootText=root.getText();
  if (Identifier == rootType || Number == rootType || StringLiteral == rootType || KW_TRUE == rootType || KW_FALSE == rootType || KW_FORMATTED == rootType || KW_EXTENDED == rootType || KW_DEPENDENCY == rootType) {
    if (StringLiteral == rootType) {
      buf.append(' ').append(rootText).append(' ');
    }
 else     if (KW_TRUE == rootType) {
      buf.append(""String_Node_Str"");
    }
 else     if (KW_FALSE == rootType) {
      buf.append(""String_Node_Str"");
    }
 else     if (Identifier == rootType && TOK_SELEXPR == ((ASTNode)root.getParent()).getToken().getType() && hasSpaces(rootText)) {
      buf.append(""String_Node_Str"").append(rootText).append(""String_Node_Str"");
    }
 else     if (Identifier == rootType && TOK_FUNCTIONSTAR == ((ASTNode)root.getParent()).getToken().getType()) {
      buf.append(""String_Node_Str"").append(rootText == null ? ""String_Node_Str"" : rootText.toLowerCase());
    }
 else {
      buf.append(""String_Node_Str"").append(rootText == null ? ""String_Node_Str"" : rootText.toLowerCase()).append(""String_Node_Str"");
    }
  }
 else   if (TOK_ALLCOLREF == rootType) {
    if (root.getChildCount() > 0) {
      for (int i=0; i < root.getChildCount(); i++) {
        toInfixString((ASTNode)root.getChild(i),buf);
      }
      buf.append(""String_Node_Str"");
    }
    buf.append(""String_Node_Str"");
  }
 else   if (TOK_FUNCTIONSTAR == rootType) {
    if (root.getChildCount() > 0) {
      for (int i=0; i < root.getChildCount(); i++) {
        toInfixString((ASTNode)root.getChild(i),buf);
      }
    }
    buf.append(""String_Node_Str"");
  }
 else   if (UNARY_OPERATORS.contains(Integer.valueOf(rootType))) {
    if (KW_NOT == rootType) {
      if (!(findNodeByPath(root,TOK_FUNCTION,KW_IN) != null)) {
        buf.append(""String_Node_Str"");
      }
    }
 else     if (TILDE == rootType) {
      buf.append(""String_Node_Str"");
    }
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else   if (BINARY_OPERATORS.contains(Integer.valueOf(root.getToken().getType()))) {
    buf.append(""String_Node_Str"");
    if (MINUS == rootType && root.getChildCount() == 1) {
      buf.append(' ').append(rootText.toLowerCase()).append(' ');
      toInfixString((ASTNode)root.getChild(0),buf);
    }
 else {
      toInfixString((ASTNode)root.getChild(0),buf);
      if (root.getToken().getType() != DOT) {
        buf.append(' ').append(rootText.toLowerCase()).append(' ');
      }
 else {
        buf.append(rootText.toLowerCase());
      }
      toInfixString((ASTNode)root.getChild(1),buf);
    }
    buf.append(""String_Node_Str"");
  }
 else   if (LSQUARE == rootType) {
    toInfixString((ASTNode)root.getChild(0),buf);
    buf.append(""String_Node_Str"");
    toInfixString((ASTNode)root.getChild(1),buf);
    buf.append(""String_Node_Str"");
  }
 else   if (PRIMITIVE_TYPES.contains(rootType)) {
    if (rootType == TOK_TINYINT) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_SMALLINT) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_INT) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_BIGINT) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_BOOLEAN) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_FLOAT) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_DOUBLE) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_DATE) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_DATETIME) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_TIMESTAMP) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_STRING) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_BINARY) {
      buf.append(""String_Node_Str"");
    }
 else     if (rootType == TOK_DECIMAL) {
      buf.append(""String_Node_Str"");
      if (root.getChildCount() >= 1) {
        buf.append(""String_Node_Str"").append(root.getChild(0).getText());
        if (root.getChildCount() == 2) {
          buf.append(""String_Node_Str"").append(root.getChild(1).getText());
        }
        buf.append(""String_Node_Str"");
      }
    }
 else     if (rootType == TOK_VARCHAR) {
      buf.append(""String_Node_Str"");
      if (root.getChildCount() >= 1) {
        buf.append(""String_Node_Str"").append(root.getChild(0).getText()).append(""String_Node_Str"");
      }
    }
 else     if (rootType == TOK_CHAR) {
      buf.append(""String_Node_Str"");
      if (root.getChildCount() >= 1) {
        buf.append(""String_Node_Str"").append(root.getChild(0).getText()).append(""String_Node_Str"");
      }
    }
 else {
      buf.append(rootText);
    }
  }
 else   if (TOK_FUNCTION == root.getToken().getType()) {
    functionString(root,buf);
  }
 else   if (TOK_FUNCTIONDI == rootType) {
    String fname=((ASTNode)root.getChild(0)).getText();
    buf.append(fname.toLowerCase()).append(""String_Node_Str"");
    for (int i=1; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i != root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
  }
 else   if (TOK_TABSORTCOLNAMEDESC == rootType || TOK_TABSORTCOLNAMEASC == rootType) {
    for (int i=0; i < root.getChildCount(); i++) {
      StringBuilder orderByCol=new StringBuilder();
      toInfixString((ASTNode)root.getChild(i),orderByCol);
      String colStr=orderByCol.toString().trim();
      if (colStr.startsWith(""String_Node_Str"") && colStr.endsWith(""String_Node_Str"")) {
        colStr=colStr.substring(1,colStr.length() - 1);
      }
      buf.append(colStr);
      buf.append(""String_Node_Str"");
    }
    if (TOK_TABSORTCOLNAMEDESC == rootType) {
      buf.append(""String_Node_Str"");
    }
 else     if (TOK_TABSORTCOLNAMEASC == rootType) {
      buf.append(""String_Node_Str"");
    }
  }
 else   if (TOK_SELECT == rootType || TOK_ORDERBY == rootType || TOK_GROUPBY == rootType) {
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i != root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
  }
 else   if (TOK_SELECTDI == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
      if (i != root.getChildCount() - 1) {
        buf.append(""String_Node_Str"");
      }
    }
  }
 else   if (TOK_DIR == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else   if (TOK_LOCAL_DIR == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else   if (TOK_TAB == rootType) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < root.getChildCount(); i++) {
      toInfixString((ASTNode)root.getChild(i),buf);
    }
  }
 else {
    if (root.getChildCount() > 0) {
      for (int i=0; i < root.getChildCount(); i++) {
        toInfixString((ASTNode)root.getChild(i),buf);
      }
    }
 else {
      buf.append(rootText);
    }
  }
}",0.8484345529988684
25272,"private String getFromString() throws SemanticException {
  StringBuilder fromBuilder=new StringBuilder();
  int aliasCount=1;
  Iterator<CandidateFact> iter=facts.iterator();
  while (iter.hasNext()) {
    CandidateFact fact=iter.next();
    FactHQLContext facthql=new FactHQLContext(fact,dimsToQuery,factDimMap.get(fact),query);
    fromBuilder.append(""String_Node_Str"");
    fromBuilder.append(facthql.toHQL());
    fromBuilder.append(""String_Node_Str"");
    fromBuilder.append(""String_Node_Str"" + aliasCount);
    aliasCount++;
    if (iter.hasNext()) {
      fromBuilder.append(""String_Node_Str"");
    }
  }
  fromBuilder.append(""String_Node_Str"");
  CandidateFact firstFact=facts.iterator().next();
  for (int i=2; i <= facts.size(); i++) {
    Iterator<Integer> dimIter=firstFact.getDimFieldIndices().iterator();
    while (dimIter.hasNext()) {
      String dim=query.getSelectAlias(dimIter.next());
      fromBuilder.append(""String_Node_Str"").append(""String_Node_Str"").append(dim).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(dim);
      if (dimIter.hasNext()) {
        fromBuilder.append(""String_Node_Str"");
      }
    }
    if (i != facts.size()) {
      fromBuilder.append(""String_Node_Str"");
    }
  }
  return fromBuilder.toString();
}","private String getFromString() throws SemanticException {
  StringBuilder fromBuilder=new StringBuilder();
  int aliasCount=1;
  Iterator<CandidateFact> iter=facts.iterator();
  while (iter.hasNext()) {
    CandidateFact fact=iter.next();
    FactHQLContext facthql=new FactHQLContext(fact,dimsToQuery,factDimMap.get(fact),query);
    fromBuilder.append(""String_Node_Str"");
    fromBuilder.append(facthql.toHQL());
    fromBuilder.append(""String_Node_Str"");
    fromBuilder.append(""String_Node_Str"" + aliasCount);
    aliasCount++;
    if (iter.hasNext()) {
      fromBuilder.append(""String_Node_Str"");
    }
  }
  CandidateFact firstFact=facts.iterator().next();
  if (!firstFact.getDimFieldIndices().isEmpty()) {
    fromBuilder.append(""String_Node_Str"");
  }
  for (int i=2; i <= facts.size(); i++) {
    Iterator<Integer> dimIter=firstFact.getDimFieldIndices().iterator();
    while (dimIter.hasNext()) {
      String dim=query.getSelectAlias(dimIter.next());
      fromBuilder.append(""String_Node_Str"").append(""String_Node_Str"").append(dim).append(""String_Node_Str"").append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(dim);
      if (dimIter.hasNext()) {
        fromBuilder.append(""String_Node_Str"");
      }
    }
    if (i != facts.size()) {
      fromBuilder.append(""String_Node_Str"");
    }
  }
  return fromBuilder.toString();
}",0.9424162589386528
25273,"private String getSelectString() throws SemanticException {
  Map<Integer,Integer> selectToFactIndex=new HashMap<Integer,Integer>(query.getSelectAST().getChildCount());
  int fi=1;
  for (  CandidateFact fact : facts) {
    for (    int ind : fact.getSelectIndices()) {
      if (!selectToFactIndex.containsKey(ind)) {
        selectToFactIndex.put(ind,fi);
      }
    }
    fi++;
  }
  StringBuilder select=new StringBuilder();
  for (int i=0; i < query.getSelectAST().getChildCount(); i++) {
    if (selectToFactIndex.get(i) == null) {
      throw new SemanticException(ErrorMsg.EXPRESSION_NOT_IN_ANY_FACT,HQLParser.getString((ASTNode)query.getSelectAST().getChild(i)));
    }
    select.append(""String_Node_Str"").append(selectToFactIndex.get(i)).append(""String_Node_Str"").append(query.getSelectAlias(i)).append(""String_Node_Str"").append(query.getSelectFinalAlias(i));
    if (i != query.getSelectAST().getChildCount() - 1) {
      select.append(""String_Node_Str"");
    }
  }
  return select.toString();
}","private String getSelectString() throws SemanticException {
  Map<Integer,List<Integer>> selectToFactIndex=new HashMap<Integer,List<Integer>>(query.getSelectAST().getChildCount());
  int fi=1;
  for (  CandidateFact fact : facts) {
    for (    int ind : fact.getSelectIndices()) {
      if (!selectToFactIndex.containsKey(ind)) {
        selectToFactIndex.put(ind,Lists.<Integer>newArrayList());
      }
      selectToFactIndex.get(ind).add(fi);
    }
    fi++;
  }
  StringBuilder select=new StringBuilder();
  for (int i=0; i < query.getSelectAST().getChildCount(); i++) {
    if (selectToFactIndex.get(i) == null) {
      throw new SemanticException(ErrorMsg.EXPRESSION_NOT_IN_ANY_FACT,HQLParser.getString((ASTNode)query.getSelectAST().getChild(i)));
    }
    if (selectToFactIndex.get(i).size() == 1) {
      select.append(""String_Node_Str"").append(selectToFactIndex.get(i).get(0)).append(""String_Node_Str"").append(query.getSelectAlias(i)).append(""String_Node_Str"");
    }
 else {
      select.append(""String_Node_Str"");
      String sep=""String_Node_Str"";
      for (      Integer factIndex : selectToFactIndex.get(i)) {
        select.append(sep).append(""String_Node_Str"").append(factIndex).append(""String_Node_Str"").append(query.getSelectAlias(i));
        sep=""String_Node_Str"";
      }
      select.append(""String_Node_Str"");
    }
    select.append(query.getSelectFinalAlias(i));
    if (i != query.getSelectAST().getChildCount() - 1) {
      select.append(""String_Node_Str"");
    }
  }
  return select.toString();
}",0.777602523659306
25274,"/** 
 * Adds the dim1 table.
 * @param tableName   the table name
 * @param specName    the spec name
 * @param storageName the storage name
 * @throws IOException
 */
public static synchronized void addDim1Table(String tableName,String specName,String storageName) throws IOException {
  LensDimensionTableCommands command=getCommand();
  String dimList=command.showDimensionTables(null);
  Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
  TestLensStorageCommands.addLocalStorage(storageName);
  URL dimSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(specName);
  try {
    command.createDimensionTable(new File(dimSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  dimList=command.showDimensionTables(null);
  Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
  try {
    Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
  }
  try {
    Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
  }
  Assert.assertTrue(dimList.contains(tableName),""String_Node_Str"");
}","/** 
 * Adds the dim1 table.
 * @param tableName   the table name
 * @param specName    the spec name
 * @param storageName the storage name
 * @throws IOException
 */
public static synchronized void addDim1Table(String tableName,String specName,String storageName) throws IOException {
  LensDimensionTableCommands command=getCommand();
  String dimList=command.showDimensionTables(null);
  Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
  TestLensStorageCommands.addLocalStorage(storageName);
  URL dimSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(specName);
  try {
    command.createDimensionTable(new File(dimSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  dimList=command.showDimensionTables(null);
  Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
  try {
    Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
    LOG.info(""String_Node_Str"",e);
  }
  try {
    Assert.assertEquals(command.showDimensionTables(""String_Node_Str""),dimList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
    LOG.info(""String_Node_Str"",e);
  }
  Assert.assertTrue(dimList.contains(tableName),""String_Node_Str"");
}",0.9738805970149254
25275,"/** 
 * Adds the fact1 table.
 * @throws IOException
 */
public static void addFact1Table() throws IOException {
  LensFactCommands command=getCommand();
  String factList=command.showFacts(null);
  Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
  Assert.assertEquals(""String_Node_Str"",factList,""String_Node_Str"");
  TestLensStorageCommands.addLocalStorage(FACT_LOCAL);
  URL factSpec=TestLensFactCommands.class.getClassLoader().getResource(""String_Node_Str"");
  try {
    command.createFact(new File(factSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  factList=command.showFacts(null);
  Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
  try {
    Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
  }
  try {
    Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
  }
  Assert.assertEquals(""String_Node_Str"",factList,""String_Node_Str"");
}","/** 
 * Adds the fact1 table.
 * @throws IOException
 */
public static void addFact1Table() throws IOException {
  LensFactCommands command=getCommand();
  String factList=command.showFacts(null);
  Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
  Assert.assertEquals(""String_Node_Str"",factList,""String_Node_Str"");
  TestLensStorageCommands.addLocalStorage(FACT_LOCAL);
  URL factSpec=TestLensFactCommands.class.getClassLoader().getResource(""String_Node_Str"");
  try {
    command.createFact(new File(factSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  factList=command.showFacts(null);
  Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
  try {
    Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
    LOG.info(""String_Node_Str"",e);
  }
  try {
    Assert.assertEquals(command.showFacts(""String_Node_Str""),factList);
    Assert.fail();
  }
 catch (  NotFoundException e) {
    LOG.info(""String_Node_Str"",e);
  }
  Assert.assertEquals(""String_Node_Str"",factList,""String_Node_Str"");
}",0.969217238346526
25276,"public static Properties getPropertiesObj(String filename){
  try {
    if (properties == null) {
      properties=new Properties();
      LOGGER.info(""String_Node_Str"" + filename);
      InputStream confStream=Util.class.getResourceAsStream(""String_Node_Str"" + filename);
      properties.load(confStream);
      confStream.close();
    }
    return properties;
  }
 catch (  IOException e) {
    LOGGER.info(e.getStackTrace());
  }
  return null;
}","public static synchronized Properties getPropertiesObj(String filename){
  try {
    if (properties == null) {
      properties=new Properties();
      LOGGER.info(""String_Node_Str"" + filename);
      InputStream confStream=Util.class.getResourceAsStream(""String_Node_Str"" + filename);
      properties.load(confStream);
      confStream.close();
    }
    return properties;
  }
 catch (  IOException e) {
    LOGGER.info(e.getStackTrace());
  }
  return null;
}",0.9857612267250822
25277,"public static void writeFile(String fileName,String str){
  try {
    PrintWriter out=new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
    out.println(str);
    out.close();
  }
 catch (  IOException e) {
    LOGGER.info(""String_Node_Str"" + e);
  }
}","public static void writeFile(String fileName,String str){
  try {
    PrintWriter out=new PrintWriter(fileName,""String_Node_Str"");
    out.println(str);
    out.close();
  }
 catch (  IOException e) {
    LOGGER.info(""String_Node_Str"" + e);
  }
}",0.8705882352941177
25278,"/** 
 * Get the max update period for the given range and available update periods
 * @param from
 * @param to
 * @param updatePeriods
 * @return
 */
public static UpdatePeriod maxIntervalInRange(Date from,Date to,Set<UpdatePeriod> updatePeriods){
  UpdatePeriod max=null;
  long diff=to.getTime() - from.getTime();
  if (diff < UpdatePeriod.MIN_INTERVAL) {
    return null;
  }
  UpdatePeriodComparator cmp=new UpdatePeriodComparator();
  for (  UpdatePeriod i : updatePeriods) {
    if (UpdatePeriod.YEARLY == i || UpdatePeriod.QUARTERLY == i || UpdatePeriod.MONTHLY == i || UpdatePeriod.WEEKLY == i) {
      int intervals=0;
switch (i) {
case YEARLY:
        intervals=DateUtil.getYearsBetween(from,to);
      break;
case QUARTERLY:
    intervals=DateUtil.getQuartersBetween(from,to);
  break;
case MONTHLY:
intervals=DateUtil.getMonthsBetween(from,to);
break;
case WEEKLY:
intervals=DateUtil.getWeeksBetween(from,to);
break;
}
if (intervals > 0) {
if (cmp.compare(i,max) > 0) {
max=i;
}
}
}
 else {
if (diff < i.weight()) {
continue;
}
if (cmp.compare(i,max) > 0) {
max=i;
}
}
}
return max;
}","/** 
 * Get the max update period for the given range and available update periods
 * @param from
 * @param to
 * @param updatePeriods
 * @return
 */
public static UpdatePeriod maxIntervalInRange(Date from,Date to,Set<UpdatePeriod> updatePeriods){
  UpdatePeriod max=null;
  long diff=to.getTime() - from.getTime();
  if (diff < UpdatePeriod.MIN_INTERVAL) {
    return null;
  }
  UpdatePeriodComparator cmp=new UpdatePeriodComparator();
  for (  UpdatePeriod i : updatePeriods) {
    if (UpdatePeriod.YEARLY == i || UpdatePeriod.QUARTERLY == i || UpdatePeriod.MONTHLY == i || UpdatePeriod.WEEKLY == i) {
      int intervals=DateUtil.getTimeDiff(from,to,i);
      if (intervals > 0) {
        if (cmp.compare(i,max) > 0) {
          max=i;
        }
      }
    }
 else {
      if (diff < i.weight()) {
        continue;
      }
      if (cmp.compare(i,max) > 0) {
        max=i;
      }
    }
  }
  return max;
}",0.7217521154803385
25279,"static long getTimeDiff(Date from,Date to,UpdatePeriod interval){
  long diff=to.getTime() - from.getTime();
switch (interval) {
case SECONDLY:
    return diff / 1000;
case MINUTELY:
  return diff / (1000 * 60);
case HOURLY:
return diff / (1000 * 60 * 60);
case DAILY:
return diff / (1000 * 60 * 60* 24);
case WEEKLY:
return getWeeksBetween(from,to);
case MONTHLY:
return getMonthsBetween(from,to);
case QUARTERLY:
return getQuartersBetween(from,to);
case YEARLY:
return getYearsBetween(from,to);
default :
return -1;
}
}","public static int getTimeDiff(Date fromDate,Date toDate,UpdatePeriod updatePeriod){
  return getCoveringInfo(fromDate,toDate,updatePeriod).getCountBetween();
}",0.2470588235294117
25280,"private void resolveFactStoragePartitions(CubeQueryContext cubeql) throws SemanticException {
  Iterator<CandidateFact> i=cubeql.getCandidateFactTables().iterator();
  while (i.hasNext()) {
    CandidateFact cfact=i.next();
    List<FactPartition> answeringParts=new ArrayList<FactPartition>();
    HashMap<String,SkipStorageCause> skipStorageCauses=new HashMap<String,SkipStorageCause>();
    Map<UpdatePeriod,RangesPartitionTimeline> missingPartitionRanges=Maps.newHashMap();
    boolean noPartsForRange=false;
    for (    TimeRange range : cubeql.getTimeRanges()) {
      Set<FactPartition> rangeParts=getPartitions(cfact.fact,range,skipStorageCauses,missingPartitionRanges);
      if (rangeParts == null || rangeParts.isEmpty()) {
        LOG.info(""String_Node_Str"" + range);
        noPartsForRange=true;
        continue;
      }
      cfact.incrementPartsQueried(rangeParts.size());
      answeringParts.addAll(rangeParts);
      cfact.getPartsQueried().addAll(rangeParts);
      cfact.getRangeToWhereClause().put(range,rangeWriter.getTimeRangeWhereClause(cubeql,cubeql.getAliasForTabName(cubeql.getCube().getName()),rangeParts));
    }
    Set<String> nonExistingParts=Sets.newHashSet();
    if (!missingPartitionRanges.isEmpty()) {
      for (      UpdatePeriod period : missingPartitionRanges.keySet()) {
        for (        TimePartition.TimePartitionRange range : missingPartitionRanges.get(period).getRanges()) {
          nonExistingParts.add(range.toString());
        }
      }
    }
    if (!nonExistingParts.isEmpty()) {
      addNonExistingParts(cfact.fact.getName(),nonExistingParts);
    }
    if (cfact.getNumQueriedParts() == 0 || (failOnPartialData && (noPartsForRange || !nonExistingParts.isEmpty()))) {
      LOG.info(""String_Node_Str"" + cfact.fact + ""String_Node_Str""+ ""String_Node_Str""+ cubeql.getTimeRanges());
      if (!nonExistingParts.isEmpty()) {
        cubeql.addFactPruningMsgs(cfact.fact,CandidateTablePruneCause.missingPartitions(nonExistingParts));
      }
 else       if (!skipStorageCauses.isEmpty()) {
        CandidateTablePruneCause cause=CandidateTablePruneCause.noCandidateStorages(skipStorageCauses);
        cubeql.addFactPruningMsgs(cfact.fact,cause);
      }
 else {
        CandidateTablePruneCause cause=new CandidateTablePruneCause(CandidateTablePruneCode.NO_FACT_UPDATE_PERIODS_FOR_GIVEN_RANGE);
        cubeql.addFactPruningMsgs(cfact.fact,cause);
      }
      i.remove();
      continue;
    }
    Map<String,Set<FactPartition>> minimalStorageTables=new LinkedHashMap<String,Set<FactPartition>>();
    boolean enabledMultiTableSelect=StorageUtil.getMinimalAnsweringTables(answeringParts,minimalStorageTables);
    if (minimalStorageTables.isEmpty()) {
      LOG.info(""String_Node_Str"" + cfact + ""String_Node_Str""+ ""String_Node_Str"");
      cubeql.addFactPruningMsgs(cfact.fact,CandidateTablePruneCause.noCandidateStorages(skipStorageCauses));
      i.remove();
      continue;
    }
    Set<String> storageTables=new LinkedHashSet<String>();
    storageTables.addAll(minimalStorageTables.keySet());
    cfact.setStorageTables(storageTables);
    if (cfact.isEnabledMultiTableSelect()) {
      cfact.setEnabledMultiTableSelect(enabledMultiTableSelect);
    }
    LOG.info(""String_Node_Str"" + cfact + ""String_Node_Str""+ answeringParts+ ""String_Node_Str""+ storageTables);
  }
}","private void resolveFactStoragePartitions(CubeQueryContext cubeql) throws SemanticException {
  Iterator<CandidateFact> i=cubeql.getCandidateFactTables().iterator();
  while (i.hasNext()) {
    CandidateFact cfact=i.next();
    List<FactPartition> answeringParts=new ArrayList<FactPartition>();
    HashMap<String,SkipStorageCause> skipStorageCauses=new HashMap<String,SkipStorageCause>();
    Map<UpdatePeriod,RangesPartitionTimeline> missingPartitionRanges=Maps.newHashMap();
    boolean noPartsForRange=false;
    for (    TimeRange range : cubeql.getTimeRanges()) {
      Set<FactPartition> rangeParts=getPartitions(cfact.fact,range,skipStorageCauses,missingPartitionRanges);
      if (rangeParts == null || rangeParts.isEmpty()) {
        LOG.info(""String_Node_Str"" + range);
        noPartsForRange=true;
        continue;
      }
      cfact.incrementPartsQueried(rangeParts.size());
      answeringParts.addAll(rangeParts);
      cfact.getPartsQueried().addAll(rangeParts);
      cfact.getRangeToWhereClause().put(range,rangeWriter.getTimeRangeWhereClause(cubeql,cubeql.getAliasForTabName(cubeql.getCube().getName()),rangeParts));
    }
    Set<String> nonExistingParts=Sets.newHashSet();
    if (!missingPartitionRanges.isEmpty()) {
      for (      UpdatePeriod period : missingPartitionRanges.keySet()) {
        for (        TimePartition.TimePartitionRange range : missingPartitionRanges.get(period).getRanges()) {
          nonExistingParts.add(range.toString());
        }
      }
    }
    if (!nonExistingParts.isEmpty()) {
      addNonExistingParts(cfact.fact.getName(),nonExistingParts);
    }
    if (cfact.getNumQueriedParts() == 0 || (failOnPartialData && (noPartsForRange || !nonExistingParts.isEmpty()))) {
      LOG.info(""String_Node_Str"" + cfact.fact + ""String_Node_Str""+ ""String_Node_Str""+ cubeql.getTimeRanges());
      if (failOnPartialData && !nonExistingParts.isEmpty()) {
        cubeql.addFactPruningMsgs(cfact.fact,CandidateTablePruneCause.missingPartitions(nonExistingParts));
      }
 else       if (!skipStorageCauses.isEmpty()) {
        CandidateTablePruneCause cause=CandidateTablePruneCause.noCandidateStorages(skipStorageCauses);
        cubeql.addFactPruningMsgs(cfact.fact,cause);
      }
 else {
        CandidateTablePruneCause cause=new CandidateTablePruneCause(CandidateTablePruneCode.NO_FACT_UPDATE_PERIODS_FOR_GIVEN_RANGE);
        cubeql.addFactPruningMsgs(cfact.fact,cause);
      }
      i.remove();
      continue;
    }
    Map<String,Set<FactPartition>> minimalStorageTables=new LinkedHashMap<String,Set<FactPartition>>();
    boolean enabledMultiTableSelect=StorageUtil.getMinimalAnsweringTables(answeringParts,minimalStorageTables);
    if (minimalStorageTables.isEmpty()) {
      LOG.info(""String_Node_Str"" + cfact + ""String_Node_Str""+ ""String_Node_Str"");
      cubeql.addFactPruningMsgs(cfact.fact,CandidateTablePruneCause.noCandidateStorages(skipStorageCauses));
      i.remove();
      continue;
    }
    Set<String> storageTables=new LinkedHashSet<String>();
    storageTables.addAll(minimalStorageTables.keySet());
    cfact.setStorageTables(storageTables);
    if (cfact.isEnabledMultiTableSelect()) {
      cfact.setEnabledMultiTableSelect(enabledMultiTableSelect);
    }
    LOG.info(""String_Node_Str"" + cfact + ""String_Node_Str""+ answeringParts+ ""String_Node_Str""+ storageTables);
  }
}",0.9968605172671552
25281,"@Test public void testCubeWhereQueryForMonthWithNoPartialData() throws Exception {
  Configuration conf=getConf();
  conf.setBoolean(CubeQueryConfUtil.FAIL_QUERY_ON_PARTIAL_DATA,true);
  SemanticException e=getSemanticExceptionInRewrite(""String_Node_Str"" + ""String_Node_Str"" + TWO_MONTHS_RANGE_UPTO_HOURS,conf);
  Assert.assertEquals(e.getCanonicalErrorMsg().getErrorCode(),ErrorMsg.NO_CANDIDATE_FACT_AVAILABLE.getErrorCode());
  PruneCauses.BriefAndDetailedError pruneCauses=extractPruneCause(e);
  Assert.assertEquals(pruneCauses.getBrief().substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3),CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3));
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.NO_CANDIDATE_STORAGES);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.NO_CANDIDATE_STORAGES);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getStorageCauses().values().iterator().next().getCause(),SkipStorageCode.PART_COL_DOES_NOT_EXIST);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getStorageCauses().values().iterator().next().getNonExistantPartCols(),Arrays.asList(""String_Node_Str""));
}","@Test public void testCubeWhereQueryForMonthWithNoPartialData() throws Exception {
  Configuration conf=getConf();
  conf.setBoolean(CubeQueryConfUtil.FAIL_QUERY_ON_PARTIAL_DATA,true);
  SemanticException e=getSemanticExceptionInRewrite(""String_Node_Str"" + ""String_Node_Str"" + TWO_MONTHS_RANGE_UPTO_HOURS,conf);
  Assert.assertEquals(e.getCanonicalErrorMsg().getErrorCode(),ErrorMsg.NO_CANDIDATE_FACT_AVAILABLE.getErrorCode());
  PruneCauses.BriefAndDetailedError pruneCauses=extractPruneCause(e);
  Assert.assertEquals(pruneCauses.getBrief().substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3),CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3));
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.NO_FACT_UPDATE_PERIODS_FOR_GIVEN_RANGE);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.NO_CANDIDATE_STORAGES);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.NO_CANDIDATE_STORAGES);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getStorageCauses().values().iterator().next().getCause(),SkipStorageCode.PART_COL_DOES_NOT_EXIST);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getStorageCauses().values().iterator().next().getNonExistantPartCols(),Arrays.asList(""String_Node_Str""));
}",0.9880073800738008
25282,"public Table getTable(String tableName) throws HiveException {
  Table tbl;
  try {
    tableName=tableName.trim().toLowerCase();
    tbl=allHiveTables.get(tableName);
    if (tbl == null) {
synchronized (allHiveTables) {
        if (!allHiveTables.containsKey(tableName)) {
          tbl=getClient().getTable(tableName);
          if (enableCaching) {
            allHiveTables.put(tableName,tbl);
          }
        }
      }
    }
  }
 catch (  HiveException e) {
    throw new HiveException(""String_Node_Str"" + tableName,e);
  }
  return tbl;
}","public Table getTable(String tableName) throws HiveException {
  Table tbl;
  try {
    tableName=tableName.trim().toLowerCase();
    tbl=allHiveTables.get(tableName);
    if (tbl == null) {
synchronized (allHiveTables) {
        if (!allHiveTables.containsKey(tableName)) {
          tbl=getClient().getTable(tableName);
          if (enableCaching) {
            allHiveTables.put(tableName,tbl);
          }
        }
 else {
          tbl=allHiveTables.get(tableName);
        }
      }
    }
  }
 catch (  HiveException e) {
    throw new HiveException(""String_Node_Str"" + tableName,e);
  }
  return tbl;
}",0.946551724137931
25283,"/** 
 * Get   {@link Cube} object corresponding to the name
 * @param tableName The cube name
 * @return Returns cube is table name passed is a cube, null otherwise
 * @throws HiveException
 */
public CubeFactTable getCubeFact(String tableName) throws HiveException {
  tableName=tableName.trim().toLowerCase();
  CubeFactTable fact=allFactTables.get(tableName);
  if (fact == null) {
synchronized (allFactTables) {
      if (!allFactTables.containsKey(tableName)) {
        fact=getFactTable(tableName);
        if (enableCaching && fact != null) {
          allFactTables.put(tableName,fact);
        }
      }
    }
  }
  return fact;
}","/** 
 * Get   {@link Cube} object corresponding to the name
 * @param tableName The cube name
 * @return Returns cube is table name passed is a cube, null otherwise
 * @throws HiveException
 */
public CubeFactTable getCubeFact(String tableName) throws HiveException {
  tableName=tableName.trim().toLowerCase();
  CubeFactTable fact=allFactTables.get(tableName);
  if (fact == null) {
synchronized (allFactTables) {
      if (!allFactTables.containsKey(tableName)) {
        fact=getFactTable(tableName);
        if (enableCaching && fact != null) {
          allFactTables.put(tableName,fact);
        }
      }
 else {
        fact=allFactTables.get(tableName);
      }
    }
  }
  return fact;
}",0.955871353777113
25284,"private void doColLifeValidation(CubeQueryContext cubeql) throws SemanticException {
  Set<String> cubeColumns=cubeql.getColumnsQueried(cubeql.getCube().getName());
  if (cubeColumns == null || cubeColumns.isEmpty()) {
    return;
  }
  for (  String col : cubeql.getColumnsQueried(cubeql.getCube().getName())) {
    CubeColumn column=cubeql.getCube().getColumnByName(col);
    for (    TimeRange range : cubeql.getTimeRanges()) {
      if (column == null) {
        if (!cubeql.getCube().getTimedDimensions().contains(col)) {
          throw new SemanticException(ErrorMsg.NOT_A_CUBE_COLUMN);
        }
        continue;
      }
      if (isColumnLifeInvalid(column,range)) {
        throw new SemanticException(ErrorMsg.NOT_AVAILABLE_IN_RANGE,col,range.toString(),(column.getStartTime() == null ? ""String_Node_Str"" : ""String_Node_Str"" + column.getStartTime()),(column.getEndTime() == null ? ""String_Node_Str"" : ""String_Node_Str"" + column.getEndTime()));
      }
    }
  }
  Map<String,Set<ReferencedQueriedColumn>> refCols=cubeql.getDenormCtx().getReferencedCols();
  for (  String col : refCols.keySet()) {
    Iterator<ReferencedQueriedColumn> refColIter=refCols.get(col).iterator();
    while (refColIter.hasNext()) {
      ReferencedQueriedColumn refCol=refColIter.next();
      for (      TimeRange range : cubeql.getTimeRanges()) {
        if (isColumnLifeInvalid(refCol.col,range)) {
          LOG.debug(""String_Node_Str"" + refCol.col.getName() + ""String_Node_Str"");
          refColIter.remove();
          break;
        }
      }
    }
  }
  JoinResolver.AutoJoinContext joinContext=cubeql.getAutoJoinCtx();
  if (joinContext == null) {
    return;
  }
  Set<String> joinColumns=joinContext.getAllJoinPathColumnsOfTable((AbstractCubeTable)cubeql.getCube());
  if (joinColumns == null || joinColumns.isEmpty()) {
    return;
  }
  for (  String col : joinColumns) {
    CubeColumn column=cubeql.getCube().getColumnByName(col);
    for (    TimeRange range : cubeql.getTimeRanges()) {
      if (isColumnLifeInvalid(column,range)) {
        LOG.info(""String_Node_Str"" + column + ""String_Node_Str"");
        Map<Aliased<Dimension>,List<SchemaGraph.JoinPath>> allPaths=joinContext.getAllPaths();
        for (        Aliased<Dimension> dimension : allPaths.keySet()) {
          List<SchemaGraph.JoinPath> joinPaths=allPaths.get(dimension);
          Iterator<SchemaGraph.JoinPath> joinPathIterator=joinPaths.iterator();
          while (joinPathIterator.hasNext()) {
            SchemaGraph.JoinPath path=joinPathIterator.next();
            if (path.containsColumnOfTable(col,(AbstractCubeTable)cubeql.getCube())) {
              LOG.info(""String_Node_Str"" + path + ""String_Node_Str""+ col+ ""String_Node_Str"");
              joinPathIterator.remove();
              if (joinPaths.isEmpty()) {
                throw new SemanticException(ErrorMsg.NO_JOIN_PATH,""String_Node_Str"" + dimension + ""String_Node_Str""+ range.getFromDate()+ ""String_Node_Str""+ range.getToDate());
              }
            }
          }
        }
      }
    }
  }
}","private void doColLifeValidation(CubeQueryContext cubeql) throws SemanticException {
  Set<String> cubeColumns=cubeql.getColumnsQueried(cubeql.getCube().getName());
  if (cubeColumns == null || cubeColumns.isEmpty()) {
    return;
  }
  for (  String col : cubeql.getColumnsQueried(cubeql.getCube().getName())) {
    CubeColumn column=cubeql.getCube().getColumnByName(col);
    for (    TimeRange range : cubeql.getTimeRanges()) {
      if (column == null) {
        if (!cubeql.getCube().getTimedDimensions().contains(col)) {
          throw new SemanticException(ErrorMsg.NOT_A_CUBE_COLUMN,col);
        }
        continue;
      }
      if (isColumnLifeInvalid(column,range)) {
        throw new SemanticException(ErrorMsg.NOT_AVAILABLE_IN_RANGE,col,range.toString(),(column.getStartTime() == null ? ""String_Node_Str"" : ""String_Node_Str"" + column.getStartTime()),(column.getEndTime() == null ? ""String_Node_Str"" : ""String_Node_Str"" + column.getEndTime()));
      }
    }
  }
  Map<String,Set<ReferencedQueriedColumn>> refCols=cubeql.getDenormCtx().getReferencedCols();
  for (  String col : refCols.keySet()) {
    Iterator<ReferencedQueriedColumn> refColIter=refCols.get(col).iterator();
    while (refColIter.hasNext()) {
      ReferencedQueriedColumn refCol=refColIter.next();
      for (      TimeRange range : cubeql.getTimeRanges()) {
        if (isColumnLifeInvalid(refCol.col,range)) {
          LOG.debug(""String_Node_Str"" + refCol.col.getName() + ""String_Node_Str"");
          refColIter.remove();
          break;
        }
      }
    }
  }
  JoinResolver.AutoJoinContext joinContext=cubeql.getAutoJoinCtx();
  if (joinContext == null) {
    return;
  }
  Set<String> joinColumns=joinContext.getAllJoinPathColumnsOfTable((AbstractCubeTable)cubeql.getCube());
  if (joinColumns == null || joinColumns.isEmpty()) {
    return;
  }
  for (  String col : joinColumns) {
    CubeColumn column=cubeql.getCube().getColumnByName(col);
    for (    TimeRange range : cubeql.getTimeRanges()) {
      if (isColumnLifeInvalid(column,range)) {
        LOG.info(""String_Node_Str"" + column + ""String_Node_Str"");
        Map<Aliased<Dimension>,List<SchemaGraph.JoinPath>> allPaths=joinContext.getAllPaths();
        for (        Aliased<Dimension> dimension : allPaths.keySet()) {
          List<SchemaGraph.JoinPath> joinPaths=allPaths.get(dimension);
          Iterator<SchemaGraph.JoinPath> joinPathIterator=joinPaths.iterator();
          while (joinPathIterator.hasNext()) {
            SchemaGraph.JoinPath path=joinPathIterator.next();
            if (path.containsColumnOfTable(col,(AbstractCubeTable)cubeql.getCube())) {
              LOG.info(""String_Node_Str"" + path + ""String_Node_Str""+ col+ ""String_Node_Str"");
              joinPathIterator.remove();
              if (joinPaths.isEmpty()) {
                throw new SemanticException(ErrorMsg.NO_JOIN_PATH,""String_Node_Str"" + dimension + ""String_Node_Str""+ range.getFromDate()+ ""String_Node_Str""+ range.getToDate());
              }
            }
          }
        }
      }
    }
  }
}",0.9993444772205834
25285,"@Test public void testLightestFactFirst() throws Exception {
  String hqlQuery=rewrite(""String_Node_Str"" + ""String_Node_Str"" + twoDaysRange,getConf());
  String expected=getExpectedQuery(cubeName,""String_Node_Str"",null,null,getWhereForDailyAndHourly2days(cubeName,""String_Node_Str""));
  compareQueries(expected,hqlQuery);
  Configuration conf=getConf();
  conf.setBoolean(CubeQueryConfUtil.FAIL_QUERY_ON_PARTIAL_DATA,true);
  hqlQuery=rewrite(""String_Node_Str"" + ""String_Node_Str"" + twoDaysRange,conf);
  expected=getExpectedQuery(cubeName,""String_Node_Str"",null,null,getWhereForHourly2days(""String_Node_Str""));
  compareQueries(expected,hqlQuery);
  conf.setBoolean(CubeQueryConfUtil.LIGHTEST_FACT_FIRST,true);
  conf.setBoolean(CubeQueryConfUtil.ADD_NON_EXISTING_PARTITIONS,true);
  SemanticException th=getSemanticExceptionInRewrite(""String_Node_Str"" + ""String_Node_Str"" + twoDaysRange,conf);
  Assert.assertEquals(th.getCanonicalErrorMsg().getErrorCode(),ErrorMsg.NO_CANDIDATE_FACT_AVAILABLE.getErrorCode());
  PruneCauses.BriefAndDetailedError pruneCauses=extractPruneCause(th);
  Assert.assertEquals(pruneCauses.getBrief().substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3),CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3));
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").size(),1);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  conf.setBoolean(CubeQueryConfUtil.ADD_NON_EXISTING_PARTITIONS,false);
  th=getSemanticExceptionInRewrite(""String_Node_Str"" + ""String_Node_Str"" + TWO_DAYS_RANGE,conf);
  Assert.assertEquals(th.getCanonicalErrorMsg().getErrorCode(),ErrorMsg.NO_CANDIDATE_FACT_AVAILABLE.getErrorCode());
  pruneCauses=extractPruneCause(th);
  Assert.assertEquals(pruneCauses.getBrief().substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3),CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3));
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").size(),1);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").size(),1);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.NO_FACT_UPDATE_PERIODS_FOR_GIVEN_RANGE);
}","@Test public void testLightestFactFirst() throws Exception {
  String hqlQuery=rewrite(""String_Node_Str"" + ""String_Node_Str"" + twoDaysRange,getConf());
  String expected=getExpectedQuery(cubeName,""String_Node_Str"",null,null,getWhereForDailyAndHourly2days(cubeName,""String_Node_Str""));
  compareQueries(expected,hqlQuery);
  Configuration conf=getConf();
  conf.setBoolean(CubeQueryConfUtil.FAIL_QUERY_ON_PARTIAL_DATA,true);
  hqlQuery=rewrite(""String_Node_Str"" + ""String_Node_Str"" + twoDaysRange,conf);
  expected=getExpectedQuery(cubeName,""String_Node_Str"",null,null,getWhereForHourly2days(""String_Node_Str""));
  compareQueries(expected,hqlQuery);
  conf.setBoolean(CubeQueryConfUtil.LIGHTEST_FACT_FIRST,true);
  conf.setBoolean(CubeQueryConfUtil.ADD_NON_EXISTING_PARTITIONS,true);
  SemanticException th=getSemanticExceptionInRewrite(""String_Node_Str"" + ""String_Node_Str"" + twoDaysRange,conf);
  Assert.assertEquals(th.getCanonicalErrorMsg().getErrorCode(),ErrorMsg.NO_CANDIDATE_FACT_AVAILABLE.getErrorCode());
  PruneCauses.BriefAndDetailedError pruneCauses=extractPruneCause(th);
  Assert.assertEquals(pruneCauses.getBrief().substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3),CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3));
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").size(),1);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  conf.setBoolean(CubeQueryConfUtil.ADD_NON_EXISTING_PARTITIONS,false);
  th=getSemanticExceptionInRewrite(""String_Node_Str"" + ""String_Node_Str"" + twoDaysRange,conf);
  Assert.assertEquals(th.getCanonicalErrorMsg().getErrorCode(),ErrorMsg.NO_CANDIDATE_FACT_AVAILABLE.getErrorCode());
  pruneCauses=extractPruneCause(th);
  Assert.assertEquals(pruneCauses.getBrief().substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3),CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.substring(0,CandidateTablePruneCode.MISSING_PARTITIONS.errorFormat.length() - 3));
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").size(),1);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.MISSING_PARTITIONS);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").size(),1);
  Assert.assertEquals(pruneCauses.getDetails().get(""String_Node_Str"").iterator().next().getCause(),CandidateTablePruneCode.NO_FACT_UPDATE_PERIODS_FOR_GIVEN_RANGE);
}",0.9958174904942966
25286,"/** 
 * Adds the dim1 table.
 * @param tableName the table name
 * @param specName the spec name
 * @param storageSpecName the storage spec name
 * @param storageName the storage name
 */
public static void addDim1Table(String tableName,String specName,String storageSpecName,String storageName){
  LensDimensionTableCommands command=getCommand();
  String dimList=command.showDimensionTables();
  Assert.assertEquals(""String_Node_Str"",dimList,""String_Node_Str"");
  TestLensStorageCommands.addLocalStorage(storageName);
  URL dimSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(specName);
  URL factStorageSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(storageSpecName);
  try {
    command.createDimensionTable(new File(dimSpec.toURI()).getAbsolutePath() + ""String_Node_Str"" + new File(factStorageSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  dimList=command.showDimensionTables();
  Assert.assertEquals(tableName,dimList,""String_Node_Str"");
}","/** 
 * Adds the dim1 table.
 * @param tableName the table name
 * @param specName the spec name
 * @param storageSpecName the storage spec name
 * @param storageName the storage name
 */
public synchronized static void addDim1Table(String tableName,String specName,String storageSpecName,String storageName){
  LensDimensionTableCommands command=getCommand();
  String dimList=command.showDimensionTables();
  TestLensStorageCommands.addLocalStorage(storageName);
  URL dimSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(specName);
  URL factStorageSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(storageSpecName);
  try {
    command.createDimensionTable(new File(dimSpec.toURI()).getAbsolutePath() + ""String_Node_Str"" + new File(factStorageSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  dimList=command.showDimensionTables();
  Assert.assertTrue(dimList.contains(tableName),""String_Node_Str"");
}",0.936768149882904
25287,"@Override public Date getLatestDateOfCube(LensSessionHandle sessionid,String cubeName,String timeDimension) throws LensException, HiveException {
  acquire(sessionid);
  CubeInterface ci=getClient(sessionid).getCube(cubeName);
  if (!(ci instanceof Cube)) {
    throw new BadRequestException(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  }
  Cube c=(Cube)ci;
  String partitionColumn=c.getPartitionColumnOfTimeDim(timeDimension);
  List<FactTable> factTables=getAllFactsOfCube(sessionid,cubeName);
  Date latestDate=null;
  if (factTables != null && !factTables.isEmpty()) {
    for (    FactTable factTable : factTables) {
      List<String> storages=getStoragesOfFact(sessionid,factTable.getName());
      if (storages != null && !storages.isEmpty()) {
        for (        String storage : storages) {
          String storageTableName=MetastoreUtil.getFactStorageTableName(factTable.getName(),storage);
          List<Partition> parts=getClient(sessionid).getPartitionsByFilter(storageTableName,StorageConstants.getLatestPartFilter(partitionColumn));
          if (parts.size() == 1) {
            Date tmpDate=getClient(sessionid).getLatestTimeStamp(parts.get(0),partitionColumn);
            if (latestDate == null || latestDate.before(tmpDate)) {
              latestDate=tmpDate;
            }
          }
 else           if (parts.size() > 1) {
            throw new LensException(""String_Node_Str"" + partitionColumn + ""String_Node_Str"");
          }
        }
      }
    }
  }
  release(sessionid);
  return latestDate;
}","@Override public Date getLatestDateOfCube(LensSessionHandle sessionid,String cubeName,String timeDimension) throws LensException, HiveException {
  acquire(sessionid);
  CubeInterface ci=getClient(sessionid).getCube(cubeName);
  if (!(ci instanceof Cube)) {
    throw new BadRequestException(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  }
  Cube c=(Cube)ci;
  String partitionColumn=c.getPartitionColumnOfTimeDim(timeDimension);
  List<FactTable> factTables=getAllFactsOfCube(sessionid,cubeName);
  Date latestDate=null;
  if (factTables != null && !factTables.isEmpty()) {
    for (    FactTable factTable : factTables) {
      List<String> storages=getStoragesOfFact(sessionid,factTable.getName());
      if (storages != null && !storages.isEmpty()) {
        for (        String storage : storages) {
          String storageTableName=MetastoreUtil.getFactStorageTableName(factTable.getName(),storage);
          List<Partition> parts=new LinkedList<Partition>();
          try {
            parts=getClient(sessionid).getPartitionsByFilter(storageTableName,StorageConstants.getLatestPartFilter(partitionColumn));
          }
 catch (          HiveException e) {
            LOG.info(""String_Node_Str"" + storageTableName + ""String_Node_Str"",e);
          }
          if (parts.size() == 1) {
            Date tmpDate=getClient(sessionid).getLatestTimeStamp(parts.get(0),partitionColumn);
            if (latestDate == null || latestDate.before(tmpDate)) {
              latestDate=tmpDate;
            }
          }
 else           if (parts.size() > 1) {
            throw new LensException(""String_Node_Str"" + partitionColumn + ""String_Node_Str"");
          }
        }
      }
    }
  }
  release(sessionid);
  return latestDate;
}",0.9372716199756396
25288,"private XStorageTableElement createStorageTblElement(String storageName,String table,String... updatePeriod){
  XStorageTableElement tbl=cubeObjectFactory.createXStorageTableElement();
  tbl.setStorageName(storageName);
  if (updatePeriod != null) {
    for (    String p : updatePeriod) {
      tbl.getUpdatePeriods().add(p);
    }
  }
  tbl.setTableDesc(createStorageTableDesc(table));
  return tbl;
}","private XStorageTableElement createStorageTblElement(String storageName,String table,final String[] timePartColNames,String... updatePeriod){
  XStorageTableElement tbl=cubeObjectFactory.createXStorageTableElement();
  tbl.setStorageName(storageName);
  if (updatePeriod != null) {
    for (    String p : updatePeriod) {
      tbl.getUpdatePeriods().add(p);
    }
  }
  tbl.setTableDesc(createStorageTableDesc(table,timePartColNames));
  return tbl;
}",0.942690058479532
25289,"private XStorageTableDesc createStorageTableDesc(String name){
  XStorageTableDesc xs1=cubeObjectFactory.createXStorageTableDesc();
  xs1.setCollectionDelimiter(""String_Node_Str"");
  xs1.setEscapeChar(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setLineDelimiter(""String_Node_Str"");
  xs1.setMapKeyDelimiter(""String_Node_Str"");
  xs1.setTableLocation(""String_Node_Str"" + name);
  xs1.setExternal(true);
  Columns partCols=cubeObjectFactory.createColumns();
  Column dt=cubeObjectFactory.createColumn();
  dt.setName(""String_Node_Str"");
  dt.setType(""String_Node_Str"");
  dt.setComment(""String_Node_Str"");
  partCols.getColumns().add(dt);
  xs1.getTimePartCols().add(""String_Node_Str"");
  xs1.setPartCols(partCols);
  return xs1;
}","private XStorageTableDesc createStorageTableDesc(String name,final String[] timePartColNames){
  XStorageTableDesc xs1=cubeObjectFactory.createXStorageTableDesc();
  xs1.setCollectionDelimiter(""String_Node_Str"");
  xs1.setEscapeChar(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setLineDelimiter(""String_Node_Str"");
  xs1.setMapKeyDelimiter(""String_Node_Str"");
  xs1.setTableLocation(""String_Node_Str"" + name);
  xs1.setExternal(true);
  Columns timePartCols=cubeObjectFactory.createColumns();
  for (  String timePartColName : timePartColNames) {
    Column partCol=cubeObjectFactory.createColumn();
    partCol.setName(timePartColName);
    partCol.setType(""String_Node_Str"");
    partCol.setComment(""String_Node_Str"");
    timePartCols.getColumns().add(partCol);
    xs1.getTimePartCols().add(timePartColName);
  }
  xs1.setPartCols(timePartCols);
  return xs1;
}",0.7374495095210617
25290,"private XPartition createPartition(String cubeTableName,Date partDate){
  XPartition xp=cubeObjectFactory.createXPartition();
  xp.setLocation(""String_Node_Str"");
  xp.setCubeTableName(cubeTableName);
  XTimePartSpec timeSpec=cubeObjectFactory.createXTimePartSpec();
  XTimePartSpecElement timePart=cubeObjectFactory.createXTimePartSpecElement();
  timePart.setKey(""String_Node_Str"");
  timePart.setValue(JAXBUtils.getXMLGregorianCalendar(partDate));
  timeSpec.getPartSpecElement().add(timePart);
  xp.setTimePartitionSpec(timeSpec);
  xp.setUpdatePeriod(""String_Node_Str"");
  return xp;
}","private XPartition createPartition(String cubeTableName,final List<XTimePartSpecElement> timePartSpecs){
  XPartition xp=cubeObjectFactory.createXPartition();
  xp.setLocation(""String_Node_Str"");
  xp.setCubeTableName(cubeTableName);
  XTimePartSpec timeSpec=cubeObjectFactory.createXTimePartSpec();
  for (  XTimePartSpecElement timePartSpec : timePartSpecs) {
    timeSpec.getPartSpecElement().add(timePartSpec);
  }
  xp.setTimePartitionSpec(timeSpec);
  xp.setUpdatePeriod(""String_Node_Str"");
  return xp;
}",0.6030881017257039
25291,"private FactTable createFactTable(String factName,String[] storages,String[] updatePeriods){
  FactTable f=cubeObjectFactory.createFactTable();
  f.setName(factName);
  f.setWeight(10.0);
  f.setCubeName(""String_Node_Str"");
  Columns cols=cubeObjectFactory.createColumns();
  Column c1=cubeObjectFactory.createColumn();
  c1.setName(""String_Node_Str"");
  c1.setType(""String_Node_Str"");
  c1.setComment(""String_Node_Str"");
  cols.getColumns().add(c1);
  Column c2=cubeObjectFactory.createColumn();
  c2.setName(""String_Node_Str"");
  c2.setType(""String_Node_Str"");
  c2.setComment(""String_Node_Str"");
  cols.getColumns().add(c2);
  f.setColumns(cols);
  Map<String,String> properties=new HashMap<String,String>();
  properties.put(""String_Node_Str"",""String_Node_Str"");
  f.setProperties(JAXBUtils.xPropertiesFromMap(properties));
  UpdatePeriods upd=cubeObjectFactory.createUpdatePeriods();
  for (int i=0; i < storages.length; i++) {
    UpdatePeriodElement uel=cubeObjectFactory.createUpdatePeriodElement();
    uel.setStorageName(storages[i]);
    uel.getUpdatePeriods().add(updatePeriods[i]);
    upd.getUpdatePeriodElement().add(uel);
  }
  f.setStorageUpdatePeriods(upd);
  return f;
}","private FactTable createFactTable(String factName,String[] storages,String[] updatePeriods,final String cubeName){
  FactTable f=cubeObjectFactory.createFactTable();
  f.setName(factName);
  f.setWeight(10.0);
  f.setCubeName(cubeName);
  Columns cols=cubeObjectFactory.createColumns();
  Column c1=cubeObjectFactory.createColumn();
  c1.setName(""String_Node_Str"");
  c1.setType(""String_Node_Str"");
  c1.setComment(""String_Node_Str"");
  cols.getColumns().add(c1);
  Column c2=cubeObjectFactory.createColumn();
  c2.setName(""String_Node_Str"");
  c2.setType(""String_Node_Str"");
  c2.setComment(""String_Node_Str"");
  cols.getColumns().add(c2);
  f.setColumns(cols);
  Map<String,String> properties=new HashMap<String,String>();
  properties.put(""String_Node_Str"",""String_Node_Str"");
  f.setProperties(JAXBUtils.xPropertiesFromMap(properties));
  UpdatePeriods upd=cubeObjectFactory.createUpdatePeriods();
  for (int i=0; i < storages.length; i++) {
    UpdatePeriodElement uel=cubeObjectFactory.createUpdatePeriodElement();
    uel.setStorageName(storages[i]);
    uel.getUpdatePeriods().add(updatePeriods[i]);
    upd.getUpdatePeriodElement().add(uel);
  }
  f.setStorageUpdatePeriods(upd);
  return f;
}",0.9803429527394396
25292,"@Override public Date getLatestDateOfCube(LensSessionHandle sessionid,String cubeName,String timeDimension) throws LensException, HiveException {
  acquire(sessionid);
  CubeInterface ci=getClient(sessionid).getCube(cubeName);
  if (!(ci instanceof Cube)) {
    throw new BadRequestException(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  }
  Cube c=(Cube)ci;
  String partitionColumn=c.getPartitionColumnOfTimeDim(timeDimension);
  List<FactTable> factTables=getAllFactsOfCube(sessionid,cubeName);
  Date latestDate=null;
  if (factTables != null && !factTables.isEmpty()) {
    for (    FactTable factTable : factTables) {
      List<String> storages=getStoragesOfFact(sessionid,factTable.getName());
      if (storages != null && !storages.isEmpty()) {
        for (        String storage : storages) {
          String storageTableName=MetastoreUtil.getFactStorageTableName(factTable.getName(),storage);
          List<Partition> parts=getClient(sessionid).getPartitionsByFilter(storageTableName,StorageConstants.getLatestPartFilter(partitionColumn));
          if (parts.size() == 1) {
            Date tmpDate=getClient(sessionid).getLatestTimeStamp(parts.get(0),partitionColumn);
            if (latestDate == null || latestDate.before(tmpDate)) {
              latestDate=tmpDate;
            }
          }
 else           if (parts.size() > 1) {
            throw new LensException(""String_Node_Str"" + partitionColumn + ""String_Node_Str"");
          }
        }
      }
    }
  }
  release(sessionid);
  return latestDate;
}","@Override public Date getLatestDateOfCube(LensSessionHandle sessionid,String cubeName,String timeDimension) throws LensException, HiveException {
  acquire(sessionid);
  CubeInterface ci=getClient(sessionid).getCube(cubeName);
  if (!(ci instanceof Cube)) {
    throw new BadRequestException(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  }
  Cube c=(Cube)ci;
  String partitionColumn=c.getPartitionColumnOfTimeDim(timeDimension);
  List<FactTable> factTables=getAllFactsOfCube(sessionid,cubeName);
  Date latestDate=null;
  if (factTables != null && !factTables.isEmpty()) {
    for (    FactTable factTable : factTables) {
      List<String> storages=getStoragesOfFact(sessionid,factTable.getName());
      if (storages != null && !storages.isEmpty()) {
        for (        String storage : storages) {
          String storageTableName=MetastoreUtil.getFactStorageTableName(factTable.getName(),storage);
          List<Partition> parts=new LinkedList<Partition>();
          try {
            parts=getClient(sessionid).getPartitionsByFilter(storageTableName,StorageConstants.getLatestPartFilter(partitionColumn));
          }
 catch (          HiveException e) {
            LOG.info(""String_Node_Str"" + storageTableName + ""String_Node_Str"",e);
          }
          if (parts.size() == 1) {
            Date tmpDate=getClient(sessionid).getLatestTimeStamp(parts.get(0),partitionColumn);
            if (latestDate == null || latestDate.before(tmpDate)) {
              latestDate=tmpDate;
            }
          }
 else           if (parts.size() > 1) {
            throw new LensException(""String_Node_Str"" + partitionColumn + ""String_Node_Str"");
          }
        }
      }
    }
  }
  release(sessionid);
  return latestDate;
}",0.9372716199756396
25293,"private XStorageTableElement createStorageTblElement(String storageName,String table,String... updatePeriod){
  XStorageTableElement tbl=cubeObjectFactory.createXStorageTableElement();
  tbl.setStorageName(storageName);
  if (updatePeriod != null) {
    for (    String p : updatePeriod) {
      tbl.getUpdatePeriods().add(p);
    }
  }
  tbl.setTableDesc(createStorageTableDesc(table));
  return tbl;
}","private XStorageTableElement createStorageTblElement(String storageName,String table,final String[] timePartColNames,String... updatePeriod){
  XStorageTableElement tbl=cubeObjectFactory.createXStorageTableElement();
  tbl.setStorageName(storageName);
  if (updatePeriod != null) {
    for (    String p : updatePeriod) {
      tbl.getUpdatePeriods().add(p);
    }
  }
  tbl.setTableDesc(createStorageTableDesc(table,timePartColNames));
  return tbl;
}",0.942690058479532
25294,"private XStorageTableDesc createStorageTableDesc(String name){
  XStorageTableDesc xs1=cubeObjectFactory.createXStorageTableDesc();
  xs1.setCollectionDelimiter(""String_Node_Str"");
  xs1.setEscapeChar(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setLineDelimiter(""String_Node_Str"");
  xs1.setMapKeyDelimiter(""String_Node_Str"");
  xs1.setTableLocation(""String_Node_Str"" + name);
  xs1.setExternal(true);
  Columns partCols=cubeObjectFactory.createColumns();
  Column dt=cubeObjectFactory.createColumn();
  dt.setName(""String_Node_Str"");
  dt.setType(""String_Node_Str"");
  dt.setComment(""String_Node_Str"");
  partCols.getColumns().add(dt);
  xs1.getTimePartCols().add(""String_Node_Str"");
  xs1.setPartCols(partCols);
  return xs1;
}","private XStorageTableDesc createStorageTableDesc(String name,final String[] timePartColNames){
  XStorageTableDesc xs1=cubeObjectFactory.createXStorageTableDesc();
  xs1.setCollectionDelimiter(""String_Node_Str"");
  xs1.setEscapeChar(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setFieldDelimiter(""String_Node_Str"");
  xs1.setLineDelimiter(""String_Node_Str"");
  xs1.setMapKeyDelimiter(""String_Node_Str"");
  xs1.setTableLocation(""String_Node_Str"" + name);
  xs1.setExternal(true);
  Columns timePartCols=cubeObjectFactory.createColumns();
  for (  String timePartColName : timePartColNames) {
    Column partCol=cubeObjectFactory.createColumn();
    partCol.setName(timePartColName);
    partCol.setType(""String_Node_Str"");
    partCol.setComment(""String_Node_Str"");
    timePartCols.getColumns().add(partCol);
    xs1.getTimePartCols().add(timePartColName);
  }
  xs1.setPartCols(timePartCols);
  return xs1;
}",0.7374495095210617
25295,"private XPartition createPartition(String cubeTableName,Date partDate){
  XPartition xp=cubeObjectFactory.createXPartition();
  xp.setLocation(""String_Node_Str"");
  xp.setCubeTableName(cubeTableName);
  XTimePartSpec timeSpec=cubeObjectFactory.createXTimePartSpec();
  XTimePartSpecElement timePart=cubeObjectFactory.createXTimePartSpecElement();
  timePart.setKey(""String_Node_Str"");
  timePart.setValue(JAXBUtils.getXMLGregorianCalendar(partDate));
  timeSpec.getPartSpecElement().add(timePart);
  xp.setTimePartitionSpec(timeSpec);
  xp.setUpdatePeriod(""String_Node_Str"");
  return xp;
}","private XPartition createPartition(String cubeTableName,final List<XTimePartSpecElement> timePartSpecs){
  XPartition xp=cubeObjectFactory.createXPartition();
  xp.setLocation(""String_Node_Str"");
  xp.setCubeTableName(cubeTableName);
  XTimePartSpec timeSpec=cubeObjectFactory.createXTimePartSpec();
  for (  XTimePartSpecElement timePartSpec : timePartSpecs) {
    timeSpec.getPartSpecElement().add(timePartSpec);
  }
  xp.setTimePartitionSpec(timeSpec);
  xp.setUpdatePeriod(""String_Node_Str"");
  return xp;
}",0.6030881017257039
25296,"private FactTable createFactTable(String factName,String[] storages,String[] updatePeriods){
  FactTable f=cubeObjectFactory.createFactTable();
  f.setName(factName);
  f.setWeight(10.0);
  f.setCubeName(""String_Node_Str"");
  Columns cols=cubeObjectFactory.createColumns();
  Column c1=cubeObjectFactory.createColumn();
  c1.setName(""String_Node_Str"");
  c1.setType(""String_Node_Str"");
  c1.setComment(""String_Node_Str"");
  cols.getColumns().add(c1);
  Column c2=cubeObjectFactory.createColumn();
  c2.setName(""String_Node_Str"");
  c2.setType(""String_Node_Str"");
  c2.setComment(""String_Node_Str"");
  cols.getColumns().add(c2);
  f.setColumns(cols);
  Map<String,String> properties=new HashMap<String,String>();
  properties.put(""String_Node_Str"",""String_Node_Str"");
  f.setProperties(JAXBUtils.xPropertiesFromMap(properties));
  UpdatePeriods upd=cubeObjectFactory.createUpdatePeriods();
  for (int i=0; i < storages.length; i++) {
    UpdatePeriodElement uel=cubeObjectFactory.createUpdatePeriodElement();
    uel.setStorageName(storages[i]);
    uel.getUpdatePeriods().add(updatePeriods[i]);
    upd.getUpdatePeriodElement().add(uel);
  }
  f.setStorageUpdatePeriods(upd);
  return f;
}","private FactTable createFactTable(String factName,String[] storages,String[] updatePeriods,final String cubeName){
  FactTable f=cubeObjectFactory.createFactTable();
  f.setName(factName);
  f.setWeight(10.0);
  f.setCubeName(cubeName);
  Columns cols=cubeObjectFactory.createColumns();
  Column c1=cubeObjectFactory.createColumn();
  c1.setName(""String_Node_Str"");
  c1.setType(""String_Node_Str"");
  c1.setComment(""String_Node_Str"");
  cols.getColumns().add(c1);
  Column c2=cubeObjectFactory.createColumn();
  c2.setName(""String_Node_Str"");
  c2.setType(""String_Node_Str"");
  c2.setComment(""String_Node_Str"");
  cols.getColumns().add(c2);
  f.setColumns(cols);
  Map<String,String> properties=new HashMap<String,String>();
  properties.put(""String_Node_Str"",""String_Node_Str"");
  f.setProperties(JAXBUtils.xPropertiesFromMap(properties));
  UpdatePeriods upd=cubeObjectFactory.createUpdatePeriods();
  for (int i=0; i < storages.length; i++) {
    UpdatePeriodElement uel=cubeObjectFactory.createUpdatePeriodElement();
    uel.setStorageName(storages[i]);
    uel.getUpdatePeriods().add(updatePeriods[i]);
    upd.getUpdatePeriodElement().add(uel);
  }
  f.setStorageUpdatePeriods(upd);
  return f;
}",0.9803429527394396
25297,"/** 
 * Cancel all the queries in query server; can be filtered with state and user.
 * @param sessionid The session in which cancel is issued
 * @param state If any state is passed, all the queries in that state will be cancelled, otherwise all queries will be cancelled. Possible states are  {@value QueryStatus.Status#values()} The queries in{@value QueryStatus.Status#FAILED},  {@value QueryStatus.Status#FAILED},   {@value QueryStatus.Status#CLOSED},  {@value QueryStatus.Status#UNKNOWN} cannot be cancelled
 * @param user If any user is passed, all the queries submitted by the user will be cancelled, otherwise all the queries will be cancelled
 * @param queryName Cancel queries matching the query name
 * @param fromDate the from date
 * @param toDate the to date
 * @return APIResult with state {@value Status#SUCCEEDED} in case of successful cancellation. APIResult with state{@value Status#FAILED} in case of cancellation failure. APIResult with state {@value Status#PARTIAL} incase of partial cancellation.
 */
@DELETE @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult cancelAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  int numCancelled=0;
  List<QueryHandle> handles=null;
  boolean failed=false;
  try {
    handles=getAllQueries(sessionid,state,queryName,user,fromDate,toDate == -1L ? Long.MAX_VALUE : toDate);
    for (    QueryHandle handle : handles) {
      if (cancelQuery(sessionid,handle)) {
        numCancelled++;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    failed=true;
  }
  String msgString=(StringUtils.isBlank(state) ? ""String_Node_Str"" : ""String_Node_Str"" + state) + (StringUtils.isBlank(user) ? ""String_Node_Str"" : ""String_Node_Str"" + user);
  if (handles != null && numCancelled == handles.size()) {
    return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + msgString + ""String_Node_Str"");
  }
 else {
    assert(failed);
    if (numCancelled == 0) {
      return new APIResult(Status.FAILED,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
 else {
      return new APIResult(Status.PARTIAL,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
  }
}","/** 
 * Cancel all the queries in query server; can be filtered with state and user.
 * @param sessionid The session in which cancel is issued
 * @param state If any state is passed, all the queries in that state will be cancelled, otherwise all queries will be cancelled. Possible states are  {@value QueryStatus.Status#values()} The queries in{@value QueryStatus.Status#FAILED},   {@value QueryStatus.Status#CLOSED},  {@value QueryStatus.Status#SUCCESSFUL} cannot be cancelled
 * @param user If any user is passed, all the queries submitted by the user will be cancelled, otherwise all the queries will be cancelled
 * @param queryName Cancel queries matching the query name
 * @param fromDate the from date, inclusive(submitTime>=fromDate)
 * @param toDate the to date, inclusive(toDate>=submitTime)
 * @return APIResult with state {@value Status#SUCCEEDED} in case of successful cancellation. APIResult with state{@value Status#FAILED} in case of cancellation failure. APIResult with state {@value Status#PARTIAL} incase of partial cancellation.
 */
@DELETE @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult cancelAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  int numCancelled=0;
  List<QueryHandle> handles=null;
  boolean failed=false;
  try {
    handles=getAllQueries(sessionid,state,queryName,user,fromDate,toDate == -1L ? Long.MAX_VALUE : toDate);
    for (    QueryHandle handle : handles) {
      if (cancelQuery(sessionid,handle)) {
        numCancelled++;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    failed=true;
  }
  String msgString=(StringUtils.isBlank(state) ? ""String_Node_Str"" : ""String_Node_Str"" + state) + (StringUtils.isBlank(user) ? ""String_Node_Str"" : ""String_Node_Str"" + user);
  if (handles != null && numCancelled == handles.size()) {
    return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + msgString + ""String_Node_Str"");
  }
 else {
    assert(failed);
    if (numCancelled == 0) {
      return new APIResult(Status.FAILED,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
 else {
      return new APIResult(Status.PARTIAL,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
  }
}",0.977230309817096
25298,"/** 
 * Submit the query for explain or execute or execute with a timeout.
 * @param sessionid The session in which user is submitting the query. Any configuration set in the session will be picked up.
 * @param query The query to run
 * @param operation The operation on the query. Supported operations are  {@value SubmitOp#EXPLAIN},   {@value SubmitOp#EXECUTE}and   {@value SubmitOp#EXECUTE_WITH_TIMEOUT}
 * @param conf The configuration for the query
 * @param timeoutmillis The timeout for the query, honored only in case of  {@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation
 * @param user the user
 * @param queryName human readable query name set by user (optional parameter)
 * @return {@link QueryHandle} in case of {@value SubmitOp#EXECUTE} operation. {@link QueryPlan} in case of{@value SubmitOp#EXPLAIN} operation. {@link QueryHandleWithResultSet} in case{@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.MULTIPART_FORM_DATA}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public QuerySubmitResult query(@FormDataParam(""String_Node_Str"") LensSessionHandle sessionid,@FormDataParam(""String_Node_Str"") String query,@FormDataParam(""String_Node_Str"") String operation,@FormDataParam(""String_Node_Str"") LensConf conf,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") Long timeoutmillis,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") String queryName){
  checkQuery(query);
  checkSessionId(sessionid);
  try {
    SubmitOp sop=null;
    try {
      sop=SubmitOp.valueOf(operation.toUpperCase());
    }
 catch (    IllegalArgumentException e) {
      throw new BadRequestException(e);
    }
    if (sop == null) {
      throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
    }
switch (sop) {
case EXECUTE:
      return queryServer.executeAsync(sessionid,query,conf,queryName);
case EXPLAIN:
    return queryServer.explain(sessionid,query,conf);
case EXECUTE_WITH_TIMEOUT:
  return queryServer.execute(sessionid,query,timeoutmillis,conf,queryName);
default :
throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
}
}
 catch (LensException e) {
throw new WebApplicationException(e);
}
}","/** 
 * Submit the query for explain or execute or execute with a timeout.
 * @param sessionid The session in which user is submitting the query. Any configuration set in the session will be picked up.
 * @param query The query to run
 * @param operation The operation on the query. Supported operations are  {@value SubmitOp#EXPLAIN},   {@value SubmitOp#EXECUTE}and   {@value SubmitOp#EXECUTE_WITH_TIMEOUT}
 * @param conf The configuration for the query
 * @param timeoutmillis The timeout for the query, honored only in case of  {@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation
 * @param queryName human readable query name set by user (optional parameter)
 * @return {@link QueryHandle} in case of {@value SubmitOp#EXECUTE} operation. {@link QueryPlan} in case of{@value SubmitOp#EXPLAIN} operation. {@link QueryHandleWithResultSet} in case{@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.MULTIPART_FORM_DATA}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public QuerySubmitResult query(@FormDataParam(""String_Node_Str"") LensSessionHandle sessionid,@FormDataParam(""String_Node_Str"") String query,@FormDataParam(""String_Node_Str"") String operation,@FormDataParam(""String_Node_Str"") LensConf conf,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") Long timeoutmillis,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") String queryName){
  checkQuery(query);
  checkSessionId(sessionid);
  try {
    SubmitOp sop=null;
    try {
      sop=SubmitOp.valueOf(operation.toUpperCase());
    }
 catch (    IllegalArgumentException e) {
      throw new BadRequestException(e);
    }
    if (sop == null) {
      throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
    }
switch (sop) {
case EXECUTE:
      return queryServer.executeAsync(sessionid,query,conf,queryName);
case EXPLAIN:
    return queryServer.explain(sessionid,query,conf);
case EXECUTE_WITH_TIMEOUT:
  return queryServer.execute(sessionid,query,timeoutmillis,conf,queryName);
default :
throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
}
}
 catch (LensException e) {
throw new WebApplicationException(e);
}
}",0.9775745699978228
25299,"/** 
 * Get all the queries in the query server; can be filtered with state and queryName. This will by default only return queries submitted by the user that has started the session. To get queries of all users, set the searchAllUsers parameter to false.
 * @param sessionid The sessionid in which queryName is working
 * @param state If any state is passed, all the queries in that state will be returned, otherwise all queries will be returned. Possible states are  {@value QueryStatus.Status#values()}
 * @param queryName If any queryName is passed, all the queries containing the queryName will be returned, otherwise all the queries will be returned
 * @param user Returns queries submitted by this user. If set to ""all"", returns queries of all users. By default, returns queries of the current user.
 * @param fromDate from date to search queries in a time range
 * @param toDate to date to search queries in a time range
 * @return List of {@link QueryHandle} objects
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public List<QueryHandle> getAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  try {
    if (toDate == -1L) {
      toDate=Long.MAX_VALUE;
    }
    return queryServer.getAllQueries(sessionid,state,user,queryName,fromDate,toDate);
  }
 catch (  LensException e) {
    throw new WebApplicationException(e);
  }
}","/** 
 * Get all the queries in the query server; can be filtered with state and queryName. This will by default only return queries submitted by the user that has started the session. To get queries of all users, set the searchAllUsers parameter to false.
 * @param sessionid The sessionid in which queryName is working
 * @param state If any state is passed, all the queries in that state will be returned, otherwise all queries will be returned. Possible states are  {@value QueryStatus.Status#values()}
 * @param queryName If any queryName is passed, all the queries containing the queryName will be returned, otherwise all the queries will be returned
 * @param user Returns queries submitted by this user. If set to ""all"", returns queries of all users. By default, returns queries of the current user.
 * @param fromDate from date to search queries in a time range, the range is inclusive(submitTime >= fromDate)
 * @param toDate to date to search queries in a time range, the range is inclusive(toDate >= submitTime)
 * @return List of {@link QueryHandle} objects
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public List<QueryHandle> getAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  try {
    if (toDate == -1L) {
      toDate=Long.MAX_VALUE;
    }
    return queryServer.getAllQueries(sessionid,state,user,queryName,fromDate,toDate);
  }
 catch (  LensException e) {
    throw new WebApplicationException(e);
  }
}",0.975197889182058
25300,"/** 
 * Adds the dim1 table.
 * @param tableName the table name
 * @param specName the spec name
 * @param storageSpecName the storage spec name
 * @param storageName the storage name
 */
public static void addDim1Table(String tableName,String specName,String storageSpecName,String storageName){
  LensDimensionTableCommands command=getCommand();
  String dimList=command.showDimensionTables();
  Assert.assertEquals(""String_Node_Str"",dimList,""String_Node_Str"");
  TestLensStorageCommands.addLocalStorage(storageName);
  URL dimSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(specName);
  URL factStorageSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(storageSpecName);
  try {
    command.createDimensionTable(new File(dimSpec.toURI()).getAbsolutePath() + ""String_Node_Str"" + new File(factStorageSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  dimList=command.showDimensionTables();
  Assert.assertEquals(tableName,dimList,""String_Node_Str"");
}","/** 
 * Adds the dim1 table.
 * @param tableName the table name
 * @param specName the spec name
 * @param storageSpecName the storage spec name
 * @param storageName the storage name
 */
public synchronized static void addDim1Table(String tableName,String specName,String storageSpecName,String storageName){
  LensDimensionTableCommands command=getCommand();
  String dimList=command.showDimensionTables();
  TestLensStorageCommands.addLocalStorage(storageName);
  URL dimSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(specName);
  URL factStorageSpec=TestLensDimensionTableCommands.class.getClassLoader().getResource(storageSpecName);
  try {
    command.createDimensionTable(new File(dimSpec.toURI()).getAbsolutePath() + ""String_Node_Str"" + new File(factStorageSpec.toURI()).getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
  dimList=command.showDimensionTables();
  Assert.assertTrue(dimList.contains(tableName),""String_Node_Str"");
}",0.936768149882904
25301,"@SuppressWarnings(""String_Node_Str"") @Override public synchronized void init(HiveConf hiveConf){
  if (getServiceState() == STATE.NOTINITED) {
    conf=hiveConf;
    conf.addResource(""String_Node_Str"");
    conf.addResource(""String_Node_Str"");
    conf.setVar(HiveConf.ConfVars.HIVE_SESSION_IMPL_CLASSNAME,LensSessionImpl.class.getCanonicalName());
    serviceMode=conf.getEnum(LensConfConstants.SERVER_MODE,SERVICE_MODE.valueOf(LensConfConstants.DEFAULT_SERVER_MODE));
    cliService=new CLIService();
    addService(cliService);
    addService(new EventServiceImpl(LensEventService.NAME));
    addService(new MetricsServiceImpl(MetricsService.NAME));
    addService(new StatisticsService(StatisticsService.STATS_SVC_NAME));
    String[] serviceNames=conf.getStrings(LensConfConstants.SERVICE_NAMES);
    for (    String sName : serviceNames) {
      try {
        String serviceClassName=conf.get(LensConfConstants.getServiceImplConfKey(sName));
        if (StringUtils.isBlank(serviceClassName)) {
          LOG.warn(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClassName);
          continue;
        }
        Class<?> cls=Class.forName(serviceClassName);
        if (LensService.class.isAssignableFrom(cls)) {
          Class<? extends LensService> serviceClass=(Class<? extends LensService>)cls;
          LOG.info(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClass);
          Constructor<?> constructor=serviceClass.getConstructor(CLIService.class);
          LensService service=(LensService)constructor.newInstance(new Object[]{cliService});
          addService(service);
          lensServices.add(service);
        }
 else         if (Service.class.isAssignableFrom(cls)) {
          Class<? extends Service> serviceClass=(Class<? extends Service>)cls;
          Service svc=serviceClass.newInstance();
          addService(svc);
        }
 else {
          LOG.warn(""String_Node_Str"" + serviceClassName + ""String_Node_Str""+ sName);
        }
      }
 catch (      Exception e) {
        LOG.warn(""String_Node_Str"" + sName,e);
        throw new RuntimeException(""String_Node_Str"" + sName,e);
      }
    }
    for (    Service svc : getServices()) {
      services.put(svc.getName(),svc);
    }
    super.init(conf);
    String persistPathStr=conf.get(LensConfConstants.SERVER_STATE_PERSIST_LOCATION,LensConfConstants.DEFAULT_SERVER_STATE_PERSIST_LOCATION);
    persistDir=new Path(persistPathStr);
    try {
      Configuration configuration=new Configuration(conf);
      configuration.setBoolean(FS_AUTOMATIC_CLOSE,false);
      persistenceFS=FileSystem.newInstance(persistDir.toUri(),conf);
      setupPersistedState();
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
    snapShotInterval=conf.getLong(LensConfConstants.SERVER_SNAPSHOT_INTERVAL,LensConfConstants.DEFAULT_SERVER_SNAPSHOT_INTERVAL);
    LOG.info(""String_Node_Str"" + services.keySet().toString());
    UserConfigLoaderFactory.init(conf);
    timer=new Timer(""String_Node_Str"",true);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public synchronized void init(HiveConf hiveConf){
  if (getServiceState() == STATE.NOTINITED) {
    conf=hiveConf;
    conf.addResource(""String_Node_Str"");
    conf.addResource(""String_Node_Str"");
    conf.setVar(HiveConf.ConfVars.HIVE_SESSION_IMPL_CLASSNAME,LensSessionImpl.class.getCanonicalName());
    serviceMode=conf.getEnum(LensConfConstants.SERVER_MODE,SERVICE_MODE.valueOf(LensConfConstants.DEFAULT_SERVER_MODE));
    cliService=new CLIService();
    addService(cliService);
    addService(new EventServiceImpl(LensEventService.NAME));
    addService(new MetricsServiceImpl(MetricsService.NAME));
    addService(new StatisticsService(StatisticsService.STATS_SVC_NAME));
    String[] serviceNames=conf.getStrings(LensConfConstants.SERVICE_NAMES);
    for (    String sName : serviceNames) {
      try {
        String serviceClassName=conf.get(LensConfConstants.getServiceImplConfKey(sName));
        if (StringUtils.isBlank(serviceClassName)) {
          LOG.warn(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClassName);
          continue;
        }
        Class<?> cls=Class.forName(serviceClassName);
        if (LensService.class.isAssignableFrom(cls)) {
          Class<? extends LensService> serviceClass=(Class<? extends LensService>)cls;
          LOG.info(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClass);
          Constructor<?> constructor=serviceClass.getConstructor(CLIService.class);
          LensService service=(LensService)constructor.newInstance(new Object[]{cliService});
          addService(service);
          lensServices.add(service);
        }
 else         if (Service.class.isAssignableFrom(cls)) {
          Class<? extends Service> serviceClass=(Class<? extends Service>)cls;
          Service svc=serviceClass.newInstance();
          addService(svc);
        }
 else {
          LOG.warn(""String_Node_Str"" + serviceClassName + ""String_Node_Str""+ sName);
        }
      }
 catch (      Exception e) {
        LOG.warn(""String_Node_Str"" + sName,e);
        throw new RuntimeException(""String_Node_Str"" + sName,e);
      }
    }
    for (    Service svc : getServices()) {
      services.put(svc.getName(),svc);
    }
    super.init(conf);
    String persistPathStr=conf.get(LensConfConstants.SERVER_STATE_PERSIST_LOCATION,LensConfConstants.DEFAULT_SERVER_STATE_PERSIST_LOCATION);
    persistDir=new Path(persistPathStr);
    try {
      Configuration configuration=new Configuration(conf);
      configuration.setBoolean(FS_AUTOMATIC_CLOSE,false);
      persistenceFS=FileSystem.newInstance(persistDir.toUri(),configuration);
      setupPersistedState();
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
    snapShotInterval=conf.getLong(LensConfConstants.SERVER_SNAPSHOT_INTERVAL,LensConfConstants.DEFAULT_SERVER_SNAPSHOT_INTERVAL);
    LOG.info(""String_Node_Str"" + services.keySet().toString());
    UserConfigLoaderFactory.init(conf);
    timer=new Timer(""String_Node_Str"",true);
  }
}",0.9985372988785958
25302,"@SuppressWarnings(""String_Node_Str"") @Override public synchronized void init(HiveConf hiveConf){
  if (getServiceState() == STATE.NOTINITED) {
    conf=hiveConf;
    conf.addResource(""String_Node_Str"");
    conf.addResource(""String_Node_Str"");
    conf.setVar(HiveConf.ConfVars.HIVE_SESSION_IMPL_CLASSNAME,LensSessionImpl.class.getCanonicalName());
    serviceMode=conf.getEnum(LensConfConstants.SERVER_MODE,SERVICE_MODE.valueOf(LensConfConstants.DEFAULT_SERVER_MODE));
    cliService=new CLIService();
    addService(cliService);
    addService(new EventServiceImpl(LensEventService.NAME));
    addService(new MetricsServiceImpl(MetricsService.NAME));
    addService(new StatisticsService(StatisticsService.STATS_SVC_NAME));
    String[] serviceNames=conf.getStrings(LensConfConstants.SERVICE_NAMES);
    for (    String sName : serviceNames) {
      try {
        String serviceClassName=conf.get(LensConfConstants.getServiceImplConfKey(sName));
        if (StringUtils.isBlank(serviceClassName)) {
          LOG.warn(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClassName);
          continue;
        }
        Class<?> cls=Class.forName(serviceClassName);
        if (LensService.class.isAssignableFrom(cls)) {
          Class<? extends LensService> serviceClass=(Class<? extends LensService>)cls;
          LOG.info(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClass);
          Constructor<?> constructor=serviceClass.getConstructor(CLIService.class);
          LensService service=(LensService)constructor.newInstance(new Object[]{cliService});
          addService(service);
          lensServices.add(service);
        }
 else         if (Service.class.isAssignableFrom(cls)) {
          Class<? extends Service> serviceClass=(Class<? extends Service>)cls;
          Service svc=serviceClass.newInstance();
          addService(svc);
        }
 else {
          LOG.warn(""String_Node_Str"" + serviceClassName + ""String_Node_Str""+ sName);
        }
      }
 catch (      Exception e) {
        LOG.warn(""String_Node_Str"" + sName,e);
        throw new RuntimeException(""String_Node_Str"" + sName,e);
      }
    }
    for (    Service svc : getServices()) {
      services.put(svc.getName(),svc);
    }
    super.init(conf);
    String persistPathStr=conf.get(LensConfConstants.SERVER_STATE_PERSIST_LOCATION,LensConfConstants.DEFAULT_SERVER_STATE_PERSIST_LOCATION);
    persistDir=new Path(persistPathStr);
    try {
      Configuration configuration=new Configuration(conf);
      configuration.setBoolean(FS_AUTOMATIC_CLOSE,false);
      persistenceFS=FileSystem.newInstance(persistDir.toUri(),conf);
      setupPersistedState();
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
    snapShotInterval=conf.getLong(LensConfConstants.SERVER_SNAPSHOT_INTERVAL,LensConfConstants.DEFAULT_SERVER_SNAPSHOT_INTERVAL);
    LOG.info(""String_Node_Str"" + services.keySet().toString());
    UserConfigLoaderFactory.init(conf);
    timer=new Timer(""String_Node_Str"",true);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public synchronized void init(HiveConf hiveConf){
  if (getServiceState() == STATE.NOTINITED) {
    conf=hiveConf;
    conf.addResource(""String_Node_Str"");
    conf.addResource(""String_Node_Str"");
    conf.setVar(HiveConf.ConfVars.HIVE_SESSION_IMPL_CLASSNAME,LensSessionImpl.class.getCanonicalName());
    serviceMode=conf.getEnum(LensConfConstants.SERVER_MODE,SERVICE_MODE.valueOf(LensConfConstants.DEFAULT_SERVER_MODE));
    cliService=new CLIService();
    addService(cliService);
    addService(new EventServiceImpl(LensEventService.NAME));
    addService(new MetricsServiceImpl(MetricsService.NAME));
    addService(new StatisticsService(StatisticsService.STATS_SVC_NAME));
    String[] serviceNames=conf.getStrings(LensConfConstants.SERVICE_NAMES);
    for (    String sName : serviceNames) {
      try {
        String serviceClassName=conf.get(LensConfConstants.getServiceImplConfKey(sName));
        if (StringUtils.isBlank(serviceClassName)) {
          LOG.warn(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClassName);
          continue;
        }
        Class<?> cls=Class.forName(serviceClassName);
        if (LensService.class.isAssignableFrom(cls)) {
          Class<? extends LensService> serviceClass=(Class<? extends LensService>)cls;
          LOG.info(""String_Node_Str"" + sName + ""String_Node_Str""+ serviceClass);
          Constructor<?> constructor=serviceClass.getConstructor(CLIService.class);
          LensService service=(LensService)constructor.newInstance(new Object[]{cliService});
          addService(service);
          lensServices.add(service);
        }
 else         if (Service.class.isAssignableFrom(cls)) {
          Class<? extends Service> serviceClass=(Class<? extends Service>)cls;
          Service svc=serviceClass.newInstance();
          addService(svc);
        }
 else {
          LOG.warn(""String_Node_Str"" + serviceClassName + ""String_Node_Str""+ sName);
        }
      }
 catch (      Exception e) {
        LOG.warn(""String_Node_Str"" + sName,e);
        throw new RuntimeException(""String_Node_Str"" + sName,e);
      }
    }
    for (    Service svc : getServices()) {
      services.put(svc.getName(),svc);
    }
    super.init(conf);
    String persistPathStr=conf.get(LensConfConstants.SERVER_STATE_PERSIST_LOCATION,LensConfConstants.DEFAULT_SERVER_STATE_PERSIST_LOCATION);
    persistDir=new Path(persistPathStr);
    try {
      Configuration configuration=new Configuration(conf);
      configuration.setBoolean(FS_AUTOMATIC_CLOSE,false);
      persistenceFS=FileSystem.newInstance(persistDir.toUri(),configuration);
      setupPersistedState();
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
    snapShotInterval=conf.getLong(LensConfConstants.SERVER_SNAPSHOT_INTERVAL,LensConfConstants.DEFAULT_SERVER_SNAPSHOT_INTERVAL);
    LOG.info(""String_Node_Str"" + services.keySet().toString());
    UserConfigLoaderFactory.init(conf);
    timer=new Timer(""String_Node_Str"",true);
  }
}",0.9985372988785958
25303,"/** 
 * Cancel all the queries in query server; can be filtered with state and user.
 * @param sessionid The session in which cancel is issued
 * @param state If any state is passed, all the queries in that state will be cancelled, otherwise all queries will be cancelled. Possible states are  {@value QueryStatus.Status#values()} The queries in{@value QueryStatus.Status#FAILED},  {@value QueryStatus.Status#FAILED},   {@value QueryStatus.Status#CLOSED},  {@value QueryStatus.Status#UNKNOWN} cannot be cancelled
 * @param user If any user is passed, all the queries submitted by the user will be cancelled, otherwise all the queries will be cancelled
 * @param queryName Cancel queries matching the query name
 * @param fromDate the from date
 * @param toDate the to date
 * @return APIResult with state {@value Status#SUCCEEDED} in case of successful cancellation. APIResult with state{@value Status#FAILED} in case of cancellation failure. APIResult with state {@value Status#PARTIAL} incase of partial cancellation.
 */
@DELETE @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult cancelAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  int numCancelled=0;
  List<QueryHandle> handles=null;
  boolean failed=false;
  try {
    handles=getAllQueries(sessionid,state,queryName,user,fromDate,toDate == -1L ? Long.MAX_VALUE : toDate);
    for (    QueryHandle handle : handles) {
      if (cancelQuery(sessionid,handle)) {
        numCancelled++;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    failed=true;
  }
  String msgString=(StringUtils.isBlank(state) ? ""String_Node_Str"" : ""String_Node_Str"" + state) + (StringUtils.isBlank(user) ? ""String_Node_Str"" : ""String_Node_Str"" + user);
  if (handles != null && numCancelled == handles.size()) {
    return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + msgString + ""String_Node_Str"");
  }
 else {
    assert(failed);
    if (numCancelled == 0) {
      return new APIResult(Status.FAILED,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
 else {
      return new APIResult(Status.PARTIAL,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
  }
}","/** 
 * Cancel all the queries in query server; can be filtered with state and user.
 * @param sessionid The session in which cancel is issued
 * @param state If any state is passed, all the queries in that state will be cancelled, otherwise all queries will be cancelled. Possible states are  {@value QueryStatus.Status#values()} The queries in{@value QueryStatus.Status#FAILED},   {@value QueryStatus.Status#CLOSED},  {@value QueryStatus.Status#SUCCESSFUL} cannot be cancelled
 * @param user If any user is passed, all the queries submitted by the user will be cancelled, otherwise all the queries will be cancelled
 * @param queryName Cancel queries matching the query name
 * @param fromDate the from date, inclusive(submitTime>=fromDate)
 * @param toDate the to date, inclusive(toDate>=submitTime)
 * @return APIResult with state {@value Status#SUCCEEDED} in case of successful cancellation. APIResult with state{@value Status#FAILED} in case of cancellation failure. APIResult with state {@value Status#PARTIAL} incase of partial cancellation.
 */
@DELETE @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult cancelAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  int numCancelled=0;
  List<QueryHandle> handles=null;
  boolean failed=false;
  try {
    handles=getAllQueries(sessionid,state,queryName,user,fromDate,toDate == -1L ? Long.MAX_VALUE : toDate);
    for (    QueryHandle handle : handles) {
      if (cancelQuery(sessionid,handle)) {
        numCancelled++;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    failed=true;
  }
  String msgString=(StringUtils.isBlank(state) ? ""String_Node_Str"" : ""String_Node_Str"" + state) + (StringUtils.isBlank(user) ? ""String_Node_Str"" : ""String_Node_Str"" + user);
  if (handles != null && numCancelled == handles.size()) {
    return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + msgString + ""String_Node_Str"");
  }
 else {
    assert(failed);
    if (numCancelled == 0) {
      return new APIResult(Status.FAILED,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
 else {
      return new APIResult(Status.PARTIAL,""String_Node_Str"" + msgString + ""String_Node_Str"");
    }
  }
}",0.977230309817096
25304,"/** 
 * Submit the query for explain or execute or execute with a timeout.
 * @param sessionid The session in which user is submitting the query. Any configuration set in the session will be picked up.
 * @param query The query to run
 * @param operation The operation on the query. Supported operations are  {@value SubmitOp#EXPLAIN},   {@value SubmitOp#EXECUTE}and   {@value SubmitOp#EXECUTE_WITH_TIMEOUT}
 * @param conf The configuration for the query
 * @param timeoutmillis The timeout for the query, honored only in case of  {@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation
 * @param user the user
 * @param queryName human readable query name set by user (optional parameter)
 * @return {@link QueryHandle} in case of {@value SubmitOp#EXECUTE} operation. {@link QueryPlan} in case of{@value SubmitOp#EXPLAIN} operation. {@link QueryHandleWithResultSet} in case{@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.MULTIPART_FORM_DATA}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public QuerySubmitResult query(@FormDataParam(""String_Node_Str"") LensSessionHandle sessionid,@FormDataParam(""String_Node_Str"") String query,@FormDataParam(""String_Node_Str"") String operation,@FormDataParam(""String_Node_Str"") LensConf conf,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") Long timeoutmillis,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") String queryName){
  checkQuery(query);
  checkSessionId(sessionid);
  try {
    SubmitOp sop=null;
    try {
      sop=SubmitOp.valueOf(operation.toUpperCase());
    }
 catch (    IllegalArgumentException e) {
      throw new BadRequestException(e);
    }
    if (sop == null) {
      throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
    }
switch (sop) {
case EXECUTE:
      return queryServer.executeAsync(sessionid,query,conf,queryName);
case EXPLAIN:
    return queryServer.explain(sessionid,query,conf);
case EXECUTE_WITH_TIMEOUT:
  return queryServer.execute(sessionid,query,timeoutmillis,conf,queryName);
default :
throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
}
}
 catch (LensException e) {
throw new WebApplicationException(e);
}
}","/** 
 * Submit the query for explain or execute or execute with a timeout.
 * @param sessionid The session in which user is submitting the query. Any configuration set in the session will be picked up.
 * @param query The query to run
 * @param operation The operation on the query. Supported operations are  {@value SubmitOp#EXPLAIN},   {@value SubmitOp#EXECUTE}and   {@value SubmitOp#EXECUTE_WITH_TIMEOUT}
 * @param conf The configuration for the query
 * @param timeoutmillis The timeout for the query, honored only in case of  {@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation
 * @param queryName human readable query name set by user (optional parameter)
 * @return {@link QueryHandle} in case of {@value SubmitOp#EXECUTE} operation. {@link QueryPlan} in case of{@value SubmitOp#EXPLAIN} operation. {@link QueryHandleWithResultSet} in case{@value SubmitOp#EXECUTE_WITH_TIMEOUT} operation.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.MULTIPART_FORM_DATA}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public QuerySubmitResult query(@FormDataParam(""String_Node_Str"") LensSessionHandle sessionid,@FormDataParam(""String_Node_Str"") String query,@FormDataParam(""String_Node_Str"") String operation,@FormDataParam(""String_Node_Str"") LensConf conf,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") Long timeoutmillis,@DefaultValue(""String_Node_Str"") @FormDataParam(""String_Node_Str"") String queryName){
  checkQuery(query);
  checkSessionId(sessionid);
  try {
    SubmitOp sop=null;
    try {
      sop=SubmitOp.valueOf(operation.toUpperCase());
    }
 catch (    IllegalArgumentException e) {
      throw new BadRequestException(e);
    }
    if (sop == null) {
      throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
    }
switch (sop) {
case EXECUTE:
      return queryServer.executeAsync(sessionid,query,conf,queryName);
case EXPLAIN:
    return queryServer.explain(sessionid,query,conf);
case EXECUTE_WITH_TIMEOUT:
  return queryServer.execute(sessionid,query,timeoutmillis,conf,queryName);
default :
throw new BadRequestException(""String_Node_Str"" + operation + submitClue);
}
}
 catch (LensException e) {
throw new WebApplicationException(e);
}
}",0.9775745699978228
25305,"/** 
 * Get all the queries in the query server; can be filtered with state and queryName. This will by default only return queries submitted by the user that has started the session. To get queries of all users, set the searchAllUsers parameter to false.
 * @param sessionid The sessionid in which queryName is working
 * @param state If any state is passed, all the queries in that state will be returned, otherwise all queries will be returned. Possible states are  {@value QueryStatus.Status#values()}
 * @param queryName If any queryName is passed, all the queries containing the queryName will be returned, otherwise all the queries will be returned
 * @param user Returns queries submitted by this user. If set to ""all"", returns queries of all users. By default, returns queries of the current user.
 * @param fromDate from date to search queries in a time range
 * @param toDate to date to search queries in a time range
 * @return List of {@link QueryHandle} objects
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public List<QueryHandle> getAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  try {
    if (toDate == -1L) {
      toDate=Long.MAX_VALUE;
    }
    return queryServer.getAllQueries(sessionid,state,user,queryName,fromDate,toDate);
  }
 catch (  LensException e) {
    throw new WebApplicationException(e);
  }
}","/** 
 * Get all the queries in the query server; can be filtered with state and queryName. This will by default only return queries submitted by the user that has started the session. To get queries of all users, set the searchAllUsers parameter to false.
 * @param sessionid The sessionid in which queryName is working
 * @param state If any state is passed, all the queries in that state will be returned, otherwise all queries will be returned. Possible states are  {@value QueryStatus.Status#values()}
 * @param queryName If any queryName is passed, all the queries containing the queryName will be returned, otherwise all the queries will be returned
 * @param user Returns queries submitted by this user. If set to ""all"", returns queries of all users. By default, returns queries of the current user.
 * @param fromDate from date to search queries in a time range, the range is inclusive(submitTime >= fromDate)
 * @param toDate to date to search queries in a time range, the range is inclusive(toDate >= submitTime)
 * @return List of {@link QueryHandle} objects
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public List<QueryHandle> getAllQueries(@QueryParam(""String_Node_Str"") LensSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String state,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String queryName,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String user,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long fromDate,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long toDate){
  checkSessionId(sessionid);
  try {
    if (toDate == -1L) {
      toDate=Long.MAX_VALUE;
    }
    return queryServer.getAllQueries(sessionid,state,user,queryName,fromDate,toDate);
  }
 catch (  LensException e) {
    throw new WebApplicationException(e);
  }
}",0.975197889182058
25306,"/** 
 * Format result set.
 * @param rs the rs
 * @return the string
 */
private String formatResultSet(LensClient.LensClientResultSetWithStats rs){
  StringBuilder b=new StringBuilder();
  int i=0;
  if (rs.getResultSet() != null) {
    QueryResultSetMetadata resultSetMetadata=rs.getResultSet().getResultSetMetadata();
    for (    ResultColumn column : resultSetMetadata.getColumns()) {
      b.append(column.getName()).append(""String_Node_Str"");
    }
    b.append(""String_Node_Str"");
    QueryResult r=rs.getResultSet().getResult();
    if (r instanceof InMemoryQueryResult) {
      InMemoryQueryResult temp=(InMemoryQueryResult)r;
      for (      ResultRow row : temp.getRows()) {
        for (        Object col : row.getValues()) {
          b.append(col).append(""String_Node_Str"");
        }
        i++;
        b.append(""String_Node_Str"");
      }
    }
 else {
      PersistentQueryResult temp=(PersistentQueryResult)r;
      b.append(""String_Node_Str"").append(temp.getPersistedURI()).append(""String_Node_Str"");
    }
  }
  if (rs.getQuery() != null) {
    long submissionTime=rs.getQuery().getSubmissionTime();
    long endTime=rs.getQuery().getFinishTime();
    b.append(i).append(""String_Node_Str"").append(endTime > 0 ? ((endTime - submissionTime) / 1000) : 0).append(""String_Node_Str"");
  }
  return b.toString();
}","/** 
 * Format result set.
 * @param rs the rs
 * @return the string
 */
private String formatResultSet(LensClient.LensClientResultSetWithStats rs){
  StringBuilder b=new StringBuilder();
  int numRows=0;
  if (rs.getResultSet() != null) {
    QueryResultSetMetadata resultSetMetadata=rs.getResultSet().getResultSetMetadata();
    for (    ResultColumn column : resultSetMetadata.getColumns()) {
      b.append(column.getName()).append(""String_Node_Str"");
    }
    b.append(""String_Node_Str"");
    QueryResult r=rs.getResultSet().getResult();
    if (r instanceof InMemoryQueryResult) {
      InMemoryQueryResult temp=(InMemoryQueryResult)r;
      for (      ResultRow row : temp.getRows()) {
        for (        Object col : row.getValues()) {
          b.append(col).append(""String_Node_Str"");
        }
        numRows++;
        b.append(""String_Node_Str"");
      }
    }
 else {
      PersistentQueryResult temp=(PersistentQueryResult)r;
      numRows=temp.getNumRows();
      b.append(""String_Node_Str"").append(temp.getPersistedURI()).append(""String_Node_Str"");
    }
  }
  if (rs.getQuery() != null) {
    long submissionTime=rs.getQuery().getSubmissionTime();
    long endTime=rs.getQuery().getFinishTime();
    b.append(numRows).append(""String_Node_Str"").append(endTime > 0 ? ((endTime - submissionTime) / 1000) : 0).append(""String_Node_Str"");
  }
  return b.toString();
}",0.9790055248618784
25307,"/** 
 * Format result set.
 * @param rs the rs
 * @return the string
 */
private String formatResultSet(LensClient.LensClientResultSetWithStats rs){
  StringBuilder b=new StringBuilder();
  int i=0;
  if (rs.getResultSet() != null) {
    QueryResultSetMetadata resultSetMetadata=rs.getResultSet().getResultSetMetadata();
    for (    ResultColumn column : resultSetMetadata.getColumns()) {
      b.append(column.getName()).append(""String_Node_Str"");
    }
    b.append(""String_Node_Str"");
    QueryResult r=rs.getResultSet().getResult();
    if (r instanceof InMemoryQueryResult) {
      InMemoryQueryResult temp=(InMemoryQueryResult)r;
      for (      ResultRow row : temp.getRows()) {
        for (        Object col : row.getValues()) {
          b.append(col).append(""String_Node_Str"");
        }
        i++;
        b.append(""String_Node_Str"");
      }
    }
 else {
      PersistentQueryResult temp=(PersistentQueryResult)r;
      b.append(""String_Node_Str"").append(temp.getPersistedURI()).append(""String_Node_Str"");
    }
  }
  if (rs.getQuery() != null) {
    long submissionTime=rs.getQuery().getSubmissionTime();
    long endTime=rs.getQuery().getFinishTime();
    b.append(i).append(""String_Node_Str"").append(endTime > 0 ? ((endTime - submissionTime) / 1000) : 0).append(""String_Node_Str"");
  }
  return b.toString();
}","/** 
 * Format result set.
 * @param rs the rs
 * @return the string
 */
private String formatResultSet(LensClient.LensClientResultSetWithStats rs){
  StringBuilder b=new StringBuilder();
  int numRows=0;
  if (rs.getResultSet() != null) {
    QueryResultSetMetadata resultSetMetadata=rs.getResultSet().getResultSetMetadata();
    for (    ResultColumn column : resultSetMetadata.getColumns()) {
      b.append(column.getName()).append(""String_Node_Str"");
    }
    b.append(""String_Node_Str"");
    QueryResult r=rs.getResultSet().getResult();
    if (r instanceof InMemoryQueryResult) {
      InMemoryQueryResult temp=(InMemoryQueryResult)r;
      for (      ResultRow row : temp.getRows()) {
        for (        Object col : row.getValues()) {
          b.append(col).append(""String_Node_Str"");
        }
        numRows++;
        b.append(""String_Node_Str"");
      }
    }
 else {
      PersistentQueryResult temp=(PersistentQueryResult)r;
      numRows=temp.getNumRows();
      b.append(""String_Node_Str"").append(temp.getPersistedURI()).append(""String_Node_Str"");
    }
  }
  if (rs.getQuery() != null) {
    long submissionTime=rs.getQuery().getSubmissionTime();
    long endTime=rs.getQuery().getFinishTime();
    b.append(numRows).append(""String_Node_Str"").append(endTime > 0 ? ((endTime - submissionTime) / 1000) : 0).append(""String_Node_Str"");
  }
  return b.toString();
}",0.9790055248618784
25308,"protected List<String> getExpectedCSVRowsWithoutComma(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRowsWithoutComma();,0.2505592841163311
25309,"protected List<String> getExpectedCSVRowsWithMultipleWithoutComma(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRowsWithMultipleWithoutComma();,0.2523191094619666
25310,"protected List<String> getExpectedTextRowsWithMultipleWithoutComma(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRowsWithMultipleWithoutComma();,0.2648752399232246
25311,"protected List<String> getExpectedTextRowsWithMultiple(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRowsWithMultiple();,0.2293762575452716
25312,"protected List<String> getExpectedCSVRowsWithMultiple(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRowsWithMultiple();,0.2174757281553398
25313,"protected List<String> getExpectedCSVRows(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRows();,0.2080378250591016
25314,"protected List<String> getExpectedTextRows(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRows();,0.2222222222222222
25315,"protected List<String> getExpectedTextRowsWithoutComma(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRowsWithoutComma();,0.2657342657342657
25316,"protected List<String> getExpectedCSVRowsWithoutComma(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRowsWithoutComma();,0.2505592841163311
25317,"protected List<String> getExpectedCSVRowsWithMultipleWithoutComma(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRowsWithMultipleWithoutComma();,0.2523191094619666
25318,"protected List<String> getExpectedTextRowsWithMultipleWithoutComma(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRowsWithMultipleWithoutComma();,0.2648752399232246
25319,"protected List<String> getExpectedTextRowsWithMultiple(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRowsWithMultiple();,0.2293762575452716
25320,"protected List<String> getExpectedCSVRowsWithMultiple(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRowsWithMultiple();,0.2174757281553398
25321,"protected List<String> getExpectedCSVRows(){
  List<String> csvRows=new ArrayList<String>();
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  csvRows.add(""String_Node_Str"" + ""String_Node_Str"");
  csvRows.add(""String_Node_Str"");
  return csvRows;
}",protected abstract List<String> getExpectedCSVRows();,0.2080378250591016
25322,"protected List<String> getExpectedTextRows(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRows();,0.2222222222222222
25323,"protected List<String> getExpectedTextRowsWithoutComma(){
  List<String> txtRows=new ArrayList<String>();
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  txtRows.add(""String_Node_Str"");
  return txtRows;
}",protected abstract List<String> getExpectedTextRowsWithoutComma();,0.2657342657342657
25324,"/** 
 * Close a Lens server session.
 * @param publicId Session's public id of the session to be closed
 * @return APIResult object indicating if the operation was successful (check result.getStatus())
 */
@DELETE @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult closeSession(@QueryParam(""String_Node_Str"") UUID publicId){
  LensSessionHandle sessionHandle=openSessions.get(publicId);
  checkSessionHandle(sessionHandle);
  openSessions.remove(publicId);
  try {
    sessionService.closeSession(sessionHandle);
  }
 catch (  LensException e) {
    return new APIResult(Status.FAILED,e.getMessage());
  }
  return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + sessionHandle + ""String_Node_Str"");
}","/** 
 * Close a Lens server session.
 * @param publicId Session's public id of the session to be closed
 * @return APIResult object indicating if the operation was successful (check result.getStatus())
 */
@DELETE @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult closeSession(@PathParam(""String_Node_Str"") UUID publicId){
  LOG.info(""String_Node_Str"" + publicId);
  LensSessionHandle sessionHandle=openSessions.get(publicId);
  checkSessionHandle(sessionHandle);
  openSessions.remove(publicId);
  try {
    sessionService.closeSession(sessionHandle);
  }
 catch (  LensException e) {
    return new APIResult(Status.FAILED,e.getMessage());
  }
  return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + sessionHandle + ""String_Node_Str"");
}",0.9518377693282636
25325,"/** 
 * Builds the query.
 * @throws SemanticException the semantic exception
 * @throws HiveException the hive exception
 */
public void buildQuery() throws SemanticException, HiveException {
  analyzeInternal();
  replaceWithUnderlyingStorage(fromAST);
  fromTree=HQLParser.getString(fromAST);
  getFilterInJoinCond(fromAST);
  getAggregateColumns(selectAST);
  getJoinCond(fromAST);
  getAllFilters(whereAST);
  buildSubqueries(fromAST);
  String limit=getLimitClause(ast);
  if (whereTree == null || joinTree == null || allSubQueries.length() == 0) {
    LOG.info(""String_Node_Str"");
    constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
    return;
  }
 else {
    String factNameAndAlias=getFactNameAlias(fromAST).trim();
    factInLineQuery.append(""String_Node_Str"").append(factKeys);
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(aggColumn.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    if (factInLineQuery.toString().substring(factInLineQuery.toString().length() - 1).equals(""String_Node_Str"")) {
      factInLineQuery.setLength(factInLineQuery.length() - 1);
    }
    factInLineQuery.append(""String_Node_Str"").append(factNameAndAlias);
    if (allSubQueries != null) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(allSubQueries.toString().substring(0,allSubQueries.lastIndexOf(""String_Node_Str"")));
    }
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(factKeys.toString().substring(0,factKeys.toString().lastIndexOf(""String_Node_Str"")));
    }
    factInLineQuery.append(""String_Node_Str"");
  }
  for (  Map.Entry<String,String> entry : mapAggTabAlias.entrySet()) {
    selectTree=selectTree.replace(entry.getKey(),entry.getValue());
    if (orderByTree != null) {
      orderByTree=orderByTree.replace(entry.getKey(),entry.getValue());
    }
    if (havingTree != null) {
      havingTree=havingTree.replace(entry.getKey(),entry.getValue());
    }
  }
  constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
}","/** 
 * Builds the query.
 * @throws SemanticException the semantic exception
 * @throws HiveException the hive exception
 */
public void buildQuery() throws SemanticException, HiveException {
  analyzeInternal();
  replaceWithUnderlyingStorage(fromAST);
  fromTree=HQLParser.getString(fromAST);
  getFilterInJoinCond(fromAST);
  getAggregateColumns(selectAST);
  getJoinCond(fromAST);
  getAllFilters(whereAST);
  buildSubqueries(fromAST);
  String limit=getLimitClause(ast);
  if (whereTree == null || joinTree == null || allSubQueries.length() == 0 || aggColumn.isEmpty()) {
    LOG.info(""String_Node_Str"");
    constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
    return;
  }
 else {
    String factNameAndAlias=getFactNameAlias(fromAST).trim();
    factInLineQuery.append(""String_Node_Str"").append(factKeys);
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(aggColumn.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    if (factInLineQuery.toString().substring(factInLineQuery.toString().length() - 1).equals(""String_Node_Str"")) {
      factInLineQuery.setLength(factInLineQuery.length() - 1);
    }
    factInLineQuery.append(""String_Node_Str"").append(factNameAndAlias);
    if (allSubQueries != null) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(allSubQueries.toString().substring(0,allSubQueries.lastIndexOf(""String_Node_Str"")));
    }
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(factKeys.toString().substring(0,factKeys.toString().lastIndexOf(""String_Node_Str"")));
    }
    factInLineQuery.append(""String_Node_Str"");
  }
  for (  Map.Entry<String,String> entry : mapAggTabAlias.entrySet()) {
    selectTree=selectTree.replace(entry.getKey(),entry.getValue());
    if (orderByTree != null) {
      orderByTree=orderByTree.replace(entry.getKey(),entry.getValue());
    }
    if (havingTree != null) {
      havingTree=havingTree.replace(entry.getKey(),entry.getValue());
    }
  }
  if (selectTree.toLowerCase().matches(""String_Node_Str"")) {
    System.out.println(selectTree);
    selectTree=selectTree.replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
}",0.9565027322404372
25326,"/** 
 * Builds the query.
 * @throws SemanticException the semantic exception
 * @throws HiveException the hive exception
 */
public void buildQuery() throws SemanticException, HiveException {
  analyzeInternal();
  replaceWithUnderlyingStorage(fromAST);
  fromTree=HQLParser.getString(fromAST);
  getFilterInJoinCond(fromAST);
  getAggregateColumns(selectAST);
  getJoinCond(fromAST);
  getAllFilters(whereAST);
  buildSubqueries(fromAST);
  String limit=getLimitClause(ast);
  if (whereTree == null || joinTree == null || allSubQueries.length() == 0) {
    LOG.info(""String_Node_Str"");
    constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
    return;
  }
 else {
    String factNameAndAlias=getFactNameAlias(fromAST).trim();
    factInLineQuery.append(""String_Node_Str"").append(factKeys);
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(aggColumn.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    if (factInLineQuery.toString().substring(factInLineQuery.toString().length() - 1).equals(""String_Node_Str"")) {
      factInLineQuery.setLength(factInLineQuery.length() - 1);
    }
    factInLineQuery.append(""String_Node_Str"").append(factNameAndAlias);
    if (allSubQueries != null) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(allSubQueries.toString().substring(0,allSubQueries.lastIndexOf(""String_Node_Str"")));
    }
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(factKeys.toString().substring(0,factKeys.toString().lastIndexOf(""String_Node_Str"")));
    }
    factInLineQuery.append(""String_Node_Str"");
  }
  for (  Map.Entry<String,String> entry : mapAggTabAlias.entrySet()) {
    selectTree=selectTree.replace(entry.getKey(),entry.getValue());
    if (orderByTree != null) {
      orderByTree=orderByTree.replace(entry.getKey(),entry.getValue());
    }
    if (havingTree != null) {
      havingTree=havingTree.replace(entry.getKey(),entry.getValue());
    }
  }
  constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
}","/** 
 * Builds the query.
 * @throws SemanticException the semantic exception
 * @throws HiveException the hive exception
 */
public void buildQuery() throws SemanticException, HiveException {
  analyzeInternal();
  replaceWithUnderlyingStorage(fromAST);
  fromTree=HQLParser.getString(fromAST);
  getFilterInJoinCond(fromAST);
  getAggregateColumns(selectAST);
  getJoinCond(fromAST);
  getAllFilters(whereAST);
  buildSubqueries(fromAST);
  String limit=getLimitClause(ast);
  if (whereTree == null || joinTree == null || allSubQueries.length() == 0 || aggColumn.isEmpty()) {
    LOG.info(""String_Node_Str"");
    constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
    return;
  }
 else {
    String factNameAndAlias=getFactNameAlias(fromAST).trim();
    factInLineQuery.append(""String_Node_Str"").append(factKeys);
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(aggColumn.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    if (factInLineQuery.toString().substring(factInLineQuery.toString().length() - 1).equals(""String_Node_Str"")) {
      factInLineQuery.setLength(factInLineQuery.length() - 1);
    }
    factInLineQuery.append(""String_Node_Str"").append(factNameAndAlias);
    if (allSubQueries != null) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(allSubQueries.toString().substring(0,allSubQueries.lastIndexOf(""String_Node_Str"")));
    }
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(factKeys.toString().substring(0,factKeys.toString().lastIndexOf(""String_Node_Str"")));
    }
    factInLineQuery.append(""String_Node_Str"");
  }
  for (  Map.Entry<String,String> entry : mapAggTabAlias.entrySet()) {
    selectTree=selectTree.replace(entry.getKey(),entry.getValue());
    if (orderByTree != null) {
      orderByTree=orderByTree.replace(entry.getKey(),entry.getValue());
    }
    if (havingTree != null) {
      havingTree=havingTree.replace(entry.getKey(),entry.getValue());
    }
  }
  if (selectTree.toLowerCase().matches(""String_Node_Str"")) {
    System.out.println(selectTree);
    selectTree=selectTree.replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
}",0.9565027322404372
25327,"/** 
 * Close a Lens server session.
 * @param publicId Session's public id of the session to be closed
 * @return APIResult object indicating if the operation was successful (check result.getStatus())
 */
@DELETE @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult closeSession(@QueryParam(""String_Node_Str"") UUID publicId){
  LensSessionHandle sessionHandle=openSessions.get(publicId);
  checkSessionHandle(sessionHandle);
  openSessions.remove(publicId);
  try {
    sessionService.closeSession(sessionHandle);
  }
 catch (  LensException e) {
    return new APIResult(Status.FAILED,e.getMessage());
  }
  return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + sessionHandle + ""String_Node_Str"");
}","/** 
 * Close a Lens server session.
 * @param publicId Session's public id of the session to be closed
 * @return APIResult object indicating if the operation was successful (check result.getStatus())
 */
@DELETE @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult closeSession(@PathParam(""String_Node_Str"") UUID publicId){
  LOG.info(""String_Node_Str"" + publicId);
  LensSessionHandle sessionHandle=openSessions.get(publicId);
  checkSessionHandle(sessionHandle);
  openSessions.remove(publicId);
  try {
    sessionService.closeSession(sessionHandle);
  }
 catch (  LensException e) {
    return new APIResult(Status.FAILED,e.getMessage());
  }
  return new APIResult(Status.SUCCEEDED,""String_Node_Str"" + sessionHandle + ""String_Node_Str"");
}",0.9518377693282636
25328,"@Override public void stop(){
  List<Runnable> pending=eventHandlerPool.shutdownNow();
  if (pending != null && !pending.isEmpty()) {
    StringBuilder pendingMsg=new StringBuilder(""String_Node_Str"");
    for (    Runnable handler : pending) {
      if (handler instanceof EventHandler) {
        pendingMsg.append(((EventHandler)handler).event.getEventId()).append(""String_Node_Str"");
      }
    }
    LOG.info(""String_Node_Str"" + pending.size() + ""String_Node_Str"");
    LOG.info(pendingMsg.toString());
  }
  super.stop();
  LOG.info(""String_Node_Str"");
}","@Override public void stop(){
  if (eventHandlerPool != null) {
    List<Runnable> pending=eventHandlerPool.shutdownNow();
    if (pending != null && !pending.isEmpty()) {
      StringBuilder pendingMsg=new StringBuilder(""String_Node_Str"");
      for (      Runnable handler : pending) {
        if (handler instanceof EventHandler) {
          pendingMsg.append(((EventHandler)handler).event.getEventId()).append(""String_Node_Str"");
        }
      }
      LOG.info(""String_Node_Str"" + pending.size() + ""String_Node_Str"");
      LOG.info(pendingMsg.toString());
    }
  }
  LOG.info(""String_Node_Str"");
  super.stop();
}",0.9169491525423727
25329,"/** 
 * Persist lens service state.
 * @throws IOException Signals that an I/O exception has occurred.
 */
private synchronized void persistLensServiceState() throws IOException {
  if (conf.getBoolean(LensConfConstants.SERVER_RESTART_ENABLED,LensConfConstants.DEFAULT_SERVER_RESTART_ENABLED)) {
    FileSystem fs=persistDir.getFileSystem(conf);
    LOG.info(""String_Node_Str"" + persistDir);
    for (    LensService service : lensServices) {
      LOG.info(""String_Node_Str"" + service.getName());
      Path serviceWritePath=new Path(persistDir,service.getName() + ""String_Node_Str"");
      ObjectOutputStream out=null;
      try {
        out=new ObjectOutputStream(fs.create(serviceWritePath));
        service.writeExternal(out);
      }
  finally {
        if (out != null) {
          out.close();
        }
      }
      Path servicePath=getServicePersistPath(service);
      fs.rename(serviceWritePath,servicePath);
      LOG.info(""String_Node_Str"" + service.getName() + ""String_Node_Str""+ servicePath);
    }
  }
 else {
    LOG.info(""String_Node_Str"");
  }
}","/** 
 * Persist lens service state.
 * @throws IOException Signals that an I/O exception has occurred.
 */
private synchronized void persistLensServiceState() throws IOException {
  if (conf.getBoolean(LensConfConstants.SERVER_RESTART_ENABLED,LensConfConstants.DEFAULT_SERVER_RESTART_ENABLED)) {
    if (persistDir != null) {
      FileSystem fs=persistDir.getFileSystem(conf);
      LOG.info(""String_Node_Str"" + persistDir);
      for (      LensService service : lensServices) {
        LOG.info(""String_Node_Str"" + service.getName());
        Path serviceWritePath=new Path(persistDir,service.getName() + ""String_Node_Str"");
        ObjectOutputStream out=null;
        try {
          out=new ObjectOutputStream(fs.create(serviceWritePath));
          service.writeExternal(out);
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
        Path servicePath=getServicePersistPath(service);
        fs.rename(serviceWritePath,servicePath);
        LOG.info(""String_Node_Str"" + service.getName() + ""String_Node_Str""+ servicePath);
      }
    }
  }
 else {
    LOG.info(""String_Node_Str"");
  }
}",0.9619909502262444
25330,"@Override public synchronized void stop(){
  LensEventService eventService=(LensEventService)LensServices.get().getService(LensEventService.NAME);
  eventService.removeListener(queryStatusListener);
  queryStatusListener.stop();
  for (  ScheduledReporter reporter : reporters) {
    reporter.stop();
  }
  LOG.info(""String_Node_Str"");
  super.stop();
}","@Override public synchronized void stop(){
  LensEventService eventService=(LensEventService)LensServices.get().getService(LensEventService.NAME);
  if (eventService != null) {
    eventService.removeListener(queryStatusListener);
  }
  if (queryStatusListener != null) {
    queryStatusListener.stop();
  }
  if (reporters != null) {
    for (    ScheduledReporter reporter : reporters) {
      reporter.stop();
    }
  }
  LOG.info(""String_Node_Str"");
  super.stop();
}",0.7815533980582524
25331,"@Test public void testCubeDriverRestart() throws Exception {
  CubeGrillDriver cubeDriver=new CubeGrillDriver(conf);
  String query=""String_Node_Str"";
  DriverQueryPlan plan=cubeDriver.explain(query,conf);
  String planString=plan.getPlan();
  Assert.assertEquals(query,planString);
  cubeDriver.executePrepareAsync(plan.getHandle(),conf);
  Assert.assertEquals(cubeDriver.getStatus(plan.getHandle()).getStatus(),QueryStatus.Status.SUCCESSFUL);
  ByteArrayOutputStream driverOut=new ByteArrayOutputStream();
  ObjectOutputStream out=new ObjectOutputStream(driverOut);
  cubeDriver.writeExternal(out);
  out.close();
  System.out.println(Arrays.toString(driverOut.toByteArray()));
  ByteArrayInputStream driverIn=new ByteArrayInputStream(driverOut.toByteArray());
  CubeGrillDriver newDriver=new CubeGrillDriver(conf);
  newDriver.readExternal(new ObjectInputStream(driverIn));
  driverIn.close();
  Assert.assertEquals(newDriver.getDrivers().size(),cubeDriver.getDrivers().size());
  Assert.assertEquals(cubeDriver.getStatus(plan.getHandle()).getStatus(),QueryStatus.Status.SUCCESSFUL);
}","@Test public void testCubeDriverRestart() throws Exception {
  CubeGrillDriver cubeDriver=new CubeGrillDriver(conf);
  String query=""String_Node_Str"";
  QueryHandle handle=cubeDriver.executeAsync(query,conf);
  ByteArrayOutputStream driverOut=new ByteArrayOutputStream();
  ObjectOutputStream out=new ObjectOutputStream(driverOut);
  cubeDriver.writeExternal(out);
  out.close();
  System.out.println(Arrays.toString(driverOut.toByteArray()));
  ByteArrayInputStream driverIn=new ByteArrayInputStream(driverOut.toByteArray());
  CubeGrillDriver newDriver=new CubeGrillDriver(conf);
  newDriver.readExternal(new ObjectInputStream(driverIn));
  driverIn.close();
  Assert.assertEquals(newDriver.getDrivers().size(),cubeDriver.getDrivers().size());
  Assert.assertEquals(cubeDriver.getStatus(handle).getStatus(),QueryStatus.Status.SUCCESSFUL);
}",0.327461139896373
25332,"@Test public void testCubeDriver() throws Exception {
  String addQ=""String_Node_Str"";
  GrillResultSet result=cubeDriver.execute(addQ,conf);
  Assert.assertNotNull(result);
  Assert.assertEquals(((MockDriver)cubeDriver.getDrivers().get(0)).query,addQ);
  String setQ=""String_Node_Str"";
  result=cubeDriver.execute(setQ,conf);
  Assert.assertNotNull(result);
  Assert.assertEquals(((MockDriver)cubeDriver.getDrivers().get(0)).query,setQ);
  String query=""String_Node_Str"";
  DriverQueryPlan plan=cubeDriver.explain(query,conf);
  String planString=plan.getPlan();
  Assert.assertEquals(query,planString);
  cubeDriver.executePrepareAsync(plan.getHandle(),conf);
  Assert.assertEquals(cubeDriver.getStatus(plan.getHandle()).getStatus(),QueryStatus.Status.SUCCESSFUL);
  Assert.assertFalse(cubeDriver.cancelQuery(plan.getHandle()));
  result=cubeDriver.executePrepare(plan.getHandle(),conf);
  Assert.assertNotNull(result);
  Assert.assertNotNull(result.getMetadata());
  Assert.assertEquals(cubeDriver.getStatus(plan.getHandle()).getStatus(),QueryStatus.Status.SUCCESSFUL);
  cubeDriver.closeQuery(plan.getHandle());
  Throwable th=null;
  try {
    cubeDriver.getStatus(plan.getHandle());
  }
 catch (  GrillException e) {
    th=e;
  }
  Assert.assertNotNull(th);
  result=cubeDriver.execute(query,conf);
  Assert.assertNotNull(result);
  Assert.assertNotNull(result.getMetadata());
  QueryHandle handle=cubeDriver.executeAsync(query,conf);
  Assert.assertEquals(cubeDriver.getStatus(handle).getStatus(),QueryStatus.Status.SUCCESSFUL);
  Assert.assertFalse(cubeDriver.cancelQuery(handle));
  cubeDriver.closeQuery(handle);
  th=null;
  try {
    cubeDriver.getStatus(handle);
  }
 catch (  GrillException e) {
    th=e;
  }
  Assert.assertNotNull(th);
}","@Test public void testCubeDriver() throws Exception {
  String addQ=""String_Node_Str"";
  GrillResultSet result=cubeDriver.execute(addQ,conf);
  Assert.assertNotNull(result);
  Assert.assertEquals(((MockDriver)cubeDriver.getDrivers().get(0)).query,addQ);
  String setQ=""String_Node_Str"";
  result=cubeDriver.execute(setQ,conf);
  Assert.assertNotNull(result);
  Assert.assertEquals(((MockDriver)cubeDriver.getDrivers().get(0)).query,setQ);
  String query=""String_Node_Str"";
  DriverQueryPlan plan=cubeDriver.explain(query,conf);
  String planString=plan.getPlan();
  Assert.assertEquals(query,planString);
  result=cubeDriver.execute(query,conf);
  Assert.assertNotNull(result);
  Assert.assertNotNull(result.getMetadata());
  QueryHandle handle=cubeDriver.executeAsync(query,conf);
  Assert.assertEquals(cubeDriver.getStatus(handle).getStatus(),QueryStatus.Status.SUCCESSFUL);
  Assert.assertFalse(cubeDriver.cancelQuery(handle));
  cubeDriver.closeQuery(handle);
  Throwable th=null;
  try {
    cubeDriver.getStatus(handle);
  }
 catch (  GrillException e) {
    th=e;
  }
  Assert.assertNotNull(th);
}",0.6410076976906928
25333,"protected void replaceWithUnderlyingStorage(ASTNode tree,CubeMetastoreClient metastoreClient) throws HiveException {
  if (tree == null) {
    return;
  }
  if (TOK_TABNAME == tree.getToken().getType()) {
    if (tree.getChildCount() == 2) {
      ASTNode dbIdentifier=(ASTNode)tree.getChild(0);
      ASTNode tableIdentifier=(ASTNode)tree.getChild(1);
      String grillTable=tableIdentifier.getText();
      String table=getUnderlyingTableName(metastoreClient,grillTable);
      String db=getUnderlyingDBName(metastoreClient,grillTable);
      if (""String_Node_Str"".equalsIgnoreCase(db)) {
        tree.deleteChild(0);
      }
 else       if (StringUtils.isNotBlank(db)) {
        dbIdentifier.getToken().setText(db);
      }
      if (StringUtils.isNotBlank(table)) {
        tableIdentifier.getToken().setText(table);
      }
    }
 else {
      ASTNode tableIdentifier=(ASTNode)tree.getChild(0);
      String grillTable=tableIdentifier.getText();
      String table=getUnderlyingTableName(metastoreClient,grillTable);
      if (StringUtils.isNotBlank(table)) {
        tableIdentifier.getToken().setText(table);
      }
      String dbName=getUnderlyingDBName(metastoreClient,grillTable);
      if (StringUtils.isNotBlank(dbName) && !""String_Node_Str"".equalsIgnoreCase(dbName)) {
        ASTNode dbIdentifier=new ASTNode(new CommonToken(HiveParser.Identifier,dbName));
        dbIdentifier.setParent(tree);
        tree.insertChild(0,dbIdentifier);
      }
    }
  }
 else {
    for (int i=0; i < tree.getChildCount(); i++) {
      replaceWithUnderlyingStorage((ASTNode)tree.getChild(i),metastoreClient);
    }
  }
}","protected void replaceWithUnderlyingStorage(ASTNode tree,CubeMetastoreClient metastoreClient){
  if (tree == null) {
    return;
  }
  if (TOK_TABNAME == tree.getToken().getType()) {
    try {
      if (tree.getChildCount() == 2) {
        ASTNode dbIdentifier=(ASTNode)tree.getChild(0);
        ASTNode tableIdentifier=(ASTNode)tree.getChild(1);
        String grillTable=tableIdentifier.getText();
        String table=getUnderlyingTableName(metastoreClient,grillTable);
        String db=getUnderlyingDBName(metastoreClient,grillTable);
        if (""String_Node_Str"".equalsIgnoreCase(db)) {
          tree.deleteChild(0);
        }
 else         if (StringUtils.isNotBlank(db)) {
          dbIdentifier.getToken().setText(db);
        }
        if (StringUtils.isNotBlank(table)) {
          tableIdentifier.getToken().setText(table);
        }
      }
 else {
        ASTNode tableIdentifier=(ASTNode)tree.getChild(0);
        String grillTable=tableIdentifier.getText();
        String table=getUnderlyingTableName(metastoreClient,grillTable);
        if (StringUtils.isNotBlank(table)) {
          tableIdentifier.getToken().setText(table);
        }
        String dbName=getUnderlyingDBName(metastoreClient,grillTable);
        if (StringUtils.isNotBlank(dbName) && !""String_Node_Str"".equalsIgnoreCase(dbName)) {
          ASTNode dbIdentifier=new ASTNode(new CommonToken(HiveParser.Identifier,dbName));
          dbIdentifier.setParent(tree);
          tree.insertChild(0,dbIdentifier);
        }
      }
    }
 catch (    HiveException e) {
      LOG.warn(""String_Node_Str"" + e.getMessage());
    }
  }
 else {
    for (int i=0; i < tree.getChildCount(); i++) {
      replaceWithUnderlyingStorage((ASTNode)tree.getChild(i),metastoreClient);
    }
  }
}",0.1637599763523499
25334,"private SessionHandle getSession(QueryContext ctx) throws GrillException {
  sessionLock.lock();
  try {
    String grillSession=null;
    if (SessionState.get() != null) {
      grillSession=SessionState.get().getSessionId();
    }
    if (grillSession == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    SessionHandle hiveSession;
    if (!grillToHiveSession.containsKey(grillSession)) {
      try {
        hiveSession=getClient().openSession(SessionState.get().getUserName(),""String_Node_Str"");
        grillToHiveSession.put(grillSession,hiveSession);
        LOG.info(""String_Node_Str"" + SessionState.get().getUserName() + ""String_Node_Str""+ grillSession+ ""String_Node_Str""+ hiveSession.getHandleIdentifier());
        for (        GrillEventListener<DriverEvent> eventListener : driverListeners) {
          try {
            eventListener.onEvent(new DriverSessionStarted(System.currentTimeMillis(),this,grillSession,hiveSession.getSessionId().toString()));
          }
 catch (          Exception exc) {
            LOG.error(""String_Node_Str"" + eventListener,exc);
          }
        }
      }
 catch (      Exception e) {
        throw new GrillException(e);
      }
    }
 else {
      hiveSession=grillToHiveSession.get(grillSession);
    }
    return hiveSession;
  }
  finally {
    sessionLock.unlock();
  }
}","private SessionHandle getSession(QueryContext ctx) throws GrillException {
  sessionLock.lock();
  try {
    String grillSession=ctx.getGrillSessionIdentifier();
    if (grillSession == null && SessionState.get() != null) {
      grillSession=SessionState.get().getSessionId();
    }
    if (grillSession == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    SessionHandle hiveSession;
    if (!grillToHiveSession.containsKey(grillSession)) {
      try {
        hiveSession=getClient().openSession(ctx.getClusterUser(),""String_Node_Str"");
        grillToHiveSession.put(grillSession,hiveSession);
        LOG.info(""String_Node_Str"" + ctx.getClusterUser() + ""String_Node_Str""+ grillSession+ ""String_Node_Str""+ hiveSession.getHandleIdentifier());
        for (        GrillEventListener<DriverEvent> eventListener : driverListeners) {
          try {
            eventListener.onEvent(new DriverSessionStarted(System.currentTimeMillis(),this,grillSession,hiveSession.getSessionId().toString()));
          }
 catch (          Exception exc) {
            LOG.error(""String_Node_Str"" + eventListener,exc);
          }
        }
      }
 catch (      Exception e) {
        throw new GrillException(e);
      }
    }
 else {
      hiveSession=grillToHiveSession.get(grillSession);
    }
    return hiveSession;
  }
  finally {
    sessionLock.unlock();
  }
}",0.9447493596780095
25335,"public String getClusterUser(){
  return conf.get(GrillConfConstants.GRILL_SESSION_CLUSTER_USER);
}","public String getClusterUser(){
  return conf.get(GrillConfConstants.GRILL_SESSION_CLUSTER_USER,submittedUser);
}",0.9339622641509434
25336,"/** 
 * Acquire a grill session specified by the public UUID
 * @param sessionHandle public UUID of the session
 * @throws GrillException if session cannot be acquired
 */
public void acquire(String sessionHandle) throws GrillException {
  getSession(sessionMap.get(sessionHandle)).acquire();
}","/** 
 * Acquire a grill session specified by the public UUID
 * @param sessionHandle public UUID of the session
 * @throws GrillException if session cannot be acquired
 */
public void acquire(String sessionHandle){
  acquire(sessionMap.get(sessionHandle));
}",0.9094202898550724
25337,"public GrillSessionHandle openSession(String username,String password,Map<String,String> configuration) throws GrillException {
  SessionHandle sessionHandle;
  username=UtilityMethods.removeDomain(username);
  doPasswdAuth(username,password);
  try {
    Map<String,String> sessionConf=new HashMap<String,String>();
    sessionConf.putAll(GrillSessionImpl.DEFAULT_HIVE_SESSION_CONF);
    if (configuration != null) {
      sessionConf.putAll(configuration);
    }
    Map<String,String> userConfig=UserConfigLoaderFactory.getUserConfig(username);
    UtilityMethods.mergeMaps(sessionConf,userConfig,false);
    sessionConf.put(GrillConfConstants.GRILL_SESSION_LOGGEDIN_USER,username);
    if (sessionConf.get(GrillConfConstants.GRILL_SESSION_CLUSTER_USER) == null) {
      LOG.info(""String_Node_Str"" + username);
      sessionConf.put(GrillConfConstants.GRILL_SESSION_CLUSTER_USER,username);
    }
    String clusterUser=sessionConf.get(GrillConfConstants.GRILL_SESSION_CLUSTER_USER);
    password=""String_Node_Str"";
    if (cliService.getHiveConf().getVar(ConfVars.HIVE_SERVER2_AUTHENTICATION).equals(HiveAuthFactory.AuthTypes.KERBEROS.toString()) && cliService.getHiveConf().getBoolVar(ConfVars.HIVE_SERVER2_ENABLE_DOAS)) {
      String delegationTokenStr=null;
      try {
        delegationTokenStr=cliService.getDelegationTokenFromMetaStore(username);
      }
 catch (      UnsupportedOperationException e) {
      }
      sessionHandle=cliService.openSessionWithImpersonation(clusterUser,password,sessionConf,delegationTokenStr);
    }
 else {
      sessionHandle=cliService.openSession(clusterUser,password,sessionConf);
    }
  }
 catch (  Exception e) {
    throw new GrillException(e);
  }
  GrillSessionHandle grillSession=new GrillSessionHandle(sessionHandle.getHandleIdentifier().getPublicId(),sessionHandle.getHandleIdentifier().getSecretId());
  sessionMap.put(grillSession.getPublicId().toString(),grillSession);
  return grillSession;
}","public GrillSessionHandle openSession(String username,String password,Map<String,String> configuration) throws GrillException {
  if (StringUtils.isBlank(username)) {
    throw new BadRequestException(""String_Node_Str"");
  }
  SessionHandle sessionHandle;
  username=UtilityMethods.removeDomain(username);
  doPasswdAuth(username,password);
  try {
    Map<String,String> sessionConf=new HashMap<String,String>();
    sessionConf.putAll(GrillSessionImpl.DEFAULT_HIVE_SESSION_CONF);
    if (configuration != null) {
      sessionConf.putAll(configuration);
    }
    Map<String,String> userConfig=UserConfigLoaderFactory.getUserConfig(username);
    UtilityMethods.mergeMaps(sessionConf,userConfig,false);
    sessionConf.put(GrillConfConstants.GRILL_SESSION_LOGGEDIN_USER,username);
    if (sessionConf.get(GrillConfConstants.GRILL_SESSION_CLUSTER_USER) == null) {
      LOG.info(""String_Node_Str"" + username);
      sessionConf.put(GrillConfConstants.GRILL_SESSION_CLUSTER_USER,username);
    }
    String clusterUser=sessionConf.get(GrillConfConstants.GRILL_SESSION_CLUSTER_USER);
    password=""String_Node_Str"";
    if (cliService.getHiveConf().getVar(ConfVars.HIVE_SERVER2_AUTHENTICATION).equals(HiveAuthFactory.AuthTypes.KERBEROS.toString()) && cliService.getHiveConf().getBoolVar(ConfVars.HIVE_SERVER2_ENABLE_DOAS)) {
      String delegationTokenStr=null;
      try {
        delegationTokenStr=cliService.getDelegationTokenFromMetaStore(username);
      }
 catch (      UnsupportedOperationException e) {
      }
      sessionHandle=cliService.openSessionWithImpersonation(clusterUser,password,sessionConf,delegationTokenStr);
    }
 else {
      sessionHandle=cliService.openSession(clusterUser,password,sessionConf);
    }
  }
 catch (  Exception e) {
    throw new GrillException(e);
  }
  GrillSessionHandle grillSession=new GrillSessionHandle(sessionHandle.getHandleIdentifier().getPublicId(),sessionHandle.getHandleIdentifier().getSecretId());
  sessionMap.put(grillSession.getPublicId().toString(),grillSession);
  return grillSession;
}",0.9757802746566792
25338,"public GrillSessionImpl getSession(GrillSessionHandle sessionHandle) throws GrillException {
  try {
    return ((GrillSessionImpl)getSessionManager().getSession(getHiveSessionHandle(sessionHandle)));
  }
 catch (  HiveSQLException exc) {
    LOG.warn(""String_Node_Str"",exc);
    throw new NotFoundException(""String_Node_Str"" + sessionHandle);
  }
catch (  Exception e) {
    throw new GrillException(e);
  }
}","public GrillSessionImpl getSession(GrillSessionHandle sessionHandle){
  try {
    return ((GrillSessionImpl)getSessionManager().getSession(getHiveSessionHandle(sessionHandle)));
  }
 catch (  HiveSQLException exc) {
    LOG.warn(""String_Node_Str"",exc);
    throw new NotFoundException(""String_Node_Str"" + sessionHandle);
  }
}",0.8858695652173914
25339,"protected void handleDriverSessionStart(DriverEvent event){
  DriverSessionStarted sessionStarted=(DriverSessionStarted)event;
  if (!(event.getDriver() instanceof HiveDriver)) {
    return;
  }
  HiveDriver hiveDriver=(HiveDriver)event.getDriver();
  String grillSession=sessionStarted.getGrillSessionID();
  GrillSessionHandle sessionHandle=getSessionHandle(grillSession);
  try {
    GrillSessionImpl session=getSession(sessionHandle);
    acquire(sessionHandle);
    List<GrillSessionImpl.ResourceEntry> resources=session.getGrillSessionPersistInfo().getResources();
    if (resources != null && !resources.isEmpty()) {
      for (      GrillSessionImpl.ResourceEntry resource : resources) {
        LOG.info(""String_Node_Str"" + resource + ""String_Node_Str""+ grillSession);
        try {
          hiveDriver.execute(createAddResourceQuery(sessionHandle,resource.getType(),resource.getLocation()));
          resource.restoredResource();
          LOG.info(""String_Node_Str"" + resource + ""String_Node_Str""+ grillSession);
        }
 catch (        Exception exc) {
          LOG.error(""String_Node_Str"" + resource + ""String_Node_Str""+ grillSession,exc);
        }
      }
    }
 else {
      LOG.info(""String_Node_Str"" + grillSession);
    }
  }
 catch (  GrillException e) {
    LOG.warn(""String_Node_Str"" + grillSession + ""String_Node_Str""+ ((DriverSessionStarted)event).getDriverSessionID(),e);
  }
 finally {
    try {
      release(sessionHandle);
    }
 catch (    GrillException e) {
      LOG.error(""String_Node_Str"" + sessionHandle,e);
    }
  }
}","protected void handleDriverSessionStart(DriverEvent event){
  DriverSessionStarted sessionStarted=(DriverSessionStarted)event;
  if (!(event.getDriver() instanceof HiveDriver)) {
    return;
  }
  HiveDriver hiveDriver=(HiveDriver)event.getDriver();
  String grillSession=sessionStarted.getGrillSessionID();
  GrillSessionHandle sessionHandle=getSessionHandle(grillSession);
  if (sessionHandle == null) {
    LOG.warn(""String_Node_Str"" + grillSession);
    return;
  }
  try {
    GrillSessionImpl session=getSession(sessionHandle);
    acquire(sessionHandle);
    List<GrillSessionImpl.ResourceEntry> resources=session.getGrillSessionPersistInfo().getResources();
    if (resources != null && !resources.isEmpty()) {
      for (      GrillSessionImpl.ResourceEntry resource : resources) {
        LOG.info(""String_Node_Str"" + resource + ""String_Node_Str""+ grillSession);
        try {
          hiveDriver.execute(createAddResourceQuery(sessionHandle,resource.getType(),resource.getLocation()));
          resource.restoredResource();
          LOG.info(""String_Node_Str"" + resource + ""String_Node_Str""+ grillSession);
        }
 catch (        Exception exc) {
          LOG.error(""String_Node_Str"" + resource + ""String_Node_Str""+ grillSession,exc);
        }
      }
    }
 else {
      LOG.info(""String_Node_Str"" + grillSession);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + grillSession + ""String_Node_Str""+ ((DriverSessionStarted)event).getDriverSessionID(),e);
  }
 finally {
    release(sessionHandle);
  }
}",0.932258064516129
25340,"@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(sessionMap.size());
  for (  GrillSessionHandle sessionHandle : sessionMap.values()) {
    try {
      GrillSessionImpl session=getSession(sessionHandle);
      session.getGrillSessionPersistInfo().writeExternal(out);
    }
 catch (    GrillException e) {
      throw new IOException(e);
    }
  }
  LOG.info(""String_Node_Str"" + sessionMap.size() + ""String_Node_Str"");
}","@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(sessionMap.size());
  for (  GrillSessionHandle sessionHandle : sessionMap.values()) {
    GrillSessionImpl session=getSession(sessionHandle);
    session.getGrillSessionPersistInfo().writeExternal(out);
  }
  LOG.info(""String_Node_Str"" + sessionMap.size() + ""String_Node_Str"");
}",0.891566265060241
25341,"public void runInternal(){
  List<GrillSessionHandle> sessionsToRemove=new ArrayList<GrillSessionHandle>(sessionMap.values());
  Iterator<GrillSessionHandle> itr=sessionsToRemove.iterator();
  while (itr.hasNext()) {
    GrillSessionHandle sessionHandle=itr.next();
    try {
      GrillSessionImpl session=getSession(sessionHandle);
      if (session.isActive()) {
        itr.remove();
      }
    }
 catch (    NotFoundException nfe) {
      itr.remove();
    }
catch (    GrillException e) {
      itr.remove();
    }
  }
  for (  GrillSessionHandle sessionHandle : sessionsToRemove) {
    try {
      long lastAccessTime=getSession(sessionHandle).getLastAccessTime();
      closeSession(sessionHandle);
      LOG.info(""String_Node_Str"" + sessionHandle.getPublicId() + ""String_Node_Str""+ new Date(lastAccessTime));
    }
 catch (    NotFoundException nfe) {
    }
catch (    GrillException e) {
      LOG.error(""String_Node_Str"" + sessionHandle.getPublicId() + ""String_Node_Str""+ e.getMessage());
    }
  }
}","public void runInternal(){
  List<GrillSessionHandle> sessionsToRemove=new ArrayList<GrillSessionHandle>(sessionMap.values());
  Iterator<GrillSessionHandle> itr=sessionsToRemove.iterator();
  while (itr.hasNext()) {
    GrillSessionHandle sessionHandle=itr.next();
    try {
      GrillSessionImpl session=getSession(sessionHandle);
      if (session.isActive()) {
        itr.remove();
      }
    }
 catch (    NotFoundException nfe) {
      itr.remove();
    }
  }
  for (  GrillSessionHandle sessionHandle : sessionsToRemove) {
    try {
      long lastAccessTime=getSession(sessionHandle).getLastAccessTime();
      closeSession(sessionHandle);
      LOG.info(""String_Node_Str"" + sessionHandle.getPublicId() + ""String_Node_Str""+ new Date(lastAccessTime));
    }
 catch (    NotFoundException nfe) {
    }
catch (    GrillException e) {
      LOG.error(""String_Node_Str"" + sessionHandle.getPublicId() + ""String_Node_Str""+ e.getMessage());
    }
  }
}",0.971021860701576
25342,"@Override public synchronized void start(){
  super.start();
  sessionExpiryThread=Executors.newSingleThreadScheduledExecutor();
  sessionExpiryThread.scheduleWithFixedDelay(sessionExpiryRunnable,60,60,TimeUnit.MINUTES);
  if (restorableSessions == null || restorableSessions.size() <= 0) {
    LOG.info(""String_Node_Str"");
    return;
  }
  for (  GrillSessionImpl.GrillSessionPersistInfo persistInfo : restorableSessions) {
    try {
      GrillSessionHandle sessionHandle=persistInfo.getSessionHandle();
      restoreSession(sessionHandle,persistInfo.getUsername(),persistInfo.getPassword());
      GrillSessionImpl session=getSession(sessionHandle);
      session.setLastAccessTime(persistInfo.getLastAccessTime());
      session.getGrillSessionPersistInfo().setConfig(persistInfo.getConfig());
      session.getGrillSessionPersistInfo().setResources(persistInfo.getResources());
      session.setCurrentDatabase(persistInfo.getDatabase());
      for (      GrillSessionImpl.ResourceEntry resourceEntry : session.getResources()) {
        try {
          addResource(sessionHandle,resourceEntry.getType(),resourceEntry.getLocation(),false);
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"" + session + ""String_Node_Str""+ resourceEntry);
          throw new RuntimeException(e);
        }
      }
      for (      Map.Entry<String,String> cfg : session.getConfig().entrySet()) {
        try {
          setSessionParameter(sessionHandle,cfg.getKey(),cfg.getValue(),false);
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"" + cfg.getKey() + ""String_Node_Str""+ cfg.getValue()+ ""String_Node_Str""+ session);
        }
      }
      LOG.info(""String_Node_Str"" + persistInfo.getSessionHandle().getPublicId());
    }
 catch (    GrillException e) {
      throw new RuntimeException(e);
    }
  }
  LOG.info(""String_Node_Str"" + restorableSessions.size() + ""String_Node_Str"");
}","@Override public synchronized void start(){
  super.start();
  sessionExpiryThread=Executors.newSingleThreadScheduledExecutor();
  sessionExpiryThread.scheduleWithFixedDelay(sessionExpiryRunnable,60,60,TimeUnit.MINUTES);
  if (restorableSessions == null || restorableSessions.size() <= 0) {
    LOG.info(""String_Node_Str"");
    return;
  }
  for (  GrillSessionImpl.GrillSessionPersistInfo persistInfo : restorableSessions) {
    try {
      GrillSessionHandle sessionHandle=persistInfo.getSessionHandle();
      restoreSession(sessionHandle,persistInfo.getUsername(),persistInfo.getPassword());
      GrillSessionImpl session=getSession(sessionHandle);
      session.setLastAccessTime(persistInfo.getLastAccessTime());
      session.getGrillSessionPersistInfo().setConfig(persistInfo.getConfig());
      session.getGrillSessionPersistInfo().setResources(persistInfo.getResources());
      session.setCurrentDatabase(persistInfo.getDatabase());
      for (      GrillSessionImpl.ResourceEntry resourceEntry : session.getResources()) {
        try {
          addResource(sessionHandle,resourceEntry.getType(),resourceEntry.getLocation());
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"" + session + ""String_Node_Str""+ resourceEntry);
          throw new RuntimeException(e);
        }
      }
      for (      Map.Entry<String,String> cfg : session.getConfig().entrySet()) {
        try {
          setSessionParameter(sessionHandle,cfg.getKey(),cfg.getValue(),false);
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"" + cfg.getKey() + ""String_Node_Str""+ cfg.getValue()+ ""String_Node_Str""+ session);
        }
      }
      LOG.info(""String_Node_Str"" + persistInfo.getSessionHandle().getPublicId());
    }
 catch (    GrillException e) {
      throw new RuntimeException(e);
    }
  }
  LOG.info(""String_Node_Str"" + restorableSessions.size() + ""String_Node_Str"");
}",0.9984439834024896
25343,"public void deleteResource(GrillSessionHandle sessionid,String type,String path){
  String command=""String_Node_Str"" + type.toLowerCase() + ""String_Node_Str""+ path;
  try {
    acquire(sessionid);
    getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
    getSession(sessionid).removeResource(type,path);
  }
 catch (  HiveSQLException e) {
    throw new WebApplicationException(e);
  }
catch (  GrillException e) {
    throw new WebApplicationException(e);
  }
 finally {
    try {
      release(sessionid);
    }
 catch (    GrillException e) {
      throw new WebApplicationException(e);
    }
  }
}","public void deleteResource(GrillSessionHandle sessionid,String type,String path){
  String command=""String_Node_Str"" + type.toLowerCase() + ""String_Node_Str""+ path;
  try {
    acquire(sessionid);
    getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
    getSession(sessionid).removeResource(type,path);
  }
 catch (  HiveSQLException e) {
    throw new WebApplicationException(e);
  }
 finally {
    release(sessionid);
  }
}",0.7930082796688133
25344,"private void addResource(GrillSessionHandle sessionid,String type,String path,boolean addToSession){
  String command=""String_Node_Str"" + type.toLowerCase() + ""String_Node_Str""+ path;
  try {
    acquire(sessionid);
    getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
    if (addToSession) {
      getSession(sessionid).addResource(type,path);
    }
  }
 catch (  HiveSQLException e) {
    throw new WebApplicationException(e);
  }
catch (  GrillException e) {
    throw new WebApplicationException(e);
  }
 finally {
    try {
      release(sessionid);
    }
 catch (    GrillException e) {
      throw new WebApplicationException(e);
    }
  }
}","public void addResource(GrillSessionHandle sessionid,String type,String path){
  String command=""String_Node_Str"" + type.toLowerCase() + ""String_Node_Str""+ path;
  try {
    acquire(sessionid);
    getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
  }
 catch (  HiveSQLException e) {
    throw new WebApplicationException(e);
  }
 finally {
    release(sessionid);
  }
}",0.6839666357738647
25345,"public GrillSessionHandle openSession(String username,String password,Map<String,String> configuration) throws GrillException {
  GrillSessionHandle sessionid=super.openSession(username,password,configuration);
  String[] auxJars=getSession(sessionid).getSessionConf().getStrings(GrillConfConstants.AUX_JARS);
  if (auxJars != null) {
    LOG.info(""String_Node_Str"" + auxJars);
    for (    String jar : auxJars) {
      addResource(sessionid,""String_Node_Str"",jar);
    }
  }
  return sessionid;
}","public GrillSessionHandle openSession(String username,String password,Map<String,String> configuration) throws GrillException {
  GrillSessionHandle sessionid=super.openSession(username,password,configuration);
  LOG.info(""String_Node_Str"" + sessionid + ""String_Node_Str""+ username);
  String[] auxJars=getSession(sessionid).getSessionConf().getStrings(GrillConfConstants.AUX_JARS);
  if (auxJars != null) {
    LOG.info(""String_Node_Str"" + auxJars);
    for (    String jar : auxJars) {
      addResourceToAllServices(sessionid,""String_Node_Str"",jar);
    }
  }
  return sessionid;
}",0.9205175600739371
25346,"public List<String> getAllSessionParameters(GrillSessionHandle sessionid,boolean verbose,String key) throws GrillException {
  List<String> result=new ArrayList<String>();
  acquire(sessionid);
  SessionState ss=getSession(sessionid).getSessionState();
  if (!StringUtils.isBlank(key)) {
    result.add(getSessionParam(getSession(sessionid).getSessionConf(),ss,key));
  }
 else {
    try {
      SortedMap<String,String> sortedMap=new TreeMap<String,String>();
      sortedMap.put(""String_Node_Str"",(ss.getIsSilent() ? ""String_Node_Str"" : ""String_Node_Str""));
      for (      String s : ss.getHiveVariables().keySet()) {
        sortedMap.put(SetProcessor.HIVEVAR_PREFIX + s,ss.getHiveVariables().get(s));
      }
      for (      Map.Entry<String,String> entry : getSession(sessionid).getSessionConf()) {
        sortedMap.put(entry.getKey(),entry.getValue());
      }
      for (      Map.Entry<String,String> entry : sortedMap.entrySet()) {
        result.add(entry.toString());
      }
    }
 catch (    GrillException e) {
      throw new WebApplicationException(e);
    }
 finally {
      try {
        release(sessionid);
      }
 catch (      GrillException e) {
        throw new WebApplicationException(e);
      }
    }
  }
  return result;
}","public List<String> getAllSessionParameters(GrillSessionHandle sessionid,boolean verbose,String key) throws GrillException {
  List<String> result=new ArrayList<String>();
  acquire(sessionid);
  try {
    SessionState ss=getSession(sessionid).getSessionState();
    if (!StringUtils.isBlank(key)) {
      result.add(getSessionParam(getSession(sessionid).getSessionConf(),ss,key));
    }
 else {
      SortedMap<String,String> sortedMap=new TreeMap<String,String>();
      sortedMap.put(""String_Node_Str"",(ss.getIsSilent() ? ""String_Node_Str"" : ""String_Node_Str""));
      for (      String s : ss.getHiveVariables().keySet()) {
        sortedMap.put(SetProcessor.HIVEVAR_PREFIX + s,ss.getHiveVariables().get(s));
      }
      for (      Map.Entry<String,String> entry : getSession(sessionid).getSessionConf()) {
        sortedMap.put(entry.getKey(),entry.getValue());
      }
      for (      Map.Entry<String,String> entry : sortedMap.entrySet()) {
        result.add(entry.toString());
      }
    }
  }
  finally {
    release(sessionid);
  }
  return result;
}",0.8676153514445882
25347,"protected void setSessionParameter(GrillSessionHandle sessionid,String key,String value,boolean addToSession){
  LOG.info(""String_Node_Str"" + key + ""String_Node_Str""+ value);
  String command=""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str""+ value;
  try {
    acquire(sessionid);
    String var;
    if (key.indexOf(SetProcessor.HIVECONF_PREFIX) == 0) {
      var=key.substring(SetProcessor.HIVECONF_PREFIX.length());
    }
 else {
      var=key;
    }
    getSession(sessionid).getSessionConf().set(var,value);
    getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
    if (addToSession) {
      getSession(sessionid).setConfig(key,value);
    }
    LOG.info(""String_Node_Str"" + key + ""String_Node_Str""+ value);
  }
 catch (  HiveSQLException e) {
    throw new WebApplicationException(e);
  }
catch (  GrillException e) {
    throw new WebApplicationException(e);
  }
 finally {
    try {
      release(sessionid);
    }
 catch (    GrillException e) {
      throw new WebApplicationException(e);
    }
  }
}","protected void setSessionParameter(GrillSessionHandle sessionid,String key,String value,boolean addToSession){
  LOG.info(""String_Node_Str"" + key + ""String_Node_Str""+ value);
  String command=""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str""+ value;
  try {
    acquire(sessionid);
    String var;
    if (key.indexOf(SetProcessor.HIVECONF_PREFIX) == 0) {
      var=key.substring(SetProcessor.HIVECONF_PREFIX.length());
    }
 else {
      var=key;
    }
    getSession(sessionid).getSessionConf().set(var,value);
    getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
    if (addToSession) {
      getSession(sessionid).setConfig(key,value);
    }
    LOG.info(""String_Node_Str"" + key + ""String_Node_Str""+ value);
  }
 catch (  HiveSQLException e) {
    throw new WebApplicationException(e);
  }
 finally {
    release(sessionid);
  }
}",0.8837209302325582
25348,"/** 
 * Add a resource to the session to all GrillServices running in this Grill server <p> The returned @{link APIResult} will have status SUCCEEDED <em>only if</em> the add operation was successful for all services running in this Grill server. </p>
 * @param sessionid session handle object
 * @param type The type of resource. Valid types are 'jar', 'file' and 'archive'
 * @param path path of the resource
 * @return {@link APIResult} with state {@link Status#SUCCEEDED}, if add was successful.  {@link APIResult} with state {@link Status#PARTIAL}, if add succeeded only for some services.  {@link APIResult} with state {@link Status#FAILED}, if add has failed
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.MULTIPART_FORM_DATA}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult addResource(@FormDataParam(""String_Node_Str"") GrillSessionHandle sessionid,@FormDataParam(""String_Node_Str"") String type,@FormDataParam(""String_Node_Str"") String path){
  int numAdded=0;
  for (  GrillService service : GrillServices.get().getGrillServices()) {
    try {
      service.addResource(sessionid,type,path);
      numAdded++;
    }
 catch (    GrillException e) {
      LOG.error(""String_Node_Str"" + service,e);
      if (numAdded != 0) {
        return new APIResult(Status.PARTIAL,""String_Node_Str"" + service.getName());
      }
 else {
        return new APIResult(Status.FAILED,""String_Node_Str"");
      }
    }
  }
  return new APIResult(Status.SUCCEEDED,""String_Node_Str"");
}","/** 
 * Add a resource to the session to all GrillServices running in this Grill server <p> The returned @{link APIResult} will have status SUCCEEDED <em>only if</em> the add operation was successful for all services running in this Grill server. </p>
 * @param sessionid session handle object
 * @param type The type of resource. Valid types are 'jar', 'file' and 'archive'
 * @param path path of the resource
 * @return {@link APIResult} with state {@link Status#SUCCEEDED}, if add was successful.  {@link APIResult} with state {@link Status#PARTIAL}, if add succeeded only for some services.  {@link APIResult} with state {@link Status#FAILED}, if add has failed
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.MULTIPART_FORM_DATA}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public APIResult addResource(@FormDataParam(""String_Node_Str"") GrillSessionHandle sessionid,@FormDataParam(""String_Node_Str"") String type,@FormDataParam(""String_Node_Str"") String path){
  int numAdded=sessionService.addResourceToAllServices(sessionid,type,path);
  if (numAdded == 0) {
    return new APIResult(Status.FAILED,""String_Node_Str"");
  }
 else   if (numAdded != GrillServices.get().getGrillServices().size()) {
    return new APIResult(Status.PARTIAL,""String_Node_Str"");
  }
  return new APIResult(Status.SUCCEEDED,""String_Node_Str"");
}",0.7997256515775034
25349,"public static BasicDataSource getDataSourceFromConf(HiveConf conf){
  BasicDataSource tmp=new BasicDataSource();
  tmp.setDriverClassName(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_DRIVER_NAME));
  tmp.setUrl(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_JDBC_URL));
  tmp.setUsername(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_JDBC_USERNAME));
  tmp.setPassword(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_JDBC_PASSWORD));
  return tmp;
}","public static BasicDataSource getDataSourceFromConf(HiveConf conf){
  BasicDataSource tmp=new BasicDataSource();
  tmp.setDriverClassName(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_DRIVER_NAME));
  tmp.setUrl(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_JDBC_URL));
  tmp.setUsername(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_JDBC_USERNAME));
  tmp.setPassword(conf.get(GrillConfConstants.GRILL_SERVER_USER_RESOLVER_DB_JDBC_PASSWORD,""String_Node_Str""));
  return tmp;
}",0.9821428571428572
25350,"public UserConfigLoaderException(String message,Throwable cause,boolean enableSuppression,boolean writableStackTrace){
  super(message,cause,enableSuppression,writableStackTrace);
}","public UserConfigLoaderException(String message,Throwable cause){
  super(message,cause);
}",0.6691176470588235
25351,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String explainQuery(@CliOption(key={""String_Node_Str"",""String_Node_Str""},mandatory=true,help=""String_Node_Str"") String sql,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") String location) throws UnsupportedEncodingException {
  QueryPlan plan=getClient().getQueryPlan(sql);
  return plan.getPlanString();
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String explainQuery(@CliOption(key={""String_Node_Str"",""String_Node_Str""},mandatory=true,help=""String_Node_Str"") String sql,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") String location) throws UnsupportedEncodingException {
  QueryPlan plan=getClient().getQueryPlan(sql);
  if (plan.isHasError() == true) {
    return plan.getErrorMsg();
  }
  return plan.getPlanString();
}",0.903448275862069
25352,"public QueryPlan toQueryPlan() throws UnsupportedEncodingException {
  return new QueryPlan(numJoins,numGbys,numSels,numSelDi,numHaving,numObys,numAggrExprs,numFilters,tablesQueried,hasSubQuery,execMode != null ? execMode.name() : null,scanMode != null ? scanMode.name() : null,tableWeights,joinWeight,gbyWeight,filterWeight,havingWeight,obyWeight,selectWeight,null,URLEncoder.encode(getPlan(),""String_Node_Str""),getCost());
}","public QueryPlan toQueryPlan() throws UnsupportedEncodingException {
  return new QueryPlan(numJoins,numGbys,numSels,numSelDi,numHaving,numObys,numAggrExprs,numFilters,tablesQueried,hasSubQuery,execMode != null ? execMode.name() : null,scanMode != null ? scanMode.name() : null,tableWeights,joinWeight,gbyWeight,filterWeight,havingWeight,obyWeight,selectWeight,null,URLEncoder.encode(getPlan(),""String_Node_Str""),getCost(),false,null);
}",0.9872537659327926
25353,"@Override public QueryPlan explain(GrillSessionHandle sessionHandle,String query,GrillConf grillConf) throws GrillException {
  try {
    LOG.info(""String_Node_Str"" + sessionHandle.toString() + ""String_Node_Str""+ query);
    acquire(sessionHandle);
    Configuration qconf=getGrillConf(sessionHandle,grillConf);
    accept(query,qconf,SubmitOp.EXPLAIN);
    Map<GrillDriver,String> driverQueries=RewriteUtil.rewriteQuery(query,drivers.values(),qconf);
    GrillDriver selectedDriver=driverSelector.select(drivers.values(),driverQueries,conf);
    return selectedDriver.explain(driverQueries.get(selectedDriver),qconf).toQueryPlan();
  }
 catch (  UnsupportedEncodingException e) {
    throw new GrillException(e);
  }
 finally {
    release(sessionHandle);
  }
}","@Override public QueryPlan explain(GrillSessionHandle sessionHandle,String query,GrillConf grillConf) throws GrillException {
  try {
    LOG.info(""String_Node_Str"" + sessionHandle.toString() + ""String_Node_Str""+ query);
    acquire(sessionHandle);
    Configuration qconf=getGrillConf(sessionHandle,grillConf);
    accept(query,qconf,SubmitOp.EXPLAIN);
    Map<GrillDriver,String> driverQueries=RewriteUtil.rewriteQuery(query,drivers.values(),qconf);
    GrillDriver selectedDriver=driverSelector.select(drivers.values(),driverQueries,conf);
    return selectedDriver.explain(driverQueries.get(selectedDriver),qconf).toQueryPlan();
  }
 catch (  GrillException e) {
    QueryPlan plan;
    if (e.getCause().getMessage() != null)     plan=new QueryPlan(true,e.getCause().getMessage());
 else     plan=new QueryPlan(true,e.getMessage());
    return plan;
  }
catch (  UnsupportedEncodingException e) {
    throw new GrillException(e);
  }
 finally {
    release(sessionHandle);
  }
}",0.8360091743119266
25354,"public GrillClientSingletonWrapper getClientWrapper(){
  return GrillClientSingletonWrapper.INSTANCE;
}","public static GrillClientSingletonWrapper getClientWrapper(){
  return GrillClientSingletonWrapper.INSTANCE;
}",0.9671361502347418
25355,"public BaseGrillCommand(){
  mapper=new ObjectMapper();
  pp=new DefaultPrettyPrinter();
  pp.indentObjectsWith(new Indenter(){
    @Override public void writeIndentation(    JsonGenerator jg,    int level) throws IOException, JsonGenerationException {
      if (level > 2) {
        jg.writeRaw(""String_Node_Str"");
      }
 else {
        jg.writeRaw(""String_Node_Str"");
      }
    }
    @Override public boolean isInline(){
      return false;
    }
  }
);
  isConnectionActive=true;
}","public BaseGrillCommand(){
  getClient();
  mapper=new ObjectMapper();
  pp=new DefaultPrettyPrinter();
  pp.indentObjectsWith(new Indenter(){
    @Override public void writeIndentation(    JsonGenerator jg,    int level) throws IOException, JsonGenerationException {
      if (level > 2) {
        jg.writeRaw(""String_Node_Str"");
      }
 else {
        jg.writeRaw(""String_Node_Str"");
      }
    }
    @Override public boolean isInline(){
      return false;
    }
  }
);
  isConnectionActive=true;
}",0.9848637739656912
25356,"public GrillClient getClient(){
  return getClientWrapper().getClient();
}","public static GrillClient getClient(){
  return getClientWrapper().getClient();
}",0.9548387096774194
25357,"protected synchronized void closeClientConnection(){
  if (isConnectionActive) {
    LOG.debug(""String_Node_Str"");
    getClient().closeConnection();
    isConnectionActive=false;
  }
}","protected static synchronized void closeClientConnection(){
  if (isConnectionActive) {
    LOG.debug(""String_Node_Str"");
    getClient().closeConnection();
    isConnectionActive=false;
  }
}",0.9814323607427056
25358,"public void constructQuery(String selecttree,String fromtree,String wheretree,String groupbytree,String havingtree,String orderbytree,String limit){
  String finalJoinClause=""String_Node_Str"";
  if (joinCondition != null)   finalJoinClause=factTable.concat(""String_Node_Str"").concat(factAlias).concat(joinCondition.toString());
 else   finalJoinClause=factTable.concat(""String_Node_Str"").concat(factAlias);
  rewrittenQuery.append(""String_Node_Str"").append(selecttree).append(""String_Node_Str"");
  if (factInLineQuery.length() != 0)   rewrittenQuery.append(finalJoinClause.replaceFirst(factTable,factInLineQuery.toString()));
 else   rewrittenQuery.append(finalJoinClause);
  if (wheretree != null)   rewrittenQuery.append(""String_Node_Str"").append(wheretree);
  if (groupbytree != null)   rewrittenQuery.append(""String_Node_Str"").append(groupbytree);
  if (havingtree != null)   rewrittenQuery.append(""String_Node_Str"").append(havingtree);
  if (orderbytree != null)   rewrittenQuery.append(""String_Node_Str"").append(orderbytree);
  if (limit != null)   rewrittenQuery.append(""String_Node_Str"").append(limit);
}","private void constructQuery(String selecttree,String fromtree,String wheretree,String groupbytree,String havingtree,String orderbytree,String limit,String jointree){
  String finalJoinClause=""String_Node_Str"";
  String factNameAndAlias=getFactNameAlias(fromAST);
  if (joinCondition != null)   finalJoinClause=factNameAndAlias.concat(""String_Node_Str"").concat(joinCondition.toString());
 else   finalJoinClause=factNameAndAlias;
  rewrittenQuery.append(""String_Node_Str"").append(selecttree).append(""String_Node_Str"");
  if (factInLineQuery.length() != 0)   rewrittenQuery.append(finalJoinClause.replaceFirst(factNameAndAlias.substring(0,factNameAndAlias.indexOf(' ')),factInLineQuery.toString()));
 else   rewrittenQuery.append(finalJoinClause);
  if (wheretree != null)   rewrittenQuery.append(""String_Node_Str"").append(wheretree);
  if (groupbytree != null)   rewrittenQuery.append(""String_Node_Str"").append(groupbytree);
  if (havingtree != null)   rewrittenQuery.append(""String_Node_Str"").append(havingtree);
  if (orderbytree != null)   rewrittenQuery.append(""String_Node_Str"").append(orderbytree);
  if (limit != null)   rewrittenQuery.append(""String_Node_Str"").append(limit);
}",0.8780487804878049
25359,"public void getJoinCond(ASTNode node){
  if (node == null) {
    return;
  }
  try {
    int rootType=node.getToken().getType();
    if (rootType == TOK_JOIN || rootType == TOK_LEFTOUTERJOIN || rootType == TOK_RIGHTOUTERJOIN || rootType == TOK_FULLOUTERJOIN || rootType == TOK_LEFTSEMIJOIN || rootType == TOK_UNIQUEJOIN) {
      ASTNode left=(ASTNode)node.getChild(0);
      ASTNode right=(ASTNode)node.getChild(1);
      String joinType=""String_Node_Str"";
      String JoinToken=node.getToken().getText();
      if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else {
        LOG.info(""String_Node_Str"" + JoinToken);
      }
      String joinCond=""String_Node_Str"";
      if (node.getChildCount() > 2) {
        joinCond=HQLParser.getString((ASTNode)node.getChild(2));
      }
      String joinClause=joinType.concat(HQLParser.getString(right)).concat(""String_Node_Str"").concat(joinCond);
      joinCondition.append(""String_Node_Str"").append(joinClause);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  for (int i=0; i < node.getChildCount(); i++) {
    ASTNode child=(ASTNode)node.getChild(i);
    getJoinCond(child);
  }
}","public void getJoinCond(ASTNode node){
  if (node == null) {
    return;
  }
  try {
    int rootType=node.getToken().getType();
    String rightTable=""String_Node_Str"";
    if (rootType == TOK_JOIN || rootType == TOK_LEFTOUTERJOIN || rootType == TOK_RIGHTOUTERJOIN || rootType == TOK_FULLOUTERJOIN || rootType == TOK_LEFTSEMIJOIN || rootType == TOK_UNIQUEJOIN) {
      ASTNode left=(ASTNode)node.getChild(0);
      ASTNode right=(ASTNode)node.getChild(1);
      rightTable=getTable(right);
      String joinType=""String_Node_Str"";
      String joinFilter=""String_Node_Str"";
      String JoinToken=node.getToken().getText();
      if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else       if (JoinToken.equals(""String_Node_Str"")) {
        joinType=""String_Node_Str"";
      }
 else {
        LOG.info(""String_Node_Str"" + JoinToken);
      }
      if (node.getChildCount() > 2) {
        joinFilter=HQLParser.getString((ASTNode)node.getChild(2));
      }
      joinCondition.append(""String_Node_Str"").append(joinType).append(""String_Node_Str"").append(rightTable).append(""String_Node_Str"").append(joinFilter).append(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  for (int i=0; i < node.getChildCount(); i++) {
    ASTNode child=(ASTNode)node.getChild(i);
    getJoinCond(child);
  }
}",0.8657933042212518
25360,"public void buildQuery(){
  try {
    analyzeInternal();
  }
 catch (  SemanticException e) {
    e.printStackTrace();
  }
  try {
    CubeMetastoreClient client=CubeMetastoreClient.getInstance(new HiveConf(conf,ColumnarSQLRewriter.class));
    replaceWithUnderlyingStorage(fromAST,client);
    fromTree=HQLParser.getString(fromAST);
  }
 catch (  HiveException exc) {
    LOG.error(""String_Node_Str"",exc);
  }
  getFilterInJoinCond(fromAST);
  getAggregateColumns(selectAST);
  getJoinCond(fromAST);
  getAllFilters(whereAST);
  buildSubqueries(fromAST);
  String limit=getLimitClause(ast);
  if (whereTree == null || joinTree == null || allSubQueries.length() == 0) {
    LOG.info(""String_Node_Str"");
    constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit);
    return;
  }
 else {
    factInLineQuery.append(""String_Node_Str"").append(factKeys);
    if (!aggColumn.isEmpty())     factInLineQuery.append(aggColumn.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    if (factInLineQuery.toString().substring(factInLineQuery.toString().length() - 1).equals(""String_Node_Str""))     factInLineQuery.setLength(factInLineQuery.length() - 1);
    factInLineQuery.append(""String_Node_Str"").append(factTable).append(""String_Node_Str"").append(factAlias);
    if (allSubQueries != null) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(allSubQueries.toString().substring(0,allSubQueries.lastIndexOf(""String_Node_Str"")));
    }
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(factKeys.toString().substring(0,factKeys.toString().lastIndexOf(""String_Node_Str"")));
    }
    factInLineQuery.append(""String_Node_Str"");
  }
  for (  Map.Entry<String,String> entry : mapAggTabAlias.entrySet()) {
    selectTree=selectTree.replace(entry.getKey(),entry.getValue());
    if (orderByTree != null) {
      orderByTree=orderByTree.replace(entry.getKey(),entry.getValue());
    }
    if (havingTree != null) {
      havingTree=havingTree.replace(entry.getKey(),entry.getValue());
    }
  }
  constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit);
}","public void buildQuery(){
  try {
    analyzeInternal();
  }
 catch (  SemanticException e) {
    e.printStackTrace();
  }
  try {
    CubeMetastoreClient client=CubeMetastoreClient.getInstance(new HiveConf(conf,ColumnarSQLRewriter.class));
    replaceWithUnderlyingStorage(fromAST,client);
    fromTree=HQLParser.getString(fromAST);
  }
 catch (  HiveException exc) {
    LOG.error(""String_Node_Str"",exc);
  }
  getFilterInJoinCond(fromAST);
  getAggregateColumns(selectAST);
  getJoinCond(fromAST);
  getAllFilters(whereAST);
  buildSubqueries(fromAST);
  String limit=getLimitClause(ast);
  if (whereTree == null || joinTree == null || allSubQueries.length() == 0) {
    LOG.info(""String_Node_Str"");
    constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
    return;
  }
 else {
    String factNameAndAlias=getFactNameAlias(fromAST).trim();
    factInLineQuery.append(""String_Node_Str"").append(factKeys);
    if (!aggColumn.isEmpty())     factInLineQuery.append(aggColumn.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    if (factInLineQuery.toString().substring(factInLineQuery.toString().length() - 1).equals(""String_Node_Str""))     factInLineQuery.setLength(factInLineQuery.length() - 1);
    factInLineQuery.append(""String_Node_Str"").append(factNameAndAlias);
    if (allSubQueries != null) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(allSubQueries.toString().substring(0,allSubQueries.lastIndexOf(""String_Node_Str"")));
    }
    if (!aggColumn.isEmpty()) {
      factInLineQuery.append(""String_Node_Str"");
      factInLineQuery.append(factKeys.toString().substring(0,factKeys.toString().lastIndexOf(""String_Node_Str"")));
    }
    factInLineQuery.append(""String_Node_Str"");
  }
  for (  Map.Entry<String,String> entry : mapAggTabAlias.entrySet()) {
    selectTree=selectTree.replace(entry.getKey(),entry.getValue());
    if (orderByTree != null) {
      orderByTree=orderByTree.replace(entry.getKey(),entry.getValue());
    }
    if (havingTree != null) {
      havingTree=havingTree.replace(entry.getKey(),entry.getValue());
    }
  }
  constructQuery(selectTree,fromTree,whereTree,groupByTree,havingTree,orderByTree,limit,joinTree);
}",0.9714791067875304
25361,"public void getFactNameAlias(String query){
  Pattern p=Pattern.compile(""String_Node_Str"");
  Matcher m=p.matcher(query.toLowerCase());
  if (m.find()) {
    String fromClause=m.group(1);
    String[] keys=fromClause.split(""String_Node_Str"");
    factTable=keys[1];
    factAlias=keys[2];
  }
}","public String getFactNameAlias(ASTNode fromAST){
  String factTable;
  String factAlias;
  ArrayList<String> allTables=getFirstChildFromFromString(fromAST);
  String[] keys=allTables.get(0).trim().split(""String_Node_Str"");
  if (keys.length == 2) {
    factTable=keys[0];
    factAlias=keys[1];
    return factTable + ""String_Node_Str"" + factAlias;
  }
 else   factTable=keys[0];
  return factTable;
}",0.2100719424460431
25362,"@Override public synchronized String rewrite(Configuration conf,String query) throws GrillException {
  this.query=query;
  this.conf=conf;
  StringBuilder mergedQuery=new StringBuilder();
  rewrittenQuery.setLength(0);
  String queryReplacedUdf=""String_Node_Str"";
  reset();
  try {
    if (query.toLowerCase().matches(""String_Node_Str"")) {
      String finalRewrittenQuery=""String_Node_Str"";
      String[] queries=query.toLowerCase().split(""String_Node_Str"");
      for (int i=0; i < queries.length; i++) {
        LOG.info(""String_Node_Str"" + i + ""String_Node_Str""+ queries[i]);
        getFactNameAlias(queries[i]);
        ast=HQLParser.parseHQL(queries[i]);
        buildQuery();
        mergedQuery=rewrittenQuery.append(""String_Node_Str"");
        finalRewrittenQuery=mergedQuery.toString().substring(0,mergedQuery.lastIndexOf(""String_Node_Str""));
        reset();
      }
      queryReplacedUdf=replaceUDFForDB(finalRewrittenQuery);
      LOG.info(""String_Node_Str"" + query);
      LOG.info(""String_Node_Str"" + queryReplacedUdf);
    }
 else {
      ast=HQLParser.parseHQL(query);
      getFactNameAlias(query);
      buildQuery();
      queryReplacedUdf=replaceUDFForDB(rewrittenQuery.toString());
      LOG.info(""String_Node_Str"" + query);
      LOG.info(""String_Node_Str"" + queryReplacedUdf);
    }
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
  return queryReplacedUdf;
}","@Override public synchronized String rewrite(Configuration conf,String query) throws GrillException {
  this.query=query;
  this.conf=conf;
  StringBuilder mergedQuery=new StringBuilder();
  rewrittenQuery.setLength(0);
  String queryReplacedUdf=""String_Node_Str"";
  fromTables.clear();
  reset();
  try {
    if (query.toLowerCase().matches(""String_Node_Str"")) {
      String finalRewrittenQuery=""String_Node_Str"";
      String[] queries=query.toLowerCase().split(""String_Node_Str"");
      for (int i=0; i < queries.length; i++) {
        LOG.info(""String_Node_Str"" + i + ""String_Node_Str""+ queries[i]);
        ast=HQLParser.parseHQL(queries[i]);
        buildQuery();
        mergedQuery=rewrittenQuery.append(""String_Node_Str"");
        finalRewrittenQuery=mergedQuery.toString().substring(0,mergedQuery.lastIndexOf(""String_Node_Str""));
        reset();
      }
      queryReplacedUdf=replaceUDFForDB(finalRewrittenQuery);
      LOG.info(""String_Node_Str"" + query);
      LOG.info(""String_Node_Str"" + queryReplacedUdf);
    }
 else {
      ast=HQLParser.parseHQL(query);
      buildQuery();
      queryReplacedUdf=replaceUDFForDB(rewrittenQuery.toString());
      LOG.info(""String_Node_Str"" + query);
      LOG.info(""String_Node_Str"" + queryReplacedUdf);
    }
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
  return queryReplacedUdf;
}",0.9670170351576658
25363,"public void reset(){
  factInLineQuery.setLength(0);
  factKeys.setLength(0);
  aggColumn.clear();
  factTable=""String_Node_Str"";
  factAlias=""String_Node_Str"";
  allSubQueries.setLength(0);
  rightFilter.clear();
  joinCondition.setLength(0);
  selectTree=fromTree=joinTree=whereTree=groupByTree=havingTree=orderByTree=null;
  selectAST=fromAST=joinAST=whereAST=groupByAST=havingAST=orderByAST=null;
  limit=null;
}","public void reset(){
  factInLineQuery.setLength(0);
  factKeys.setLength(0);
  aggColumn.clear();
  allSubQueries.setLength(0);
  rightFilter.clear();
  joinCondition.setLength(0);
  selectTree=fromTree=joinTree=whereTree=groupByTree=havingTree=orderByTree=null;
  selectAST=fromAST=joinAST=whereAST=groupByAST=havingAST=orderByAST=null;
  limit=null;
  fromTables.clear();
}",0.8939393939393939
25364,"@Test public void testNoRewrite() throws ParseException, SemanticException, GrillException {
  SessionState.start(new HiveConf(ColumnarSQLRewriter.class));
  HiveConf conf=new HiveConf();
  ColumnarSQLRewriter qtest=new ColumnarSQLRewriter();
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String actual=qtest.rewrite(conf,query);
  String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  compareQueries(expected,actual);
  String query2=""String_Node_Str"";
  String actual2=qtest.rewrite(conf,query2);
  String expected2=""String_Node_Str"";
  compareQueries(expected2,actual2);
  String query3=""String_Node_Str"";
  String actual3=qtest.rewrite(conf,query3);
  String expected3=""String_Node_Str"";
  compareQueries(expected3,actual3);
}","@Test public void testNoRewrite() throws ParseException, SemanticException, GrillException {
  SessionState.start(new HiveConf(ColumnarSQLRewriter.class));
  HiveConf conf=new HiveConf();
  ColumnarSQLRewriter qtest=new ColumnarSQLRewriter();
  String query=""String_Node_Str"";
  String actual=qtest.rewrite(conf,query);
  String expected=""String_Node_Str"";
  compareQueries(expected,actual);
  String query2=""String_Node_Str"";
  String actual2=qtest.rewrite(conf,query2);
  String expected2=""String_Node_Str"";
  compareQueries(expected2,actual2);
  String query3=""String_Node_Str"";
  String actual3=qtest.rewrite(conf,query3);
  String expected3=""String_Node_Str"";
  compareQueries(expected3,actual3);
  String query4=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String actual4=qtest.rewrite(conf,query4);
  String expected4=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  compareQueries(expected4,actual4);
}",0.7907761529808774
25365,"static Configuration getFinalQueryConf(GrillDriver driver,Configuration queryConf){
  Configuration conf=new Configuration(driver.getConf());
  for (  Map.Entry<String,String> entry : queryConf) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      CubeGrillDriver.LOG.warn(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
      continue;
    }
    conf.set(entry.getKey(),entry.getValue());
  }
  return conf;
}","public static Configuration getFinalQueryConf(GrillDriver driver,Configuration queryConf){
  Configuration conf=new Configuration(driver.getConf());
  for (  Map.Entry<String,String> entry : queryConf) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      CubeGrillDriver.LOG.warn(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
      continue;
    }
    conf.set(entry.getKey(),entry.getValue());
  }
  return conf;
}",0.9918887601390498
25366,"private GrillResultSet getResultset(QueryHandle queryHandle) throws GrillException {
  if (!allQueries.containsKey(queryHandle)) {
    FinishedGrillQuery query=grillServerDao.getQuery(queryHandle.toString());
    if (query != null) {
      if (query.getResult() == null) {
        throw new NotFoundException(""String_Node_Str"" + queryHandle);
      }
      try {
        Class<GrillResultSetMetadata> mdKlass=(Class<GrillResultSetMetadata>)Class.forName(query.getMetadataClass());
        return new GrillPersistentResult(mapper.readValue(query.getMetadata(),mdKlass),query.getResult(),query.getRows());
      }
 catch (      Exception e) {
        throw new GrillException(e);
      }
    }
    throw new NotFoundException(""String_Node_Str"" + queryHandle);
  }
  GrillResultSet resultSet=resultSets.get(queryHandle);
  if (resultSet == null) {
    QueryContext ctx=allQueries.get(queryHandle);
    if (ctx.isPersistent() && ctx.getQueryOutputFormatter() != null) {
      resultSets.put(queryHandle,new GrillPersistentResult(ctx.getQueryOutputFormatter().getMetadata(),ctx.getQueryOutputFormatter().getFinalOutputPath().toString(),ctx.getQueryOutputFormatter().getNumRows()));
    }
 else     if (allQueries.get(queryHandle).isResultAvailableInDriver()) {
      resultSet=allQueries.get(queryHandle).getSelectedDriver().fetchResultSet(allQueries.get(queryHandle));
      resultSets.put(queryHandle,resultSet);
    }
 else {
      throw new NotFoundException(""String_Node_Str"" + queryHandle);
    }
  }
  return resultSets.get(queryHandle);
}","private GrillResultSet getResultset(QueryHandle queryHandle) throws GrillException {
  QueryContext ctx=allQueries.get(queryHandle);
  if (ctx == null) {
    return getResultsetFromDAO(queryHandle);
  }
 else {
synchronized (ctx) {
      if (ctx.isFinishedQueryPersisted()) {
        return getResultsetFromDAO(queryHandle);
      }
      GrillResultSet resultSet=resultSets.get(queryHandle);
      if (resultSet == null) {
        if (ctx.isPersistent() && ctx.getQueryOutputFormatter() != null) {
          resultSets.put(queryHandle,new GrillPersistentResult(ctx.getQueryOutputFormatter().getMetadata(),ctx.getQueryOutputFormatter().getFinalOutputPath().toString(),ctx.getQueryOutputFormatter().getNumRows()));
        }
 else         if (allQueries.get(queryHandle).isResultAvailableInDriver()) {
          resultSet=allQueries.get(queryHandle).getSelectedDriver().fetchResultSet(allQueries.get(queryHandle));
          resultSets.put(queryHandle,resultSet);
        }
 else {
          throw new NotFoundException(""String_Node_Str"" + queryHandle);
        }
      }
    }
    return resultSets.get(queryHandle);
  }
}",0.1892602328201277
25367,"QueryCompletionListenerImpl(){
}","QueryCompletionListenerImpl(QueryHandle handle){
  this.handle=handle;
}",0.6153846153846154
25368,"@Override public void onCompletion(QueryHandle handle){
synchronized (this) {
    succeeded=true;
    LOG.info(""String_Node_Str"");
    this.notify();
  }
}","@Override public void onCompletion(QueryHandle handle){
synchronized (this) {
    succeeded=true;
    LOG.info(""String_Node_Str"" + handle + ""String_Node_Str"");
    this.notify();
  }
}",0.9144542772861356
25369,"private QueryHandleWithResultSet executeTimeoutInternal(GrillSessionHandle sessionHandle,QueryContext ctx,long timeoutMillis,Configuration conf) throws GrillException {
  QueryHandle handle=executeAsyncInternal(sessionHandle,ctx,conf);
  QueryHandleWithResultSet result=new QueryHandleWithResultSet(handle);
  while (getQueryContext(sessionHandle,handle).getStatus().getStatus().equals(QueryStatus.Status.QUEUED)) {
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  QueryCompletionListener listener=new QueryCompletionListenerImpl();
  getQueryContext(sessionHandle,handle).getSelectedDriver().registerForCompletionNotification(handle,timeoutMillis,listener);
  try {
synchronized (listener) {
      listener.wait(timeoutMillis);
    }
  }
 catch (  InterruptedException e) {
    LOG.info(""String_Node_Str"");
  }
  if (getQueryContext(sessionHandle,handle).getStatus().isFinished()) {
    result.setResult(getResultset(handle).toQueryResult());
  }
  return result;
}","private QueryHandleWithResultSet executeTimeoutInternal(GrillSessionHandle sessionHandle,QueryContext ctx,long timeoutMillis,Configuration conf) throws GrillException {
  QueryHandle handle=executeAsyncInternal(sessionHandle,ctx,conf);
  QueryHandleWithResultSet result=new QueryHandleWithResultSet(handle);
  while (getQueryContext(sessionHandle,handle).getStatus().getStatus().equals(QueryStatus.Status.QUEUED)) {
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  QueryCompletionListener listener=new QueryCompletionListenerImpl(handle);
  getQueryContext(sessionHandle,handle).getSelectedDriver().registerForCompletionNotification(handle,timeoutMillis,listener);
  try {
synchronized (listener) {
      listener.wait(timeoutMillis);
    }
  }
 catch (  InterruptedException e) {
    LOG.info(""String_Node_Str"");
  }
  if (getQueryContext(sessionHandle,handle).getStatus().isFinished()) {
    result.setResult(getResultset(handle).toQueryResult());
  }
  return result;
}",0.9971070395371264
25370,"@Override public void onError(QueryHandle handle,String error){
synchronized (this) {
    succeeded=false;
    LOG.info(""String_Node_Str"");
    this.notify();
  }
}","@Override public void onError(QueryHandle handle,String error){
synchronized (this) {
    succeeded=false;
    LOG.info(""String_Node_Str"" + handle + ""String_Node_Str"");
    this.notify();
  }
}",0.9187675070028012
25371,"@Test public void testQueryCommands() throws Exception {
  client=new GrillClient();
  client.setConnectionParam(""String_Node_Str"",""String_Node_Str"");
  setup(client);
  GrillQueryCommands qCom=new GrillQueryCommands();
  qCom.setClient(client);
  testExecuteSyncQuery(qCom);
  testExecuteAsyncQuery(qCom);
  testExplainQuery(qCom);
  testPreparedQuery(qCom);
}","@Test public void testQueryCommands() throws Exception {
  client=new GrillClient();
  client.setConnectionParam(""String_Node_Str"",""String_Node_Str"");
  setup(client);
  GrillQueryCommands qCom=new GrillQueryCommands();
  qCom.setClient(client);
  testExecuteSyncQuery(qCom);
  testExecuteAsyncQuery(qCom);
  testExplainQuery(qCom);
  testPreparedQuery(qCom);
  testShowPersistentResultSet(qCom);
}",0.9512516469038208
25372,"public InMemoryQueryResult getResultSet(GrillQuery query){
  if (query.getStatus().getStatus() != QueryStatus.Status.SUCCESSFUL) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Client client=ClientBuilder.newClient();
  try {
    WebTarget target=getQueryWebTarget(client);
    return target.path(query.getQueryHandle().toString()).path(""String_Node_Str"").queryParam(""String_Node_Str"",connection.getSessionHandle()).request().get(InMemoryQueryResult.class);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"" + e.getMessage());
  }
}","public QueryResult getResultSet(GrillQuery query){
  if (query.getStatus().getStatus() != QueryStatus.Status.SUCCESSFUL) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Client client=ClientBuilder.newClient();
  try {
    WebTarget target=getQueryWebTarget(client);
    return target.path(query.getQueryHandle().toString()).path(""String_Node_Str"").queryParam(""String_Node_Str"",connection.getSessionHandle()).request().get(QueryResult.class);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"" + e.getMessage());
  }
}",0.9865771812080536
25373,"public GrillJdbcResultSet(InMemoryQueryResult result,QueryResultSetMetadata metadata,GrillJdbcStatement statement){
  this.result=result;
  this.metadata=metadata;
  this.statement=statement;
  colNames=new ArrayList<String>();
  colTypes=new ArrayList<ResultColumnType>();
  for (  ResultColumn col : metadata.getColumns()) {
    colNames.add(col.getName());
    colTypes.add(col.getType());
  }
  iterators=result.getRows().iterator();
}","public GrillJdbcResultSet(QueryResult result,QueryResultSetMetadata metadata,GrillJdbcStatement statement){
  this.result=result;
  this.metadata=metadata;
  this.statement=statement;
  colNames=new ArrayList<String>();
  colTypes=new ArrayList<ResultColumnType>();
  for (  ResultColumn col : metadata.getColumns()) {
    colNames.add(col.getName());
    colTypes.add(col.getType());
  }
  if (result instanceof InMemoryQueryResult) {
    iterators=((InMemoryQueryResult)result).getRows().iterator();
  }
 else {
    iterators=null;
  }
}",0.8507157464212679
25374,"@Override public boolean next() throws SQLException {
  if (closed) {
    throw new SQLException(""String_Node_Str"");
  }
  if (iterators.hasNext()) {
    currentRow=iterators.next();
    return true;
  }
  return false;
}","@Override public boolean next() throws SQLException {
  if (closed) {
    throw new SQLException(""String_Node_Str"");
  }
  if (iterators != null && iterators.hasNext()) {
    currentRow=iterators.next();
    return true;
  }
  return false;
}",0.9546436285097192
25375,"public void runQueries(String fileName) throws IOException {
  InputStream file=SampleMetastore.class.getClassLoader().getResourceAsStream(fileName);
  BufferedReader reader=new BufferedReader(new InputStreamReader(file));
  String query;
  while ((query=reader.readLine()) != null) {
    if (StringUtils.isBlank(query)) {
      continue;
    }
    if (query.startsWith(""String_Node_Str"")) {
      continue;
    }
    total++;
    System.out.println(""String_Node_Str"" + query);
    QueryHandle handle=queryClient.executeQuery(query,true);
    System.out.println(""String_Node_Str"" + queryClient.getQuery().getStatus());
    System.out.println(""String_Node_Str"" + (queryClient.getQuery().getFinishTime() - queryClient.getQuery().getSubmissionTime()));
    System.out.println(""String_Node_Str"" + (queryClient.getQuery().getDriverFinishTime() - queryClient.getQuery().getDriverStartTime()));
    if (queryClient.wasQuerySuccessful()) {
      success++;
      if (queryClient.getQuery().getStatus().isResultSetAvailable()) {
        System.out.println(""String_Node_Str"");
        InMemoryQueryResult result=queryClient.getResultSet();
        for (        ResultRow row : result.getRows()) {
          System.out.println(StringUtils.join(row.getValues(),""String_Node_Str""));
        }
        queryClient.closeResultSet();
      }
    }
 else {
      retCode=1;
    }
    System.out.println(""String_Node_Str"");
  }
}","public void runQueries(String fileName) throws IOException {
  InputStream file=SampleMetastore.class.getClassLoader().getResourceAsStream(fileName);
  BufferedReader reader=new BufferedReader(new InputStreamReader(file));
  String query;
  while ((query=reader.readLine()) != null) {
    if (StringUtils.isBlank(query)) {
      continue;
    }
    if (query.startsWith(""String_Node_Str"")) {
      continue;
    }
    total++;
    System.out.println(""String_Node_Str"" + query);
    QueryHandle handle=queryClient.executeQuery(query,true);
    System.out.println(""String_Node_Str"" + queryClient.getQuery().getStatus());
    System.out.println(""String_Node_Str"" + (queryClient.getQuery().getFinishTime() - queryClient.getQuery().getSubmissionTime()));
    System.out.println(""String_Node_Str"" + (queryClient.getQuery().getDriverFinishTime() - queryClient.getQuery().getDriverStartTime()));
    if (queryClient.wasQuerySuccessful()) {
      success++;
      if (queryClient.getQuery().getStatus().isResultSetAvailable()) {
        System.out.println(""String_Node_Str"");
        QueryResult queryResult=queryClient.getResultSet();
        if (queryResult instanceof InMemoryQueryResult) {
          InMemoryQueryResult result=(InMemoryQueryResult)queryResult;
          for (          ResultRow row : result.getRows()) {
            System.out.println(StringUtils.join(row.getValues(),""String_Node_Str""));
          }
        }
 else         if (queryResult instanceof PersistentQueryResult) {
          PersistentQueryResult persistentQueryResult=(PersistentQueryResult)queryResult;
          System.out.println(""String_Node_Str"" + persistentQueryResult.getPersistedURI());
        }
        queryClient.closeResultSet();
      }
    }
 else {
      retCode=1;
    }
    System.out.println(""String_Node_Str"");
  }
}",0.8582066397766056
25376,"private static void findCubePositions(ASTNode ast,List<CubeQueryInfo> cubeQueries,String originalQuery) throws SemanticException {
  int child_count=ast.getChildCount();
  if (ast.getToken() != null) {
    if (ast.getChild(0) != null) {
      CubeGrillDriver.LOG.debug(""String_Node_Str"" + ast.getChild(0) + ""String_Node_Str""+ ((ASTNode)ast.getChild(0)).getToken().getType());
    }
    if (ast.getToken().getType() == HiveParser.TOK_QUERY && ((ASTNode)ast.getChild(0)).getToken().getType() == HiveParser.KW_CUBE) {
      CubeGrillDriver.LOG.debug(""String_Node_Str"");
      CubeQueryInfo cqi=new CubeQueryInfo();
      cqi.cubeAST=ast;
      if (ast.getParent() != null) {
        ASTNode parent=(ASTNode)ast.getParent();
        cqi.startPos=ast.getCharPositionInLine();
        int ci=ast.getChildIndex();
        if (parent.getToken() == null || parent.getToken().getType() == HiveParser.TOK_EXPLAIN) {
          cqi.endPos=originalQuery.length();
        }
 else         if (parent.getChildCount() > ci + 1) {
          if (parent.getToken().getType() == HiveParser.TOK_SUBQUERY) {
            cqi.endPos=getEndPos(originalQuery,parent.getChild(ci + 1).getCharPositionInLine(),""String_Node_Str"");
            ;
          }
 else           if (parent.getToken().getType() == HiveParser.TOK_UNION) {
            cqi.endPos=getEndPos(originalQuery,parent.getChild(ci + 1).getCharPositionInLine() - 1,""String_Node_Str"");
          }
 else {
            CubeGrillDriver.LOG.warn(""String_Node_Str"" + ast.dump());
            throw new SemanticException(""String_Node_Str"");
          }
        }
 else {
          cqi.endPos=getEndPos(originalQuery,parent.getParent().getChild(1).getCharPositionInLine(),""String_Node_Str"",""String_Node_Str"");
        }
      }
      CubeGrillDriver.LOG.debug(""String_Node_Str"" + cqi + ""String_Node_Str""+ originalQuery.substring(cqi.startPos,cqi.endPos));
      cubeQueries.add(cqi);
    }
 else {
      for (int child_pos=0; child_pos < child_count; ++child_pos) {
        findCubePositions((ASTNode)ast.getChild(child_pos),cubeQueries,originalQuery);
      }
    }
  }
 else {
    CubeGrillDriver.LOG.warn(""String_Node_Str"");
  }
}","private static void findCubePositions(ASTNode ast,List<CubeQueryInfo> cubeQueries,String originalQuery) throws SemanticException {
  int child_count=ast.getChildCount();
  if (ast.getToken() != null) {
    if (ast.getChild(0) != null) {
      CubeGrillDriver.LOG.debug(""String_Node_Str"" + ast.getChild(0) + ""String_Node_Str""+ ((ASTNode)ast.getChild(0)).getToken().getType());
    }
    if (ast.getToken().getType() == HiveParser.TOK_QUERY && ((ASTNode)ast.getChild(0)).getToken().getType() == HiveParser.KW_CUBE) {
      CubeGrillDriver.LOG.debug(""String_Node_Str"");
      CubeQueryInfo cqi=new CubeQueryInfo();
      cqi.cubeAST=ast;
      if (ast.getParent() != null) {
        ASTNode parent=(ASTNode)ast.getParent();
        cqi.startPos=ast.getCharPositionInLine();
        int ci=ast.getChildIndex();
        if (parent.getToken() == null || parent.getToken().getType() == HiveParser.TOK_EXPLAIN || parent.getToken().getType() == HiveParser.TOK_CREATETABLE) {
          cqi.endPos=originalQuery.length();
        }
 else         if (parent.getChildCount() > ci + 1) {
          if (parent.getToken().getType() == HiveParser.TOK_SUBQUERY) {
            cqi.endPos=getEndPos(originalQuery,parent.getChild(ci + 1).getCharPositionInLine(),""String_Node_Str"");
            ;
          }
 else           if (parent.getToken().getType() == HiveParser.TOK_UNION) {
            cqi.endPos=getEndPos(originalQuery,parent.getChild(ci + 1).getCharPositionInLine() - 1,""String_Node_Str"");
          }
 else {
            CubeGrillDriver.LOG.warn(""String_Node_Str"" + ast.dump());
            throw new SemanticException(""String_Node_Str"");
          }
        }
 else {
          CubeGrillDriver.LOG.debug(""String_Node_Str"");
          cqi.endPos=getEndPos(originalQuery,parent.getParent().getChild(1).getCharPositionInLine(),""String_Node_Str"",""String_Node_Str"");
        }
      }
      CubeGrillDriver.LOG.debug(""String_Node_Str"" + cqi + ""String_Node_Str""+ originalQuery.substring(cqi.startPos,cqi.endPos));
      cubeQueries.add(cqi);
    }
 else {
      for (int child_pos=0; child_pos < child_count; ++child_pos) {
        findCubePositions((ASTNode)ast.getChild(child_pos),cubeQueries,originalQuery);
      }
    }
  }
 else {
    CubeGrillDriver.LOG.warn(""String_Node_Str"");
  }
}",0.7893669745438162
25377,"@Test public void testCubeQuery() throws ParseException, SemanticException, GrillException {
  List<GrillDriver> drivers=new ArrayList<GrillDriver>();
  MockDriver driver=new MockDriver();
  Configuration conf=new Configuration();
  driver.configure(conf);
  drivers.add(driver);
  CubeQueryRewriter mockWriter=getMockedRewriter();
  PowerMockito.stub(PowerMockito.method(RewriteUtil.class,""String_Node_Str"")).toReturn(mockWriter);
  String q1=""String_Node_Str"";
  Assert.assertFalse(RewriteUtil.isCubeQuery(q1));
  List<RewriteUtil.CubeQueryInfo> cubeQueries=RewriteUtil.findCubePositions(q1);
  Assert.assertEquals(cubeQueries.size(),0);
  RewriteUtil.rewriteQuery(q1,drivers,conf);
  String q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(RewriteUtil.getReplacedQuery(q2));
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"" + ""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),3);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(2).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),3);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(2).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
}","@Test public void testCubeQuery() throws ParseException, SemanticException, GrillException {
  List<GrillDriver> drivers=new ArrayList<GrillDriver>();
  MockDriver driver=new MockDriver();
  Configuration conf=new Configuration();
  driver.configure(conf);
  drivers.add(driver);
  CubeQueryRewriter mockWriter=getMockedRewriter();
  PowerMockito.stub(PowerMockito.method(RewriteUtil.class,""String_Node_Str"")).toReturn(mockWriter);
  String q1=""String_Node_Str"";
  Assert.assertFalse(RewriteUtil.isCubeQuery(q1));
  List<RewriteUtil.CubeQueryInfo> cubeQueries=RewriteUtil.findCubePositions(q1);
  Assert.assertEquals(cubeQueries.size(),0);
  RewriteUtil.rewriteQuery(q1,drivers,conf);
  String q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(RewriteUtil.getReplacedQuery(q2));
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"" + ""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),3);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(2).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),3);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(2).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  q2=""String_Node_Str"";
  Assert.assertTrue(RewriteUtil.isCubeQuery(q2));
  cubeQueries=RewriteUtil.findCubePositions(q2);
  RewriteUtil.rewriteQuery(q2,drivers,conf);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  RewriteUtil.rewriteQuery(q2,drivers,conf);
}",0.9351569178165832
25378,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String getQueries(@CliOption(key={""String_Node_Str"",""String_Node_Str""},mandatory=true,help=""String_Node_Str"") String sql,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") String location){
  QueryPlan plan=client.getQueryPlan(sql);
  return plan.getPlanString();
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String getQueries(@CliOption(key={""String_Node_Str"",""String_Node_Str""},mandatory=true,help=""String_Node_Str"") String sql,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") String location) throws UnsupportedEncodingException {
  QueryPlan plan=client.getQueryPlan(sql);
  return plan.getPlanString();
}",0.9506008010680908
25379,"public QueryPlan toQueryPlan(){
  return new QueryPlan(numJoins,numGbys,numSels,numSelDi,numHaving,numObys,numAggrExprs,numFilters,tablesQueried,hasSubQuery,execMode.name(),scanMode.name(),tableWeights,joinWeight,gbyWeight,filterWeight,havingWeight,obyWeight,selectWeight,null,getPlan(),getCost());
}","public QueryPlan toQueryPlan() throws UnsupportedEncodingException {
  return new QueryPlan(numJoins,numGbys,numSels,numSelDi,numHaving,numObys,numAggrExprs,numFilters,tablesQueried,hasSubQuery,execMode.name(),scanMode.name(),tableWeights,joinWeight,gbyWeight,filterWeight,havingWeight,obyWeight,selectWeight,null,URLEncoder.encode(getPlan(),""String_Node_Str""),getCost());
}",0.8902077151335311
25380,"@Override public QueryPlan explain(GrillSessionHandle sessionHandle,String query,GrillConf GrillConf) throws GrillException {
  try {
    LOG.info(""String_Node_Str"" + sessionHandle.toString() + ""String_Node_Str""+ query);
    acquire(sessionHandle);
    Configuration qconf=getGrillConf(sessionHandle,GrillConf);
    accept(query,qconf,SubmitOp.EXPLAIN);
    Map<GrillDriver,String> driverQueries=RewriteUtil.rewriteQuery(query,drivers);
    return driverSelector.select(drivers,driverQueries,conf).explain(query,qconf).toQueryPlan();
  }
  finally {
    release(sessionHandle);
  }
}","@Override public QueryPlan explain(GrillSessionHandle sessionHandle,String query,GrillConf grillConf) throws GrillException {
  try {
    LOG.info(""String_Node_Str"" + sessionHandle.toString() + ""String_Node_Str""+ query);
    acquire(sessionHandle);
    Configuration qconf=getGrillConf(sessionHandle,grillConf);
    accept(query,qconf,SubmitOp.EXPLAIN);
    Map<GrillDriver,String> driverQueries=RewriteUtil.rewriteQuery(query,drivers);
    return driverSelector.select(drivers,driverQueries,conf).explain(query,qconf).toQueryPlan();
  }
 catch (  UnsupportedEncodingException e) {
    throw new GrillException(e);
  }
 finally {
    release(sessionHandle);
  }
}",0.9197431781701444
25381,"@Override public QueryPlan explainAndPrepare(GrillSessionHandle sessionHandle,String query,GrillConf GrillConf) throws GrillException {
  try {
    LOG.info(""String_Node_Str"" + sessionHandle.toString() + ""String_Node_Str""+ query);
    acquire(sessionHandle);
    Configuration qconf=getGrillConf(sessionHandle,GrillConf);
    accept(query,qconf,SubmitOp.EXPLAIN_AND_PREPARE);
    PreparedQueryContext prepared=new PreparedQueryContext(query,null,qconf);
    rewriteAndSelect(prepared);
    preparedQueries.put(prepared.getPrepareHandle(),prepared);
    preparedQueryQueue.add(prepared);
    QueryPlan plan=prepared.getSelectedDriver().explainAndPrepare(prepared).toQueryPlan();
    plan.setPrepareHandle(prepared.getPrepareHandle());
    return plan;
  }
  finally {
    release(sessionHandle);
  }
}","@Override public QueryPlan explainAndPrepare(GrillSessionHandle sessionHandle,String query,GrillConf GrillConf) throws GrillException {
  try {
    LOG.info(""String_Node_Str"" + sessionHandle.toString() + ""String_Node_Str""+ query);
    acquire(sessionHandle);
    Configuration qconf=getGrillConf(sessionHandle,GrillConf);
    accept(query,qconf,SubmitOp.EXPLAIN_AND_PREPARE);
    PreparedQueryContext prepared=new PreparedQueryContext(query,null,qconf);
    rewriteAndSelect(prepared);
    preparedQueries.put(prepared.getPrepareHandle(),prepared);
    preparedQueryQueue.add(prepared);
    QueryPlan plan=prepared.getSelectedDriver().explainAndPrepare(prepared).toQueryPlan();
    plan.setPrepareHandle(prepared.getPrepareHandle());
    return plan;
  }
 catch (  UnsupportedEncodingException e) {
    throw new GrillException(e);
  }
 finally {
    release(sessionHandle);
  }
}",0.9428571428571428
25382,"public GrillSessionImpl(TProtocolVersion protocol,String username,String password,HiveConf serverConf,Map<String,String> sessionConf){
  super(protocol,username,password,serverConf,sessionConf);
}","public GrillSessionImpl(TProtocolVersion protocol,String username,String password,HiveConf serverConf,Map<String,String> sessionConf,String ipAddress){
  super(protocol,username,password,serverConf,sessionConf,ipAddress);
}",0.935560859188544
25383,"private void updateFinishedQuery(QueryContext ctx){
  launchedQueries.remove(ctx);
  finishedQueries.add(new FinishedQuery(ctx));
}","private void updateFinishedQuery(QueryContext ctx,QueryStatus before){
  if (before.getStatus().equals(Status.QUEUED)) {
    acceptedQueries.remove(ctx);
  }
 else {
    launchedQueries.remove(ctx);
  }
  finishedQueries.add(new FinishedQuery(ctx));
}",0.6596858638743456
25384,"@Override public boolean cancelQuery(GrillSessionHandle sessionHandle,QueryHandle queryHandle) throws GrillException {
  try {
    acquire(sessionHandle);
    QueryContext ctx=getQueryContext(sessionHandle,queryHandle);
    if (ctx.getStatus().getStatus().equals(QueryStatus.Status.LAUNCHED)) {
      boolean ret=ctx.getSelectedDriver().cancelQuery(queryHandle);
      if (!ret) {
        return false;
      }
    }
 else {
      acceptedQueries.remove(ctx);
    }
    QueryStatus before=ctx.getStatus();
    ctx.setStatus(new QueryStatus(0.0,Status.CANCELED,""String_Node_Str"",false,null,null));
    fireStatusChangeEvent(ctx,ctx.getStatus(),before);
    updateFinishedQuery(ctx);
    return true;
  }
  finally {
    release(sessionHandle);
  }
}","@Override public boolean cancelQuery(GrillSessionHandle sessionHandle,QueryHandle queryHandle) throws GrillException {
  try {
    acquire(sessionHandle);
    QueryContext ctx=getQueryContext(sessionHandle,queryHandle);
    if (ctx.getStatus().isFinished()) {
      return false;
    }
synchronized (ctx) {
      if (ctx.getStatus().getStatus().equals(QueryStatus.Status.LAUNCHED) || ctx.getStatus().getStatus().equals(QueryStatus.Status.RUNNING)) {
        boolean ret=ctx.getSelectedDriver().cancelQuery(queryHandle);
        if (!ret) {
          return false;
        }
      }
      setCancelledStatus(ctx,""String_Node_Str"");
    }
    return true;
  }
  finally {
    release(sessionHandle);
  }
}",0.6147484493452792
25385,"private void setFailedStatus(QueryContext ctx,String statusMsg,String reason) throws GrillException {
  QueryStatus before=ctx.getStatus();
  ctx.setStatus(new QueryStatus(0.0f,QueryStatus.Status.FAILED,statusMsg,false,null,reason));
  fireStatusChangeEvent(ctx,ctx.getStatus(),before);
  updateFinishedQuery(ctx);
}","private void setFailedStatus(QueryContext ctx,String statusMsg,String reason) throws GrillException {
  QueryStatus before=ctx.getStatus();
  ctx.setStatus(new QueryStatus(0.0f,QueryStatus.Status.FAILED,statusMsg,false,null,reason));
  updateFinishedQuery(ctx,before);
  fireStatusChangeEvent(ctx,ctx.getStatus(),before);
}",0.9014084507042254
25386,"private QueryHandle executeAsyncInternal(GrillSessionHandle sessionHandle,QueryContext ctx,Configuration qconf) throws GrillException {
  ctx.setGrillSessionIdentifier(sessionHandle.getPublicId().toString());
  QueryStatus before=ctx.getStatus();
  acceptedQueries.add(ctx);
  ctx.setStatus(new QueryStatus(0.0,QueryStatus.Status.QUEUED,""String_Node_Str"",false,null,null));
  allQueries.put(ctx.getQueryHandle(),ctx);
  fireStatusChangeEvent(ctx,ctx.getStatus(),before);
  LOG.info(""String_Node_Str"" + ctx.getQueryHandle().getHandleId());
  return ctx.getQueryHandle();
}","private QueryHandle executeAsyncInternal(GrillSessionHandle sessionHandle,QueryContext ctx,Configuration qconf) throws GrillException {
  ctx.setGrillSessionIdentifier(sessionHandle.getPublicId().toString());
  QueryStatus before=ctx.getStatus();
  ctx.setStatus(new QueryStatus(0.0,QueryStatus.Status.QUEUED,""String_Node_Str"",false,null,null));
  acceptedQueries.add(ctx);
  allQueries.put(ctx.getQueryHandle(),ctx);
  fireStatusChangeEvent(ctx,ctx.getStatus(),before);
  LOG.info(""String_Node_Str"" + ctx.getQueryHandle().getHandleId());
  return ctx.getQueryHandle();
}",0.9509632224168126
25387,"private void updateStatus(final QueryHandle handle) throws GrillException {
  QueryContext ctx=allQueries.get(handle);
  if (ctx != null) {
synchronized (ctx) {
      QueryStatus before=ctx.getStatus();
      if (!ctx.getStatus().getStatus().equals(QueryStatus.Status.QUEUED) && !ctx.getStatus().isFinished()) {
        ctx.setStatus(ctx.getSelectedDriver().getStatus(ctx.getQueryHandle()));
      }
      if (ctx.getStatus().isFinished()) {
        updateFinishedQuery(ctx);
      }
      fireStatusChangeEvent(ctx,ctx.getStatus(),before);
    }
  }
}","private void updateStatus(final QueryHandle handle) throws GrillException {
  QueryContext ctx=allQueries.get(handle);
  if (ctx != null) {
synchronized (ctx) {
      QueryStatus before=ctx.getStatus();
      if (!ctx.getStatus().getStatus().equals(QueryStatus.Status.QUEUED) && !ctx.getStatus().isFinished()) {
        ctx.setStatus(ctx.getSelectedDriver().getStatus(ctx.getQueryHandle()));
        if (ctx.getStatus().isFinished()) {
          updateFinishedQuery(ctx,before);
        }
        fireStatusChangeEvent(ctx,ctx.getStatus(),before);
      }
    }
  }
}",0.8400357462019661
25388,"@Test public void testExecuteAsyncInMemoryResult() throws InterruptedException, IOException {
  final WebTarget target=target().path(""String_Node_Str"");
  final FormDataMultiPart mp=new FormDataMultiPart();
  GrillConf conf=new GrillConf();
  conf.addProperty(GrillConfConstants.GRILL_PERSISTENT_RESULT_SET,""String_Node_Str"");
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),grillSessionId,MediaType.APPLICATION_XML_TYPE));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str"" + testTable));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str""));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").fileName(""String_Node_Str"").build(),conf,MediaType.APPLICATION_XML_TYPE));
  final QueryHandle handle=target.request().post(Entity.entity(mp,MediaType.MULTIPART_FORM_DATA_TYPE),QueryHandle.class);
  Assert.assertNotNull(handle);
  GrillQuery ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
  Assert.assertEquals(ctx.getStatus().getStatus(),QueryStatus.Status.QUEUED);
  QueryStatus stat=ctx.getStatus();
  while (!stat.isFinished()) {
    ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
    stat=ctx.getStatus();
    Thread.sleep(1000);
  }
  Assert.assertEquals(ctx.getStatus().getStatus(),QueryStatus.Status.SUCCESSFUL);
  validateResultSetMetadata(handle);
  InMemoryQueryResult resultset=target.path(handle.toString()).path(""String_Node_Str"").queryParam(""String_Node_Str"",grillSessionId).request().get(InMemoryQueryResult.class);
  validateInmemoryResult(resultset);
}","@Test public void testExecuteAsyncInMemoryResult() throws InterruptedException, IOException {
  final WebTarget target=target().path(""String_Node_Str"");
  final FormDataMultiPart mp=new FormDataMultiPart();
  GrillConf conf=new GrillConf();
  conf.addProperty(GrillConfConstants.GRILL_PERSISTENT_RESULT_SET,""String_Node_Str"");
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),grillSessionId,MediaType.APPLICATION_XML_TYPE));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str"" + testTable));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str""));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").fileName(""String_Node_Str"").build(),conf,MediaType.APPLICATION_XML_TYPE));
  final QueryHandle handle=target.request().post(Entity.entity(mp,MediaType.MULTIPART_FORM_DATA_TYPE),QueryHandle.class);
  Assert.assertNotNull(handle);
  GrillQuery ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
  Assert.assertTrue(ctx.getStatus().getStatus().equals(Status.QUEUED) || ctx.getStatus().getStatus().equals(Status.LAUNCHED) || ctx.getStatus().getStatus().equals(Status.RUNNING));
  QueryStatus stat=ctx.getStatus();
  while (!stat.isFinished()) {
    ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
    stat=ctx.getStatus();
    Thread.sleep(1000);
  }
  Assert.assertEquals(ctx.getStatus().getStatus(),QueryStatus.Status.SUCCESSFUL);
  validateResultSetMetadata(handle);
  InMemoryQueryResult resultset=target.path(handle.toString()).path(""String_Node_Str"").queryParam(""String_Node_Str"",grillSessionId).request().get(InMemoryQueryResult.class);
  validateInmemoryResult(resultset);
}",0.9500405076964624
25389,"@Test public void testExecuteAsync() throws InterruptedException, IOException {
  final WebTarget target=target().path(""String_Node_Str"");
  final FormDataMultiPart mp=new FormDataMultiPart();
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),grillSessionId,MediaType.APPLICATION_XML_TYPE));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str"" + testTable));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str""));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").fileName(""String_Node_Str"").build(),new GrillConf(),MediaType.APPLICATION_XML_TYPE));
  final QueryHandle handle=target.request().post(Entity.entity(mp,MediaType.MULTIPART_FORM_DATA_TYPE),QueryHandle.class);
  Assert.assertNotNull(handle);
  GrillQuery ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
  Assert.assertEquals(ctx.getStatus().getStatus(),QueryStatus.Status.QUEUED);
  QueryStatus stat=ctx.getStatus();
  while (!stat.isFinished()) {
    ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
    stat=ctx.getStatus();
    Thread.sleep(1000);
  }
  Assert.assertEquals(ctx.getStatus().getStatus(),QueryStatus.Status.SUCCESSFUL);
  validatePersistedResult(handle);
  final QueryHandle handle2=target.request().post(Entity.entity(mp,MediaType.MULTIPART_FORM_DATA_TYPE),QueryHandle.class);
  Assert.assertNotNull(handle2);
  APIResult result=target.path(handle2.toString()).queryParam(""String_Node_Str"",grillSessionId).request().delete(APIResult.class);
  Assert.assertEquals(result.getStatus(),APIResult.Status.SUCCEEDED);
  while (true) {
    Thread.sleep(1000);
    GrillQuery ctx2=target.path(handle2.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
    if (QueryEnded.END_STATES.contains(ctx2.getStatus().getStatus())) {
      Assert.assertTrue(ctx2.getStatus().getStatus() == QueryStatus.Status.CANCELED || ctx2.getStatus().getStatus() == QueryStatus.Status.SUCCESSFUL,""String_Node_Str"");
      break;
    }
 else {
      System.out.println(handle2 + ""String_Node_Str"" + ctx2.getStatus().getStatus());
    }
  }
}","@Test public void testExecuteAsync() throws InterruptedException, IOException {
  final WebTarget target=target().path(""String_Node_Str"");
  final FormDataMultiPart mp=new FormDataMultiPart();
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),grillSessionId,MediaType.APPLICATION_XML_TYPE));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str"" + testTable));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").build(),""String_Node_Str""));
  mp.bodyPart(new FormDataBodyPart(FormDataContentDisposition.name(""String_Node_Str"").fileName(""String_Node_Str"").build(),new GrillConf(),MediaType.APPLICATION_XML_TYPE));
  final QueryHandle handle=target.request().post(Entity.entity(mp,MediaType.MULTIPART_FORM_DATA_TYPE),QueryHandle.class);
  Assert.assertNotNull(handle);
  GrillQuery ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
  Assert.assertTrue(ctx.getStatus().getStatus().equals(Status.QUEUED) || ctx.getStatus().getStatus().equals(Status.LAUNCHED) || ctx.getStatus().getStatus().equals(Status.RUNNING));
  QueryStatus stat=ctx.getStatus();
  while (!stat.isFinished()) {
    ctx=target.path(handle.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
    stat=ctx.getStatus();
    Thread.sleep(1000);
  }
  Assert.assertEquals(ctx.getStatus().getStatus(),QueryStatus.Status.SUCCESSFUL);
  validatePersistedResult(handle);
  final QueryHandle handle2=target.request().post(Entity.entity(mp,MediaType.MULTIPART_FORM_DATA_TYPE),QueryHandle.class);
  Assert.assertNotNull(handle2);
  APIResult result=target.path(handle2.toString()).queryParam(""String_Node_Str"",grillSessionId).request().delete(APIResult.class);
  Assert.assertEquals(result.getStatus(),APIResult.Status.SUCCEEDED);
  while (true) {
    Thread.sleep(1000);
    GrillQuery ctx2=target.path(handle2.toString()).queryParam(""String_Node_Str"",grillSessionId).request().get(GrillQuery.class);
    if (QueryEnded.END_STATES.contains(ctx2.getStatus().getStatus())) {
      Assert.assertTrue(ctx2.getStatus().getStatus() == QueryStatus.Status.CANCELED || ctx2.getStatus().getStatus() == QueryStatus.Status.SUCCESSFUL,""String_Node_Str"");
      break;
    }
 else {
      System.out.println(handle2 + ""String_Node_Str"" + ctx2.getStatus().getStatus());
    }
  }
}",0.9615784008307372
25390,"public APIResult(Status status,String message){
  super();
  this.status=status;
  this.message=message;
  requestId=NDC.peek();
  try {
    UUID.fromString(requestId);
  }
 catch (  IllegalArgumentException e) {
    requestId=null;
  }
}","public APIResult(Status status,String message){
  super();
  this.status=status;
  this.message=message;
}",0.6162790697674418
25391,"private void findCubePositions(ASTNode ast,List<CubeQueryInfo> cubeQueries,int queryEndPos) throws SemanticException {
  int child_count=ast.getChildCount();
  if (ast.getToken() != null) {
    if (ast.getToken().getType() == HiveParser.TOK_QUERY && ((ASTNode)ast.getChild(0)).getToken().getType() == HiveParser.KW_CUBE) {
      CubeQueryInfo cqi=new CubeQueryInfo();
      cqi.cubeAST=ast;
      if (ast.getParent() != null) {
        ASTNode parent=(ASTNode)ast.getParent();
        cqi.startPos=ast.getCharPositionInLine();
        int ci=ast.getChildIndex();
        if (parent.getToken() == null || parent.getToken().getType() == HiveParser.TOK_EXPLAIN) {
          cqi.endPos=queryEndPos;
        }
 else         if (parent.getChildCount() > ci + 1) {
          if (parent.getToken().getType() == HiveParser.TOK_SUBQUERY) {
            cqi.endPos=parent.getChild(ci + 1).getCharPositionInLine() - 2;
          }
 else           if (parent.getToken().getType() == HiveParser.TOK_UNION) {
            cqi.endPos=parent.getChild(ci + 1).getCharPositionInLine() - 11;
          }
 else {
            LOG.warn(""String_Node_Str"" + ast.dump());
            throw new SemanticException(""String_Node_Str"");
          }
        }
 else {
          cqi.endPos=parent.getParent().getChild(1).getCharPositionInLine() - 2;
        }
      }
      cubeQueries.add(cqi);
    }
 else {
      for (int child_pos=0; child_pos < child_count; ++child_pos) {
        findCubePositions((ASTNode)ast.getChild(child_pos),cubeQueries,queryEndPos);
      }
    }
  }
}","private void findCubePositions(ASTNode ast,List<CubeQueryInfo> cubeQueries,String originalQuery) throws SemanticException {
  int child_count=ast.getChildCount();
  if (ast.getToken() != null) {
    if (ast.getToken().getType() == HiveParser.TOK_QUERY && ((ASTNode)ast.getChild(0)).getToken().getType() == HiveParser.KW_CUBE) {
      CubeQueryInfo cqi=new CubeQueryInfo();
      cqi.cubeAST=ast;
      if (ast.getParent() != null) {
        ASTNode parent=(ASTNode)ast.getParent();
        cqi.startPos=ast.getCharPositionInLine();
        int ci=ast.getChildIndex();
        if (parent.getToken() == null || parent.getToken().getType() == HiveParser.TOK_EXPLAIN) {
          cqi.endPos=originalQuery.length();
        }
 else         if (parent.getChildCount() > ci + 1) {
          if (parent.getToken().getType() == HiveParser.TOK_SUBQUERY) {
            cqi.endPos=getEndPos(originalQuery,getEndPos(originalQuery,parent.getChild(ci + 1).getCharPositionInLine()),""String_Node_Str"");
            ;
          }
 else           if (parent.getToken().getType() == HiveParser.TOK_UNION) {
            cqi.endPos=getEndPos(originalQuery,parent.getChild(ci + 1).getCharPositionInLine() - 1,""String_Node_Str"");
          }
 else {
            LOG.warn(""String_Node_Str"" + ast.dump());
            throw new SemanticException(""String_Node_Str"");
          }
        }
 else {
          cqi.endPos=getEndPos(originalQuery,getEndPos(originalQuery,parent.getParent().getChild(1).getCharPositionInLine()),""String_Node_Str"",""String_Node_Str"");
        }
      }
      cubeQueries.add(cqi);
    }
 else {
      for (int child_pos=0; child_pos < child_count; ++child_pos) {
        findCubePositions((ASTNode)ast.getChild(child_pos),cubeQueries,originalQuery);
      }
    }
  }
}",0.9130959565479784
25392,"@Test public void testCubeQuery() throws ParseException, SemanticException, GrillException {
  CubeGrillDriver mockedDriver=Mockito.spy(cubeDriver);
  CubeQueryRewriter mockWriter=getMockedRewriter();
  Mockito.doReturn(mockWriter).when(mockedDriver).getRewriter(any(GrillDriver.class));
  String q1=""String_Node_Str"";
  Assert.assertFalse(cubeDriver.isCubeQuery(q1));
  List<CubeQueryInfo> cubeQueries=mockedDriver.findCubePositions(q1);
  Assert.assertEquals(cubeQueries.size(),0);
  mockedDriver.rewriteQuery(q1);
  String q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(mockedDriver.getReplacedQuery(q2));
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"" + ""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
}","@Test public void testCubeQuery() throws ParseException, SemanticException, GrillException {
  CubeGrillDriver mockedDriver=Mockito.spy(cubeDriver);
  CubeQueryRewriter mockWriter=getMockedRewriter();
  Mockito.doReturn(mockWriter).when(mockedDriver).getRewriter(any(GrillDriver.class));
  String q1=""String_Node_Str"";
  Assert.assertFalse(cubeDriver.isCubeQuery(q1));
  List<CubeQueryInfo> cubeQueries=mockedDriver.findCubePositions(q1);
  Assert.assertEquals(cubeQueries.size(),0);
  mockedDriver.rewriteQuery(q1);
  String q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(mockedDriver.getReplacedQuery(q2));
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"" + ""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  mockedDriver.rewriteQuery(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),1);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  mockedDriver.rewriteQuery(q2);
  Assert.assertEquals(cubeQueries.size(),3);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(2).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  mockedDriver.rewriteQuery(q2);
  Assert.assertEquals(cubeQueries.size(),3);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(2).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
  q2=""String_Node_Str"" + ""String_Node_Str"";
  Assert.assertTrue(cubeDriver.isCubeQuery(q2));
  cubeQueries=mockedDriver.findCubePositions(q2);
  mockedDriver.rewriteQuery(q2);
  Assert.assertEquals(cubeQueries.size(),2);
  Assert.assertEquals(cubeQueries.get(0).query,""String_Node_Str"");
  Assert.assertEquals(cubeQueries.get(1).query,""String_Node_Str"");
  mockedDriver.rewriteQuery(q2);
}",0.7659894657637322
25393,"@Override public ResultRow next() throws GrillException {
  TRow row=rowItr.next();
  List<ColumnDescriptor> descriptors=getTableSchema().getColumnDescriptors();
  List<Object> results=new ArrayList<Object>(row.getColValsSize());
  List<TColumnValue> thriftRow=row.getColVals();
  for (int i=0; i < row.getColValsSize(); i++) {
    TColumnValue tColumnValue=thriftRow.get(i);
    Type type=descriptors.get(i).getType();
    Object value=null;
switch (type) {
case NULL_TYPE:
      value=null;
    break;
case BOOLEAN_TYPE:
{
    TBoolValue tValue=tColumnValue.getBoolVal();
    if (tValue.isSetValue()) {
      value=tValue.isValue();
    }
    break;
  }
case TINYINT_TYPE:
{
  TByteValue tValue=tColumnValue.getByteVal();
  if (tValue.isSetValue()) {
    value=tValue.getValue();
  }
  break;
}
case SMALLINT_TYPE:
{
TI16Value tValue=tColumnValue.getI16Val();
if (tValue.isSetValue()) {
  value=tValue.getValue();
}
break;
}
case INT_TYPE:
{
TI32Value tValue=tColumnValue.getI32Val();
if (tValue.isSetValue()) {
value=tValue.getValue();
}
break;
}
case BIGINT_TYPE:
{
TI64Value tValue=tColumnValue.getI64Val();
if (tValue.isSetValue()) {
value=tValue.getValue();
}
break;
}
case FLOAT_TYPE:
case DOUBLE_TYPE:
{
TDoubleValue tValue=tColumnValue.getDoubleVal();
if (tValue.isSetValue()) {
value=tValue.getValue();
}
break;
}
case STRING_TYPE:
case VARCHAR_TYPE:
case DATE_TYPE:
case TIMESTAMP_TYPE:
case BINARY_TYPE:
case DECIMAL_TYPE:
case ARRAY_TYPE:
case MAP_TYPE:
case STRUCT_TYPE:
case UNION_TYPE:
case USER_DEFINED_TYPE:
{
TStringValue tValue=tColumnValue.getStringVal();
if (tValue.isSetValue()) {
value=tValue.getValue();
}
break;
}
default :
value=null;
}
results.add(value);
}
return new ResultRow(results);
}","@Override public ResultRow next() throws GrillException {
  List<ColumnDescriptor> descriptors=getTableSchema().getColumnDescriptors();
  int numColumns=descriptors.size();
  List<Object> results=new ArrayList<Object>(numColumns);
  Object[] row=fetchedRowsItr.next();
  results.addAll(Arrays.asList(row));
  return new ResultRow(results);
}",0.1834951456310679
25394,"@Override public boolean hasNext() throws GrillException {
  if (noMoreResults) {
    return false;
  }
  if (rowItr == null || !rowItr.hasNext()) {
    try {
      rowSet=client.fetchResults(opHandle,FetchOrientation.FETCH_NEXT,fetchSize).toTRowSet();
      noMoreResults=rowSet.getRowsSize() == 0;
    }
 catch (    Exception e) {
      throw new GrillException(e);
    }
    rowItr=rowSet.getRowsIterator();
  }
  return rowItr.hasNext();
}","@Override public boolean hasNext() throws GrillException {
  if (fetchedRowsItr == null || !fetchedRowsItr.hasNext()) {
    try {
      rowSet=client.fetchResults(opHandle,FetchOrientation.FETCH_NEXT,fetchSize);
      noMoreResults=rowSet.numRows() == 0;
      if (noMoreResults) {
        return false;
      }
      fetchedRowsItr=rowSet.iterator();
    }
 catch (    Exception e) {
      throw new GrillException(e);
    }
  }
  return fetchedRowsItr.hasNext();
}",0.6512651265126512
25395,"private void extractPlanDetails(List<String> explainOutput,HiveConf conf) throws HiveException {
  ParserState state=ParserState.BEGIN;
  ParserState prevState=state;
  ArrayList<ParserState> states=new ArrayList<ParserState>();
  Hive metastore=Hive.get(conf);
  for (  String line : explainOutput) {
    String tr=line.trim();
    prevState=state;
    state=nextState(tr,state);
    if (prevState != state) {
      states.add(prevState);
    }
switch (state) {
case MOVE:
      if (tr.startsWith(""String_Node_Str"")) {
        String outputPath=tr.replace(""String_Node_Str"",""String_Node_Str"").trim();
        resultDestination=outputPath;
      }
    break;
case TABLE_SCAN:
  if (tr.startsWith(""String_Node_Str"")) {
    String tableName=tr.replace(""String_Node_Str"",""String_Node_Str"").trim();
    tablesQueried.add(tableName);
    Table tbl=metastore.getTable(tableName);
    String costStr=tbl.getParameters().get(GrillConfConstants.STORAGE_COST);
    Double weight=1d;
    if (costStr != null) {
      weight=Double.parseDouble(costStr);
    }
    tableWeights.put(tableName,weight);
  }
break;
case JOIN:
if (tr.equals(""String_Node_Str"")) {
numJoins++;
}
break;
case SELECT:
if (tr.startsWith(""String_Node_Str"") && states.get(states.size() - 1) == ParserState.TABLE_SCAN) {
numSels++;
}
break;
case GROUPBY_EXPRS:
if (tr.startsWith(""String_Node_Str"")) {
numAggrExprs++;
}
break;
case GROUPBY_KEYS:
if (tr.startsWith(""String_Node_Str"")) {
numGbys++;
}
break;
}
}
}","private void extractPlanDetails(List<String> explainOutput,HiveConf conf) throws HiveException {
  ParserState state=ParserState.BEGIN;
  ParserState prevState=state;
  ArrayList<ParserState> states=new ArrayList<ParserState>();
  Hive metastore=Hive.get(conf);
  for (  String line : explainOutput) {
    String tr=line.trim();
    prevState=state;
    state=nextState(tr,state);
    if (prevState != state) {
      states.add(prevState);
    }
switch (state) {
case MOVE:
      if (tr.startsWith(""String_Node_Str"")) {
        String outputPath=tr.replace(""String_Node_Str"",""String_Node_Str"").trim();
        resultDestination=outputPath;
      }
    break;
case TABLE_SCAN:
  if (tr.startsWith(""String_Node_Str"")) {
    String tableName=tr.replace(""String_Node_Str"",""String_Node_Str"").trim();
    tablesQueried.add(tableName);
    Table tbl=metastore.getTable(tableName);
    String costStr=tbl.getParameters().get(GrillConfConstants.STORAGE_COST);
    Double weight=1d;
    if (costStr != null) {
      weight=Double.parseDouble(costStr);
    }
    tableWeights.put(tableName,weight);
  }
break;
case JOIN:
if (tr.equals(""String_Node_Str"")) {
numJoins++;
}
break;
case SELECT:
if (tr.startsWith(""String_Node_Str"") && states.get(states.size() - 1) == ParserState.TABLE_SCAN) {
numSels+=StringUtils.split(tr,""String_Node_Str"").length;
}
break;
case GROUPBY_EXPRS:
if (tr.startsWith(""String_Node_Str"")) {
numAggrExprs+=StringUtils.split(tr,""String_Node_Str"").length;
}
break;
case GROUPBY_KEYS:
if (tr.startsWith(""String_Node_Str"")) {
numGbys+=StringUtils.split(tr,""String_Node_Str"").length;
}
break;
}
}
}",0.9531554977228368
25396,"@Test public void testExecuteQueryAsync() throws Exception {
  createTestTable(""String_Node_Str"");
  String expectFail=""String_Node_Str"";
  conf.setBoolean(GrillConfConstants.GRILL_PERSISTENT_RESULT_SET,true);
  QueryContext context=new QueryContext(expectFail,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.FAILED,true,null,false);
  driver.closeQuery(context.getQueryHandle());
  String select=""String_Node_Str"";
  conf.setBoolean(HiveDriver.GRILL_PERSISTENT_RESULT_SET,false);
  context=new QueryContext(select,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.SUCCESSFUL,false,null,false);
  driver.closeQuery(context.getQueryHandle());
  conf.setBoolean(HiveDriver.GRILL_PERSISTENT_RESULT_SET,true);
  context=new QueryContext(select,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.SUCCESSFUL,true,HiveDriver.GRILL_RESULT_SET_PARENT_DIR_DEFAULT,false);
  driver.closeQuery(context.getQueryHandle());
  conf.set(HiveDriver.GRILL_OUTPUT_DIRECTORY_FORMAT,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  select=""String_Node_Str"";
  context=new QueryContext(select,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.SUCCESSFUL,true,HiveDriver.GRILL_RESULT_SET_PARENT_DIR_DEFAULT,true);
  driver.closeQuery(context.getQueryHandle());
}","@Test public void testExecuteQueryAsync() throws Exception {
  createTestTable(""String_Node_Str"");
  String expectFail=""String_Node_Str"";
  conf.setBoolean(GrillConfConstants.GRILL_PERSISTENT_RESULT_SET,true);
  conf.set(""String_Node_Str"",FailHook.class.getCanonicalName());
  QueryContext context=new QueryContext(expectFail,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.FAILED,true,null,false);
  driver.closeQuery(context.getQueryHandle());
  conf.set(""String_Node_Str"",""String_Node_Str"");
  String select=""String_Node_Str"";
  conf.setBoolean(HiveDriver.GRILL_PERSISTENT_RESULT_SET,false);
  context=new QueryContext(select,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.SUCCESSFUL,false,null,false);
  driver.closeQuery(context.getQueryHandle());
  conf.setBoolean(HiveDriver.GRILL_PERSISTENT_RESULT_SET,true);
  context=new QueryContext(select,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.SUCCESSFUL,true,HiveDriver.GRILL_RESULT_SET_PARENT_DIR_DEFAULT,false);
  driver.closeQuery(context.getQueryHandle());
  conf.set(HiveDriver.GRILL_OUTPUT_DIRECTORY_FORMAT,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  select=""String_Node_Str"";
  context=new QueryContext(select,null,conf);
  driver.executeAsync(context);
  validateExecuteAsync(context,Status.SUCCESSFUL,true,HiveDriver.GRILL_RESULT_SET_PARENT_DIR_DEFAULT,true);
  driver.closeQuery(context.getQueryHandle());
}",0.9603340292275574
25397,"public static SessionHandle getHiveSessionHandle(GrillSessionHandle grillHandle){
  return new SessionHandle(new HandleIdentifier(grillHandle.getPublicId(),grillHandle.getSecretId()));
}","public static SessionHandle getHiveSessionHandle(GrillSessionHandle grillHandle){
  return new SessionHandle(new HandleIdentifier(grillHandle.getPublicId(),grillHandle.getSecretId()),CLIService.SERVER_VERSION);
}",0.9346733668341708
25398,"public GrillSessionImpl(String username,String password,Map<String,String> sessionConf){
  super(username,password,sessionConf);
}","public GrillSessionImpl(TProtocolVersion protocol,String username,String password,Map<String,String> sessionConf){
  super(protocol,username,password,sessionConf);
}",0.8813559322033898
25399,"public OperationHandle getAllSessionParameters(GrillSessionHandle sessionid,boolean verbose,String key){
  String command=""String_Node_Str"";
  if (verbose) {
    command+=""String_Node_Str"";
  }
  if (!StringUtils.isBlank(key)) {
    command+=""String_Node_Str"" + key;
  }
  OperationHandle handle;
  try {
    acquire(sessionid);
    handle=getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
  }
 catch (  HiveSQLException e) {
    throw new WebApplicationException(e);
  }
catch (  GrillException e) {
    throw new WebApplicationException(e);
  }
 finally {
    try {
      release(sessionid);
    }
 catch (    GrillException e) {
      throw new WebApplicationException(e);
    }
  }
  return handle;
}","public OperationHandle getAllSessionParameters(GrillSessionHandle sessionid,boolean verbose,String key) throws GrillException, HiveSQLException {
  String command=""String_Node_Str"";
  if (verbose) {
    command+=""String_Node_Str"";
  }
  if (!StringUtils.isBlank(key)) {
    command+=""String_Node_Str"" + key;
  }
  OperationHandle handle;
  try {
    acquire(sessionid);
    handle=getCliService().executeStatement(getHiveSessionHandle(sessionid),command,null);
  }
  finally {
    try {
      release(sessionid);
    }
 catch (    GrillException e) {
      throw new WebApplicationException(e);
    }
  }
  return handle;
}",0.2564480471628592
25400,"/** 
 * Get a list of key=value parameters set for this session
 * @param sessionid session handle object
 * @param verbose If true, all the parameters will be returned.If false, configuration parameters will be returned
 * @param key if this is empty, output will contain all parameters and their values, if it is non empty parameters will be filtered by key
 * @return List of Strings, one entry per key-value pair
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public StringList getParams(@QueryParam(""String_Node_Str"") GrillSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") boolean verbose,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String key){
  OperationHandle handle=sessionService.getAllSessionParameters(sessionid,verbose,key);
  RowSet rows=null;
  try {
    rows=sessionService.getCliService().fetchResults(handle);
  }
 catch (  HiveSQLException e) {
    new WebApplicationException(e);
  }
  List<String> result=new ArrayList<String>();
  for (  TRow row : rows.toTRowSet().getRows()) {
    result.add(row.getColVals().get(0).getStringVal().getValue());
  }
  return new StringList(result);
}","/** 
 * Get a list of key=value parameters set for this session
 * @param sessionid session handle object
 * @param verbose If true, all the parameters will be returned.If false, configuration parameters will be returned
 * @param key if this is empty, output will contain all parameters and their values, if it is non empty parameters will be filtered by key
 * @return List of Strings, one entry per key-value pair
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML,MediaType.TEXT_PLAIN}) public StringList getParams(@QueryParam(""String_Node_Str"") GrillSessionHandle sessionid,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") boolean verbose,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") String key){
  RowSet rows=null;
  boolean failed=false;
  List<String> result=new ArrayList<String>();
  try {
    OperationHandle handle=sessionService.getAllSessionParameters(sessionid,verbose,key);
    rows=sessionService.getCliService().fetchResults(handle);
  }
 catch (  HiveSQLException e) {
    failed=true;
    result.add(key + ""String_Node_Str"");
  }
catch (  GrillException e) {
    new WebApplicationException(e);
  }
  if (!failed) {
    Iterator<Object[]> itr=rows.iterator();
    while (itr.hasNext()) {
      result.add((String)itr.next()[0]);
    }
  }
  return new StringList(result);
}",0.7796480489671003
25401,"/** 
 * Get status of the query, specified by the handle
 * @param handle The query handle
 * @return query status
 */
@Override public QueryStatus getStatus(QueryHandle handle) throws GrillException {
  checkConfigured();
  JdbcQueryContext ctx=getQueryContext(handle);
  QueryStatus status;
  if (ctx.getResultFuture().isDone()) {
    if (ctx.isCancelled()) {
      status=new QueryStatus(1.0,Status.CANCELED,handle.getHandleId() + ""String_Node_Str"",true);
    }
 else     if (ctx.getQueryResult() != null && ctx.getQueryResult().error != null) {
      status=new QueryStatus(1.0,Status.FAILED,ctx.getQueryResult().error.getMessage(),false);
    }
 else {
      status=new QueryStatus(1.0,Status.SUCCESSFUL,handle.getHandleId() + ""String_Node_Str"",true);
    }
  }
 else {
    status=new QueryStatus(0.0,Status.RUNNING,handle.getHandleId() + ""String_Node_Str"",false);
  }
  return status;
}","/** 
 * Get status of the query, specified by the handle
 * @param handle The query handle
 * @return query status
 */
@Override public QueryStatus getStatus(QueryHandle handle) throws GrillException {
  checkConfigured();
  JdbcQueryContext ctx=getQueryContext(handle);
  QueryStatus status;
  if (ctx.getResultFuture().isDone()) {
    if (ctx.isCancelled()) {
      status=new QueryStatus(1.0,Status.CANCELED,handle.getHandleId() + ""String_Node_Str"",true,null,null);
    }
 else     if (ctx.getQueryResult() != null && ctx.getQueryResult().error != null) {
      status=new QueryStatus(1.0,Status.FAILED,ctx.getQueryResult().error.getMessage(),false,null,null);
    }
 else {
      status=new QueryStatus(1.0,Status.SUCCESSFUL,handle.getHandleId() + ""String_Node_Str"",true,null,null);
    }
  }
 else {
    status=new QueryStatus(0.0,Status.RUNNING,handle.getHandleId() + ""String_Node_Str"",false,null,null);
  }
  return status;
}",0.9780701754385964
25402,"public CubeReader(final Properties changes) throws IOException {
  reader=CubeDefinitionReaderFactory.get(changes);
  props.load(Thread.currentThread().getContextClassLoader().getResourceAsStream(""String_Node_Str""));
  for (  final Object key : changes.keySet()) {
    props.put(key,changes.get(key));
  }
}","public CubeReader(final Properties changes) throws IOException {
  reader=CubeDefinitionReaderFactory.get(changes);
  props=reader.getAllProps();
  for (  final Object key : changes.keySet()) {
    props.put(key,changes.get(key));
  }
}",0.4935543278084714
25403,"@Override public QueryStatus getStatus(QueryHandle handle) throws GrillException {
  LOG.info(""String_Node_Str"" + handle);
  OperationHandle hiveHandle=getHiveHandle(handle);
  ByteArrayInputStream in=null;
  boolean hasResult=false;
  try {
    OperationStatus opStatus=getClient().getOperationStatus(hiveHandle);
    QueryStatus.Status stat=null;
switch (opStatus.getState()) {
case CANCELED:
      stat=Status.CANCELED;
    break;
case CLOSED:
  stat=Status.CLOSED;
break;
case ERROR:
stat=Status.FAILED;
break;
case FINISHED:
stat=Status.SUCCESSFUL;
hasResult=true;
break;
case INITIALIZED:
stat=Status.RUNNING;
break;
case RUNNING:
stat=Status.RUNNING;
break;
case PENDING:
stat=Status.LAUNCHED;
break;
case UNKNOWN:
stat=Status.UNKNOWN;
break;
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String msg=""String_Node_Str"";
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskStatus> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskStatus>>(){
}
);
int completedTasks=0;
StringBuilder message=new StringBuilder();
for (TaskStatus taskStat : taskStatuses) {
String state=taskStat.getTaskState();
if (""String_Node_Str"".equalsIgnoreCase(state)) {
completedTasks++;
}
message.append(taskStat.getExternalHandle()).append(""String_Node_Str"").append(state).append(""String_Node_Str"");
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
msg=message.toString();
}
 else {
LOG.warn(""String_Node_Str"");
}
return new QueryStatus(progress,stat,msg,false,ctx.hiveHandle.getHandleIdentifier().toString());
}
 catch (Exception e) {
throw new GrillException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
}
}","@Override public QueryStatus getStatus(QueryHandle handle) throws GrillException {
  LOG.info(""String_Node_Str"" + handle);
  OperationHandle hiveHandle=getHiveHandle(handle);
  ByteArrayInputStream in=null;
  boolean hasResult=false;
  try {
    OperationStatus opStatus=getClient().getOperationStatus(hiveHandle);
    QueryStatus.Status stat=null;
switch (opStatus.getState()) {
case CANCELED:
      stat=Status.CANCELED;
    break;
case CLOSED:
  stat=Status.CLOSED;
break;
case ERROR:
stat=Status.FAILED;
break;
case FINISHED:
stat=Status.SUCCESSFUL;
hasResult=true;
break;
case INITIALIZED:
stat=Status.RUNNING;
break;
case RUNNING:
stat=Status.RUNNING;
break;
case PENDING:
stat=Status.LAUNCHED;
break;
case UNKNOWN:
stat=Status.UNKNOWN;
break;
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String msg=""String_Node_Str"";
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskStatus> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskStatus>>(){
}
);
int completedTasks=0;
StringBuilder message=new StringBuilder();
for (TaskStatus taskStat : taskStatuses) {
String state=taskStat.getTaskState();
if (""String_Node_Str"".equalsIgnoreCase(state)) {
completedTasks++;
}
message.append(taskStat.getExternalHandle()).append(""String_Node_Str"").append(state).append(""String_Node_Str"");
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
msg=message.toString();
}
 else {
LOG.warn(""String_Node_Str"");
}
return new QueryStatus(progress,stat,msg,false,hiveHandle.getHandleIdentifier().toString());
}
 catch (Exception e) {
throw new GrillException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
}
}",0.9989200863930886
25404,"@BeforeTest public void setup() throws Exception {
  service=new EventServiceImpl();
  service.init();
  service.start();
  LOG.info(""String_Node_Str"");
}","@BeforeTest public void setup() throws Exception {
  service=new EventServiceImpl();
  service.start();
  LOG.info(""String_Node_Str"");
}",0.9379310344827586
25405,"@Override public QueryPlan explain(String query,Configuration conf) throws GrillException {
  QueryContext ctx=createQueryContext(query,conf);
  Configuration explainConf=new Configuration(conf);
  explainConf.setBoolean(GRILL_PERSISTENT_RESULT_SET,false);
  String explainQuery=""String_Node_Str"" + ctx.hiveQuery;
  HiveInMemoryResultSet inMemoryResultSet=(HiveInMemoryResultSet)execute(explainQuery,explainConf);
  List<String> explainOutput=new ArrayList<String>();
  while (inMemoryResultSet.hasNext()) {
    explainOutput.add(((TStringValue)inMemoryResultSet.next().get(0)).getValue());
  }
  QueryHandle handle=null;
  if (conf.getBoolean(GrillConfConstatnts.PREPARE_ON_EXPLAIN,GrillConfConstatnts.DEFAULT_PREPARE_ON_EXPLAIN)) {
    handleToContext.put(ctx.queryHandle,ctx);
    handle=ctx.queryHandle;
  }
  LOG.info(""String_Node_Str"" + query);
  try {
    return new HiveQueryPlan(explainOutput,handle,ctx.conf);
  }
 catch (  HiveException e) {
    throw new GrillException(""String_Node_Str"",e);
  }
}","@Override public QueryPlan explain(String query,Configuration conf) throws GrillException {
  QueryContext ctx=createQueryContext(query,conf);
  Configuration explainConf=new Configuration(conf);
  explainConf.setBoolean(GRILL_PERSISTENT_RESULT_SET,false);
  String explainQuery=""String_Node_Str"" + ctx.hiveQuery;
  HiveInMemoryResultSet inMemoryResultSet=(HiveInMemoryResultSet)execute(explainQuery,explainConf);
  List<String> explainOutput=new ArrayList<String>();
  while (inMemoryResultSet.hasNext()) {
    explainOutput.add(((TStringValue)inMemoryResultSet.next().get(0)).getValue());
  }
  QueryHandle handle=null;
  if (conf.getBoolean(GrillConfConstants.PREPARE_ON_EXPLAIN,GrillConfConstants.DEFAULT_PREPARE_ON_EXPLAIN)) {
    handleToContext.put(ctx.queryHandle,ctx);
    handle=ctx.queryHandle;
  }
  LOG.info(""String_Node_Str"" + query);
  try {
    return new HiveQueryPlan(explainOutput,handle,ctx.conf);
  }
 catch (  HiveException e) {
    throw new GrillException(""String_Node_Str"",e);
  }
}",0.9990079365079364
25406,"@Override public QueryStatus getStatus(QueryHandle handle) throws GrillException {
  LOG.info(""String_Node_Str"" + handle);
  QueryContext ctx=getContext(handle);
  ByteArrayInputStream in=null;
  try {
    OperationStatus opStatus=getClient().getOperationStatus(ctx.hiveHandle);
    QueryStatus.Status stat=null;
switch (opStatus.getState()) {
case CANCELED:
      stat=Status.CANCELED;
    break;
case CLOSED:
  stat=Status.CLOSED;
break;
case ERROR:
stat=Status.FAILED;
break;
case FINISHED:
stat=Status.SUCCESSFUL;
break;
case INITIALIZED:
stat=Status.RUNNING;
break;
case RUNNING:
stat=Status.RUNNING;
break;
case PENDING:
stat=Status.PENDING;
break;
case UNKNOWN:
stat=Status.UNKNOWN;
break;
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String msg=""String_Node_Str"";
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskStatus> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskStatus>>(){
}
);
int completedTasks=0;
StringBuilder message=new StringBuilder();
for (TaskStatus taskStat : taskStatuses) {
String state=taskStat.getTaskState();
if (""String_Node_Str"".equalsIgnoreCase(state)) {
completedTasks++;
}
message.append(taskStat.getExternalHandle()).append(""String_Node_Str"").append(state).append(""String_Node_Str"");
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
msg=message.toString();
}
 else {
LOG.warn(""String_Node_Str"");
}
return new QueryStatus(progress,stat,msg,false);
}
 catch (Exception e) {
throw new GrillException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
}
}","@Override public QueryStatus getStatus(QueryHandle handle) throws GrillException {
  LOG.info(""String_Node_Str"" + handle);
  QueryContext ctx=getContext(handle);
  ByteArrayInputStream in=null;
  try {
    OperationStatus opStatus=getClient().getOperationStatus(ctx.hiveHandle);
    QueryStatus.Status stat=null;
switch (opStatus.getState()) {
case CANCELED:
      stat=Status.CANCELED;
    break;
case CLOSED:
  stat=Status.CLOSED;
break;
case ERROR:
stat=Status.FAILED;
break;
case FINISHED:
stat=Status.SUCCESSFUL;
break;
case INITIALIZED:
stat=Status.RUNNING;
break;
case RUNNING:
stat=Status.RUNNING;
break;
case PENDING:
stat=Status.LAUNCHED;
break;
case UNKNOWN:
stat=Status.UNKNOWN;
break;
}
float progress=0f;
String jsonTaskStatus=opStatus.getTaskStatus();
String msg=""String_Node_Str"";
if (StringUtils.isNotBlank(jsonTaskStatus)) {
ObjectMapper mapper=new ObjectMapper();
in=new ByteArrayInputStream(jsonTaskStatus.getBytes(""String_Node_Str""));
List<TaskStatus> taskStatuses=mapper.readValue(in,new TypeReference<List<TaskStatus>>(){
}
);
int completedTasks=0;
StringBuilder message=new StringBuilder();
for (TaskStatus taskStat : taskStatuses) {
String state=taskStat.getTaskState();
if (""String_Node_Str"".equalsIgnoreCase(state)) {
completedTasks++;
}
message.append(taskStat.getExternalHandle()).append(""String_Node_Str"").append(state).append(""String_Node_Str"");
}
progress=taskStatuses.size() == 0 ? 0 : (float)completedTasks / taskStatuses.size();
msg=message.toString();
}
 else {
LOG.warn(""String_Node_Str"");
}
return new QueryStatus(progress,stat,msg,false);
}
 catch (Exception e) {
throw new GrillException(""String_Node_Str"",e);
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
}
}",0.9968634160250928
25407,"@Test public void testExplain() throws Exception {
  createTestTable(""String_Node_Str"");
  QueryPlan plan=driver.explain(""String_Node_Str"",conf);
  assertTrue(plan instanceof HiveQueryPlan);
  assertEquals(plan.getTableWeight(""String_Node_Str""),500.0);
  GrillResultSet result=driver.executePrepare(plan.getHandle(),conf);
  validateExecuteSync(result);
  driver.executePrepareAsync(plan.getHandle(),conf);
  validateExecuteAsync(plan.getHandle(),Status.SUCCESSFUL);
  driver.closeQuery(plan.getHandle());
  conf.setBoolean(GrillConfConstatnts.PREPARE_ON_EXPLAIN,false);
  plan=driver.explain(""String_Node_Str"",conf);
  assertTrue(plan instanceof HiveQueryPlan);
  assertNull(plan.getHandle());
  conf.setBoolean(GrillConfConstatnts.PREPARE_ON_EXPLAIN,true);
}","@Test public void testExplain() throws Exception {
  createTestTable(""String_Node_Str"");
  QueryPlan plan=driver.explain(""String_Node_Str"",conf);
  assertTrue(plan instanceof HiveQueryPlan);
  assertEquals(plan.getTableWeight(""String_Node_Str""),500.0);
  GrillResultSet result=driver.executePrepare(plan.getHandle(),conf);
  validateExecuteSync(result);
  driver.executePrepareAsync(plan.getHandle(),conf);
  validateExecuteAsync(plan.getHandle(),Status.SUCCESSFUL);
  driver.closeQuery(plan.getHandle());
  conf.setBoolean(GrillConfConstants.PREPARE_ON_EXPLAIN,false);
  plan=driver.explain(""String_Node_Str"",conf);
  assertTrue(plan instanceof HiveQueryPlan);
  assertNull(plan.getHandle());
  conf.setBoolean(GrillConfConstants.PREPARE_ON_EXPLAIN,true);
}",0.9986824769433466
25408,"@Override public Object clone(){
  GoogleSpreadsheetOutputMeta retval=(GoogleSpreadsheetOutputMeta)super.clone();
  retval.setServiceEmail(this.serviceEmail);
  retval.setPrivateKeyStore(this.privateKeyStore);
  retval.setSpreadsheetKey(this.spreadsheetKey);
  retval.setWorksheetId(this.spreadsheetKey);
  return retval;
}","@Override public Object clone(){
  GoogleSpreadsheetOutputMeta retval=(GoogleSpreadsheetOutputMeta)super.clone();
  retval.setServiceEmail(this.serviceEmail);
  retval.setPrivateKeyStore(this.privateKeyStore);
  retval.setSpreadsheetKey(this.spreadsheetKey);
  retval.setWorksheetId(this.worksheetId);
  return retval;
}",0.9611197511664076
25409,"@Override public Object clone(){
  GoogleSpreadsheetInputMeta retval=(GoogleSpreadsheetInputMeta)super.clone();
  retval.setServiceEmail(this.serviceEmail);
  retval.setPrivateKeyStore(this.privateKeyStore);
  retval.setSpreadsheetKey(this.spreadsheetKey);
  retval.setWorksheetId(this.spreadsheetKey);
  return retval;
}","@Override public Object clone(){
  GoogleSpreadsheetInputMeta retval=(GoogleSpreadsheetInputMeta)super.clone();
  retval.setServiceEmail(this.serviceEmail);
  retval.setPrivateKeyStore(this.privateKeyStore);
  retval.setSpreadsheetKey(this.spreadsheetKey);
  retval.setWorksheetId(this.worksheetId);
  return retval;
}",0.9608763693270737
25410,"public static ComposeData buildDefault(Context context,Uri uri){
  return new ComposeData(uri,context.getString(R.string.default_lgtm_text),40,Color.BLACK);
}","public static ComposeData buildDefault(Context context,Uri uri){
  return new ComposeData(uri,context.getString(R.string.default_lgtm_text),80,Color.BLACK);
}",0.9936708860759492
25411,"@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_compose);
  mHolder.onCreate(getIntent().<Uri>getParcelableExtra(EXTRA_URI),savedInstanceState);
  mHelper.setSurface(mHolder.getData());
}","@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_compose);
  mHolder.onCreate(getIntent().<Uri>getParcelableExtra(EXTRA_URI),savedInstanceState);
  mHelper.setUpActionBar();
  mHelper.setUpComposeView(mHolder.getData());
}",0.9169435215946844
25412,"@Inject ComposeViewHelper(@ForActivity Context context){
  super(context);
  mMoveDetector=new MoveGestureDetector(context,this);
  mScaleDetector=new ScaleGestureDetector(context,this);
}","@Inject ComposeViewHelper(@ForActivity Context context){
  super(context);
}",0.5757575757575758
25413,"@Override public void surfaceChanged(SurfaceHolder holder,int format,int width,int height){
  if (mLooper != null) {
    mWidth=width;
    mHeight=height;
    mLooper.start();
  }
}","@Override public void surfaceChanged(SurfaceHolder holder,int format,int width,int height){
  if (mLooper != null) {
    mWidth=width;
    mHeight=height;
    Paint.FontMetrics metrics=mTextPaint.getFontMetrics();
    float textWidth=mTextPaint.measureText(mData.getText());
    mTextBaseX=(mWidth / 2) - textWidth / 2;
    mTextBaseY=(mHeight / 2) - (metrics.ascent + metrics.descent) / 2;
    mLooper.start();
  }
}",0.6053511705685619
25414,"@Override public boolean onTouchEvent(MotionEvent event){
  mScaleDetector.onTouchEvent(event);
  mRotateDetector.onTouchEvent(event);
  mMoveDetector.onTouchEvent(event);
  mLooper=new Thread(this);
  mLooper.start();
  return true;
}","@Override public boolean onTouchEvent(@Nonnull MotionEvent event){
  mScaleDetector.onTouchEvent(event);
  mRotateDetector.onTouchEvent(event);
  mMoveDetector.onTouchEvent(event);
  mLooper=new Thread(this);
  mLooper.start();
  return true;
}",0.9812108559498957
25415,"void drawText(Canvas canvas){
  canvas.save();
  float textSize=mTextSize * mScaleFactor;
  float textX=mTextBaseX + mTextX;
  float textY=mTextBaseY=mTextY;
  canvas.rotate(mDegree,textX,textY);
  mTextPaint.setTextSize(textSize < 255.f ? textSize : 255.f);
  canvas.drawText(mData.getText(),textX,textY,mTextPaint);
  float strokeSize=0.5f * mScaleFactor;
  Paint strokePaint=new Paint();
  strokePaint.setStyle(Paint.Style.STROKE);
  strokePaint.setStrokeWidth(strokeSize < 3.f ? strokeSize : 3.f);
  strokePaint.setColor(Color.BLACK);
  strokePaint.setTextSize(textSize < 255.f ? textSize : 255.f);
  strokePaint.setTypeface(Typeface.DEFAULT_BOLD);
  strokePaint.setAntiAlias(true);
  canvas.drawText(mData.getText(),textX,textY,strokePaint);
  canvas.restore();
}","void drawText(Canvas canvas){
  canvas.save();
  float textSize=mTextSize * mScaleFactor;
  float textX=mTextBaseX + mTextX;
  float textY=mTextBaseY + mTextY;
  canvas.rotate(mDegree,textX,textY);
  mTextPaint.setTextSize(textSize < 255.f ? textSize : 255.f);
  canvas.drawText(mData.getText(),textX,textY,mTextPaint);
  float strokeSize=0.5f * mScaleFactor;
  Paint strokePaint=new Paint();
  strokePaint.setStyle(Paint.Style.STROKE);
  strokePaint.setStrokeWidth(strokeSize < 3.f ? strokeSize : 3.f);
  strokePaint.setColor(Color.BLACK);
  strokePaint.setTextSize(textSize < 255.f ? textSize : 255.f);
  strokePaint.setTypeface(Typeface.DEFAULT_BOLD);
  strokePaint.setAntiAlias(true);
  canvas.drawText(mData.getText(),textX,textY,strokePaint);
  canvas.restore();
}",0.9973992197659298
25416,"public ComposeView(Context context,ComposeData data){
  super(context);
  mData=data;
  mMoveDetector=new MoveGestureDetector(context,this);
  mScaleDetector=new ScaleGestureDetector(context,this);
  mRotateDetector=new RotateGestureDetector(context,this);
  getHolder().addCallback(this);
  mTextSize=mData.getTextSize();
  mScaleFactor=1.f;
  mTextPaint=new Paint();
  mTextPaint.setTextSize(mTextSize);
  mTextPaint.setColor(Color.WHITE);
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTypeface(Typeface.DEFAULT_BOLD);
  Paint.FontMetrics metrics=mTextPaint.getFontMetrics();
  float textWidth=mTextPaint.measureText(mData.getText());
  mTextBaseX=(mWidth / 2) - textWidth / 2;
  mTextBaseY=(mHeight / 2) - (metrics.ascent + metrics.descent) / 2;
}","public ComposeView(Context context,ComposeData data){
  super(context);
  mData=data;
  mMoveDetector=new MoveGestureDetector(context,this);
  mScaleDetector=new ScaleGestureDetector(context,this);
  mRotateDetector=new RotateGestureDetector(context,this);
  getHolder().addCallback(this);
  mTextSize=mData.getTextSize();
  mScaleFactor=1.f;
  mTextPaint=new Paint();
  mTextPaint.setTextSize(mTextSize);
  mTextPaint.setColor(Color.WHITE);
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTypeface(Typeface.DEFAULT_BOLD);
}",0.8215962441314554
25417,"private void loadMixes(){
  RandomAccessFile randomAccessFile=null;
  try {
    List<Path> mixFiles=listDirectoryMixes(Paths.get(RESOURCE_FOLDER));
    for (    Path f : mixFiles) {
      randomAccessFile=new RandomAccessFile(f.toString().toLowerCase(),""String_Node_Str"");
      FileChannel inChannel=randomAccessFile.getChannel();
      MixFile mix=new MixFile(f.getFileName().toString(),inChannel);
      mixes.put(mix.getFileName(),mix);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
  }
}","private void loadMixes(){
  RandomAccessFile randomAccessFile=null;
  try {
    List<Path> mixFiles=listDirectoryMixes(Paths.get(RESOURCE_FOLDER));
    for (    Path f : mixFiles) {
      randomAccessFile=new RandomAccessFile(f.toString(),""String_Node_Str"");
      FileChannel inChannel=randomAccessFile.getChannel();
      MixFile mix=new MixFile(f.getFileName().toString(),inChannel);
      mixes.put(mix.getFileName(),mix);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
  }
}",0.9864341085271318
25418,"public PalFile getPaletteByName(String name){
  if (palettes.containsKey(name)) {
    return palettes.get(name);
  }
  try (RandomAccessFile randomAccessFile=new RandomAccessFile(Paths.get(PAL_FOLDER + name).toString().toLowerCase(),""String_Node_Str"")){
    FileChannel inChannel=randomAccessFile.getChannel();
    PalFile palfile=new PalFile(name,inChannel);
    palettes.put(name,palfile);
    return palfile;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
  }
  return null;
}","public PalFile getPaletteByName(String name){
  if (palettes.containsKey(name)) {
    return palettes.get(name);
  }
  try (RandomAccessFile randomAccessFile=new RandomAccessFile(PAL_FOLDER + name.toString().toLowerCase(),""String_Node_Str"")){
    FileChannel inChannel=randomAccessFile.getChannel();
    PalFile palfile=new PalFile(name,inChannel);
    palettes.put(name,palfile);
    return palfile;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
  }
  return null;
}",0.9889447236180904
25419,"public void update(int delta){
  cellX=(int)(-Main.getInstance().getCamera().getOffsetX() + Main.getInstance().getContainer().getInput().getMouseX()) / 24;
  cellY=(int)(-Main.getInstance().getCamera().getOffsetY() + Main.getInstance().getContainer().getInput().getMouseY()) / 24;
  if (!Main.getInstance().getPlayer().getBase().getProductionQueue().canBuild(this.targetBuilding)) {
    resetBuildingMode();
  }
}","public void update(int delta){
  cellX=(int)(-Main.getInstance().getCamera().getOffsetX() + Main.getInstance().getContainer().getInput().getMouseX()) / 24;
  cellY=(int)(-Main.getInstance().getCamera().getOffsetY() + Main.getInstance().getContainer().getInput().getMouseY()) / 24;
  if (this.targetBuilding != null) {
    boolean isBuildingCancelled=!Main.getInstance().getPlayer().getBase().getProductionQueue().getProductionForBuilding(this.targetBuilding).isReady();
    if (isBuildingCancelled || !Main.getInstance().getPlayer().getBase().getProductionQueue().canBuild(this.targetBuilding)) {
      resetBuildingMode();
    }
  }
}",0.7729007633587787
25420,"private void initExternalResources() throws ResourceInitializationException {
  getConfigurationParams(parameters);
  this.rawTextFiles=FileUtils.listRawTextFiles(rawTextFilePath);
  this.restClient=S4ClientBuilder.newClientInstance().withS4Endpoint(serviceEndpoint).withApiKeyId(apiKeyId).withApiPassword(apiPassword).build();
}","private void initExternalResources() throws ResourceInitializationException {
  getConfigurationParams(parameters);
  this.rawTextFiles=FileUtils.listFiles(rawTextFilePath);
  this.restClient=S4ClientBuilder.newClientInstance().withS4Endpoint(serviceEndpoint).withApiKeyId(apiKeyId).withApiPassword(apiPassword).build();
}",0.989247311827957
25421,"/** 
 * Create a collection reader description corresponding to the provided configuration data.
 * @param confData Any configuration data values in the standard UIMAfit format
 * @return a new <code>CollectionReaderDescription</code> instance suitable for using a pipeline directlyor serializing to disk as XML
 * @throws org.apache.uima.resource.ResourceInitializationException
 */
public CollectionReaderDescription createDescription(Object... confData) throws ResourceInitializationException {
  this.parameters=confData;
  initExternalResources();
  final AnnotatedDocument s4Document=fetchS4AnnotatedDocument(rawTextFiles.get(0));
  this.s4CasConverter=new S4DocumentToUimaCasConverter(s4Document);
  s4CasConverter.inferCasTypeSystem(s4Document.entities);
  TypeSystemDescription tsd;
  try {
    tsd=s4CasConverter.getTypeSystemDescription();
  }
 catch (  Exception e) {
    throw new ResourceInitializationException(e);
  }
  return CollectionReaderFactory.createReaderDescription(S4DocumentCollectionReader.class,tsd,parameters);
}","/** 
 * Create a collection reader description corresponding to the provided configuration data.
 * @param confData Any configuration data values in the standard UIMAfit format
 * @return a new <code>CollectionReaderDescription</code> instance suitable for using a pipeline directlyor serializing to disk as XML
 * @throws org.apache.uima.resource.ResourceInitializationException
 */
public CollectionReaderDescription createDescription(Object... confData) throws ResourceInitializationException {
  this.parameters=confData;
  initExternalResources();
  final AnnotatedDocument s4Document=fetchS4AnnotatedDocument(rawTextFiles.get(0));
  this.s4CasConverter=new S4DocumentToUimaCasConverter(s4Document);
  s4CasConverter.inferCasTypeSystem(s4Document.entities.keySet());
  TypeSystemDescription tsd;
  try {
    tsd=s4CasConverter.getTypeSystemDescription();
  }
 catch (  Exception e) {
    throw new ResourceInitializationException(e);
  }
  return CollectionReaderFactory.createReaderDescription(S4DocumentCollectionReader.class,tsd,parameters);
}",0.9956999522216914
25422,"private void transformFetchedDocument(File rawTextFile,CAS... cas){
  final AnnotatedDocument s4Document=fetchS4AnnotatedDocument(rawTextFile);
  this.s4CasConverter=new S4DocumentToUimaCasConverter(s4Document);
  s4CasConverter.convertAnnotations();
  s4CasConverter.setSourceDocumentText();
  cas[0]=s4CasConverter.getConvertedDocument();
}","private void transformFetchedDocument(File rawTextFile,CAS cas){
  final AnnotatedDocument s4Document=fetchS4AnnotatedDocument(rawTextFile);
  this.s4CasConverter=new S4DocumentToUimaCasConverter(s4Document);
  s4CasConverter.convertAnnotations(cas);
  s4CasConverter.setSourceDocumentText(cas);
}",0.9107981220657276
25423,"@Override public void convertAnnotations(){
  Map<String,List<Annotation>> entities=this.startDocument.entities;
  int featureStructureArrayIndex=0;
  inferCasTypeSystem(entities);
  try {
    this.endDocument=CasCreationUtils.createCas(tsd,null,null);
  }
 catch (  ResourceInitializationException e) {
    e.printStackTrace();
  }
  TypeSystem typeSystem=endDocument.getTypeSystem();
  this.featureStructureArrayCapacity=entities.size();
  this.annotationFeatureStructures=endDocument.createArrayFS(featureStructureArrayCapacity);
  for (  Map.Entry<String,List<Annotation>> entityEntry : entities.entrySet()) {
    String annotationName=entityEntry.getKey();
    annotationName=removeDashes(annotationName);
    List<Annotation> annotations=entityEntry.getValue();
    for (    Annotation ann : annotations) {
      Type type=typeSystem.getType(annotationName);
      LOG.info(""String_Node_Str"" + type);
      AnnotationFS afs=endDocument.createAnnotation(type,(int)ann.startOffset,(int)ann.endOffset);
      endDocument.addFsToIndexes(afs);
      if (featureStructureArrayIndex + 1 == featureStructureArrayCapacity) {
        resizeArrayFS(featureStructureArrayCapacity * 2,annotationFeatureStructures);
      }
      annotationFeatureStructures.set(featureStructureArrayIndex++,afs);
    }
  }
  endDocument.addFsToIndexes(annotationFeatureStructures);
}","@Override public void convertAnnotations(CAS cas){
  Map<String,List<Annotation>> entities=this.startDocument.entities;
  int featureStructureArrayIndex=0;
  inferCasTypeSystem(entities.keySet());
  try {
    LOG.info(""String_Node_Str"");
    cas=CasCreationUtils.createCas(tsd,null,null);
  }
 catch (  ResourceInitializationException e) {
    LOG.info(""String_Node_Str"",e);
  }
  TypeSystem typeSystem=cas.getTypeSystem();
  this.featureStructureArrayCapacity=entities.size();
  this.annotationFeatureStructures=cas.createArrayFS(featureStructureArrayCapacity);
  for (  Map.Entry<String,List<Annotation>> entityEntry : entities.entrySet()) {
    String annotationName=entityEntry.getKey();
    annotationName=removeDashes(annotationName);
    Type type=typeSystem.getType(annotationName);
    List<Annotation> annotations=entityEntry.getValue();
    LOG.info(""String_Node_Str"" + type);
    for (    Annotation ann : annotations) {
      AnnotationFS afs=cas.createAnnotation(type,(int)ann.startOffset,(int)ann.endOffset);
      cas.addFsToIndexes(afs);
      if (featureStructureArrayIndex + 1 == featureStructureArrayCapacity) {
        resizeArrayFS(featureStructureArrayCapacity * 2,annotationFeatureStructures,cas);
      }
      annotationFeatureStructures.set(featureStructureArrayIndex++,afs);
    }
  }
  cas.addFsToIndexes(annotationFeatureStructures);
}",0.8502202643171806
25424,"private void resizeArrayFS(int newCapacity,ArrayFS originalArray){
  ArrayFS biggerArrayFS=endDocument.createArrayFS(newCapacity);
  biggerArrayFS.copyFromArray(originalArray.toArray(),0,0,originalArray.size());
  this.annotationFeatureStructures=biggerArrayFS;
  this.featureStructureArrayCapacity=annotationFeatureStructures.size();
}","private void resizeArrayFS(int newCapacity,ArrayFS originalArray,CAS cas){
  ArrayFS biggerArrayFS=cas.createArrayFS(newCapacity);
  biggerArrayFS.copyFromArray(originalArray.toArray(),0,0,originalArray.size());
  this.annotationFeatureStructures=biggerArrayFS;
  this.featureStructureArrayCapacity=annotationFeatureStructures.size();
}",0.9672619047619048
25425,"public void inferCasTypeSystem(Map<String,List<Annotation>> entities){
  for (  String typeName : entities.keySet()) {
    typeName=removeDashes(typeName);
    tsd.addType(typeName,""String_Node_Str"" + typeName,""String_Node_Str"");
    LOG.info(""String_Node_Str"" + typeName);
  }
}","@Override public void inferCasTypeSystem(Iterable<String> originalTypes){
  for (  String typeName : originalTypes) {
    typeName=removeDashes(typeName);
    tsd.addType(typeName,""String_Node_Str"" + typeName,""String_Node_Str"");
    LOG.info(""String_Node_Str"" + typeName);
  }
}",0.8438061041292639
25426,"/** 
 * Removes dashes from UIMA Annotations because they are not allowed to contain dashes.
 * @param typeName
 * @return
 */
private String removeDashes(String typeName){
  if (typeName.contains(""String_Node_Str"")) {
    typeName=typeName.replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  return typeName;
}","/** 
 * Removes dashes from UIMA Annotations because they are not allowed to contain dashes.
 * @param typeName the annotation name of the current annotation of the source document
 * @return the transformed annotation name suited for the UIMA typesystem
 */
private String removeDashes(String typeName){
  if (typeName.contains(""String_Node_Str"")) {
    typeName=typeName.replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  return typeName;
}",0.8263157894736842
25427,"@Override public void setSourceDocumentText(){
  endDocument.setSofaDataString(startDocument.text,""String_Node_Str"");
}","@Override public void setSourceDocumentText(CAS cas){
  cas.setSofaDataString(startDocument.text,""String_Node_Str"");
}",0.919831223628692
25428,void convertAnnotations();,"/** 
 * Operation responsible for converting the custom annotations into native UIMA datastructures. .
 * @param cas the CAS object to be populated
 */
void convertAnnotations(CAS cas);",0.2464454976303317
25429,void setSourceDocumentText();,"/** 
 * Operation responsible for setting the document's raw text to the CAS objects.
 * @param cas the CAS object to be populated
 */
void setSourceDocumentText(CAS cas);",0.29
25430,"/** 
 * Send a request with embedded plain text document, Request output as GATE JSON and use the defauls set of annotation selectors.
 */
private static void processInlineDocument(){
  ProcessingRequest pr=new ProcessingRequest();
  pr.setDocument(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  pr.setMimeType(""String_Node_Str"");
  processRequest(pr,GATE_JSON);
}","/** 
 * Send a request with embedded plain text document, Request output as GATE JSON and use the defauls set of annotation selectors.
 */
private static void processInlineDocument(){
  ProcessingRequest pr=new ProcessingRequest();
  pr.setDocument(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  pr.setDocumentType(""String_Node_Str"");
  processRequest(pr,GATE_JSON);
}",0.994160583941606
25431,"/** 
 * Process a tweet as an embedded document Request output as GATE JSON and set some custom annotation selectors
 */
private static void processTweet(){
  ProcessingRequest pr=new ProcessingRequest();
  pr.setDocument(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  pr.setMimeType(""String_Node_Str"");
  pr.setAnnotationSelectors(new String[]{""String_Node_Str"",""String_Node_Str""});
  processRequest(pr,GATE_JSON);
}","/** 
 * Process a tweet as an embedded document Request output as GATE JSON and set some custom annotation selectors
 */
private static void processTweet(){
  ProcessingRequest pr=new ProcessingRequest();
  pr.setDocument(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  pr.setDocumentType(""String_Node_Str"");
  pr.setAnnotationSelectors(new String[]{""String_Node_Str"",""String_Node_Str""});
  processRequest(pr,GATE_JSON);
}",0.3315440479949479
25432,"/** 
 * Process an HTML document by supplying its publicly accessible URL Request output as GATE XML and use the default set of annotation selectors.
 */
private static void processRemoteDocument(){
  ProcessingRequest pr=new ProcessingRequest();
  pr.setDocumentUrl(""String_Node_Str"");
  pr.setMimeType(""String_Node_Str"");
  processRequest(pr,GATE_XML);
}","/** 
 * Process an HTML document by supplying its publicly accessible URL Request output as GATE XML and use the default set of annotation selectors.
 */
private static void processRemoteDocument(){
  ProcessingRequest pr=new ProcessingRequest();
  pr.setDocumentUrl(""String_Node_Str"");
  pr.setDocumentType(""String_Node_Str"");
  processRequest(pr,GATE_XML);
}",0.9832402234636872
25433,"/** 
 * Serialize a ProcessingRequest and send it to Self Service Semantic Suite Online Processing Service
 * @param pr the processing request to send
 * @param acceptType the type of output we want to produce
 */
private static void processRequest(ProcessingRequest pr,String acceptType){
  HttpPost post=new HttpPost(endpointUrl + shopItemId);
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  post.setHeader(""String_Node_Str"",acceptType);
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  String message=null;
  try {
    message=pr.toJSON();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  System.out.println(""String_Node_Str"");
  System.out.println(message);
  post.setEntity(new StringEntity(message,Charset.forName(""String_Node_Str"")));
  CloseableHttpResponse response=null;
  try {
    response=httpClient.execute(post,ctx);
    StatusLine sl=response.getStatusLine();
    int statusCode=sl.getStatusCode();
switch (statusCode) {
case 200:
{
        System.out.println(""String_Node_Str"");
        System.out.println(response.toString());
        System.out.println(getContent(response));
        break;
      }
case 400:
{
      System.out.println(""String_Node_Str"");
      System.out.println(response.toString());
      System.out.println(getContent(response));
      break;
    }
case 403:
{
    System.out.println(""String_Node_Str"");
    System.out.println(response.toString());
    System.out.println(getContent(response));
    break;
  }
case 404:
{
  System.out.println(""String_Node_Str"");
  System.out.println(response.toString());
  System.out.println(getContent(response));
  break;
}
case 406:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
case 408:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
case 415:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
case 500:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
default :
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
}
}
 catch (ClientProtocolException e) {
e.printStackTrace();
}
catch (IOException e) {
e.printStackTrace();
}
 finally {
try {
response.close();
}
 catch (IOException e) {
}
}
}","/** 
 * Serialize a ProcessingRequest and send it to Self Service Semantic Suite Online Processing Service
 * @param pr the processing request to send
 * @param acceptType the type of output we want to produce
 */
private static void processRequest(ProcessingRequest pr,String acceptType){
  HttpPost post=new HttpPost(endpointUrl + serviceId);
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  post.setHeader(""String_Node_Str"",acceptType);
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  String message=null;
  try {
    message=pr.toJSON();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  System.out.println(""String_Node_Str"");
  System.out.println(message);
  post.setEntity(new StringEntity(message,Charset.forName(""String_Node_Str"")));
  CloseableHttpResponse response=null;
  try {
    response=httpClient.execute(post,ctx);
    StatusLine sl=response.getStatusLine();
    int statusCode=sl.getStatusCode();
switch (statusCode) {
case 200:
{
        System.out.println(""String_Node_Str"");
        System.out.println(response.toString());
        System.out.println(getContent(response));
        break;
      }
case 400:
{
      System.out.println(""String_Node_Str"");
      System.out.println(response.toString());
      System.out.println(getContent(response));
      break;
    }
case 403:
{
    System.out.println(""String_Node_Str"");
    System.out.println(response.toString());
    System.out.println(getContent(response));
    break;
  }
case 404:
{
  System.out.println(""String_Node_Str"");
  System.out.println(response.toString());
  System.out.println(getContent(response));
  break;
}
case 406:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
case 408:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
case 415:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
case 500:
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
default :
{
System.out.println(""String_Node_Str"");
System.out.println(response.toString());
System.out.println(getContent(response));
break;
}
}
}
 catch (ClientProtocolException e) {
e.printStackTrace();
}
catch (IOException e) {
e.printStackTrace();
}
 finally {
try {
response.close();
}
 catch (IOException e) {
}
}
}",0.9974791545472174
25434,"/** 
 * Construct a request for the online service to annotate a document it downloads directly from a remote URL.
 * @param documentUrl the URL from which the document should bedownloaded. This must be accessible to the service so it must not require authentication credentials etc. (but it may be, for example, a pre-signed Amazon S3 URL).
 * @param type the MIME type that the service should use to parse thedocument.
 * @param annotationSelectors annotations to return. Leave as<code>null</code> to use the default selectors recommended by the pipeline provider.
 */
public OnlineServiceRequest(URL documentUrl,SupportedMimeType type,List<AnnotationSelector> annotationSelectors){
  this.documentUrl=documentUrl.toString();
  this.mimeType=type.value;
  if (annotationSelectors != null) {
    this.annotationSelectors=new LinkedList<String>();
    for (    AnnotationSelector as : annotationSelectors) {
      this.annotationSelectors.add(as.toString());
    }
  }
}","/** 
 * Construct a request for the online service to annotate a document it downloads directly from a remote URL.
 * @param documentUrl the URL from which the document should bedownloaded. This must be accessible to the service so it must not require authentication credentials etc. (but it may be, for example, a pre-signed Amazon S3 URL).
 * @param type the MIME type that the service should use to parse thedocument.
 * @param annotationSelectors annotations to return. Leave as<code>null</code> to use the default selectors recommended by the pipeline provider.
 */
public OnlineServiceRequest(URL documentUrl,SupportedMimeType type,List<AnnotationSelector> annotationSelectors){
  this.documentUrl=documentUrl.toString();
  this.documentType=type.value;
  if (annotationSelectors != null) {
    this.annotationSelectors=new LinkedList<String>();
    for (    AnnotationSelector as : annotationSelectors) {
      this.annotationSelectors.add(as.toString());
    }
  }
}",0.9938271604938272
25435,"void Otsu(ImagePlus imp,int radius,double par1,double par2,boolean doIwhite){
  int[] data;
  int w=imp.getWidth();
  int h=imp.getHeight();
  int position;
  int radiusx2=radius * 2;
  ImageProcessor ip=imp.getProcessor();
  byte[] pixels=(byte[])ip.getPixels();
  byte[] pixelsOut=new byte[pixels.length];
  byte object;
  byte backg;
  if (doIwhite) {
    object=(byte)0xff;
    backg=(byte)0;
  }
 else {
    object=(byte)0;
    backg=(byte)0xff;
  }
  int k, kStar;
  int N1, N;
  double BCV, BCVmax;
  double num, denom;
  int Sk;
  int S, L=256;
  int roiy;
  Roi roi=new OvalRoi(0,0,radiusx2,radiusx2);
  for (int y=0; y < h; y++) {
    IJ.showProgress((double)(y) / (h - 1));
    roiy=y - radius;
    for (int x=0; x < w; x++) {
      roi.setLocation(x - radius,roiy);
      ip.setRoi(roi);
      position=x + y * w;
      data=ip.getHistogram();
      S=N=0;
      for (k=0; k < L; k++) {
        S+=k * data[k];
        N+=data[k];
      }
      Sk=0;
      N1=data[0];
      BCV=0;
      BCVmax=0;
      kStar=0;
      for (k=1; k < L - 1; k++) {
        Sk+=k * data[k];
        N1+=data[k];
        denom=(double)(N1) * (N - N1);
        if (denom != 0) {
          num=((double)N1 / N) * S - Sk;
          BCV=(num * num) / denom;
        }
 else         BCV=0;
        if (BCV >= BCVmax) {
          BCVmax=BCV;
          kStar=k;
        }
      }
      pixelsOut[position]=((int)(pixels[position] & 0xff) > kStar) ? object : backg;
    }
  }
  for (position=0; position < w * h; position++)   pixels[position]=pixelsOut[position];
}","void Otsu(ImagePlus imp,int radius,double par1,double par2,boolean doIwhite){
  int[] data;
  int w=imp.getWidth();
  int h=imp.getHeight();
  int position;
  int radiusx2=radius * 2;
  ImageProcessor ip=imp.getProcessor();
  byte[] pixels=(byte[])ip.getPixels();
  byte[] pixelsOut=new byte[pixels.length];
  byte object;
  byte backg;
  if (doIwhite) {
    object=(byte)0xff;
    backg=(byte)0;
  }
 else {
    object=(byte)0;
    backg=(byte)0xff;
  }
  int ih, roiy, L=256;
  int threshold;
  int num_pixels;
  double total_mean;
  double bcv, term;
  double max_bcv;
  double[] cnh=new double[L];
  double[] mean=new double[L];
  double[] histo=new double[L];
  Roi roi=new OvalRoi(0,0,radiusx2,radiusx2);
  for (int y=0; y < h; y++) {
    IJ.showProgress((double)(y) / (h - 1));
    roiy=y - radius;
    for (int x=0; x < w; x++) {
      roi.setLocation(x - radius,roiy);
      ip.setRoi(roi);
      position=x + y * w;
      data=ip.getHistogram();
      num_pixels=0;
      for (ih=0; ih < L; ih++)       num_pixels=num_pixels + data[ih];
      term=1.0 / (double)num_pixels;
      for (ih=0; ih < L; ih++) {
        histo[ih]=term * data[ih];
      }
      cnh[0]=histo[0];
      for (ih=1; ih < L; ih++) {
        cnh[ih]=cnh[ih - 1] + histo[ih];
      }
      mean[0]=0.0;
      for (ih=0 + 1; ih < L; ih++) {
        mean[ih]=mean[ih - 1] + ih * histo[ih];
      }
      total_mean=mean[L - 1];
      threshold=Integer.MIN_VALUE;
      max_bcv=0.0;
      for (ih=0; ih < L; ih++) {
        bcv=total_mean * cnh[ih] - mean[ih];
        bcv*=bcv / (cnh[ih] * (1.0 - cnh[ih]));
        if (max_bcv < bcv) {
          max_bcv=bcv;
          threshold=ih;
        }
      }
      pixelsOut[position]=((int)(pixels[position] & 0xff) > threshold) ? object : backg;
    }
  }
  for (position=0; position < w * h; position++)   pixels[position]=pixelsOut[position];
}",0.6035087719298246
25436,"/** 
 * Ask for parameters and then execute.
 */
public void run(String arg){
  ImagePlus imp=IJ.getImage();
  if (null == imp) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  if (imp.getBitDepth() != 8) {
    IJ.showMessage(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  GenericDialog gd=new GenericDialog(""String_Node_Str"");
  String[] methods={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final Package p=getClass().getPackage();
  final String version=p == null ? null : p.getImplementationVersion();
  final String versionSuffix=version == null ? ""String_Node_Str"" : ""String_Node_Str"" + version;
  gd.addMessage(""String_Node_Str"" + versionSuffix);
  gd.addChoice(""String_Node_Str"",methods,methods[0]);
  gd.addNumericField(""String_Node_Str"",15,0);
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",0,0);
  gd.addNumericField(""String_Node_Str"",0,0);
  gd.addCheckbox(""String_Node_Str"",true);
  if (imp.getStackSize() > 1) {
    gd.addCheckbox(""String_Node_Str"",false);
  }
  gd.addMessage(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return;
  String myMethod=gd.getNextChoice();
  int radius=(int)gd.getNextNumber();
  double par1=(double)gd.getNextNumber();
  double par2=(double)gd.getNextNumber();
  boolean doIwhite=gd.getNextBoolean();
  boolean doIstack=false;
  int stackSize=imp.getStackSize();
  if (stackSize > 1)   doIstack=gd.getNextBoolean();
  if (myMethod.equals(""String_Node_Str"")) {
    ImageProcessor ip=imp.getProcessor();
    int xe=ip.getWidth();
    int ye=ip.getHeight();
    int ml=methods.length;
    ImagePlus imp2, imp3;
    ImageStack tstack=null, stackNew;
    if (stackSize > 1 && doIstack) {
      boolean doItAnyway=true;
      if (stackSize > 25) {
        YesNoCancelDialog d=new YesNoCancelDialog(IJ.getInstance(),""String_Node_Str"",""String_Node_Str"" + stackSize + ""String_Node_Str"");
        if (!d.yesPressed()) {
          doItAnyway=false;
        }
        if (d.cancelPressed())         return;
      }
      for (int j=1; j <= stackSize; j++) {
        imp.setSlice(j);
        ip=imp.getProcessor();
        tstack=new ImageStack(xe,ye);
        for (int k=1; k < ml; k++)         tstack.addSlice(methods[k],ip.duplicate());
        imp2=new ImagePlus(""String_Node_Str"",tstack);
        imp2.updateAndDraw();
        for (int k=1; k < ml; k++) {
          imp2.setSlice(k);
          Object[] result=exec(imp2,methods[k],radius,par1,par2,doIwhite);
        }
        CanvasResizer cr=new CanvasResizer();
        stackNew=cr.expandStack(tstack,(xe + 2),(ye + 18),1,1);
        imp3=new ImagePlus(""String_Node_Str"",stackNew);
        imp3.updateAndDraw();
        MontageMaker mm=new MontageMaker();
        mm.makeMontage(imp3,3,3,1.0,1,(ml - 1),1,0,true);
      }
      imp.setSlice(1);
      IJ.run(""String_Node_Str"",""String_Node_Str"");
      return;
    }
 else {
      tstack=new ImageStack(xe,ye);
      for (int k=1; k < ml; k++)       tstack.addSlice(methods[k],ip.duplicate());
      imp2=new ImagePlus(""String_Node_Str"",tstack);
      imp2.updateAndDraw();
      for (int k=1; k < ml; k++) {
        imp2.setSlice(k);
        Object[] result=exec(imp2,methods[k],radius,par1,par2,doIwhite);
      }
      CanvasResizer cr=new CanvasResizer();
      stackNew=cr.expandStack(tstack,(xe + 2),(ye + 18),1,1);
      imp3=new ImagePlus(""String_Node_Str"",stackNew);
      imp3.updateAndDraw();
      MontageMaker mm=new MontageMaker();
      mm.makeMontage(imp3,3,3,1.0,1,(ml - 1),1,0,true);
      return;
    }
  }
 else {
    if (stackSize > 1 && doIstack) {
      for (int k=1; k <= stackSize; k++) {
        imp.setSlice(k);
        Object[] result=exec(imp,myMethod,radius,par1,par2,doIwhite);
      }
      imp.setSlice(1);
    }
 else {
      Object[] result=exec(imp,myMethod,radius,par1,par2,doIwhite);
    }
  }
}","/** 
 * Ask for parameters and then execute.
 */
public void run(String arg){
  ImagePlus imp=IJ.getImage();
  if (null == imp) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  if (imp.getBitDepth() != 8) {
    IJ.showMessage(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  GenericDialog gd=new GenericDialog(""String_Node_Str"");
  String[] methods={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  gd.addMessage(""String_Node_Str"");
  gd.addChoice(""String_Node_Str"",methods,methods[0]);
  gd.addNumericField(""String_Node_Str"",15,0);
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",0,0);
  gd.addNumericField(""String_Node_Str"",0,0);
  gd.addCheckbox(""String_Node_Str"",true);
  if (imp.getStackSize() > 1) {
    gd.addCheckbox(""String_Node_Str"",false);
  }
  gd.addMessage(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return;
  String myMethod=gd.getNextChoice();
  int radius=(int)gd.getNextNumber();
  double par1=(double)gd.getNextNumber();
  double par2=(double)gd.getNextNumber();
  boolean doIwhite=gd.getNextBoolean();
  boolean doIstack=false;
  int stackSize=imp.getStackSize();
  if (stackSize > 1)   doIstack=gd.getNextBoolean();
  if (myMethod.equals(""String_Node_Str"")) {
    ImageProcessor ip=imp.getProcessor();
    int xe=ip.getWidth();
    int ye=ip.getHeight();
    int ml=methods.length;
    ImagePlus imp2, imp3;
    ImageStack tstack=null, stackNew;
    if (stackSize > 1 && doIstack) {
      boolean doItAnyway=true;
      if (stackSize > 25) {
        YesNoCancelDialog d=new YesNoCancelDialog(IJ.getInstance(),""String_Node_Str"",""String_Node_Str"" + stackSize + ""String_Node_Str"");
        if (!d.yesPressed()) {
          doItAnyway=false;
        }
        if (d.cancelPressed())         return;
      }
      for (int j=1; j <= stackSize; j++) {
        imp.setSlice(j);
        ip=imp.getProcessor();
        tstack=new ImageStack(xe,ye);
        for (int k=1; k < ml; k++)         tstack.addSlice(methods[k],ip.duplicate());
        imp2=new ImagePlus(""String_Node_Str"",tstack);
        imp2.updateAndDraw();
        for (int k=1; k < ml; k++) {
          imp2.setSlice(k);
          Object[] result=exec(imp2,methods[k],radius,par1,par2,doIwhite);
        }
        CanvasResizer cr=new CanvasResizer();
        stackNew=cr.expandStack(tstack,(xe + 2),(ye + 18),1,1);
        imp3=new ImagePlus(""String_Node_Str"",stackNew);
        imp3.updateAndDraw();
        MontageMaker mm=new MontageMaker();
        mm.makeMontage(imp3,3,3,1.0,1,(ml - 1),1,0,true);
      }
      imp.setSlice(1);
      IJ.run(""String_Node_Str"",""String_Node_Str"");
      return;
    }
 else {
      tstack=new ImageStack(xe,ye);
      for (int k=1; k < ml; k++)       tstack.addSlice(methods[k],ip.duplicate());
      imp2=new ImagePlus(""String_Node_Str"",tstack);
      imp2.updateAndDraw();
      for (int k=1; k < ml; k++) {
        imp2.setSlice(k);
        Object[] result=exec(imp2,methods[k],radius,par1,par2,doIwhite);
      }
      CanvasResizer cr=new CanvasResizer();
      stackNew=cr.expandStack(tstack,(xe + 2),(ye + 18),1,1);
      imp3=new ImagePlus(""String_Node_Str"",stackNew);
      imp3.updateAndDraw();
      MontageMaker mm=new MontageMaker();
      mm.makeMontage(imp3,3,3,1.0,1,(ml - 1),1,0,true);
      return;
    }
  }
 else {
    if (stackSize > 1 && doIstack) {
      for (int k=1; k <= stackSize; k++) {
        imp.setSlice(k);
        Object[] result=exec(imp,myMethod,radius,par1,par2,doIwhite);
      }
      imp.setSlice(1);
    }
 else {
      Object[] result=exec(imp,myMethod,radius,par1,par2,doIwhite);
    }
  }
}",0.9706148867313916
25437,"public static int Minimum(int[] data){
  if (data.length < 2)   return 0;
  int iter=0;
  int threshold=-1;
  int max=-1;
  double[] iHisto=new double[data.length];
  for (int i=0; i < data.length; i++) {
    iHisto[i]=(double)data[i];
    if (data[i] > 0)     max=i;
  }
  double[] tHisto=iHisto;
  while (!bimodalTest(iHisto)) {
    for (int i=1; i < data.length - 1; i++)     tHisto[i]=(iHisto[i - 1] + iHisto[i] + iHisto[i + 1]) / 3;
    tHisto[0]=(iHisto[0] + iHisto[1]) / 3;
    tHisto[data.length - 1]=(iHisto[data.length - 2] + iHisto[data.length - 1]) / 3;
    iHisto=tHisto;
    iter++;
    if (iter > 10000) {
      threshold=-1;
      IJ.log(""String_Node_Str"");
      return threshold;
    }
  }
  for (int i=1; i < max; i++) {
    if (iHisto[i - 1] > iHisto[i] && iHisto[i + 1] >= iHisto[i]) {
      threshold=i;
      break;
    }
  }
  return threshold;
}","public static int Minimum(int[] data){
  if (data.length < 2)   return 0;
  int iter=0;
  int threshold=-1;
  int max=-1;
  double[] iHisto=new double[data.length];
  for (int i=0; i < data.length; i++) {
    iHisto[i]=(double)data[i];
    if (data[i] > 0)     max=i;
  }
  double[] tHisto=new double[iHisto.length];
  while (!bimodalTest(iHisto)) {
    for (int i=1; i < data.length - 1; i++)     tHisto[i]=(iHisto[i - 1] + iHisto[i] + iHisto[i + 1]) / 3;
    tHisto[0]=(iHisto[0] + iHisto[1]) / 3;
    tHisto[data.length - 1]=(iHisto[data.length - 2] + iHisto[data.length - 1]) / 3;
    System.arraycopy(tHisto,0,iHisto,0,iHisto.length);
    iter++;
    if (iter > 10000) {
      threshold=-1;
      IJ.log(""String_Node_Str"");
      return threshold;
    }
  }
  for (int i=1; i < max; i++) {
    if (iHisto[i - 1] > iHisto[i] && iHisto[i + 1] >= iHisto[i]) {
      threshold=i;
      break;
    }
  }
  return threshold;
}",0.9481894150417828
25438,"public boolean getInstallDefaultDrop(){
  return this.flush_on_connect;
}","public boolean getInstallDefaultDrop(){
  return this.install_default_drop;
}",0.8133333333333334
25439,"@Override public void switchRemoved(long switchId){
  logger.debug(""String_Node_Str"");
  List<Proxy> proxies=controllerConnector.getSwitchProxies(switchId);
  Iterator<Proxy> it=proxies.iterator();
  Iterator<IOFSwitch> switchIt=this.switches.iterator();
  while (switchIt.hasNext()) {
    IOFSwitch tmpSwitch=switchIt.next();
    if (tmpSwitch.getId() == switchId) {
      switchIt.remove();
    }
  }
  this.statsCacher.clearCache(switchId);
  while (it.hasNext()) {
    Proxy p=it.next();
    p.disconnect();
    it.remove();
  }
}","@Override public void switchRemoved(long switchId){
  logger.debug(""String_Node_Str"");
  Iterator<IOFSwitch> switchIt=this.switches.iterator();
  while (switchIt.hasNext()) {
    IOFSwitch tmpSwitch=switchIt.next();
    if (tmpSwitch.getId() == switchId) {
      switchIt.remove();
    }
  }
  this.statsCacher.clearCache(switchId);
  List<Proxy> proxies=controllerConnector.getSwitchProxies(switchId);
  if (proxies != null) {
    Iterator<Proxy> it=proxies.iterator();
    while (it.hasNext()) {
      Proxy p=it.next();
      p.disconnect();
      it.remove();
    }
  }
}",0.4292155094679892
25440,"@Get(""String_Node_Str"") public HashMap<String,Object> getSliceStatus(){
  IFlowSpaceFirewallService iFSFs=(IFlowSpaceFirewallService)getContext().getAttributes().get(IFlowSpaceFirewallService.class.getCanonicalName());
  String dpidStr=(String)getRequestAttributes().get(""String_Node_Str"");
  Long dpid=HexString.toLong(dpidStr);
  String sliceStr=(String)getRequestAttributes().get(""String_Node_Str"");
  List<Proxy> proxies=iFSFs.getSwitchProxies(dpid);
  HashMap<String,Object> results=new HashMap<String,Object>();
  if (proxies == null) {
    logger.info(""String_Node_Str"" + dpidStr + ""String_Node_Str"");
    HashMap<Long,Slicer> slice=iFSFs.getSlice(sliceStr);
    if (slice == null) {
      results.put(""String_Node_Str"",""String_Node_Str"" + sliceStr);
      return results;
    }
    if (!slice.containsKey(dpid)) {
      logger.warn(""String_Node_Str"" + dpidStr + ""String_Node_Str""+ sliceStr);
      results.put(""String_Node_Str"",""String_Node_Str"" + dpidStr + ""String_Node_Str""+ sliceStr);
      return results;
    }
    Slicer mySlice=slice.get(dpid);
    results.put(""String_Node_Str"",""String_Node_Str"");
    results.put(""String_Node_Str"",0);
    results.put(""String_Node_Str"",mySlice.getMaxFlows());
    results.put(""String_Node_Str"",false);
    results.put(""String_Node_Str"",dpidStr);
    results.put(""String_Node_Str"",mySlice.getPacketInRate());
    results.put(""String_Node_Str"",0);
  }
  Iterator<Proxy> it=proxies.iterator();
  Proxy myProxy=null;
  while (it.hasNext()) {
    Proxy p=it.next();
    if (p.getSlicer().getSliceName().equals(sliceStr)) {
      myProxy=p;
    }
  }
  if (myProxy == null) {
    logger.warn(""String_Node_Str"" + sliceStr + ""String_Node_Str""+ dpidStr);
    results.put(""String_Node_Str"",""String_Node_Str"" + dpidStr + ""String_Node_Str""+ sliceStr);
    return results;
  }
  results.put(""String_Node_Str"",myProxy.getSlicer().getRate());
  results.put(""String_Node_Str"",myProxy.getFlowCount());
  results.put(""String_Node_Str"",myProxy.getSlicer().getMaxFlows());
  results.put(""String_Node_Str"",myProxy.connected());
  results.put(""String_Node_Str"",myProxy.getSwitch().getStringId());
  results.put(""String_Node_Str"",myProxy.getSlicer().getPacketInRate());
  results.put(""String_Node_Str"",myProxy.getPacketInRate());
  results.put(""String_Node_Str"",myProxy.getSlicer().getMaxFlowRate());
  return results;
}","@Get(""String_Node_Str"") public HashMap<String,Object> getSliceStatus(){
  IFlowSpaceFirewallService iFSFs=(IFlowSpaceFirewallService)getContext().getAttributes().get(IFlowSpaceFirewallService.class.getCanonicalName());
  String dpidStr=(String)getRequestAttributes().get(""String_Node_Str"");
  Long dpid=HexString.toLong(dpidStr);
  String sliceStr=(String)getRequestAttributes().get(""String_Node_Str"");
  List<Proxy> proxies=iFSFs.getSwitchProxies(dpid);
  HashMap<String,Object> results=new HashMap<String,Object>();
  if (proxies == null) {
    logger.info(""String_Node_Str"" + dpidStr + ""String_Node_Str"");
    HashMap<Long,Slicer> slice=iFSFs.getSlice(sliceStr);
    if (slice == null) {
      results.put(""String_Node_Str"",""String_Node_Str"" + sliceStr);
      return results;
    }
    if (!slice.containsKey(dpid)) {
      logger.warn(""String_Node_Str"" + dpidStr + ""String_Node_Str""+ sliceStr);
      results.put(""String_Node_Str"",""String_Node_Str"" + dpidStr + ""String_Node_Str""+ sliceStr);
      return results;
    }
    Slicer mySlice=slice.get(dpid);
    results.put(""String_Node_Str"",""String_Node_Str"");
    results.put(""String_Node_Str"",0);
    results.put(""String_Node_Str"",mySlice.getMaxFlows());
    results.put(""String_Node_Str"",false);
    results.put(""String_Node_Str"",dpidStr);
    results.put(""String_Node_Str"",mySlice.getPacketInRate());
    results.put(""String_Node_Str"",0);
  }
  Iterator<Proxy> it=proxies.iterator();
  Proxy myProxy=null;
  while (it.hasNext()) {
    Proxy p=it.next();
    if (p.getSlicer().getSliceName().equals(sliceStr)) {
      myProxy=p;
    }
  }
  if (myProxy == null) {
    logger.warn(""String_Node_Str"" + sliceStr + ""String_Node_Str""+ dpidStr);
    results.put(""String_Node_Str"",""String_Node_Str"" + dpidStr + ""String_Node_Str""+ sliceStr);
    return results;
  }
  results.put(""String_Node_Str"",myProxy.getSlicer().getRate());
  results.put(""String_Node_Str"",myProxy.getFlowCount());
  results.put(""String_Node_Str"",myProxy.getSlicer().getMaxFlowRate());
  results.put(""String_Node_Str"",myProxy.connected());
  results.put(""String_Node_Str"",myProxy.getSwitch().getStringId());
  results.put(""String_Node_Str"",myProxy.getSlicer().getPacketInRate());
  results.put(""String_Node_Str"",myProxy.getPacketInRate());
  results.put(""String_Node_Str"",myProxy.getSlicer().getMaxFlows());
  return results;
}",0.9978696207925012
25441,"/** 
 * handle messages from the switch and verify they should be a part of this slice if not just return
 * @param msg
 * @param cntx
 */
public void toController(OFMessage msg,FloodlightContext cntx){
  if (ofcch == null) {
    return;
  }
  log.debug(""String_Node_Str"" + msg.getType());
  int xid=msg.getXid();
switch (msg.getType()) {
case PACKET_IN:
    OFPacketIn pcktIn=(OFPacketIn)msg;
  OFMatch match=new OFMatch();
if (pcktIn.getPacketData().length <= 0) {
  log.debug(""String_Node_Str"");
  return;
}
match.loadFromPacket(pcktIn.getPacketData(),pcktIn.getInPort());
OFFlowMod flowMod=new OFFlowMod();
flowMod.setMatch(match);
List<OFFlowMod> allowed=this.mySlicer.allowedFlows(flowMod);
if (allowed.size() == 0) {
log.debug(""String_Node_Str"" + this.mySlicer.getSliceName());
return;
}
if (this.packetInRate.okToProcess()) {
this.mySlicer.addBufferId(pcktIn.getBufferId(),pcktIn.getPacketData());
if (this.mySlicer.getTagManagement()) {
log.debug(""String_Node_Str"");
Ethernet newPkt=new Ethernet();
byte[] pktData=pcktIn.getPacketData();
newPkt.deserialize(pktData,0,pktData.length);
newPkt.setEtherType(newPkt.getEtherType());
newPkt.setVlanID(Ethernet.VLAN_UNTAGGED);
byte[] newPktData=newPkt.serialize();
pcktIn.setPacketData(newPktData);
pcktIn.setTotalLength((short)newPktData.length);
}
break;
}
 else {
log.warn(""String_Node_Str"" + this.getSlicer().getSliceName() + ""String_Node_Str""+ this.getSlicer().getSwitchName()+ ""String_Node_Str"");
this.setAdminStatus(false);
return;
}
case PORT_STATUS:
OFPortStatus portStatus=(OFPortStatus)msg;
OFPhysicalPort port=portStatus.getDesc();
if (!this.mySlicer.isPortPartOfSlice(port.getName())) {
log.debug(""String_Node_Str"" + this.getSlicer().getSwitchName() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ this.mySlicer.getSliceName());
return;
}
switch (OFPortReason.fromReasonCode(portStatus.getReason())) {
case OFPPR_ADD:
this.mySlicer.setPortId(port.getName(),port.getPortNumber());
break;
case OFPPR_MODIFY:
break;
case OFPPR_DELETE:
break;
}
break;
case ERROR:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.remove(xid);
OFError error=(OFError)msg;
OFMessage error_msg=null;
try {
error_msg=error.getOffendingMsg();
}
 catch (MessageParseException e) {
log.error(""String_Node_Str"");
break;
}
if (error_msg == null) {
break;
}
switch (error_msg.getType()) {
case FLOW_MOD:
OFFlowMod mod=(OFFlowMod)error_msg;
switch (mod.getCommand()) {
case OFFlowMod.OFPFC_ADD:
this.flowCount--;
break;
case OFFlowMod.OFPFC_DELETE:
this.flowCount++;
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.flowCount++;
break;
default :
break;
}
break;
default :
break;
}
}
 else {
return;
}
break;
case FLOW_REMOVED:
OFFlowRemoved removedFlow=(OFFlowRemoved)msg;
OFFlowMod mod=new OFFlowMod();
mod.setMatch(removedFlow.getMatch());
List<OFFlowMod> flows=mySlicer.allowedFlows(mod);
if (flows.size() == 0) {
return;
}
if (mySlicer.getTagManagement()) {
removedFlow.getMatch().setDataLayerVirtualLan((short)0);
removedFlow.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN);
msg=removedFlow;
}
this.flowCount--;
break;
case BARRIER_REPLY:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.removeToKey(xid);
}
 else {
return;
}
break;
case ECHO_REQUEST:
return;
default :
log.debug(""String_Node_Str"" + msg.getType());
break;
}
try {
ofcch.sendMessage(msg);
}
 catch (IOException e) {
e.printStackTrace();
}
}","/** 
 * handle messages from the switch and verify they should be a part of this slice if not just return
 * @param msg
 * @param cntx
 */
public void toController(OFMessage msg,FloodlightContext cntx){
  if (ofcch == null) {
    return;
  }
  log.debug(""String_Node_Str"" + msg.getType());
  int xid=msg.getXid();
switch (msg.getType()) {
case PACKET_IN:
    OFPacketIn pcktIn=(OFPacketIn)msg;
  OFMatch match=new OFMatch();
if (pcktIn.getPacketData().length <= 0) {
  log.debug(""String_Node_Str"");
  return;
}
match.loadFromPacket(pcktIn.getPacketData(),pcktIn.getInPort());
OFFlowMod flowMod=new OFFlowMod();
flowMod.setMatch(match);
List<OFFlowMod> allowed=this.mySlicer.allowedFlows(flowMod);
if (allowed.size() == 0) {
log.debug(""String_Node_Str"" + this.mySlicer.getSliceName());
return;
}
if (this.packetInRate.okToProcess()) {
this.mySlicer.addBufferId(pcktIn.getBufferId(),pcktIn.getPacketData());
if (this.mySlicer.getTagManagement()) {
log.debug(""String_Node_Str"");
Ethernet newPkt=new Ethernet();
byte[] pktData=pcktIn.getPacketData();
newPkt.deserialize(pktData,0,pktData.length);
newPkt.setEtherType(newPkt.getEtherType());
newPkt.setVlanID(Ethernet.VLAN_UNTAGGED);
byte[] newPktData=newPkt.serialize();
pcktIn.setPacketData(newPktData);
pcktIn.setTotalLength((short)newPktData.length);
}
break;
}
 else {
log.warn(""String_Node_Str"" + this.getSlicer().getSliceName() + ""String_Node_Str""+ this.getSlicer().getSwitchName()+ ""String_Node_Str"");
this.setAdminStatus(false);
return;
}
case PORT_STATUS:
OFPortStatus portStatus=(OFPortStatus)msg;
OFPhysicalPort port=portStatus.getDesc();
if (!this.mySlicer.isPortPartOfSlice(port.getName())) {
log.debug(""String_Node_Str"" + this.getSlicer().getSwitchName() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ this.mySlicer.getSliceName());
return;
}
switch (OFPortReason.fromReasonCode(portStatus.getReason())) {
case OFPPR_ADD:
this.mySlicer.setPortId(port.getName(),port.getPortNumber());
break;
case OFPPR_MODIFY:
break;
case OFPPR_DELETE:
break;
}
break;
case ERROR:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.remove(xid);
OFError error=(OFError)msg;
OFMessage error_msg=null;
try {
error_msg=error.getOffendingMsg();
}
 catch (MessageParseException e) {
log.error(""String_Node_Str"");
break;
}
if (error_msg == null) {
break;
}
switch (error_msg.getType()) {
case FLOW_MOD:
OFFlowMod mod=(OFFlowMod)error_msg;
switch (mod.getCommand()) {
case OFFlowMod.OFPFC_ADD:
this.flowCount--;
break;
case OFFlowMod.OFPFC_DELETE:
this.flowCount++;
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.flowCount++;
break;
default :
break;
}
break;
default :
break;
}
}
 else {
return;
}
break;
case FLOW_REMOVED:
OFFlowRemoved removedFlow=(OFFlowRemoved)msg;
OFFlowMod mod=new OFFlowMod();
mod.setMatch(removedFlow.getMatch());
List<OFFlowMod> flows=mySlicer.allowedFlows(mod);
if (flows.size() == 0) {
return;
}
if (mySlicer.getTagManagement()) {
removedFlow.getMatch().setDataLayerVirtualLan((short)0);
removedFlow.getMatch().setWildcards(removedFlow.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN));
msg=removedFlow;
}
this.flowCount--;
break;
case BARRIER_REPLY:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.removeToKey(xid);
}
 else {
return;
}
break;
case ECHO_REQUEST:
return;
default :
log.debug(""String_Node_Str"" + msg.getType());
break;
}
try {
ofcch.sendMessage(msg);
}
 catch (IOException e) {
e.printStackTrace();
}
}",0.9945882697089368
25442,"/** 
 * processFlow - processes a FlowStat and updates or removes the flow
 * @param switchId
 * @param flowStat
 * @param time
 * @param flowCount
 */
private void processFlow(Long switchId,OFFlowStatisticsReply flowStat,long time,HashMap<String,Integer> flowCount){
  if (!map.containsKey(switchId)) {
    HashMap<OFMatch,FSFWOFFlowStatisticsReply> tmpMap=new HashMap<OFMatch,FSFWOFFlowStatisticsReply>();
    map.put(switchId,tmpMap);
  }
  HashMap<OFMatch,FSFWOFFlowStatisticsReply> flowMap=map.get(switchId);
  if (flowMap.containsKey(flowStat.getMatch())) {
    log.debug(""String_Node_Str"");
    FSFWOFFlowStatisticsReply cachedStat=(FSFWOFFlowStatisticsReply)flowMap.get(flowStat.getMatch());
    if (cachedStat.compareActions(flowStat.getActions())) {
      if (this.updateFlowStatData(cachedStat,flowStat,flowCount)) {
        return;
      }
 else {
        log.error(""String_Node_Str"");
        return;
      }
    }
 else {
      log.error(""String_Node_Str"");
      log.error(cachedStat.toString());
      log.error(flowStat.toString());
      FSFWOFFlowStatisticsReply parentStat=cachedStat.getParentStat();
      OFFlowMod flow=this.buildFlowMod(parentStat);
      Slicer slice=this.parent.getProxy(switchId,parentStat.getSliceName()).getSlicer();
      List<OFFlowMod> flows;
      if (slice.getTagManagement()) {
        log.error(""String_Node_Str"");
        flows=slice.managedFlows(flow);
      }
 else {
        log.error(""String_Node_Str"");
        flows=slice.allowedFlows(flow);
      }
      this.delFlowMod(switchId,slice.getSliceName(),flow,flows);
    }
  }
 else {
    OFFlowMod flow=this.buildFlowMod(flowStat);
    Slicer slice=this.findSliceForFlow(switchId,flow);
    if (slice == null) {
      log.info(""String_Node_Str"" + flowStat.toString());
      this.deleteFlow(switchId,flowStat);
    }
 else {
      List<OFFlowMod> flows=new ArrayList<OFFlowMod>();
      if (slice.getTagManagement()) {
        flows.add(flow);
        OFFlowMod newFlow;
        try {
          newFlow=flow.clone();
          newFlow.getMatch().setDataLayerVirtualLan((short)0);
          newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN));
          List<OFAction> newActions=new ArrayList<OFAction>();
          int length=0;
          for (          OFAction act : newFlow.getActions()) {
            if (act.getType() == OFActionType.SET_VLAN_ID) {
              continue;
            }
 else             if (act.getType() == OFActionType.STRIP_VLAN) {
              continue;
            }
 else {
              newActions.add(act);
              length+=act.getLength();
            }
          }
          newFlow.setActions(newActions);
          newFlow.setLength((short)(OFFlowMod.MINIMUM_LENGTH + length));
          this.addFlowMod(switchId,slice.getSliceName(),newFlow,flows);
        }
 catch (        CloneNotSupportedException e) {
          log.warn(""String_Node_Str"");
          return;
        }
      }
 else {
        flows.add(flow);
        this.addFlowMod(switchId,slice.getSliceName(),flow,flows);
      }
      FSFWOFFlowStatisticsReply cachedStat=(FSFWOFFlowStatisticsReply)flowMap.get(flowStat.getMatch());
      if (this.updateFlowStatData(cachedStat,flowStat,flowCount)) {
        return;
      }
 else {
        log.warn(""String_Node_Str"");
      }
    }
  }
}","/** 
 * processFlow - processes a FlowStat and updates or removes the flow
 * @param switchId
 * @param flowStat
 * @param time
 * @param flowCount
 */
private void processFlow(Long switchId,OFFlowStatisticsReply flowStat,long time,HashMap<String,Integer> flowCount){
  if (!map.containsKey(switchId)) {
    HashMap<OFMatch,FSFWOFFlowStatisticsReply> tmpMap=new HashMap<OFMatch,FSFWOFFlowStatisticsReply>();
    map.put(switchId,tmpMap);
  }
  HashMap<OFMatch,FSFWOFFlowStatisticsReply> flowMap=map.get(switchId);
  if (flowMap.containsKey(flowStat.getMatch())) {
    log.debug(""String_Node_Str"");
    FSFWOFFlowStatisticsReply cachedStat=(FSFWOFFlowStatisticsReply)flowMap.get(flowStat.getMatch());
    if (cachedStat.compareActions(flowStat.getActions())) {
      if (this.updateFlowStatData(cachedStat,flowStat,flowCount)) {
        return;
      }
 else {
        log.error(""String_Node_Str"");
        return;
      }
    }
 else {
      log.error(""String_Node_Str"");
      log.error(cachedStat.toString());
      log.error(flowStat.toString());
      FSFWOFFlowStatisticsReply parentStat=cachedStat.getParentStat();
      OFFlowMod flow=this.buildFlowMod(parentStat);
      Slicer slice=this.parent.getProxy(switchId,parentStat.getSliceName()).getSlicer();
      if (slice == null) {
        this.deleteFlow(switchId,parentStat);
        return;
      }
      List<OFFlowMod> flows;
      if (slice.getTagManagement()) {
        log.error(""String_Node_Str"");
        flows=slice.managedFlows(flow);
      }
 else {
        log.error(""String_Node_Str"");
        flows=slice.allowedFlows(flow);
      }
      this.delFlowMod(switchId,slice.getSliceName(),flow,flows);
    }
  }
 else {
    OFFlowMod flow=this.buildFlowMod(flowStat);
    Slicer slice=this.findSliceForFlow(switchId,flow);
    if (slice == null) {
      log.info(""String_Node_Str"" + flowStat.toString());
      this.deleteFlow(switchId,flowStat);
    }
 else {
      List<OFFlowMod> flows=new ArrayList<OFFlowMod>();
      if (slice.getTagManagement()) {
        flows.add(flow);
        OFFlowMod newFlow;
        try {
          newFlow=flow.clone();
          newFlow.getMatch().setDataLayerVirtualLan((short)0);
          newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN));
          List<OFAction> newActions=new ArrayList<OFAction>();
          int length=0;
          for (          OFAction act : newFlow.getActions()) {
            if (act.getType() == OFActionType.SET_VLAN_ID) {
              continue;
            }
 else             if (act.getType() == OFActionType.STRIP_VLAN) {
              continue;
            }
 else {
              newActions.add(act);
              length+=act.getLength();
            }
          }
          newFlow.setActions(newActions);
          newFlow.setLength((short)(OFFlowMod.MINIMUM_LENGTH + length));
          this.addFlowMod(switchId,slice.getSliceName(),newFlow,flows);
        }
 catch (        CloneNotSupportedException e) {
          log.warn(""String_Node_Str"");
          return;
        }
      }
 else {
        flows.add(flow);
        this.addFlowMod(switchId,slice.getSliceName(),flow,flows);
      }
      FSFWOFFlowStatisticsReply cachedStat=(FSFWOFFlowStatisticsReply)flowMap.get(flowStat.getMatch());
      if (this.updateFlowStatData(cachedStat,flowStat,flowCount)) {
        return;
      }
 else {
        log.warn(""String_Node_Str"");
      }
    }
  }
}",0.9857331960582438
25443,"/** 
 * handle messages from the switch and verify they should be a part of this slice if not just return
 * @param msg
 * @param cntx
 */
public void toController(OFMessage msg,FloodlightContext cntx){
  if (ofcch == null) {
    return;
  }
  log.debug(""String_Node_Str"" + msg.getType());
  int xid=msg.getXid();
switch (msg.getType()) {
case PACKET_IN:
    OFPacketIn pcktIn=(OFPacketIn)msg;
  OFMatch match=new OFMatch();
if (pcktIn.getPacketData().length <= 0) {
  log.debug(""String_Node_Str"");
  return;
}
match.loadFromPacket(pcktIn.getPacketData(),pcktIn.getInPort());
OFFlowMod flowMod=new OFFlowMod();
flowMod.setMatch(match);
List<OFFlowMod> allowed=this.mySlicer.allowedFlows(flowMod);
if (allowed.size() == 0) {
log.debug(""String_Node_Str"" + this.mySlicer.getSliceName());
return;
}
if (this.packetInRate.okToProcess()) {
this.mySlicer.addBufferId(pcktIn.getBufferId(),pcktIn.getPacketData());
if (this.mySlicer.getTagManagement()) {
log.debug(""String_Node_Str"");
Ethernet newPkt=new Ethernet();
byte[] pktData=pcktIn.getPacketData();
newPkt.deserialize(pktData,0,pktData.length);
newPkt.setEtherType(newPkt.getEtherType());
newPkt.setVlanID(Ethernet.VLAN_UNTAGGED);
byte[] newPktData=newPkt.serialize();
pcktIn.setPacketData(newPktData);
pcktIn.setTotalLength((short)newPktData.length);
}
break;
}
 else {
log.error(""String_Node_Str"" + this.getSlicer().getSliceName() + ""String_Node_Str""+ this.getSlicer().getSwitchName()+ ""String_Node_Str"");
this.setAdminStatus(false);
return;
}
case PORT_STATUS:
OFPortStatus portStatus=(OFPortStatus)msg;
OFPhysicalPort port=portStatus.getDesc();
if (!this.mySlicer.isPortPartOfSlice(port.getName())) {
log.debug(""String_Node_Str"" + this.getSlicer().getSwitchName() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ this.mySlicer.getSliceName());
return;
}
switch (OFPortReason.fromReasonCode(portStatus.getReason())) {
case OFPPR_ADD:
this.mySlicer.setPortId(port.getName(),port.getPortNumber());
break;
case OFPPR_MODIFY:
break;
case OFPPR_DELETE:
break;
}
break;
case ERROR:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.remove(xid);
OFError error=(OFError)msg;
OFMessage error_msg=null;
try {
error_msg=error.getOffendingMsg();
}
 catch (MessageParseException e) {
log.error(""String_Node_Str"");
break;
}
if (error_msg == null) {
break;
}
switch (error_msg.getType()) {
case FLOW_MOD:
OFFlowMod mod=(OFFlowMod)error_msg;
switch (mod.getCommand()) {
case OFFlowMod.OFPFC_ADD:
this.flowCount--;
break;
case OFFlowMod.OFPFC_DELETE:
this.flowCount++;
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.flowCount++;
break;
default :
break;
}
break;
default :
break;
}
}
 else {
return;
}
break;
case FLOW_REMOVED:
OFFlowRemoved removedFlow=(OFFlowRemoved)msg;
OFFlowMod mod=new OFFlowMod();
mod.setMatch(removedFlow.getMatch());
List<OFFlowMod> flows=mySlicer.allowedFlows(mod);
if (flows.size() == 0) {
return;
}
if (mySlicer.getTagManagement()) {
mod.getMatch().setDataLayerVirtualLan((short)0);
mod.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN);
List<OFAction> acts=mod.getActions();
List<OFAction> newActs=new ArrayList<OFAction>();
int length=0;
for (OFAction act : acts) {
switch (act.getType()) {
case SET_VLAN_ID:
break;
case STRIP_VLAN:
break;
default :
newActs.add(act);
length+=act.getLengthU();
}
}
mod.setActions(newActs);
mod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + length));
msg=mod;
}
this.flowCount--;
break;
case BARRIER_REPLY:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.removeToKey(xid);
}
 else {
return;
}
break;
case ECHO_REQUEST:
return;
default :
log.debug(""String_Node_Str"" + msg.getType());
break;
}
try {
ofcch.sendMessage(msg);
}
 catch (IOException e) {
e.printStackTrace();
}
}","/** 
 * handle messages from the switch and verify they should be a part of this slice if not just return
 * @param msg
 * @param cntx
 */
public void toController(OFMessage msg,FloodlightContext cntx){
  if (ofcch == null) {
    return;
  }
  log.debug(""String_Node_Str"" + msg.getType());
  int xid=msg.getXid();
switch (msg.getType()) {
case PACKET_IN:
    OFPacketIn pcktIn=(OFPacketIn)msg;
  OFMatch match=new OFMatch();
if (pcktIn.getPacketData().length <= 0) {
  log.debug(""String_Node_Str"");
  return;
}
match.loadFromPacket(pcktIn.getPacketData(),pcktIn.getInPort());
OFFlowMod flowMod=new OFFlowMod();
flowMod.setMatch(match);
List<OFFlowMod> allowed=this.mySlicer.allowedFlows(flowMod);
if (allowed.size() == 0) {
log.debug(""String_Node_Str"" + this.mySlicer.getSliceName());
return;
}
if (this.packetInRate.okToProcess()) {
this.mySlicer.addBufferId(pcktIn.getBufferId(),pcktIn.getPacketData());
if (this.mySlicer.getTagManagement()) {
log.debug(""String_Node_Str"");
Ethernet newPkt=new Ethernet();
byte[] pktData=pcktIn.getPacketData();
newPkt.deserialize(pktData,0,pktData.length);
newPkt.setEtherType(newPkt.getEtherType());
newPkt.setVlanID(Ethernet.VLAN_UNTAGGED);
byte[] newPktData=newPkt.serialize();
pcktIn.setPacketData(newPktData);
pcktIn.setTotalLength((short)newPktData.length);
}
break;
}
 else {
log.error(""String_Node_Str"" + this.getSlicer().getSliceName() + ""String_Node_Str""+ this.getSlicer().getSwitchName()+ ""String_Node_Str"");
this.setAdminStatus(false);
return;
}
case PORT_STATUS:
OFPortStatus portStatus=(OFPortStatus)msg;
OFPhysicalPort port=portStatus.getDesc();
if (!this.mySlicer.isPortPartOfSlice(port.getName())) {
log.debug(""String_Node_Str"" + this.getSlicer().getSwitchName() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ this.mySlicer.getSliceName());
return;
}
switch (OFPortReason.fromReasonCode(portStatus.getReason())) {
case OFPPR_ADD:
this.mySlicer.setPortId(port.getName(),port.getPortNumber());
break;
case OFPPR_MODIFY:
break;
case OFPPR_DELETE:
break;
}
break;
case ERROR:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.remove(xid);
OFError error=(OFError)msg;
OFMessage error_msg=null;
try {
error_msg=error.getOffendingMsg();
}
 catch (MessageParseException e) {
log.error(""String_Node_Str"");
break;
}
if (error_msg == null) {
break;
}
switch (error_msg.getType()) {
case FLOW_MOD:
OFFlowMod mod=(OFFlowMod)error_msg;
switch (mod.getCommand()) {
case OFFlowMod.OFPFC_ADD:
this.flowCount--;
break;
case OFFlowMod.OFPFC_DELETE:
this.flowCount++;
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.flowCount++;
break;
default :
break;
}
break;
default :
break;
}
}
 else {
return;
}
break;
case FLOW_REMOVED:
OFFlowRemoved removedFlow=(OFFlowRemoved)msg;
OFFlowMod mod=new OFFlowMod();
mod.setMatch(removedFlow.getMatch());
List<OFFlowMod> flows=mySlicer.allowedFlows(mod);
if (flows.size() == 0) {
return;
}
if (mySlicer.getTagManagement()) {
removedFlow.getMatch().setDataLayerVirtualLan((short)0);
removedFlow.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN);
msg=removedFlow;
}
this.flowCount--;
break;
case BARRIER_REPLY:
if (xidMap.containsKey(xid)) {
msg.setXid(xidMap.get(xid));
xidMap.removeToKey(xid);
}
 else {
return;
}
break;
case ECHO_REQUEST:
return;
default :
log.debug(""String_Node_Str"" + msg.getType());
break;
}
try {
ofcch.sendMessage(msg);
}
 catch (IOException e) {
e.printStackTrace();
}
}",0.9446939921392477
25444,"public void addFlowMod(Long dpid,String sliceName,OFFlowMod flow){
  FSFWOFFlowStatisticsReply flowStat=new FSFWOFFlowStatisticsReply();
  flowStat.setMatch(flow.getMatch());
  flowStat.setActions(flow.getActions());
  flowStat.setPacketCount(0);
  flowStat.setByteCount(0);
  flowStat.setPriority(flow.getPriority());
  flowStat.setCookie(flow.getCookie());
  flowStat.setHardTimeout(flow.getHardTimeout());
  flowStat.setIdleTimeout(flow.getIdleTimeout());
  short length=0;
  for (  OFAction act : flowStat.getActions()) {
    length+=act.getLengthU();
  }
  flowStat.setLength((short)(OFFlowStatisticsReply.MINIMUM_LENGTH + length));
  if (sliced.containsKey(dpid)) {
    HashMap<String,List<OFStatistics>> sliceStats=sliced.get(dpid);
    if (sliceStats.containsKey(sliceName)) {
      log.debug(""String_Node_Str"");
      sliceStats.get(sliceName).add(flowStat);
      log.debug(""String_Node_Str"" + sliceStats.get(sliceName).size());
    }
 else {
      List<OFStatistics> stats=new ArrayList<OFStatistics>();
      log.debug(""String_Node_Str"");
      stats.add(flowStat);
      sliceStats.put(sliceName,stats);
    }
  }
 else {
    HashMap<String,List<OFStatistics>> sliceStats=new HashMap<String,List<OFStatistics>>();
    List<OFStatistics> stats=new ArrayList<OFStatistics>();
    sliceStats.put(sliceName,stats);
    stats.add(flowStat);
    log.debug(""String_Node_Str"");
    sliced.put(dpid,sliceStats);
  }
  log.debug(""String_Node_Str"" + flowStat.toString() + ""String_Node_Str"");
  flowStat.setLastSeen(System.currentTimeMillis());
}","public synchronized void addFlowMod(Long dpid,String sliceName,OFFlowMod flow){
  FSFWOFFlowStatisticsReply flowStat=new FSFWOFFlowStatisticsReply();
  flowStat.setMatch(flow.getMatch());
  flowStat.setActions(flow.getActions());
  flowStat.setPacketCount(0);
  flowStat.setByteCount(0);
  flowStat.setPriority(flow.getPriority());
  flowStat.setCookie(flow.getCookie());
  flowStat.setHardTimeout(flow.getHardTimeout());
  flowStat.setIdleTimeout(flow.getIdleTimeout());
  short length=0;
  for (  OFAction act : flowStat.getActions()) {
    length+=act.getLengthU();
  }
  flowStat.setLength((short)(OFFlowStatisticsReply.MINIMUM_LENGTH + length));
  if (sliced.containsKey(dpid)) {
    HashMap<String,List<OFStatistics>> sliceStats=sliced.get(dpid);
    if (sliceStats.containsKey(sliceName)) {
      log.debug(""String_Node_Str"");
      sliceStats.get(sliceName).add(flowStat);
      log.debug(""String_Node_Str"" + sliceStats.get(sliceName).size());
    }
 else {
      List<OFStatistics> stats=new ArrayList<OFStatistics>();
      log.debug(""String_Node_Str"");
      stats.add(flowStat);
      sliceStats.put(sliceName,stats);
    }
  }
 else {
    HashMap<String,List<OFStatistics>> sliceStats=new HashMap<String,List<OFStatistics>>();
    List<OFStatistics> stats=new ArrayList<OFStatistics>();
    sliceStats.put(sliceName,stats);
    stats.add(flowStat);
    log.debug(""String_Node_Str"");
    sliced.put(dpid,sliceStats);
  }
  log.debug(""String_Node_Str"" + flowStat.toString() + ""String_Node_Str"");
  flowStat.setLastSeen(System.currentTimeMillis());
}",0.99581589958159
25445,"public void writeObject(ObjectOutputStream aOutputStream) throws IOException {
  aOutputStream.writeObject(sliced.clone());
}","public synchronized void writeObject(ObjectOutputStream aOutputStream) throws IOException {
  aOutputStream.writeObject(sliced.clone());
}",0.9505703422053232
25446,"public void delFlowMod(long dpid,String sliceName,OFFlowMod flow){
  FSFWOFFlowStatisticsReply flowStat=(FSFWOFFlowStatisticsReply)this.findCachedStat(dpid,flow.getMatch(),sliceName);
  if (flowStat != null) {
    log.error(""String_Node_Str"");
    flowStat.setToBeDeleted(true);
    return;
  }
  log.error(""String_Node_Str"");
}","public synchronized void delFlowMod(long dpid,String sliceName,OFFlowMod flow){
  FSFWOFFlowStatisticsReply flowStat=(FSFWOFFlowStatisticsReply)this.findCachedStat(dpid,flow.getMatch(),sliceName);
  if (flowStat != null) {
    log.error(""String_Node_Str"");
    flowStat.setToBeDeleted(true);
    return;
  }
  log.error(""String_Node_Str"");
}",0.9805680119581464
25447,"private void handleFlowStatsRequest(OFMessage msg){
  log.debug(""String_Node_Str"" + mySwitch.getStringId() + ""String_Node_Str"");
  List<OFStatistics> results=this.parent.getSlicedFlowStats(mySwitch.getId(),this.mySlicer.getSliceName());
  if (results == null) {
    log.debug(""String_Node_Str"");
    return;
  }
  log.debug(""String_Node_Str"" + results.toString());
  this.flowCount=results.size();
  if (results.size() <= 0) {
    OFStatisticsReply reply=new OFStatisticsReply();
    reply.setStatistics(results);
    reply.setStatisticType(OFStatisticsType.FLOW);
    reply.setXid(msg.getXid());
    reply.setFlags((short)0x0000);
    try {
      ofcch.sendMessage(reply);
    }
 catch (    IOException e1) {
      e1.printStackTrace();
    }
    return;
  }
  short length=0;
  int counter=0;
  Iterator<OFStatistics> it2=results.iterator();
  List<OFFlowStatisticsReply> limitedResults=new ArrayList<OFFlowStatisticsReply>();
  while (it2.hasNext()) {
    OFFlowStatisticsReply stat=(OFFlowStatisticsReply)it2.next();
    if (this.mySlicer.getTagManagement()) {
      stat.getMatch().setDataLayerVirtualLan((short)0);
      stat.getMatch().setWildcards(stat.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN));
      List<OFAction> newActions=new ArrayList<OFAction>();
      short actLength=0;
      List<OFAction> actions=stat.getActions();
      Iterator<OFAction> actIt=actions.iterator();
      while (actIt.hasNext()) {
        OFAction act=actIt.next();
switch (act.getType()) {
case SET_VLAN_ID:
          break;
case SET_VLAN_PCP:
        break;
case STRIP_VLAN:
      break;
default :
    newActions.add(act);
  actLength+=act.getLength();
break;
}
}
stat.setActions(newActions);
stat.setLength((short)(OFFlowStatisticsReply.MINIMUM_LENGTH + actLength));
}
length+=stat.getLength();
counter++;
limitedResults.add(stat);
if (counter >= 10 || it2.hasNext() == false) {
OFStatisticsReply reply=new OFStatisticsReply();
reply.setStatistics(limitedResults);
reply.setStatisticType(OFStatisticsType.FLOW);
reply.setXid(msg.getXid());
if (it2.hasNext() == false) {
reply.setFlags((short)0x0000);
}
 else {
reply.setFlags((short)0x0001);
}
length+=reply.getLength();
reply.setLength(length);
try {
ofcch.sendMessage(reply);
}
 catch (IOException e1) {
e1.printStackTrace();
}
counter=0;
length=0;
limitedResults=new ArrayList<OFFlowStatisticsReply>();
}
}
}","private void handleFlowStatsRequest(OFMessage msg){
  log.debug(""String_Node_Str"" + mySwitch.getStringId() + ""String_Node_Str"");
  List<OFStatistics> results=this.parent.getSlicedFlowStats(mySwitch.getId(),this.mySlicer.getSliceName());
  if (results == null) {
    log.debug(""String_Node_Str"");
    return;
  }
  log.debug(""String_Node_Str"" + results.toString());
  this.flowCount=results.size();
  if (results.size() <= 0) {
    OFStatisticsReply reply=new OFStatisticsReply();
    reply.setStatistics(results);
    reply.setStatisticType(OFStatisticsType.FLOW);
    reply.setXid(msg.getXid());
    reply.setFlags((short)0x0000);
    try {
      ofcch.sendMessage(reply);
    }
 catch (    IOException e1) {
      e1.printStackTrace();
    }
    return;
  }
  short length=0;
  int counter=0;
  Iterator<OFStatistics> it2=results.iterator();
  List<OFFlowStatisticsReply> limitedResults=new ArrayList<OFFlowStatisticsReply>();
  while (it2.hasNext()) {
    OFFlowStatisticsReply stat=(OFFlowStatisticsReply)it2.next();
    if (this.mySlicer.getTagManagement()) {
      OFFlowStatisticsReply newStat=new OFFlowStatisticsReply();
      newStat.setMatch(stat.getMatch().clone());
      newStat.getMatch().setDataLayerVirtualLan((short)0);
      newStat.getMatch().setWildcards(newStat.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN));
      List<OFAction> newActions=new ArrayList<OFAction>();
      short actLength=0;
      List<OFAction> actions=stat.getActions();
      Iterator<OFAction> actIt=actions.iterator();
      while (actIt.hasNext()) {
        OFAction act=actIt.next();
switch (act.getType()) {
case SET_VLAN_ID:
          break;
case SET_VLAN_PCP:
        break;
case STRIP_VLAN:
      break;
default :
    newActions.add(act);
  actLength+=act.getLength();
break;
}
}
newStat.setActions(newActions);
newStat.setLength((short)(OFFlowStatisticsReply.MINIMUM_LENGTH + actLength));
stat=newStat;
}
length+=stat.getLength();
counter++;
limitedResults.add(stat);
if (counter >= 10 || it2.hasNext() == false) {
OFStatisticsReply reply=new OFStatisticsReply();
reply.setStatistics(limitedResults);
reply.setStatisticType(OFStatisticsType.FLOW);
reply.setXid(msg.getXid());
if (it2.hasNext() == false) {
reply.setFlags((short)0x0000);
}
 else {
reply.setFlags((short)0x0001);
}
length+=reply.getLength();
reply.setLength(length);
try {
ofcch.sendMessage(reply);
}
 catch (IOException e1) {
e1.printStackTrace();
}
counter=0;
length=0;
limitedResults=new ArrayList<OFFlowStatisticsReply>();
}
}
}",0.966646204215265
25448,"public static List<OFStatistics> SliceStats(Slicer slicer,List<OFStatistics> stats){
  List<OFStatistics> reply=new ArrayList<OFStatistics>();
  if (stats == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"" + stats.toString());
  Iterator<OFStatistics> it=stats.iterator();
  while (it.hasNext()) {
    OFFlowStatisticsReply flowStat=(OFFlowStatisticsReply)it.next();
    OFFlowMod flowMod=new OFFlowMod();
    flowMod.setMatch(flowStat.getMatch());
    flowMod.setActions(flowStat.getActions());
    log.debug(""String_Node_Str"" + flowStat.toString());
    log.debug(""String_Node_Str"" + flowMod.toString());
    List<OFFlowMod> flowMods=slicer.allowedFlows(flowMod);
    if (flowMods.size() != 0) {
      if (slicer.getTagManagement()) {
        List<OFAction> actions=flowStat.getActions();
        List<OFAction> newActions=new ArrayList<OFAction>();
        for (        OFAction act : actions) {
switch (act.getType()) {
case SET_VLAN_ID:
            flowStat.setLength((short)(flowStat.getLength() - act.getLength()));
          break;
case STRIP_VLAN:
        flowStat.setLength((short)(flowStat.getLength() - act.getLength()));
      break;
default :
    newActions.add(act);
}
}
flowStat.setActions(newActions);
flowStat.getMatch().setWildcards(flowStat.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN));
}
reply.add(flowStat);
}
}
return reply;
}","public static List<OFStatistics> SliceStats(Slicer slicer,List<OFStatistics> stats){
  List<OFStatistics> reply=new ArrayList<OFStatistics>();
  if (stats == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"" + stats.toString());
  Iterator<OFStatistics> it=stats.iterator();
  while (it.hasNext()) {
    OFFlowStatisticsReply flowStat=(OFFlowStatisticsReply)it.next();
    OFFlowMod flowMod=new OFFlowMod();
    flowMod.setMatch(flowStat.getMatch());
    flowMod.setActions(flowStat.getActions());
    log.debug(""String_Node_Str"" + flowStat.toString());
    log.debug(""String_Node_Str"" + flowMod.toString());
    List<OFFlowMod> flowMods=slicer.allowedFlows(flowMod);
    if (flowMods.size() != 0) {
      if (slicer.getTagManagement()) {
        List<OFAction> actions=flowStat.getActions();
        List<OFAction> newActions=new ArrayList<OFAction>();
        for (        OFAction act : actions) {
switch (act.getType()) {
case SET_VLAN_ID:
            flowStat.setLength((short)(flowStat.getLength() - act.getLength()));
          break;
case STRIP_VLAN:
        flowStat.setLength((short)(flowStat.getLength() - act.getLength()));
      break;
default :
    newActions.add(act);
}
}
flowStat.setActions(newActions);
flowStat.getMatch().setWildcards(flowStat.getMatch().getWildcardObj().wildcard(Wildcards.Flag.DL_VLAN));
flowStat.getMatch().setDataLayerVirtualLan((short)0);
}
reply.add(flowStat);
}
}
return reply;
}",0.9813278008298756
25449,"private void processFlowMod(OFMessage msg,FloodlightContext cntx){
  List<OFFlowMod> flows;
  OFFlowMod flow=(OFFlowMod)msg;
  if (flow.getCommand() == OFFlowMod.OFPFC_DELETE && flow.getMatch().equals(new OFMatch())) {
    this.removeFlows();
    return;
  }
  if (this.mySlicer.getTagManagement()) {
    flows=this.mySlicer.managedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
 else {
    flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
        OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
        error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
        this.sendError((OFMessage)msg,error);
        return;
      }
    if (this.mySlicer.doTimeouts()) {
      if (flow.getIdleTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false,cntx);
        this.timeouts.add(timeout);
        flow.setIdleTimeout((short)0);
      }
      if (flow.getHardTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true,cntx);
        this.timeouts.add(timeout);
        flow.setHardTimeout((short)0);
      }
    }
  this.updateFlowCount(1);
break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
this.sendError((OFMessage)msg,error);
return;
}
if (this.mySlicer.doTimeouts()) {
if (flow.getIdleTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false,cntx);
this.timeouts.add(timeout);
flow.setIdleTimeout((short)0);
}
if (flow.getHardTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true,cntx);
this.timeouts.add(timeout);
flow.setHardTimeout((short)0);
}
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
messages.add((OFMessage)flow);
}
log.error(""String_Node_Str"" + messages.toString());
mapXids(messages);
try {
mySwitch.write(messages,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}","private void processFlowMod(OFMessage msg,FloodlightContext cntx){
  List<OFFlowMod> flows;
  OFFlowMod tmpFlow=(OFFlowMod)msg;
  if (tmpFlow.getCommand() == OFFlowMod.OFPFC_DELETE && tmpFlow.getMatch().equals(new OFMatch())) {
    this.removeFlows();
    return;
  }
  if (this.mySlicer.getTagManagement()) {
    flows=this.mySlicer.managedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
 else {
    flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
        OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
        error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
        this.sendError((OFMessage)msg,error);
        return;
      }
    if (this.mySlicer.doTimeouts()) {
      if (flow.getIdleTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false,cntx);
        this.timeouts.add(timeout);
        flow.setIdleTimeout((short)0);
      }
      if (flow.getHardTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true,cntx);
        this.timeouts.add(timeout);
        flow.setHardTimeout((short)0);
      }
    }
  this.updateFlowCount(1);
break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
this.sendError((OFMessage)msg,error);
return;
}
if (this.mySlicer.doTimeouts()) {
if (flow.getIdleTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false,cntx);
this.timeouts.add(timeout);
flow.setIdleTimeout((short)0);
}
if (flow.getHardTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true,cntx);
this.timeouts.add(timeout);
flow.setHardTimeout((short)0);
}
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
messages.add((OFMessage)flow);
}
log.error(""String_Node_Str"" + messages.toString());
mapXids(messages);
try {
mySwitch.write(messages,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}",0.9980742072153036
25450,"public List<OFFlowMod> managedFlows(OFFlowMod flowMod){
  log.debug(""String_Node_Str"" + flowMod.toString() + ""String_Node_Str"");
  List<OFFlowMod> flows=new ArrayList<OFFlowMod>();
  OFMatch match=flowMod.getMatch();
  if (match == null) {
    return flows;
  }
  if (match.getDataLayerVirtualLan() == 0 || match.getDataLayerVirtualLan() == -1) {
    if (match.getInputPort() == 0) {
      Iterator<Entry<String,PortConfig>> it=this.portList.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,PortConfig> port=(Entry<String,PortConfig>)it.next();
        if (port.getValue().getPortId() != 0) {
          try {
            OFFlowMod newFlow=flowMod.clone();
            newFlow.getMatch().setInputPort(port.getValue().getPortId());
            newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().matchOn(Flag.IN_PORT));
            newFlow.getMatch().setDataLayerVirtualLan(port.getValue().getVlanRange().getAvailableTags()[0]);
            newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().matchOn(Flag.DL_VLAN));
            List<OFFlowMod> newFlows=this.managedFlowActions(newFlow);
            for (            OFFlowMod flow : newFlows) {
              flows.add(flow);
            }
          }
 catch (          CloneNotSupportedException e) {
            flows.clear();
            return flows;
          }
catch (          Exception e) {
            flows.clear();
            return flows;
          }
        }
      }
    }
 else {
      short vlanId;
      PortConfig pConfig=this.getPortConfig(match.getInputPort());
      if (pConfig == null) {
        flows.clear();
        return flows;
      }
 else {
        vlanId=(short)pConfig.getVlanRange().getAvailableTags()[0];
      }
      match.setDataLayerVirtualLan(vlanId);
      flowMod.setMatch(match);
      flows=this.managedFlowActions(flowMod);
    }
  }
 else {
    log.debug(""String_Node_Str"" + flowMod.toString());
    return flows;
  }
  return flows;
}","public List<OFFlowMod> managedFlows(OFFlowMod flowMod){
  log.debug(""String_Node_Str"" + flowMod.toString() + ""String_Node_Str"");
  List<OFFlowMod> flows=new ArrayList<OFFlowMod>();
  OFMatch match=flowMod.getMatch();
  if (match == null) {
    return flows;
  }
  if (match.getWildcardObj().isWildcarded(Flag.DL_VLAN) || match.getDataLayerVirtualLan() == -1) {
    if (match.getWildcardObj().isWildcarded(Flag.IN_PORT)) {
      Iterator<Entry<String,PortConfig>> it=this.portList.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,PortConfig> port=(Entry<String,PortConfig>)it.next();
        if (port.getValue().getPortId() != 0) {
          try {
            OFFlowMod newFlow=flowMod.clone();
            newFlow.getMatch().setInputPort(port.getValue().getPortId());
            newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().matchOn(Flag.IN_PORT));
            newFlow.getMatch().setDataLayerVirtualLan(port.getValue().getVlanRange().getAvailableTags()[0]);
            newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().matchOn(Flag.DL_VLAN));
            List<OFFlowMod> newFlows=this.managedFlowActions(newFlow);
            for (            OFFlowMod flow : newFlows) {
              flows.add(flow);
            }
          }
 catch (          CloneNotSupportedException e) {
            flows.clear();
            return flows;
          }
catch (          Exception e) {
            flows.clear();
            return flows;
          }
        }
      }
    }
 else {
      short vlanId;
      PortConfig pConfig=this.getPortConfig(match.getInputPort());
      if (pConfig == null) {
        flows.clear();
        return flows;
      }
 else {
        vlanId=(short)pConfig.getVlanRange().getAvailableTags()[0];
      }
      match.setDataLayerVirtualLan(vlanId);
      match.setWildcards(match.getWildcardObj().matchOn(Flag.DL_VLAN));
      flowMod.setMatch(match);
      flows=this.managedFlowActions(flowMod);
    }
  }
 else {
    log.debug(""String_Node_Str"" + flowMod.toString());
    return flows;
  }
  return flows;
}",0.7052785923753666
25451,"public List<OFFlowMod> managedFlowActions(OFFlowMod flowMod){
  List<OFFlowMod> newFlows=new ArrayList<OFFlowMod>();
  List<OFAction> actions=flowMod.getActions();
  List<OFAction> newActions=new ArrayList<OFAction>();
  short additional_length=0;
  for (  OFAction act : actions) {
switch (act.getType()) {
case OUTPUT:
      OFActionOutput out=(OFActionOutput)act;
    short vlanTag;
  PortConfig pConfig=this.getPortConfig(out.getPort());
if (pConfig == null) {
  return newFlows;
}
 else {
  vlanTag=(short)pConfig.getVlanRange().getAvailableTags()[0];
}
if (vlanTag == -1) {
OFActionStripVirtualLan strip_vlan_vid=new OFActionStripVirtualLan();
newActions.add(strip_vlan_vid);
additional_length+=strip_vlan_vid.getLength();
}
 else {
OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
set_vlan_vid.setVirtualLanIdentifier(vlanTag);
newActions.add(set_vlan_vid);
additional_length+=set_vlan_vid.getLength();
}
newActions.add(out);
break;
case SET_VLAN_ID:
return newFlows;
case STRIP_VLAN:
return newFlows;
default :
newActions.add(act);
break;
}
}
OFFlowMod newFlow=new OFFlowMod();
newFlow.setMatch(flowMod.getMatch());
newFlow.setActions(newActions);
newFlow.setLength((short)(flowMod.getLength() + additional_length));
newFlows.add(newFlow);
return newFlows;
}","public List<OFFlowMod> managedFlowActions(OFFlowMod flowMod){
  List<OFFlowMod> newFlows=new ArrayList<OFFlowMod>();
  List<OFAction> actions=flowMod.getActions();
  List<OFAction> newActions=new ArrayList<OFAction>();
  short additional_length=0;
  for (  OFAction act : actions) {
switch (act.getType()) {
case OUTPUT:
      OFActionOutput out=(OFActionOutput)act;
    short vlanTag;
  PortConfig pConfig=this.getPortConfig(out.getPort());
if (pConfig == null) {
  return newFlows;
}
 else {
  vlanTag=(short)pConfig.getVlanRange().getAvailableTags()[0];
}
if (vlanTag == -1) {
OFActionStripVirtualLan strip_vlan_vid=new OFActionStripVirtualLan();
newActions.add(strip_vlan_vid);
additional_length+=strip_vlan_vid.getLength();
}
 else {
OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
set_vlan_vid.setVirtualLanIdentifier(vlanTag);
newActions.add(set_vlan_vid);
additional_length+=set_vlan_vid.getLength();
}
newActions.add(out);
break;
case SET_VLAN_ID:
return newFlows;
case STRIP_VLAN:
return newFlows;
default :
newActions.add(act);
break;
}
}
flowMod.setActions(newActions);
flowMod.setLength((short)(flowMod.getLength() + additional_length));
newFlows.add(flowMod);
return newFlows;
}",0.8915375446960667
25452,"@Test public void testManagedFlowModWithNoPort(){
  VLANSlicer otherSlicer=new VLANSlicer();
  otherSlicer.setTagManagement(true);
  pConfig=new PortConfig();
  pConfig.setPortName(""String_Node_Str"");
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)101,true);
  pConfig.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig);
  pConfig2=new PortConfig();
  pConfig2.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)103,true);
  pConfig2.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig2);
  pConfig3=new PortConfig();
  pConfig3.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)104,true);
  pConfig3.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig3);
  pConfig5=new PortConfig();
  pConfig5.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)106,true);
  pConfig5.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig5);
  pConfig6=new PortConfig();
  pConfig6.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)107,true);
  pConfig6.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig6);
  otherSlicer.setSwitch(sw);
  OFFlowMod flowMod=new OFFlowMod();
  OFMatch match=new OFMatch();
  match.setInputPort((short)4);
  flowMod.setMatch(match);
  List<OFAction> actions=new ArrayList<OFAction>();
  OFActionOutput out=new OFActionOutput();
  out.setPort((short)1);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH));
  List<OFFlowMod> managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
  flowMod.getMatch().setInputPort((short)3);
  out.setPort((short)4);
  actions.clear();
  actions.add(out);
  flowMod.setActions(actions);
  managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
}","@Test public void testManagedFlowModWithNoPort(){
  VLANSlicer otherSlicer=new VLANSlicer();
  otherSlicer.setTagManagement(true);
  pConfig=new PortConfig();
  pConfig.setPortName(""String_Node_Str"");
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)101,true);
  pConfig.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig);
  pConfig2=new PortConfig();
  pConfig2.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)103,true);
  pConfig2.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig2);
  pConfig3=new PortConfig();
  pConfig3.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)104,true);
  pConfig3.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig3);
  pConfig5=new PortConfig();
  pConfig5.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)106,true);
  pConfig5.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig5);
  pConfig6=new PortConfig();
  pConfig6.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)107,true);
  pConfig6.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig6);
  otherSlicer.setSwitch(sw);
  OFFlowMod flowMod=new OFFlowMod();
  OFMatch match=new OFMatch();
  match.setInputPort((short)4);
  match.setWildcards(match.getWildcardObj().matchOn(Flag.IN_PORT));
  flowMod.setMatch(match);
  List<OFAction> actions=new ArrayList<OFAction>();
  OFActionOutput out=new OFActionOutput();
  out.setPort((short)1);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH));
  List<OFFlowMod> managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
  flowMod.getMatch().setInputPort((short)3);
  out.setPort((short)4);
  actions.clear();
  actions.add(out);
  flowMod.setActions(actions);
  managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
}",0.9833984375
25453,"@Test public void testManagedFlowModWithTag(){
  VLANSlicer otherSlicer=new VLANSlicer();
  otherSlicer.setTagManagement(true);
  pConfig=new PortConfig();
  pConfig.setPortName(""String_Node_Str"");
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)101,true);
  pConfig.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig);
  pConfig2=new PortConfig();
  pConfig2.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)103,true);
  pConfig2.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig2);
  pConfig3=new PortConfig();
  pConfig3.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)104,true);
  pConfig3.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig3);
  pConfig5=new PortConfig();
  pConfig5.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)106,true);
  pConfig5.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig5);
  pConfig6=new PortConfig();
  pConfig6.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)107,true);
  pConfig6.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig6);
  otherSlicer.setSwitch(sw);
  OFFlowMod flowMod=new OFFlowMod();
  OFMatch match=new OFMatch();
  match.setInputPort((short)3);
  match.setDataLayerVirtualLan((short)200);
  flowMod.setMatch(match);
  List<OFAction> actions=new ArrayList<OFAction>();
  OFActionOutput out=new OFActionOutput();
  out.setPort((short)1);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH));
  List<OFFlowMod> managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
  actions.clear();
  OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
  set_vlan_vid.setVirtualLanIdentifier((short)100);
  actions.add(set_vlan_vid);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.getMatch().setDataLayerVirtualLan((short)0);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH + OFActionVirtualLanIdentifier.MINIMUM_LENGTH));
  managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
}","@Test public void testManagedFlowModWithTag(){
  VLANSlicer otherSlicer=new VLANSlicer();
  otherSlicer.setTagManagement(true);
  pConfig=new PortConfig();
  pConfig.setPortName(""String_Node_Str"");
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)101,true);
  pConfig.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig);
  pConfig2=new PortConfig();
  pConfig2.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)103,true);
  pConfig2.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig2);
  pConfig3=new PortConfig();
  pConfig3.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)104,true);
  pConfig3.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig3);
  pConfig5=new PortConfig();
  pConfig5.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)106,true);
  pConfig5.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig5);
  pConfig6=new PortConfig();
  pConfig6.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)107,true);
  pConfig6.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig6);
  otherSlicer.setSwitch(sw);
  OFFlowMod flowMod=new OFFlowMod();
  OFMatch match=new OFMatch();
  match.setInputPort((short)3);
  match.setDataLayerVirtualLan((short)200);
  match.setWildcards(match.getWildcardObj().matchOn(Flag.IN_PORT));
  match.setWildcards(match.getWildcardObj().matchOn(Flag.DL_VLAN));
  flowMod.setMatch(match);
  List<OFAction> actions=new ArrayList<OFAction>();
  OFActionOutput out=new OFActionOutput();
  out.setPort((short)1);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH));
  List<OFFlowMod> managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
  actions.clear();
  OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
  set_vlan_vid.setVirtualLanIdentifier((short)100);
  actions.add(set_vlan_vid);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.getMatch().setDataLayerVirtualLan((short)0);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH + OFActionVirtualLanIdentifier.MINIMUM_LENGTH));
  managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 0);
}",0.9717020391177694
25454,"@Test public void testManagedFlowMod(){
  VLANSlicer otherSlicer=new VLANSlicer();
  otherSlicer.setTagManagement(true);
  pConfig=new PortConfig();
  pConfig.setPortName(""String_Node_Str"");
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)101,true);
  pConfig.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig);
  pConfig2=new PortConfig();
  pConfig2.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)103,true);
  pConfig2.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig2);
  pConfig3=new PortConfig();
  pConfig3.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)104,true);
  pConfig3.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig3);
  pConfig5=new PortConfig();
  pConfig5.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)106,true);
  pConfig5.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig5);
  pConfig6=new PortConfig();
  pConfig6.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)107,true);
  pConfig6.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig6);
  otherSlicer.setSwitch(sw);
  OFFlowMod flowMod=new OFFlowMod();
  OFMatch match=new OFMatch();
  match.setInputPort((short)3);
  flowMod.setMatch(match);
  List<OFAction> actions=new ArrayList<OFAction>();
  OFActionOutput out=new OFActionOutput();
  out.setPort((short)1);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH));
  List<OFFlowMod> managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 1);
  OFFlowMod processedFlow=managedFlows.get(0);
  assertTrue(processedFlow.getMatch().getDataLayerVirtualLan() == 104);
  List<OFAction> processedActions=processedFlow.getActions();
  assertTrue(processedActions.size() == 2);
  assertTrue(processedActions.get(0).getType() == OFActionType.SET_VLAN_ID);
  OFActionVirtualLanIdentifier set_vlan_vid=(OFActionVirtualLanIdentifier)processedActions.get(0);
  assertTrue(set_vlan_vid.getVirtualLanIdentifier() == 101);
}","@Test public void testManagedFlowMod(){
  VLANSlicer otherSlicer=new VLANSlicer();
  otherSlicer.setTagManagement(true);
  pConfig=new PortConfig();
  pConfig.setPortName(""String_Node_Str"");
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)101,true);
  pConfig.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig);
  pConfig2=new PortConfig();
  pConfig2.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)103,true);
  pConfig2.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig2);
  pConfig3=new PortConfig();
  pConfig3.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)104,true);
  pConfig3.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig3);
  pConfig5=new PortConfig();
  pConfig5.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)106,true);
  pConfig5.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig5);
  pConfig6=new PortConfig();
  pConfig6.setPortName(""String_Node_Str"");
  range=new VLANRange();
  range.setVlanAvail((short)107,true);
  pConfig6.setVLANRange(range);
  otherSlicer.setPortConfig(""String_Node_Str"",pConfig6);
  otherSlicer.setSwitch(sw);
  OFFlowMod flowMod=new OFFlowMod();
  OFMatch match=new OFMatch();
  match.setInputPort((short)3);
  match.setWildcards(match.getWildcardObj().matchOn(Flag.IN_PORT));
  flowMod.setMatch(match);
  List<OFAction> actions=new ArrayList<OFAction>();
  OFActionOutput out=new OFActionOutput();
  out.setPort((short)1);
  actions.add(out);
  flowMod.setActions(actions);
  flowMod.setLength((short)(OFFlowMod.MINIMUM_LENGTH + OFActionOutput.MINIMUM_LENGTH));
  List<OFFlowMod> managedFlows=otherSlicer.managedFlows(flowMod);
  assertTrue(managedFlows.size() == 1);
  OFFlowMod processedFlow=managedFlows.get(0);
  assertTrue(processedFlow.getMatch().getDataLayerVirtualLan() == 104);
  List<OFAction> processedActions=processedFlow.getActions();
  assertTrue(processedActions.size() == 2);
  assertTrue(processedActions.get(0).getType() == OFActionType.SET_VLAN_ID);
  OFActionVirtualLanIdentifier set_vlan_vid=(OFActionVirtualLanIdentifier)processedActions.get(0);
  assertTrue(set_vlan_vid.getVirtualLanIdentifier() == 101);
}",0.985022026431718
25455,"@Override public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
  floodlightProvider.addOFSwitchListener(this);
  floodlightProvider.addOFMessageListener(OFType.BARRIER_REPLY,this);
  floodlightProvider.addOFMessageListener(OFType.PACKET_IN,this);
  floodlightProvider.addOFMessageListener(OFType.PORT_MOD,this);
  floodlightProvider.addOFMessageListener(OFType.PORT_STATUS,this);
  floodlightProvider.addOFMessageListener(OFType.ERROR,this);
  switches=new ArrayList<IOFSwitch>();
  statsTimer=new Timer(""String_Node_Str"");
  statsCacher=new FlowStatCacher(this);
  statsTimer.scheduleAtFixedRate(statsCacher,0,10 * 1000);
  controllerConnectTimer=new Timer(""String_Node_Str"");
  controllerConnector=new ControllerConnector();
  controllerConnectTimer.scheduleAtFixedRate(controllerConnector,0,10 * 1000);
  restApi.addRestletRoutable(new FlowSpaceFirewallWebRoutable());
}","@Override public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
  floodlightProvider.addOFSwitchListener(this);
  floodlightProvider.addOFMessageListener(OFType.BARRIER_REPLY,this);
  floodlightProvider.addOFMessageListener(OFType.PACKET_IN,this);
  floodlightProvider.addOFMessageListener(OFType.PORT_MOD,this);
  floodlightProvider.addOFMessageListener(OFType.PORT_STATUS,this);
  floodlightProvider.addOFMessageListener(OFType.ERROR,this);
  floodlightProvider.addOFMessageListener(OFType.FLOW_REMOVED,this);
  switches=new ArrayList<IOFSwitch>();
  statsTimer=new Timer(""String_Node_Str"");
  statsCacher=new FlowStatCacher(this);
  statsTimer.scheduleAtFixedRate(statsCacher,0,10 * 1000);
  controllerConnectTimer=new Timer(""String_Node_Str"");
  controllerConnector=new ControllerConnector();
  controllerConnectTimer.scheduleAtFixedRate(controllerConnector,0,10 * 1000);
  restApi.addRestletRoutable(new FlowSpaceFirewallWebRoutable());
}",0.963395225464191
25456,"public FlowTimeout(OFFlowMod flow,int timeout,boolean hard){
  this.flow=flow;
  this.hard=hard;
  this.expires=new Timestamp(System.currentTimeMillis() + (timeout * 1000));
  log.error(""String_Node_Str"" + this.expires.toString());
  this.timeout=timeout;
  this.packetCount=0;
}","public FlowTimeout(OFFlowMod flow,int timeout,boolean hard,FloodlightContext context){
  this.flow=flow;
  this.hard=hard;
  this.context=context;
  this.expires=new Timestamp(System.currentTimeMillis() + (timeout * 1000));
  log.error(""String_Node_Str"" + this.expires.toString());
  this.timeout=timeout;
  this.packetCount=0;
}",0.9177631578947368
25457,"@Override @LogMessageDocs({@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"" + ""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"" + ""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_CONTROLLER),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"" + ""String_Node_Str"",recommendation=LogMessageDoc.CHECK_CONTROLLER),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.GENERIC_ACTION)}) public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  if (e.getCause() instanceof ReadTimeoutException) {
    log.error(""String_Node_Str"",this.proxy.getSlicer().getSliceName(),this.proxy.getSlicer().getControllerAddress().toString());
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof HandshakeTimeoutException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"");
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof ClosedChannelException) {
    log.debug(""String_Node_Str"");
  }
 else   if (e.getCause() instanceof IOException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",e.getCause().getMessage());
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",e.getCause());
    }
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof SwitchStateException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",this.proxy.getSlicer().getSliceName(),e.getCause().getMessage());
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",e.getCause());
    }
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof MessageParseException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",e.getCause());
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof StorageException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",e.getCause());
  }
 else   if (e.getCause() instanceof RejectedExecutionException) {
    log.warn(""String_Node_Str"");
  }
 else {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str""+ this.state,e.getCause());
    ctx.getChannel().close();
  }
}","@Override @LogMessageDocs({@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"" + ""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"" + ""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_SWITCH),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.CHECK_CONTROLLER),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"",explanation=""String_Node_Str"" + ""String_Node_Str"",recommendation=LogMessageDoc.CHECK_CONTROLLER),@LogMessageDoc(level=""String_Node_Str"",message=""String_Node_Str"" + ""String_Node_Str"",explanation=""String_Node_Str"",recommendation=LogMessageDoc.GENERIC_ACTION)}) public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  if (e.getCause() instanceof ReadTimeoutException) {
    log.error(""String_Node_Str"",this.proxy.getSlicer().getSliceName(),this.proxy.getSlicer().getControllerAddress().toString());
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof HandshakeTimeoutException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"");
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof ClosedChannelException) {
    log.debug(""String_Node_Str"");
  }
 else   if (e.getCause() instanceof IOException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",e.getCause().getMessage());
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",e.getCause());
    }
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof SwitchStateException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",this.proxy.getSlicer().getSliceName(),e.getCause().getMessage());
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",e.getCause());
    }
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof MessageParseException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",e.getCause());
    ctx.getChannel().close();
  }
 else   if (e.getCause() instanceof StorageException) {
    log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str"",e.getCause());
  }
 else   if (e.getCause() instanceof RejectedExecutionException) {
    log.warn(""String_Node_Str"");
  }
 else {
    try {
      log.error(""String_Node_Str"" + this.proxy.getSlicer().getSliceName() + ""String_Node_Str""+ this.proxy.getSlicer().getControllerAddress().toString()+ ""String_Node_Str""+ this.state,e.getCause());
    }
 catch (    NullPointerException bad) {
      log.error(""String_Node_Str"" + bad.getMessage());
      ctx.getChannel().close();
    }
    ctx.getChannel().close();
  }
}",0.9735521497355216
25458,"private void processFlowMod(OFMessage msg,FloodlightContext cntx){
  List<OFFlowMod> flows;
  if (this.mySlicer.getTagManagement()) {
    flows=this.mySlicer.managedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
 else {
    flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
        OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
        error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
        this.sendError((OFMessage)msg,error);
        return;
      }
    if (this.mySlicer.doTimeouts()) {
      if (flow.getIdleTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false);
        this.timeouts.add(timeout);
        flow.setIdleTimeout((short)0);
      }
      if (flow.getHardTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true);
        this.timeouts.add(timeout);
        flow.setHardTimeout((short)0);
      }
    }
  this.updateFlowCount(1);
break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
this.sendError((OFMessage)msg,error);
return;
}
if (this.mySlicer.doTimeouts()) {
if (flow.getIdleTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false);
this.timeouts.add(timeout);
flow.setIdleTimeout((short)0);
}
if (flow.getHardTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true);
this.timeouts.add(timeout);
flow.setHardTimeout((short)0);
}
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
messages.add((OFMessage)flow);
}
log.error(""String_Node_Str"" + messages.toString());
mapXids(messages);
try {
mySwitch.write(messages,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}","private void processFlowMod(OFMessage msg,FloodlightContext cntx){
  List<OFFlowMod> flows;
  if (this.mySlicer.getTagManagement()) {
    flows=this.mySlicer.managedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
 else {
    flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
    if (flows.size() == 0) {
      log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
      OFError error=new OFError(OFError.OFErrorType.OFPET_BAD_REQUEST);
      error.setErrorCode(OFBadRequestCode.OFPBRC_EPERM);
      this.sendError((OFMessage)msg,error);
      return;
    }
 else {
      log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    }
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
        OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
        error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
        this.sendError((OFMessage)msg,error);
        return;
      }
    if (this.mySlicer.doTimeouts()) {
      if (flow.getIdleTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false,cntx);
        this.timeouts.add(timeout);
        flow.setIdleTimeout((short)0);
      }
      if (flow.getHardTimeout() != 0) {
        FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true,cntx);
        this.timeouts.add(timeout);
        flow.setHardTimeout((short)0);
      }
    }
  this.updateFlowCount(1);
break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
OFError error=new OFError(OFError.OFErrorType.OFPET_FLOW_MOD_FAILED);
error.setErrorCode(OFError.OFFlowModFailedCode.OFPFMFC_ALL_TABLES_FULL);
this.sendError((OFMessage)msg,error);
return;
}
if (this.mySlicer.doTimeouts()) {
if (flow.getIdleTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getIdleTimeout(),false,cntx);
this.timeouts.add(timeout);
flow.setIdleTimeout((short)0);
}
if (flow.getHardTimeout() != 0) {
FlowTimeout timeout=new FlowTimeout(flow,flow.getHardTimeout(),true,cntx);
this.timeouts.add(timeout);
flow.setHardTimeout((short)0);
}
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
messages.add((OFMessage)flow);
}
log.error(""String_Node_Str"" + messages.toString());
mapXids(messages);
try {
mySwitch.write(messages,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}",0.9973067600323188
25459,"public void checkExpiredFlows(){
  log.debug(""String_Node_Str"");
  Iterator<FlowTimeout> it=this.timeouts.iterator();
  while (it.hasNext()) {
    FlowTimeout timeout=it.next();
    if (timeout.isExpired()) {
      log.debug(""String_Node_Str"");
      it.remove();
      OFFlowMod flow=timeout.getFlow();
      flow.setCommand(OFFlowMod.OFPFC_DELETE_STRICT);
      List<OFAction> actions=new ArrayList<OFAction>();
      flow.setActions(actions);
      flow.setHardTimeout((short)0);
      flow.setIdleTimeout((short)0);
      this.toSwitch((OFMessage)flow,null);
    }
  }
}","public void checkExpiredFlows(){
  log.debug(""String_Node_Str"");
  Iterator<FlowTimeout> it=this.timeouts.iterator();
  while (it.hasNext()) {
    FlowTimeout timeout=it.next();
    if (timeout.isExpired()) {
      log.debug(""String_Node_Str"");
      it.remove();
      OFFlowMod flow=timeout.getFlow();
      flow.setOutPort(OFPort.OFPP_NONE);
      flow.setCommand(OFFlowMod.OFPFC_DELETE);
      List<OFAction> actions=new ArrayList<OFAction>();
      flow.setActions(actions);
      flow.setHardTimeout((short)0);
      flow.setIdleTimeout((short)0);
      flow.setFlags(OFFlowMod.OFPFF_SEND_FLOW_REM);
      this.toSwitch((OFMessage)flow,timeout.getContext());
    }
  }
}",0.8752
25460,"@Test public void testFlowTimeoutInit(){
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),10,false);
  assertNotNull(""String_Node_Str"",timeout);
  assertTrue(""String_Node_Str"",timeout.isHard() == false);
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 0);
  assertTrue(""String_Node_Str"",timeout.isExpired() == false);
  timeout=new FlowTimeout(new OFFlowMod(),100,true);
  assertNotNull(""String_Node_Str"",timeout);
  assertTrue(""String_Node_Str"",timeout.isHard());
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 0);
  assertTrue(""String_Node_Str"",timeout.isExpired() == false);
}","@Test public void testFlowTimeoutInit(){
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),10,false,null);
  assertNotNull(""String_Node_Str"",timeout);
  assertTrue(""String_Node_Str"",timeout.isHard() == false);
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 0);
  assertTrue(""String_Node_Str"",timeout.isExpired() == false);
  timeout=new FlowTimeout(new OFFlowMod(),100,true,null);
  assertNotNull(""String_Node_Str"",timeout);
  assertTrue(""String_Node_Str"",timeout.isHard());
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 0);
  assertTrue(""String_Node_Str"",timeout.isExpired() == false);
}",0.9918300653594772
25461,"@Test public void testFlowTimeoutSetPacketCount(){
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),1,false);
  timeout.setPacketCount((long)100);
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 100);
  timeout.setPacketCount((long)1000);
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 1000);
}","@Test public void testFlowTimeoutSetPacketCount(){
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),1,false,null);
  timeout.setPacketCount((long)100);
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 100);
  timeout.setPacketCount((long)1000);
  assertTrue(""String_Node_Str"",timeout.getPacketCount() == 1000);
}",0.9922958397534668
25462,"@Test public void testFlowTimeoutTimeout() throws InterruptedException {
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),1,false);
  assertFalse(""String_Node_Str"",timeout.isExpired());
  Thread.sleep(2000);
  assertTrue(""String_Node_Str"",timeout.isExpired());
}","@Test public void testFlowTimeoutTimeout() throws InterruptedException {
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),1,false,null);
  assertFalse(""String_Node_Str"",timeout.isExpired());
  Thread.sleep(2000);
  assertTrue(""String_Node_Str"",timeout.isExpired());
}",0.9907235621521336
25463,"@Test public void testFlowTimeoutUpdateLastUsed() throws InterruptedException {
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),10,false);
  assertFalse(""String_Node_Str"",timeout.isExpired());
  Thread.sleep(5000);
  timeout.updateLastUsed();
  Thread.sleep(7000);
  assertFalse(""String_Node_Str"",timeout.isExpired());
  Thread.sleep(4000);
  assertTrue(""String_Node_Str"",timeout.isExpired());
}","@Test public void testFlowTimeoutUpdateLastUsed() throws InterruptedException {
  FlowTimeout timeout=new FlowTimeout(new OFFlowMod(),10,false,null);
  assertFalse(""String_Node_Str"",timeout.isExpired());
  Thread.sleep(5000);
  timeout.updateLastUsed();
  Thread.sleep(7000);
  assertFalse(""String_Node_Str"",timeout.isExpired());
  Thread.sleep(4000);
  assertTrue(""String_Node_Str"",timeout.isExpired());
}",0.9938042131350682
25464,"public void checkExpiredFlows(){
  log.debug(""String_Node_Str"");
  Iterator<FlowTimeout> it=this.timeouts.iterator();
  while (it.hasNext()) {
    FlowTimeout timeout=it.next();
    if (timeout.isExpired()) {
      log.debug(""String_Node_Str"");
      it.remove();
      OFFlowMod flow=timeout.getFlow();
      flow.setOutPort(OFPort.OFPP_NONE);
      flow.setCommand(OFFlowMod.OFPFC_DELETE);
      List<OFAction> actions=new ArrayList<OFAction>();
      flow.setActions(actions);
      flow.setHardTimeout((short)0);
      flow.setIdleTimeout((short)0);
      flow.setFlags(OFFlowMod.OFPFF_SEND_FLOW_REM);
      this.toSwitch((OFMessage)flow,timeout.getContext());
    }
  }
}","public void checkExpiredFlows(){
  log.debug(""String_Node_Str"");
  Iterator<FlowTimeout> it=this.timeouts.iterator();
  while (it.hasNext()) {
    FlowTimeout timeout=it.next();
    if (timeout.isExpired()) {
      log.debug(""String_Node_Str"");
      it.remove();
      OFFlowMod flow=timeout.getFlow();
      flow.setOutPort(OFPort.OFPP_NONE);
      flow.setCommand(OFFlowMod.OFPFC_DELETE_STRICT);
      flow.setHardTimeout((short)0);
      flow.setIdleTimeout((short)0);
      flow.setFlags(OFFlowMod.OFPFF_SEND_FLOW_REM);
      this.toSwitch((OFMessage)flow,timeout.getContext());
    }
  }
}",0.925255704169945
25465,"/** 
 * process an OFPacketOut message to verify that it fits in this slice properly.  We don't want one slice to be able to inject traffic into another slice erroneously
 * @param output the OFPacketOut message to be properly sliced
 */
public List<OFMessage> allowedPacketOut(OFPacketOut outPacket){
  List<OFAction> newActions=new ArrayList<OFAction>();
  List<OFAction> actions=outPacket.getActions();
  List<OFMessage> packets=new ArrayList<OFMessage>();
  Iterator<OFAction> it=actions.iterator();
  OFMatch match=new OFMatch();
  if (outPacket.getPacketData().length == 0 && outPacket.getBufferId() != 0) {
    int bufferId=outPacket.getBufferId();
    if (this.bufferIds.containsKey(bufferId)) {
      outPacket.setBufferId(OFPacketOut.BUFFER_ID_NONE);
      outPacket.setPacketData(this.bufferIds.get(bufferId));
      outPacket.setLengthU(outPacket.getLengthU() + this.bufferIds.get(bufferId).length);
    }
 else {
      return packets;
    }
  }
  try {
    match.loadFromPacket(outPacket.getPacketData(),(short)0);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e.getMessage());
    packets.clear();
    return packets;
  }
  short curVlan=match.getDataLayerVirtualLan();
  while (it.hasNext()) {
    OFAction action=it.next();
switch (action.getType()) {
case SET_VLAN_ID:
      OFActionVirtualLanIdentifier setvid=(OFActionVirtualLanIdentifier)action;
    curVlan=setvid.getVirtualLanIdentifier();
  newActions.add(action);
break;
case OUTPUT:
OFActionOutput output=(OFActionOutput)action;
if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
log.info(""String_Node_Str"");
for (Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
PortConfig myPortCfg=this.getPortConfig(port.getValue().getPortId());
if (myPortCfg == null) {
  log.info(""String_Node_Str"" + port.getValue().getPortId());
  packets.clear();
  return packets;
}
if (!myPortCfg.vlanAllowed(curVlan)) {
  log.info(""String_Node_Str"" + port.getValue().getPortId() + ""String_Node_Str""+ curVlan);
  packets.clear();
  return packets;
}
log.debug(""String_Node_Str"" + port.getValue().getPortId());
List<OFAction> actualActions=new ArrayList<OFAction>();
actualActions.addAll(newActions);
OFPacketOut newOut=this.clonePacketOut(outPacket);
OFActionOutput newOutput=new OFActionOutput();
newOutput.setMaxLength(Short.MAX_VALUE);
newOutput.setType(OFActionType.OUTPUT);
newOutput.setLength((short)OFActionOutput.MINIMUM_LENGTH);
newOutput.setPort(port.getValue().getPortId());
actualActions.add(newOutput);
newOut.setActions(actualActions);
int size=0;
for (OFAction act : actualActions) {
  size=size + act.getLengthU();
}
newOut.setActionsLength((short)size);
packets.add(newOut);
}
}
 else if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
log.info(""String_Node_Str"");
packets.clear();
return packets;
}
 else {
PortConfig myPortCfg=this.getPortConfig(output.getPort());
if (myPortCfg == null) {
log.info(""String_Node_Str"" + output.getPort());
packets.clear();
return packets;
}
if (!myPortCfg.vlanAllowed(curVlan)) {
log.info(""String_Node_Str"" + output.getPort() + ""String_Node_Str""+ curVlan);
packets.clear();
return packets;
}
log.debug(""String_Node_Str"");
List<OFAction> actualActions=new ArrayList<OFAction>();
actualActions.addAll(newActions);
OFPacketOut newOut=this.clonePacketOut(outPacket);
actualActions.add(output);
newOut.setActions(actualActions);
int size=0;
for (OFAction act : actualActions) {
size=size + act.getLengthU();
}
newOut.setActionsLength((short)size);
packets.add(newOut);
}
break;
case STRIP_VLAN:
curVlan=0;
newActions.add(action);
break;
default :
newActions.add(action);
break;
}
}
log.debug(""String_Node_Str"" + packets.toString());
return packets;
}","/** 
 * process an OFPacketOut message to verify that it fits in this slice properly.  We don't want one slice to be able to inject traffic into another slice erroneously
 * @param output the OFPacketOut message to be properly sliced
 */
public List<OFMessage> allowedPacketOut(OFPacketOut outPacket){
  List<OFAction> newActions=new ArrayList<OFAction>();
  List<OFAction> actions=outPacket.getActions();
  List<OFMessage> packets=new ArrayList<OFMessage>();
  Iterator<OFAction> it=actions.iterator();
  OFMatch match=new OFMatch();
  if (outPacket.getPacketData().length == 0 && outPacket.getBufferId() != 0) {
    int bufferId=outPacket.getBufferId();
    if (this.bufferIds.containsKey(bufferId)) {
      outPacket.setBufferId(OFPacketOut.BUFFER_ID_NONE);
      outPacket.setPacketData(this.bufferIds.get(bufferId));
      outPacket.setLengthU(outPacket.getLengthU() + this.bufferIds.get(bufferId).length);
    }
 else {
      return packets;
    }
  }
  try {
    match.loadFromPacket(outPacket.getPacketData(),(short)0);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e.getMessage());
    packets.clear();
    return packets;
  }
  short curVlan=match.getDataLayerVirtualLan();
  while (it.hasNext()) {
    OFAction action=it.next();
switch (action.getType()) {
case SET_VLAN_ID:
      OFActionVirtualLanIdentifier setvid=(OFActionVirtualLanIdentifier)action;
    curVlan=setvid.getVirtualLanIdentifier();
  newActions.add(action);
break;
case OUTPUT:
OFActionOutput output=(OFActionOutput)action;
if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
log.info(""String_Node_Str"");
for (Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
PortConfig myPortCfg=this.getPortConfig(port.getValue().getPortId());
if (myPortCfg == null) {
  log.info(""String_Node_Str"" + port.getValue().getPortId());
  packets.clear();
  return packets;
}
if (!myPortCfg.vlanAllowed(curVlan)) {
  log.info(""String_Node_Str"" + port.getValue().getPortId() + ""String_Node_Str""+ curVlan);
  packets.clear();
  return packets;
}
log.debug(""String_Node_Str"" + port.getValue().getPortId());
List<OFAction> actualActions=new ArrayList<OFAction>();
actualActions.addAll(newActions);
OFPacketOut newOut=this.clonePacketOut(outPacket);
OFActionOutput newOutput=new OFActionOutput();
newOutput.setMaxLength(Short.MAX_VALUE);
newOutput.setType(OFActionType.OUTPUT);
newOutput.setLength((short)OFActionOutput.MINIMUM_LENGTH);
newOutput.setPort(port.getValue().getPortId());
actualActions.add(newOutput);
newOut.setActions(actualActions);
int size=0;
for (OFAction act : actualActions) {
  size=size + act.getLengthU();
}
newOut.setActionsLength((short)size);
newOut.setLength((short)(OFPacketOut.MINIMUM_LENGTH + newOut.getPacketData().length + size));
packets.add(newOut);
}
}
 else if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
log.info(""String_Node_Str"");
packets.clear();
return packets;
}
 else {
PortConfig myPortCfg=this.getPortConfig(output.getPort());
if (myPortCfg == null) {
log.info(""String_Node_Str"" + output.getPort());
packets.clear();
return packets;
}
if (!myPortCfg.vlanAllowed(curVlan)) {
log.info(""String_Node_Str"" + output.getPort() + ""String_Node_Str""+ curVlan);
packets.clear();
return packets;
}
log.debug(""String_Node_Str"");
List<OFAction> actualActions=new ArrayList<OFAction>();
actualActions.addAll(newActions);
OFPacketOut newOut=this.clonePacketOut(outPacket);
actualActions.add(output);
newOut.setActions(actualActions);
int size=0;
for (OFAction act : actualActions) {
size=size + act.getLengthU();
}
newOut.setActionsLength((short)size);
newOut.setLength((short)(OFPacketOut.MINIMUM_LENGTH + newOut.getPacketData().length + size));
packets.add(newOut);
}
break;
case STRIP_VLAN:
curVlan=0;
newActions.add(action);
break;
default :
newActions.add(action);
break;
}
}
log.debug(""String_Node_Str"" + packets.toString());
return packets;
}",0.9751388521555144
25466,"public List<OFFlowMod> managedFlowActions(OFFlowMod flowMod){
  List<OFFlowMod> newFlows=new ArrayList<OFFlowMod>();
  List<OFAction> actions=flowMod.getActions();
  List<OFAction> newActions=new ArrayList<OFAction>();
  short additional_length=0;
  for (  OFAction act : actions) {
switch (act.getType()) {
case OUTPUT:
      OFActionOutput out=(OFActionOutput)act;
    short vlanTag;
  PortConfig pConfig=this.getPortConfig(out.getPort());
if (pConfig == null) {
  newFlows.clear();
  return newFlows;
}
 else {
  vlanTag=(short)pConfig.getVlanRange().getAvailableTags()[0];
}
if (vlanTag == -1) {
OFActionStripVirtualLan strip_vlan_vid=new OFActionStripVirtualLan();
newActions.add(strip_vlan_vid);
additional_length+=strip_vlan_vid.getLength();
}
 else {
OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
set_vlan_vid.setVirtualLanIdentifier(vlanTag);
newActions.add(set_vlan_vid);
additional_length+=set_vlan_vid.getLength();
}
newActions.add(out);
break;
case SET_VLAN_ID:
log.error(""String_Node_Str"");
newFlows.clear();
return newFlows;
case STRIP_VLAN:
log.error(""String_Node_Str"");
newFlows.clear();
return newFlows;
default :
newActions.add(act);
break;
}
}
flowMod.setActions(newActions);
flowMod.setLength((short)(flowMod.getLength() + additional_length));
newFlows.add(flowMod);
return newFlows;
}","public List<OFFlowMod> managedFlowActions(OFFlowMod flowMod){
  List<OFFlowMod> newFlows=new ArrayList<OFFlowMod>();
  List<OFAction> actions=flowMod.getActions();
  List<OFAction> newActions=new ArrayList<OFAction>();
  short additional_length=0;
  for (  OFAction act : actions) {
switch (act.getType()) {
case OUTPUT:
      OFActionOutput out=(OFActionOutput)act;
    short vlanTag;
  if (out.getPort() == OFPort.OFPP_CONTROLLER.getValue()) {
    newActions.add(out);
    break;
  }
if (out.getPort() == OFPort.OFPP_ALL.getValue()) {
  Iterator<Entry<String,PortConfig>> it=this.portList.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<String,PortConfig> port=(Entry<String,PortConfig>)it.next();
    if (port.getValue().getPortId() != 0) {
      PortConfig pConfig=this.getPortConfig(port.getValue().getPortId());
      vlanTag=(short)pConfig.getVlanRange().getAvailableTags()[0];
      if (vlanTag == -1) {
        OFActionStripVirtualLan strip_vlan_vid=new OFActionStripVirtualLan();
        newActions.add(strip_vlan_vid);
        additional_length+=strip_vlan_vid.getLength();
      }
 else {
        OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
        set_vlan_vid.setVirtualLanIdentifier(vlanTag);
        newActions.add(set_vlan_vid);
        additional_length+=set_vlan_vid.getLength();
      }
      OFActionOutput newOut=new OFActionOutput();
      out.setPort(port.getValue().getPortId());
      newActions.add(newOut);
      additional_length+=newOut.getLength();
    }
  }
  additional_length-=out.getLengthU();
  break;
}
PortConfig pConfig=this.getPortConfig(out.getPort());
if (pConfig == null) {
newFlows.clear();
return newFlows;
}
 else {
vlanTag=(short)pConfig.getVlanRange().getAvailableTags()[0];
}
if (vlanTag == -1) {
OFActionStripVirtualLan strip_vlan_vid=new OFActionStripVirtualLan();
newActions.add(strip_vlan_vid);
additional_length+=strip_vlan_vid.getLength();
}
 else {
OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
set_vlan_vid.setVirtualLanIdentifier(vlanTag);
newActions.add(set_vlan_vid);
additional_length+=set_vlan_vid.getLength();
}
newActions.add(out);
break;
case SET_VLAN_ID:
log.error(""String_Node_Str"");
newFlows.clear();
return newFlows;
case STRIP_VLAN:
log.error(""String_Node_Str"");
newFlows.clear();
return newFlows;
default :
newActions.add(act);
break;
}
}
flowMod.setActions(newActions);
flowMod.setLength((short)(flowMod.getLength() + additional_length));
newFlows.add(flowMod);
return newFlows;
}",0.6506459948320413
25467,"public List<OFMessage> managedPacketOut(OFPacketOut outPacket){
  List<OFAction> newActions=new ArrayList<OFAction>();
  List<OFAction> actions=outPacket.getActions();
  List<OFMessage> packets=new ArrayList<OFMessage>();
  Iterator<OFAction> it=actions.iterator();
  OFMatch match=new OFMatch();
  if (outPacket.getPacketData().length == 0 && outPacket.getBufferId() != 0) {
    int bufferId=outPacket.getBufferId();
    if (this.bufferIds.containsKey(bufferId)) {
      outPacket.setBufferId(OFPacketOut.BUFFER_ID_NONE);
      outPacket.setPacketData(this.bufferIds.get(bufferId));
      outPacket.setLengthU(outPacket.getLengthU() + this.bufferIds.get(bufferId).length);
    }
 else {
      return packets;
    }
  }
  try {
    match.loadFromPacket(outPacket.getPacketData(),(short)0);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e.getMessage());
    packets.clear();
    return packets;
  }
  log.error(""String_Node_Str"" + match.getDataLayerVirtualLan());
  if (match.getDataLayerVirtualLan() != -1) {
    log.error(""String_Node_Str"");
    packets.clear();
    return packets;
  }
  while (it.hasNext()) {
    OFAction action=it.next();
switch (action.getType()) {
case SET_VLAN_ID:
      packets.clear();
    return packets;
case OUTPUT:
  OFActionOutput output=(OFActionOutput)action;
if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
  log.info(""String_Node_Str"");
  for (  Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
    PortConfig myPortCfg=this.getPortConfig(port.getValue().getPortId());
    if (myPortCfg == null) {
      log.info(""String_Node_Str"" + port.getValue().getPortId());
      packets.clear();
      return packets;
    }
    List<OFAction> actualActions=new ArrayList<OFAction>();
    actualActions.addAll(newActions);
    OFPacketOut newOut=this.clonePacketOut(outPacket);
    OFActionOutput newOutput=new OFActionOutput();
    newOutput.setMaxLength(Short.MAX_VALUE);
    newOutput.setType(OFActionType.OUTPUT);
    newOutput.setLength((short)OFActionOutput.MINIMUM_LENGTH);
    newOutput.setPort(port.getValue().getPortId());
    OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
    set_vlan_vid.setVirtualLanIdentifier(myPortCfg.getVlanRange().getAvailableTags()[0]);
    actualActions.add(set_vlan_vid);
    actualActions.add(newOutput);
    newOut.setActions(actualActions);
    int size=0;
    for (    OFAction act : actualActions) {
      size=size + act.getLengthU();
    }
    newOut.setActionsLength((short)size);
    packets.add(newOut);
  }
}
 else if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
  log.info(""String_Node_Str"");
  packets.clear();
  return packets;
}
 else {
  PortConfig myPortCfg=this.getPortConfig(output.getPort());
  if (myPortCfg == null) {
    log.info(""String_Node_Str"" + output.getPort());
    packets.clear();
    return packets;
  }
  log.error(""String_Node_Str"");
  List<OFAction> actualActions=new ArrayList<OFAction>();
  actualActions.addAll(newActions);
  OFPacketOut newOut=this.clonePacketOut(outPacket);
  OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
  set_vlan_vid.setVirtualLanIdentifier(myPortCfg.getVlanRange().getAvailableTags()[0]);
  actualActions.add(set_vlan_vid);
  actualActions.add(output);
  newOut.setActions(actualActions);
  int size=0;
  for (  OFAction act : actualActions) {
    size=size + act.getLengthU();
  }
  newOut.setActionsLength((short)size);
  packets.add(newOut);
}
break;
case STRIP_VLAN:
packets.clear();
return packets;
default :
newActions.add(action);
break;
}
}
log.debug(""String_Node_Str"" + packets.toString());
return packets;
}","public List<OFMessage> managedPacketOut(OFPacketOut outPacket){
  List<OFAction> newActions=new ArrayList<OFAction>();
  List<OFAction> actions=outPacket.getActions();
  List<OFMessage> packets=new ArrayList<OFMessage>();
  Iterator<OFAction> it=actions.iterator();
  OFMatch match=new OFMatch();
  if (outPacket.getPacketData().length == 0 && outPacket.getBufferId() != 0) {
    int bufferId=outPacket.getBufferId();
    if (this.bufferIds.containsKey(bufferId)) {
      outPacket.setBufferId(OFPacketOut.BUFFER_ID_NONE);
      outPacket.setPacketData(this.bufferIds.get(bufferId));
      outPacket.setLengthU(outPacket.getLengthU() + this.bufferIds.get(bufferId).length);
    }
 else {
      return packets;
    }
  }
  try {
    match.loadFromPacket(outPacket.getPacketData(),(short)0);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e.getMessage());
    packets.clear();
    return packets;
  }
  log.error(""String_Node_Str"" + match.getDataLayerVirtualLan());
  if (match.getDataLayerVirtualLan() != -1) {
    log.error(""String_Node_Str"");
    packets.clear();
    return packets;
  }
  while (it.hasNext()) {
    OFAction action=it.next();
switch (action.getType()) {
case SET_VLAN_ID:
      packets.clear();
    return packets;
case OUTPUT:
  OFActionOutput output=(OFActionOutput)action;
if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
  log.info(""String_Node_Str"");
  for (  Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
    PortConfig myPortCfg=this.getPortConfig(port.getValue().getPortId());
    if (myPortCfg == null) {
      log.info(""String_Node_Str"" + port.getValue().getPortId());
      packets.clear();
      return packets;
    }
    List<OFAction> actualActions=new ArrayList<OFAction>();
    actualActions.addAll(newActions);
    OFPacketOut newOut=this.clonePacketOut(outPacket);
    OFActionOutput newOutput=new OFActionOutput();
    newOutput.setMaxLength(Short.MAX_VALUE);
    newOutput.setType(OFActionType.OUTPUT);
    newOutput.setLength((short)OFActionOutput.MINIMUM_LENGTH);
    newOutput.setPort(port.getValue().getPortId());
    OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
    set_vlan_vid.setVirtualLanIdentifier(myPortCfg.getVlanRange().getAvailableTags()[0]);
    actualActions.add(set_vlan_vid);
    actualActions.add(newOutput);
    newOut.setActions(actualActions);
    int size=0;
    for (    OFAction act : actualActions) {
      size=size + act.getLengthU();
    }
    newOut.setActionsLength((short)size);
    newOut.setLength((short)(OFPacketOut.MINIMUM_LENGTH + newOut.getPacketData().length + size));
    packets.add(newOut);
  }
}
 else if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
  log.info(""String_Node_Str"");
  packets.clear();
  return packets;
}
 else {
  PortConfig myPortCfg=this.getPortConfig(output.getPort());
  if (myPortCfg == null) {
    log.info(""String_Node_Str"" + output.getPort());
    packets.clear();
    return packets;
  }
  log.error(""String_Node_Str"");
  List<OFAction> actualActions=new ArrayList<OFAction>();
  actualActions.addAll(newActions);
  OFPacketOut newOut=this.clonePacketOut(outPacket);
  OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
  set_vlan_vid.setVirtualLanIdentifier(myPortCfg.getVlanRange().getAvailableTags()[0]);
  actualActions.add(set_vlan_vid);
  actualActions.add(output);
  newOut.setActions(actualActions);
  int size=0;
  for (  OFAction act : actualActions) {
    size=size + act.getLengthU();
  }
  newOut.setActionsLength((short)size);
  newOut.setLength((short)(OFPacketOut.MINIMUM_LENGTH + newOut.getPacketData().length + size));
  packets.add(newOut);
}
break;
case STRIP_VLAN:
packets.clear();
return packets;
default :
newActions.add(action);
break;
}
}
log.debug(""String_Node_Str"" + packets.toString());
return packets;
}",0.9741333333333332
25468,"public List<OFFlowMod> managedFlows(OFFlowMod flowMod){
  log.debug(""String_Node_Str"" + flowMod.toString() + ""String_Node_Str"");
  List<OFFlowMod> flows=new ArrayList<OFFlowMod>();
  OFMatch match=flowMod.getMatch();
  if (match == null) {
    return flows;
  }
  if (match.getDataLayerVirtualLan() == 0 || match.getDataLayerVirtualLan() == -1) {
    if (match.getInputPort() == 0) {
      Iterator<Entry<String,PortConfig>> it=this.portList.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,PortConfig> port=(Entry<String,PortConfig>)it.next();
        if (port.getValue().getPortId() != 0) {
          try {
            OFFlowMod newFlow=flowMod.clone();
            newFlow.getMatch().setInputPort(port.getValue().getPortId());
            newFlow.getMatch().setDataLayerVirtualLan(port.getValue().getVlanRange().getAvailableTags()[0]);
            List<OFFlowMod> newFlows=this.managedFlowActions(newFlow);
            for (            OFFlowMod flow : newFlows) {
              flows.add(flow);
            }
          }
 catch (          CloneNotSupportedException e) {
            flows.clear();
            return flows;
          }
catch (          Exception e) {
            flows.clear();
            return flows;
          }
        }
      }
    }
 else {
      match.setDataLayerVirtualLan((short)this.getPortConfig(match.getInputPort()).getVlanRange().getAvailableTags()[0]);
      flowMod.setMatch(match);
      flows=this.managedFlowActions(flowMod);
    }
  }
 else {
    log.debug(""String_Node_Str"" + flowMod.toString());
    return flows;
  }
  return flows;
}","public List<OFFlowMod> managedFlows(OFFlowMod flowMod){
  log.debug(""String_Node_Str"" + flowMod.toString() + ""String_Node_Str"");
  List<OFFlowMod> flows=new ArrayList<OFFlowMod>();
  OFMatch match=flowMod.getMatch();
  if (match == null) {
    return flows;
  }
  if (match.getDataLayerVirtualLan() == 0 || match.getDataLayerVirtualLan() == -1) {
    if (match.getInputPort() == 0) {
      Iterator<Entry<String,PortConfig>> it=this.portList.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<String,PortConfig> port=(Entry<String,PortConfig>)it.next();
        if (port.getValue().getPortId() != 0) {
          try {
            OFFlowMod newFlow=flowMod.clone();
            newFlow.getMatch().setInputPort(port.getValue().getPortId());
            newFlow.getMatch().setDataLayerVirtualLan(port.getValue().getVlanRange().getAvailableTags()[0]);
            List<OFFlowMod> newFlows=this.managedFlowActions(newFlow);
            for (            OFFlowMod flow : newFlows) {
              flows.add(flow);
            }
          }
 catch (          CloneNotSupportedException e) {
            flows.clear();
            return flows;
          }
catch (          Exception e) {
            flows.clear();
            return flows;
          }
        }
      }
    }
 else {
      short vlanId;
      PortConfig pConfig=this.getPortConfig(match.getInputPort());
      if (pConfig == null) {
        flows.clear();
        return flows;
      }
 else {
        vlanId=(short)pConfig.getVlanRange().getAvailableTags()[0];
      }
      match.setDataLayerVirtualLan(vlanId);
      flowMod.setMatch(match);
      flows=this.managedFlowActions(flowMod);
    }
  }
 else {
    log.debug(""String_Node_Str"" + flowMod.toString());
    return flows;
  }
  return flows;
}",0.9147744028310232
25469,"public List<OFFlowMod> managedFlowActions(OFFlowMod flowMod){
  List<OFFlowMod> newFlows=new ArrayList<OFFlowMod>();
  List<OFAction> actions=flowMod.getActions();
  List<OFAction> newActions=new ArrayList<OFAction>();
  short additional_length=0;
  for (  OFAction act : actions) {
switch (act.getType()) {
case OUTPUT:
      OFActionOutput out=(OFActionOutput)act;
    short vlanTag=(short)this.getPortConfig(out.getPort()).getVlanRange().getAvailableTags()[0];
  if (vlanTag == -1) {
    OFActionStripVirtualLan strip_vlan_vid=new OFActionStripVirtualLan();
    newActions.add(strip_vlan_vid);
    additional_length+=strip_vlan_vid.getLength();
  }
 else {
    OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
    set_vlan_vid.setVirtualLanIdentifier(vlanTag);
    newActions.add(set_vlan_vid);
    additional_length+=set_vlan_vid.getLength();
  }
newActions.add(out);
break;
case SET_VLAN_ID:
return newFlows;
case STRIP_VLAN:
return newFlows;
default :
newActions.add(act);
break;
}
}
OFFlowMod newFlow=new OFFlowMod();
newFlow.setMatch(flowMod.getMatch());
newFlow.setActions(newActions);
newFlow.setLength((short)(flowMod.getLength() + additional_length));
newFlows.add(newFlow);
return newFlows;
}","public List<OFFlowMod> managedFlowActions(OFFlowMod flowMod){
  List<OFFlowMod> newFlows=new ArrayList<OFFlowMod>();
  List<OFAction> actions=flowMod.getActions();
  List<OFAction> newActions=new ArrayList<OFAction>();
  short additional_length=0;
  for (  OFAction act : actions) {
switch (act.getType()) {
case OUTPUT:
      OFActionOutput out=(OFActionOutput)act;
    short vlanTag;
  PortConfig pConfig=this.getPortConfig(out.getPort());
if (pConfig == null) {
  return newFlows;
}
 else {
  vlanTag=(short)pConfig.getVlanRange().getAvailableTags()[0];
}
if (vlanTag == -1) {
OFActionStripVirtualLan strip_vlan_vid=new OFActionStripVirtualLan();
newActions.add(strip_vlan_vid);
additional_length+=strip_vlan_vid.getLength();
}
 else {
OFActionVirtualLanIdentifier set_vlan_vid=new OFActionVirtualLanIdentifier();
set_vlan_vid.setVirtualLanIdentifier(vlanTag);
newActions.add(set_vlan_vid);
additional_length+=set_vlan_vid.getLength();
}
newActions.add(out);
break;
case SET_VLAN_ID:
return newFlows;
case STRIP_VLAN:
return newFlows;
default :
newActions.add(act);
break;
}
}
OFFlowMod newFlow=new OFFlowMod();
newFlow.setMatch(flowMod.getMatch());
newFlow.setActions(newActions);
newFlow.setLength((short)(flowMod.getLength() + additional_length));
newFlows.add(newFlow);
return newFlows;
}",0.90707789640174
25470,"/** 
 * test creating the vlan range based on an array of shorts and allowed or not allowed
 */
@Test public void testParamInitFalse(){
  short[] allowed=new short[10];
  allowed[0]=1;
  allowed[1]=150;
  allowed[2]=2;
  allowed[3]=4;
  allowed[4]=4095;
  allowed[5]=-1;
  allowed[6]=5;
  allowed[7]=100;
  allowed[8]=1000;
  allowed[9]=4000;
  VLANRange range=new VLANRange(allowed,false);
  assertNotNull(""String_Node_Str"",range);
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)1));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)1000));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)2));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)3));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)101));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)4000));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)4095));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)150));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)-1));
}","/** 
 * test creating the vlan range based on an array of shorts and allowed or not allowed
 */
@Test public void testParamInitFalse(){
  short[] allowed=new short[10];
  allowed[0]=1;
  allowed[1]=150;
  allowed[2]=2;
  allowed[3]=4;
  allowed[4]=4095;
  allowed[5]=-1;
  allowed[6]=5;
  allowed[7]=100;
  allowed[8]=1000;
  allowed[9]=4000;
  VLANRange range=new VLANRange(allowed,false);
  assertNotNull(""String_Node_Str"",range);
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)1));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)1000));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)2));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)3));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)101));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)4000));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)4095));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)150));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)-1));
  Short[] avail=range.getAvailableTags();
  assertTrue(avail.length == 4086);
  assertTrue(avail[0] == 3);
  assertTrue(avail[1] == 6);
  assertTrue(avail[2] == 7);
  assertTrue(avail[3] == 8);
}",0.9126126126126126
25471,"/** 
 * test creating the vlan range based on an array of shorts and allowed or not allowed
 */
@Test public void testParamInit(){
  short[] allowed=new short[10];
  allowed[0]=1;
  allowed[1]=150;
  allowed[2]=2;
  allowed[3]=4;
  allowed[4]=4095;
  allowed[5]=-1;
  allowed[6]=5;
  allowed[7]=100;
  allowed[8]=1000;
  allowed[9]=4000;
  VLANRange range=new VLANRange(allowed,true);
  assertNotNull(""String_Node_Str"",range);
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)1));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)1000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)2));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)3));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)101));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)4000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)4095));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)150));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)-1));
}","/** 
 * test creating the vlan range based on an array of shorts and allowed or not allowed
 */
@Test public void testParamInit(){
  short[] allowed=new short[10];
  allowed[0]=1;
  allowed[1]=150;
  allowed[2]=2;
  allowed[3]=4;
  allowed[4]=4095;
  allowed[5]=-1;
  allowed[6]=5;
  allowed[7]=100;
  allowed[8]=1000;
  allowed[9]=4000;
  VLANRange range=new VLANRange(allowed,true);
  assertNotNull(""String_Node_Str"",range);
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)1));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)1000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)2));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)3));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)101));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)4000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)4095));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)150));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)-1));
  Short[] avail=range.getAvailableTags();
  assertTrue(avail.length == 10);
  assertTrue(avail[0] == 1);
  assertTrue(avail[1] == 150);
  assertTrue(avail[2] == 2);
  assertTrue(avail[3] == 4);
}",0.9117379435850772
25472,"/** 
 * tests setting each vlan range independently
 */
@Test public void setVlanAvail(){
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)1,true);
  range.setVlanAvail((short)2,true);
  range.setVlanAvail((short)3,false);
  range.setVlanAvail((short)4,true);
  range.setVlanAvail((short)5,true);
  range.setVlanAvail((short)100,true);
  range.setVlanAvail((short)4000,true);
  range.setVlanAvail((short)-1,true);
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)1));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)1000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)2));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)3));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)101));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)100));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)4000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)-1));
}","/** 
 * tests setting each vlan range independently
 */
@Test public void setVlanAvail(){
  VLANRange range=new VLANRange();
  range.setVlanAvail((short)1,true);
  range.setVlanAvail((short)2,true);
  range.setVlanAvail((short)3,false);
  range.setVlanAvail((short)4,true);
  range.setVlanAvail((short)5,true);
  range.setVlanAvail((short)100,true);
  range.setVlanAvail((short)4000,true);
  range.setVlanAvail((short)-1,true);
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)1));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)1000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)2));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)3));
  assertFalse(""String_Node_Str"",range.getVlanAvail((short)101));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)100));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)4000));
  assertTrue(""String_Node_Str"",range.getVlanAvail((short)-1));
  Short[] avail=range.getAvailableTags();
  assertTrue(avail.length == 7);
  assertTrue(avail[0] == 1);
  assertTrue(avail[1] == 2);
  assertTrue(avail[2] == 4);
  assertTrue(avail[3] == 5);
  assertTrue(avail[4] == 100);
  assertTrue(avail[5] == 4000);
  assertTrue(avail[6] == -1);
}",0.8686401480111008
25473,"public boolean setSliceAdminState(Long dpid,String sliceName,boolean state){
  List<Proxy> proxies=this.controllerConnector.getSwitchProxies(dpid);
  for (  Proxy p : proxies) {
    if (p.getSlicer().getSliceName().equals(sliceName)) {
      p.setAdminStatus(state);
      return true;
    }
  }
  return false;
}","public boolean setSliceAdminState(Long dpid,String sliceName,boolean state){
  List<Proxy> proxies=this.controllerConnector.getSwitchProxies(dpid);
  for (  Proxy p : proxies) {
    if (p.getSlicer().getSliceName().equals(sliceName)) {
      logger.info(""String_Node_Str"" + sliceName + ""String_Node_Str""+ state);
      p.setAdminStatus(state);
      return true;
    }
  }
  return false;
}",0.8904694167852063
25474,"public Proxy(IOFSwitch switchImp,Slicer slicer,FlowSpaceFirewall fsf){
  mySlicer=slicer;
  mySwitch=switchImp;
  mySlicer.setSwitch(mySwitch);
  parent=fsf;
  flowCount=0;
  xidMap=new XidMap();
  adminStatus=true;
  packetInRate=new RateTracker(100,slicer.getPacketInRate());
}","public Proxy(IOFSwitch switchImp,Slicer slicer,FlowSpaceFirewall fsf){
  mySlicer=slicer;
  mySwitch=switchImp;
  mySlicer.setSwitch(mySwitch);
  parent=fsf;
  flowCount=0;
  xidMap=new XidMap();
  adminStatus=mySlicer.getAdminState();
  packetInRate=new RateTracker(100,slicer.getPacketInRate());
}",0.9515570934256056
25475,"public void setAdminStatus(Boolean status){
  adminStatus=status;
  if (status) {
    log.warn(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str"");
  }
 else {
    log.error(""String_Node_Str"" + this.mySlicer.getSliceName());
    this.removeFlows();
    this.disconnect();
  }
}","public void setAdminStatus(Boolean status){
  this.adminStatus=status;
  this.mySlicer.setAdminState(status);
  if (status) {
    log.warn(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str"");
  }
 else {
    log.error(""String_Node_Str"" + this.mySlicer.getSliceName());
    if (this.connected()) {
      this.removeFlows();
      this.disconnect();
    }
  }
}",0.8214285714285714
25476,"public void removeFlows(){
  List<OFStatistics> stats=this.parent.getStats(mySwitch.getId());
  List<OFStatistics> results=null;
  try {
    results=FlowStatSlicer.SliceStats(mySlicer,stats);
  }
 catch (  IllegalArgumentException e) {
  }
  if (results == null) {
    log.debug(""String_Node_Str"");
    return;
  }
  List<OFMessage> deletes=new ArrayList<OFMessage>();
  for (  OFStatistics stat : results) {
    OFFlowStatisticsReply flowStat=(OFFlowStatisticsReply)stat;
    OFFlowMod flow=new OFFlowMod();
    flow.setMatch(flowStat.getMatch());
    flow.setActions(flowStat.getActions());
    flow.setLengthU(OFFlowMod.MAXIMUM_LENGTH);
    flow.setCommand(OFFlowMod.OFPFC_DELETE);
    deletes.add(flow);
  }
  try {
    this.mySwitch.write(deletes,null);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void removeFlows(){
  List<OFStatistics> results=this.parent.getSlicedFlowStats(mySwitch.getId(),this.mySlicer.getSliceName());
  if (results == null) {
    log.debug(""String_Node_Str"");
    return;
  }
  List<OFMessage> deletes=new ArrayList<OFMessage>();
  for (  OFStatistics stat : results) {
    OFFlowStatisticsReply flowStat=(OFFlowStatisticsReply)stat;
    OFFlowMod flow=new OFFlowMod();
    flow.setMatch(flowStat.getMatch());
    flow.setActions(flowStat.getActions());
    int length=0;
    for (    OFAction act : flow.getActions()) {
      length+=act.getLength();
    }
    flow.setLengthU(OFFlowMod.MINIMUM_LENGTH + length);
    flow.setCommand(OFFlowMod.OFPFC_DELETE);
    deletes.add(flow);
  }
  try {
    this.mySwitch.write(deletes,null);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.8143203883495146
25477,"public VLANSlicer(){
  myRateTracker=new RateTracker(10,100);
  packetInRate=10;
  portList=new HashMap<String,PortConfig>();
  name=""String_Node_Str"";
  this.bufferIds=Collections.synchronizedMap(new LinkedHashMap<Integer,byte[]>(){
    /** 
 */
    private static final long serialVersionUID=1L;
    @Override public boolean removeEldestEntry(    Map.Entry<Integer,byte[]> eldest){
      return size() >= 1000;
    }
  }
);
}","public VLANSlicer(){
  myRateTracker=new RateTracker(10,100);
  packetInRate=10;
  portList=new HashMap<String,PortConfig>();
  name=""String_Node_Str"";
  this.adminState=true;
  this.bufferIds=Collections.synchronizedMap(new LinkedHashMap<Integer,byte[]>(){
    /** 
 */
    private static final long serialVersionUID=1L;
    @Override public boolean removeEldestEntry(    Map.Entry<Integer,byte[]> eldest){
      return size() >= 1000;
    }
  }
);
}",0.9726651480637812
25478,"private void processFlowMod(OFMessage msg,FloodlightContext cntx){
  List<OFFlowMod> flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
  if (flows.size() == 0) {
    log.info(""String_Node_Str"");
    this.sendError((OFMessage)msg);
    return;
  }
 else {
    log.info(""String_Node_Str"");
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
    messages.add((OFMessage)msg);
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
        this.sendError((OFMessage)msg);
        return;
      }
    this.updateFlowCount(1);
  break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
  log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
  this.sendError((OFMessage)msg);
  return;
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
}
mapXids(messages);
try {
mySwitch.write(messages,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}","private void processFlowMod(OFMessage msg,FloodlightContext cntx){
  List<OFFlowMod> flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
  if (flows.size() == 0) {
    log.error(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
    this.sendError((OFMessage)msg);
    return;
  }
 else {
    log.info(""String_Node_Str"" + this.mySlicer.getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str""+ ((OFFlowMod)msg).toString());
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
    messages.add((OFMessage)msg);
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
        this.sendError((OFMessage)msg);
        return;
      }
    this.updateFlowCount(1);
  break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
  log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
  this.sendError((OFMessage)msg);
  return;
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
}
mapXids(messages);
try {
mySwitch.write(messages,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}",0.8597774244833069
25479,"/** 
 * slice requests from the controller to the switch. if a message isn't allowed then return with the sendError
 * @param msg
 * @param cntx
 */
public void toSwitch(OFMessage msg,FloodlightContext cntx){
  log.debug(""String_Node_Str"" + msg.getType());
  if (!this.mySlicer.isOkToProcessMessage()) {
    log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
    this.sendError((OFMessage)msg);
    return;
  }
switch (msg.getType()) {
case FLOW_MOD:
    processFlowMod(msg,cntx);
  return;
case PACKET_OUT:
List<OFMessage> allowed=this.mySlicer.allowedPacketOut((OFPacketOut)msg);
if (allowed.isEmpty()) {
log.info(""String_Node_Str"");
this.sendError((OFMessage)msg);
return;
}
 else {
log.info(""String_Node_Str"");
mapXids(allowed);
try {
  mySwitch.write(allowed,cntx);
}
 catch (IOException e) {
  e.printStackTrace();
}
mySwitch.flush();
}
return;
case STATS_REQUEST:
handleStatsRequest(msg);
return;
case PORT_MOD:
this.sendError((OFMessage)msg);
return;
case SET_CONFIG:
this.sendError((OFMessage)msg);
return;
default :
break;
}
mapXids(msg);
if (!this.valid_header(msg)) {
log.error(""String_Node_Str"" + this.getSlicer().getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str"");
return;
}
try {
mySwitch.write(msg,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}","/** 
 * slice requests from the controller to the switch. if a message isn't allowed then return with the sendError
 * @param msg
 * @param cntx
 */
public void toSwitch(OFMessage msg,FloodlightContext cntx){
  log.debug(""String_Node_Str"" + msg.getType());
  if (!this.mySlicer.isOkToProcessMessage()) {
    log.warn(""String_Node_Str"" + this.mySwitch.getStringId() + ""String_Node_Str""+ this.mySlicer.getSliceName()+ ""String_Node_Str"");
    this.sendError((OFMessage)msg);
    return;
  }
switch (msg.getType()) {
case FLOW_MOD:
    processFlowMod(msg,cntx);
  return;
case PACKET_OUT:
List<OFMessage> allowed=this.mySlicer.allowedPacketOut((OFPacketOut)msg);
if (allowed.isEmpty()) {
log.info(""String_Node_Str"");
this.sendError((OFMessage)msg);
return;
}
 else {
log.debug(""String_Node_Str"");
mapXids(allowed);
try {
  mySwitch.write(allowed,cntx);
}
 catch (IOException e) {
  e.printStackTrace();
}
mySwitch.flush();
}
return;
case STATS_REQUEST:
handleStatsRequest(msg);
return;
case PORT_MOD:
this.sendError((OFMessage)msg);
return;
case SET_CONFIG:
this.sendError((OFMessage)msg);
return;
default :
break;
}
mapXids(msg);
if (!this.valid_header(msg)) {
log.error(""String_Node_Str"" + this.getSlicer().getSliceName() + ""String_Node_Str""+ this.mySwitch.getStringId()+ ""String_Node_Str"");
return;
}
try {
mySwitch.write(msg,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}",0.9967868618350588
25480,"/** 
 * reloadConfig - reloads the configuration of FSF disconnects/re-connects/and connects to slices as the FSF config specifies this is only called via the web-service
 */
public boolean reloadConfig(){
  ArrayList<HashMap<Long,Slicer>> newSlices;
  ArrayList<Proxy> toBeRemoved=new ArrayList<Proxy>();
  try {
    newSlices=ConfigParser.parseConfig(""String_Node_Str"");
    Iterator<HashMap<Long,Slicer>> sliceIt=this.slices.iterator();
    while (sliceIt.hasNext()) {
      @SuppressWarnings(""String_Node_Str"") HashMap<Long,Slicer> tmp=sliceIt.next();
      sliceIt.remove();
    }
    for (    HashMap<Long,Slicer> slice : newSlices) {
      for (      Long dpid : slice.keySet()) {
        this.setSlice(dpid,slice.get(dpid).getSliceName(),slice.get(dpid));
      }
    }
    for (    IOFSwitch sw : this.switches) {
      List<Proxy> proxies=controllerConnector.getSwitchProxies(sw.getId());
      if (proxies == null) {
        logger.error(""String_Node_Str"");
        continue;
      }
      logger.warn(""String_Node_Str"" + proxies.size());
      for (      Proxy p : proxies) {
        boolean updated=false;
        for (        HashMap<Long,Slicer> slice : newSlices) {
          logger.error(""String_Node_Str"" + slice.keySet().size());
          if (slice.containsKey(sw.getId()) && slice.get(sw.getId()).getSliceName().equals(p.getSlicer().getSliceName())) {
            p.setSlicer(slice.get(sw.getId()));
            logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str"");
            updated=true;
            slice.remove(sw.getId());
          }
        }
        if (!updated) {
          logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str""+ sw.getStringId()+ ""String_Node_Str"");
          p.disconnect();
          toBeRemoved.add(p);
        }
      }
    }
    Iterator<HashMap<Long,Slicer>> sliceIt2=newSlices.iterator();
    logger.warn(""String_Node_Str"" + newSlices.size());
    while (sliceIt2.hasNext()) {
      HashMap<Long,Slicer> slice=sliceIt2.next();
      if (slice.isEmpty()) {
      }
 else {
        for (        Long dpid : slice.keySet()) {
          if (this.switches.contains(dpid)) {
            IOFSwitch sw=floodlightProvider.getSwitch(dpid);
            Slicer vlanSlicer=slice.get(dpid);
            controllerConnector.addProxy(dpid,new Proxy(sw,vlanSlicer,this));
          }
        }
      }
    }
    for (    Proxy p : toBeRemoved) {
      this.removeProxy(p.getSwitch().getId(),p);
      this.removeSlice(p.getSwitch().getId(),p.getSlicer().getSliceName());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  SAXException e) {
    e.printStackTrace();
    return false;
  }
catch (  ParserConfigurationException e) {
    logger.error(e.getMessage());
    return false;
  }
catch (  XPathExpressionException e) {
    logger.error(e.getMessage());
    return false;
  }
  logger.error(""String_Node_Str"" + this.slices.size());
  return true;
}","/** 
 * reloadConfig - reloads the configuration of FSF disconnects/re-connects/and connects to slices as the FSF config specifies this is only called via the web-service
 */
public boolean reloadConfig(){
  ArrayList<HashMap<Long,Slicer>> newSlices;
  ArrayList<Proxy> toBeRemoved=new ArrayList<Proxy>();
  try {
    newSlices=ConfigParser.parseConfig(""String_Node_Str"");
    Iterator<HashMap<Long,Slicer>> sliceIt=this.slices.iterator();
    while (sliceIt.hasNext()) {
      @SuppressWarnings(""String_Node_Str"") HashMap<Long,Slicer> tmp=sliceIt.next();
      sliceIt.remove();
    }
    for (    HashMap<Long,Slicer> slice : newSlices) {
      for (      Long dpid : slice.keySet()) {
        this.setSlice(dpid,slice.get(dpid).getSliceName(),slice.get(dpid));
      }
    }
    List<Proxy> proxies=controllerConnector.getAllProxies();
    logger.warn(""String_Node_Str"" + proxies.size());
    for (    Proxy p : proxies) {
      boolean updated=false;
      for (      HashMap<Long,Slicer> slice : newSlices) {
        logger.error(""String_Node_Str"" + slice.keySet().size());
        if (slice.containsKey(p.getSwitch().getId()) && slice.get(p.getSwitch().getId()).getSliceName().equals(p.getSlicer().getSliceName())) {
          p.setSlicer(slice.get(p.getSwitch().getId()));
          logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str"");
          updated=true;
          slice.remove(p.getSwitch().getId());
        }
      }
      if (!updated) {
        logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str""+ p.getSwitch().getStringId()+ ""String_Node_Str"");
        p.disconnect();
        toBeRemoved.add(p);
      }
    }
    Iterator<HashMap<Long,Slicer>> sliceIt2=newSlices.iterator();
    logger.warn(""String_Node_Str"" + newSlices.size());
    while (sliceIt2.hasNext()) {
      HashMap<Long,Slicer> slice=sliceIt2.next();
      if (slice.isEmpty()) {
      }
 else {
        for (        Long dpid : slice.keySet()) {
          IOFSwitch sw=floodlightProvider.getSwitch(dpid);
          Slicer vlanSlicer=slice.get(dpid);
          controllerConnector.addProxy(dpid,new Proxy(sw,vlanSlicer,this));
        }
      }
    }
    for (    Proxy p : toBeRemoved) {
      this.removeProxy(p.getSwitch().getId(),p);
      this.removeSlice(p.getSwitch().getId(),p.getSlicer().getSliceName());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  SAXException e) {
    e.printStackTrace();
    return false;
  }
catch (  ParserConfigurationException e) {
    logger.error(e.getMessage());
    return false;
  }
catch (  XPathExpressionException e) {
    logger.error(e.getMessage());
    return false;
  }
  logger.error(""String_Node_Str"" + this.slices.size());
  return true;
}",0.5177612198925663
25481,"/** 
 * reloadConfig - reloads the configuration of FSF disconnects/re-connects/and connects to slices as the FSF config specifies this is only called via the web-service
 */
public boolean reloadConfig(){
  ArrayList<HashMap<Long,Slicer>> newSlices;
  ArrayList<Proxy> toBeRemoved=new ArrayList<Proxy>();
  try {
    newSlices=ConfigParser.parseConfig(""String_Node_Str"");
    for (    HashMap<Long,Slicer> slice : newSlices) {
      for (      Long dpid : slice.keySet()) {
        this.setSlice(dpid,slice.get(dpid).getSliceName(),slice.get(dpid));
      }
    }
    for (    IOFSwitch sw : this.switches) {
      List<Proxy> proxies=controllerConnector.getSwitchProxies(sw.getId());
      if (proxies == null) {
        logger.error(""String_Node_Str"");
        continue;
      }
      logger.warn(""String_Node_Str"" + proxies.size());
      for (      Proxy p : proxies) {
        boolean updated=false;
        for (        HashMap<Long,Slicer> slice : newSlices) {
          logger.error(""String_Node_Str"" + slice.keySet().size());
          if (slice.containsKey(sw.getId()) && slice.get(sw.getId()).getSliceName().equals(p.getSlicer().getSliceName())) {
            p.setSlicer(slice.get(sw.getId()));
            logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str"");
            updated=true;
            slice.remove(sw.getId());
          }
        }
        if (!updated) {
          logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str""+ sw.getStringId()+ ""String_Node_Str"");
          p.disconnect();
          toBeRemoved.add(p);
        }
      }
    }
    Iterator<HashMap<Long,Slicer>> sliceIt=newSlices.iterator();
    logger.warn(""String_Node_Str"" + newSlices.size());
    while (sliceIt.hasNext()) {
      HashMap<Long,Slicer> slice=sliceIt.next();
      if (slice.isEmpty()) {
      }
 else {
        for (        Long dpid : slice.keySet()) {
          if (this.switches.contains(dpid)) {
            IOFSwitch sw=floodlightProvider.getSwitch(dpid);
            Slicer vlanSlicer=slice.get(dpid);
            controllerConnector.addProxy(dpid,new Proxy(sw,vlanSlicer,this));
          }
        }
      }
    }
    for (    Proxy p : toBeRemoved) {
      this.removeProxy(p.getSwitch().getId(),p);
      this.removeSlice(p.getSwitch().getId(),p.getSlicer().getSliceName());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  SAXException e) {
    e.printStackTrace();
    return false;
  }
catch (  ParserConfigurationException e) {
    logger.error(e.getMessage());
    return false;
  }
catch (  XPathExpressionException e) {
    logger.error(e.getMessage());
    return false;
  }
  logger.error(""String_Node_Str"" + this.slices.size());
  return true;
}","/** 
 * reloadConfig - reloads the configuration of FSF disconnects/re-connects/and connects to slices as the FSF config specifies this is only called via the web-service
 */
public boolean reloadConfig(){
  ArrayList<HashMap<Long,Slicer>> newSlices;
  ArrayList<Proxy> toBeRemoved=new ArrayList<Proxy>();
  try {
    newSlices=ConfigParser.parseConfig(""String_Node_Str"");
    Iterator<HashMap<Long,Slicer>> sliceIt=this.slices.iterator();
    while (sliceIt.hasNext()) {
      @SuppressWarnings(""String_Node_Str"") HashMap<Long,Slicer> tmp=sliceIt.next();
      sliceIt.remove();
    }
    for (    HashMap<Long,Slicer> slice : newSlices) {
      for (      Long dpid : slice.keySet()) {
        this.setSlice(dpid,slice.get(dpid).getSliceName(),slice.get(dpid));
      }
    }
    for (    IOFSwitch sw : this.switches) {
      List<Proxy> proxies=controllerConnector.getSwitchProxies(sw.getId());
      if (proxies == null) {
        logger.error(""String_Node_Str"");
        continue;
      }
      logger.warn(""String_Node_Str"" + proxies.size());
      for (      Proxy p : proxies) {
        boolean updated=false;
        for (        HashMap<Long,Slicer> slice : newSlices) {
          logger.error(""String_Node_Str"" + slice.keySet().size());
          if (slice.containsKey(sw.getId()) && slice.get(sw.getId()).getSliceName().equals(p.getSlicer().getSliceName())) {
            p.setSlicer(slice.get(sw.getId()));
            logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str"");
            updated=true;
            slice.remove(sw.getId());
          }
        }
        if (!updated) {
          logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str""+ sw.getStringId()+ ""String_Node_Str"");
          p.disconnect();
          toBeRemoved.add(p);
        }
      }
    }
    Iterator<HashMap<Long,Slicer>> sliceIt2=newSlices.iterator();
    logger.warn(""String_Node_Str"" + newSlices.size());
    while (sliceIt2.hasNext()) {
      HashMap<Long,Slicer> slice=sliceIt2.next();
      if (slice.isEmpty()) {
      }
 else {
        for (        Long dpid : slice.keySet()) {
          if (this.switches.contains(dpid)) {
            IOFSwitch sw=floodlightProvider.getSwitch(dpid);
            Slicer vlanSlicer=slice.get(dpid);
            controllerConnector.addProxy(dpid,new Proxy(sw,vlanSlicer,this));
          }
        }
      }
    }
    for (    Proxy p : toBeRemoved) {
      this.removeProxy(p.getSwitch().getId(),p);
      this.removeSlice(p.getSwitch().getId(),p.getSlicer().getSliceName());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  SAXException e) {
    e.printStackTrace();
    return false;
  }
catch (  ParserConfigurationException e) {
    logger.error(e.getMessage());
    return false;
  }
catch (  XPathExpressionException e) {
    logger.error(e.getMessage());
    return false;
  }
  logger.error(""String_Node_Str"" + this.slices.size());
  return true;
}",0.9625390218522372
25482,"public synchronized List<HashMap<Long,Slicer>> getSlices(){
  List<HashMap<Long,Slicer>> slices=Collections.synchronizedList(this.slices);
synchronized (slices) {
    logger.error(""String_Node_Str"" + slices.size());
    return slices;
  }
}","public synchronized List<HashMap<Long,Slicer>> getSlices(){
  List<HashMap<Long,Slicer>> slices=Collections.synchronizedList(this.slices);
  logger.error(""String_Node_Str"" + slices.size());
  return slices;
}",0.9285714285714286
25483,"public synchronized void removeSlice(long dpid,String name){
  for (  HashMap<Long,Slicer> hash : this.slices) {
    if (hash.containsKey(dpid)) {
      if (hash.get(dpid).getSliceName().equals(name)) {
        hash.remove(dpid);
        return;
      }
    }
  }
  for (int i=0; i < this.slices.size(); i++) {
    HashMap<Long,Slicer> tmp=this.slices.get(i);
    if (tmp.isEmpty()) {
      this.slices.remove(i);
    }
  }
}","public synchronized void removeSlice(long dpid,String name){
  for (  HashMap<Long,Slicer> hash : this.slices) {
    if (hash.containsKey(dpid)) {
      if (hash.get(dpid).getSliceName().equals(name)) {
        hash.remove(dpid);
      }
    }
  }
  for (int i=0; i < this.slices.size(); i++) {
    HashMap<Long,Slicer> tmp=this.slices.get(i);
    if (tmp.isEmpty()) {
      this.slices.remove(i);
    }
  }
}",0.9808153477218226
25484,"/** 
 * get a list of proxies for a given switch
 * @param switchId (Long)
 * @return List <Proxy> getSwitchProxiessynchronized for thread safty
 */
public synchronized List<Proxy> getSwitchProxies(Long switchId){
  log.debug(""String_Node_Str"" + switchId);
  Set<Long> keys=proxies.keySet();
  Iterator<Long> it=keys.iterator();
  while (it.hasNext()) {
    Long key=it.next();
    log.debug(""String_Node_Str"" + key);
  }
  return proxies.get(switchId);
}","/** 
 * get a list of proxies for a given switch
 * @param switchId (Long)
 * @return List <Proxy> getSwitchProxiessynchronized for thread safty
 */
public synchronized List<Proxy> getSwitchProxies(Long switchId){
  log.debug(""String_Node_Str"" + switchId);
  return proxies.get(switchId);
}",0.72751677852349
25485,"public List<HashMap<Long,Slicer>> getSlices(){
  List<HashMap<Long,Slicer>> slices=Collections.synchronizedList(this.slices);
synchronized (slices) {
    logger.error(""String_Node_Str"" + slices.size());
    return slices;
  }
}","public synchronized List<HashMap<Long,Slicer>> getSlices(){
  List<HashMap<Long,Slicer>> slices=Collections.synchronizedList(this.slices);
synchronized (slices) {
    logger.error(""String_Node_Str"" + slices.size());
    return slices;
  }
}",0.9721627408993576
25486,"public HashMap<Long,Slicer> getSlice(String name){
  List<HashMap<Long,Slicer>> mySlices=Collections.synchronizedList(this.slices);
synchronized (mySlices) {
    Iterator<HashMap<Long,Slicer>> it=mySlices.iterator();
    while (it.hasNext()) {
      HashMap<Long,Slicer> slice=it.next();
      Iterator<Long> dpidIt=slice.keySet().iterator();
      if (dpidIt.hasNext()) {
        Long dpid=dpidIt.next();
        if (slice.get(dpid).getSliceName().equals(name)) {
          return slice;
        }
      }
    }
  }
  return null;
}","public synchronized HashMap<Long,Slicer> getSlice(String name){
  List<HashMap<Long,Slicer>> mySlices=Collections.synchronizedList(this.slices);
  Iterator<HashMap<Long,Slicer>> it=mySlices.iterator();
  while (it.hasNext()) {
    HashMap<Long,Slicer> slice=it.next();
    Iterator<Long> dpidIt=slice.keySet().iterator();
    if (dpidIt.hasNext()) {
      Long dpid=dpidIt.next();
      if (slice.get(dpid).getSliceName().equals(name)) {
        return slice;
      }
    }
  }
  return null;
}",0.9113924050632912
25487,"/** 
 * reloadConfig - reloads the configuration of FSF disconnects/re-connects/and connects to slices as the FSF config specifies this is only called via the web-service
 */
@SuppressWarnings(""String_Node_Str"") public boolean reloadConfig(){
  ArrayList<HashMap<Long,Slicer>> newSlices;
  ArrayList<IOFSwitch> newSwitches;
  try {
    List<HashMap<Long,Slicer>> mySlices=Collections.synchronizedList(this.slices);
    newSlices=ConfigParser.parseConfig(""String_Node_Str"");
synchronized (mySlices) {
      if (newSlices.size() == 0) {
        logger.error(""String_Node_Str"");
        return false;
      }
 else {
        mySlices.clear();
        mySlices.addAll(newSlices);
      }
    }
    newSwitches=(ArrayList<IOFSwitch>)this.switches.clone();
    logger.error(""String_Node_Str"" + newSwitches.size());
    Iterator<IOFSwitch> it=newSwitches.iterator();
    while (it.hasNext()) {
      IOFSwitch sw=it.next();
      List<Proxy> proxies=controllerConnector.getSwitchProxies(sw.getId());
      if (proxies == null) {
        logger.error(""String_Node_Str"");
      }
      if (proxies != null) {
        List<Proxy> myProxies=Collections.synchronizedList(controllerConnector.getSwitchProxies(sw.getId()));
synchronized (myProxies) {
          if (myProxies != null) {
            logger.warn(""String_Node_Str"" + myProxies.size());
            Iterator<Proxy> proxyIt=myProxies.iterator();
            while (proxyIt.hasNext()) {
              Proxy p=proxyIt.next();
              boolean updated=false;
              for (              HashMap<Long,Slicer> slice : newSlices) {
                logger.error(""String_Node_Str"" + slice.keySet().size());
                if (slice.containsKey(sw.getId()) && slice.get(sw.getId()).getSliceName().equals(p.getSlicer().getSliceName())) {
                  p.setSlicer(slice.get(sw.getId()));
                  logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str"");
                  slice.remove(sw.getId());
                  updated=true;
                }
              }
              if (updated == false) {
                logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str"");
                p.disconnect();
                proxyIt.remove();
              }
            }
          }
        }
      }
    }
    Iterator<HashMap<Long,Slicer>> sliceIt=newSlices.iterator();
    logger.warn(""String_Node_Str"" + newSlices.size());
    while (sliceIt.hasNext()) {
      HashMap<Long,Slicer> slice=sliceIt.next();
      if (slice.isEmpty()) {
      }
 else {
        for (        Long dpid : slice.keySet()) {
          if (newSwitches.contains(dpid)) {
            IOFSwitch sw=floodlightProvider.getSwitch(dpid);
            Slicer vlanSlicer=slice.get(dpid);
            controllerConnector.addProxy(dpid,new Proxy(sw,vlanSlicer,this));
          }
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  SAXException e) {
    e.printStackTrace();
    return false;
  }
catch (  ParserConfigurationException e) {
    logger.error(e.getMessage());
    return false;
  }
catch (  XPathExpressionException e) {
    logger.error(e.getMessage());
    return false;
  }
  logger.error(""String_Node_Str"" + this.slices.size());
  return true;
}","/** 
 * reloadConfig - reloads the configuration of FSF disconnects/re-connects/and connects to slices as the FSF config specifies this is only called via the web-service
 */
public boolean reloadConfig(){
  ArrayList<HashMap<Long,Slicer>> newSlices;
  ArrayList<Proxy> toBeRemoved=new ArrayList<Proxy>();
  try {
    newSlices=ConfigParser.parseConfig(""String_Node_Str"");
    for (    HashMap<Long,Slicer> slice : newSlices) {
      for (      Long dpid : slice.keySet()) {
        this.setSlice(dpid,slice.get(dpid).getSliceName(),slice.get(dpid));
      }
    }
    for (    IOFSwitch sw : this.switches) {
      logger.error(""String_Node_Str"" + controllerConnector.getSwitchProxies(sw.getId()).size());
      List<Proxy> proxies=controllerConnector.getSwitchProxies(sw.getId());
      if (proxies == null) {
        logger.error(""String_Node_Str"");
        continue;
      }
      logger.warn(""String_Node_Str"" + proxies.size());
      for (      Proxy p : proxies) {
        boolean updated=false;
        for (        HashMap<Long,Slicer> slice : newSlices) {
          logger.error(""String_Node_Str"" + slice.keySet().size());
          if (slice.containsKey(sw.getId()) && slice.get(sw.getId()).getSliceName().equals(p.getSlicer().getSliceName())) {
            p.setSlicer(slice.get(sw.getId()));
            logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str"");
            updated=true;
            slice.remove(sw.getId());
          }
        }
        if (!updated) {
          logger.warn(""String_Node_Str"" + p.getSlicer().getSliceName() + ""String_Node_Str""+ sw.getStringId()+ ""String_Node_Str"");
          p.disconnect();
          toBeRemoved.add(p);
        }
      }
    }
    Iterator<HashMap<Long,Slicer>> sliceIt=newSlices.iterator();
    logger.warn(""String_Node_Str"" + newSlices.size());
    while (sliceIt.hasNext()) {
      HashMap<Long,Slicer> slice=sliceIt.next();
      if (slice.isEmpty()) {
      }
 else {
        for (        Long dpid : slice.keySet()) {
          if (this.switches.contains(dpid)) {
            IOFSwitch sw=floodlightProvider.getSwitch(dpid);
            Slicer vlanSlicer=slice.get(dpid);
            controllerConnector.addProxy(dpid,new Proxy(sw,vlanSlicer,this));
          }
        }
      }
    }
    for (    Proxy p : toBeRemoved) {
      this.removeProxy(p.getSwitch().getId(),p);
      this.removeSlice(p.getSwitch().getId(),p.getSlicer().getSliceName());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  SAXException e) {
    e.printStackTrace();
    return false;
  }
catch (  ParserConfigurationException e) {
    logger.error(e.getMessage());
    return false;
  }
catch (  XPathExpressionException e) {
    logger.error(e.getMessage());
    return false;
  }
  logger.error(""String_Node_Str"" + this.slices.size());
  return true;
}",0.2504454884173011
25488,"/** 
 * Removes a switch from the list of switches
 * @param sw
 */
public void removeSwitch(IOFSwitch sw){
  mySwitches.remove(sw);
}","/** 
 * Removes a switch from the list of switches
 * @param sw
 */
public synchronized void removeSwitch(IOFSwitch sw){
  mySwitches.remove(sw);
}",0.9537366548042704
25489,"/** 
 * Adds a switch to the list of Switches
 * @param sw
 */
public void addSwitch(IOFSwitch sw){
  mySwitches.add(sw);
}","/** 
 * Adds a switch to the list of Switches
 * @param sw
 */
public synchronized void addSwitch(IOFSwitch sw){
  mySwitches.add(sw);
}",0.9498069498069498
25490,"/** 
 * disconnect from the controller
 */
public void disconnect(){
  myController.disconnect();
  myController.close();
}","/** 
 * disconnect from the controller
 */
public void disconnect(){
  if (myController.isConnected()) {
    myController.disconnect();
    myController.close();
  }
}",0.8482758620689655
25491,"/** 
 * sets the slicer if for example the config is updated
 * @param newSlicer
 */
public void setSlicer(Slicer newSlicer){
  if (newSlicer.getControllerAddress().equals(this.mySlicer.getControllerAddress())) {
    this.disconnect();
  }
  this.mySlicer=newSlicer;
  this.mySlicer.setSwitch(this.mySwitch);
  this.packetInRate.setRate(this.getSlicer().getPacketInRate());
}","/** 
 * sets the slicer if for example the config is updated
 * @param newSlicer
 */
public void setSlicer(Slicer newSlicer){
  if (!newSlicer.getControllerAddress().equals(this.mySlicer.getControllerAddress())) {
    this.disconnect();
  }
  this.mySlicer=newSlicer;
  this.mySlicer.setSwitch(this.mySwitch);
  this.packetInRate.setRate(this.getSlicer().getPacketInRate());
}",0.9986684420772304
25492,"private void processFlowMod(OFMessage msg){
  List<OFFlowMod> flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
  if (flows.size() == 0) {
    log.info(""String_Node_Str"");
    this.sendError((OFMessage)msg);
    return;
  }
 else {
    log.info(""String_Node_Str"");
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
    messages.add((OFMessage)msg);
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"");
        this.sendError((OFMessage)msg);
        return;
      }
    this.updateFlowCount(1);
  break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
  log.warn(""String_Node_Str"");
  this.sendError((OFMessage)msg);
  return;
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
}
mapXids(messages);
try {
mySwitch.write(messages,null);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}","private void processFlowMod(OFMessage msg,FloodlightContext cntx){
  List<OFFlowMod> flows=this.mySlicer.allowedFlows((OFFlowMod)msg);
  if (flows.size() == 0) {
    log.info(""String_Node_Str"");
    this.sendError((OFMessage)msg);
    return;
  }
 else {
    log.info(""String_Node_Str"");
  }
  List<OFMessage> messages=new ArrayList<OFMessage>();
  Iterator<OFFlowMod> it=flows.iterator();
  while (it.hasNext()) {
    OFFlowMod flow=it.next();
    messages.add((OFMessage)msg);
switch (flow.getCommand()) {
case OFFlowMod.OFPFC_ADD:
      if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
        log.warn(""String_Node_Str"");
        this.sendError((OFMessage)msg);
        return;
      }
    this.updateFlowCount(1);
  break;
case OFFlowMod.OFPFF_CHECK_OVERLAP:
if (this.mySlicer.isGreaterThanMaxFlows(this.flowCount + 1)) {
  log.warn(""String_Node_Str"");
  this.sendError((OFMessage)msg);
  return;
}
this.updateFlowCount(1);
break;
case OFFlowMod.OFPFC_DELETE:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_DELETE_STRICT:
this.updateFlowCount(-1);
break;
case OFFlowMod.OFPFC_MODIFY:
break;
}
}
mapXids(messages);
try {
mySwitch.write(messages,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}",0.987444309437019
25493,"/** 
 * slice requests from the controller to the switch. if a message isn't allowed then return with the sendError
 * @param msg
 * @param cntx
 */
public void toSwitch(OFMessage msg,FloodlightContext cntx){
  log.debug(""String_Node_Str"" + msg.getType());
  if (!this.mySlicer.isOkToProcessMessage()) {
    log.warn(""String_Node_Str"");
    this.sendError((OFMessage)msg);
  }
switch (msg.getType()) {
case FLOW_MOD:
    processFlowMod(msg);
  return;
case PACKET_OUT:
List<OFMessage> allowed=this.mySlicer.allowedPacketOut((OFPacketOut)msg);
if (allowed.isEmpty()) {
log.info(""String_Node_Str"");
this.sendError((OFMessage)msg);
return;
}
 else {
log.info(""String_Node_Str"");
mapXids(allowed);
try {
  mySwitch.write(allowed,null);
}
 catch (IOException e) {
  e.printStackTrace();
}
mySwitch.flush();
}
return;
case STATS_REQUEST:
handleStatsRequest(msg);
return;
case PORT_MOD:
this.sendError((OFMessage)msg);
return;
case SET_CONFIG:
this.sendError((OFMessage)msg);
return;
default :
break;
}
mapXids(msg);
try {
mySwitch.write(msg,null);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}","/** 
 * slice requests from the controller to the switch. if a message isn't allowed then return with the sendError
 * @param msg
 * @param cntx
 */
public void toSwitch(OFMessage msg,FloodlightContext cntx){
  log.debug(""String_Node_Str"" + msg.getType());
  if (!this.mySlicer.isOkToProcessMessage()) {
    log.warn(""String_Node_Str"");
    this.sendError((OFMessage)msg);
    return;
  }
switch (msg.getType()) {
case FLOW_MOD:
    processFlowMod(msg,cntx);
  return;
case PACKET_OUT:
List<OFMessage> allowed=this.mySlicer.allowedPacketOut((OFPacketOut)msg);
if (allowed.isEmpty()) {
log.info(""String_Node_Str"");
this.sendError((OFMessage)msg);
return;
}
 else {
log.info(""String_Node_Str"");
mapXids(allowed);
try {
  mySwitch.write(allowed,cntx);
}
 catch (IOException e) {
  e.printStackTrace();
}
mySwitch.flush();
}
return;
case STATS_REQUEST:
handleStatsRequest(msg);
return;
case PORT_MOD:
this.sendError((OFMessage)msg);
return;
case SET_CONFIG:
this.sendError((OFMessage)msg);
return;
default :
break;
}
mapXids(msg);
try {
mySwitch.write(msg,cntx);
}
 catch (IOException e) {
e.printStackTrace();
}
mySwitch.flush();
}",0.9852612773559624
25494,"/** 
 * expands the actions in a flowMod so that if we have an ALL action it will be output to all ports but the port it came frome
 * @param flowMod
 * @return
 */
private OFFlowMod expandActions(OFFlowMod flowMod){
  Short portId=flowMod.getMatch().getInputPort();
  List<OFAction> actions=flowMod.getActions();
  if (actions == null || actions.isEmpty()) {
    log.debug(""String_Node_Str"");
    return null;
  }
  List<OFAction> newActions=new ArrayList<OFAction>();
  for (  OFAction action : actions) {
    log.debug(""String_Node_Str"" + action.getType().name());
    if (action.getType() == OFActionType.OUTPUT) {
      OFActionOutput output=(OFActionOutput)action;
      if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
        log.debug(""String_Node_Str"");
        for (        Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
          if (port.getValue().getPortId() != portId) {
            OFActionOutput newAct;
            try {
              newAct=(OFActionOutput)action.clone();
            }
 catch (            CloneNotSupportedException e) {
              log.error(""String_Node_Str"");
              log.error(e.getMessage());
              return null;
            }
            newAct.setPort(port.getValue().getPortId());
            newActions.add(newAct);
          }
        }
      }
 else       if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
        return null;
      }
 else {
        log.debug(""String_Node_Str"");
        newActions.add(action);
      }
    }
 else {
      log.debug(""String_Node_Str"");
      newActions.add(action);
    }
  }
  OFFlowMod newFlow;
  try {
    newFlow=flowMod.clone();
  }
 catch (  CloneNotSupportedException e) {
    e.printStackTrace();
    return null;
  }
  newFlow.setActions(newActions);
  return newFlow;
}","/** 
 * expands the actions in a flowMod so that if we have an ALL action it will be output to all ports but the port it came frome
 * @param flowMod
 * @return
 */
private OFFlowMod expandActions(OFFlowMod flowMod){
  Short portId=flowMod.getMatch().getInputPort();
  List<OFAction> actions=flowMod.getActions();
  if (actions == null || actions.isEmpty()) {
    log.debug(""String_Node_Str"");
    return flowMod;
  }
  List<OFAction> newActions=new ArrayList<OFAction>();
  for (  OFAction action : actions) {
    log.debug(""String_Node_Str"" + action.getType().name());
    if (action.getType() == OFActionType.OUTPUT) {
      OFActionOutput output=(OFActionOutput)action;
      if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
        log.debug(""String_Node_Str"");
        for (        Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
          if (port.getValue().getPortId() != portId) {
            OFActionOutput newAct;
            try {
              newAct=(OFActionOutput)action.clone();
            }
 catch (            CloneNotSupportedException e) {
              log.error(""String_Node_Str"");
              log.error(e.getMessage());
              return null;
            }
            newAct.setPort(port.getValue().getPortId());
            newActions.add(newAct);
          }
        }
      }
 else       if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
        return null;
      }
 else {
        log.debug(""String_Node_Str"");
        newActions.add(action);
      }
    }
 else {
      log.debug(""String_Node_Str"");
      newActions.add(action);
    }
  }
  OFFlowMod newFlow;
  try {
    newFlow=flowMod.clone();
  }
 catch (  CloneNotSupportedException e) {
    e.printStackTrace();
    return null;
  }
  newFlow.setActions(newActions);
  return newFlow;
}",0.996957123098202
25495,"@Get(""String_Node_Str"") public List<HashMap<Long,Slicer>> Slices(){
  IFlowSpaceFirewallService iFSFs=(IFlowSpaceFirewallService)getContext().getAttributes().get(IFlowSpaceFirewallService.class.getCanonicalName());
  List<HashMap<Long,Slicer>> slices=iFSFs.getSlices();
  return slices;
}","@Get(""String_Node_Str"") public HashMap<String,List<Slicer>> Slices(){
  IFlowSpaceFirewallService iFSFs=(IFlowSpaceFirewallService)getContext().getAttributes().get(IFlowSpaceFirewallService.class.getCanonicalName());
  List<HashMap<Long,Slicer>> slices=iFSFs.getSlices();
  HashMap<String,List<Slicer>> newSlices=new HashMap<String,List<Slicer>>();
  for (  HashMap<Long,Slicer> slice : slices) {
    for (    Long dpid : slice.keySet()) {
      if (newSlices.containsKey(slice.get(dpid).getSliceName())) {
        List<Slicer> curSlices=newSlices.get(slice.get(dpid).getSliceName());
        curSlices.add(slice.get(dpid));
      }
 else {
        List<Slicer> curSlices=new ArrayList<Slicer>();
        curSlices.add(slice.get(dpid));
        newSlices.put(slice.get(dpid).getSliceName(),curSlices);
      }
    }
  }
  return newSlices;
}",0.4782993799822852
25496,"@Get(""String_Node_Str"") public HashMap<Long,List<Slicer>> getSwitches(){
  IFlowSpaceFirewallService iFSFs=(IFlowSpaceFirewallService)getContext().getAttributes().get(IFlowSpaceFirewallService.class.getCanonicalName());
  List<HashMap<Long,Slicer>> slices=iFSFs.getSlices();
  HashMap<Long,List<Slicer>> results=new HashMap<Long,List<Slicer>>();
  Iterator<HashMap<Long,Slicer>> sliceIt=slices.iterator();
  while (sliceIt.hasNext()) {
    HashMap<Long,Slicer> slice=sliceIt.next();
    Iterator<Long> dpidIt=slice.keySet().iterator();
    while (dpidIt.hasNext()) {
      Long dpid=dpidIt.next();
      if (results.containsKey(dpid)) {
        results.get(dpid).add(slice.get(dpid));
      }
 else {
        ArrayList<Slicer> sliceList=new ArrayList<Slicer>();
        sliceList.add(slice.get(dpid));
        results.put(dpid,sliceList);
      }
    }
  }
  return results;
}","@Get(""String_Node_Str"") public List<IOFSwitch> getSwitches(){
  IFlowSpaceFirewallService iFSFs=(IFlowSpaceFirewallService)getContext().getAttributes().get(IFlowSpaceFirewallService.class.getCanonicalName());
  return iFSFs.getSwitches();
}",0.3620071684587813
25497,"private OFFlowMod expandActions(OFFlowMod flowMod){
  List<OFAction> actions=flowMod.getActions();
  if (actions == null || actions.isEmpty()) {
    return null;
  }
  List<OFAction> newActions=new ArrayList<OFAction>();
  for (  OFAction action : actions) {
    log.debug(""String_Node_Str"" + action.getType().name());
    if (action.getType() == OFActionType.OUTPUT) {
      OFActionOutput output=(OFActionOutput)action;
      if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
        log.debug(""String_Node_Str"");
        for (        Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
          OFActionOutput newAct;
          try {
            newAct=(OFActionOutput)action.clone();
          }
 catch (          CloneNotSupportedException e) {
            log.error(""String_Node_Str"");
            log.error(e.getMessage());
            return null;
          }
          newAct.setPort(port.getValue().getPortId());
          newActions.add(newAct);
        }
      }
 else       if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
        return null;
      }
 else {
        log.debug(""String_Node_Str"");
        newActions.add(action);
      }
    }
  }
  OFFlowMod newFlow;
  try {
    newFlow=flowMod.clone();
  }
 catch (  CloneNotSupportedException e) {
    e.printStackTrace();
    return null;
  }
  newFlow.setActions(newActions);
  return newFlow;
}","/** 
 * expands the actions in a flowMod so that if we have an ALL action it will be output to all ports but the port it came frome
 * @param flowMod
 * @return
 */
private OFFlowMod expandActions(OFFlowMod flowMod){
  Short portId=flowMod.getMatch().getInputPort();
  List<OFAction> actions=flowMod.getActions();
  if (actions == null || actions.isEmpty()) {
    log.debug(""String_Node_Str"");
    return null;
  }
  List<OFAction> newActions=new ArrayList<OFAction>();
  for (  OFAction action : actions) {
    log.debug(""String_Node_Str"" + action.getType().name());
    if (action.getType() == OFActionType.OUTPUT) {
      OFActionOutput output=(OFActionOutput)action;
      if (output.getPort() == OFPort.OFPP_ALL.getValue()) {
        log.debug(""String_Node_Str"");
        for (        Map.Entry<String,PortConfig> port : this.portList.entrySet()) {
          if (port.getValue().getPortId() != portId) {
            OFActionOutput newAct;
            try {
              newAct=(OFActionOutput)action.clone();
            }
 catch (            CloneNotSupportedException e) {
              log.error(""String_Node_Str"");
              log.error(e.getMessage());
              return null;
            }
            newAct.setPort(port.getValue().getPortId());
            newActions.add(newAct);
          }
        }
      }
 else       if (output.getPort() == OFPort.OFPP_FLOOD.getValue()) {
        return null;
      }
 else {
        log.debug(""String_Node_Str"");
        newActions.add(action);
      }
    }
 else {
      log.debug(""String_Node_Str"");
      newActions.add(action);
    }
  }
  OFFlowMod newFlow;
  try {
    newFlow=flowMod.clone();
  }
 catch (  CloneNotSupportedException e) {
    e.printStackTrace();
    return null;
  }
  newFlow.setActions(newActions);
  return newFlow;
}",0.8121477770820288
25498,"/** 
 * Takes a flowMod and determines if it can be sent to the switch based on the policy.  If it can then
 * @param flowMod OFFlowMod to be sliced and possibly explodedinto multiple flow mods
 */
public List<OFFlowMod> allowedFlows(OFFlowMod flowMod){
  log.debug(""String_Node_Str"" + flowMod.toString());
  List<OFFlowMod> flowMods=new ArrayList<OFFlowMod>();
  OFMatch match=flowMod.getMatch();
  if (match == null) {
    return flowMods;
  }
  if (match.getDataLayerVirtualLan() == 0) {
    log.error(""String_Node_Str"");
    return flowMods;
  }
  if (match.getInputPort() == 0) {
    Iterator<Entry<String,PortConfig>> it=this.portList.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<String,PortConfig> port=(Entry<String,PortConfig>)it.next();
      if (port.getValue().getPortId() != 0) {
        log.debug(""String_Node_Str"" + port.getValue().getPortId());
        try {
          OFFlowMod newFlow=flowMod.clone();
          newFlow.getMatch().setInputPort(port.getValue().getPortId());
          newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().matchOn(Flag.IN_PORT));
          log.debug(""String_Node_Str"" + newFlow.getMatch().getInputPort());
          log.debug(""String_Node_Str"");
          OFFlowMod expandedFlow=this.expandActions(newFlow);
          if (this.isFlowAllowed(expandedFlow)) {
            flowMods.add(expandedFlow);
          }
 else {
            log.debug(""String_Node_Str"" + expandedFlow.toString());
            flowMods.clear();
            return flowMods;
          }
        }
 catch (        CloneNotSupportedException e) {
          log.error(""String_Node_Str"");
        }
catch (        Exception e) {
          log.error(""String_Node_Str"");
        }
      }
    }
    log.debug(""String_Node_Str"" + flowMods.size() + ""String_Node_Str""+ sw.getPorts().size());
    if (flowMods.size() == sw.getPorts().size()) {
      log.debug(""String_Node_Str"");
      flowMods.clear();
      flowMods.add(flowMod);
    }
  }
 else {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"");
    OFFlowMod expandedFlow=this.expandActions(flowMod);
    if (this.isFlowAllowed(expandedFlow)) {
      flowMods.add(expandedFlow);
    }
 else {
      log.debug(""String_Node_Str"" + expandedFlow.toString());
      flowMods.clear();
      return flowMods;
    }
  }
  log.debug(""String_Node_Str"" + flowMods.toString());
  return flowMods;
}","/** 
 * Takes a flowMod and determines if it can be sent to the switch based on the policy.  If it can then
 * @param flowMod OFFlowMod to be sliced and possibly explodedinto multiple flow mods
 */
public List<OFFlowMod> allowedFlows(OFFlowMod flowMod){
  log.debug(""String_Node_Str"" + flowMod.toString());
  List<OFFlowMod> flowMods=new ArrayList<OFFlowMod>();
  OFMatch match=flowMod.getMatch();
  if (match == null) {
    return flowMods;
  }
  if (match.getDataLayerVirtualLan() == 0) {
    log.error(""String_Node_Str"");
    return flowMods;
  }
  if (match.getInputPort() == 0) {
    Iterator<Entry<String,PortConfig>> it=this.portList.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<String,PortConfig> port=(Entry<String,PortConfig>)it.next();
      if (port.getValue().getPortId() != 0) {
        log.debug(""String_Node_Str"" + port.getValue().getPortId());
        try {
          OFFlowMod newFlow=flowMod.clone();
          newFlow.getMatch().setInputPort(port.getValue().getPortId());
          newFlow.getMatch().setWildcards(newFlow.getMatch().getWildcardObj().matchOn(Flag.IN_PORT));
          log.debug(""String_Node_Str"" + newFlow.getMatch().getInputPort());
          log.debug(""String_Node_Str"");
          OFFlowMod expandedFlow=this.expandActions(newFlow);
          if (expandedFlow == null) {
            log.warn(""String_Node_Str"" + newFlow.toString());
            flowMods.clear();
            return flowMods;
          }
          if (this.isFlowAllowed(expandedFlow)) {
            flowMods.add(expandedFlow);
          }
 else {
            log.debug(""String_Node_Str"" + expandedFlow.toString());
            flowMods.clear();
            return flowMods;
          }
        }
 catch (        CloneNotSupportedException e) {
          log.error(""String_Node_Str"");
        }
catch (        Exception e) {
          log.error(""String_Node_Str"");
        }
      }
    }
    log.debug(""String_Node_Str"" + flowMods.size() + ""String_Node_Str""+ sw.getPorts().size());
    if (flowMods.size() == sw.getPorts().size()) {
      log.debug(""String_Node_Str"");
      flowMods.clear();
      flowMods.add(flowMod);
    }
  }
 else {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"");
    OFFlowMod expandedFlow=this.expandActions(flowMod);
    if (expandedFlow == null) {
      log.warn(""String_Node_Str"" + flowMod.toString());
      flowMods.clear();
      return flowMods;
    }
    if (this.isFlowAllowed(expandedFlow)) {
      flowMods.add(expandedFlow);
    }
 else {
      log.debug(""String_Node_Str"" + expandedFlow.toString());
      flowMods.clear();
      return flowMods;
    }
  }
  log.debug(""String_Node_Str"" + flowMods.toString());
  return flowMods;
}",0.9390862944162436
25499,"public void deriveAndSaveSortedNeighborPairs() throws IOException, InterruptedException {
  LOG.info(""String_Node_Str"");
  final String renderParametersUrlTemplate=getRenderParametersUrlTemplate();
  final List<Double> zValues=getZValues();
  final ExistingMatchHelper existingMatchHelper;
  if (parameters.excludePairsInMatchCollection == null) {
    existingMatchHelper=null;
  }
 else {
    existingMatchHelper=new ExistingMatchHelper(parameters,renderDataClient);
  }
  final Map<Double,TileBoundsRTree> zToTreeMap=new LinkedHashMap<>(zValues.size());
  double z;
  for (int zIndex=0; (zIndex < zValues.size()) && (zIndex < parameters.zNeighborDistance); zIndex++) {
    z=zValues.get(zIndex);
    zToTreeMap.put(z,buildRTree(z));
    if (existingMatchHelper != null) {
      existingMatchHelper.addExistingPairs(z);
    }
  }
  final Set<OrderedCanvasIdPair> neighborPairs=new TreeSet<>();
  int totalSavedPairCount=0;
  Double neighborZ;
  TileBoundsRTree currentZTree;
  List<TileBoundsRTree> neighborTreeList;
  Set<OrderedCanvasIdPair> currentNeighborPairs;
  for (int zIndex=0; zIndex < zValues.size(); zIndex++) {
    z=zValues.get(zIndex);
    if (parameters.zNeighborDistance == 0) {
      zToTreeMap.put(z,buildRTree(z));
    }
    double maxNeighborZ=z;
    final double idealMaxNeighborZ=Math.min(parameters.maxZ,z + parameters.zNeighborDistance);
    for (int neighborZIndex=zIndex + 1; neighborZIndex < zValues.size(); neighborZIndex++) {
      maxNeighborZ=zValues.get(neighborZIndex);
      if (maxNeighborZ > idealMaxNeighborZ) {
        maxNeighborZ=zValues.get(neighborZIndex - 1);
        break;
      }
    }
    if (!zToTreeMap.containsKey(maxNeighborZ)) {
      if (zIndex > 0) {
        final double completedZ=zValues.get(zIndex - 1);
        zToTreeMap.remove(completedZ);
      }
      zToTreeMap.put(maxNeighborZ,buildRTree(maxNeighborZ));
      if (existingMatchHelper != null) {
        existingMatchHelper.addExistingPairs(maxNeighborZ);
      }
    }
    currentZTree=zToTreeMap.get(z);
    neighborTreeList=new ArrayList<>();
    for (int neighborZIndex=zIndex + 1; neighborZIndex < zValues.size(); neighborZIndex++) {
      neighborZ=zValues.get(neighborZIndex);
      if (neighborZ > maxNeighborZ) {
        break;
      }
      neighborTreeList.add(zToTreeMap.get(neighborZ));
    }
    currentNeighborPairs=currentZTree.getCircleNeighbors(neighborTreeList,parameters.xyNeighborFactor,parameters.explicitRadius,parameters.excludeCornerNeighbors,parameters.excludeSameLayerNeighbors,parameters.excludeSameSectionNeighbors);
    if (existingMatchHelper != null) {
      existingMatchHelper.removeExistingPairs(z,currentNeighborPairs);
    }
    neighborPairs.addAll(currentNeighborPairs);
    if (neighborPairs.size() > parameters.maxPairsPerFile) {
      final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
      int fromIndex=0;
      for (; ; fromIndex+=parameters.maxPairsPerFile) {
        final int toIndex=fromIndex + parameters.maxPairsPerFile;
        if (toIndex <= neighborPairs.size()) {
          savePairs(neighborPairsList.subList(fromIndex,toIndex),renderParametersUrlTemplate,getOutputFileName());
          numberOfOutputFiles++;
          totalSavedPairCount+=parameters.maxPairsPerFile;
        }
 else {
          break;
        }
      }
      neighborPairs.clear();
      neighborPairs.addAll(neighborPairsList.subList(fromIndex,neighborPairsList.size()));
    }
  }
  if (neighborPairs.size() > 0) {
    final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
    final String outputFileName=numberOfOutputFiles == 0 ? parameters.toJson : getOutputFileName();
    savePairs(neighborPairsList,renderParametersUrlTemplate,outputFileName);
    totalSavedPairCount+=neighborPairs.size();
  }
  LOG.info(""String_Node_Str"",totalSavedPairCount);
}","public void deriveAndSaveSortedNeighborPairs() throws IOException, InterruptedException {
  LOG.info(""String_Node_Str"");
  final String renderParametersUrlTemplate=getRenderParametersUrlTemplate();
  final List<Double> zValues=getZValues();
  final ExistingMatchHelper existingMatchHelper;
  if (parameters.excludePairsInMatchCollection == null) {
    existingMatchHelper=null;
  }
 else {
    existingMatchHelper=new ExistingMatchHelper(parameters,renderDataClient);
  }
  final Map<Double,TileBoundsRTree> zToTreeMap=new LinkedHashMap<>(zValues.size());
  double z;
  for (int zIndex=0; (zIndex < zValues.size()) && (zIndex < parameters.zNeighborDistance); zIndex++) {
    z=zValues.get(zIndex);
    zToTreeMap.put(z,buildRTree(z));
    if (existingMatchHelper != null) {
      existingMatchHelper.addExistingPairs(z);
    }
  }
  final Set<OrderedCanvasIdPair> neighborPairs=new TreeSet<>();
  int totalSavedPairCount=0;
  Double neighborZ;
  TileBoundsRTree currentZTree;
  List<TileBoundsRTree> neighborTreeList;
  Set<OrderedCanvasIdPair> currentNeighborPairs;
  for (int zIndex=0; zIndex < zValues.size(); zIndex++) {
    z=zValues.get(zIndex);
    if (parameters.zNeighborDistance == 0) {
      zToTreeMap.put(z,buildRTree(z));
    }
    neighborTreeList=new ArrayList<>();
    final double idealMaxNeighborZ=Math.min(parameters.maxZ,z + parameters.zNeighborDistance);
    for (int neighborZIndex=zIndex + 1; neighborZIndex < zValues.size(); neighborZIndex++) {
      neighborZ=zValues.get(neighborZIndex);
      if (neighborZ > idealMaxNeighborZ) {
        break;
      }
      if (!zToTreeMap.containsKey(neighborZ)) {
        if (zIndex > 0) {
          final double completedZ=zValues.get(zIndex - 1);
          zToTreeMap.remove(completedZ);
        }
        zToTreeMap.put(neighborZ,buildRTree(neighborZ));
        if (existingMatchHelper != null) {
          existingMatchHelper.addExistingPairs(neighborZ);
        }
      }
      neighborTreeList.add(zToTreeMap.get(neighborZ));
    }
    currentZTree=zToTreeMap.get(z);
    currentNeighborPairs=currentZTree.getCircleNeighbors(neighborTreeList,parameters.xyNeighborFactor,parameters.explicitRadius,parameters.excludeCornerNeighbors,parameters.excludeSameLayerNeighbors,parameters.excludeSameSectionNeighbors);
    if (existingMatchHelper != null) {
      existingMatchHelper.removeExistingPairs(z,currentNeighborPairs);
    }
    neighborPairs.addAll(currentNeighborPairs);
    if (neighborPairs.size() > parameters.maxPairsPerFile) {
      final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
      int fromIndex=0;
      for (; ; fromIndex+=parameters.maxPairsPerFile) {
        final int toIndex=fromIndex + parameters.maxPairsPerFile;
        if (toIndex <= neighborPairs.size()) {
          savePairs(neighborPairsList.subList(fromIndex,toIndex),renderParametersUrlTemplate,getOutputFileName());
          numberOfOutputFiles++;
          totalSavedPairCount+=parameters.maxPairsPerFile;
        }
 else {
          break;
        }
      }
      neighborPairs.clear();
      neighborPairs.addAll(neighborPairsList.subList(fromIndex,neighborPairsList.size()));
    }
  }
  if (neighborPairs.size() > 0) {
    final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
    final String outputFileName=numberOfOutputFiles == 0 ? parameters.toJson : getOutputFileName();
    savePairs(neighborPairsList,renderParametersUrlTemplate,outputFileName);
    totalSavedPairCount+=neighborPairs.size();
  }
  LOG.info(""String_Node_Str"",totalSavedPairCount);
}",0.8778256189451022
25500,"public void deriveAndSaveSortedNeighborPairs() throws IOException, InterruptedException {
  LOG.info(""String_Node_Str"");
  final String renderParametersUrlTemplate=getRenderParametersUrlTemplate();
  final List<Double> zValues=getZValues();
  final ExistingMatchHelper existingMatchHelper;
  if (parameters.excludePairsInMatchCollection == null) {
    existingMatchHelper=null;
  }
 else {
    existingMatchHelper=new ExistingMatchHelper(parameters,renderDataClient);
  }
  final Map<Double,TileBoundsRTree> zToTreeMap=new LinkedHashMap<>(zValues.size());
  double z;
  for (int zIndex=0; (zIndex < zValues.size()) && (zIndex < parameters.zNeighborDistance); zIndex++) {
    z=zValues.get(zIndex);
    zToTreeMap.put(z,buildRTree(z));
    if (existingMatchHelper != null) {
      existingMatchHelper.addExistingPairs(z);
    }
  }
  final Set<OrderedCanvasIdPair> neighborPairs=new TreeSet<>();
  int totalSavedPairCount=0;
  Double neighborZ;
  TileBoundsRTree currentZTree;
  List<TileBoundsRTree> neighborTreeList;
  Set<OrderedCanvasIdPair> currentNeighborPairs;
  for (int zIndex=0; zIndex < zValues.size(); zIndex++) {
    z=zValues.get(zIndex);
    if (parameters.zNeighborDistance == 0) {
      zToTreeMap.put(z,buildRTree(z));
    }
    final double maxNeighborZ=Math.min(parameters.maxZ,z + parameters.zNeighborDistance);
    if (!zToTreeMap.containsKey(maxNeighborZ)) {
      if (zIndex > 0) {
        final double completedZ=zValues.get(zIndex - 1);
        zToTreeMap.remove(completedZ);
      }
      zToTreeMap.put(maxNeighborZ,buildRTree(maxNeighborZ));
      if (existingMatchHelper != null) {
        existingMatchHelper.addExistingPairs(maxNeighborZ);
      }
    }
    currentZTree=zToTreeMap.get(z);
    neighborTreeList=new ArrayList<>();
    for (int neighborZIndex=zIndex + 1; neighborZIndex < zValues.size(); neighborZIndex++) {
      neighborZ=zValues.get(neighborZIndex);
      if (neighborZ > maxNeighborZ) {
        break;
      }
      neighborTreeList.add(zToTreeMap.get(neighborZ));
    }
    currentNeighborPairs=currentZTree.getCircleNeighbors(neighborTreeList,parameters.xyNeighborFactor,parameters.explicitRadius,parameters.excludeCornerNeighbors,parameters.excludeSameLayerNeighbors,parameters.excludeSameSectionNeighbors);
    if (existingMatchHelper != null) {
      existingMatchHelper.removeExistingPairs(z,currentNeighborPairs);
    }
    neighborPairs.addAll(currentNeighborPairs);
    if (neighborPairs.size() > parameters.maxPairsPerFile) {
      final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
      int fromIndex=0;
      for (; ; fromIndex+=parameters.maxPairsPerFile) {
        final int toIndex=fromIndex + parameters.maxPairsPerFile;
        if (toIndex <= neighborPairs.size()) {
          savePairs(neighborPairsList.subList(fromIndex,toIndex),renderParametersUrlTemplate,getOutputFileName());
          numberOfOutputFiles++;
          totalSavedPairCount+=parameters.maxPairsPerFile;
        }
 else {
          break;
        }
      }
      neighborPairs.clear();
      neighborPairs.addAll(neighborPairsList.subList(fromIndex,neighborPairsList.size()));
    }
  }
  if (neighborPairs.size() > 0) {
    final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
    final String outputFileName=numberOfOutputFiles == 0 ? parameters.toJson : getOutputFileName();
    savePairs(neighborPairsList,renderParametersUrlTemplate,outputFileName);
    totalSavedPairCount+=neighborPairs.size();
  }
  LOG.info(""String_Node_Str"",totalSavedPairCount);
}","public void deriveAndSaveSortedNeighborPairs() throws IOException, InterruptedException {
  LOG.info(""String_Node_Str"");
  final String renderParametersUrlTemplate=getRenderParametersUrlTemplate();
  final List<Double> zValues=getZValues();
  final ExistingMatchHelper existingMatchHelper;
  if (parameters.excludePairsInMatchCollection == null) {
    existingMatchHelper=null;
  }
 else {
    existingMatchHelper=new ExistingMatchHelper(parameters,renderDataClient);
  }
  final Map<Double,TileBoundsRTree> zToTreeMap=new LinkedHashMap<>(zValues.size());
  double z;
  for (int zIndex=0; (zIndex < zValues.size()) && (zIndex < parameters.zNeighborDistance); zIndex++) {
    z=zValues.get(zIndex);
    zToTreeMap.put(z,buildRTree(z));
    if (existingMatchHelper != null) {
      existingMatchHelper.addExistingPairs(z);
    }
  }
  final Set<OrderedCanvasIdPair> neighborPairs=new TreeSet<>();
  int totalSavedPairCount=0;
  Double neighborZ;
  TileBoundsRTree currentZTree;
  List<TileBoundsRTree> neighborTreeList;
  Set<OrderedCanvasIdPair> currentNeighborPairs;
  for (int zIndex=0; zIndex < zValues.size(); zIndex++) {
    z=zValues.get(zIndex);
    if (parameters.zNeighborDistance == 0) {
      zToTreeMap.put(z,buildRTree(z));
    }
    double maxNeighborZ=z;
    final double idealMaxNeighborZ=Math.min(parameters.maxZ,z + parameters.zNeighborDistance);
    for (int neighborZIndex=zIndex + 1; neighborZIndex < zValues.size(); neighborZIndex++) {
      maxNeighborZ=zValues.get(neighborZIndex);
      if (maxNeighborZ > idealMaxNeighborZ) {
        maxNeighborZ=zValues.get(neighborZIndex - 1);
        break;
      }
    }
    if (!zToTreeMap.containsKey(maxNeighborZ)) {
      if (zIndex > 0) {
        final double completedZ=zValues.get(zIndex - 1);
        zToTreeMap.remove(completedZ);
      }
      zToTreeMap.put(maxNeighborZ,buildRTree(maxNeighborZ));
      if (existingMatchHelper != null) {
        existingMatchHelper.addExistingPairs(maxNeighborZ);
      }
    }
    currentZTree=zToTreeMap.get(z);
    neighborTreeList=new ArrayList<>();
    for (int neighborZIndex=zIndex + 1; neighborZIndex < zValues.size(); neighborZIndex++) {
      neighborZ=zValues.get(neighborZIndex);
      if (neighborZ > maxNeighborZ) {
        break;
      }
      neighborTreeList.add(zToTreeMap.get(neighborZ));
    }
    currentNeighborPairs=currentZTree.getCircleNeighbors(neighborTreeList,parameters.xyNeighborFactor,parameters.explicitRadius,parameters.excludeCornerNeighbors,parameters.excludeSameLayerNeighbors,parameters.excludeSameSectionNeighbors);
    if (existingMatchHelper != null) {
      existingMatchHelper.removeExistingPairs(z,currentNeighborPairs);
    }
    neighborPairs.addAll(currentNeighborPairs);
    if (neighborPairs.size() > parameters.maxPairsPerFile) {
      final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
      int fromIndex=0;
      for (; ; fromIndex+=parameters.maxPairsPerFile) {
        final int toIndex=fromIndex + parameters.maxPairsPerFile;
        if (toIndex <= neighborPairs.size()) {
          savePairs(neighborPairsList.subList(fromIndex,toIndex),renderParametersUrlTemplate,getOutputFileName());
          numberOfOutputFiles++;
          totalSavedPairCount+=parameters.maxPairsPerFile;
        }
 else {
          break;
        }
      }
      neighborPairs.clear();
      neighborPairs.addAll(neighborPairsList.subList(fromIndex,neighborPairsList.size()));
    }
  }
  if (neighborPairs.size() > 0) {
    final List<OrderedCanvasIdPair> neighborPairsList=new ArrayList<>(neighborPairs);
    final String outputFileName=numberOfOutputFiles == 0 ? parameters.toJson : getOutputFileName();
    savePairs(neighborPairsList,renderParametersUrlTemplate,outputFileName);
    totalSavedPairCount+=neighborPairs.size();
  }
  LOG.info(""String_Node_Str"",totalSavedPairCount);
}",0.9589964931211222
25501,"private static TilePairClient.Parameters getTestParameters(final int zNeighborDistance,final String toJson) throws IllegalArgumentException {
  final TilePairClient.Parameters p=new TilePairClient.Parameters();
  final String argString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + zNeighborDistance + ""String_Node_Str""+ toJson;
  p.parse(argString.split(""String_Node_Str""));
  return p;
}","private static TilePairClient.Parameters getTestParameters(final int zNeighborDistance,final int maxPairsPerFile,final String toJson) throws IllegalArgumentException {
  final TilePairClient.Parameters p=new TilePairClient.Parameters();
  final String argString=""String_Node_Str"" + ""String_Node_Str"" + maxPairsPerFile + ""String_Node_Str""+ ""String_Node_Str""+ zNeighborDistance+ ""String_Node_Str""+ toJson;
  p.parse(argString.split(""String_Node_Str""));
  return p;
}",0.8858131487889274
25502,"private void testDeriveAndSaveSortedNeighborPairs(final int zNeighborDistance,final int expectedNumberOfFiles) throws Exception {
  final String toJson=baseFileName + ""String_Node_Str"";
  final MockTilePairClient client=new MockTilePairClient(getTestParameters(zNeighborDistance,toJson));
  client.deriveAndSaveSortedNeighborPairs();
  final List<Path> pairFilePaths=new ArrayList<>();
  Files.list(Paths.get(""String_Node_Str"")).forEach(path -> {
    if (path.getFileName().toString().startsWith(baseFileName)) {
      pairFilePaths.add(path);
    }
  }
);
  Assert.assertEquals(""String_Node_Str"",expectedNumberOfFiles,pairFilePaths.size());
}","private void testDeriveAndSaveSortedNeighborPairs(final int zNeighborDistance,final int expectedNumberOfFiles) throws Exception {
  final String toJson=baseFileName + ""String_Node_Str"";
  final MockTilePairClient client=new MockTilePairClient(getTestParameters(zNeighborDistance,3,toJson),1.0,2.0,3.0,4.0,5.0);
  client.deriveAndSaveSortedNeighborPairs();
  final List<Path> pairFilePaths=new ArrayList<>();
  Files.list(Paths.get(""String_Node_Str"")).forEach(path -> {
    if (path.getFileName().toString().startsWith(baseFileName)) {
      pairFilePaths.add(path);
    }
  }
);
  Assert.assertEquals(""String_Node_Str"",expectedNumberOfFiles,pairFilePaths.size());
}",0.9831804281345564
25503,"@Override public List<Double> getZValues() throws IOException {
  return Arrays.asList(1.0,2.0,3.0,4.0,5.0);
}","@Override public List<Double> getZValues() throws IOException {
  return zValues;
}",0.8082901554404145
25504,"public MockTilePairClient(final TilePairClient.Parameters p) throws IllegalArgumentException {
  super(p);
}","public MockTilePairClient(final TilePairClient.Parameters p,final Double... zValues) throws IllegalArgumentException {
  super(p);
  this.zValues=Arrays.asList(zValues);
}",0.7741935483870968
25505,"@Override public Iterator<Integer> call(final Integer partitionIndex,final Iterator<CanvasMatches> matchesIterator) throws Exception {
  LogUtilities.setupExecutorLog4j(""String_Node_Str"" + partitionIndex);
  String previousCollection=null;
  String currentCollection;
  final List<CanvasMatches> matchesList=new ArrayList<>();
  int savedMatchCount=0;
  CanvasMatches canvasMatches;
  while (matchesIterator.hasNext()) {
    canvasMatches=matchesIterator.next();
    if (canvasMatches.size() > 0) {
      currentCollection=pIdToCollectionMap.get(canvasMatches.getpId());
      if (currentCollection == null) {
        throw new IllegalStateException(""String_Node_Str"" + canvasMatches.getpId());
      }
 else       if (!currentCollection.equals(previousCollection)) {
        savedMatchCount+=saveMatchesAndClearList(previousCollection,matchesList);
        previousCollection=currentCollection;
      }
      matchesList.add(canvasMatches);
    }
  }
  savedMatchCount+=saveMatchesAndClearList(previousCollection,matchesList);
  return Collections.singletonList(savedMatchCount).iterator();
}","@Override public Iterator<Integer> call(final Integer partitionIndex,final Iterator<CanvasMatches> matchesIterator) throws Exception {
  LogUtilities.setupExecutorLog4j(""String_Node_Str"" + partitionIndex);
  String previousCollection=null;
  String currentCollection;
  final List<CanvasMatches> matchesList=new ArrayList<>();
  int savedMatchCount=0;
  CanvasMatches canvasMatches;
  while (matchesIterator.hasNext()) {
    canvasMatches=matchesIterator.next();
    if (canvasMatches.size() > 0) {
      currentCollection=pIdToCollectionMap.get(canvasMatches.getOriginalPId());
      if (currentCollection == null) {
        throw new IllegalStateException(""String_Node_Str"" + canvasMatches.getpId());
      }
 else       if (!currentCollection.equals(previousCollection)) {
        savedMatchCount+=saveMatchesAndClearList(previousCollection,matchesList);
        previousCollection=currentCollection;
      }
      matchesList.add(canvasMatches);
    }
  }
  savedMatchCount+=saveMatchesAndClearList(previousCollection,matchesList);
  return Collections.singletonList(savedMatchCount).iterator();
}",0.9954421148587056
25506,"@Path(""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"" + ""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=404,message=""String_Node_Str"")}) public LeafTransformSpec buildAffineWarpFieldTransform(@PathParam(""String_Node_Str"") final String owner,@PathParam(""String_Node_Str"") final String project,@PathParam(""String_Node_Str"") final Double z,@QueryParam(""String_Node_Str"") final Integer consensusRows,@QueryParam(""String_Node_Str"") final Integer consensusColumns){
  LOG.info(""String_Node_Str"",owner,project,z);
  LeafTransformSpec transformSpec=null;
  final int consensusRowCount=consensusRows == null ? 10 : consensusRows;
  final int consensusColumnCount=consensusRows == null ? 10 : consensusColumns;
  try {
    final List<StackMetaData> projectStacks=renderDao.getStackMetaDataList(owner,project);
    final Map<String,StackMetaData> projectStackNamesToMetadataMap=new HashMap<>(projectStacks.size() * 2);
    for (    final StackMetaData stackMetaData : projectStacks) {
      projectStackNamesToMetadataMap.put(stackMetaData.getStackId().getStack(),stackMetaData);
    }
    final List<HierarchicalStack> alignedTierStacks=new ArrayList<>(projectStacks.size());
    HierarchicalStack hierarchicalStack;
    for (    final StackMetaData stackMetaData : projectStacks) {
      hierarchicalStack=stackMetaData.getHierarchicalData();
      if ((hierarchicalStack != null) && (projectStackNamesToMetadataMap.containsKey(hierarchicalStack.getAlignedStackId().getStack()))) {
        alignedTierStacks.add(hierarchicalStack);
      }
    }
    StackId alignedStackId;
    StackStats alignedStackStats;
    Bounds alignedStackBounds;
    AffineModel2D relativeAlignedModel;
    final double[] affineMatrixElements=new double[6];
    TileSpec tileSpecForZ;
    if (alignedTierStacks.size() > 0) {
      LOG.info(""String_Node_Str"",z,alignedTierStacks.size());
      AffineWarpField warpField=null;
      final Map<HierarchicalStack,AffineWarpField> tierStackToConsensusFieldMap=new HashMap<>();
      double[] locationOffsets=AffineWarpFieldTransform.EMPTY_OFFSETS;
      for (      final HierarchicalStack tierStack : alignedTierStacks) {
        if (warpField == null) {
          warpField=new AffineWarpField(tierStack.getTotalTierFullScaleWidth(),tierStack.getTotalTierFullScaleHeight(),tierStack.getTotalTierRowCount(),tierStack.getTotalTierColumnCount(),AffineWarpField.getDefaultInterpolatorFactory());
          final StackMetaData parentStackMetadata=getStackMetaData(tierStack.getParentTierStackId());
          final StackStats parentStats=parentStackMetadata.getStats();
          if (parentStats != null) {
            final Bounds parentBounds=parentStats.getStackBounds();
            locationOffsets=new double[]{parentBounds.getMinX(),parentBounds.getMinY()};
          }
        }
        alignedStackId=tierStack.getAlignedStackId();
        alignedStackBounds=null;
        alignedStackStats=projectStackNamesToMetadataMap.get(alignedStackId.getStack()).getStats();
        if (alignedStackStats != null) {
          alignedStackBounds=alignedStackStats.getStackBounds();
        }
        if (alignedStackBounds == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + z + ""String_Node_Str""+ alignedStackId+ ""String_Node_Str"");
        }
        final Set<String> multiConsensusGroupIds=matchDao.getMultiConsensusGroupIds(tierStack.getMatchCollectionId());
        if ((multiConsensusGroupIds.size() > 0) && (multiConsensusGroupIds.contains(z.toString()))) {
          final Bounds tierStackBounds=tierStack.getFullScaleBounds();
          final ConsensusWarpFieldBuilder builder=new ConsensusWarpFieldBuilder(tierStackBounds.getDeltaX(),tierStackBounds.getDeltaY(),consensusRowCount,consensusColumnCount);
          final String groupId=z.toString();
          final List<CanvasMatches> canvasMatchesList=matchDao.getMatchesOutsideGroup(tierStack.getMatchCollectionId(),z.toString());
          final Map<String,List<RealPoint>> tileIdToPoints=new HashMap<>();
          for (          final CanvasMatches pair : canvasMatchesList) {
            final String tileId;
            final List<RealPoint> points;
            if (groupId.equals(pair.getpGroupId())) {
              tileId=pair.getpId();
              points=pair.getMatches().getPList();
            }
 else {
              tileId=pair.getqId();
              points=pair.getMatches().getQList();
            }
            final List<RealPoint> savedPoints=tileIdToPoints.get(tileId);
            if (savedPoints == null) {
              tileIdToPoints.put(tileId,points);
            }
 else {
              savedPoints.addAll(points);
            }
          }
          for (          final String tileId : tileIdToPoints.keySet()) {
            tileSpecForZ=renderDao.getTileSpec(alignedStackId,tileId,false);
            relativeAlignedModel=getRelativeAlignedModel(tierStack,tileSpecForZ,alignedStackId,alignedStackBounds.getMinX(),alignedStackBounds.getMinY());
            builder.addConsensusSetData(relativeAlignedModel,tileIdToPoints.get(tileId));
          }
          tierStackToConsensusFieldMap.put(tierStack,builder.build());
        }
 else {
          tileSpecForZ=renderDao.getTileSpec(alignedStackId,tierStack.getTileIdForZ(z),false);
          relativeAlignedModel=getRelativeAlignedModel(tierStack,tileSpecForZ,alignedStackId,alignedStackBounds.getMinX(),alignedStackBounds.getMinY());
          relativeAlignedModel.toArray(affineMatrixElements);
          warpField.set(tierStack.getTierRow(),tierStack.getTierColumn(),affineMatrixElements);
        }
      }
      if ((warpField != null) && (tierStackToConsensusFieldMap.size() > 0)) {
        LOG.info(""String_Node_Str"",tierStackToConsensusFieldMap.size());
        final AffineWarpField hiResField=warpField.getHighResolutionCopy(consensusRowCount,consensusColumnCount);
        for (        final HierarchicalStack tierStack : tierStackToConsensusFieldMap.keySet()) {
          final AffineWarpField consensusField=tierStackToConsensusFieldMap.get(tierStack);
          final int startHiResRow=tierStack.getTierRow() * consensusRowCount;
          final int startHiResColumn=tierStack.getTierColumn() * consensusColumnCount;
          for (int row=0; row < consensusRowCount; row++) {
            for (int column=0; column < consensusColumnCount; column++) {
              hiResField.set((startHiResRow + row),(startHiResColumn + column),consensusField.get(row,column));
            }
          }
        }
        warpField=hiResField;
      }
      final String warpFieldTransformId=z + ""String_Node_Str"";
      final AffineWarpFieldTransform warpFieldTransform=new AffineWarpFieldTransform(locationOffsets,warpField);
      transformSpec=new LeafTransformSpec(warpFieldTransformId,null,AffineWarpFieldTransform.class.getName(),warpFieldTransform.toDataString());
    }
 else {
      throw new ObjectNotFoundException(""String_Node_Str"" + owner + ""String_Node_Str""+ project+ ""String_Node_Str"");
    }
  }
 catch (  final Throwable t) {
    RenderServiceUtil.throwServiceException(t);
  }
  return transformSpec;
}","@Path(""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"" + ""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=404,message=""String_Node_Str"")}) public LeafTransformSpec buildAffineWarpFieldTransform(@PathParam(""String_Node_Str"") final String owner,@PathParam(""String_Node_Str"") final String project,@PathParam(""String_Node_Str"") final Double z,@QueryParam(""String_Node_Str"") final Integer consensusRows,@QueryParam(""String_Node_Str"") final Integer consensusColumns){
  LOG.info(""String_Node_Str"",owner,project,z);
  LeafTransformSpec transformSpec=null;
  final int consensusRowCount=consensusRows == null ? 10 : consensusRows;
  final int consensusColumnCount=consensusRows == null ? 10 : consensusColumns;
  try {
    final List<StackMetaData> projectStacks=renderDao.getStackMetaDataList(owner,project);
    final Map<String,StackMetaData> projectStackNamesToMetadataMap=new HashMap<>(projectStacks.size() * 2);
    for (    final StackMetaData stackMetaData : projectStacks) {
      projectStackNamesToMetadataMap.put(stackMetaData.getStackId().getStack(),stackMetaData);
    }
    final List<HierarchicalStack> alignedTierStacks=new ArrayList<>(projectStacks.size());
    HierarchicalStack hierarchicalStack;
    for (    final StackMetaData stackMetaData : projectStacks) {
      hierarchicalStack=stackMetaData.getHierarchicalData();
      if ((hierarchicalStack != null) && (projectStackNamesToMetadataMap.containsKey(hierarchicalStack.getAlignedStackId().getStack()))) {
        alignedTierStacks.add(hierarchicalStack);
      }
    }
    StackId alignedStackId;
    StackStats alignedStackStats;
    Bounds alignedStackBounds;
    AffineModel2D relativeAlignedModel;
    final double[] affineMatrixElements=new double[6];
    TileSpec tileSpecForZ;
    if (alignedTierStacks.size() > 0) {
      LOG.info(""String_Node_Str"",z,alignedTierStacks.size());
      AffineWarpField warpField=null;
      final Map<HierarchicalStack,AffineWarpField> tierStackToConsensusFieldMap=new HashMap<>();
      double[] locationOffsets=AffineWarpFieldTransform.EMPTY_OFFSETS;
      for (      final HierarchicalStack tierStack : alignedTierStacks) {
        if (warpField == null) {
          warpField=new AffineWarpField(tierStack.getTotalTierFullScaleWidth(),tierStack.getTotalTierFullScaleHeight(),tierStack.getTotalTierRowCount(),tierStack.getTotalTierColumnCount(),AffineWarpField.getDefaultInterpolatorFactory());
          final StackMetaData parentStackMetadata=getStackMetaData(tierStack.getParentTierStackId());
          final StackStats parentStats=parentStackMetadata.getStats();
          if (parentStats != null) {
            final Bounds parentBounds=parentStats.getStackBounds();
            locationOffsets=new double[]{parentBounds.getMinX(),parentBounds.getMinY()};
          }
        }
        alignedStackId=tierStack.getAlignedStackId();
        alignedStackBounds=null;
        alignedStackStats=projectStackNamesToMetadataMap.get(alignedStackId.getStack()).getStats();
        if (alignedStackStats != null) {
          alignedStackBounds=alignedStackStats.getStackBounds();
        }
        if (alignedStackBounds == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + z + ""String_Node_Str""+ alignedStackId+ ""String_Node_Str"");
        }
        final String groupId=z.toString();
        if (tierStack.hasSplitGroupId(groupId)) {
          final Bounds tierStackBounds=tierStack.getFullScaleBounds();
          final ConsensusWarpFieldBuilder builder=new ConsensusWarpFieldBuilder(tierStackBounds.getDeltaX(),tierStackBounds.getDeltaY(),consensusRowCount,consensusColumnCount);
          final List<CanvasMatches> canvasMatchesList=matchDao.getMatchesOutsideGroup(tierStack.getMatchCollectionId(),groupId);
          final CanvasNameToPointsMap nameToPointsForGroup=new CanvasNameToPointsMap(1 / tierStack.getScale());
          nameToPointsForGroup.addPointsForGroup(groupId,canvasMatchesList);
          for (          final String tileId : nameToPointsForGroup.getNames()) {
            tileSpecForZ=renderDao.getTileSpec(alignedStackId,tileId,false);
            relativeAlignedModel=getRelativeAlignedModel(tierStack,tileSpecForZ,alignedStackId,alignedStackBounds.getMinX(),alignedStackBounds.getMinY());
            builder.addConsensusSetData(relativeAlignedModel,nameToPointsForGroup.getPoints(tileId));
          }
          tierStackToConsensusFieldMap.put(tierStack,builder.build());
        }
 else {
          tileSpecForZ=renderDao.getTileSpec(alignedStackId,tierStack.getTileIdForZ(z),false);
          relativeAlignedModel=getRelativeAlignedModel(tierStack,tileSpecForZ,alignedStackId,alignedStackBounds.getMinX(),alignedStackBounds.getMinY());
          relativeAlignedModel.toArray(affineMatrixElements);
          warpField.set(tierStack.getTierRow(),tierStack.getTierColumn(),affineMatrixElements);
        }
      }
      if ((warpField != null) && (tierStackToConsensusFieldMap.size() > 0)) {
        LOG.info(""String_Node_Str"",tierStackToConsensusFieldMap.size());
        final AffineWarpField hiResField=warpField.getHighResolutionCopy(consensusRowCount,consensusColumnCount);
        for (        final HierarchicalStack tierStack : tierStackToConsensusFieldMap.keySet()) {
          final AffineWarpField consensusField=tierStackToConsensusFieldMap.get(tierStack);
          final int startHiResRow=tierStack.getTierRow() * consensusRowCount;
          final int startHiResColumn=tierStack.getTierColumn() * consensusColumnCount;
          for (int row=0; row < consensusRowCount; row++) {
            for (int column=0; column < consensusColumnCount; column++) {
              hiResField.set((startHiResRow + row),(startHiResColumn + column),consensusField.get(row,column));
            }
          }
        }
        warpField=hiResField;
      }
      final String warpFieldTransformId=z + ""String_Node_Str"";
      final AffineWarpFieldTransform warpFieldTransform=new AffineWarpFieldTransform(locationOffsets,warpField);
      transformSpec=new LeafTransformSpec(warpFieldTransformId,null,AffineWarpFieldTransform.class.getName(),warpFieldTransform.toDataString());
    }
 else {
      throw new ObjectNotFoundException(""String_Node_Str"" + owner + ""String_Node_Str""+ project+ ""String_Node_Str"");
    }
  }
 catch (  final Throwable t) {
    RenderServiceUtil.throwServiceException(t);
  }
  return transformSpec;
}",0.8525067306992651
25507,"@JsonIgnore public List<OrderedCanvasIdPair> getNeighborPairs(final List<Double> zValues,final int zNeighborDistance){
  final int n=zValues.size();
  final List<OrderedCanvasIdPair> neighborPairs=new ArrayList<>(n * zNeighborDistance);
  Double pz;
  Double qz;
  CanvasId p;
  CanvasId q;
  for (int i=0; i < n; i++) {
    pz=zValues.get(i);
    p=new CanvasId(pz.toString(),getTileIdForZ(pz));
    for (int k=i + 1; k < n && k < i + zNeighborDistance; k++) {
      qz=zValues.get(k);
      q=new CanvasId(qz.toString(),getTileIdForZ(qz));
      neighborPairs.add(new OrderedCanvasIdPair(p,q));
    }
  }
  return neighborPairs;
}","/** 
 * Pairs each specified layer (z value) with the specified number of adjacent layers.
 * @param zValues            ordered list of z values for this stack.
 * @param zNeighborDistance  number of adjacent layers to pair with each layer.
 * @return list of layer pair identifiers.
 */
@JsonIgnore public List<OrderedCanvasIdPair> getNeighborPairs(final List<Double> zValues,final int zNeighborDistance){
  final int n=zValues.size();
  final List<OrderedCanvasIdPair> neighborPairs=new ArrayList<>(n * zNeighborDistance);
  Double pz;
  Double qz;
  CanvasId p;
  CanvasId q;
  for (int i=0; i < n; i++) {
    pz=zValues.get(i);
    p=new CanvasId(pz.toString(),getTileIdForZ(pz));
    for (int k=i + 1; k < n && k <= i + zNeighborDistance; k++) {
      qz=zValues.get(k);
      q=new CanvasId(qz.toString(),getTileIdForZ(qz));
      neighborPairs.add(new OrderedCanvasIdPair(p,q));
    }
  }
  return neighborPairs;
}",0.8139085640695428
25508,"@Override public Integer call(final Double z) throws Exception {
  LogUtilities.setupExecutorLog4j(z.toString());
  final StackId alignedStackId=tierZeroStack.getAlignedStackId();
  final RenderDataClient alignedDataClient=new RenderDataClient(baseDataUrl,alignedStackId.getOwner(),alignedStackId.getProject());
  final StackMetaData alignedStackMetaData=alignedDataClient.getStackMetaData(alignedStackId.getStack());
  final Bounds alignedStackBounds=alignedStackMetaData.getStats().getStackBounds();
  final ResolvedTileSpecCollection tileSpecCollection=alignedDataClient.getResolvedTiles(alignedStackId.getStack(),z);
  if (tileSpecCollection.getTileCount() != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + z + ""String_Node_Str""+ alignedStackId+ ""String_Node_Str""+ tileSpecCollection.getTileCount()+ ""String_Node_Str"");
  }
  final TileSpec layerTileSpec=tileSpecCollection.getTileSpecs().iterator().next();
  final TransformSpec roughAlignmentTransform;
  final TransformSpec lastTransform=layerTileSpec.getLastTransform();
  final CoordinateTransform transformInstance=lastTransform.getNewInstance();
  if (transformInstance instanceof AffineModel2D) {
    final AffineModel2D scaledAffineModel=(AffineModel2D)transformInstance;
    final AffineModel2D fullScaleRelativeModel=tierZeroStack.getFullScaleRelativeModel(scaledAffineModel,alignedStackBounds.getMinX(),alignedStackBounds.getMinY());
    final double[] affineMatrixElements=new double[6];
    fullScaleRelativeModel.toArray(affineMatrixElements);
    final mpicbg.trakem2.transform.AffineModel2D specModel=new mpicbg.trakem2.transform.AffineModel2D();
    specModel.set(fullScaleRelativeModel);
    final String roughTransformId=""String_Node_Str"" + z + ""String_Node_Str"";
    roughAlignmentTransform=new LeafTransformSpec(roughTransformId,null,specModel.getClass().getName(),specModel.toDataString());
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + layerTileSpec.getTileId() + ""String_Node_Str""+ transformInstance.getClass().getName()+ ""String_Node_Str"");
  }
  final StackId montageStackId=tierZeroStack.getParentTierStackId();
  final RenderDataClient montageDataClient=new RenderDataClient(baseDataUrl,montageStackId.getOwner(),montageStackId.getProject());
  final ResolvedTileSpecCollection tileCollection=montageDataClient.getResolvedTiles(montageStackId.getStack(),z);
  tileCollection.addTransformSpecToCollection(roughAlignmentTransform);
  tileCollection.addReferenceTransformToAllTiles(roughAlignmentTransform.getId(),false);
  final RenderDataClient roughDataClient=new RenderDataClient(baseDataUrl,roughStackId.getOwner(),roughStackId.getProject());
  roughDataClient.saveResolvedTiles(tileCollection,roughStackId.getStack(),z);
  return tileCollection.getTileCount();
}","@Override public Integer call(final Double z) throws Exception {
  LogUtilities.setupExecutorLog4j(z.toString());
  final StackId montageStackId=tierZeroStack.getParentTierStackId();
  final RenderDataClient montageDataClient=new RenderDataClient(baseDataUrl,montageStackId.getOwner(),montageStackId.getProject());
  final Bounds montageLayerBounds=montageDataClient.getLayerBounds(montageStackId.getStack(),z);
  final StackId alignedStackId=tierZeroStack.getAlignedStackId();
  final RenderDataClient alignedDataClient=new RenderDataClient(baseDataUrl,alignedStackId.getOwner(),alignedStackId.getProject());
  final ResolvedTileSpecCollection tileSpecCollection=alignedDataClient.getResolvedTiles(alignedStackId.getStack(),z);
  if (tileSpecCollection.getTileCount() != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + z + ""String_Node_Str""+ alignedStackId+ ""String_Node_Str""+ tileSpecCollection.getTileCount()+ ""String_Node_Str"");
  }
  final TileSpec layerTileSpec=tileSpecCollection.getTileSpecs().iterator().next();
  final TransformSpec roughAlignmentTransform;
  final TransformSpec lastTransform=layerTileSpec.getLastTransform();
  final CoordinateTransform transformInstance=lastTransform.getNewInstance();
  if (transformInstance instanceof AffineModel2D) {
    final AffineModel2D scaledAffineModel=(AffineModel2D)transformInstance;
    final AffineModel2D fullScaleRoughModel=tierZeroStack.getFullScaleRoughModel(scaledAffineModel,montageLayerBounds.getMinX(),montageLayerBounds.getMinY());
    final mpicbg.trakem2.transform.AffineModel2D specModel=new mpicbg.trakem2.transform.AffineModel2D();
    specModel.set(fullScaleRoughModel);
    final String roughTransformId=""String_Node_Str"" + z + ""String_Node_Str"";
    roughAlignmentTransform=new LeafTransformSpec(roughTransformId,null,specModel.getClass().getName(),specModel.toDataString());
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + layerTileSpec.getTileId() + ""String_Node_Str""+ transformInstance.getClass().getName()+ ""String_Node_Str"");
  }
  final ResolvedTileSpecCollection tileCollection=montageDataClient.getResolvedTiles(montageStackId.getStack(),z);
  tileCollection.addTransformSpecToCollection(roughAlignmentTransform);
  tileCollection.addReferenceTransformToAllTiles(roughAlignmentTransform.getId(),false);
  final RenderDataClient roughDataClient=new RenderDataClient(baseDataUrl,roughStackId.getOwner(),roughStackId.getProject());
  roughDataClient.saveResolvedTiles(tileCollection,roughStackId.getStack(),z);
  return tileCollection.getTileCount();
}",0.6479030754892824
25509,"private void generateTierMatchesByStack(final MatchRenderParameters matchRenderParameters,final MatchClipParameters emptyClipParameters) throws IOException, URISyntaxException {
  for (  final HierarchicalStack tierStack : tierStacks) {
    if (tierStack.requiresMatchDerivation()) {
      final MatchCollectionId matchCollectionId=tierStack.getMatchCollectionId();
      LOG.info(""String_Node_Str"",matchCollectionId.getName());
      final MatchStorageFunction matchStorageFunction=new MatchStorageFunction(parameters.renderWeb.baseDataUrl,matchCollectionId.getOwner(),matchCollectionId.getName());
      final long savedMatchPairCount=SIFTPointMatchClient.generateMatchesForPairs(sparkContext,getRenderablePairsForStack(tierStack),parameters.renderWeb.baseDataUrl,matchRenderParameters,parameters.match,emptyClipParameters,matchStorageFunction);
      tierStack.setSavedMatchPairCount(savedMatchPairCount);
      driverTierRender.setHierarchicalData(tierStack.getSplitStackId().getStack(),tierStack);
    }
  }
}","private void generateTierMatchesByStack(final MatchRenderParameters matchRenderParameters,final MatchClipParameters emptyClipParameters) throws IOException, URISyntaxException {
  LOG.info(""String_Node_Str"");
  for (  final HierarchicalStack tierStack : tierStacks) {
    if (tierStack.requiresMatchDerivation()) {
      final MatchCollectionId matchCollectionId=tierStack.getMatchCollectionId();
      LOG.info(""String_Node_Str"",matchCollectionId.getName());
      final MatchStorageFunction matchStorageFunction=new MatchStorageFunction(parameters.renderWeb.baseDataUrl,matchCollectionId.getOwner(),matchCollectionId.getName());
      final long savedMatchPairCount=SIFTPointMatchClient.generateMatchesForPairs(sparkContext,getRenderablePairsForStack(tierStack),parameters.renderWeb.baseDataUrl,matchRenderParameters,parameters.match,emptyClipParameters,matchStorageFunction);
      tierStack.setSavedMatchPairCount(savedMatchPairCount);
      persistHierarchicalData(tierStack);
    }
  }
  LOG.info(""String_Node_Str"");
}",0.7497546614327772
25510,"private void alignTier() throws IOException {
  LOG.info(""String_Node_Str"");
  final List<HierarchicalStack> stacksWithMatches=tierStacks.stream().filter(HierarchicalStack::hasMatchPairs).collect(Collectors.toList());
  final List<HierarchicalStack> stacksToAlign;
  if (parameters.keepExisting(PipelineStep.ALIGN)) {
    stacksToAlign=stacksWithMatches.stream().filter(HierarchicalStack::requiresAlignment).collect(Collectors.toList());
    LOG.info(""String_Node_Str"",(stacksWithMatches.size() - stacksToAlign.size()),stacksWithMatches.size());
  }
 else {
    stacksToAlign=stacksWithMatches;
  }
  if (stacksToAlign.size() > 0) {
    final EMAlignerTool solver=new EMAlignerTool(new File(parameters.solverScript),new File(parameters.solverParametersTemplate));
    final Broadcast<EMAlignerTool> broadcastEMAlignerTool=sparkContext.broadcast(solver);
    final HierarchicalTierSolveFunction solveStacksFunction=new HierarchicalTierSolveFunction(parameters.boxBaseDataUrl,broadcastEMAlignerTool);
    for (    final HierarchicalStack tierStack : stacksToAlign) {
      driverTierRender.deleteStack(tierStack.getAlignedStackId().getStack(),null);
    }
    final JavaRDD<HierarchicalStack> rddTierStacksToAlign=sparkContext.parallelize(stacksToAlign);
    final JavaRDD<HierarchicalStack> rddTierStacksAfterAlignment=rddTierStacksToAlign.map(solveStacksFunction);
    final List<HierarchicalStack> tierStacksAfterAlignment=rddTierStacksAfterAlignment.collect();
    LOG.info(""String_Node_Str"");
    final Map<String,HierarchicalStack> nameToUpdatedStackMap=new HashMap<>(tierStacksAfterAlignment.size() * 2);
    for (    final HierarchicalStack tierStack : tierStacksAfterAlignment) {
      final String tierStackName=tierStack.getSplitStackId().getStack();
      LOG.info(""String_Node_Str"",tierStackName,tierStack.getAlignmentQuality());
      driverTierRender.setHierarchicalData(tierStackName,tierStack);
      nameToUpdatedStackMap.put(tierStackName,tierStack);
    }
    HierarchicalStack tierStack;
    HierarchicalStack updatedStack;
    for (int i=0; i < tierStacks.size(); i++) {
      tierStack=tierStacks.get(i);
      updatedStack=nameToUpdatedStackMap.get(tierStack.getSplitStackId().getStack());
      if (updatedStack != null) {
        tierStacks.set(i,updatedStack);
      }
    }
  }
 else {
    LOG.info(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"");
}","private void alignTier() throws IOException {
  LOG.info(""String_Node_Str"");
  final List<HierarchicalStack> stacksWithMatches=tierStacks.stream().filter(HierarchicalStack::hasMatchPairs).collect(Collectors.toList());
  final List<HierarchicalStack> stacksToAlign;
  if (parameters.keepExisting(PipelineStep.ALIGN)) {
    stacksToAlign=stacksWithMatches.stream().filter(HierarchicalStack::requiresAlignment).collect(Collectors.toList());
    LOG.info(""String_Node_Str"",(stacksWithMatches.size() - stacksToAlign.size()),stacksWithMatches.size());
  }
 else {
    stacksToAlign=stacksWithMatches;
  }
  if (stacksToAlign.size() > 0) {
    final EMAlignerTool solver=new EMAlignerTool(new File(parameters.solverScript),new File(parameters.solverParametersTemplate));
    final Broadcast<EMAlignerTool> broadcastEMAlignerTool=sparkContext.broadcast(solver);
    final HierarchicalTierSolveFunction solveStacksFunction=new HierarchicalTierSolveFunction(parameters.boxBaseDataUrl,broadcastEMAlignerTool);
    for (    final HierarchicalStack tierStack : stacksToAlign) {
      driverTierRender.deleteStack(tierStack.getAlignedStackId().getStack(),null);
    }
    final JavaRDD<HierarchicalStack> rddTierStacksToAlign=sparkContext.parallelize(stacksToAlign);
    final JavaRDD<HierarchicalStack> rddTierStacksAfterAlignment=rddTierStacksToAlign.map(solveStacksFunction);
    final List<HierarchicalStack> tierStacksAfterAlignment=rddTierStacksAfterAlignment.collect();
    LOG.info(""String_Node_Str"");
    final Map<String,HierarchicalStack> nameToUpdatedStackMap=new HashMap<>(tierStacksAfterAlignment.size() * 2);
    for (    final HierarchicalStack tierStack : tierStacksAfterAlignment) {
      final String tierStackName=tierStack.getSplitStackId().getStack();
      LOG.info(""String_Node_Str"",tierStackName,tierStack.getAlignmentQuality());
      persistHierarchicalData(tierStack);
      nameToUpdatedStackMap.put(tierStackName,tierStack);
    }
    HierarchicalStack tierStack;
    HierarchicalStack updatedStack;
    for (int i=0; i < tierStacks.size(); i++) {
      tierStack=tierStacks.get(i);
      updatedStack=nameToUpdatedStackMap.get(tierStack.getSplitStackId().getStack());
      if (updatedStack != null) {
        tierStacks.set(i,updatedStack);
      }
    }
  }
 else {
    LOG.info(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"");
}",0.9917634635691658
25511,"private void generateMatchesForTier() throws IOException, URISyntaxException {
  LOG.info(""String_Node_Str"");
  final RenderDataClient driverMatchClient=new RenderDataClient(parameters.renderWeb.baseDataUrl,parameters.renderWeb.owner,""String_Node_Str"");
  final Map<String,Long> existingMatchCollectionPairCounts=getExistingMatchCollectionPairCounts(driverMatchClient);
  if (parameters.keepExisting(PipelineStep.MATCH)) {
    updateSavedMatchPairCounts(existingMatchCollectionPairCounts,false);
  }
 else {
    deleteExistingMatchCollectionsForTier(driverMatchClient,existingMatchCollectionPairCounts);
  }
  final MatchRenderParameters matchRenderParameters=new MatchRenderParameters();
  matchRenderParameters.fillWithNoise=parameters.fillWithNoise;
  matchRenderParameters.renderWithFilter=parameters.renderWithFilter;
  matchRenderParameters.renderWithoutMask=false;
  matchRenderParameters.renderScale=1.0;
  final MatchClipParameters emptyClipParameters=new MatchClipParameters();
  final int numberOfLayers=zValues.size();
  final long potentialPairsPerStack;
  if (parameters.zNeighborDistance >= numberOfLayers) {
    potentialPairsPerStack=getTriangularNumber(numberOfLayers);
  }
 else {
    potentialPairsPerStack=(numberOfLayers * parameters.zNeighborDistance) - getTriangularNumber(parameters.zNeighborDistance);
  }
  final long totalPotentialPairs=potentialPairsPerStack * tierStacks.size();
  if ((totalPotentialPairs < 1000) || ((potentialPairsPerStack < sparkContext.defaultParallelism()) && (totalPotentialPairs < 100000))) {
    generateTierMatchesInOneBatch(matchRenderParameters,emptyClipParameters,driverMatchClient);
  }
 else {
    generateTierMatchesByStack(matchRenderParameters,emptyClipParameters);
  }
  LOG.info(""String_Node_Str"");
}","private void generateMatchesForTier() throws IOException, URISyntaxException {
  LOG.info(""String_Node_Str"");
  final RenderDataClient driverMatchClient=new RenderDataClient(parameters.renderWeb.baseDataUrl,parameters.renderWeb.owner,""String_Node_Str"");
  final Map<String,Long> existingMatchPairCounts=getExistingMatchPairCounts(driverMatchClient);
  if (parameters.keepExisting(PipelineStep.MATCH)) {
    updateSavedMatchPairCounts(existingMatchPairCounts);
  }
 else {
    deleteExistingMatchDataForTier(driverMatchClient,existingMatchPairCounts);
  }
  final MatchRenderParameters matchRenderParameters=new MatchRenderParameters();
  matchRenderParameters.fillWithNoise=parameters.fillWithNoise;
  matchRenderParameters.renderWithFilter=parameters.renderWithFilter;
  matchRenderParameters.renderWithoutMask=false;
  matchRenderParameters.renderScale=1.0;
  final MatchClipParameters emptyClipParameters=new MatchClipParameters();
  final long potentialPairsPerStack=getPotentialPairsPerStack(zValues.size(),parameters.zNeighborDistance);
  final long totalPotentialPairs=potentialPairsPerStack * tierStacks.size();
  LOG.info(""String_Node_Str"",sparkContext.defaultParallelism(),potentialPairsPerStack,totalPotentialPairs);
  if ((totalPotentialPairs < 1000) || ((potentialPairsPerStack < sparkContext.defaultParallelism()) && (totalPotentialPairs < 100000))) {
    generateTierMatchesInOneBatch(matchRenderParameters,emptyClipParameters,driverMatchClient);
  }
 else {
    generateTierMatchesByStack(matchRenderParameters,emptyClipParameters);
  }
  LOG.info(""String_Node_Str"");
}",0.8152790211877051
25512,"private void generateTierMatchesInOneBatch(final MatchRenderParameters matchRenderParameters,final MatchClipParameters emptyClipParameters,final RenderDataClient driverMatchClient) throws IOException, URISyntaxException {
  final MultiCollectionMatchStorageFunction matchStorageFunction=new MultiCollectionMatchStorageFunction(parameters.renderWeb.baseDataUrl,parameters.renderWeb.owner);
  RenderableCanvasIdPairs renderableCanvasIdPairs=null;
  for (  final HierarchicalStack tierStack : tierStacks) {
    if (tierStack.requiresMatchDerivation()) {
      final String matchCollectionName=tierStack.getMatchCollectionId().getName();
      int fromIndex=0;
      if (renderableCanvasIdPairs == null) {
        renderableCanvasIdPairs=getRenderablePairsForStack(tierStack);
      }
 else {
        fromIndex=renderableCanvasIdPairs.size();
        addCanvasPairsForStack(tierStack,renderableCanvasIdPairs);
      }
      final List<OrderedCanvasIdPair> tierPairs=renderableCanvasIdPairs.getNeighborPairs().subList(fromIndex,renderableCanvasIdPairs.size());
      for (      final OrderedCanvasIdPair tierPair : tierPairs) {
        matchStorageFunction.mapPIdToCollection(tierPair.getP().getId(),matchCollectionName);
      }
    }
  }
  if (renderableCanvasIdPairs != null) {
    LOG.info(""String_Node_Str"",renderableCanvasIdPairs.size());
    final long savedMatchPairCount=SIFTPointMatchClient.generateMatchesForPairs(sparkContext,renderableCanvasIdPairs,parameters.renderWeb.baseDataUrl,matchRenderParameters,parameters.match,emptyClipParameters,matchStorageFunction);
    LOG.info(""String_Node_Str"",savedMatchPairCount);
    updateSavedMatchPairCounts(getExistingMatchCollectionPairCounts(driverMatchClient),true);
  }
}","private void generateTierMatchesInOneBatch(final MatchRenderParameters matchRenderParameters,final MatchClipParameters emptyClipParameters,final RenderDataClient driverMatchClient) throws IOException, URISyntaxException {
  LOG.info(""String_Node_Str"");
  final MultiCollectionMatchStorageFunction matchStorageFunction=new MultiCollectionMatchStorageFunction(parameters.renderWeb.baseDataUrl,parameters.renderWeb.owner);
  RenderableCanvasIdPairs renderableCanvasIdPairs=null;
  for (  final HierarchicalStack tierStack : tierStacks) {
    if (tierStack.requiresMatchDerivation()) {
      final String matchCollectionName=tierStack.getMatchCollectionId().getName();
      int fromIndex=0;
      if (renderableCanvasIdPairs == null) {
        renderableCanvasIdPairs=getRenderablePairsForStack(tierStack);
      }
 else {
        fromIndex=renderableCanvasIdPairs.size();
        addCanvasPairsForStack(tierStack,renderableCanvasIdPairs);
      }
      final List<OrderedCanvasIdPair> tierPairs=renderableCanvasIdPairs.getNeighborPairs().subList(fromIndex,renderableCanvasIdPairs.size());
      for (      final OrderedCanvasIdPair tierPair : tierPairs) {
        matchStorageFunction.mapPIdToCollection(tierPair.getP().getId(),matchCollectionName);
      }
    }
  }
  if (renderableCanvasIdPairs != null) {
    LOG.info(""String_Node_Str"",renderableCanvasIdPairs.size());
    final long savedMatchPairCount=SIFTPointMatchClient.generateMatchesForPairs(sparkContext,renderableCanvasIdPairs,parameters.renderWeb.baseDataUrl,matchRenderParameters,parameters.match,emptyClipParameters,matchStorageFunction);
    LOG.info(""String_Node_Str"",savedMatchPairCount);
    final Map<String,Long> existingMatchPairCounts=getExistingMatchPairCounts(driverMatchClient);
    for (    final HierarchicalStack tierStack : tierStacks) {
      if (tierStack.requiresMatchDerivation()) {
        long matchPairCount=0;
        final String collectionName=tierStack.getMatchCollectionId().getName();
        if (existingMatchPairCounts.containsKey(collectionName)) {
          matchPairCount=existingMatchPairCounts.get(collectionName);
        }
        tierStack.setSavedMatchPairCount(matchPairCount);
        persistHierarchicalData(tierStack);
      }
    }
  }
  LOG.info(""String_Node_Str"");
}",0.8415
25513,"private void updateSavedMatchPairCounts(final Map<String,Long> existingMatchCollectionPairCounts,final boolean persistResults) throws IOException {
  for (  final HierarchicalStack tierStack : tierStacks) {
    final String matchCollectionName=tierStack.getMatchCollectionId().getName();
    if (existingMatchCollectionPairCounts.containsKey(matchCollectionName)) {
      tierStack.setSavedMatchPairCount(existingMatchCollectionPairCounts.get(matchCollectionName));
      if (persistResults) {
        driverTierRender.setHierarchicalData(tierStack.getSplitStackId().getStack(),tierStack);
      }
    }
  }
}","private void updateSavedMatchPairCounts(final Map<String,Long> existingMatchCollectionPairCounts) throws IOException {
  for (  final HierarchicalStack tierStack : tierStacks) {
    final String matchCollectionName=tierStack.getMatchCollectionId().getName();
    tierStack.setSavedMatchPairCount(existingMatchCollectionPairCounts.get(matchCollectionName));
  }
}",0.6735324407826982
25514,"@Test public void testWarp() throws Exception {
  final int numberOfConcurrentTasks=1;
  final String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final ProcessTimer processTimer=new ProcessTimer();
  final HierarchicalAlignmentClient.Parameters parameters=new HierarchicalAlignmentClient.Parameters();
  parameters.parse(args);
  LOG.info(""String_Node_Str"",parameters);
  final String master=""String_Node_Str"" + numberOfConcurrentTasks + ""String_Node_Str"";
  final SparkConf sparkConf=new SparkConf().setMaster(master).setAppName(this.getClass().getSimpleName());
  final HierarchicalAlignmentClient client=new HierarchicalAlignmentClient(parameters,sparkConf);
  client.run();
  LOG.info(""String_Node_Str"",processTimer);
}","/** 
 * This test assumes access to a running render web service instance, so it is commented out. To run the test, uncomment the Test annotation and update the client arguments as needed.
 */
@SuppressWarnings(""String_Node_Str"") public void testWarp() throws Exception {
  final int numberOfConcurrentTasks=1;
  final String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final ProcessTimer processTimer=new ProcessTimer();
  final HierarchicalAlignmentClient.Parameters parameters=new HierarchicalAlignmentClient.Parameters();
  parameters.parse(args);
  LOG.info(""String_Node_Str"",parameters);
  final String master=""String_Node_Str"" + numberOfConcurrentTasks + ""String_Node_Str"";
  final SparkConf sparkConf=new SparkConf().setMaster(master).setAppName(this.getClass().getSimpleName());
  final HierarchicalAlignmentClient client=new HierarchicalAlignmentClient(parameters,sparkConf);
  client.run();
  LOG.info(""String_Node_Str"",processTimer);
}",0.9200551343900758
25515,"/** 
 * Adjusts these parameters to clip for montage pair point match rendering.
 * @param clipOffsets  full scale x[0] and y[1] offsets for clipped area.
 * @param clipWidth    number of full scale pixels to include in clipped members of left/right pairs.
 * @param clipHeight   number of full scale pixels to include in clipped members of top/bottom pairs.
 */
public void clipForMontagePair(final double[] clipOffsets,final Integer clipWidth,final Integer clipHeight){
  if (clipOffsets != null) {
    if (clipWidth != null) {
      x=x + clipOffsets[0];
      width=clipWidth;
    }
    if (clipHeight != null) {
      y=y + clipOffsets[1];
      height=clipHeight;
    }
  }
}","/** 
 * Adjusts these parameters to clip for montage pair point match rendering.
 * @param canvasId     canvas information.
 * @param clipWidth    number of full scale pixels to include in clipped members of left/right pairs.
 * @param clipHeight   number of full scale pixels to include in clipped members of top/bottom pairs.
 */
public void clipForMontagePair(final CanvasId canvasId,final Integer clipWidth,final Integer clipHeight){
  final MontageRelativePosition relativePosition=canvasId.getRelativePosition();
  if (relativePosition != null) {
    final double[] clipOffsets=canvasId.getClipOffsets();
switch (relativePosition) {
case TOP:
case BOTTOM:
      if (clipHeight != null) {
        y=y + clipOffsets[1];
        height=clipHeight;
      }
    break;
case LEFT:
case RIGHT:
  if (clipWidth != null) {
    x=x + clipOffsets[0];
    width=clipWidth;
  }
break;
}
}
}",0.237851662404092
25516,"public void clipForMontagePair(final Bounds bounds,final Integer clipWidth,final Integer clipHeight){
  canvasId.setClipOffsets(bounds.getDeltaX().intValue(),bounds.getDeltaY().intValue(),clipWidth,clipHeight);
  renderParameters.clipForMontagePair(canvasId.getClipOffsets(),clipWidth,clipHeight);
}","public void clipForMontagePair(final Bounds bounds,final Integer clipWidth,final Integer clipHeight){
  canvasId.setClipOffsets(bounds.getDeltaX().intValue(),bounds.getDeltaY().intValue(),clipWidth,clipHeight);
  renderParameters.clipForMontagePair(canvasId,clipWidth,clipHeight);
}",0.9707401032702238
25517,"public RenderParameters getRenderParameters(final CanvasId canvasId) throws IllegalArgumentException {
  final RenderParameters renderParameters=RenderParameters.loadFromUrl(getRenderParametersUrl(canvasId));
  if ((clipWidth != null) || (clipHeight != null)) {
    canvasId.setClipOffsets(renderParameters.getWidth(),renderParameters.getHeight(),clipWidth,clipHeight);
    renderParameters.clipForMontagePair(canvasId.getClipOffsets(),clipWidth,clipHeight);
  }
  return renderParameters;
}","public RenderParameters getRenderParameters(final CanvasId canvasId) throws IllegalArgumentException {
  final RenderParameters renderParameters=RenderParameters.loadFromUrl(getRenderParametersUrl(canvasId));
  if ((clipWidth != null) || (clipHeight != null)) {
    canvasId.setClipOffsets(renderParameters.getWidth(),renderParameters.getHeight(),clipWidth,clipHeight);
    renderParameters.clipForMontagePair(canvasId,clipWidth,clipHeight);
  }
  return renderParameters;
}",0.9823834196891192
25518,"public int generateMipmapsForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z);
  final ResolvedTileSpecCollection tiles=renderDataClient.getResolvedTiles(stack,z);
  final int tileCount=tiles.getTileCount();
  final int tilesPerGroup=(int)Math.ceil((double)tileCount / parameters.numberOfRenderGroups);
  final int startTile=(parameters.renderGroup - 1) * tilesPerGroup;
  final int stopTile=startTile + tilesPerGroup;
  int count=0;
  int rendered=0;
  for (  final TileSpec tileSpec : tiles.getTileSpecs()) {
    if ((count >= startTile) && (count < stopTile)) {
      generateMissingMipmapFiles(tileSpec);
      rendered++;
    }
    count++;
  }
  LOG.info(""String_Node_Str"",tileCount,tilesPerGroup,parameters.numberOfRenderGroups,startTile,stopTile);
  LOG.info(""String_Node_Str"",rendered,z);
  return count;
}","public int generateMipmapsForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z);
  final ResolvedTileSpecCollection tiles=renderDataClient.getResolvedTiles(stack,z);
  final int tileCount=tiles.getTileCount();
  final int tilesPerGroup=(int)Math.ceil((double)tileCount / parameters.numberOfRenderGroups);
  final int startTile=(parameters.renderGroup - 1) * tilesPerGroup;
  final int stopTile=startTile + tilesPerGroup;
  final List<TileSpec> tileSpecsToRender=new ArrayList<>(tiles.getTileSpecs()).subList(startTile,stopTile);
  for (  final TileSpec tileSpec : tileSpecsToRender) {
    generateMissingMipmapFiles(tileSpec);
  }
  final int renderedTileCount=tileSpecsToRender.size();
  LOG.info(""String_Node_Str"",renderedTileCount,z,parameters.renderGroup,startTile,stopTile - 1,tileCount);
  return renderedTileCount;
}",0.6945107398568019
25519,"public static List<HierarchicalStack> splitTier(final StackId roughTilesStackId,final Bounds parentStackBounds,final int maxPixelsPerDimension,final int tier){
  final List<HierarchicalStack> splitStacks=new ArrayList<>();
  final int parentWidth=(int)Math.ceil(parentStackBounds.getDeltaX());
  final int parentHeight=(int)Math.ceil(parentStackBounds.getDeltaY());
  final int rowsAndColumns=deriveRowsAndColumnsForTier(tier);
  final int maxDimension=Math.max(parentWidth,parentHeight);
  final int maxDimensionPerCell=ceilIntDivide(maxDimension,rowsAndColumns);
  final int cellWidth=ceilIntDivide(parentWidth,rowsAndColumns);
  final int cellHeight=ceilIntDivide(parentHeight,rowsAndColumns);
  final double scale=(double)maxPixelsPerDimension / maxDimensionPerCell;
  int row=0;
  int column;
  Bounds splitStackBounds;
  final int parentMinX=parentStackBounds.getMinX().intValue();
  final int parentMinY=parentStackBounds.getMinY().intValue();
  final double parentMinZ=parentStackBounds.getMinZ();
  final int parentMaxX=(int)Math.ceil(parentStackBounds.getMaxX());
  final int parentMaxY=(int)Math.ceil(parentStackBounds.getMaxY());
  final double parentMaxZ=parentStackBounds.getMaxZ();
  for (int y=parentMinY; y < parentMaxY; y+=cellHeight) {
    column=0;
    for (int x=parentMinX; x < parentMaxX; x+=cellWidth) {
      splitStackBounds=new Bounds((double)x,(double)y,parentMinZ,(double)x + cellWidth,(double)y + cellHeight,parentMaxZ);
      splitStacks.add(new HierarchicalStack(roughTilesStackId,tier,row,column,rowsAndColumns,rowsAndColumns,scale,splitStackBounds));
      column++;
    }
    row++;
  }
  return splitStacks;
}","public static List<HierarchicalStack> splitTier(final StackId roughTilesStackId,final Bounds parentStackBounds,final int maxPixelsPerDimension,final int tier){
  final List<HierarchicalStack> splitStacks=new ArrayList<>();
  final int parentWidth=(int)Math.ceil(parentStackBounds.getDeltaX());
  final int parentHeight=(int)Math.ceil(parentStackBounds.getDeltaY());
  final int rowsAndColumns=deriveRowsAndColumnsForTier(tier);
  final int maxDimension=Math.max(parentWidth,parentHeight);
  final int maxDimensionPerCell=ceilIntDivide(maxDimension,rowsAndColumns);
  final int cellWidth=ceilIntDivide(parentWidth,rowsAndColumns);
  final int cellHeight=ceilIntDivide(parentHeight,rowsAndColumns);
  final double scale=Math.min(1.0,(double)maxPixelsPerDimension / maxDimensionPerCell);
  int row=0;
  int column;
  Bounds splitStackBounds;
  final int parentMinX=parentStackBounds.getMinX().intValue();
  final int parentMinY=parentStackBounds.getMinY().intValue();
  final double parentMinZ=parentStackBounds.getMinZ();
  final int parentMaxX=(int)Math.ceil(parentStackBounds.getMaxX());
  final int parentMaxY=(int)Math.ceil(parentStackBounds.getMaxY());
  final double parentMaxZ=parentStackBounds.getMaxZ();
  for (int y=parentMinY; y < parentMaxY; y+=cellHeight) {
    column=0;
    for (int x=parentMinX; x < parentMaxX; x+=cellWidth) {
      splitStackBounds=new Bounds((double)x,(double)y,parentMinZ,(double)x + cellWidth,(double)y + cellHeight,parentMaxZ);
      splitStacks.add(new HierarchicalStack(roughTilesStackId,tier,row,column,rowsAndColumns,rowsAndColumns,scale,splitStackBounds));
      column++;
    }
    row++;
  }
  return splitStacks;
}",0.9957627118644068
25520,"@JsonIgnore public boolean requiresAlignment(){
  return (alignmentQuality == null);
}","@JsonIgnore public boolean requiresAlignment(){
  return hasMatchPairs() && (alignmentQuality == null);
}",0.900523560209424
25521,"/** 
 * Constructs a canvas composed of   {@link TransformableCanvas transformed sources}that is dynamically rendered when   {@link #getChannels} is called.
 * @param canvasName              name of this canvas.
 * @param channelNames            names of channels to include in this canvas.
 * @param canvasList              list of transformed components to render.
 * @param x                       left coordinate for this canvas.
 * @param y                       top coordinate for this canvas.
 * @param fullScaleWidth          canvas width at mipmap level 0.
 * @param fullScaleHeight         canvas height at mipmap level 0.
 * @param meshCellSize            desired size of a mesh cell (triangle) in pixels.
 * @param levelZeroScale          scale factor for transformed components at mipmap level 0 of this canvas.
 * @param numberOfMappingThreads  number of threads to use for pixel mapping.
 * @param skipInterpolation       enable sloppy but fast rendering by skipping interpolation.
 * @param binaryMask              render only 100% opaque pixels.
 */
public RenderedCanvasMipmapSource(final String canvasName,final Set<String> channelNames,final List<TransformableCanvas> canvasList,final double x,final double y,final int fullScaleWidth,final int fullScaleHeight,final double meshCellSize,final double levelZeroScale,final int numberOfMappingThreads,final boolean skipInterpolation,final boolean binaryMask){
  this.canvasName=canvasName;
  this.channelNames=channelNames;
  this.canvasList=canvasList;
  this.x=x;
  this.y=y;
  this.fullScaleWidth=fullScaleWidth;
  this.fullScaleHeight=fullScaleHeight;
  this.meshCellSize=meshCellSize;
  this.levelZeroScale=levelZeroScale;
  this.numberOfMappingThreads=numberOfMappingThreads;
  this.skipInterpolation=skipInterpolation;
  this.binaryMask=binaryMask;
}","/** 
 * Constructs a canvas composed of   {@link TransformableCanvas transformed sources}that is dynamically rendered when   {@link #getChannels} is called.
 * @param canvasName              name of this canvas.
 * @param channelNames            names of channels to include in this canvas.
 * @param canvasList              list of transformed components to render.
 * @param x                       left coordinate for this canvas.
 * @param y                       top coordinate for this canvas.
 * @param fullScaleWidth          canvas width at mipmap level 0.
 * @param fullScaleHeight         canvas height at mipmap level 0.
 * @param meshCellSize            desired size of a mesh cell (triangle) in pixels.
 * @param levelZeroScale          scale factor for transformed components at mipmap level 0 of this canvas.
 * @param numberOfMappingThreads  number of threads to use for pixel mapping.
 * @param skipInterpolation       enable sloppy but fast rendering by skipping interpolation.
 * @param hasMasks                true if this canvas contains at least one source with a mask.
 * @param binaryMask              render only 100% opaque pixels.
 */
public RenderedCanvasMipmapSource(final String canvasName,final Set<String> channelNames,final List<TransformableCanvas> canvasList,final double x,final double y,final int fullScaleWidth,final int fullScaleHeight,final double meshCellSize,final double levelZeroScale,final int numberOfMappingThreads,final boolean skipInterpolation,final boolean hasMasks,final boolean binaryMask){
  this.canvasName=canvasName;
  this.channelNames=channelNames;
  this.canvasList=canvasList;
  this.x=x;
  this.y=y;
  this.fullScaleWidth=fullScaleWidth;
  this.fullScaleHeight=fullScaleHeight;
  this.meshCellSize=meshCellSize;
  this.levelZeroScale=levelZeroScale;
  this.numberOfMappingThreads=numberOfMappingThreads;
  this.skipInterpolation=skipInterpolation;
  this.hasMasks=hasMasks;
  this.binaryMask=binaryMask;
}",0.961751516750198
25522,"@Override public ChannelMap getChannels(final int mipmapLevel) throws IllegalArgumentException {
  final ChannelMap targetChannels=new ChannelMap();
  final double levelScale=(1.0 / Math.pow(2.0,mipmapLevel)) * levelZeroScale;
  final int levelWidth=(int)((fullScaleWidth * levelScale) + 0.5);
  final int levelHeight=(int)((fullScaleHeight * levelScale) + 0.5);
  for (  final String channelName : channelNames) {
    targetChannels.put(channelName,new ImageProcessorWithMasks(new FloatProcessor(levelWidth,levelHeight),null,null));
  }
  long totalScaleDerivationTime=0;
  for (  final TransformableCanvas canvas : canvasList) {
    final long scaleDerivationStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> renderTransformList=addRenderScaleAndOffset(canvas.getTransformList(),levelZeroScale,levelScale,x,y);
    final MipmapSource source=canvas.getSource();
    final double averageScale=Utils.sampleAverageScale(renderTransformList,source.getFullScaleWidth(),source.getFullScaleHeight(),meshCellSize);
    final int componentMipmapLevel=Utils.bestMipmapLevel(averageScale);
    totalScaleDerivationTime+=(System.currentTimeMillis() - scaleDerivationStart);
    mapPixels(source,componentMipmapLevel,renderTransformList,meshCellSize,binaryMask,numberOfMappingThreads,skipInterpolation,targetChannels);
  }
  LOG.debug(""String_Node_Str"",canvasList.size(),totalScaleDerivationTime);
  return targetChannels;
}","@Override public ChannelMap getChannels(final int mipmapLevel) throws IllegalArgumentException {
  final ChannelMap targetChannels=new ChannelMap();
  final double levelScale=(1.0 / Math.pow(2.0,mipmapLevel)) * levelZeroScale;
  final int levelWidth=(int)((fullScaleWidth * levelScale) + 0.5);
  final int levelHeight=(int)((fullScaleHeight * levelScale) + 0.5);
  for (  final String channelName : channelNames) {
    targetChannels.put(channelName,new ImageProcessorWithMasks(new FloatProcessor(levelWidth,levelHeight),null,null));
  }
  long totalScaleDerivationTime=0;
  for (  final TransformableCanvas canvas : canvasList) {
    final long scaleDerivationStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> renderTransformList=addRenderScaleAndOffset(canvas.getTransformList(),levelZeroScale,levelScale,x,y);
    final MipmapSource source=canvas.getSource();
    final double averageScale=Utils.sampleAverageScale(renderTransformList,source.getFullScaleWidth(),source.getFullScaleHeight(),meshCellSize);
    final int componentMipmapLevel=Utils.bestMipmapLevel(averageScale);
    totalScaleDerivationTime+=(System.currentTimeMillis() - scaleDerivationStart);
    mapPixels(source,componentMipmapLevel,renderTransformList,meshCellSize,hasMasks,binaryMask,numberOfMappingThreads,skipInterpolation,targetChannels);
  }
  LOG.debug(""String_Node_Str"",canvasList.size(),totalScaleDerivationTime);
  return targetChannels;
}",0.9969082789419444
25523,"/** 
 * Maps pixels from a source to a target.
 * @param source                  source pixel data.
 * @param mipmapLevel             source mipmap level.
 * @param renderTransformList     list of transforms for the render context.
 * @param meshCellSize            desired size of a mesh cell (triangle) in pixels.
 * @param binaryMask              render only 100% opaque pixels.
 * @param numberOfMappingThreads  number of threads to use for pixel mapping.
 * @param skipInterpolation       enable sloppy but fast rendering by skipping interpolation.
 * @param targetChannels          target channels for mapped results.
 */
public static void mapPixels(final MipmapSource source,final int mipmapLevel,final CoordinateTransformList<CoordinateTransform> renderTransformList,final double meshCellSize,final boolean binaryMask,final int numberOfMappingThreads,final boolean skipInterpolation,final ChannelMap targetChannels){
  final ChannelMap sourceChannels=source.getChannels(mipmapLevel);
  if (sourceChannels.size() > 0) {
    final long mapStart=System.currentTimeMillis();
    final ImageProcessorWithMasks firstChannel=sourceChannels.getFirstChannel();
    final boolean hasMask=(firstChannel.mask != null);
    final int mipmapWidth=firstChannel.ip.getWidth();
    final int mipmapHeight=firstChannel.ip.getHeight();
    if (hasMask) {
      for (      final ImageProcessorWithMasks targetChannel : targetChannels.values()) {
        if (targetChannel.mask == null) {
          targetChannel.mask=new ByteProcessor(targetChannel.ip.getWidth(),targetChannel.ip.getHeight());
        }
      }
    }
    final PixelMapper tilePixelMapper=getPixelMapper(sourceChannels,hasMask,binaryMask,skipInterpolation,targetChannels);
    if (tilePixelMapper != null) {
      final RenderTransformMesh mesh=createRenderMesh(mipmapLevel,renderTransformList,source.getFullScaleWidth(),meshCellSize,mipmapWidth,mipmapHeight);
      final long meshCreationStop=System.currentTimeMillis();
      final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
      final String mapType=skipInterpolation ? ""String_Node_Str"" : ""String_Node_Str"";
      mapping.map(tilePixelMapper,numberOfMappingThreads);
      for (      final String channelName : targetChannels.names()) {
        final ImageProcessorWithMasks sourceChannel=sourceChannels.get(channelName);
        final ImageProcessorWithMasks targetChannel=targetChannels.get(channelName);
        targetChannel.ip.setMinAndMax(sourceChannel.ip.getMin(),sourceChannel.ip.getMax());
      }
      final long mapStop=System.currentTimeMillis();
      LOG.debug(""String_Node_Str"",source.getSourceName(),mapStop - mapStart,meshCreationStop - mapStart,mapType,mapStop - meshCreationStop);
    }
  }
 else {
    LOG.warn(""String_Node_Str"",source.getSourceName());
  }
}","/** 
 * Maps pixels from a source to a target.
 * @param source                  source pixel data.
 * @param mipmapLevel             source mipmap level.
 * @param renderTransformList     list of transforms for the render context.
 * @param meshCellSize            desired size of a mesh cell (triangle) in pixels.
 * @param canvasHasMasks          true if at least one source in the larger canvas being rendered has a mask(even if this source does not have a mask).
 * @param binaryMask              render only 100% opaque pixels.
 * @param numberOfMappingThreads  number of threads to use for pixel mapping.
 * @param skipInterpolation       enable sloppy but fast rendering by skipping interpolation.
 * @param targetChannels          target channels for mapped results.
 */
public static void mapPixels(final MipmapSource source,final int mipmapLevel,final CoordinateTransformList<CoordinateTransform> renderTransformList,final double meshCellSize,final boolean canvasHasMasks,final boolean binaryMask,final int numberOfMappingThreads,final boolean skipInterpolation,final ChannelMap targetChannels){
  final ChannelMap sourceChannels=source.getChannels(mipmapLevel);
  if (sourceChannels.size() > 0) {
    final long mapStart=System.currentTimeMillis();
    final ImageProcessorWithMasks firstChannel=sourceChannels.getFirstChannel();
    final int mipmapWidth=firstChannel.ip.getWidth();
    final int mipmapHeight=firstChannel.ip.getHeight();
    if (canvasHasMasks) {
      for (      final ImageProcessorWithMasks targetChannel : targetChannels.values()) {
        if (targetChannel.mask == null) {
          targetChannel.mask=new ByteProcessor(targetChannel.ip.getWidth(),targetChannel.ip.getHeight());
        }
      }
      for (      final ImageProcessorWithMasks sourceChannel : sourceChannels.values()) {
        if (sourceChannel.mask == null) {
          sourceChannel.mask=new ByteProcessor(sourceChannel.ip.getWidth(),sourceChannel.ip.getHeight());
          sourceChannel.mask.invert();
        }
      }
    }
    final PixelMapper tilePixelMapper=getPixelMapper(sourceChannels,canvasHasMasks,binaryMask,skipInterpolation,targetChannels);
    if (tilePixelMapper != null) {
      final RenderTransformMesh mesh=createRenderMesh(mipmapLevel,renderTransformList,source.getFullScaleWidth(),meshCellSize,mipmapWidth,mipmapHeight);
      final long meshCreationStop=System.currentTimeMillis();
      final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
      final String mapType=skipInterpolation ? ""String_Node_Str"" : ""String_Node_Str"";
      mapping.map(tilePixelMapper,numberOfMappingThreads);
      for (      final String channelName : targetChannels.names()) {
        final ImageProcessorWithMasks sourceChannel=sourceChannels.get(channelName);
        final ImageProcessorWithMasks targetChannel=targetChannels.get(channelName);
        targetChannel.ip.setMinAndMax(sourceChannel.ip.getMin(),sourceChannel.ip.getMax());
      }
      final long mapStop=System.currentTimeMillis();
      LOG.debug(""String_Node_Str"",source.getSourceName(),mapStop - mapStart,meshCreationStop - mapStart,mapType,mapStop - meshCreationStop);
    }
  }
 else {
    LOG.warn(""String_Node_Str"",source.getSourceName());
  }
}",0.8359771054783319
25524,"@Override public ChannelMap getChannels(final int mipmapLevel) throws IllegalArgumentException {
  final ChannelMap channels=new ChannelMap();
  if ((channelSpecList != null) && (channelSpecList.size() > 0)) {
    final long loadMipStart=System.currentTimeMillis();
    final ChannelSpec firstChannelSpec=channelSpecList.get(0);
    int downSampleLevels=0;
    final Map.Entry<Integer,ImageAndMask> mipmapEntry=firstChannelSpec.getFloorMipmapEntry(mipmapLevel);
    final ImageAndMask imageAndMask=mipmapEntry.getValue();
    final int currentMipmapLevel=mipmapEntry.getKey();
    if (currentMipmapLevel < mipmapLevel) {
      downSampleLevels=mipmapLevel - currentMipmapLevel;
    }
    final ImageProcessor imageProcessor=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,firstChannelSpec.is16Bit());
    final long loadMipStop=System.currentTimeMillis();
    if (imageProcessor.getWidth() == 0 || imageProcessor.getHeight() == 0) {
      LOG.debug(""String_Node_Str"" + getSourceName() + ""String_Node_Str""+ imageAndMask.getImageUrl()+ ""String_Node_Str""+ downSampleLevels+ ""String_Node_Str"");
    }
 else {
      final ImageProcessor maskProcessor;
      final String maskUrl=imageAndMask.getMaskUrl();
      if ((maskUrl != null) && (!excludeMask)) {
        maskProcessor=imageProcessorCache.get(maskUrl,downSampleLevels,true,false);
      }
 else {
        maskProcessor=null;
      }
      final long loadMaskStop=System.currentTimeMillis();
      setMinAndMaxIntensity(imageProcessor,firstChannelSpec);
      final ImageProcessorWithMasks firstChannel=new ImageProcessorWithMasks(imageProcessor,maskProcessor,null);
      if ((maskProcessor != null) && (firstChannel.mask == null)) {
        LOG.warn(""String_Node_Str"",sourceName,imageAndMask.getImageUrl(),imageProcessor.getWidth(),imageProcessor.getHeight(),imageAndMask.getMaskUrl(),maskProcessor.getWidth(),maskProcessor.getHeight());
      }
      channels.put(firstChannelSpec.getName(),firstChannel);
      if (channelSpecList.size() > 1) {
        final boolean firstChannelHasMask=(firstChannel.mask != null);
        loadAdditionalChannels(imageProcessor.getWidth(),imageProcessor.getHeight(),firstChannelHasMask,mipmapLevel,channels);
      }
      final long loadAdditionalChannelsStop=System.currentTimeMillis();
      LOG.debug(""String_Node_Str"",sourceName,loadAdditionalChannelsStop - loadMipStart,mipmapLevel,loadMipStop - loadMipStart,downSampleLevels,loadMaskStop - loadMipStop,loadAdditionalChannelsStop - loadMaskStop,imageProcessorCache.size());
    }
  }
  return channels;
}","@Override public ChannelMap getChannels(final int mipmapLevel) throws IllegalArgumentException {
  final ChannelMap channels=new ChannelMap();
  if ((channelSpecList != null) && (channelSpecList.size() > 0)) {
    final long loadMipStart=System.currentTimeMillis();
    final ChannelSpec firstChannelSpec=channelSpecList.get(0);
    int downSampleLevels=0;
    final Map.Entry<Integer,ImageAndMask> mipmapEntry=firstChannelSpec.getFloorMipmapEntry(mipmapLevel);
    final ImageAndMask imageAndMask=mipmapEntry.getValue();
    final int currentMipmapLevel=mipmapEntry.getKey();
    if (currentMipmapLevel < mipmapLevel) {
      downSampleLevels=mipmapLevel - currentMipmapLevel;
    }
    final ImageProcessor imageProcessor=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,firstChannelSpec.is16Bit());
    final long loadMipStop=System.currentTimeMillis();
    if (imageProcessor.getWidth() == 0 || imageProcessor.getHeight() == 0) {
      LOG.debug(""String_Node_Str"" + getSourceName() + ""String_Node_Str""+ imageAndMask.getImageUrl()+ ""String_Node_Str""+ downSampleLevels+ ""String_Node_Str"");
    }
 else {
      final ImageProcessor maskProcessor;
      final String maskUrl=imageAndMask.getMaskUrl();
      if ((maskUrl != null) && (!excludeMask)) {
        maskProcessor=imageProcessorCache.get(maskUrl,downSampleLevels,true,false);
      }
 else {
        maskProcessor=null;
      }
      final long loadMaskStop=System.currentTimeMillis();
      setMinAndMaxIntensity(imageProcessor,firstChannelSpec);
      final ImageProcessorWithMasks firstChannel=new ImageProcessorWithMasks(imageProcessor,maskProcessor,null);
      if ((maskProcessor != null) && (firstChannel.mask == null)) {
        LOG.warn(""String_Node_Str"",sourceName,imageAndMask.getImageUrl(),imageProcessor.getWidth(),imageProcessor.getHeight(),imageAndMask.getMaskUrl(),maskProcessor.getWidth(),maskProcessor.getHeight());
      }
      channels.put(firstChannelSpec.getName(),firstChannel);
      if (channelSpecList.size() > 1) {
        loadAdditionalChannels(imageProcessor.getWidth(),imageProcessor.getHeight(),mipmapLevel,channels);
      }
      final long loadAdditionalChannelsStop=System.currentTimeMillis();
      LOG.debug(""String_Node_Str"",sourceName,loadAdditionalChannelsStop - loadMipStart,mipmapLevel,loadMipStop - loadMipStart,downSampleLevels,loadMaskStop - loadMipStop,loadAdditionalChannelsStop - loadMaskStop,imageProcessorCache.size());
    }
  }
  return channels;
}",0.9555423829282752
25525,"/** 
 * Loads remaining channel data for multi-channel images.
 * @param firstChannelWidth    first channel width (at requested mipmap level).
 * @param firstChannelHeight   first channel height (at requested mipmap level).
 * @param firstChannelHasMask  indicates whether the first channel has a mask.
 * @param mipmapLevel          requested mipmap level for all channels.
 * @param channels             map of pixel data for all source channels.
 */
private void loadAdditionalChannels(final int firstChannelWidth,final int firstChannelHeight,final boolean firstChannelHasMask,final int mipmapLevel,final ChannelMap channels){
  for (int i=1; i < channelSpecList.size(); i++) {
    final ChannelSpec channelSpec=channelSpecList.get(i);
    final Map.Entry<Integer,ImageAndMask> mipmapEntry=channelSpec.getFloorMipmapEntry(mipmapLevel);
    final ImageAndMask imageAndMask=mipmapEntry.getValue();
    int downSampleLevels=0;
    final int currentMipmapLevel=mipmapEntry.getKey();
    if (currentMipmapLevel < mipmapLevel) {
      downSampleLevels=mipmapLevel - currentMipmapLevel;
    }
    final ImageProcessor imageProcessor=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,channelSpec.is16Bit());
    if (imageProcessor.getWidth() == firstChannelWidth && imageProcessor.getWidth() == firstChannelHeight) {
      final ImageProcessor maskProcessor;
      final String maskUrl=imageAndMask.getMaskUrl();
      if ((maskUrl != null) && (!excludeMask)) {
        maskProcessor=imageProcessorCache.get(maskUrl,downSampleLevels,true,false);
      }
 else {
        maskProcessor=null;
      }
      setMinAndMaxIntensity(imageProcessor,channelSpec);
      final ImageProcessorWithMasks channel=new ImageProcessorWithMasks(imageProcessor,maskProcessor,null);
      channels.put(channelSpec.getName(),channel);
    }
 else {
      LOG.warn(""String_Node_Str"",getSourceName(),channelSpec.getName(),imageAndMask.getImageUrl(),mipmapLevel,imageProcessor.getWidth(),imageProcessor.getHeight(),firstChannelWidth,firstChannelHeight);
    }
  }
  boolean removeAllMasks=false;
  for (  final ImageProcessorWithMasks channel : channels.values()) {
    if (firstChannelHasMask) {
      if (channel.mask == null) {
        removeAllMasks=true;
        break;
      }
    }
 else     if (channel.mask != null) {
      removeAllMasks=true;
      break;
    }
  }
  if (removeAllMasks) {
    LOG.warn(""String_Node_Str"",getSourceName());
    for (    final ImageProcessorWithMasks channel : channels.values()) {
      channel.mask=null;
    }
  }
}","/** 
 * Loads remaining channel data for multi-channel images.
 * @param firstChannelWidth    first channel width (at requested mipmap level).
 * @param firstChannelHeight   first channel height (at requested mipmap level).
 * @param mipmapLevel          requested mipmap level for all channels.
 * @param channels             map of pixel data for all source channels.
 */
private void loadAdditionalChannels(final int firstChannelWidth,final int firstChannelHeight,final int mipmapLevel,final ChannelMap channels){
  for (int i=1; i < channelSpecList.size(); i++) {
    final ChannelSpec channelSpec=channelSpecList.get(i);
    final Map.Entry<Integer,ImageAndMask> mipmapEntry=channelSpec.getFloorMipmapEntry(mipmapLevel);
    final ImageAndMask imageAndMask=mipmapEntry.getValue();
    int downSampleLevels=0;
    final int currentMipmapLevel=mipmapEntry.getKey();
    if (currentMipmapLevel < mipmapLevel) {
      downSampleLevels=mipmapLevel - currentMipmapLevel;
    }
    final ImageProcessor imageProcessor=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,channelSpec.is16Bit());
    if (imageProcessor.getWidth() == firstChannelWidth && imageProcessor.getWidth() == firstChannelHeight) {
      final ImageProcessor maskProcessor;
      final String maskUrl=imageAndMask.getMaskUrl();
      if ((maskUrl != null) && (!excludeMask)) {
        maskProcessor=imageProcessorCache.get(maskUrl,downSampleLevels,true,false);
      }
 else {
        maskProcessor=null;
      }
      setMinAndMaxIntensity(imageProcessor,channelSpec);
      final ImageProcessorWithMasks channel=new ImageProcessorWithMasks(imageProcessor,maskProcessor,null);
      channels.put(channelSpec.getName(),channel);
    }
 else {
      LOG.warn(""String_Node_Str"",getSourceName(),channelSpec.getName(),imageAndMask.getImageUrl(),mipmapLevel,imageProcessor.getWidth(),imageProcessor.getHeight(),firstChannelWidth,firstChannelHeight);
    }
  }
}",0.8649489115948468
25526,"@Test public void testRender() throws Exception {
  final ImageAndMask imageWithoutMask=new ImageAndMask(""String_Node_Str"",null);
  final ImageProcessorCache imageProcessorCache=new ImageProcessorCache();
  final ImageProcessor rawIp=imageProcessorCache.get(imageWithoutMask.getImageUrl(),0,false,false);
  final BufferedImage rawImage=rawIp.getBufferedImage();
  final ChannelSpec channelSpec=new ChannelSpec();
  channelSpec.putMipmap(0,imageWithoutMask);
  final TileSpec tileSpec=new TileSpec();
  tileSpec.addChannel(channelSpec);
  final RenderParameters tileRenderParameters=new RenderParameters(null,0,0,rawIp.getWidth(),rawIp.getHeight(),1.0);
  tileRenderParameters.addTileSpec(tileSpec);
  tileRenderParameters.setSkipInterpolation(true);
  final BufferedImage renderedImage=tileRenderParameters.openTargetImage();
  ArgbRenderer.render(tileRenderParameters,renderedImage,imageProcessorCache);
  Assert.assertEquals(""String_Node_Str"",rawImage.getWidth(),renderedImage.getWidth());
  Assert.assertEquals(""String_Node_Str"",rawImage.getWidth(),renderedImage.getHeight());
  for (int x=0; x < rawImage.getWidth(); x++) {
    for (int y=0; y < rawImage.getHeight(); y++) {
      Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",rawImage.getRGB(x,y),renderedImage.getRGB(x,y));
    }
  }
}","@Test public void testRender() throws Exception {
  final ImageAndMask imageWithoutMask=new ImageAndMask(""String_Node_Str"",null);
  final ImageProcessorCache imageProcessorCache=new ImageProcessorCache();
  final ImageProcessor rawIp=imageProcessorCache.get(imageWithoutMask.getImageUrl(),0,false,false);
  final BufferedImage rawImage=rawIp.getBufferedImage();
  final ChannelSpec channelSpec=new ChannelSpec();
  channelSpec.putMipmap(0,imageWithoutMask);
  final TileSpec tileSpec=new TileSpec();
  tileSpec.addChannel(channelSpec);
  final RenderParameters tileRenderParameters=new RenderParameters(null,0,0,rawIp.getWidth(),rawIp.getHeight(),1.0);
  tileRenderParameters.addTileSpec(tileSpec);
  tileRenderParameters.setSkipInterpolation(true);
  final BufferedImage renderedImage=tileRenderParameters.openTargetImage();
  ArgbRenderer.render(tileRenderParameters,renderedImage,imageProcessorCache);
  Assert.assertEquals(""String_Node_Str"",rawImage.getWidth(),renderedImage.getWidth());
  Assert.assertEquals(""String_Node_Str"",rawImage.getHeight(),renderedImage.getHeight());
  for (int x=0; x < rawImage.getWidth(); x++) {
    for (int y=0; y < rawImage.getHeight(); y++) {
      Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",rawImage.getRGB(x,y),renderedImage.getRGB(x,y));
    }
  }
}",0.9958631064309892
25527,"public static void render(final List<TileSpec> tileSpecs,final BufferedImage targetImage,final double x,final double y,final double meshCellSize,final double scale,final boolean areaOffset,final int numberOfThreads,final boolean skipInterpolation,final boolean doFilter,final boolean binaryMask,final boolean excludeMask,final ImageProcessorCache imageProcessorCache,final Integer backgroundRGBColor,final Double renderMinIntensity,final Double renderMaxIntensity) throws IllegalArgumentException {
  final int targetWidth=targetImage.getWidth();
  final int targetHeight=targetImage.getHeight();
  final double[] min=new double[2];
  final double[] max=new double[2];
  final Graphics2D targetGraphics=targetImage.createGraphics();
  if (backgroundRGBColor != null) {
    targetGraphics.setBackground(new Color(backgroundRGBColor));
    targetGraphics.clearRect(0,0,targetWidth,targetHeight);
  }
  LOG.debug(""String_Node_Str"",tileSpecs.size(),numberOfThreads);
  final long tileLoopStart=System.currentTimeMillis();
  int tileSpecIndex=0;
  long tileSpecStart;
  long loadMipStop;
  long filterStop;
  long loadMaskStop;
  long ctListCreationStop;
  long meshCreationStop;
  long sourceCreationStop;
  long targetCreationStop;
  long mapInterpolatedStop;
  long drawImageStop;
  for (  final TileSpec ts : tileSpecs) {
    tileSpecStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctl=createRenderTransform(ts,areaOffset,scale,x,y);
    Map.Entry<Integer,ImageAndMask> mipmapEntry;
    ImageAndMask imageAndMask=null;
    ImageProcessor widthAndHeightProcessor=null;
    int width=ts.getWidth();
    int height=ts.getHeight();
    boolean convertTo16Bit=(ts.getMaxIntensity() > 255);
    if ((width < 0) || (height < 0)) {
      mipmapEntry=ts.getFirstMipmapEntry();
      imageAndMask=mipmapEntry.getValue();
      widthAndHeightProcessor=imageProcessorCache.get(imageAndMask.getImageUrl(),0,false,convertTo16Bit);
      width=widthAndHeightProcessor.getWidth();
      height=widthAndHeightProcessor.getHeight();
    }
    final double s=Utils.sampleAverageScale(ctl,width,height,meshCellSize);
    int mipmapLevel=Utils.bestMipmapLevel(s);
    int downSampleLevels=0;
    final ImageProcessor ipMipmap;
    if (widthAndHeightProcessor == null) {
      mipmapEntry=ts.getFloorMipmapEntry(mipmapLevel);
      imageAndMask=mipmapEntry.getValue();
      final int currentMipmapLevel=mipmapEntry.getKey();
      if (currentMipmapLevel < mipmapLevel) {
        downSampleLevels=mipmapLevel - currentMipmapLevel;
      }
 else {
        mipmapLevel=currentMipmapLevel;
      }
      ipMipmap=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,convertTo16Bit);
    }
 else     if (mipmapLevel > 0) {
      downSampleLevels=mipmapLevel;
      ipMipmap=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,convertTo16Bit);
    }
 else {
      ipMipmap=widthAndHeightProcessor;
    }
    loadMipStop=System.currentTimeMillis();
    if (ipMipmap.getWidth() == 0 || ipMipmap.getHeight() == 0) {
      LOG.debug(""String_Node_Str"",imageAndMask.getImageUrl());
      continue;
    }
    if (doFilter) {
      final double mipmapScale=1.0 / (1 << mipmapLevel);
      vtnf1.process(ipMipmap,mipmapScale);
      vtnf2.process(ipMipmap,mipmapScale);
      nlcf.process(ipMipmap,mipmapScale);
    }
    filterStop=System.currentTimeMillis();
    ImageProcessor maskSourceProcessor;
    final String maskUrl=imageAndMask.getMaskUrl();
    if ((maskUrl != null) && (!excludeMask)) {
      maskSourceProcessor=imageProcessorCache.get(maskUrl,downSampleLevels,true,false);
    }
 else {
      maskSourceProcessor=null;
    }
    loadMaskStop=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctlMipmap=new CoordinateTransformList<>();
    ctlMipmap.add(Utils.createScaleLevelTransform(mipmapLevel));
    ctlMipmap.add(ctl);
    ctListCreationStop=System.currentTimeMillis();
    final RenderTransformMesh mesh=new RenderTransformMesh(ctlMipmap,(int)(width / meshCellSize + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    mesh.bounds(min,max);
    final int tx=(int)Math.max(0,Math.min(targetWidth,min[0]));
    final int ty=(int)Math.max(0,Math.min(targetHeight,min[1]));
    final int w=(int)(Math.min(targetWidth,max[0]) - tx) + 1;
    final int h=(int)(Math.min(targetHeight,max[1]) - ty) + 1;
    if (w <= 0 || h <= 0) {
      LOG.debug(""String_Node_Str"",ts);
      continue;
    }
    mesh.translateTarget(-tx,-ty);
    mesh.updateAffines();
    meshCreationStop=System.currentTimeMillis();
    final ImageProcessorWithMasks source=new ImageProcessorWithMasks(ipMipmap,maskSourceProcessor,null);
    if ((maskSourceProcessor != null) && (source.mask == null)) {
      LOG.warn(""String_Node_Str"" + ipMipmap.getWidth() + ""String_Node_Str""+ ipMipmap.getHeight()+ ""String_Node_Str""+ maskSourceProcessor.getWidth()+ ""String_Node_Str""+ maskSourceProcessor.getHeight());
      maskSourceProcessor=null;
    }
    sourceCreationStop=System.currentTimeMillis();
    final ImageProcessor tp=ipMipmap.createProcessor(w,h);
    final ImageProcessor maskTargetProcessor;
    if (maskSourceProcessor != null)     maskTargetProcessor=new ByteProcessor(w,h);
 else     maskTargetProcessor=null;
    final ImageProcessorWithMasks target=new ImageProcessorWithMasks(tp,maskTargetProcessor,null);
    targetCreationStop=System.currentTimeMillis();
    final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
    final String mapType;
    if (skipInterpolation) {
      mapType=""String_Node_Str"";
      mapping.map(source,target,numberOfThreads);
    }
 else {
      mapType=""String_Node_Str"";
      mapping.mapInterpolated(source,target,numberOfThreads);
    }
    mapInterpolatedStop=System.currentTimeMillis();
    final BufferedImage image=targetToARGBImage(target,ts,binaryMask,renderMinIntensity,renderMaxIntensity);
    targetGraphics.drawImage(image,tx,ty,null);
    drawImageStop=System.currentTimeMillis();
    LOG.debug(""String_Node_Str"",tileSpecIndex,drawImageStop - tileSpecStart,loadMipStop - tileSpecStart,downSampleLevels,filterStop - loadMipStop,loadMaskStop - filterStop,ctListCreationStop - loadMaskStop,meshCreationStop - ctListCreationStop,sourceCreationStop - meshCreationStop,targetCreationStop - sourceCreationStop,mapType,mapInterpolatedStop - targetCreationStop,drawImageStop - mapInterpolatedStop,imageProcessorCache.size());
    tileSpecIndex++;
  }
  targetGraphics.dispose();
  LOG.debug(""String_Node_Str"",tileSpecs.size(),System.currentTimeMillis() - tileLoopStart);
}","public static void render(final List<TileSpec> tileSpecs,final BufferedImage targetImage,final double x,final double y,final double meshCellSize,final double scale,final boolean areaOffset,final int numberOfThreads,final boolean skipInterpolation,final boolean doFilter,final boolean binaryMask,final boolean excludeMask,final ImageProcessorCache imageProcessorCache,final Integer backgroundRGBColor,final Double renderMinIntensity,final Double renderMaxIntensity) throws IllegalArgumentException {
  final int targetWidth=targetImage.getWidth();
  final int targetHeight=targetImage.getHeight();
  final double[] min=new double[2];
  final double[] max=new double[2];
  final Graphics2D targetGraphics=targetImage.createGraphics();
  if (backgroundRGBColor != null) {
    targetGraphics.setBackground(new Color(backgroundRGBColor));
    targetGraphics.clearRect(0,0,targetWidth,targetHeight);
  }
  LOG.debug(""String_Node_Str"",tileSpecs.size(),numberOfThreads);
  final long tileLoopStart=System.currentTimeMillis();
  int tileSpecIndex=0;
  long tileSpecStart;
  long loadMipStop;
  long filterStop;
  long loadMaskStop;
  long ctListCreationStop;
  long meshCreationStop;
  long sourceCreationStop;
  long targetCreationStop;
  long mapInterpolatedStop;
  long drawImageStop;
  for (  final TileSpec ts : tileSpecs) {
    tileSpecStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctl=createRenderTransform(ts,areaOffset,scale,x,y);
    Map.Entry<Integer,ImageAndMask> mipmapEntry;
    ImageAndMask imageAndMask=null;
    ImageProcessor widthAndHeightProcessor=null;
    int width=ts.getWidth();
    int height=ts.getHeight();
    final boolean convertTo16Bit=(ts.getMaxIntensity() > 255);
    if ((width < 0) || (height < 0)) {
      mipmapEntry=ts.getFirstMipmapEntry();
      imageAndMask=mipmapEntry.getValue();
      widthAndHeightProcessor=imageProcessorCache.get(imageAndMask.getImageUrl(),0,false,convertTo16Bit);
      width=widthAndHeightProcessor.getWidth();
      height=widthAndHeightProcessor.getHeight();
    }
    final double s=Utils.sampleAverageScale(ctl,width,height,meshCellSize);
    int mipmapLevel=Utils.bestMipmapLevel(s);
    int downSampleLevels=0;
    final ImageProcessor ipMipmap;
    if (widthAndHeightProcessor == null) {
      mipmapEntry=ts.getFloorMipmapEntry(mipmapLevel);
      imageAndMask=mipmapEntry.getValue();
      final int currentMipmapLevel=mipmapEntry.getKey();
      if (currentMipmapLevel < mipmapLevel) {
        downSampleLevels=mipmapLevel - currentMipmapLevel;
      }
 else {
        mipmapLevel=currentMipmapLevel;
      }
      ipMipmap=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,convertTo16Bit);
    }
 else     if (mipmapLevel > 0) {
      downSampleLevels=mipmapLevel;
      ipMipmap=imageProcessorCache.get(imageAndMask.getImageUrl(),downSampleLevels,false,convertTo16Bit);
    }
 else {
      ipMipmap=widthAndHeightProcessor;
    }
    loadMipStop=System.currentTimeMillis();
    if (ipMipmap.getWidth() == 0 || ipMipmap.getHeight() == 0) {
      LOG.debug(""String_Node_Str"",imageAndMask.getImageUrl());
      continue;
    }
    if (doFilter) {
      final double mipmapScale=1.0 / (1 << mipmapLevel);
      vtnf1.process(ipMipmap,mipmapScale);
      vtnf2.process(ipMipmap,mipmapScale);
      nlcf.process(ipMipmap,mipmapScale);
    }
    filterStop=System.currentTimeMillis();
    ImageProcessor maskSourceProcessor;
    final String maskUrl=imageAndMask.getMaskUrl();
    if ((maskUrl != null) && (!excludeMask)) {
      maskSourceProcessor=imageProcessorCache.get(maskUrl,downSampleLevels,true,false);
    }
 else {
      maskSourceProcessor=null;
    }
    loadMaskStop=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctlMipmap=new CoordinateTransformList<>();
    ctlMipmap.add(Utils.createScaleLevelTransform(mipmapLevel));
    ctlMipmap.add(ctl);
    ctListCreationStop=System.currentTimeMillis();
    final RenderTransformMesh mesh=new RenderTransformMesh(ctlMipmap,(int)(width / meshCellSize + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    mesh.bounds(min,max);
    final int tx=(int)Math.max(0,Math.min(targetWidth,min[0]));
    final int ty=(int)Math.max(0,Math.min(targetHeight,min[1]));
    final int w=(int)(Math.min(targetWidth,max[0]) - tx) + 1;
    final int h=(int)(Math.min(targetHeight,max[1]) - ty) + 1;
    if (w <= 0 || h <= 0) {
      LOG.debug(""String_Node_Str"",ts);
      continue;
    }
    mesh.translateTarget(-tx,-ty);
    mesh.updateAffines();
    meshCreationStop=System.currentTimeMillis();
    final ImageProcessorWithMasks source=new ImageProcessorWithMasks(ipMipmap,maskSourceProcessor,null);
    if ((maskSourceProcessor != null) && (source.mask == null)) {
      LOG.warn(""String_Node_Str"" + ipMipmap.getWidth() + ""String_Node_Str""+ ipMipmap.getHeight()+ ""String_Node_Str""+ maskSourceProcessor.getWidth()+ ""String_Node_Str""+ maskSourceProcessor.getHeight());
      maskSourceProcessor=null;
    }
    sourceCreationStop=System.currentTimeMillis();
    final ImageProcessor tp=ipMipmap.createProcessor(w,h);
    final ImageProcessor maskTargetProcessor;
    if (maskSourceProcessor != null)     maskTargetProcessor=new ByteProcessor(w,h);
 else     maskTargetProcessor=null;
    final ImageProcessorWithMasks target=new ImageProcessorWithMasks(tp,maskTargetProcessor,null);
    targetCreationStop=System.currentTimeMillis();
    final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
    final String mapType;
    if (skipInterpolation) {
      mapType=""String_Node_Str"";
      mapping.map(source,target,numberOfThreads);
    }
 else {
      mapType=""String_Node_Str"";
      mapping.mapInterpolated(source,target,numberOfThreads);
    }
    mapInterpolatedStop=System.currentTimeMillis();
    final BufferedImage image=targetToARGBImage(target,ts,binaryMask,renderMinIntensity,renderMaxIntensity);
    targetGraphics.drawImage(image,tx,ty,null);
    drawImageStop=System.currentTimeMillis();
    LOG.debug(""String_Node_Str"",tileSpecIndex,drawImageStop - tileSpecStart,loadMipStop - tileSpecStart,downSampleLevels,filterStop - loadMipStop,loadMaskStop - filterStop,ctListCreationStop - loadMaskStop,meshCreationStop - ctListCreationStop,sourceCreationStop - meshCreationStop,targetCreationStop - sourceCreationStop,mapType,mapInterpolatedStop - targetCreationStop,drawImageStop - mapInterpolatedStop,imageProcessorCache.size());
    tileSpecIndex++;
  }
  targetGraphics.dispose();
  LOG.debug(""String_Node_Str"",tileSpecs.size(),System.currentTimeMillis() - tileLoopStart);
}",0.9995473064735174
25528,"public static TileSpec deriveBoundingBox(final TileSpec tileSpec,final double meshCellSize,final boolean force){
  if (!tileSpec.hasWidthAndHeightDefined()) {
    final Map.Entry<Integer,ImageAndMask> mipmapEntry=tileSpec.getFirstMipmapEntry();
    final ImageAndMask imageAndMask=mipmapEntry.getValue();
    final ImageProcessor imageProcessor=ImageProcessorCache.getNonCachedImage(imageAndMask.getImageUrl(),0,false);
    tileSpec.setWidth((double)imageProcessor.getWidth());
    tileSpec.setHeight((double)imageProcessor.getHeight());
  }
  tileSpec.deriveBoundingBox(meshCellSize,force);
  return tileSpec;
}","public static TileSpec deriveBoundingBox(final TileSpec tileSpec,final double meshCellSize,final boolean force){
  if (!tileSpec.hasWidthAndHeightDefined()) {
    final Map.Entry<Integer,ImageAndMask> mipmapEntry=tileSpec.getFirstMipmapEntry();
    final ImageAndMask imageAndMask=mipmapEntry.getValue();
    final ImageProcessor imageProcessor=ImageProcessorCache.getNonCachedImage(imageAndMask.getImageUrl(),0,false,false);
    tileSpec.setWidth((double)imageProcessor.getWidth());
    tileSpec.setHeight((double)imageProcessor.getHeight());
  }
  tileSpec.deriveBoundingBox(meshCellSize,force);
  return tileSpec;
}",0.9951219512195122
25529,"@Override public int weigh(@Nullable CacheKey key,@Nullable ImageProcessor value){
  final int weight;
  if (value == null) {
    weight=0;
  }
 else {
    weight=value.getPixelCount() * value.getBitDepth() / 8;
  }
  return weight;
}","@Override public int weigh(@Nullable final CacheKey key,@Nullable final ImageProcessor value){
  final int weight;
  if (value == null) {
    weight=0;
  }
 else {
    weight=value.getPixelCount() * value.getBitDepth() / 8;
  }
  return weight;
}",0.975
25530,"/** 
 * Constructs a cache instance using the specified parameters.
 * @param maximumNumberOfCachedPixels         the maximum number of pixels to maintain in the cache.This should roughly correlate to the maximum amount of memory for the cache.
 * @param recordStats                         if true, useful tuning stats like cache hits and loads will bemaintained (presumably at some nominal overhead cost); otherwise stats are not maintained.
 * @param cacheOriginalsForDownSampledImages  if true, when down sampled images are requested their sourceimages will also be cached (presumably improving the speed of future down sampling to a different level); otherwise only the down sampled result images are cached.
 */
public ImageProcessorCache(final long maximumNumberOfCachedPixels,final boolean recordStats,final boolean cacheOriginalsForDownSampledImages){
  this.maximumNumberOfCachedPixels=maximumNumberOfCachedPixels;
  this.recordStats=recordStats;
  this.cacheOriginalsForDownSampledImages=cacheOriginalsForDownSampledImages;
  final Weigher<CacheKey,ImageProcessor> weigher=new Weigher<CacheKey,ImageProcessor>(){
    @Override public int weigh(    @Nullable CacheKey key,    @Nullable ImageProcessor value){
      final int weight;
      if (value == null) {
        weight=0;
      }
 else {
        weight=value.getPixelCount() * value.getBitDepth() / 8;
      }
      return weight;
    }
  }
;
  final CacheLoader<CacheKey,ImageProcessor> loader=new CacheLoader<CacheKey,ImageProcessor>(){
    @Override public ImageProcessor load(    @Nullable CacheKey key) throws Exception {
      ImageProcessor imageProcessor=null;
      if (key != null) {
        imageProcessor=loadImageProcessor(key.getUri(),key.getDownSampleLevels(),key.isMask(),key.isConvertTo16Bit());
      }
      return imageProcessor;
    }
  }
;
  if (recordStats) {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).recordStats().build(loader);
  }
 else {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).build(loader);
  }
}","/** 
 * Constructs a cache instance using the specified parameters.
 * @param maximumNumberOfCachedPixels         the maximum number of pixels to maintain in the cache.This should roughly correlate to the maximum amount of memory for the cache.
 * @param recordStats                         if true, useful tuning stats like cache hits and loads will bemaintained (presumably at some nominal overhead cost); otherwise stats are not maintained.
 * @param cacheOriginalsForDownSampledImages  if true, when down sampled images are requested their sourceimages will also be cached (presumably improving the speed of future down sampling to a different level); otherwise only the down sampled result images are cached.
 */
public ImageProcessorCache(final long maximumNumberOfCachedPixels,final boolean recordStats,final boolean cacheOriginalsForDownSampledImages){
  this.maximumNumberOfCachedPixels=maximumNumberOfCachedPixels;
  this.recordStats=recordStats;
  this.cacheOriginalsForDownSampledImages=cacheOriginalsForDownSampledImages;
  final Weigher<CacheKey,ImageProcessor> weigher=new Weigher<CacheKey,ImageProcessor>(){
    @Override public int weigh(    @Nullable final CacheKey key,    @Nullable final ImageProcessor value){
      final int weight;
      if (value == null) {
        weight=0;
      }
 else {
        weight=value.getPixelCount() * value.getBitDepth() / 8;
      }
      return weight;
    }
  }
;
  final CacheLoader<CacheKey,ImageProcessor> loader=new CacheLoader<CacheKey,ImageProcessor>(){
    @Override public ImageProcessor load(    @Nullable final CacheKey key) throws Exception {
      ImageProcessor imageProcessor=null;
      if (key != null) {
        imageProcessor=loadImageProcessor(key.getUri(),key.getDownSampleLevels(),key.isMask(),key.isConvertTo16Bit());
      }
      return imageProcessor;
    }
  }
;
  if (recordStats) {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).recordStats().build(loader);
  }
 else {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).build(loader);
  }
}",0.995736617716722
25531,"protected ImageProcessor loadImageProcessor(final String url,final int downSampleLevels,final boolean isMask,final boolean convertTo16Bit) throws IllegalArgumentException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",url,downSampleLevels,convertTo16Bit);
  }
  ImageProcessor imageProcessor=null;
  if (downSampleLevels > 0) {
    imageProcessor=cache.getIfPresent(new CacheKey(url,0,isMask,convertTo16Bit));
  }
  if (imageProcessor == null) {
    final Opener opener=new Opener();
    opener.setSilentMode(true);
    final ImagePlus imagePlus=opener.openURL(url);
    if (imagePlus == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + url + ""String_Node_Str"");
    }
    imageProcessor=imagePlus.getProcessor();
    if (!isMask && imageProcessor.getBitDepth() == 8 && convertTo16Bit) {
      imageProcessor=imageProcessor.convertToShort(false);
      imageProcessor.multiply(256.0);
    }
    if (cacheOriginalsForDownSampledImages && (downSampleLevels > 0)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",url);
      }
      cache.put(new CacheKey(url,0,isMask,convertTo16Bit),imageProcessor);
    }
  }
  if (downSampleLevels > 0) {
    imageProcessor=Downsampler.downsampleImageProcessor(imageProcessor,downSampleLevels);
  }
  return imageProcessor;
}","/** 
 * The core method used to load image processor instances that is called when cache misses occur.
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.
 * @param isMask            indicates whether this image is a mask.
 * @return a newly loaded image processor to be cached.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
protected ImageProcessor loadImageProcessor(final String url,final int downSampleLevels,final boolean isMask,final boolean convertTo16Bit) throws IllegalArgumentException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",url,downSampleLevels,convertTo16Bit);
  }
  ImageProcessor imageProcessor=null;
  if (downSampleLevels > 0) {
    imageProcessor=cache.getIfPresent(new CacheKey(url,0,isMask,convertTo16Bit));
  }
  if (imageProcessor == null) {
    final Opener opener=new Opener();
    opener.setSilentMode(true);
    final ImagePlus imagePlus=opener.openURL(url);
    if (imagePlus == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + url + ""String_Node_Str"");
    }
    imageProcessor=imagePlus.getProcessor();
    if (!isMask && imageProcessor.getBitDepth() == 8 && convertTo16Bit) {
      imageProcessor=imageProcessor.convertToShort(false);
      imageProcessor.multiply(256.0);
    }
    if (cacheOriginalsForDownSampledImages && (downSampleLevels > 0)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",url);
      }
      cache.put(new CacheKey(url,0,isMask,convertTo16Bit),imageProcessor);
    }
  }
  if (downSampleLevels > 0) {
    imageProcessor=Downsampler.downsampleImageProcessor(imageProcessor,downSampleLevels);
  }
  return imageProcessor;
}",0.8615284128020901
25532,"@Override public ImageProcessor load(@Nullable CacheKey key) throws Exception {
  ImageProcessor imageProcessor=null;
  if (key != null) {
    imageProcessor=loadImageProcessor(key.getUri(),key.getDownSampleLevels(),key.isMask(),key.isConvertTo16Bit());
  }
  return imageProcessor;
}","@Override public ImageProcessor load(@Nullable final CacheKey key) throws Exception {
  ImageProcessor imageProcessor=null;
  if (key != null) {
    imageProcessor=loadImageProcessor(key.getUri(),key.getDownSampleLevels(),key.isMask(),key.isConvertTo16Bit());
  }
  return imageProcessor;
}",0.989547038327526
25533,"public ImageProcessor get(final String url,final int downSampleLevels,boolean isMask,boolean convertTo16Bit) throws IllegalArgumentException {
  final CacheKey key=new CacheKey(url,downSampleLevels,isMask,convertTo16Bit);
  final ImageProcessor imageProcessor;
  try {
    imageProcessor=cache.get(key);
  }
 catch (  Throwable t) {
    throw new IllegalArgumentException(""String_Node_Str"" + key + ""String_Node_Str"",t);
  }
  return imageProcessor.duplicate();
}","/** 
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.Negative values are considered the same as zero.
 * @param isMask            indicates whether this image is a mask.
 * @param convertTo16Bit    indicates whether this image should be converted to 16-bit.
 * @return a duplicate instance of the cached image processor for the specified url string.If the source processor is not already cached, it will be loaded into the cache. The duplicate instance is returned because the processors are mutable and the cached instance needs to remain unaltered for future use.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
public ImageProcessor get(final String url,final int downSampleLevels,final boolean isMask,final boolean convertTo16Bit) throws IllegalArgumentException {
  final CacheKey key=new CacheKey(url,downSampleLevels,isMask,convertTo16Bit);
  final ImageProcessor imageProcessor;
  try {
    imageProcessor=cache.get(key);
  }
 catch (  final Throwable t) {
    throw new IllegalArgumentException(""String_Node_Str"" + key + ""String_Node_Str"",t);
  }
  return imageProcessor.duplicate();
}",0.4178743961352657
25534,"@Override public boolean equals(Object o){
  boolean result=true;
  if (this != o) {
    if (o instanceof CacheKey) {
      final CacheKey that=(CacheKey)o;
      result=this.url.equals(that.url) && (this.downSampleLevels == that.downSampleLevels) && (this.convertTo16Bit == that.convertTo16Bit);
    }
 else {
      result=false;
    }
  }
  return result;
}","@Override public boolean equals(final Object o){
  boolean result=true;
  if (this != o) {
    if (o instanceof CacheKey) {
      final CacheKey that=(CacheKey)o;
      result=this.url.equals(that.url) && (this.downSampleLevels == that.downSampleLevels) && (this.convertTo16Bit == that.convertTo16Bit);
    }
 else {
      result=false;
    }
  }
  return result;
}",0.9917127071823204
25535,"/** 
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.
 * @param isMask            indicates whether this image is a mask.
 * @return a newly loaded (non-cached) image processor.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
public static ImageProcessor getNonCachedImage(final String url,final int downSampleLevels,final boolean isMask) throws IllegalArgumentException {
  return DISABLED_CACHE.loadImageProcessor(url,downSampleLevels,isMask);
}","/** 
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.
 * @param isMask            indicates whether this image is a mask.
 * @return a newly loaded (non-cached) image processor.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
public static ImageProcessor getNonCachedImage(final String url,final int downSampleLevels,final boolean isMask,final boolean convertTo16Bit) throws IllegalArgumentException {
  return DISABLED_CACHE.loadImageProcessor(url,downSampleLevels,isMask,convertTo16Bit);
}",0.961335676625659
25536,"/** 
 * Loads a label image processor when cache misses occur for source images. Masks are loaded in the standard manner.
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.
 * @param isMask            indicates whether this image is a mask.
 * @return a newly loaded image processor to be cached.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
@Override protected ImageProcessor loadImageProcessor(final String url,final int downSampleLevels,final boolean isMask) throws IllegalArgumentException {
  ImageProcessor imageProcessor;
  if (isMask) {
    imageProcessor=super.loadImageProcessor(url,downSampleLevels,true);
  }
 else {
    final Color labelColor=getColorForUrl(url);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",url,downSampleLevels,labelColor);
    }
    final TileSpec tileSpec=urlToTileSpec.get(url);
    imageProcessor=loadLabelProcessor(tileSpec.getWidth(),tileSpec.getHeight(),labelColor);
    if (downSampleLevels > 0) {
      imageProcessor=Downsampler.downsampleImageProcessor(imageProcessor,downSampleLevels);
    }
  }
  return imageProcessor;
}","/** 
 * Loads a label image processor when cache misses occur for source images. Masks are loaded in the standard manner.
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.
 * @param isMask            indicates whether this image is a mask.
 * @return a newly loaded image processor to be cached.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
@Override protected ImageProcessor loadImageProcessor(final String url,final int downSampleLevels,final boolean isMask,final boolean convertTo16Bit) throws IllegalArgumentException {
  ImageProcessor imageProcessor;
  if (isMask) {
    imageProcessor=super.loadImageProcessor(url,downSampleLevels,true,convertTo16Bit);
  }
 else {
    final Color labelColor=getColorForUrl(url);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",url,downSampleLevels,labelColor);
    }
    final TileSpec tileSpec=urlToTileSpec.get(url);
    imageProcessor=loadLabelProcessor(tileSpec.getWidth(),tileSpec.getHeight(),labelColor);
    if (downSampleLevels > 0) {
      imageProcessor=Downsampler.downsampleImageProcessor(imageProcessor,downSampleLevels);
    }
  }
  return imageProcessor;
}",0.9818181818181818
25537,"@Test public void testRender() throws Exception {
  final ImageAndMask imageWithoutMask=new ImageAndMask(""String_Node_Str"",null);
  final ImageProcessorCache imageProcessorCache=new ImageProcessorCache();
  final ImageProcessor rawIp=imageProcessorCache.get(imageWithoutMask.getImageUrl(),0,false);
  final BufferedImage rawImage=rawIp.getBufferedImage();
  final TileSpec tileSpec=new TileSpec();
  tileSpec.putMipmap(0,imageWithoutMask);
  final RenderParameters tileRenderParameters=new RenderParameters(null,0,0,rawIp.getWidth(),rawIp.getHeight(),1.0);
  tileRenderParameters.addTileSpec(tileSpec);
  tileRenderParameters.setSkipInterpolation(true);
  final BufferedImage renderedImage=tileRenderParameters.openTargetImage();
  Render.render(tileRenderParameters,renderedImage,imageProcessorCache);
  Assert.assertEquals(""String_Node_Str"",rawImage.getWidth(),renderedImage.getWidth());
  Assert.assertEquals(""String_Node_Str"",rawImage.getWidth(),renderedImage.getHeight());
  for (int x=0; x < rawImage.getWidth(); x++) {
    for (int y=0; y < rawImage.getHeight(); y++) {
      Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",rawImage.getRGB(x,y),renderedImage.getRGB(x,y));
    }
  }
}","@Test public void testRender() throws Exception {
  final ImageAndMask imageWithoutMask=new ImageAndMask(""String_Node_Str"",null);
  final ImageProcessorCache imageProcessorCache=new ImageProcessorCache();
  final ImageProcessor rawIp=imageProcessorCache.get(imageWithoutMask.getImageUrl(),0,false,false);
  final BufferedImage rawImage=rawIp.getBufferedImage();
  final TileSpec tileSpec=new TileSpec();
  tileSpec.putMipmap(0,imageWithoutMask);
  final RenderParameters tileRenderParameters=new RenderParameters(null,0,0,rawIp.getWidth(),rawIp.getHeight(),1.0);
  tileRenderParameters.addTileSpec(tileSpec);
  tileRenderParameters.setSkipInterpolation(true);
  final BufferedImage renderedImage=tileRenderParameters.openTargetImage();
  Render.render(tileRenderParameters,renderedImage,imageProcessorCache);
  Assert.assertEquals(""String_Node_Str"",rawImage.getWidth(),renderedImage.getWidth());
  Assert.assertEquals(""String_Node_Str"",rawImage.getWidth(),renderedImage.getHeight());
  for (int x=0; x < rawImage.getWidth(); x++) {
    for (int y=0; y < rawImage.getHeight(); y++) {
      Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",rawImage.getRGB(x,y),renderedImage.getRGB(x,y));
    }
  }
}",0.997560975609756
25538,"public void testRenderMeshOperations() throws Exception {
  for (int i=0; i < 10; ++i) {
    final long start=System.currentTimeMillis();
    final RenderTransformMesh mesh=new RenderTransformMesh(ctlMipmap,(int)(tileSpec.getWidth() / tileSpec.getMeshCellSize() + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    mesh.updateAffines();
    final long meshCreationStop=System.currentTimeMillis();
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks source=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(ipMipmap,maskSourceProcessor,null);
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks target=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(tp,maskTargetProcessor,null);
    final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
    mapping.mapInterpolated(source,target,1);
    final long mapInterpolatedStop=System.currentTimeMillis();
    LOG.info(""String_Node_Str"",meshCreationStop - start,mapInterpolatedStop - meshCreationStop);
    final ImageProcessor targetImageProcessor=target.ip;
    final int expectedPixelCount=5989000;
    Assert.assertEquals(""String_Node_Str"",expectedPixelCount,targetImageProcessor.getPixelCount());
    final int[] expectedPixelValues={0,0,0,0,0,0,0,0,0,0,0,0,0,135,107,118,126,171,103,189,129,178,130,0,0,100,151,122,122,105,169,155,179,126,131,0,0,149,100,107,185,130,163,138,189,187,194,0,0,179,153,168,171,181,128,119,132,195,113,0,0,129,150,118,179,93,185,135,78,106,185,0,0,136,164,136,184,167,184,150,182,143,172,0,0,120,134,140,67,92,76,112,178,96,185,0,0,101,81,171,138,117,147,145,162,114,97,0,0,131,157,173,170,81,157,148,177,173,160,0,0,142,101,93,90,131,139,127,173,185,150,0,0,166,161,105,165,109,165,155,92,152,154,0,0,169,89,87,163,162,142,109,177,155,104,0,0,0,0,0,0,0,0,0,0,0,0,0};
    int index=0;
    for (int x=0; x < targetImageProcessor.getWidth(); x+=200) {
      for (int y=0; y < targetImageProcessor.getHeight(); y+=200) {
        Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",expectedPixelValues[index],targetImageProcessor.getPixel(x,y));
        index++;
      }
    }
  }
}","@Test public void testRenderMeshOperations() throws Exception {
  for (int i=0; i < 10; ++i) {
    final long start=System.currentTimeMillis();
    final RenderTransformMesh mesh=new RenderTransformMesh(ctlMipmap,(int)(tileSpec.getWidth() / tileSpec.getMeshCellSize() + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    mesh.updateAffines();
    final long meshCreationStop=System.currentTimeMillis();
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks source=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(ipMipmap,maskSourceProcessor,null);
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks target=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(tp,maskTargetProcessor,null);
    final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
    mapping.mapInterpolated(source,target,1);
    final long mapInterpolatedStop=System.currentTimeMillis();
    LOG.info(""String_Node_Str"",meshCreationStop - start,mapInterpolatedStop - meshCreationStop);
    final ImageProcessor targetImageProcessor=target.ip;
    final int expectedPixelCount=5989000;
    Assert.assertEquals(""String_Node_Str"",expectedPixelCount,targetImageProcessor.getPixelCount());
    final int[] expectedPixelValues={0,0,0,0,0,0,0,0,0,0,0,0,0,135,107,118,126,171,103,189,129,178,130,0,0,100,151,122,122,105,169,155,179,126,131,0,0,149,100,107,185,130,163,138,189,187,194,0,0,179,153,168,171,181,128,119,132,195,113,0,0,129,150,118,179,93,185,135,78,106,185,0,0,136,164,136,184,167,184,150,182,143,172,0,0,120,134,140,67,92,76,112,178,96,185,0,0,101,81,171,138,117,147,145,162,114,97,0,0,131,157,173,170,81,157,148,177,173,160,0,0,142,101,93,90,131,139,127,173,185,150,0,0,166,161,105,165,109,165,155,92,152,154,0,0,169,89,87,163,162,142,109,177,155,104,0,0,0,0,0,0,0,0,0,0,0,0,0};
    int index=0;
    for (int x=0; x < targetImageProcessor.getWidth(); x+=200) {
      for (int y=0; y < targetImageProcessor.getHeight(); y+=200) {
        Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",expectedPixelValues[index],targetImageProcessor.getPixel(x,y));
        index++;
      }
    }
  }
}",0.998620055197792
25539,"@Before public void setup() throws Exception {
  tileSpec=TileSpec.fromJson(TILE_SPEC_JSON);
  ctlMipmap=new CoordinateTransformList<>();
  for (  final CoordinateTransform t : tileSpec.getTransformList().getList(null)) {
    ctlMipmap.add(t);
  }
  final int downSampleLevels=0;
  final Map.Entry<Integer,ImageAndMask> mipmapEntry=tileSpec.getFirstMipmapEntry();
  final ImageAndMask imageAndMask=mipmapEntry.getValue();
  ipMipmap=ImageProcessorCache.getNonCachedImage(imageAndMask.getImageUrl(),downSampleLevels,false);
  tp=ipMipmap.createProcessor(ipMipmap.getWidth(),ipMipmap.getHeight());
  final String maskUrl=imageAndMask.getMaskUrl();
  maskSourceProcessor=ImageProcessorCache.getNonCachedImage(maskUrl,downSampleLevels,true);
  maskTargetProcessor=new ByteProcessor(tp.getWidth(),tp.getHeight());
}","@Before public void setup() throws Exception {
  tileSpec=TileSpec.fromJson(TILE_SPEC_JSON);
  ctlMipmap=new CoordinateTransformList<>();
  for (  final CoordinateTransform t : tileSpec.getTransformList().getList(null)) {
    ctlMipmap.add(t);
  }
  final int downSampleLevels=0;
  final Map.Entry<Integer,ImageAndMask> mipmapEntry=tileSpec.getFirstMipmapEntry();
  final ImageAndMask imageAndMask=mipmapEntry.getValue();
  ipMipmap=ImageProcessorCache.getNonCachedImage(imageAndMask.getImageUrl(),downSampleLevels,false,false);
  tp=ipMipmap.createProcessor(ipMipmap.getWidth(),ipMipmap.getHeight());
  final String maskUrl=imageAndMask.getMaskUrl();
  maskSourceProcessor=ImageProcessorCache.getNonCachedImage(maskUrl,downSampleLevels,true,false);
  maskTargetProcessor=new ByteProcessor(tp.getWidth(),tp.getHeight());
}",0.9926470588235294
25540,"public void testMeshOperations() throws Exception {
  for (int i=0; i < 10; ++i) {
    final long start=System.currentTimeMillis();
    final CoordinateTransformMesh mesh=new CoordinateTransformMesh(ctlMipmap,(int)(tileSpec.getWidth() / tileSpec.getMeshCellSize() + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    final long meshCreationStop=System.currentTimeMillis();
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks source=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(ipMipmap,maskSourceProcessor,null);
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks target=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(tp,maskTargetProcessor,null);
    final TransformMeshMappingWithMasks<TransformMesh> mapping=new TransformMeshMappingWithMasks<TransformMesh>(mesh);
    mapping.mapInterpolated(source,target,1);
    final long mapInterpolatedStop=System.currentTimeMillis();
    LOG.info(""String_Node_Str"",meshCreationStop - start,mapInterpolatedStop - meshCreationStop);
    final ImageProcessor targetImageProcessor=target.ip;
    final int expectedPixelCount=5989000;
    Assert.assertEquals(""String_Node_Str"",expectedPixelCount,targetImageProcessor.getPixelCount());
    final int[] expectedPixelValues={0,0,0,0,0,0,0,0,0,0,0,0,0,135,107,118,126,171,103,189,129,178,130,0,0,100,151,122,122,105,169,155,179,126,131,0,0,149,100,107,185,130,163,138,189,187,194,0,0,179,153,168,171,181,128,119,132,195,113,0,0,129,150,118,179,93,185,135,78,106,185,0,0,136,164,136,184,167,184,150,182,143,172,0,0,120,134,140,67,92,76,112,178,96,185,0,0,101,81,171,138,117,147,145,162,114,97,0,0,131,157,173,170,81,157,148,177,173,160,0,0,142,101,93,90,131,139,127,173,185,150,0,0,166,161,105,165,109,165,155,92,152,154,0,0,169,89,87,163,162,142,109,177,155,104,0,0,0,0,0,0,0,0,0,0,0,0,0};
    int index=0;
    for (int x=0; x < targetImageProcessor.getWidth(); x+=200) {
      for (int y=0; y < targetImageProcessor.getHeight(); y+=200) {
        Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",expectedPixelValues[index],targetImageProcessor.getPixel(x,y));
        index++;
      }
    }
  }
}","@Test public void testMeshOperations() throws Exception {
  for (int i=0; i < 10; ++i) {
    final long start=System.currentTimeMillis();
    final CoordinateTransformMesh mesh=new CoordinateTransformMesh(ctlMipmap,(int)(tileSpec.getWidth() / tileSpec.getMeshCellSize() + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    final long meshCreationStop=System.currentTimeMillis();
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks source=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(ipMipmap,maskSourceProcessor,null);
    final TransformMeshMappingWithMasks.ImageProcessorWithMasks target=new TransformMeshMappingWithMasks.ImageProcessorWithMasks(tp,maskTargetProcessor,null);
    final TransformMeshMappingWithMasks<TransformMesh> mapping=new TransformMeshMappingWithMasks<TransformMesh>(mesh);
    mapping.mapInterpolated(source,target,1);
    final long mapInterpolatedStop=System.currentTimeMillis();
    LOG.info(""String_Node_Str"",meshCreationStop - start,mapInterpolatedStop - meshCreationStop);
    final ImageProcessor targetImageProcessor=target.ip;
    final int expectedPixelCount=5989000;
    Assert.assertEquals(""String_Node_Str"",expectedPixelCount,targetImageProcessor.getPixelCount());
    final int[] expectedPixelValues={0,0,0,0,0,0,0,0,0,0,0,0,0,135,107,118,126,171,103,189,129,178,130,0,0,100,151,122,122,105,169,155,179,126,131,0,0,149,100,107,185,130,163,138,189,187,194,0,0,179,153,168,171,181,128,119,132,195,113,0,0,129,150,118,179,93,185,135,78,106,185,0,0,136,164,136,184,167,184,150,182,143,172,0,0,120,134,140,67,92,76,112,178,96,185,0,0,101,81,171,138,117,147,145,162,114,97,0,0,131,157,173,170,81,157,148,177,173,160,0,0,142,101,93,90,131,139,127,173,185,150,0,0,166,161,105,165,109,165,155,92,152,154,0,0,169,89,87,163,162,142,109,177,155,104,0,0,0,0,0,0,0,0,0,0,0,0,0};
    int index=0;
    for (int x=0; x < targetImageProcessor.getWidth(); x+=200) {
      for (int y=0; y < targetImageProcessor.getHeight(); y+=200) {
        Assert.assertEquals(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",expectedPixelValues[index],targetImageProcessor.getPixel(x,y));
        index++;
      }
    }
  }
}",0.9986162361623616
25541,"public static BufferedImage targetToARGBImage(final ImageProcessorWithMasks target,final double sourceMinIntensity,final double sourceMaxIntensity,final boolean binaryMask,final Double renderMinIntensity,final Double renderMaxIntensity){
  final double minIntensity=(renderMinIntensity == null) ? sourceMinIntensity : renderMinIntensity;
  final double maxIntensity=(renderMaxIntensity == null) ? sourceMaxIntensity : renderMaxIntensity;
  target.ip.setMinAndMax(minIntensity,maxIntensity);
  final ColorProcessor cp=target.ip.convertToColorProcessor();
  final int[] cpPixels=(int[])cp.getPixels();
  final byte[] alphaPixels;
  if (target.mask != null) {
    alphaPixels=(byte[])target.mask.getPixels();
  }
 else {
    alphaPixels=(byte[])target.outside.getPixels();
  }
  if (binaryMask) {
    for (int i=0; i < cpPixels.length; ++i) {
      if (alphaPixels[i] == -1)       cpPixels[i]&=0xffffffff;
 else       cpPixels[i]&=0x00ffffff;
    }
  }
 else {
    for (int i=0; i < cpPixels.length; ++i) {
      cpPixels[i]&=0x00ffffff | (alphaPixels[i] << 24);
    }
  }
  final BufferedImage image=new BufferedImage(cp.getWidth(),cp.getHeight(),BufferedImage.TYPE_INT_ARGB);
  final WritableRaster raster=image.getRaster();
  raster.setDataElements(0,0,cp.getWidth(),cp.getHeight(),cpPixels);
  return image;
}","public static BufferedImage targetToARGBImage(final ImageProcessorWithMasks target,final double sourceMinIntensity,final double sourceMaxIntensity,final boolean binaryMask,final Double renderMinIntensity,final Double renderMaxIntensity){
  final double minIntensity=(renderMinIntensity == null) ? sourceMinIntensity : renderMinIntensity;
  final double maxIntensity=(renderMaxIntensity == null) ? sourceMaxIntensity : renderMaxIntensity;
  target.ip.setMinAndMax(minIntensity,maxIntensity);
  final ColorProcessor cp=target.ip.convertToColorProcessor();
  final int[] cpPixels=(int[])cp.getPixels();
  final byte[] alphaPixels;
  if (target.mask != null) {
    alphaPixels=(byte[])target.mask.getPixels();
  }
 else   if (target.outside != null) {
    alphaPixels=(byte[])target.outside.getPixels();
  }
 else {
    alphaPixels=null;
  }
  if (alphaPixels == null) {
    for (int i=0; i < cpPixels.length; ++i) {
      cpPixels[i]&=0xffffffff;
    }
  }
 else   if (binaryMask) {
    for (int i=0; i < cpPixels.length; ++i) {
      if (alphaPixels[i] == -1)       cpPixels[i]&=0xffffffff;
 else       cpPixels[i]&=0x00ffffff;
    }
  }
 else {
    for (int i=0; i < cpPixels.length; ++i) {
      cpPixels[i]&=0x00ffffff | (alphaPixels[i] << 24);
    }
  }
  final BufferedImage image=new BufferedImage(cp.getWidth(),cp.getHeight(),BufferedImage.TYPE_INT_ARGB);
  final WritableRaster raster=image.getRaster();
  raster.setDataElements(0,0,cp.getWidth(),cp.getHeight(),cpPixels);
  return image;
}",0.9337134711332858
25542,"@Override public ChannelMap getChannels(final int mipmapLevel) throws IllegalArgumentException {
  final ChannelMap targetChannels=new ChannelMap();
  final double levelScale=(1.0 / Math.pow(2.0,mipmapLevel)) * levelZeroScale;
  final int levelWidth=(int)((fullScaleWidth * levelScale) + 0.5);
  final int levelHeight=(int)((fullScaleHeight * levelScale) + 0.5);
  for (  final String channelName : channelNames) {
    targetChannels.put(channelName,new ImageProcessorWithMasks(new FloatProcessor(levelWidth,levelHeight),new ByteProcessor(levelWidth,levelHeight),null));
  }
  long totalScaleDerivationTime=0;
  for (  final TransformableCanvas canvas : canvasList) {
    final long scaleDerivationStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> renderTransformList=addRenderScaleAndOffset(canvas.getTransformList(),levelZeroScale,levelScale,x,y);
    final MipmapSource source=canvas.getSource();
    final double averageScale=Utils.sampleAverageScale(renderTransformList,source.getFullScaleWidth(),source.getFullScaleHeight(),meshCellSize);
    final int componentMipmapLevel=Utils.bestMipmapLevel(averageScale);
    totalScaleDerivationTime+=(System.currentTimeMillis() - scaleDerivationStart);
    mapPixels(source,componentMipmapLevel,renderTransformList,meshCellSize,binaryMask,numberOfMappingThreads,skipInterpolation,targetChannels);
  }
  LOG.debug(""String_Node_Str"",canvasList.size(),totalScaleDerivationTime);
  return targetChannels;
}","@Override public ChannelMap getChannels(final int mipmapLevel) throws IllegalArgumentException {
  final ChannelMap targetChannels=new ChannelMap();
  final double levelScale=(1.0 / Math.pow(2.0,mipmapLevel)) * levelZeroScale;
  final int levelWidth=(int)((fullScaleWidth * levelScale) + 0.5);
  final int levelHeight=(int)((fullScaleHeight * levelScale) + 0.5);
  for (  final String channelName : channelNames) {
    targetChannels.put(channelName,new ImageProcessorWithMasks(new FloatProcessor(levelWidth,levelHeight),null,null));
  }
  long totalScaleDerivationTime=0;
  for (  final TransformableCanvas canvas : canvasList) {
    final long scaleDerivationStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> renderTransformList=addRenderScaleAndOffset(canvas.getTransformList(),levelZeroScale,levelScale,x,y);
    final MipmapSource source=canvas.getSource();
    final double averageScale=Utils.sampleAverageScale(renderTransformList,source.getFullScaleWidth(),source.getFullScaleHeight(),meshCellSize);
    final int componentMipmapLevel=Utils.bestMipmapLevel(averageScale);
    totalScaleDerivationTime+=(System.currentTimeMillis() - scaleDerivationStart);
    mapPixels(source,componentMipmapLevel,renderTransformList,meshCellSize,binaryMask,numberOfMappingThreads,skipInterpolation,targetChannels);
  }
  LOG.debug(""String_Node_Str"",canvasList.size(),totalScaleDerivationTime);
  return targetChannels;
}",0.9853691731881592
25543,"/** 
 * Maps pixels from a source to a target.
 * @param source                  source pixel data.
 * @param mipmapLevel             source mipmap level.
 * @param renderTransformList     list of transforms for the render context.
 * @param meshCellSize            desired size of a mesh cell (triangle) in pixels.
 * @param binaryMask              render only 100% opaque pixels.
 * @param numberOfMappingThreads  number of threads to use for pixel mapping.
 * @param skipInterpolation       enable sloppy but fast rendering by skipping interpolation.
 * @param targetChannels          target channels for mapped results.
 */
public static void mapPixels(final MipmapSource source,final int mipmapLevel,final CoordinateTransformList<CoordinateTransform> renderTransformList,final double meshCellSize,final boolean binaryMask,final int numberOfMappingThreads,final boolean skipInterpolation,final ChannelMap targetChannels){
  final ChannelMap sourceChannels=source.getChannels(mipmapLevel);
  if (sourceChannels.size() > 0) {
    final long mapStart=System.currentTimeMillis();
    final ImageProcessorWithMasks firstChannel=sourceChannels.getFirstChannel();
    final boolean hasMask=(firstChannel.mask != null);
    final int mipmapWidth=firstChannel.ip.getWidth();
    final int mipmapHeight=firstChannel.ip.getHeight();
    final PixelMapper tilePixelMapper=getPixelMapper(sourceChannels,hasMask,binaryMask,skipInterpolation,targetChannels);
    if (tilePixelMapper != null) {
      final RenderTransformMesh mesh=createRenderMesh(mipmapLevel,renderTransformList,source.getFullScaleWidth(),meshCellSize,mipmapWidth,mipmapHeight);
      final long meshCreationStop=System.currentTimeMillis();
      final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
      final String mapType=skipInterpolation ? ""String_Node_Str"" : ""String_Node_Str"";
      mapping.map(tilePixelMapper,numberOfMappingThreads);
      final long mapStop=System.currentTimeMillis();
      LOG.debug(""String_Node_Str"",source.getSourceName(),mapStop - mapStart,meshCreationStop - mapStart,mapType,mapStop - meshCreationStop);
    }
  }
 else {
    LOG.warn(""String_Node_Str"",source.getSourceName());
  }
}","/** 
 * Maps pixels from a source to a target.
 * @param source                  source pixel data.
 * @param mipmapLevel             source mipmap level.
 * @param renderTransformList     list of transforms for the render context.
 * @param meshCellSize            desired size of a mesh cell (triangle) in pixels.
 * @param binaryMask              render only 100% opaque pixels.
 * @param numberOfMappingThreads  number of threads to use for pixel mapping.
 * @param skipInterpolation       enable sloppy but fast rendering by skipping interpolation.
 * @param targetChannels          target channels for mapped results.
 */
public static void mapPixels(final MipmapSource source,final int mipmapLevel,final CoordinateTransformList<CoordinateTransform> renderTransformList,final double meshCellSize,final boolean binaryMask,final int numberOfMappingThreads,final boolean skipInterpolation,final ChannelMap targetChannels){
  final ChannelMap sourceChannels=source.getChannels(mipmapLevel);
  if (sourceChannels.size() > 0) {
    final long mapStart=System.currentTimeMillis();
    final ImageProcessorWithMasks firstChannel=sourceChannels.getFirstChannel();
    final boolean hasMask=(firstChannel.mask != null);
    final int mipmapWidth=firstChannel.ip.getWidth();
    final int mipmapHeight=firstChannel.ip.getHeight();
    if (hasMask) {
      for (      final ImageProcessorWithMasks targetChannel : targetChannels.values()) {
        if (targetChannel.mask == null) {
          targetChannel.mask=new ByteProcessor(targetChannel.ip.getWidth(),targetChannel.ip.getHeight());
        }
      }
    }
    final PixelMapper tilePixelMapper=getPixelMapper(sourceChannels,hasMask,binaryMask,skipInterpolation,targetChannels);
    if (tilePixelMapper != null) {
      final RenderTransformMesh mesh=createRenderMesh(mipmapLevel,renderTransformList,source.getFullScaleWidth(),meshCellSize,mipmapWidth,mipmapHeight);
      final long meshCreationStop=System.currentTimeMillis();
      final RenderTransformMeshMappingWithMasks mapping=new RenderTransformMeshMappingWithMasks(mesh);
      final String mapType=skipInterpolation ? ""String_Node_Str"" : ""String_Node_Str"";
      mapping.map(tilePixelMapper,numberOfMappingThreads);
      final long mapStop=System.currentTimeMillis();
      LOG.debug(""String_Node_Str"",source.getSourceName(),mapStop - mapStart,meshCreationStop - mapStart,mapType,mapStop - meshCreationStop);
    }
  }
 else {
    LOG.warn(""String_Node_Str"",source.getSourceName());
  }
}",0.9404534859080314
25544,"public void writeCoordinatesWithTileIds(final StackId stackId,final Double z,final List<TileCoordinates> worldCoordinatesList,final OutputStream outputStream) throws IllegalArgumentException, IOException {
  LOG.debug(""String_Node_Str"",stackId,z,worldCoordinatesList.size());
  MongoUtil.validateRequiredParameter(""String_Node_Str"",stackId);
  final MongoCollection<Document> tileCollection=getTileCollection(stackId);
  final Document tileKeys=new Document(""String_Node_Str"",1).append(""String_Node_Str"",0);
  final Document orderBy=new Document(""String_Node_Str"",1);
  final ProcessTimer timer=new ProcessTimer();
  final byte[] openBracket=""String_Node_Str"".getBytes();
  final byte[] comma=""String_Node_Str"".getBytes();
  final byte[] closeBracket=""String_Node_Str"".getBytes();
  int coordinateCount=0;
  double[] world;
  double coordinateZ=z == null ? 0 : z;
  Document tileQuery=new Document();
  MongoCursor<Document> cursor=null;
  Document document;
  Object tileId;
  String coordinatesJson;
  try {
    outputStream.write(openBracket);
    TileCoordinates worldCoordinates;
    for (int i=0; i < worldCoordinatesList.size(); i++) {
      worldCoordinates=worldCoordinatesList.get(i);
      world=worldCoordinates.getWorld();
      if (world == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + i);
      }
 else       if (z == null) {
        if (world.length < 2) {
          throw new IllegalArgumentException(""String_Node_Str"" + i);
        }
      }
 else {
        if (world.length < 3) {
          throw new IllegalArgumentException(""String_Node_Str"" + i);
        }
        coordinateZ=world[2];
      }
      tileQuery=getIntersectsBoxQuery(coordinateZ,world[0],world[1],world[0],world[1]);
      cursor=tileCollection.find(tileQuery).projection(tileKeys).sort(orderBy).iterator();
      if (i > 0) {
        outputStream.write(comma);
      }
      outputStream.write(openBracket);
      if (cursor.hasNext()) {
        document=cursor.next();
        tileId=document.get(""String_Node_Str"");
        if (tileId != null) {
          worldCoordinates.setTileId(tileId.toString());
        }
        coordinatesJson=worldCoordinates.toJson();
        outputStream.write(coordinatesJson.getBytes());
        while (cursor.hasNext()) {
          document=cursor.next();
          tileId=document.get(""String_Node_Str"");
          if (tileId != null) {
            worldCoordinates.setTileId(tileId.toString());
          }
          coordinatesJson=worldCoordinates.toJson();
          outputStream.write(comma);
          outputStream.write(coordinatesJson.getBytes());
        }
      }
 else {
        coordinatesJson=worldCoordinates.toJson();
        outputStream.write(coordinatesJson.getBytes());
      }
      cursor.close();
      outputStream.write(closeBracket);
      coordinateCount++;
      if (timer.hasIntervalPassed()) {
        LOG.debug(""String_Node_Str"",coordinateCount);
      }
    }
    outputStream.write(closeBracket);
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  LOG.debug(""String_Node_Str"",coordinateCount,MongoUtil.fullName(tileCollection),tileQuery.toJson(),tileKeys.toJson(),orderBy.toJson(),timer.getElapsedSeconds());
}","public void writeCoordinatesWithTileIds(final StackId stackId,final Double z,final List<TileCoordinates> worldCoordinatesList,final OutputStream outputStream) throws IllegalArgumentException, IOException {
  LOG.debug(""String_Node_Str"",stackId,z,worldCoordinatesList.size());
  MongoUtil.validateRequiredParameter(""String_Node_Str"",stackId);
  final MongoCollection<Document> tileCollection=getTileCollection(stackId);
  final Document tileKeys=new Document(""String_Node_Str"",1).append(""String_Node_Str"",0);
  final Document orderBy=new Document(""String_Node_Str"",1);
  final ProcessTimer timer=new ProcessTimer();
  final byte[] openBracket=""String_Node_Str"".getBytes();
  final byte[] comma=""String_Node_Str"".getBytes();
  final byte[] closeBracket=""String_Node_Str"".getBytes();
  int coordinateCount=0;
  double[] world;
  double coordinateZ=z == null ? -1 : z;
  Document tileQuery=new Document();
  MongoCursor<Document> cursor=null;
  Document document;
  Object tileId;
  String coordinatesJson;
  try {
    outputStream.write(openBracket);
    TileCoordinates worldCoordinates;
    for (int i=0; i < worldCoordinatesList.size(); i++) {
      worldCoordinates=worldCoordinatesList.get(i);
      world=worldCoordinates.getWorld();
      if (world == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + i);
      }
 else       if (z == null) {
        if (world.length < 3) {
          throw new IllegalArgumentException(""String_Node_Str"" + i);
        }
        coordinateZ=world[2];
      }
 else {
        if (world.length < 2) {
          throw new IllegalArgumentException(""String_Node_Str"" + i);
        }
      }
      tileQuery=getIntersectsBoxQuery(coordinateZ,world[0],world[1],world[0],world[1]);
      cursor=tileCollection.find(tileQuery).projection(tileKeys).sort(orderBy).iterator();
      if (i > 0) {
        outputStream.write(comma);
      }
      outputStream.write(openBracket);
      if (cursor.hasNext()) {
        document=cursor.next();
        tileId=document.get(""String_Node_Str"");
        if (tileId != null) {
          worldCoordinates.setTileId(tileId.toString());
        }
        coordinatesJson=worldCoordinates.toJson();
        outputStream.write(coordinatesJson.getBytes());
        while (cursor.hasNext()) {
          document=cursor.next();
          tileId=document.get(""String_Node_Str"");
          if (tileId != null) {
            worldCoordinates.setTileId(tileId.toString());
          }
          coordinatesJson=worldCoordinates.toJson();
          outputStream.write(comma);
          outputStream.write(coordinatesJson.getBytes());
        }
      }
 else {
        coordinatesJson=worldCoordinates.toJson();
        outputStream.write(coordinatesJson.getBytes());
      }
      cursor.close();
      outputStream.write(closeBracket);
      coordinateCount++;
      if (timer.hasIntervalPassed()) {
        LOG.debug(""String_Node_Str"",coordinateCount);
      }
    }
    outputStream.write(closeBracket);
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  LOG.debug(""String_Node_Str"",coordinateCount,MongoUtil.fullName(tileCollection),tileQuery.toJson(),tileKeys.toJson(),orderBy.toJson(),timer.getElapsedSeconds());
}",0.9600745688985552
25545,"private Map<String,TransformSpec> addResolvedTileSpecs(final StackId stackId,final Document tileQuery,final RenderParameters renderParameters){
  final MongoCollection<Document> tileCollection=getTileCollection(stackId);
  final Document orderBy=new Document(""String_Node_Str"",1);
  try (MongoCursor<Document> cursor=tileCollection.find(tileQuery).sort(orderBy).iterator()){
    Document document;
    TileSpec tileSpec;
    int count=0;
    while (cursor.hasNext()) {
      if (count > 50000) {
        throw new IllegalArgumentException(""String_Node_Str"" + count + ""String_Node_Str""+ tileQuery);
      }
      document=cursor.next();
      tileSpec=TileSpec.fromJson(document.toJson());
      renderParameters.addTileSpec(tileSpec);
      count++;
    }
  }
   LOG.debug(""String_Node_Str"",renderParameters.numberOfTileSpecs(),MongoUtil.fullName(tileCollection),tileQuery.toJson(),orderBy.toJson());
  return resolveTransformReferencesForTiles(stackId,renderParameters.getTileSpecs());
}","private Map<String,TransformSpec> addResolvedTileSpecs(final StackId stackId,final Document tileQuery,final RenderParameters renderParameters){
  final MongoCollection<Document> tileCollection=getTileCollection(stackId);
  final Document orderBy=new Document(""String_Node_Str"",1);
  try (MongoCursor<Document> cursor=tileCollection.find(tileQuery).sort(orderBy).iterator()){
    Document document;
    TileSpec tileSpec;
    int count=0;
    while (cursor.hasNext()) {
      if (count > 50000) {
        throw new IllegalArgumentException(""String_Node_Str"" + count + ""String_Node_Str""+ tileQuery);
      }
      document=cursor.next();
      tileSpec=TileSpec.fromJson(document.toJson());
      renderParameters.addTileSpec(tileSpec);
      count++;
    }
  }
   if (LOG.isDebugEnabled()) {
    String queryJson=tileQuery.toJson();
    if (queryJson.length() > 100) {
      queryJson=queryJson.substring(0,95) + ""String_Node_Str"";
    }
    LOG.debug(""String_Node_Str"",renderParameters.numberOfTileSpecs(),MongoUtil.fullName(tileCollection),queryJson,orderBy.toJson());
  }
  return resolveTransformReferencesForTiles(stackId,renderParameters.getTileSpecs());
}",0.9046067938576082
25546,"private RenderParameters generateLevelZeroBox(final int x,final int y,final Double z,final ImageProcessorCache imageProcessorCache,final BoxMipmapGenerator boxMipmapGenerator,final IGridPaths iGridPaths,final File levelZeroFile,final int row,final int column) throws IOException {
  final String parametersUrl=getRenderDataClient().getRenderParametersUrlString(stack,x,y,z,boxWidth,boxHeight,1.0);
  LOG.info(""String_Node_Str"",parametersUrl);
  final RenderParameters renderParameters=RenderParameters.loadFromUrl(parametersUrl);
  renderParameters.setSkipInterpolation(parameters.skipInterpolation);
  renderParameters.setBinaryMask(parameters.binaryMask);
  renderParameters.setBackgroundRGBColor(backgroundRGBColor);
  if (renderParameters.hasTileSpecs()) {
    final BufferedImage levelZeroImage=renderParameters.openTargetImage();
    Render.render(renderParameters,levelZeroImage,imageProcessorCache);
    BoxMipmapGenerator.saveImage(levelZeroImage,levelZeroFile,parameters.label,format);
    boxMipmapGenerator.addSource(row,column,levelZeroFile);
    if (iGridPaths != null) {
      iGridPaths.addImage(levelZeroFile,row,column);
    }
  }
 else {
    LOG.info(""String_Node_Str"",z,row,column);
  }
  return renderParameters;
}","private RenderParameters generateLevelZeroBox(final int x,final int y,final Double z,final ImageProcessorCache imageProcessorCache,final BoxMipmapGenerator boxMipmapGenerator,final IGridPaths iGridPaths,final File levelZeroFile,final int row,final int column) throws IOException {
  final String parametersUrl=getRenderDataClient().getRenderParametersUrlString(stack,x,y,z,boxWidth,boxHeight,1.0);
  LOG.info(""String_Node_Str"",parametersUrl);
  final RenderParameters renderParameters=RenderParameters.loadFromUrl(parametersUrl);
  renderParameters.setSkipInterpolation(parameters.skipInterpolation);
  renderParameters.setBinaryMask(parameters.binaryMask);
  renderParameters.setBackgroundRGBColor(backgroundRGBColor);
  if (renderParameters.hasTileSpecs()) {
    final BufferedImage levelZeroImage=renderParameters.openTargetImage();
    Render.render(renderParameters,levelZeroImage,imageProcessorCache);
    BoxMipmapGenerator.saveImage(levelZeroImage,levelZeroFile,parameters.label,format);
    boxMipmapGenerator.addSource(row,column,levelZeroFile);
    if (iGridPaths != null) {
      iGridPaths.addImage(levelZeroFile,row,column);
    }
  }
 else {
    LOG.info(""String_Node_Str"",row,column);
  }
  return renderParameters;
}",0.9991896272285252
25547,"public int size(){
  return (matches == null) ? 0 : matches.getWs().length;
}","public int size(){
  int size=0;
  if (matches != null) {
    final double[] w=matches.getWs();
    if (w != null) {
      size=w.length;
    }
  }
  return size;
}",0.5643153526970954
25548,"/** 
 * @return list of section data objects for the specified stackId.
 * @throws IllegalArgumentException if any required parameters are missing or the stack cannot be found.
 */
public List<SectionData> getSectionData(final StackId stackId,final Double minZ,final Double maxZ) throws IllegalArgumentException {
  MongoUtil.validateRequiredParameter(""String_Node_Str"",stackId);
  final List<SectionData> list=new ArrayList<>();
  if (!MongoUtil.exists(renderDatabase,stackId.getSectionCollectionName())) {
    throw new IllegalArgumentException(""String_Node_Str"" + stackId + ""String_Node_Str"");
  }
  final MongoCollection<Document> sectionCollection=getSectionCollection(stackId);
  final Document query=new Document();
  if (minZ != null) {
    query.append(""String_Node_Str"",new Document(QueryOperators.GTE,minZ));
  }
  if (maxZ != null) {
    query.append(""String_Node_Str"",new Document(QueryOperators.LTE,maxZ));
  }
  try (MongoCursor<Document> cursor=sectionCollection.find(query).iterator()){
    Document document;
    Document resultId;
    String sectionId;
    Number tileCount;
    Long tileCountLong=null;
    Double z;
    Double minX;
    Double maxX;
    Double minY;
    Double maxY;
    while (cursor.hasNext()) {
      document=cursor.next();
      resultId=document.get(""String_Node_Str"",Document.class);
      sectionId=resultId.get(""String_Node_Str"",String.class);
      z=resultId.get(""String_Node_Str"",Double.class);
      tileCount=document.get(""String_Node_Str"",Number.class);
      if (tileCount != null) {
        tileCountLong=tileCount.longValue();
      }
      minX=document.getDouble(""String_Node_Str"");
      maxX=document.getDouble(""String_Node_Str"");
      minY=document.getDouble(""String_Node_Str"");
      maxY=document.getDouble(""String_Node_Str"");
      if ((sectionId != null) && (z != null)) {
        list.add(new SectionData(sectionId,z,tileCountLong,minX,maxX,minY,maxY));
      }
    }
  }
   LOG.debug(""String_Node_Str"",list.size(),sectionCollection.getNamespace().getFullName());
  return list;
}","/** 
 * @return list of section data objects for the specified stackId.
 * @throws IllegalArgumentException if any required parameters are missing or the stack cannot be found.
 */
public List<SectionData> getSectionData(final StackId stackId,final Double minZ,final Double maxZ) throws IllegalArgumentException {
  MongoUtil.validateRequiredParameter(""String_Node_Str"",stackId);
  final List<SectionData> list=new ArrayList<>();
  if (!MongoUtil.exists(renderDatabase,stackId.getSectionCollectionName())) {
    throw new IllegalArgumentException(""String_Node_Str"" + stackId + ""String_Node_Str"");
  }
  final MongoCollection<Document> sectionCollection=getSectionCollection(stackId);
  final Document query=new Document();
  if (minZ != null) {
    if (maxZ != null) {
      query.append(""String_Node_Str"",new Document(QueryOperators.GTE,minZ).append(QueryOperators.LTE,maxZ));
    }
 else {
      query.append(""String_Node_Str"",new Document(QueryOperators.GTE,minZ));
    }
  }
 else   if (maxZ != null) {
    query.append(""String_Node_Str"",new Document(QueryOperators.LTE,maxZ));
  }
  try (MongoCursor<Document> cursor=sectionCollection.find(query).iterator()){
    Document document;
    Document resultId;
    String sectionId;
    Number tileCount;
    Long tileCountLong=null;
    Double z;
    Double minX;
    Double maxX;
    Double minY;
    Double maxY;
    while (cursor.hasNext()) {
      document=cursor.next();
      resultId=document.get(""String_Node_Str"",Document.class);
      sectionId=resultId.get(""String_Node_Str"",String.class);
      z=resultId.get(""String_Node_Str"",Double.class);
      tileCount=document.get(""String_Node_Str"",Number.class);
      if (tileCount != null) {
        tileCountLong=tileCount.longValue();
      }
      minX=document.getDouble(""String_Node_Str"");
      maxX=document.getDouble(""String_Node_Str"");
      minY=document.getDouble(""String_Node_Str"");
      maxY=document.getDouble(""String_Node_Str"");
      if ((sectionId != null) && (z != null)) {
        list.add(new SectionData(sectionId,z,tileCountLong,minX,maxX,minY,maxY));
      }
    }
  }
   LOG.debug(""String_Node_Str"",list.size(),sectionCollection.getNamespace().getFullName());
  return list;
}",0.9297297297297298
25549,"public String getBaseOwner(){
  if (baseOwner == null) {
    baseOwner=owner;
  }
  return baseProject;
}","public String getBaseOwner(){
  if (baseOwner == null) {
    baseOwner=owner;
  }
  return baseOwner;
}",0.9519230769230768
25550,"@Override public Iterator<CanvasMatches> call(final Integer partitionIndex,final Iterator<OrderedCanvasIdPair> pairIterator) throws Exception {
  LogUtilities.setupExecutorLog4j(""String_Node_Str"" + partitionIndex);
  final Logger log=LoggerFactory.getLogger(SIFTPointMatchClient.class);
  final CanvasDataCache dataCache=CanvasDataCache.getSharedCache(broadcastCacheMaxKilobytes.getValue(),broadcastFeatureLoader.getValue());
  final CanvasFeatureMatcher featureMatcher=broadcastFeatureMatcher.getValue();
  final List<CanvasMatches> matchList=new ArrayList<>();
  int pairCount=0;
  OrderedCanvasIdPair pair;
  CanvasId p;
  CanvasId q;
  List<Feature> pFeatures;
  List<Feature> qFeatures;
  CanvasFeatureMatchResult matchResult;
  Matches inlierMatches;
  while (pairIterator.hasNext()) {
    pair=pairIterator.next();
    pairCount++;
    p=pair.getP();
    q=pair.getQ();
    pFeatures=dataCache.getFeatureList(p);
    qFeatures=dataCache.getFeatureList(q);
    log.info(""String_Node_Str"",p,q);
    matchResult=featureMatcher.deriveMatchResult(pFeatures,qFeatures);
    inlierMatches=matchResult.getInlierMatches();
    if (inlierMatches.getWs().length > 0) {
      matchList.add(new CanvasMatches(p.getGroupId(),p.getId(),q.getGroupId(),q.getId(),matchResult.getInlierMatches()));
    }
  }
  log.info(""String_Node_Str"",matchList.size(),pairCount,dataCache.stats());
  return matchList.iterator();
}","@Override public Iterator<CanvasMatches> call(final Integer partitionIndex,final Iterator<OrderedCanvasIdPair> pairIterator) throws Exception {
  LogUtilities.setupExecutorLog4j(""String_Node_Str"" + partitionIndex);
  final Logger log=LoggerFactory.getLogger(SIFTPointMatchClient.class);
  final CanvasDataCache dataCache=CanvasDataCache.getSharedCache(broadcastCacheMaxKilobytes.getValue(),broadcastFeatureLoader.getValue());
  final CanvasFeatureMatcher featureMatcher=broadcastFeatureMatcher.getValue();
  final List<CanvasMatches> matchList=new ArrayList<>();
  int pairCount=0;
  OrderedCanvasIdPair pair;
  CanvasId p;
  CanvasId q;
  List<Feature> pFeatures;
  List<Feature> qFeatures;
  CanvasFeatureMatchResult matchResult;
  Matches inlierMatches;
  while (pairIterator.hasNext()) {
    pair=pairIterator.next();
    pairCount++;
    p=pair.getP();
    q=pair.getQ();
    pFeatures=dataCache.getFeatureList(p);
    qFeatures=dataCache.getFeatureList(q);
    log.info(""String_Node_Str"",p,q);
    matchResult=featureMatcher.deriveMatchResult(pFeatures,qFeatures);
    inlierMatches=matchResult.getInlierMatches();
    if (inlierMatches.getWs().length > 0) {
      if (renderScale != 1.0) {
        scalePoints(inlierMatches.getPs(),renderScale);
        scalePoints(inlierMatches.getQs(),renderScale);
      }
      matchList.add(new CanvasMatches(p.getGroupId(),p.getId(),q.getGroupId(),q.getId(),inlierMatches));
    }
  }
  log.info(""String_Node_Str"",matchList.size(),pairCount,dataCache.stats());
  return matchList.iterator();
}",0.933786078098472
25551,"public void run() throws IOException, URISyntaxException {
  final SparkConf conf=new SparkConf().setAppName(""String_Node_Str"");
  final JavaSparkContext sparkContext=new JavaSparkContext(conf);
  final String sparkAppId=sparkContext.getConf().getAppId();
  final String executorsJson=LogUtilities.getExecutorsApiJson(sparkAppId);
  LOG.info(""String_Node_Str"",sparkAppId,executorsJson);
  final RenderableCanvasIdPairs renderableCanvasIdPairs=RenderableCanvasIdPairsUtilities.load(parameters.pairJson);
  final String renderParametersUrlTemplateForRun=RenderableCanvasIdPairsUtilities.getRenderParametersUrlTemplateForRun(renderableCanvasIdPairs,parameters.baseDataUrl,parameters.renderScale,parameters.renderWithFilter,parameters.renderWithoutMask,false);
  final long cacheMaxKilobytes=parameters.maxFeatureCacheGb * 1000000;
  final CanvasFeatureListLoader featureLoader=new CanvasFeatureListLoader(renderParametersUrlTemplateForRun,getCanvasFeatureExtractor());
  final Broadcast<Long> broadcastCacheMaxKilobytes=sparkContext.broadcast(cacheMaxKilobytes);
  final Broadcast<CanvasFeatureListLoader> broadcastFeatureLoader=sparkContext.broadcast(featureLoader);
  final Broadcast<CanvasFeatureMatcher> broadcastFeatureMatcher=sparkContext.broadcast(getCanvasFeatureMatcher());
  final JavaRDD<OrderedCanvasIdPair> rddCanvasIdPairs=sparkContext.parallelize(renderableCanvasIdPairs.getNeighborPairs());
  final JavaRDD<CanvasMatches> rddMatches=rddCanvasIdPairs.mapPartitionsWithIndex(new Function2<Integer,Iterator<OrderedCanvasIdPair>,Iterator<CanvasMatches>>(){
    @Override public Iterator<CanvasMatches> call(    final Integer partitionIndex,    final Iterator<OrderedCanvasIdPair> pairIterator) throws Exception {
      LogUtilities.setupExecutorLog4j(""String_Node_Str"" + partitionIndex);
      final Logger log=LoggerFactory.getLogger(SIFTPointMatchClient.class);
      final CanvasDataCache dataCache=CanvasDataCache.getSharedCache(broadcastCacheMaxKilobytes.getValue(),broadcastFeatureLoader.getValue());
      final CanvasFeatureMatcher featureMatcher=broadcastFeatureMatcher.getValue();
      final List<CanvasMatches> matchList=new ArrayList<>();
      int pairCount=0;
      OrderedCanvasIdPair pair;
      CanvasId p;
      CanvasId q;
      List<Feature> pFeatures;
      List<Feature> qFeatures;
      CanvasFeatureMatchResult matchResult;
      Matches inlierMatches;
      while (pairIterator.hasNext()) {
        pair=pairIterator.next();
        pairCount++;
        p=pair.getP();
        q=pair.getQ();
        pFeatures=dataCache.getFeatureList(p);
        qFeatures=dataCache.getFeatureList(q);
        log.info(""String_Node_Str"",p,q);
        matchResult=featureMatcher.deriveMatchResult(pFeatures,qFeatures);
        inlierMatches=matchResult.getInlierMatches();
        if (inlierMatches.getWs().length > 0) {
          matchList.add(new CanvasMatches(p.getGroupId(),p.getId(),q.getGroupId(),q.getId(),matchResult.getInlierMatches()));
        }
      }
      log.info(""String_Node_Str"",matchList.size(),pairCount,dataCache.stats());
      return matchList.iterator();
    }
  }
,true);
  final JavaRDD<Integer> rddSavedMatchPairCounts=rddMatches.mapPartitionsWithIndex(new MatchStorageFunction(parameters.baseDataUrl,parameters.owner,parameters.collection),true);
  final int numPartitions=rddSavedMatchPairCounts.getNumPartitions();
  LOG.info(""String_Node_Str"",numPartitions,rddSavedMatchPairCounts.toDebugString());
  final List<Integer> matchPairCountList=rddSavedMatchPairCounts.collect();
  long total=0;
  for (  final Integer matchCount : matchPairCountList) {
    total+=matchCount;
  }
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"",total,matchPairCountList.size());
  sparkContext.stop();
}","public void run() throws IOException, URISyntaxException {
  final SparkConf conf=new SparkConf().setAppName(""String_Node_Str"");
  final JavaSparkContext sparkContext=new JavaSparkContext(conf);
  final String sparkAppId=sparkContext.getConf().getAppId();
  final String executorsJson=LogUtilities.getExecutorsApiJson(sparkAppId);
  LOG.info(""String_Node_Str"",sparkAppId,executorsJson);
  final RenderableCanvasIdPairs renderableCanvasIdPairs=RenderableCanvasIdPairsUtilities.load(parameters.pairJson);
  final String renderParametersUrlTemplateForRun=RenderableCanvasIdPairsUtilities.getRenderParametersUrlTemplateForRun(renderableCanvasIdPairs,parameters.baseDataUrl,parameters.renderScale,parameters.renderWithFilter,parameters.renderWithoutMask,false);
  final long cacheMaxKilobytes=parameters.maxFeatureCacheGb * 1000000;
  final CanvasFeatureListLoader featureLoader=new CanvasFeatureListLoader(renderParametersUrlTemplateForRun,getCanvasFeatureExtractor());
  final double renderScale=parameters.renderScale;
  final Broadcast<Long> broadcastCacheMaxKilobytes=sparkContext.broadcast(cacheMaxKilobytes);
  final Broadcast<CanvasFeatureListLoader> broadcastFeatureLoader=sparkContext.broadcast(featureLoader);
  final Broadcast<CanvasFeatureMatcher> broadcastFeatureMatcher=sparkContext.broadcast(getCanvasFeatureMatcher());
  final JavaRDD<OrderedCanvasIdPair> rddCanvasIdPairs=sparkContext.parallelize(renderableCanvasIdPairs.getNeighborPairs());
  final JavaRDD<CanvasMatches> rddMatches=rddCanvasIdPairs.mapPartitionsWithIndex(new Function2<Integer,Iterator<OrderedCanvasIdPair>,Iterator<CanvasMatches>>(){
    @Override public Iterator<CanvasMatches> call(    final Integer partitionIndex,    final Iterator<OrderedCanvasIdPair> pairIterator) throws Exception {
      LogUtilities.setupExecutorLog4j(""String_Node_Str"" + partitionIndex);
      final Logger log=LoggerFactory.getLogger(SIFTPointMatchClient.class);
      final CanvasDataCache dataCache=CanvasDataCache.getSharedCache(broadcastCacheMaxKilobytes.getValue(),broadcastFeatureLoader.getValue());
      final CanvasFeatureMatcher featureMatcher=broadcastFeatureMatcher.getValue();
      final List<CanvasMatches> matchList=new ArrayList<>();
      int pairCount=0;
      OrderedCanvasIdPair pair;
      CanvasId p;
      CanvasId q;
      List<Feature> pFeatures;
      List<Feature> qFeatures;
      CanvasFeatureMatchResult matchResult;
      Matches inlierMatches;
      while (pairIterator.hasNext()) {
        pair=pairIterator.next();
        pairCount++;
        p=pair.getP();
        q=pair.getQ();
        pFeatures=dataCache.getFeatureList(p);
        qFeatures=dataCache.getFeatureList(q);
        log.info(""String_Node_Str"",p,q);
        matchResult=featureMatcher.deriveMatchResult(pFeatures,qFeatures);
        inlierMatches=matchResult.getInlierMatches();
        if (inlierMatches.getWs().length > 0) {
          if (renderScale != 1.0) {
            scalePoints(inlierMatches.getPs(),renderScale);
            scalePoints(inlierMatches.getQs(),renderScale);
          }
          matchList.add(new CanvasMatches(p.getGroupId(),p.getId(),q.getGroupId(),q.getId(),inlierMatches));
        }
      }
      log.info(""String_Node_Str"",matchList.size(),pairCount,dataCache.stats());
      return matchList.iterator();
    }
  }
,true);
  final JavaRDD<Integer> rddSavedMatchPairCounts=rddMatches.mapPartitionsWithIndex(new MatchStorageFunction(parameters.baseDataUrl,parameters.owner,parameters.collection),true);
  final int numPartitions=rddSavedMatchPairCounts.getNumPartitions();
  LOG.info(""String_Node_Str"",numPartitions,rddSavedMatchPairCounts.toDebugString());
  final List<Integer> matchPairCountList=rddSavedMatchPairCounts.collect();
  long total=0;
  for (  final Integer matchCount : matchPairCountList) {
    total+=matchCount;
  }
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"",total,matchPairCountList.size());
  sparkContext.stop();
}",0.9690507152145644
25552,"@Path(""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=404,message=""String_Node_Str"")}) public RenderParameters getRenderParameters(@PathParam(""String_Node_Str"") final String owner,@PathParam(""String_Node_Str"") final String project,@PathParam(""String_Node_Str"") final String stack,@PathParam(""String_Node_Str"") final String tileId,@QueryParam(""String_Node_Str"") final Double scale,@QueryParam(""String_Node_Str"") final Boolean filter,@QueryParam(""String_Node_Str"") final Boolean binaryMask,@QueryParam(""String_Node_Str"") final Boolean excludeMask){
  LOG.info(""String_Node_Str"",owner,project,stack,tileId,scale,filter,binaryMask);
  RenderParameters parameters=null;
  try {
    final TileSpec tileSpec=getTileSpec(owner,project,stack,tileId,true);
    tileSpec.flattenTransforms();
    final StackId stackId=new StackId(owner,project,stack);
    final StackMetaData stackMetaData=getStackMetaData(stackId);
    parameters=new RenderParameters(null,tileSpec.getMinX(),tileSpec.getMinY(),(int)(tileSpec.getMaxX() - tileSpec.getMinX()),(int)(tileSpec.getMaxY() - tileSpec.getMinY()),scale);
    parameters.setDoFilter(filter);
    parameters.setBinaryMask(binaryMask);
    parameters.setExcludeMask(excludeMask);
    parameters.addTileSpec(tileSpec);
    parameters.setMipmapPathBuilder(stackMetaData.getCurrentMipmapPathBuilder());
  }
 catch (  final Throwable t) {
    RenderServiceUtil.throwServiceException(t);
  }
  return parameters;
}","@Path(""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=404,message=""String_Node_Str"")}) public RenderParameters getRenderParameters(@PathParam(""String_Node_Str"") final String owner,@PathParam(""String_Node_Str"") final String project,@PathParam(""String_Node_Str"") final String stack,@PathParam(""String_Node_Str"") final String tileId,@QueryParam(""String_Node_Str"") final Double scale,@QueryParam(""String_Node_Str"") final Boolean filter,@QueryParam(""String_Node_Str"") final Boolean binaryMask,@QueryParam(""String_Node_Str"") final Boolean excludeMask){
  LOG.info(""String_Node_Str"",owner,project,stack,tileId,scale,filter,binaryMask);
  RenderParameters parameters=null;
  try {
    final TileSpec tileSpec=getTileSpec(owner,project,stack,tileId,true);
    tileSpec.flattenTransforms();
    final StackId stackId=new StackId(owner,project,stack);
    final StackMetaData stackMetaData=getStackMetaData(stackId);
    final int tileWidth=(int)(tileSpec.getMaxX() - tileSpec.getMinX()) + 1;
    final int tileHeight=(int)(tileSpec.getMaxY() - tileSpec.getMinY()) + 1;
    parameters=new RenderParameters(null,tileSpec.getMinX(),tileSpec.getMinY(),tileWidth,tileHeight,scale);
    parameters.setDoFilter(filter);
    parameters.setBinaryMask(binaryMask);
    parameters.setExcludeMask(excludeMask);
    parameters.addTileSpec(tileSpec);
    parameters.setMipmapPathBuilder(stackMetaData.getCurrentMipmapPathBuilder());
  }
 catch (  final Throwable t) {
    RenderServiceUtil.throwServiceException(t);
  }
  return parameters;
}",0.926751592356688
25553,"/** 
 * Constructs an ordered pair.
 * @param oneId      one canvas identifier.
 * @param anotherId  another canvas identifier.
 * @throws IllegalArgumentException if both identifiers are the same.
 */
public OrderedCanvasIdPair(final CanvasId oneId,final CanvasId anotherId) throws IllegalArgumentException {
  final int comparisonResult=oneId.compareTo(anotherId);
  if (comparisonResult < 0) {
    this.p=oneId;
    this.q=anotherId;
  }
 else   if (comparisonResult > 0) {
    this.p=anotherId;
    this.q=oneId;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + oneId + ""String_Node_Str"");
  }
}","/** 
 * Constructs an ordered pair.
 * @param oneId      one canvas identifier.
 * @param anotherId  another canvas identifier.
 * @throws IllegalArgumentException if both identifiers are the same.
 */
public OrderedCanvasIdPair(@Nonnull final CanvasId oneId,@Nonnull final CanvasId anotherId) throws IllegalArgumentException {
  final int comparisonResult=oneId.compareTo(anotherId);
  if (comparisonResult < 0) {
    this.p=oneId;
    this.q=anotherId;
  }
 else   if (comparisonResult > 0) {
    this.p=anotherId;
    this.q=oneId;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + oneId + ""String_Node_Str"");
  }
}",0.9857142857142858
25554,"@Path(""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=404,message=""String_Node_Str"")}) public RenderParameters getRenderParameters(@PathParam(""String_Node_Str"") final String owner,@PathParam(""String_Node_Str"") final String project,@PathParam(""String_Node_Str"") final String stack,@PathParam(""String_Node_Str"") final String tileId,@QueryParam(""String_Node_Str"") final Double scale,@QueryParam(""String_Node_Str"") final Boolean filter,@QueryParam(""String_Node_Str"") final Boolean binaryMask){
  LOG.info(""String_Node_Str"",owner,project,stack,tileId,scale,filter,binaryMask);
  RenderParameters parameters=null;
  try {
    final TileSpec tileSpec=getTileSpec(owner,project,stack,tileId,true);
    tileSpec.flattenTransforms();
    final StackId stackId=new StackId(owner,project,stack);
    final StackMetaData stackMetaData=getStackMetaData(stackId);
    parameters=new RenderParameters(null,tileSpec.getMinX(),tileSpec.getMinY(),tileSpec.getWidth(),tileSpec.getHeight(),scale);
    parameters.setDoFilter(filter);
    parameters.setBinaryMask(binaryMask);
    parameters.addTileSpec(tileSpec);
    parameters.setMipmapPathBuilder(stackMetaData.getCurrentMipmapPathBuilder());
  }
 catch (  final Throwable t) {
    RenderServiceUtil.throwServiceException(t);
  }
  return parameters;
}","@Path(""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=404,message=""String_Node_Str"")}) public RenderParameters getRenderParameters(@PathParam(""String_Node_Str"") final String owner,@PathParam(""String_Node_Str"") final String project,@PathParam(""String_Node_Str"") final String stack,@PathParam(""String_Node_Str"") final String tileId,@QueryParam(""String_Node_Str"") final Double scale,@QueryParam(""String_Node_Str"") final Boolean filter,@QueryParam(""String_Node_Str"") final Boolean binaryMask){
  LOG.info(""String_Node_Str"",owner,project,stack,tileId,scale,filter,binaryMask);
  RenderParameters parameters=null;
  try {
    final TileSpec tileSpec=getTileSpec(owner,project,stack,tileId,true);
    tileSpec.flattenTransforms();
    final StackId stackId=new StackId(owner,project,stack);
    final StackMetaData stackMetaData=getStackMetaData(stackId);
    parameters=new RenderParameters(null,tileSpec.getMinX(),tileSpec.getMinY(),(int)(tileSpec.getMaxX() - tileSpec.getMinX()),(int)(tileSpec.getMaxY() - tileSpec.getMinY()),scale);
    parameters.setDoFilter(filter);
    parameters.setBinaryMask(binaryMask);
    parameters.addTileSpec(tileSpec);
    parameters.setMipmapPathBuilder(stackMetaData.getCurrentMipmapPathBuilder());
  }
 catch (  final Throwable t) {
    RenderServiceUtil.throwServiceException(t);
  }
  return parameters;
}",0.9709078163336838
25555,"private List<TileSpec> getTileSpecsForCoordinates(final List<TileCoordinates> coordinatesList,final ResolvedTileSpecCollection tiles){
  if ((coordinatesList == null) || (coordinatesList.size() == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tileId;
  TileSpec tileSpec;
  final List<TileSpec> tileSpecList=new ArrayList<>();
  for (  final TileCoordinates coordinates : coordinatesList) {
    tileId=coordinates.getTileId();
    if (tileId != null) {
      tileSpec=tiles.getTileSpec(tileId);
      if (tileSpec != null) {
        tileSpecList.add(tileSpec);
      }
    }
  }
  if (tileSpecList.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + z + ""String_Node_Str""+ stack+ ""String_Node_Str""+ coordinatesList.get(0));
  }
  return tileSpecList;
}","private List<TileSpec> getTileSpecsForCoordinates(final List<TileCoordinates> coordinatesList,final ResolvedTileSpecCollection tiles){
  if ((coordinatesList == null) || (coordinatesList.size() == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tileId;
  TileSpec tileSpec;
  final List<TileSpec> tileSpecList=new ArrayList<>();
  for (  final TileCoordinates coordinates : coordinatesList) {
    tileId=coordinates.getTileId();
    if (tileId != null) {
      tileSpec=tiles.getTileSpec(tileId);
      if (tileSpec != null) {
        tileSpecList.add(tileSpec);
      }
    }
  }
  if (tileSpecList.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + z + ""String_Node_Str""+ stack+ ""String_Node_Str""+ Arrays.toString(coordinatesList.get(0).getWorld()));
  }
  return tileSpecList;
}",0.9646341463414634
25556,"/** 
 * @param pointMatchList  list of point matches to convert.
 * @return the specified point match list in {@link Matches} form.
 */
public static Matches convertPointMatchListToMatches(final List<PointMatch> pointMatchList){
  final Matches matches;
  final int pointMatchCount=pointMatchList.size();
  if (pointMatchCount > 0) {
    PointMatch pointMatch=pointMatchList.get(0);
    Point p1=pointMatch.getP1();
    double[] local1=p1.getL();
    final int dimensionCount=local1.length;
    final double p[][]=new double[dimensionCount][pointMatchCount];
    final double q[][]=new double[dimensionCount][pointMatchCount];
    final double w[]=new double[pointMatchCount];
    Point p2;
    double[] local2;
    for (int i=0; i < pointMatchCount; i++) {
      pointMatch=pointMatchList.get(i);
      p1=pointMatch.getP1();
      local1=p1.getL();
      p2=pointMatch.getP2();
      local2=p2.getL();
      for (int j=0; j < dimensionCount; j++) {
        p[j][i]=local1[j];
        q[j][i]=local2[j];
      }
      w[i]=pointMatch.getWeight();
    }
    matches=new Matches(p,q,w);
  }
 else {
    matches=new Matches(new double[0][0],new double[0][0],new double[0]);
  }
  return matches;
}","/** 
 * @param pointMatchList  list of point matches to convert.
 * @return the specified point match list in {@link Matches} form.
 */
public static Matches convertPointMatchListToMatches(final List<PointMatch> pointMatchList){
  final Matches matches;
  final int pointMatchCount=pointMatchList.size();
  if (pointMatchCount > 0) {
    PointMatch pointMatch=pointMatchList.get(0);
    Point p1=pointMatch.getP1();
    double[] local1=p1.getL();
    final int dimensionCount=local1.length;
    final double p[][]=new double[dimensionCount][pointMatchCount];
    final double q[][]=new double[dimensionCount][pointMatchCount];
    final double w[]=new double[pointMatchCount];
    Point p2;
    double[] local2;
    for (int i=0; i < pointMatchCount; i++) {
      pointMatch=pointMatchList.get(i);
      p1=pointMatch.getP1();
      local1=p1.getL();
      p2=pointMatch.getP2();
      local2=p2.getL();
      for (int j=0; j < dimensionCount; j++) {
        p[j][i]=local1[j];
        q[j][i]=local2[j];
      }
      w[i]=pointMatch.getWeight();
    }
    matches=new Matches(p,q,w);
  }
 else {
    matches=new Matches(new double[1][0],new double[1][0],new double[0]);
  }
  return matches;
}",0.985774058577406
25557,"private void setDbCollectionName() throws IllegalArgumentException {
  dbCollectionName=owner + FIELD_SEPARATOR + name;
  if (dbCollectionName.length() > MAX_COLLECTION_NAME_LENGTH) {
    throw new IllegalArgumentException(""String_Node_Str"" + this.dbCollectionName + ""String_Node_Str""+ MAX_COLLECTION_NAME_LENGTH+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}","private void setDbCollectionName() throws IllegalArgumentException {
  dbCollectionName=COLLECTION_NAME_UTIL.getName(owner,name);
}",0.4785276073619632
25558,"public MatchCollectionId(final String owner,final String name) throws IllegalArgumentException {
  validateValue(""String_Node_Str"",VALID_NAME,owner);
  validateValue(""String_Node_Str"",VALID_NAME,name);
  this.owner=owner;
  this.name=name;
  setDbCollectionName();
}","public MatchCollectionId(final String owner,final String name) throws IllegalArgumentException {
  COLLECTION_NAME_UTIL.validateValue(""String_Node_Str"",owner);
  COLLECTION_NAME_UTIL.validateValue(""String_Node_Str"",name);
  this.owner=owner;
  this.name=name;
  setDbCollectionName();
}",0.6956521739130435
25559,"public static MatchCollectionId fromDbCollectionName(final String dbCollectionName) throws IllegalArgumentException {
  final int separatorIndex=dbCollectionName.indexOf(FIELD_SEPARATOR);
  final int nameIndex=separatorIndex + FIELD_SEPARATOR.length();
  if ((separatorIndex < 1) || (dbCollectionName.length() <= nameIndex)) {
    throw new IllegalArgumentException(""String_Node_Str"" + dbCollectionName + ""String_Node_Str"");
  }
  final String owner=dbCollectionName.substring(0,separatorIndex);
  final String name=dbCollectionName.substring(nameIndex);
  return new MatchCollectionId(owner,name);
}","public static MatchCollectionId fromDbCollectionName(final String dbCollectionName) throws IllegalArgumentException {
  final String[] fields=COLLECTION_NAME_UTIL.getFields(dbCollectionName);
  if (fields.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + dbCollectionName + ""String_Node_Str"");
  }
  return new MatchCollectionId(fields[0],fields[1]);
}",0.5122950819672131
25560,"private String getCollectionName(final String suffix){
  return getScopePrefix() + suffix;
}","private String getCollectionName(final String suffix){
  return COLLECTION_NAME_UTIL.getName(owner,project,stack,suffix);
}",0.7162790697674418
25561,"public StackId(final String owner,final String project,final String stack) throws IllegalArgumentException {
  validateValue(""String_Node_Str"",VALID_NAME,owner);
  validateValue(""String_Node_Str"",VALID_NAME,project);
  validateValue(""String_Node_Str"",VALID_NAME,stack);
  setScopePrefix(owner,project,stack);
  this.owner=owner;
  this.project=project;
  this.stack=stack;
}","public StackId(final String owner,final String project,final String stack) throws IllegalArgumentException {
  COLLECTION_NAME_UTIL.validateValue(""String_Node_Str"",owner);
  COLLECTION_NAME_UTIL.validateValue(""String_Node_Str"",project);
  COLLECTION_NAME_UTIL.validateValue(""String_Node_Str"",stack);
  this.owner=owner;
  this.project=project;
  this.stack=stack;
  getTransformCollectionName();
}",0.4539559014267185
25562,"public static List<Color> buildColorList(final int maxLabels){
  if (maxLabels == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final double squareRoot=Math.sqrt(maxLabels);
  final int maxValue=255;
  if (squareRoot > maxValue) {
    throw new IllegalArgumentException(""String_Node_Str"" + maxLabels + ""String_Node_Str"");
  }
  int step=(int)(maxValue / squareRoot);
  if (step > 1) {
    step=step - 1;
  }
  final List<Color> colorList=new ArrayList<>(maxLabels);
  for (int green=0; ((green < maxValue) && (colorList.size() < maxLabels)); green+=step) {
    for (int blue=0; ((blue < maxValue) && (colorList.size() < maxLabels)); blue+=step) {
      if (green != blue) {
        colorList.add(new Color(0,green,blue));
      }
    }
  }
  if (colorList.size() < maxLabels) {
    throw new IllegalStateException(""String_Node_Str"" + maxLabels + ""String_Node_Str"");
  }
  Collections.shuffle(colorList);
  return colorList;
}","public static List<Color> buildColorList(final int maxLabels){
  if (maxLabels == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final double squareRoot=Math.sqrt(maxLabels);
  final int maxValue=255;
  if (squareRoot > maxValue) {
    throw new IllegalArgumentException(""String_Node_Str"" + maxLabels + ""String_Node_Str"");
  }
  int step=(int)(maxValue / squareRoot);
  if (step > 30) {
    step=30;
  }
 else   if (step > 1) {
    step=step - 1;
  }
  final List<Color> colorList=new ArrayList<>(maxLabels);
  for (int green=0; ((green < maxValue) && (colorList.size() < maxLabels)); green+=step) {
    for (int blue=0; ((blue < maxValue) && (colorList.size() < maxLabels)); blue+=step) {
      if (green != blue) {
        colorList.add(new Color(0,green,blue));
      }
    }
  }
  if (colorList.size() < maxLabels) {
    throw new IllegalStateException(""String_Node_Str"" + colorList.size() + ""String_Node_Str""+ maxLabels+ ""String_Node_Str""+ step);
  }
  Collections.shuffle(colorList);
  return colorList;
}",0.9480584972264248
25563,"/** 
 * Constructs a cache instance using the specified parameters.
 * @param maximumNumberOfCachedPixels         the maximum number of pixels to maintain in the cache.This should roughly correlate to the maximum amount of memory for the cache.
 * @param recordStats                         if true, useful tuning stats like cache hits and loads will bemaintained (presumably at some nominal overhead cost); otherwise stats are not maintained.
 * @param cacheOriginalsForDownSampledImages  if true, when down sampled images are requested their sourceimages will also be cached (presumably improving the speed of future down sampling to a different level); otherwise only the down sampled result images are cached.
 * @param width                                standard width for all loaded tiles.
 * @param height                               standard height for all loaded tiles.
 * @param maxLabels                            maximum number of distinct label colors (tiles) needed.
 */
public LabelImageProcessorCache(long maximumNumberOfCachedPixels,boolean recordStats,boolean cacheOriginalsForDownSampledImages,int width,int height,int maxLabels){
  super(maximumNumberOfCachedPixels,recordStats,cacheOriginalsForDownSampledImages);
  this.width=width;
  this.height=height;
  this.labelIndex=-1;
  this.colors=buildColorList(maxLabels);
  this.urlToColor=new HashMap<>((int)(maxLabels * 1.4));
}","/** 
 * Constructs a cache instance using the specified parameters.
 * @param maximumNumberOfCachedPixels         the maximum number of pixels to maintain in the cache.This should roughly correlate to the maximum amount of memory for the cache.
 * @param recordStats                         if true, useful tuning stats like cache hits and loads will bemaintained (presumably at some nominal overhead cost); otherwise stats are not maintained.
 * @param cacheOriginalsForDownSampledImages  if true, when down sampled images are requested their sourceimages will also be cached (presumably improving the speed of future down sampling to a different level); otherwise only the down sampled result images are cached.
 * @param width                                standard width for all loaded tiles.
 * @param height                               standard height for all loaded tiles.
 * @param maxLabels                            maximum number of distinct label colors (tiles) needed.
 */
public LabelImageProcessorCache(final long maximumNumberOfCachedPixels,final boolean recordStats,final boolean cacheOriginalsForDownSampledImages,final int width,final int height,final int maxLabels){
  super(maximumNumberOfCachedPixels,recordStats,cacheOriginalsForDownSampledImages);
  this.width=width;
  this.height=height;
  this.labelIndex=-1;
  this.colors=buildColorList(maxLabels);
  this.urlToColor=new HashMap<>((int)(maxLabels * 1.4));
}",0.9873328641801548
25564,"private BoxMipmapGenerator validateNextLevel(final BoxMipmapGenerator boxMipmapGenerator,final int[][] expectedRowAndColumnPairs) throws Exception {
  final BoxMipmapGenerator nextLevelGenerator=boxMipmapGenerator.generateNextLevel();
  final int level=nextLevelGenerator.getSourceLevel();
  final List<File> missingFiles=new ArrayList<>();
  for (  final int[] rowAndColumn : expectedRowAndColumnPairs) {
    final File file=new File(boxDirectory,level + ""String_Node_Str"" + z+ ""String_Node_Str""+ rowAndColumn[0]+ ""String_Node_Str""+ rowAndColumn[1]+ ""String_Node_Str"");
    filesAndDirectoriesToDelete.add(file);
    if (!file.exists()) {
      missingFiles.add(file);
    }
    filesAndDirectoriesToDelete.add(new File(boxDirectory,level + ""String_Node_Str"" + z+ ""String_Node_Str""+ rowAndColumn[0]));
  }
  filesAndDirectoriesToDelete.add(new File(boxDirectory,level + ""String_Node_Str"" + z));
  filesAndDirectoriesToDelete.add(new File(boxDirectory,String.valueOf(level)));
  Assert.assertTrue(""String_Node_Str"" + level + ""String_Node_Str""+ missingFiles,missingFiles.isEmpty());
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final File overviewFile=new File(overviewDirPath.toFile(),z + ""String_Node_Str"").getAbsoluteFile();
  final boolean isOverviewGenerated=boxMipmapGenerator.generateOverview(overviewWidth,layerBounds,overviewFile);
  filesAndDirectoriesToDelete.add(overviewFile);
  filesAndDirectoriesToDelete.add(overviewFile.getParentFile());
  Assert.assertFalse(""String_Node_Str"" + level,isOverviewGenerated);
  Assert.assertFalse(""String_Node_Str"" + overviewFile + ""String_Node_Str""+ level,overviewFile.exists());
  return nextLevelGenerator;
}","private BoxMipmapGenerator validateNextLevel(final BoxMipmapGenerator boxMipmapGenerator,final int[][] expectedRowAndColumnPairs) throws Exception {
  final BoxMipmapGenerator nextLevelGenerator=boxMipmapGenerator.generateNextLevel();
  final int level=nextLevelGenerator.getSourceLevel();
  final List<File> missingFiles=new ArrayList<>();
  for (  final int[] rowAndColumn : expectedRowAndColumnPairs) {
    final File file=new File(boxDirectory,level + ""String_Node_Str"" + z+ ""String_Node_Str""+ rowAndColumn[0]+ ""String_Node_Str""+ rowAndColumn[1]+ ""String_Node_Str"");
    filesAndDirectoriesToDelete.add(file);
    if (!file.exists()) {
      missingFiles.add(file);
    }
    filesAndDirectoriesToDelete.add(new File(boxDirectory,level + ""String_Node_Str"" + z+ ""String_Node_Str""+ rowAndColumn[0]));
  }
  filesAndDirectoriesToDelete.add(new File(boxDirectory,level + ""String_Node_Str"" + z));
  filesAndDirectoriesToDelete.add(new File(boxDirectory,String.valueOf(level)));
  Assert.assertTrue(""String_Node_Str"" + level + ""String_Node_Str""+ missingFiles,missingFiles.isEmpty());
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final File overviewFile=new File(overviewDirPath.toFile(),z + ""String_Node_Str"").getAbsoluteFile();
  final boolean isOverviewGenerated=boxMipmapGenerator.generateOverview(overviewWidth,stackBounds,overviewFile);
  filesAndDirectoriesToDelete.add(overviewFile);
  filesAndDirectoriesToDelete.add(overviewFile.getParentFile());
  Assert.assertFalse(""String_Node_Str"" + level,isOverviewGenerated);
  Assert.assertFalse(""String_Node_Str"" + overviewFile + ""String_Node_Str""+ level,overviewFile.exists());
  return nextLevelGenerator;
}",0.997067448680352
25565,"@Test public void testMipmapGenerator() throws Exception {
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z,false,Utils.PNG_FORMAT,boxWidth,boxHeight,boxDirectory,0,0,lastRow,0,lastColumn,false);
  for (int row=1; row < 3; row++) {
    for (int column=2; column < 4; column++) {
      boxMipmapGenerator.addSource(row,column,new File(boxDirectory,""String_Node_Str"" + z + ""String_Node_Str""+ row+ ""String_Node_Str""+ column+ ""String_Node_Str""));
    }
  }
  boxMipmapGenerator=validateNextLevel(boxMipmapGenerator,new int[][]{{0,1},{1,1}});
  boxMipmapGenerator=validateNextLevel(boxMipmapGenerator,new int[][]{{0,0}});
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final File overviewFile=new File(overviewDirPath.toFile(),z + ""String_Node_Str"").getAbsoluteFile();
  final boolean isOverviewGenerated=boxMipmapGenerator.generateOverview(overviewWidth,layerBounds,overviewFile);
  filesAndDirectoriesToDelete.add(overviewFile);
  Assert.assertTrue(""String_Node_Str"",isOverviewGenerated);
  Assert.assertNotNull(""String_Node_Str"" + overviewFile + ""String_Node_Str""+ boxMipmapGenerator.getSourceLevel(),overviewFile);
  Assert.assertTrue(""String_Node_Str"" + overviewFile + ""String_Node_Str""+ boxMipmapGenerator.getSourceLevel()+ ""String_Node_Str"",overviewFile.exists());
  filesAndDirectoriesToDelete.add(overviewFile.getParentFile());
}","@Test public void testMipmapGenerator() throws Exception {
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z,false,Utils.PNG_FORMAT,boxWidth,boxHeight,boxDirectory,0,0,lastRow,0,lastColumn,false);
  for (int row=1; row < 3; row++) {
    for (int column=2; column < 4; column++) {
      boxMipmapGenerator.addSource(row,column,new File(boxDirectory,""String_Node_Str"" + z + ""String_Node_Str""+ row+ ""String_Node_Str""+ column+ ""String_Node_Str""));
    }
  }
  boxMipmapGenerator=validateNextLevel(boxMipmapGenerator,new int[][]{{0,1},{1,1}});
  boxMipmapGenerator=validateNextLevel(boxMipmapGenerator,new int[][]{{0,0}});
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final File overviewFile=new File(overviewDirPath.toFile(),z + ""String_Node_Str"").getAbsoluteFile();
  final boolean isOverviewGenerated=boxMipmapGenerator.generateOverview(overviewWidth,stackBounds,overviewFile);
  filesAndDirectoriesToDelete.add(overviewFile);
  Assert.assertTrue(""String_Node_Str"",isOverviewGenerated);
  Assert.assertNotNull(""String_Node_Str"" + overviewFile + ""String_Node_Str""+ boxMipmapGenerator.getSourceLevel(),overviewFile);
  Assert.assertTrue(""String_Node_Str"" + overviewFile + ""String_Node_Str""+ boxMipmapGenerator.getSourceLevel()+ ""String_Node_Str"",overviewFile.exists());
  filesAndDirectoriesToDelete.add(overviewFile.getParentFile());
}",0.996413199426112
25566,"@Before public void setup() throws Exception {
  this.boxDirectory=new File(""String_Node_Str"");
  this.z=11;
  this.boxWidth=148;
  this.boxHeight=148;
  this.lastRow=3;
  this.lastColumn=3;
  this.overviewWidth=80;
  final double layerMaxX=((lastColumn + 1) * boxWidth) - 1;
  final double layerMaxY=((lastRow + 1) * boxHeight) - 1;
  this.layerBounds=new Bounds(0.0,0.0,layerMaxX,layerMaxY);
  filesAndDirectoriesToDelete=new ArrayList<>();
}","@Before public void setup() throws Exception {
  this.boxDirectory=new File(""String_Node_Str"");
  this.z=11;
  this.boxWidth=148;
  this.boxHeight=148;
  this.lastRow=3;
  this.lastColumn=3;
  this.overviewWidth=80;
  final double layerMaxX=((lastColumn + 1) * boxWidth) - 1;
  final double layerMaxY=((lastRow + 1) * boxHeight) - 1;
  this.stackBounds=new Bounds(0.0,0.0,layerMaxX,layerMaxY);
  filesAndDirectoriesToDelete=new ArrayList<>();
}",0.9887387387387389
25567,"public void generateBoxesForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z,boxDirectory,renderDataClient);
  final Bounds layerBounds=renderDataClient.getLayerBounds(stack,z);
  final SectionBoxBounds boxBounds=new SectionBoxBounds(z,boxWidth,boxHeight,layerBounds);
  if (params.renderGroup != null) {
    boxBounds.setRenderGroup(params.renderGroup,params.numberOfRenderGroups,params.maxLevel);
  }
  final List<TileBounds> tileBoundsList=renderDataClient.getTileBounds(stack,z);
  final int tileCount=tileBoundsList.size();
  final TileBounds firstTileBounds=tileBoundsList.get(0);
  final TileSpec firstTileSpec=renderDataClient.getTile(stack,firstTileBounds.getTileId());
  LOG.info(""String_Node_Str"",z,layerBounds,boxBounds,tileCount);
  final ImageProcessorCache imageProcessorCache;
  if (params.label) {
    imageProcessorCache=new LabelImageProcessorCache(ImageProcessorCache.DEFAULT_MAX_CACHED_PIXELS,true,false,firstTileSpec.getWidth(),firstTileSpec.getHeight(),tileCount);
  }
 else {
    imageProcessorCache=new ImageProcessorCache();
  }
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z.intValue(),params.label,format,boxWidth,boxHeight,boxDirectory,0,boxBounds.getFirstRow(),boxBounds.getLastRow(),boxBounds.getFirstColumn(),boxBounds.getLastColumn(),params.forceGeneration);
  final IGridPaths iGridPaths;
  if (params.createIGrid) {
    iGridPaths=new IGridPaths(boxBounds.getNumberOfRows(),boxBounds.getNumberOfColumns());
  }
 else {
    iGridPaths=null;
  }
  generateLevelZero(z,boxBounds,tileCount,imageProcessorCache,boxMipmapGenerator,iGridPaths);
  if (iGridPaths != null) {
    final Path iGridDirectory=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
    iGridPaths.saveToFile(iGridDirectory.toFile(),z,emptyImageFile);
  }
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final String overviewFileName=z.intValue() + ""String_Node_Str"" + format.toLowerCase();
  final File overviewFile=new File(overviewDirPath.toFile(),overviewFileName).getAbsoluteFile();
  boolean isOverviewGenerated=(!params.forceGeneration) && overviewFile.exists();
  if (isOverviewGenerated) {
    LOG.info(""String_Node_Str"",z,overviewFile.getAbsolutePath());
  }
  for (int level=0; level < params.maxLevel; level++) {
    boxMipmapGenerator=boxMipmapGenerator.generateNextLevel();
    if (params.isOverviewNeeded() && (!isOverviewGenerated)) {
      isOverviewGenerated=boxMipmapGenerator.generateOverview(params.overviewWidth,layerBounds,overviewFile);
    }
  }
  LOG.info(""String_Node_Str"",z);
}","public void generateBoxesForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z,boxDirectory,renderDataClient);
  final Bounds layerBounds=renderDataClient.getLayerBounds(stack,z);
  final SectionBoxBounds boxBounds=new SectionBoxBounds(z,boxWidth,boxHeight,layerBounds);
  if (params.renderGroup != null) {
    boxBounds.setRenderGroup(params.renderGroup,params.numberOfRenderGroups,params.maxLevel);
  }
  final List<TileBounds> tileBoundsList=renderDataClient.getTileBounds(stack,z);
  final int tileCount=tileBoundsList.size();
  final TileBounds firstTileBounds=tileBoundsList.get(0);
  final TileSpec firstTileSpec=renderDataClient.getTile(stack,firstTileBounds.getTileId());
  LOG.info(""String_Node_Str"",z,layerBounds,boxBounds,tileCount);
  final ImageProcessorCache imageProcessorCache;
  if (params.label) {
    imageProcessorCache=new LabelImageProcessorCache(ImageProcessorCache.DEFAULT_MAX_CACHED_PIXELS,true,false,firstTileSpec.getWidth(),firstTileSpec.getHeight(),tileCount);
  }
 else {
    imageProcessorCache=new ImageProcessorCache();
  }
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z.intValue(),params.label,format,boxWidth,boxHeight,boxDirectory,0,boxBounds.getFirstRow(),boxBounds.getLastRow(),boxBounds.getFirstColumn(),boxBounds.getLastColumn(),params.forceGeneration);
  final IGridPaths iGridPaths;
  if (params.createIGrid) {
    iGridPaths=new IGridPaths(boxBounds.getNumberOfRows(),boxBounds.getNumberOfColumns());
  }
 else {
    iGridPaths=null;
  }
  generateLevelZero(z,boxBounds,tileCount,imageProcessorCache,boxMipmapGenerator,iGridPaths);
  if (iGridPaths != null) {
    final Path iGridDirectory=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
    iGridPaths.saveToFile(iGridDirectory.toFile(),z,emptyImageFile);
  }
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final String overviewFileName=z.intValue() + ""String_Node_Str"" + format.toLowerCase();
  final File overviewFile=new File(overviewDirPath.toFile(),overviewFileName).getAbsoluteFile();
  boolean isOverviewGenerated=(!params.forceGeneration) && overviewFile.exists();
  if (isOverviewGenerated) {
    LOG.info(""String_Node_Str"",z,overviewFile.getAbsolutePath());
  }
  for (int level=0; level < params.maxLevel; level++) {
    boxMipmapGenerator=boxMipmapGenerator.generateNextLevel();
    if (params.isOverviewNeeded() && (!isOverviewGenerated)) {
      isOverviewGenerated=boxMipmapGenerator.generateOverview(params.overviewWidth,stackBounds,overviewFile);
    }
  }
  LOG.info(""String_Node_Str"",z);
}",0.998086490623804
25568,"public BoxClient(final Parameters params){
  this.params=params;
  this.stack=params.stack;
  this.format=params.format;
  this.boxWidth=params.width;
  this.boxHeight=params.height;
  String boxName=this.boxWidth + ""String_Node_Str"" + this.boxHeight;
  if (params.label) {
    boxName+=""String_Node_Str"";
    this.backgroundRGBColor=Color.WHITE.getRGB();
  }
 else {
    this.backgroundRGBColor=null;
  }
  final Path boxPath=Paths.get(params.rootDirectory,params.project,params.stack,boxName).toAbsolutePath();
  this.boxDirectory=boxPath.toFile();
  final File stackDirectory=this.boxDirectory.getParentFile();
  if (!stackDirectory.exists()) {
    throw new IllegalArgumentException(""String_Node_Str"" + stackDirectory);
  }
  if (!stackDirectory.canWrite()) {
    throw new IllegalArgumentException(""String_Node_Str"" + stackDirectory);
  }
  this.emptyImageFile=new File(boxDirectory.getAbsolutePath(),""String_Node_Str"" + format.toLowerCase());
  if (params.renderGroup != null) {
    if (params.numberOfRenderGroups == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (params.renderGroup < 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (params.renderGroup > params.numberOfRenderGroups) {
      throw new IllegalArgumentException(""String_Node_Str"" + params.numberOfRenderGroups + ""String_Node_Str""+ params.renderGroup+ ""String_Node_Str"");
    }
  }
 else   if (params.numberOfRenderGroups != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.renderDataClient=params.getClient();
}","public BoxClient(final Parameters params) throws IOException {
  this.params=params;
  this.stack=params.stack;
  this.format=params.format;
  this.boxWidth=params.width;
  this.boxHeight=params.height;
  String boxName=this.boxWidth + ""String_Node_Str"" + this.boxHeight;
  if (params.label) {
    boxName+=""String_Node_Str"";
    this.backgroundRGBColor=Color.WHITE.getRGB();
  }
 else {
    this.backgroundRGBColor=null;
  }
  final Path boxPath=Paths.get(params.rootDirectory,params.project,params.stack,boxName).toAbsolutePath();
  this.boxDirectory=boxPath.toFile();
  final File stackDirectory=this.boxDirectory.getParentFile();
  if (!stackDirectory.exists()) {
    throw new IllegalArgumentException(""String_Node_Str"" + stackDirectory);
  }
  if (!stackDirectory.canWrite()) {
    throw new IllegalArgumentException(""String_Node_Str"" + stackDirectory);
  }
  this.emptyImageFile=new File(boxDirectory.getAbsolutePath(),""String_Node_Str"" + format.toLowerCase());
  if (params.renderGroup != null) {
    if (params.numberOfRenderGroups == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (params.renderGroup < 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (params.renderGroup > params.numberOfRenderGroups) {
      throw new IllegalArgumentException(""String_Node_Str"" + params.numberOfRenderGroups + ""String_Node_Str""+ params.renderGroup+ ""String_Node_Str"");
    }
  }
 else   if (params.numberOfRenderGroups != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.renderDataClient=params.getClient();
  final StackMetaData stackMetaData=this.renderDataClient.getStackMetaData(this.stack);
  this.stackBounds=stackMetaData.getStats().getStackBounds();
}",0.9489182692307692
25569,"private void validateValue(final String context,final Pattern pattern,final String value) throws IllegalArgumentException {
  final Matcher m=pattern.matcher(value);
  if (!m.matches()) {
    throw new IllegalArgumentException(""String_Node_Str"" + context + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
}","private void validateValue(final String context,final Pattern pattern,final String value) throws IllegalArgumentException {
  final Matcher m=pattern.matcher(value);
  if (!m.matches()) {
    throw new IllegalArgumentException(""String_Node_Str"" + context + ""String_Node_Str""+ value+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}",0.9418960244648318
25570,"@Test public void testSaveToFile() throws Exception {
  final int numberOfRows=5;
  final int numberOfColumns=6;
  final IGridPaths iGridPaths=new IGridPaths(numberOfRows,numberOfColumns);
  for (int row=2; row < 4; row++) {
    for (int column=1; column < 4; column++) {
      iGridPaths.addImage(new File(""String_Node_Str"" + row + ""String_Node_Str""+ column+ ""String_Node_Str""),row,column);
    }
  }
  final File parentDirectory=new File(""String_Node_Str"").getAbsoluteFile();
  final Double z=(double)new Date().getTime();
  final File emptyFile=new File(""String_Node_Str"");
  file=iGridPaths.saveToFile(parentDirectory,z,emptyFile);
  final List<String> iGridLines=Files.readAllLines(file.toPath(),Charset.defaultCharset());
  final int expectedLineCount=numberOfRows * numberOfColumns + 2;
  Assert.assertEquals(""String_Node_Str"",expectedLineCount,iGridLines.size());
}","@Test public void testSaveToFile() throws Exception {
  final int numberOfRows=5;
  final int numberOfColumns=6;
  final IGridPaths iGridPaths=new IGridPaths(numberOfRows,numberOfColumns);
  for (int row=2; row < 4; row++) {
    for (int column=1; column < 4; column++) {
      iGridPaths.addImage(new File(""String_Node_Str"" + row + ""String_Node_Str""+ column+ ""String_Node_Str""),row,column);
    }
  }
  validateSave(iGridPaths,numberOfRows,numberOfColumns);
}",0.6316579144786196
25571,"/** 
 * Checks if a location is inside a given polygon at the target side or not.
 * @param pm
 * @param t
 * @return
 */
static public boolean isInTargetTriangle(final double[][] pq,final double[] t){
}","/** 
 * Checks whether a location is inside a given triangle at the target side or not.
 * @param pq triangle vertices
 * @param t reference coordinate
 * @return
 */
final static public boolean isInTargetTriangle(final double[][] pq,final double[] t){
}",0.7964989059080962
25572,"/** 
 * Update all affine transformations that would have been affected by a given   {@link PointMatch Vertex}.
 * @param p
 */
public void updateAffines(){
  for (  final Pair<AffineModel2D,double[][]> apq : av) {
    final double[][] p=new double[][]{apq.b[0],apq.b[1]};
    final double[][] q=new double[][]{apq.b[2],apq.b[3]};
    try {
      apq.a.fit(p,q,unitWeights);
    }
 catch (    final NotEnoughDataPointsException e) {
      e.printStackTrace();
    }
catch (    final IllDefinedDataPointsException e) {
      e.printStackTrace();
    }
  }
}","/** 
 * Update all affine transformations.
 */
public void updateAffines(){
  for (  final Pair<AffineModel2D,double[][]> apq : av) {
    final double[][] p=new double[][]{apq.b[0],apq.b[1]};
    final double[][] q=new double[][]{apq.b[2],apq.b[3]};
    try {
      apq.a.fit(p,q,unitWeights);
    }
 catch (    final NotEnoughDataPointsException e) {
      e.printStackTrace();
    }
catch (    final IllDefinedDataPointsException e) {
      e.printStackTrace();
    }
  }
}",0.9194956353055286
25573,"/** 
 * @param pq PointMatches [{p<sub>x</sub>, p<sub>y</sub>, q<sub>x</sub>, q<sub>y</sub><literal>}]
 * @param min x = min[0], y = min[1]
 * @param max x = max[0], y = max[1]
 */
final static public void calculateTargetBoundingBox(final double[][] pq,final double[] min,final double[] max){
  min[0]=pq[2][0];
  min[1]=pq[3][0];
  max[0]=pq[2][0];
  max[1]=pq[3][0];
  for (int i=1; i < pq[0].length; ++i) {
    if (pq[2][i] < min[0])     min[0]=pq[2][i];
 else     if (pq[2][i] > max[0])     max[0]=pq[2][i];
    if (pq[3][i] < min[1])     min[1]=pq[3][i];
 else     if (pq[3][i] > max[1])     max[1]=pq[3][i];
  }
}","/** 
 * @param pq PointMatches [{p<sub>x</sub>, p<sub>y</sub>, q<sub>x</sub>, q<sub>y</sub><literal>}]
 * @param min x = min[0], y = min[1]
 * @param max x = max[0], y = max[1]
 */
final static public void calculateTargetBoundingBox(final double[][] pq,final double[] min,final double[] max){
  calculateBoundingBox(pq[2],pq[3],min,max);
}",0.6325678496868476
25574,"/** 
 * Checks if a location is inside a given polygon at the source side or not.
 * @param pm
 * @param t
 * @return
 */
final static public boolean isInSourceTriangle(final double[][] pq,final double[] t){
}","/** 
 * Checks whether a location is inside a given triangle at the target side or not.
 * @param pq triangle vertices
 * @param t reference coordinate
 * @return
 */
final static public boolean isInSourceTriangle(final double[][] pq,final double[] t){
}",0.7516198704103672
25575,"final static protected void mapTriangle(final Pair<AffineModel2D,double[][]> ai,final ImageProcessor source,final ImageProcessor sourceMask,final ImageProcessor target,final ImageProcessor targetMask,final ByteProcessor targetOutside){
  final int w=target.getWidth() - 1;
  final int h=target.getHeight() - 1;
  final double[][] pq=ai.b;
  final double[] min=new double[2];
  final double[] max=new double[2];
  RenderTransformMesh.calculateTargetBoundingBox(pq,min,max);
  final int minX=Math.max(0,Util.roundPos(min[0]));
  final int minY=Math.max(0,Util.roundPos(min[1]));
  final int maxX=Math.min(w,Util.roundPos(max[0]));
  final int maxY=Math.min(h,Util.roundPos(max[1]));
  final double[] t=new double[2];
  for (int y=minY; y <= maxY; ++y) {
    for (int x=minX; x <= maxX; ++x) {
      if (RenderTransformMesh.isInTargetTriangle(pq,t)) {
        t[0]=x;
        t[1]=y;
        try {
          ai.a.applyInverseInPlace(t);
        }
 catch (        final Exception e) {
          continue;
        }
        target.set(x,y,source.getPixel((int)(t[0] + 0.5f),(int)(t[1] + 0.5f)));
        targetOutside.set(x,y,0xff);
        targetMask.set(x,y,sourceMask.getPixel((int)(t[0] + 0.5f),(int)(t[1] + 0.5f)));
      }
    }
  }
}","final static protected void mapTriangle(final Pair<AffineModel2D,double[][]> ai,final ImageProcessor source,final ImageProcessor sourceMask,final ImageProcessor target,final ImageProcessor targetMask,final ByteProcessor targetOutside){
  final int w=target.getWidth() - 1;
  final int h=target.getHeight() - 1;
  final double[][] pq=ai.b;
  final double[] min=new double[2];
  final double[] max=new double[2];
  RenderTransformMesh.calculateTargetBoundingBox(pq,min,max);
  final int minX=Math.max(0,Util.roundPos(min[0]));
  final int minY=Math.max(0,Util.roundPos(min[1]));
  final int maxX=Math.min(w,Util.roundPos(max[0]));
  final int maxY=Math.min(h,Util.roundPos(max[1]));
  final double[] t=new double[2];
  for (int y=minY; y <= maxY; ++y) {
    for (int x=minX; x <= maxX; ++x) {
      if (RenderTransformMesh.isInTargetTriangle(pq,x,y)) {
        t[0]=x;
        t[1]=y;
        try {
          ai.a.applyInverseInPlace(t);
        }
 catch (        final Exception e) {
          continue;
        }
        target.set(x,y,source.getPixel((int)(t[0] + 0.5f),(int)(t[1] + 0.5f)));
        targetOutside.set(x,y,0xff);
        targetMask.set(x,y,sourceMask.getPixel((int)(t[0] + 0.5f),(int)(t[1] + 0.5f)));
      }
    }
  }
}",0.9983818770226536
25576,"final static protected void mapTriangleInterpolated(final Pair<AffineModel2D,double[][]> ai,final ImageProcessor source,final ImageProcessor sourceMask,final ImageProcessor target,final ImageProcessor targetMask,final ByteProcessor targetOutside){
  final int w=target.getWidth() - 1;
  final int h=target.getHeight() - 1;
  final double[][] pq=ai.b;
  final double[] min=new double[2];
  final double[] max=new double[2];
  RenderTransformMesh.calculateTargetBoundingBox(pq,min,max);
  final int minX=Math.max(0,Util.roundPos(min[0]));
  final int minY=Math.max(0,Util.roundPos(min[1]));
  final int maxX=Math.min(w,Util.roundPos(max[0]));
  final int maxY=Math.min(h,Util.roundPos(max[1]));
  final double[] t=new double[2];
  for (int y=minY; y <= maxY; ++y) {
    for (int x=minX; x <= maxX; ++x) {
      if (RenderTransformMesh.isInTargetTriangle(pq,t)) {
        t[0]=x;
        t[1]=y;
        try {
          ai.a.applyInverseInPlace(t);
        }
 catch (        final Exception e) {
          continue;
        }
        target.set(x,y,source.getPixelInterpolated(t[0],t[1]));
        targetOutside.set(x,y,0xff);
        targetMask.set(x,y,sourceMask.getPixelInterpolated(t[0],t[1]));
      }
    }
  }
}","final static protected void mapTriangleInterpolated(final Pair<AffineModel2D,double[][]> ai,final ImageProcessor source,final ImageProcessor sourceMask,final ImageProcessor target,final ImageProcessor targetMask,final ByteProcessor targetOutside){
  final int w=target.getWidth() - 1;
  final int h=target.getHeight() - 1;
  final double[][] pq=ai.b;
  final double[] min=new double[2];
  final double[] max=new double[2];
  RenderTransformMesh.calculateTargetBoundingBox(pq,min,max);
  final int minX=Math.max(0,Util.roundPos(min[0]));
  final int minY=Math.max(0,Util.roundPos(min[1]));
  final int maxX=Math.min(w,Util.roundPos(max[0]));
  final int maxY=Math.min(h,Util.roundPos(max[1]));
  final double[] t=new double[2];
  for (int y=minY; y <= maxY; ++y) {
    for (int x=minX; x <= maxX; ++x) {
      if (RenderTransformMesh.isInTargetTriangle(pq,x,y)) {
        t[0]=x;
        t[1]=y;
        try {
          ai.a.applyInverseInPlace(t);
        }
 catch (        final Exception e) {
          continue;
        }
        target.set(x,y,source.getPixelInterpolated(t[0],t[1]));
        targetOutside.set(x,y,0xff);
        targetMask.set(x,y,sourceMask.getPixelInterpolated(t[0],t[1]));
      }
    }
  }
}",0.9983552631578948
25577,"final static protected void mapShortAlphaTriangle(final Pair<AffineModel2D,double[][]> ai,final ShortProcessor source,final ByteProcessor alpha,final ShortProcessor target){
  final int w=target.getWidth() - 1;
  final int h=target.getHeight() - 1;
  final double[][] pq=ai.b;
  final double[] min=new double[2];
  final double[] max=new double[2];
  RenderTransformMesh.calculateTargetBoundingBox(pq,min,max);
  final int minX=Math.max(0,Util.roundPos(min[0]));
  final int minY=Math.max(0,Util.roundPos(min[1]));
  final int maxX=Math.min(w,Util.roundPos(max[0]));
  final int maxY=Math.min(h,Util.roundPos(max[1]));
  final double[] t=new double[2];
  for (int y=minY; y <= maxY; ++y) {
    for (int x=minX; x <= maxX; ++x) {
      if (RenderTransformMesh.isInTargetTriangle(pq,t)) {
        t[0]=x;
        t[1]=y;
        try {
          ai.a.applyInverseInPlace(t);
        }
 catch (        final Exception e) {
          continue;
        }
        final int is=source.getPixelInterpolated(t[0],t[1]);
        final int it=target.get(x,y);
        final double f=alpha.getPixelInterpolated(t[0],t[1]) / 255.0;
        final double v=it + f * (is - it);
        target.set(x,y,(int)Math.max(0,Math.min(65535,Math.round(v))));
      }
    }
  }
}","final static protected void mapShortAlphaTriangle(final Pair<AffineModel2D,double[][]> ai,final ShortProcessor source,final ByteProcessor alpha,final ShortProcessor target){
  final int w=target.getWidth() - 1;
  final int h=target.getHeight() - 1;
  final double[][] pq=ai.b;
  final double[] min=new double[2];
  final double[] max=new double[2];
  RenderTransformMesh.calculateTargetBoundingBox(pq,min,max);
  final int minX=Math.max(0,Util.roundPos(min[0]));
  final int minY=Math.max(0,Util.roundPos(min[1]));
  final int maxX=Math.min(w,Util.roundPos(max[0]));
  final int maxY=Math.min(h,Util.roundPos(max[1]));
  final double[] t=new double[2];
  for (int y=minY; y <= maxY; ++y) {
    for (int x=minX; x <= maxX; ++x) {
      if (RenderTransformMesh.isInTargetTriangle(pq,x,y)) {
        t[0]=x;
        t[1]=y;
        try {
          ai.a.applyInverseInPlace(t);
        }
 catch (        final Exception e) {
          continue;
        }
        final int is=source.getPixelInterpolated(t[0],t[1]);
        final int it=target.get(x,y);
        final double f=alpha.getPixelInterpolated(t[0],t[1]) / 255.0;
        final double v=it + f * (is - it);
        target.set(x,y,(int)Math.max(0,Math.min(65535,Math.round(v))));
      }
    }
  }
}",0.9984038308060654
25578,"@BeforeClass public static void before() throws Exception {
  stackId=new StackId(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  embeddedMongoDb=new EmbeddedMongoDb(RenderDao.RENDER_DB_NAME);
  dao=new RenderDao(embeddedMongoDb.getMongoClient());
  embeddedMongoDb.importCollection(RenderDao.STACK_META_DATA_COLLECTION_NAME,new File(""String_Node_Str""),true,false,true);
  embeddedMongoDb.importCollection(stackId.getTileCollectionName(),new File(""String_Node_Str""),true,false,true);
  embeddedMongoDb.importCollection(stackId.getTransformCollectionName(),new File(""String_Node_Str""),true,false,true);
}","@BeforeClass public static void before() throws Exception {
  stackId=new StackId(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  embeddedMongoDb=new EmbeddedMongoDb(RenderDao.RENDER_DB_NAME);
  dao=new RenderDao(embeddedMongoDb.getMongoClient());
}",0.5940366972477065
25579,"private void cloneCollection(final DBCollection fromCollection,final DBCollection toCollection) throws IllegalArgumentException {
  LOG.debug(""String_Node_Str"",fromCollection.count(),fromCollection.getFullName(),toCollection.getFullName());
  final ProcessTimer timer=new ProcessTimer(15000);
  final int maxDocumentsPerBulkInsert=10000;
  long count=0;
  final DBObject query=new BasicDBObject();
  BulkWriteOperation bulk=toCollection.initializeUnorderedBulkOperation();
  try (DBCursor cursor=fromCollection.find(query)){
    DBObject document;
    while (cursor.hasNext()) {
      document=cursor.next();
      count++;
      if (count % maxDocumentsPerBulkInsert == 0) {
        bulk.execute();
        bulk=toCollection.initializeUnorderedBulkOperation();
        if (timer.hasIntervalPassed()) {
          LOG.debug(""String_Node_Str"",count);
        }
      }
 else {
        bulk.insert(document);
      }
    }
    if (count % maxDocumentsPerBulkInsert > 0) {
      bulk.execute();
    }
  }
   LOG.debug(""String_Node_Str"",count,fromCollection.getFullName(),toCollection.getFullName());
}","private void cloneCollection(final DBCollection fromCollection,final DBCollection toCollection) throws IllegalStateException {
  final long fromCount=fromCollection.count();
  long toCount;
  final String fromFullName=fromCollection.getFullName();
  final String toFullName=toCollection.getFullName();
  LOG.debug(""String_Node_Str"",fromCount,fromFullName,toFullName);
  final ProcessTimer timer=new ProcessTimer(15000);
  final int maxDocumentsPerBulkInsert=10000;
  long count=0;
  final DBObject query=new BasicDBObject();
  BulkWriteOperation bulk=toCollection.initializeOrderedBulkOperation();
  try (DBCursor cursor=fromCollection.find(query)){
    BulkWriteResult result;
    long insertedCount;
    DBObject document;
    while (cursor.hasNext()) {
      document=cursor.next();
      bulk.insert(document);
      count++;
      if (count % maxDocumentsPerBulkInsert == 0) {
        result=bulk.execute(WriteConcern.ACKNOWLEDGED);
        insertedCount=result.getInsertedCount();
        if (insertedCount != maxDocumentsPerBulkInsert) {
          throw new IllegalStateException(""String_Node_Str"" + insertedCount + ""String_Node_Str""+ maxDocumentsPerBulkInsert+ ""String_Node_Str""+ count);
        }
        bulk=toCollection.initializeOrderedBulkOperation();
        if (timer.hasIntervalPassed()) {
          LOG.debug(""String_Node_Str"",count);
        }
      }
    }
    if (count % maxDocumentsPerBulkInsert > 0) {
      result=bulk.execute(WriteConcern.ACKNOWLEDGED);
      insertedCount=result.getInsertedCount();
      final long expectedCount=count % maxDocumentsPerBulkInsert;
      if (insertedCount != expectedCount) {
        throw new IllegalStateException(""String_Node_Str"" + insertedCount + ""String_Node_Str""+ expectedCount+ ""String_Node_Str""+ count);
      }
    }
    toCount=toCollection.count();
    if (toCount != fromCount) {
      throw new IllegalStateException(""String_Node_Str"" + toCount + ""String_Node_Str""+ fromCount+ ""String_Node_Str"");
    }
  }
   LOG.debug(""String_Node_Str"",toCount,fromFullName,toFullName);
}",0.5971383147853736
25580,"public void cloneStack(final StackId fromStackId,final StackId toStackId) throws IllegalArgumentException {
  validateRequiredParameter(""String_Node_Str"",fromStackId);
  validateRequiredParameter(""String_Node_Str"",toStackId);
  final DBCollection fromTransformCollection=getTransformCollection(fromStackId);
  final DBCollection toTransformCollection=getTransformCollection(toStackId);
  cloneCollection(fromTransformCollection,toTransformCollection);
  final DBCollection fromTileCollection=getTileCollection(fromStackId);
  final DBCollection toTileCollection=getTileCollection(toStackId);
  cloneCollection(fromTileCollection,toTileCollection);
}","public void cloneStack(final StackId fromStackId,final StackId toStackId) throws IllegalArgumentException, IllegalStateException {
  validateRequiredParameter(""String_Node_Str"",fromStackId);
  validateRequiredParameter(""String_Node_Str"",toStackId);
  final DBCollection fromTransformCollection=getTransformCollection(fromStackId);
  final DBCollection toTransformCollection=getTransformCollection(toStackId);
  cloneCollection(fromTransformCollection,toTransformCollection);
  final DBCollection fromTileCollection=getTileCollection(fromStackId);
  final DBCollection toTileCollection=getTileCollection(toStackId);
  cloneCollection(fromTileCollection,toTileCollection);
}",0.9825889477668432
25581,"private void resolveTileSpecs() throws IllegalStateException {
  for (  TileSpec tileSpec : tileIdToSpecMap.values()) {
    resolveTileSpec(tileSpec);
  }
}","public void resolveTileSpecs() throws IllegalStateException {
  for (  TileSpec tileSpec : tileIdToSpecMap.values()) {
    resolveTileSpec(tileSpec);
  }
}",0.9710610932475884
25582,"public List<List<TileCoordinates>> worldToLocal(final List<List<TileCoordinates>> worldListOfLists) throws IOException {
  LOG.info(""String_Node_Str"",worldListOfLists.size());
  final ResolvedTileSpecCollection tiles=renderDataClient.getResolvedTiles(stack,z);
  final ProcessTimer timer=new ProcessTimer();
  final List<List<TileCoordinates>> localListOfLists=new ArrayList<>(worldListOfLists.size());
  List<TileSpec> tileSpecList;
  List<TileCoordinates> coordinatesList;
  TileCoordinates coordinates=null;
  double[] world;
  int errorCount=0;
  for (int i=0; i < worldListOfLists.size(); i++) {
    coordinatesList=worldListOfLists.get(i);
    try {
      tileSpecList=getTileSpecsForCoordinates(coordinatesList,tiles);
      coordinates=coordinatesList.get(0);
      world=coordinates.getWorld();
      if (world == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (world.length < 2) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      localListOfLists.add(TileCoordinates.getLocalCoordinates(tileSpecList,world[0],world[1]));
    }
 catch (    final Throwable t) {
      LOG.warn(""String_Node_Str"",i,t);
      errorCount++;
      if (coordinates == null) {
        coordinates=TileCoordinates.buildWorldInstance(null,null);
      }
      coordinates.setError(t.getMessage());
      localListOfLists.add(Arrays.asList(coordinates));
    }
    if (timer.hasIntervalPassed()) {
      LOG.info(""String_Node_Str"",localListOfLists.size(),worldListOfLists.size());
    }
  }
  LOG.info(""String_Node_Str"",localListOfLists.size(),errorCount,timer.getElapsedSeconds());
  return localListOfLists;
}","public List<List<TileCoordinates>> worldToLocal(final List<List<TileCoordinates>> worldListOfLists,final ResolvedTileSpecCollection tiles) throws IOException {
  LOG.info(""String_Node_Str"",worldListOfLists.size());
  final ProcessTimer timer=new ProcessTimer();
  final List<List<TileCoordinates>> localListOfLists=new ArrayList<>(worldListOfLists.size());
  List<TileSpec> tileSpecList;
  List<TileCoordinates> coordinatesList;
  TileCoordinates coordinates=null;
  double[] world;
  int errorCount=0;
  for (int i=0; i < worldListOfLists.size(); i++) {
    coordinatesList=worldListOfLists.get(i);
    try {
      tileSpecList=getTileSpecsForCoordinates(coordinatesList,tiles);
      coordinates=coordinatesList.get(0);
      world=coordinates.getWorld();
      if (world == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (world.length < 2) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      localListOfLists.add(TileCoordinates.getLocalCoordinates(tileSpecList,world[0],world[1]));
    }
 catch (    final Throwable t) {
      LOG.warn(""String_Node_Str"",i,t);
      errorCount++;
      if (coordinates == null) {
        coordinates=TileCoordinates.buildWorldInstance(null,null);
      }
      coordinates.setError(t.getMessage());
      localListOfLists.add(Arrays.asList(coordinates));
    }
    if (timer.hasIntervalPassed()) {
      LOG.info(""String_Node_Str"",localListOfLists.size(),worldListOfLists.size());
    }
  }
  LOG.info(""String_Node_Str"",localListOfLists.size(),errorCount,timer.getElapsedSeconds());
  return localListOfLists;
}",0.9623100303951369
25583,"public List<TileCoordinates> localToWorld(final List<TileCoordinates> localCoordinatesList) throws IOException {
  LOG.info(""String_Node_Str"",localCoordinatesList.size());
  final ResolvedTileSpecCollection tiles=renderDataClient.getResolvedTiles(stack,z);
  final ProcessTimer timer=new ProcessTimer();
  final List<TileCoordinates> worldCoordinatesList=new ArrayList<>(localCoordinatesList.size());
  TileSpec tileSpec;
  TileCoordinates coordinates;
  String tileId;
  double[] local;
  int errorCount=0;
  for (int i=0; i < localCoordinatesList.size(); i++) {
    coordinates=localCoordinatesList.get(i);
    try {
      if (coordinates == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      tileId=coordinates.getTileId();
      if (tileId == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      local=coordinates.getLocal();
      if (local == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (local.length < 2) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      tileSpec=tiles.getTileSpec(tileId);
      if (tileSpec == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + tileId + ""String_Node_Str""+ z+ ""String_Node_Str""+ stack);
      }
      worldCoordinatesList.add(TileCoordinates.getWorldCoordinates(tileSpec,local[0],local[1]));
    }
 catch (    final Throwable t) {
      LOG.warn(""String_Node_Str"",i,t);
      errorCount++;
      if (coordinates == null) {
        coordinates=TileCoordinates.buildLocalInstance(null,null);
      }
      coordinates.setError(t.getMessage());
      worldCoordinatesList.add(coordinates);
    }
    if (timer.hasIntervalPassed()) {
      LOG.info(""String_Node_Str"",worldCoordinatesList.size(),localCoordinatesList.size());
    }
  }
  LOG.info(""String_Node_Str"",worldCoordinatesList.size(),errorCount,timer.getElapsedSeconds());
  return worldCoordinatesList;
}","public List<TileCoordinates> localToWorld(final List<TileCoordinates> localCoordinatesList,final ResolvedTileSpecCollection tiles) throws IOException {
  LOG.info(""String_Node_Str"",localCoordinatesList.size());
  final ProcessTimer timer=new ProcessTimer();
  final List<TileCoordinates> worldCoordinatesList=new ArrayList<>(localCoordinatesList.size());
  TileSpec tileSpec;
  TileCoordinates coordinates;
  String tileId;
  double[] local;
  int errorCount=0;
  for (int i=0; i < localCoordinatesList.size(); i++) {
    coordinates=localCoordinatesList.get(i);
    try {
      if (coordinates == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      tileId=coordinates.getTileId();
      if (tileId == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      local=coordinates.getLocal();
      if (local == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (local.length < 2) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      tileSpec=tiles.getTileSpec(tileId);
      if (tileSpec == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + tileId + ""String_Node_Str""+ z+ ""String_Node_Str""+ stack);
      }
      worldCoordinatesList.add(TileCoordinates.getWorldCoordinates(tileSpec,local[0],local[1]));
    }
 catch (    final Throwable t) {
      LOG.warn(""String_Node_Str"",i,t);
      errorCount++;
      if (coordinates == null) {
        coordinates=TileCoordinates.buildLocalInstance(null,null);
      }
      coordinates.setError(t.getMessage());
      worldCoordinatesList.add(coordinates);
    }
    if (timer.hasIntervalPassed()) {
      LOG.info(""String_Node_Str"",worldCoordinatesList.size(),localCoordinatesList.size());
    }
  }
  LOG.info(""String_Node_Str"",worldCoordinatesList.size(),errorCount,timer.getElapsedSeconds());
  return worldCoordinatesList;
}",0.968090581574884
25584,"public void generateBoxesForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z,boxDirectory,renderDataClient);
  final Bounds layerBounds=renderDataClient.getLayerBounds(stack,z);
  final BoxBounds boxBounds=new BoxBounds(z,layerBounds);
  final List<TileBounds> tileBoundsList=renderDataClient.getTileBounds(stack,z);
  final int tileCount=tileBoundsList.size();
  final TileBounds firstTileBounds=tileBoundsList.get(0);
  final TileSpec firstTileSpec=renderDataClient.getTile(stack,firstTileBounds.getTileId());
  LOG.info(""String_Node_Str"",z,layerBounds,boxBounds,tileCount);
  final ImageProcessorCache imageProcessorCache;
  if (params.label) {
    imageProcessorCache=new LabelImageProcessorCache(ImageProcessorCache.DEFAULT_MAX_CACHED_PIXELS,true,false,firstTileSpec.getWidth(),firstTileSpec.getHeight(),tileCount);
  }
 else {
    imageProcessorCache=new ImageProcessorCache();
  }
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z.intValue(),params.label,format,boxWidth,boxHeight,boxDirectory,0,boxBounds.lastRow,boxBounds.lastColumn,params.forceGeneration);
  final IGridPaths iGridPaths;
  if (params.createIGrid) {
    iGridPaths=new IGridPaths(boxBounds.lastRow,boxBounds.lastColumn);
  }
 else {
    iGridPaths=null;
  }
  generateLevelZero(z,layerBounds,boxBounds,tileCount,imageProcessorCache,boxMipmapGenerator,iGridPaths);
  if (iGridPaths != null) {
    final Path iGridDirectory=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
    iGridPaths.saveToFile(iGridDirectory.toFile(),z,emptyImageFile);
  }
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final File overviewFile=new File(overviewDirPath.toFile(),z + ""String_Node_Str"" + format.toLowerCase()).getAbsoluteFile();
  boolean isOverviewGenerated=(!params.forceGeneration) && overviewFile.exists();
  for (int level=0; level < params.maxLevel; level++) {
    boxMipmapGenerator=boxMipmapGenerator.generateNextLevel();
    if (params.isOverviewNeeded() && (!isOverviewGenerated)) {
      isOverviewGenerated=boxMipmapGenerator.generateOverview(params.overviewWidth,layerBounds,overviewFile);
    }
  }
  LOG.info(""String_Node_Str"",z);
}","public void generateBoxesForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z,boxDirectory,renderDataClient);
  final Bounds layerBounds=renderDataClient.getLayerBounds(stack,z);
  final BoxBounds boxBounds=new BoxBounds(z,layerBounds);
  final List<TileBounds> tileBoundsList=renderDataClient.getTileBounds(stack,z);
  final int tileCount=tileBoundsList.size();
  final TileBounds firstTileBounds=tileBoundsList.get(0);
  final TileSpec firstTileSpec=renderDataClient.getTile(stack,firstTileBounds.getTileId());
  LOG.info(""String_Node_Str"",z,layerBounds,boxBounds,tileCount);
  final ImageProcessorCache imageProcessorCache;
  if (params.label) {
    imageProcessorCache=new LabelImageProcessorCache(ImageProcessorCache.DEFAULT_MAX_CACHED_PIXELS,true,false,firstTileSpec.getWidth(),firstTileSpec.getHeight(),tileCount);
  }
 else {
    imageProcessorCache=new ImageProcessorCache();
  }
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z.intValue(),params.label,format,boxWidth,boxHeight,boxDirectory,0,boxBounds.lastRow,boxBounds.lastColumn,params.forceGeneration);
  final IGridPaths iGridPaths;
  if (params.createIGrid) {
    iGridPaths=new IGridPaths(boxBounds.lastRow,boxBounds.lastColumn);
  }
 else {
    iGridPaths=null;
  }
  generateLevelZero(z,layerBounds,boxBounds,tileCount,imageProcessorCache,boxMipmapGenerator,iGridPaths);
  if (iGridPaths != null) {
    final Path iGridDirectory=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
    iGridPaths.saveToFile(iGridDirectory.toFile(),z,emptyImageFile);
  }
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final String overviewFileName=z.intValue() + ""String_Node_Str"" + format.toLowerCase();
  final File overviewFile=new File(overviewDirPath.toFile(),overviewFileName).getAbsoluteFile();
  boolean isOverviewGenerated=(!params.forceGeneration) && overviewFile.exists();
  for (int level=0; level < params.maxLevel; level++) {
    boxMipmapGenerator=boxMipmapGenerator.generateNextLevel();
    if (params.isOverviewNeeded() && (!isOverviewGenerated)) {
      isOverviewGenerated=boxMipmapGenerator.generateOverview(params.overviewWidth,layerBounds,overviewFile);
    }
  }
  LOG.info(""String_Node_Str"",z);
}",0.7781979977753058
25585,"public void generateBoxesForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z,boxDirectory,renderDataClient);
  final Bounds layerBounds=renderDataClient.getLayerBounds(stack,z);
  final BoxBounds boxBounds=new BoxBounds(z,layerBounds);
  final List<TileBounds> tileBoundsList=renderDataClient.getTileBounds(stack,z);
  final int tileCount=tileBoundsList.size();
  final TileBounds firstTileBounds=tileBoundsList.get(0);
  final TileSpec firstTileSpec=renderDataClient.getTile(stack,firstTileBounds.getTileId());
  LOG.info(""String_Node_Str"",z,layerBounds,boxBounds,tileCount);
  final ImageProcessorCache imageProcessorCache;
  if (params.label) {
    imageProcessorCache=new LabelImageProcessorCache(ImageProcessorCache.DEFAULT_MAX_CACHED_PIXELS,true,false,firstTileSpec.getWidth(),firstTileSpec.getHeight(),tileCount);
  }
 else {
    imageProcessorCache=new ImageProcessorCache();
  }
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z.intValue(),params.label,format,boxWidth,boxHeight,boxDirectory,0,boxBounds.lastRow,boxBounds.lastColumn,params.forceGeneration);
  final IGridPaths iGridPaths;
  if (params.createIGrid) {
    iGridPaths=new IGridPaths(boxBounds.lastRow,boxBounds.lastColumn);
  }
 else {
    iGridPaths=null;
  }
  generateLevelZero(z,layerBounds,boxBounds,tileCount,imageProcessorCache,boxMipmapGenerator,iGridPaths);
  if (iGridPaths != null) {
    final Path iGridDirectory=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
    iGridPaths.saveToFile(iGridDirectory.toFile(),z,emptyImageFile);
  }
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final String overviewFileName=z.intValue() + ""String_Node_Str"" + format.toLowerCase();
  final File overviewFile=new File(overviewDirPath.toFile(),overviewFileName).getAbsoluteFile();
  boolean isOverviewGenerated=(!params.forceGeneration) && overviewFile.exists();
  for (int level=0; level < params.maxLevel; level++) {
    boxMipmapGenerator=boxMipmapGenerator.generateNextLevel();
    if (params.isOverviewNeeded() && (!isOverviewGenerated)) {
      isOverviewGenerated=boxMipmapGenerator.generateOverview(params.overviewWidth,layerBounds,overviewFile);
    }
  }
  LOG.info(""String_Node_Str"",z);
}","public void generateBoxesForZ(final Double z) throws Exception {
  LOG.info(""String_Node_Str"",z,boxDirectory,renderDataClient);
  final Bounds layerBounds=renderDataClient.getLayerBounds(stack,z);
  final BoxBounds boxBounds=new BoxBounds(z,layerBounds);
  final List<TileBounds> tileBoundsList=renderDataClient.getTileBounds(stack,z);
  final int tileCount=tileBoundsList.size();
  final TileBounds firstTileBounds=tileBoundsList.get(0);
  final TileSpec firstTileSpec=renderDataClient.getTile(stack,firstTileBounds.getTileId());
  LOG.info(""String_Node_Str"",z,layerBounds,boxBounds,tileCount);
  final ImageProcessorCache imageProcessorCache;
  if (params.label) {
    imageProcessorCache=new LabelImageProcessorCache(ImageProcessorCache.DEFAULT_MAX_CACHED_PIXELS,true,false,firstTileSpec.getWidth(),firstTileSpec.getHeight(),tileCount);
  }
 else {
    imageProcessorCache=new ImageProcessorCache();
  }
  BoxMipmapGenerator boxMipmapGenerator=new BoxMipmapGenerator(z.intValue(),params.label,format,boxWidth,boxHeight,boxDirectory,0,boxBounds.lastRow,boxBounds.lastColumn,params.forceGeneration);
  final IGridPaths iGridPaths;
  if (params.createIGrid) {
    iGridPaths=new IGridPaths(boxBounds.lastRow,boxBounds.lastColumn);
  }
 else {
    iGridPaths=null;
  }
  generateLevelZero(z,layerBounds,boxBounds,tileCount,imageProcessorCache,boxMipmapGenerator,iGridPaths);
  if (iGridPaths != null) {
    final Path iGridDirectory=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
    iGridPaths.saveToFile(iGridDirectory.toFile(),z,emptyImageFile);
  }
  final Path overviewDirPath=Paths.get(boxDirectory.getAbsolutePath(),""String_Node_Str"");
  final String overviewFileName=z.intValue() + ""String_Node_Str"" + format.toLowerCase();
  final File overviewFile=new File(overviewDirPath.toFile(),overviewFileName).getAbsoluteFile();
  boolean isOverviewGenerated=(!params.forceGeneration) && overviewFile.exists();
  if (isOverviewGenerated) {
    LOG.info(""String_Node_Str"",z,overviewFile.getAbsolutePath());
  }
  for (int level=0; level < params.maxLevel; level++) {
    boxMipmapGenerator=boxMipmapGenerator.generateNextLevel();
    if (params.isOverviewNeeded() && (!isOverviewGenerated)) {
      isOverviewGenerated=boxMipmapGenerator.generateOverview(params.overviewWidth,layerBounds,overviewFile);
    }
  }
  LOG.info(""String_Node_Str"",z);
}",0.9787325456498388
25586,"private void generateLevelZero(final Double z,final Bounds layerBounds,final BoxBounds boxBounds,final int tileCount,final ImageProcessorCache imageProcessorCache,final BoxMipmapGenerator boxMipmapGenerator,final IGridPaths iGridPaths) throws URISyntaxException, IOException {
  final Progress progress=new Progress(tileCount);
  RenderParameters renderParameters;
  String parametersUrl;
  BufferedImage levelZeroImage;
  File levelZeroFile;
  int row=boxBounds.firstRow;
  int column;
  for (int y=boxBounds.firstY; y < layerBounds.getMaxY(); y+=boxHeight) {
    column=boxBounds.firstColumn;
    for (int x=boxBounds.firstX; x < layerBounds.getMaxX(); x+=boxWidth) {
      levelZeroFile=BoxMipmapGenerator.getImageFile(format,boxDirectory,0,boxBounds.z,row,column);
      if (params.forceGeneration || (!levelZeroFile.exists())) {
        parametersUrl=renderDataClient.getRenderParametersUrlString(stack,x,y,z,boxWidth,boxHeight,1.0);
        LOG.info(""String_Node_Str"",z,parametersUrl);
        renderParameters=RenderParameters.loadFromUrl(parametersUrl);
        renderParameters.setSkipInterpolation(params.skipInterpolation);
        renderParameters.setBackgroundRGBColor(backgroundRGBColor);
        if (renderParameters.hasTileSpecs()) {
          levelZeroImage=renderParameters.openTargetImage();
          Render.render(renderParameters,levelZeroImage,imageProcessorCache);
          BoxMipmapGenerator.saveImage(levelZeroImage,levelZeroFile,params.label,format);
        }
 else {
          LOG.info(""String_Node_Str"",z,row,column);
        }
        boxMipmapGenerator.addSource(row,column,levelZeroFile);
        if (iGridPaths != null) {
          iGridPaths.addImage(levelZeroFile,row,column);
        }
        progress.markProcessedTilesForRow(y,renderParameters);
      }
 else {
        LOG.info(""String_Node_Str"",levelZeroFile.getAbsolutePath());
      }
      column++;
    }
    LOG.info(""String_Node_Str"",z,row,boxBounds.lastRow,progress,imageProcessorCache.getStats());
    row++;
  }
}","private void generateLevelZero(final Double z,final Bounds layerBounds,final BoxBounds boxBounds,final int tileCount,final ImageProcessorCache imageProcessorCache,final BoxMipmapGenerator boxMipmapGenerator,final IGridPaths iGridPaths) throws URISyntaxException, IOException {
  final Progress progress=new Progress(tileCount);
  RenderParameters renderParameters;
  String parametersUrl;
  BufferedImage levelZeroImage;
  File levelZeroFile;
  int row=boxBounds.firstRow;
  int column;
  for (int y=boxBounds.firstY; y < layerBounds.getMaxY(); y+=boxHeight) {
    column=boxBounds.firstColumn;
    for (int x=boxBounds.firstX; x < layerBounds.getMaxX(); x+=boxWidth) {
      levelZeroFile=BoxMipmapGenerator.getImageFile(format,boxDirectory,0,boxBounds.z,row,column);
      if (params.forceGeneration || (!levelZeroFile.exists())) {
        parametersUrl=renderDataClient.getRenderParametersUrlString(stack,x,y,z,boxWidth,boxHeight,1.0);
        LOG.info(""String_Node_Str"",z,parametersUrl);
        renderParameters=RenderParameters.loadFromUrl(parametersUrl);
        renderParameters.setSkipInterpolation(params.skipInterpolation);
        renderParameters.setBackgroundRGBColor(backgroundRGBColor);
        if (renderParameters.hasTileSpecs()) {
          levelZeroImage=renderParameters.openTargetImage();
          Render.render(renderParameters,levelZeroImage,imageProcessorCache);
          BoxMipmapGenerator.saveImage(levelZeroImage,levelZeroFile,params.label,format);
          boxMipmapGenerator.addSource(row,column,levelZeroFile);
          if (iGridPaths != null) {
            iGridPaths.addImage(levelZeroFile,row,column);
          }
        }
 else {
          LOG.info(""String_Node_Str"",z,row,column);
        }
      }
 else {
        LOG.info(""String_Node_Str"",levelZeroFile.getAbsolutePath());
        renderParameters=null;
        boxMipmapGenerator.addSource(row,column,levelZeroFile);
        if (iGridPaths != null) {
          iGridPaths.addImage(levelZeroFile,row,column);
        }
      }
      progress.markProcessedTilesForRow(y,renderParameters);
      column++;
    }
    LOG.info(""String_Node_Str"",z,row,boxBounds.lastRow,progress,imageProcessorCache.getStats());
    row++;
  }
}",0.8445179584120983
25587,"public void markProcessedTilesForRow(final int rowY,final RenderParameters renderParameters){
  final int rowMaxY=rowY + boxHeight;
  if (rowY > currentRowY) {
    currentRowY=rowY;
    currentRowPartialTileSum=0;
  }
  for (  TileSpec tileSpec : renderParameters.getTileSpecs()) {
    if (tileSpec.getMaxY() <= rowMaxY) {
      processedTileIds.add(tileSpec.getTileId());
    }
 else {
      currentRowPartialTileSum+=(rowMaxY - tileSpec.getMinY()) / (double)tileSpec.getHeight();
    }
  }
}","public void markProcessedTilesForRow(final int rowY,final RenderParameters renderParameters){
  final int rowMaxY=rowY + boxHeight;
  if (rowY > currentRowY) {
    currentRowY=rowY;
    currentRowPartialTileSum=0;
  }
  if (renderParameters != null) {
    for (    TileSpec tileSpec : renderParameters.getTileSpecs()) {
      if (tileSpec.getMaxY() <= rowMaxY) {
        processedTileIds.add(tileSpec.getTileId());
      }
 else {
        currentRowPartialTileSum+=(rowMaxY - tileSpec.getMinY()) / (double)tileSpec.getHeight();
      }
    }
  }
}",0.9384615384615383
25588,"/** 
 * Constructs a cache instance using the specified parameters.
 * @param maximumNumberOfCachedPixels         the maximum number of pixels to maintain in the cache.This should roughly correlate to the maximum amount of memory for the cache.
 * @param recordStats                         if true, useful tuning stats like cache hits and loads will bemaintained (presumably at some nominal overhead cost); otherwise stats are not maintained.
 * @param cacheOriginalsForDownSampledImages  if true, when down sampled images are requested their sourceimages will also be cached (presumably improving the speed of future down sampling to a different level); otherwise only the down sampled result images are cached.
 */
public ImageProcessorCache(final long maximumNumberOfCachedPixels,final boolean recordStats,final boolean cacheOriginalsForDownSampledImages){
  this.maximumNumberOfCachedPixels=maximumNumberOfCachedPixels;
  this.recordStats=recordStats;
  this.cacheOriginalsForDownSampledImages=cacheOriginalsForDownSampledImages;
  this.opener=new Opener();
  this.opener.setSilentMode(true);
  final Weigher<CacheKey,ImageProcessor> weigher=new Weigher<CacheKey,ImageProcessor>(){
    @Override public int weigh(    @Nullable CacheKey key,    @Nullable ImageProcessor value){
      final int weight;
      if (value == null) {
        weight=0;
      }
 else {
        weight=value.getPixelCount();
      }
      return weight;
    }
  }
;
  final CacheLoader<CacheKey,ImageProcessor> loader=new CacheLoader<CacheKey,ImageProcessor>(){
    @Override public ImageProcessor load(    @Nullable CacheKey key) throws Exception {
      ImageProcessor imageProcessor=null;
      if (key != null) {
        imageProcessor=loadImageProcessor(key.getUri(),key.getDownSampleLevels(),key.isMask());
      }
      return imageProcessor;
    }
  }
;
  if (recordStats) {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).recordStats().build(loader);
  }
 else {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).build(loader);
  }
}","/** 
 * Constructs a cache instance using the specified parameters.
 * @param maximumNumberOfCachedPixels         the maximum number of pixels to maintain in the cache.This should roughly correlate to the maximum amount of memory for the cache.
 * @param recordStats                         if true, useful tuning stats like cache hits and loads will bemaintained (presumably at some nominal overhead cost); otherwise stats are not maintained.
 * @param cacheOriginalsForDownSampledImages  if true, when down sampled images are requested their sourceimages will also be cached (presumably improving the speed of future down sampling to a different level); otherwise only the down sampled result images are cached.
 */
public ImageProcessorCache(final long maximumNumberOfCachedPixels,final boolean recordStats,final boolean cacheOriginalsForDownSampledImages){
  this.maximumNumberOfCachedPixels=maximumNumberOfCachedPixels;
  this.recordStats=recordStats;
  this.cacheOriginalsForDownSampledImages=cacheOriginalsForDownSampledImages;
  final Weigher<CacheKey,ImageProcessor> weigher=new Weigher<CacheKey,ImageProcessor>(){
    @Override public int weigh(    @Nullable CacheKey key,    @Nullable ImageProcessor value){
      final int weight;
      if (value == null) {
        weight=0;
      }
 else {
        weight=value.getPixelCount();
      }
      return weight;
    }
  }
;
  final CacheLoader<CacheKey,ImageProcessor> loader=new CacheLoader<CacheKey,ImageProcessor>(){
    @Override public ImageProcessor load(    @Nullable CacheKey key) throws Exception {
      ImageProcessor imageProcessor=null;
      if (key != null) {
        imageProcessor=loadImageProcessor(key.getUri(),key.getDownSampleLevels(),key.isMask());
      }
      return imageProcessor;
    }
  }
;
  if (recordStats) {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).recordStats().build(loader);
  }
 else {
    cache=CacheBuilder.newBuilder().maximumWeight(maximumNumberOfCachedPixels).weigher(weigher).build(loader);
  }
}",0.9848884624610218
25589,"/** 
 * The core method used to load image processor instances that is called when cache misses occur.
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.
 * @param isMask            indicates whether this image is a mask.
 * @return a newly loaded image processor to be cached.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
protected ImageProcessor loadImageProcessor(final String url,final int downSampleLevels,final boolean isMask) throws IllegalArgumentException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",url,downSampleLevels);
  }
  ImageProcessor imageProcessor=null;
  if (downSampleLevels > 0) {
    imageProcessor=cache.getIfPresent(new CacheKey(url,0,isMask));
  }
  if (imageProcessor == null) {
    final ImagePlus imagePlus=opener.openURL(url);
    if (imagePlus == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + url + ""String_Node_Str"");
    }
    imageProcessor=imagePlus.getProcessor();
    if (cacheOriginalsForDownSampledImages && (downSampleLevels > 0)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",url);
      }
      cache.put(new CacheKey(url,0,isMask),imageProcessor);
    }
  }
  if (downSampleLevels > 0) {
    imageProcessor=Downsampler.downsampleImageProcessor(imageProcessor,downSampleLevels);
  }
  return imageProcessor;
}","/** 
 * The core method used to load image processor instances that is called when cache misses occur.
 * @param url               url for the image.
 * @param downSampleLevels  number of levels to further down sample the image.
 * @param isMask            indicates whether this image is a mask.
 * @return a newly loaded image processor to be cached.
 * @throws IllegalArgumentException if the image cannot be loaded.
 */
protected ImageProcessor loadImageProcessor(final String url,final int downSampleLevels,final boolean isMask) throws IllegalArgumentException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",url,downSampleLevels);
  }
  ImageProcessor imageProcessor=null;
  if (downSampleLevels > 0) {
    imageProcessor=cache.getIfPresent(new CacheKey(url,0,isMask));
  }
  if (imageProcessor == null) {
    final Opener opener=new Opener();
    opener.setSilentMode(true);
    final ImagePlus imagePlus=opener.openURL(url);
    if (imagePlus == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + url + ""String_Node_Str"");
    }
    imageProcessor=imagePlus.getProcessor();
    if (cacheOriginalsForDownSampledImages && (downSampleLevels > 0)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",url);
      }
      cache.put(new CacheKey(url,0,isMask),imageProcessor);
    }
  }
  if (downSampleLevels > 0) {
    imageProcessor=Downsampler.downsampleImageProcessor(imageProcessor,downSampleLevels);
  }
  return imageProcessor;
}",0.9759780370624572
25590,"private static float[] centerToWorld(final TileSpec tileSpec){
  final float[] center=new float[]{(float)tileSpec.getWidth() / 2.0f,(float)tileSpec.getHeight() / 2.0f};
  final CoordinateTransformList<CoordinateTransform> ctl=tileSpec.createTransformList();
  ctl.applyInPlace(center);
  return center;
}","private static float[] centerToWorld(final TileSpec tileSpec){
  final float[] center=new float[]{(float)tileSpec.getWidth() / 2.0f,(float)tileSpec.getHeight() / 2.0f};
  final CoordinateTransformList<CoordinateTransform> ctl=tileSpec.getTransformList();
  ctl.applyInPlace(center);
  return center;
}",0.9851239669421488
25591,"public static void render(final List<TileSpec> tileSpecs,final BufferedImage targetImage,final double x,final double y,final double triangleSize,final double scale,final boolean areaOffset,final int numberOfThreads,final boolean skipInterpolation,final boolean doFilter) throws IllegalArgumentException {
  final Graphics2D targetGraphics=targetImage.createGraphics();
  LOG.debug(""String_Node_Str"",tileSpecs.size(),numberOfThreads);
  final long tileLoopStart=System.currentTimeMillis();
  int tileSpecIndex=0;
  long tileSpecStart;
  long loadMipStop;
  long scaleMipStop;
  long loadMaskStop;
  long ctListCreationStop;
  long meshCreationStop;
  long sourceCreationStop;
  long targetCreationStop;
  long mapInterpolatedStop;
  long drawImageStop;
  final ByteProcessorCache byteProcessorCache=new ByteProcessorCache();
  ByteProcessor bpMaskSource;
  ByteProcessor bpMaskTarget;
  for (  final TileSpec ts : tileSpecs) {
    tileSpecStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctl=ts.createTransformList();
    final AffineModel2D scaleAndOffset=new AffineModel2D();
    if (areaOffset) {
      final double offset=(1 - scale) * 0.5;
      scaleAndOffset.set((float)scale,0,0,(float)scale,-(float)(x * scale + offset),-(float)(y * scale + offset));
    }
 else {
      scaleAndOffset.set((float)scale,0,0,(float)scale,-(float)(x * scale),-(float)(y * scale));
    }
    ctl.add(scaleAndOffset);
    Map.Entry<Integer,ImageAndMask> mipmapEntry;
    ImageAndMask imageAndMask=null;
    ImageProcessor ip=null;
    int width=ts.getWidth();
    int height=ts.getHeight();
    if ((width < 0) || (height < 0)) {
      mipmapEntry=ts.getFirstMipmapEntry();
      imageAndMask=mipmapEntry.getValue();
      final ImagePlus imp=getImagePlusForMipmap(imageAndMask);
      ip=imp.getProcessor();
      width=imp.getWidth();
      height=imp.getHeight();
    }
    final double s=Utils.sampleAverageScale(ctl,width,height,triangleSize);
    int mipmapLevel=Utils.bestMipmapLevel(s);
    Integer downSampleLevels=null;
    final ImageProcessor ipMipmap;
    if (ip == null) {
      mipmapEntry=ts.getFloorMipmapEntry(mipmapLevel);
      imageAndMask=mipmapEntry.getValue();
      final ImagePlus imp=getImagePlusForMipmap(imageAndMask);
      loadMipStop=System.currentTimeMillis();
      ip=imp.getProcessor();
      final int currentMipmapLevel=mipmapEntry.getKey();
      if (currentMipmapLevel >= mipmapLevel) {
        mipmapLevel=currentMipmapLevel;
        ipMipmap=ip;
        LOG.debug(""String_Node_Str"",mipmapLevel);
      }
 else {
        downSampleLevels=mipmapLevel - currentMipmapLevel;
        LOG.debug(""String_Node_Str"",currentMipmapLevel,mipmapLevel);
        ipMipmap=Downsampler.downsampleImageProcessor(ip,downSampleLevels);
      }
    }
 else {
      loadMipStop=System.currentTimeMillis();
      downSampleLevels=mipmapLevel;
      LOG.debug(""String_Node_Str"",mipmapLevel);
      ipMipmap=Downsampler.downsampleImageProcessor(ip,downSampleLevels);
    }
    if (doFilter) {
      final double mipmapScale=1.0 / (1 << mipmapLevel);
      vtnf1.process(ipMipmap,mipmapScale);
      vtnf2.process(ipMipmap,mipmapScale);
      nlcf.process(ipMipmap,mipmapScale);
    }
    final ImageProcessor tp=ipMipmap.createProcessor(targetImage.getWidth(),targetImage.getHeight());
    scaleMipStop=System.currentTimeMillis();
    bpMaskSource=null;
    bpMaskTarget=null;
    final String maskUrl=imageAndMask.getMaskUrl();
    if (maskUrl != null) {
      bpMaskSource=byteProcessorCache.getProcessor(maskUrl,downSampleLevels);
      if (bpMaskSource != null) {
        bpMaskTarget=new ByteProcessor(tp.getWidth(),tp.getHeight());
      }
    }
    loadMaskStop=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctlMipmap=new CoordinateTransformList<CoordinateTransform>();
    ctlMipmap.add(Utils.createScaleLevelTransform(mipmapLevel));
    ctlMipmap.add(ctl);
    ctListCreationStop=System.currentTimeMillis();
    final CoordinateTransformMesh mesh=new CoordinateTransformMesh(ctlMipmap,(int)(width / triangleSize + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    meshCreationStop=System.currentTimeMillis();
    final ImageProcessorWithMasks source=new ImageProcessorWithMasks(ipMipmap,bpMaskSource,null);
    if ((bpMaskTarget != null) && (source.mask == null)) {
      LOG.warn(""String_Node_Str"" + ipMipmap.getWidth() + ""String_Node_Str""+ ipMipmap.getHeight()+ ""String_Node_Str""+ bpMaskSource.getWidth()+ ""String_Node_Str""+ bpMaskSource.getHeight());
      bpMaskTarget=null;
    }
    sourceCreationStop=System.currentTimeMillis();
    final ImageProcessorWithMasks target=new ImageProcessorWithMasks(tp,bpMaskTarget,null);
    targetCreationStop=System.currentTimeMillis();
    final TransformMeshMappingWithMasks<TransformMesh> mapping=new TransformMeshMappingWithMasks<TransformMesh>(mesh);
    String mapType;
    if (skipInterpolation) {
      mapType=""String_Node_Str"";
      mapping.map(source,target,numberOfThreads);
    }
 else {
      mapType=""String_Node_Str"";
      mapping.mapInterpolated(source,target,numberOfThreads);
    }
    mapInterpolatedStop=System.currentTimeMillis();
    tp.setMinAndMax(ts.getMinIntensity(),ts.getMaxIntensity());
    final ColorProcessor cp=tp.convertToColorProcessor();
    final int[] cpPixels=(int[])cp.getPixels();
    final byte[] alphaPixels;
    if (bpMaskTarget != null) {
      alphaPixels=(byte[])bpMaskTarget.getPixels();
    }
 else {
      alphaPixels=(byte[])target.outside.getPixels();
    }
    for (int i=0; i < cpPixels.length; ++i) {
      cpPixels[i]&=0x00ffffff | (alphaPixels[i] << 24);
    }
    final BufferedImage image=new BufferedImage(cp.getWidth(),cp.getHeight(),BufferedImage.TYPE_INT_ARGB);
    final WritableRaster raster=image.getRaster();
    raster.setDataElements(0,0,cp.getWidth(),cp.getHeight(),cpPixels);
    targetGraphics.drawImage(image,0,0,null);
    drawImageStop=System.currentTimeMillis();
    LOG.debug(""String_Node_Str"",tileSpecIndex,drawImageStop - tileSpecStart,loadMipStop - tileSpecStart,downSampleLevels,scaleMipStop - loadMipStop,loadMaskStop - scaleMipStop,ctListCreationStop - loadMaskStop,meshCreationStop - ctListCreationStop,sourceCreationStop - meshCreationStop,targetCreationStop - sourceCreationStop,mapType,mapInterpolatedStop - targetCreationStop,drawImageStop - mapInterpolatedStop);
    tileSpecIndex++;
  }
  LOG.debug(""String_Node_Str"",tileSpecs.size(),System.currentTimeMillis() - tileLoopStart);
}","public static void render(final List<TileSpec> tileSpecs,final BufferedImage targetImage,final double x,final double y,final double triangleSize,final double scale,final boolean areaOffset,final int numberOfThreads,final boolean skipInterpolation,final boolean doFilter) throws IllegalArgumentException {
  final Graphics2D targetGraphics=targetImage.createGraphics();
  LOG.debug(""String_Node_Str"",tileSpecs.size(),numberOfThreads);
  final long tileLoopStart=System.currentTimeMillis();
  int tileSpecIndex=0;
  long tileSpecStart;
  long loadMipStop;
  long scaleMipStop;
  long loadMaskStop;
  long ctListCreationStop;
  long meshCreationStop;
  long sourceCreationStop;
  long targetCreationStop;
  long mapInterpolatedStop;
  long drawImageStop;
  final ByteProcessorCache byteProcessorCache=new ByteProcessorCache();
  ByteProcessor bpMaskSource;
  ByteProcessor bpMaskTarget;
  for (  final TileSpec ts : tileSpecs) {
    tileSpecStart=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctl=new CoordinateTransformList<CoordinateTransform>();
    for (    final CoordinateTransform t : ts.getTransformList().getList(null))     ctl.add(t);
    final AffineModel2D scaleAndOffset=new AffineModel2D();
    if (areaOffset) {
      final double offset=(1 - scale) * 0.5;
      scaleAndOffset.set((float)scale,0,0,(float)scale,-(float)(x * scale + offset),-(float)(y * scale + offset));
    }
 else {
      scaleAndOffset.set((float)scale,0,0,(float)scale,-(float)(x * scale),-(float)(y * scale));
    }
    ctl.add(scaleAndOffset);
    Map.Entry<Integer,ImageAndMask> mipmapEntry;
    ImageAndMask imageAndMask=null;
    ImageProcessor ip=null;
    int width=ts.getWidth();
    int height=ts.getHeight();
    if ((width < 0) || (height < 0)) {
      mipmapEntry=ts.getFirstMipmapEntry();
      imageAndMask=mipmapEntry.getValue();
      final ImagePlus imp=getImagePlusForMipmap(imageAndMask);
      ip=imp.getProcessor();
      width=imp.getWidth();
      height=imp.getHeight();
    }
    final double s=Utils.sampleAverageScale(ctl,width,height,triangleSize);
    int mipmapLevel=Utils.bestMipmapLevel(s);
    Integer downSampleLevels=null;
    final ImageProcessor ipMipmap;
    if (ip == null) {
      mipmapEntry=ts.getFloorMipmapEntry(mipmapLevel);
      imageAndMask=mipmapEntry.getValue();
      final ImagePlus imp=getImagePlusForMipmap(imageAndMask);
      loadMipStop=System.currentTimeMillis();
      ip=imp.getProcessor();
      final int currentMipmapLevel=mipmapEntry.getKey();
      if (currentMipmapLevel >= mipmapLevel) {
        mipmapLevel=currentMipmapLevel;
        ipMipmap=ip;
        LOG.debug(""String_Node_Str"",mipmapLevel);
      }
 else {
        downSampleLevels=mipmapLevel - currentMipmapLevel;
        LOG.debug(""String_Node_Str"",currentMipmapLevel,mipmapLevel);
        ipMipmap=Downsampler.downsampleImageProcessor(ip,downSampleLevels);
      }
    }
 else {
      loadMipStop=System.currentTimeMillis();
      downSampleLevels=mipmapLevel;
      LOG.debug(""String_Node_Str"",mipmapLevel);
      ipMipmap=Downsampler.downsampleImageProcessor(ip,downSampleLevels);
    }
    if (doFilter) {
      final double mipmapScale=1.0 / (1 << mipmapLevel);
      vtnf1.process(ipMipmap,mipmapScale);
      vtnf2.process(ipMipmap,mipmapScale);
      nlcf.process(ipMipmap,mipmapScale);
    }
    final ImageProcessor tp=ipMipmap.createProcessor(targetImage.getWidth(),targetImage.getHeight());
    scaleMipStop=System.currentTimeMillis();
    bpMaskSource=null;
    bpMaskTarget=null;
    final String maskUrl=imageAndMask.getMaskUrl();
    if (maskUrl != null) {
      bpMaskSource=byteProcessorCache.getProcessor(maskUrl,downSampleLevels);
      if (bpMaskSource != null) {
        bpMaskTarget=new ByteProcessor(tp.getWidth(),tp.getHeight());
      }
    }
    loadMaskStop=System.currentTimeMillis();
    final CoordinateTransformList<CoordinateTransform> ctlMipmap=new CoordinateTransformList<CoordinateTransform>();
    ctlMipmap.add(Utils.createScaleLevelTransform(mipmapLevel));
    ctlMipmap.add(ctl);
    ctListCreationStop=System.currentTimeMillis();
    final CoordinateTransformMesh mesh=new CoordinateTransformMesh(ctlMipmap,(int)(width / triangleSize + 0.5),ipMipmap.getWidth(),ipMipmap.getHeight());
    meshCreationStop=System.currentTimeMillis();
    final ImageProcessorWithMasks source=new ImageProcessorWithMasks(ipMipmap,bpMaskSource,null);
    if ((bpMaskTarget != null) && (source.mask == null)) {
      LOG.warn(""String_Node_Str"" + ipMipmap.getWidth() + ""String_Node_Str""+ ipMipmap.getHeight()+ ""String_Node_Str""+ bpMaskSource.getWidth()+ ""String_Node_Str""+ bpMaskSource.getHeight());
      bpMaskTarget=null;
    }
    sourceCreationStop=System.currentTimeMillis();
    final ImageProcessorWithMasks target=new ImageProcessorWithMasks(tp,bpMaskTarget,null);
    targetCreationStop=System.currentTimeMillis();
    final TransformMeshMappingWithMasks<TransformMesh> mapping=new TransformMeshMappingWithMasks<TransformMesh>(mesh);
    String mapType;
    if (skipInterpolation) {
      mapType=""String_Node_Str"";
      mapping.map(source,target,numberOfThreads);
    }
 else {
      mapType=""String_Node_Str"";
      mapping.mapInterpolated(source,target,numberOfThreads);
    }
    mapInterpolatedStop=System.currentTimeMillis();
    tp.setMinAndMax(ts.getMinIntensity(),ts.getMaxIntensity());
    final ColorProcessor cp=tp.convertToColorProcessor();
    final int[] cpPixels=(int[])cp.getPixels();
    final byte[] alphaPixels;
    if (bpMaskTarget != null) {
      alphaPixels=(byte[])bpMaskTarget.getPixels();
    }
 else {
      alphaPixels=(byte[])target.outside.getPixels();
    }
    for (int i=0; i < cpPixels.length; ++i) {
      cpPixels[i]&=0x00ffffff | (alphaPixels[i] << 24);
    }
    final BufferedImage image=new BufferedImage(cp.getWidth(),cp.getHeight(),BufferedImage.TYPE_INT_ARGB);
    final WritableRaster raster=image.getRaster();
    raster.setDataElements(0,0,cp.getWidth(),cp.getHeight(),cpPixels);
    targetGraphics.drawImage(image,0,0,null);
    drawImageStop=System.currentTimeMillis();
    LOG.debug(""String_Node_Str"",tileSpecIndex,drawImageStop - tileSpecStart,loadMipStop - tileSpecStart,downSampleLevels,scaleMipStop - loadMipStop,loadMaskStop - scaleMipStop,ctListCreationStop - loadMaskStop,meshCreationStop - ctListCreationStop,sourceCreationStop - meshCreationStop,targetCreationStop - sourceCreationStop,mapType,mapInterpolatedStop - targetCreationStop,drawImageStop - mapInterpolatedStop);
    tileSpecIndex++;
  }
  LOG.debug(""String_Node_Str"",tileSpecs.size(),System.currentTimeMillis() - tileLoopStart);
}",0.989646772228989
25592,"/** 
 * @return a coordinate transform mesh built from this spec's list of transforms.
 * @throws IllegalStateException if width or height have not been defined for this tile.
 */
public CoordinateTransformMesh getCoordinateTransformMesh() throws IllegalStateException {
  if (!hasWidthAndHeightDefined()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final CoordinateTransformList<CoordinateTransform> ctList=createTransformList();
  return new CoordinateTransformMesh(ctList,getNumberOfTrianglesCoveringWidth(),width.floatValue(),height.floatValue());
}","/** 
 * @return a coordinate transform mesh built from this spec's list of transforms.
 * @throws IllegalStateException if width or height have not been defined for this tile.
 */
public CoordinateTransformMesh getCoordinateTransformMesh() throws IllegalStateException {
  if (!hasWidthAndHeightDefined()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final CoordinateTransformList<CoordinateTransform> ctList=getTransformList();
  return new CoordinateTransformMesh(ctList,getNumberOfTrianglesCoveringWidth(),width.floatValue(),height.floatValue());
}",0.9921259842519684
25593,"/** 
 * @return a transform mesh built from this spec's list of transforms.
 * @throws IllegalStateException if width or height have not been defined for this tile.
 */
public TransformMesh getTransformMesh() throws IllegalStateException {
  if (!hasWidthAndHeightDefined()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final CoordinateTransformList<CoordinateTransform> ctList=createTransformList();
  return new TransformMesh(ctList,getNumberOfTrianglesCoveringWidth(),width.floatValue(),height.floatValue());
}","/** 
 * @return a transform mesh built from this spec's list of transforms.
 * @throws IllegalStateException if width or height have not been defined for this tile.
 */
public TransformMesh getTransformMesh() throws IllegalStateException {
  if (!hasWidthAndHeightDefined()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final CoordinateTransformList<CoordinateTransform> ctList=getTransformList();
  return new TransformMesh(ctList,getNumberOfTrianglesCoveringWidth(),width.floatValue(),height.floatValue());
}",0.9915174363807728
25594,"/** 
 * @param x  local x coordinate to transform into world coordinate.
 * @param y  local y coordinate to transform into world coordinate.
 * @return world coordinates (x, y, z) for the specified local coordinates.
 */
public float[] getWorldCoordinates(float x,float y){
  float[] worldCoordinates;
  float[] w=new float[]{x,y};
  if (hasTransforms()) {
    final CoordinateTransformList<CoordinateTransform> ctl=createTransformList();
    ctl.applyInPlace(w);
  }
  if (z == null) {
    worldCoordinates=w;
  }
 else {
    worldCoordinates=new float[]{w[0],w[1],z.floatValue()};
  }
  return worldCoordinates;
}","/** 
 * @param x  local x coordinate to transform into world coordinate.
 * @param y  local y coordinate to transform into world coordinate.
 * @return world coordinates (x, y, z) for the specified local coordinates.
 */
public float[] getWorldCoordinates(float x,float y){
  float[] worldCoordinates;
  float[] w=new float[]{x,y};
  if (hasTransforms()) {
    final CoordinateTransformList<CoordinateTransform> ctl=getTransformList();
    ctl.applyInPlace(w);
  }
  if (z == null) {
    worldCoordinates=w;
  }
 else {
    worldCoordinates=new float[]{w[0],w[1],z.floatValue()};
  }
  return worldCoordinates;
}",0.9926650366748166
25595,"public static TileCoordinates getLocalCoordinates(TileSpec tileSpec,float x,float y){
  final float[] local=tileSpec.getLocalCoordinates(x,y);
  return buildLocalInstance(tileSpec.getTileId(),local);
}","/** 
 * @param tileSpecList  list of tiles that contain the specified point.
 * @param x             x coordinate.
 * @param y             y coordinate.
 * @return a local {@link TileCoordinates} instance with the inverse of the specified world point.
 * @throws IllegalStateException if the specified point cannot be inverted for any of the specified tiles.
 */
public static TileCoordinates getLocalCoordinates(List<TileSpec> tileSpecList,float x,float y) throws IllegalStateException {
  TileCoordinates tileCoordinates=null;
  List<String> nonInvertibleTileIds=null;
  float[] local;
  for (  TileSpec tileSpec : tileSpecList) {
    try {
      local=tileSpec.getLocalCoordinates(x,y);
      tileCoordinates=buildLocalInstance(tileSpec.getTileId(),local);
      break;
    }
 catch (    NoninvertibleModelException e) {
      if (nonInvertibleTileIds == null) {
        nonInvertibleTileIds=new ArrayList<String>();
      }
      nonInvertibleTileIds.add(tileSpec.getTileId());
    }
  }
  if (tileCoordinates == null) {
    throw new IllegalStateException(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ nonInvertibleTileIds+ ""String_Node_Str"");
  }
  if (nonInvertibleTileIds != null) {
    LOG.info(""String_Node_Str"",x,y,nonInvertibleTileIds,tileCoordinates.getTileId());
  }
  return tileCoordinates;
}",0.225130890052356
25596,"/** 
 * @param x  world x coordinate to inversely transform into local coordinate.
 * @param y  world y coordinate to inversely transform into local coordinate.
 * @return local coordinates (x, y, z) for the specified world coordinates.
 * @throws IllegalStateException if width or height have not been defined for this tile.
 */
public float[] getLocalCoordinates(float x,float y) throws IllegalStateException {
  float[] localCoordinates;
  float[] l=new float[]{x,y};
  if (hasTransforms()) {
    final CoordinateTransformMesh mesh=getCoordinateTransformMesh();
    try {
      mesh.applyInverseInPlace(l);
    }
 catch (    NoninvertibleModelException e) {
      LOG.debug(""String_Node_Str"" + e.getMessage());
    }
  }
  if (z == null) {
    localCoordinates=l;
  }
 else {
    localCoordinates=new float[]{l[0],l[1],z.floatValue()};
  }
  return localCoordinates;
}","/** 
 * @param x  world x coordinate to inversely transform into local coordinate.
 * @param y  world y coordinate to inversely transform into local coordinate.
 * @return local coordinates (x, y, z) for the specified world coordinates.
 * @throws IllegalStateException if width or height have not been defined for this tile.
 * @throws NoninvertibleModelException if this tile's transforms cannot be inverted for the specified point.
 */
public float[] getLocalCoordinates(float x,float y) throws IllegalStateException, NoninvertibleModelException {
  float[] localCoordinates;
  float[] l=new float[]{x,y};
  if (hasTransforms()) {
    final CoordinateTransformMesh mesh=getCoordinateTransformMesh();
    mesh.applyInverseInPlace(l);
  }
  if (z == null) {
    localCoordinates=l;
  }
 else {
    localCoordinates=new float[]{l[0],l[1],z.floatValue()};
  }
  return localCoordinates;
}",0.8521046643913538
25597,"@Path(""String_Node_Str"") @PUT @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public List<TileCoordinates> getLocalCoordinates(@PathParam(""String_Node_Str"") String owner,@PathParam(""String_Node_Str"") String project,@PathParam(""String_Node_Str"") String stack,@PathParam(""String_Node_Str"") Double z,List<TileCoordinates> worldCoordinatesList){
  LOG.info(""String_Node_Str"",owner,project,stack,z,worldCoordinatesList.size());
  final long startTime=System.currentTimeMillis();
  long lastStatusTime=startTime;
  List<TileCoordinates> localCoordinatesList=new ArrayList<TileCoordinates>(worldCoordinatesList.size());
  final StackId stackId=new StackId(owner,project,stack);
  TileSpec tileSpec;
  TileCoordinates coordinates;
  float[] world;
  int errorCount=0;
  for (int i=0; i < worldCoordinatesList.size(); i++) {
    coordinates=worldCoordinatesList.get(i);
    try {
      if (coordinates == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      world=coordinates.getWorld();
      if (world == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (world.length < 2) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      tileSpec=renderDao.getTileSpec(stackId,(double)world[0],(double)world[1],z);
      localCoordinatesList.add(TileCoordinates.getLocalCoordinates(tileSpec,world[0],world[1]));
    }
 catch (    Throwable t) {
      LOG.warn(""String_Node_Str"",i,t);
      errorCount++;
      if (coordinates == null) {
        coordinates=TileCoordinates.buildWorldInstance(null,null);
      }
      coordinates.setError(t.getMessage());
      localCoordinatesList.add(coordinates);
    }
    if ((System.currentTimeMillis() - lastStatusTime) > COORDINATE_PROCESSING_LOG_INTERVAL) {
      lastStatusTime=System.currentTimeMillis();
      LOG.info(""String_Node_Str"",localCoordinatesList.size(),worldCoordinatesList.size());
    }
  }
  LOG.info(""String_Node_Str"",localCoordinatesList.size(),errorCount,(System.currentTimeMillis() - startTime));
  return localCoordinatesList;
}","@Path(""String_Node_Str"") @PUT @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public List<TileCoordinates> getLocalCoordinates(@PathParam(""String_Node_Str"") String owner,@PathParam(""String_Node_Str"") String project,@PathParam(""String_Node_Str"") String stack,@PathParam(""String_Node_Str"") Double z,List<TileCoordinates> worldCoordinatesList){
  LOG.info(""String_Node_Str"",owner,project,stack,z,worldCoordinatesList.size());
  final long startTime=System.currentTimeMillis();
  long lastStatusTime=startTime;
  List<TileCoordinates> localCoordinatesList=new ArrayList<TileCoordinates>(worldCoordinatesList.size());
  final StackId stackId=new StackId(owner,project,stack);
  List<TileSpec> tileSpecList;
  TileCoordinates coordinates;
  float[] world;
  int errorCount=0;
  for (int i=0; i < worldCoordinatesList.size(); i++) {
    coordinates=worldCoordinatesList.get(i);
    try {
      if (coordinates == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      world=coordinates.getWorld();
      if (world == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (world.length < 2) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      tileSpecList=renderDao.getTileSpecs(stackId,(double)world[0],(double)world[1],z);
      localCoordinatesList.add(TileCoordinates.getLocalCoordinates(tileSpecList,world[0],world[1]));
    }
 catch (    Throwable t) {
      LOG.warn(""String_Node_Str"",i,t);
      errorCount++;
      if (coordinates == null) {
        coordinates=TileCoordinates.buildWorldInstance(null,null);
      }
      coordinates.setError(t.getMessage());
      localCoordinatesList.add(coordinates);
    }
    if ((System.currentTimeMillis() - lastStatusTime) > COORDINATE_PROCESSING_LOG_INTERVAL) {
      lastStatusTime=System.currentTimeMillis();
      LOG.info(""String_Node_Str"",localCoordinatesList.size(),worldCoordinatesList.size());
    }
  }
  LOG.info(""String_Node_Str"",localCoordinatesList.size(),errorCount,(System.currentTimeMillis() - startTime));
  return localCoordinatesList;
}",0.995509335854408
25598,"/** 
 * @return the tile specification that encompasses the specified coordinates.
 * @throws IllegalArgumentException if any required parameters are missing, the stack cannot be found, or a tile that encompasses the coordinates cannot be found.
 */
public TileSpec getTileSpec(StackId stackId,Double x,Double y,Double z) throws IllegalArgumentException {
  validateRequiredParameter(""String_Node_Str"",x);
  validateRequiredParameter(""String_Node_Str"",y);
  validateRequiredParameter(""String_Node_Str"",z);
  final DB db=getDatabase(stackId);
  final DBCollection tileCollection=db.getCollection(TILE_COLLECTION_NAME);
  final DBObject tileQuery=new BasicDBObject(""String_Node_Str"",z).append(""String_Node_Str"",lte(x)).append(""String_Node_Str"",lte(y)).append(""String_Node_Str"",gte(x)).append(""String_Node_Str"",gte(y));
  final RenderParameters renderParameters=new RenderParameters();
  addResolvedTileSpecs(db,tileCollection,tileQuery,renderParameters);
  if (!renderParameters.hasTileSpecs()) {
    throw new IllegalArgumentException(""String_Node_Str"" + stackId + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ z);
  }
  return renderParameters.getTileSpecs().get(0);
}","/** 
 * @return the specified tile spec.
 * @throws IllegalArgumentException if any required parameters are missing.
 * @throws ObjectNotFoundException if a spec with the specified z and tileId cannot be found.
 */
public TileSpec getTileSpec(StackId stackId,String tileId,boolean resolveTransformReferences) throws IllegalArgumentException, ObjectNotFoundException {
  validateRequiredParameter(""String_Node_Str"",tileId);
  final DB db=getDatabase(stackId);
  final DBCollection tileCollection=db.getCollection(TILE_COLLECTION_NAME);
  final BasicDBObject query=new BasicDBObject();
  query.put(""String_Node_Str"",tileId);
  LOG.debug(""String_Node_Str"",tileCollection.getDB().getName(),tileCollection.getName(),query);
  final DBObject document=tileCollection.findOne(query);
  if (document == null) {
    throw new ObjectNotFoundException(""String_Node_Str"" + tileId + ""String_Node_Str""+ db.getName()+ ""String_Node_Str""+ TILE_COLLECTION_NAME+ ""String_Node_Str"");
  }
  final TileSpec tileSpec=TileSpec.fromJson(document.toString());
  if (resolveTransformReferences) {
    resolveTransformReferencesForTiles(db,Arrays.asList(tileSpec));
  }
  return tileSpec;
}",0.4731457800511509
25599,"public ByteProcessor getProcessor(String urlString,int mipmapLevel){
  if ((lastByteProcessor == null) || (!urlString.equals(lastUrlString)) || (mipmapLevel != lastMipmapLevel)) {
    lastByteProcessor=buildByteProcessor(urlString,mipmapLevel);
    lastUrlString=urlString;
    lastMipmapLevel=mipmapLevel;
  }
  return lastByteProcessor;
}","public ByteProcessor getProcessor(String urlString,int mipmapLevel,boolean isDownSamplingNeeded){
  if ((lastByteProcessor == null) || (!urlString.equals(lastUrlString)) || (mipmapLevel != lastMipmapLevel)) {
    lastByteProcessor=buildByteProcessor(urlString,mipmapLevel,isDownSamplingNeeded);
    lastUrlString=urlString;
    lastMipmapLevel=mipmapLevel;
  }
  return lastByteProcessor;
}",0.9315068493150684
25600,"private ByteProcessor buildByteProcessor(String urlString,int mipmapLevel){
  ByteProcessor byteProcessor=null;
  if (urlString != null) {
    final ImagePlus imagePlus=Utils.openImagePlusUrl(urlString);
    if (imagePlus == null) {
      LOG.error(""String_Node_Str"",urlString);
    }
 else {
      final ImageProcessor imageProcessor=imagePlus.getProcessor();
      byteProcessor=Downsampler.downsampleByteProcessor(imageProcessor.convertToByteProcessor(),mipmapLevel);
    }
  }
  return byteProcessor;
}","private ByteProcessor buildByteProcessor(String urlString,int mipmapLevel,boolean isDownSamplingNeeded){
  ByteProcessor byteProcessor=null;
  if (urlString != null) {
    final ImagePlus imagePlus=Utils.openImagePlusUrl(urlString);
    if (imagePlus == null) {
      LOG.error(""String_Node_Str"",urlString);
    }
 else {
      final ImageProcessor imageProcessor=imagePlus.getProcessor();
      byteProcessor=imageProcessor.convertToByteProcessor();
      if (isDownSamplingNeeded) {
        byteProcessor=Downsampler.downsampleByteProcessor(byteProcessor,mipmapLevel);
      }
    }
  }
  return byteProcessor;
}",0.8178571428571428
25601,"public ByteProcessor getProcessor(String urlString,int mipmapLevel,boolean isDownSamplingNeeded){
  if ((lastByteProcessor == null) || (!urlString.equals(lastUrlString)) || (mipmapLevel != lastMipmapLevel)) {
    lastByteProcessor=buildByteProcessor(urlString,mipmapLevel,isDownSamplingNeeded);
    lastUrlString=urlString;
    lastMipmapLevel=mipmapLevel;
  }
  return lastByteProcessor;
}","/** 
 * @param urlString         url or path for the mask.
 * @param downSampleLevels  the amount of down sampling needed(delta between level of the mask and the desired level for rendering).
 * @return a processor (possibly already cached) for the specified mask and down sampling factor.
 */
public ByteProcessor getProcessor(String urlString,Integer downSampleLevels){
  if ((lastByteProcessor == null) || (!urlString.equals(lastUrlString)) || ((downSampleLevels == null) && (lastDownSampleLevels != null))|| ((downSampleLevels != null) && (!downSampleLevels.equals(lastDownSampleLevels)))) {
    lastByteProcessor=buildByteProcessor(urlString,downSampleLevels);
    lastUrlString=urlString;
    lastDownSampleLevels=downSampleLevels;
  }
  return lastByteProcessor;
}",0.4031007751937984
25602,"private ByteProcessor buildByteProcessor(String urlString,int mipmapLevel,boolean isDownSamplingNeeded){
  ByteProcessor byteProcessor=null;
  if (urlString != null) {
    final ImagePlus imagePlus=Utils.openImagePlusUrl(urlString);
    if (imagePlus == null) {
      LOG.error(""String_Node_Str"",urlString);
    }
 else {
      final ImageProcessor imageProcessor=imagePlus.getProcessor();
      byteProcessor=imageProcessor.convertToByteProcessor();
      if (isDownSamplingNeeded) {
        byteProcessor=Downsampler.downsampleByteProcessor(byteProcessor,mipmapLevel);
      }
    }
  }
  return byteProcessor;
}","private ByteProcessor buildByteProcessor(String urlString,Integer downSampleLevels){
  ByteProcessor byteProcessor=null;
  if (urlString != null) {
    final ImagePlus imagePlus=Utils.openImagePlusUrl(urlString);
    if (imagePlus == null) {
      LOG.error(""String_Node_Str"",urlString);
    }
 else {
      final ImageProcessor imageProcessor=imagePlus.getProcessor();
      byteProcessor=imageProcessor.convertToByteProcessor();
      if (downSampleLevels != null) {
        byteProcessor=Downsampler.downsampleByteProcessor(byteProcessor,downSampleLevels);
      }
    }
  }
  return byteProcessor;
}",0.9186524239934264
25603,"public ByteProcessorCache(){
  this.lastUrlString=null;
  this.lastMipmapLevel=0;
  this.lastByteProcessor=null;
}","public ByteProcessorCache(){
  this.lastUrlString=null;
  this.lastDownSampleLevels=null;
  this.lastByteProcessor=null;
}",0.9152542372881356
25604,"/** 
 * If a parametersUrl has been specified, load those values and apply them to any default or unset values in this set of values.  This is a little messy because many of the values are primitives instead of objects which makes it impossible to definitively identify unset values. For now, if a primitive value is set to its default it will be overridden by the parametersUrl value.
 * @throws IllegalArgumentException
 */
private void applyBaseParameters() throws IllegalArgumentException {
  if (parametersUrl != null) {
    final RenderParameters baseParameters=loadParametersUrl();
    tileSpecUrl=mergedValue(tileSpecUrl,baseParameters.tileSpecUrl);
    res=mergedValue(res,baseParameters.res,DEFAULT_RESOLUTION);
    in=mergedValue(in,baseParameters.in);
    out=mergedValue(out,baseParameters.out);
    x=mergedValue(x,baseParameters.x,DEFAULT_X_AND_Y);
    y=mergedValue(y,baseParameters.y,DEFAULT_X_AND_Y);
    width=mergedValue(width,baseParameters.width,DEFAULT_HEIGHT_AND_WIDTH);
    height=mergedValue(height,baseParameters.height,DEFAULT_HEIGHT_AND_WIDTH);
    scale=mergedValue(scale,baseParameters.scale,DEFAULT_SCALE);
    areaOffset=mergedValue(areaOffset,baseParameters.areaOffset,false);
    skipInterpolation=mergedValue(skipInterpolation,baseParameters.skipInterpolation,false);
    if (quality == DEFAULT_QUALITY) {
      quality=baseParameters.quality;
    }
  }
}","/** 
 * If a parametersUrl has been specified, load those values and apply them to any default or unset values in this set of values.  This is a little messy because many of the values are primitives instead of objects which makes it impossible to definitively identify unset values. For now, if a primitive value is set to its default it will be overridden by the parametersUrl value.
 * @throws IllegalArgumentException
 */
private void applyBaseParameters() throws IllegalArgumentException {
  if (parametersUrl != null) {
    final RenderParameters baseParameters=loadParametersUrl();
    tileSpecUrl=mergedValue(tileSpecUrl,baseParameters.tileSpecUrl);
    res=mergedValue(res,baseParameters.res,DEFAULT_RESOLUTION);
    in=mergedValue(in,baseParameters.in);
    out=mergedValue(out,baseParameters.out);
    x=mergedValue(x,baseParameters.x,DEFAULT_X_AND_Y);
    y=mergedValue(y,baseParameters.y,DEFAULT_X_AND_Y);
    width=mergedValue(width,baseParameters.width,DEFAULT_HEIGHT_AND_WIDTH);
    height=mergedValue(height,baseParameters.height,DEFAULT_HEIGHT_AND_WIDTH);
    scale=mergedValue(scale,baseParameters.scale,DEFAULT_SCALE);
    areaOffset=mergedValue(areaOffset,baseParameters.areaOffset,false);
    skipInterpolation=mergedValue(skipInterpolation,baseParameters.skipInterpolation,false);
    if (quality == DEFAULT_QUALITY) {
      quality=baseParameters.quality;
    }
    tileSpecs.addAll(baseParameters.tileSpecs);
  }
}",0.9830388692579504
25605,"/** 
 * @param args  arguments to parse.
 * @return parameters instance populated by parsing the specified arguments.
 * @throws IllegalArgumentException if any invalid arguments are specified.
 */
public static RenderParameters parseCommandLineArgs(String[] args) throws IllegalArgumentException {
  RenderParameters parameters=new RenderParameters();
  parameters.setCommander();
  try {
    parameters.jCommander.parse(args);
  }
 catch (  Throwable t) {
    throw new IllegalArgumentException(""String_Node_Str"",t);
  }
  parameters.applyBaseParameters();
  if (parameters.tileSpecUrl == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  parameters.initializeDerivedValues();
  return parameters;
}","/** 
 * @param args  arguments to parse.
 * @return parameters instance populated by parsing the specified arguments.
 * @throws IllegalArgumentException if any invalid arguments are specified.
 */
public static RenderParameters parseCommandLineArgs(String[] args) throws IllegalArgumentException {
  RenderParameters parameters=new RenderParameters();
  parameters.setCommander();
  try {
    parameters.jCommander.parse(args);
  }
 catch (  Throwable t) {
    throw new IllegalArgumentException(""String_Node_Str"",t);
  }
  parameters.applyBaseParameters();
  parameters.initializeDerivedValues();
  return parameters;
}",0.8431226765799257
25606,"private static void extractPDNGateway(PDNGatewayContents pgwContents,Resource omnEpc){
  String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
  Resource pgwResource=omnEpc.getModel().createResource(uuid);
  pgwResource.addProperty(RDF.type,info.openmultinet.ontology.vocabulary.Epc.PDNGateway);
  String name=pgwContents.getName();
  if (name != null && name != ""String_Node_Str"") {
    pgwResource.addProperty(RDFS.label,name);
  }
  BigInteger rate=pgwContents.getRate();
  BigInteger minusOne=BigInteger.valueOf(-1);
  if (rate != null && rate.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCode,rate);
  }
  BigInteger delay=pgwContents.getDelay();
  if (delay != null && delay.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.delayCode,delay);
  }
  BigInteger loss=pgwContents.getLoss();
  if (loss != null && loss.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.packetlossCode,loss);
  }
  omnEpc.addProperty(info.openmultinet.ontology.vocabulary.Epc.pdnGateway,pgwResource);
}","private static void extractPDNGateway(PDNGatewayContents pgwContents,Resource omnEpc){
  String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
  Resource pgwResource=omnEpc.getModel().createResource(uuid);
  pgwResource.addProperty(RDF.type,info.openmultinet.ontology.vocabulary.Epc.PDNGateway);
  String name=pgwContents.getName();
  if (name != null && name != ""String_Node_Str"") {
    pgwResource.addProperty(RDFS.label,name);
  }
  BigInteger rateUp=pgwContents.getRateUp();
  BigInteger minusOne=BigInteger.valueOf(-1);
  if (rateUp != null && rateUp.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp,rateUp);
  }
  BigInteger rateDown=pgwContents.getRateDown();
  if (rateDown != null && rateDown.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown,rateDown);
  }
  BigInteger delay=pgwContents.getDelay();
  if (delay != null && delay.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.delayCode,delay);
  }
  BigInteger loss=pgwContents.getLoss();
  if (loss != null && loss.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.packetlossCode,loss);
  }
  omnEpc.addProperty(info.openmultinet.ontology.vocabulary.Epc.pdnGateway,pgwResource);
}",0.876046233559187
25607,"private static void setPGW(Epc epc,Resource pgw){
  PDNGatewayContents pgwContents=new ObjectFactory().createPDNGatewayContents();
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCode)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCode).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRate(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode)) {
    int delay=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode).getObject().asLiteral().getInt();
    BigInteger bigDelay=BigInteger.valueOf(delay);
    pgwContents.setDelay(bigDelay);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode)) {
    int loss=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode).getObject().asLiteral().getInt();
    BigInteger bigLoss=BigInteger.valueOf(loss);
    pgwContents.setLoss(bigLoss);
  }
  if (pgw.hasProperty(RDFS.label)) {
    String name=pgw.getProperty(RDFS.label).getObject().asLiteral().getString();
    pgwContents.setName(name);
  }
  epc.getApnOrEnodebOrPdnGateway().add(pgwContents);
}","private static void setPGW(Epc epc,Resource pgw){
  PDNGatewayContents pgwContents=new ObjectFactory().createPDNGatewayContents();
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRateUp(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRateDown(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode)) {
    int delay=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode).getObject().asLiteral().getInt();
    BigInteger bigDelay=BigInteger.valueOf(delay);
    pgwContents.setDelay(bigDelay);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode)) {
    int loss=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode).getObject().asLiteral().getInt();
    BigInteger bigLoss=BigInteger.valueOf(loss);
    pgwContents.setLoss(bigLoss);
  }
  if (pgw.hasProperty(RDFS.label)) {
    String name=pgw.getProperty(RDFS.label).getObject().asLiteral().getString();
    pgwContents.setName(name);
  }
  epc.getApnOrEnodebOrPdnGateway().add(pgwContents);
}",0.8893854748603351
25608,"private static void extractPDNGateway(PDNGatewayContents pgwContents,Resource omnEpc){
  String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
  Resource pgwResource=omnEpc.getModel().createResource(uuid);
  pgwResource.addProperty(RDF.type,info.openmultinet.ontology.vocabulary.Epc.PDNGateway);
  String name=pgwContents.getName();
  if (name != null && name != ""String_Node_Str"") {
    pgwResource.addProperty(RDFS.label,name);
  }
  BigInteger rate=pgwContents.getRate();
  BigInteger minusOne=BigInteger.valueOf(-1);
  if (rate != null && rate.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCode,rate);
  }
  BigInteger delay=pgwContents.getDelay();
  if (delay != null && delay.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.delayCode,delay);
  }
  BigInteger loss=pgwContents.getLoss();
  if (loss != null && loss.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.packetlossCode,loss);
  }
  omnEpc.addProperty(info.openmultinet.ontology.vocabulary.Epc.pdnGateway,pgwResource);
}","private static void extractPDNGateway(PDNGatewayContents pgwContents,Resource omnEpc){
  String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
  Resource pgwResource=omnEpc.getModel().createResource(uuid);
  pgwResource.addProperty(RDF.type,info.openmultinet.ontology.vocabulary.Epc.PDNGateway);
  String name=pgwContents.getName();
  if (name != null && name != ""String_Node_Str"") {
    pgwResource.addProperty(RDFS.label,name);
  }
  BigInteger rate=pgwContents.getRateUp();
  BigInteger minusOne=BigInteger.valueOf(-1);
  if (rate != null && rate.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp,rate);
  }
  BigInteger rateDown=pgwContents.getRateDown();
  if (rateDown != null && rateDown.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown,rateDown);
  }
  BigInteger delay=pgwContents.getDelay();
  if (delay != null && delay.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.delayCode,delay);
  }
  BigInteger loss=pgwContents.getLoss();
  if (loss != null && loss.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.packetlossCode,loss);
  }
  omnEpc.addProperty(info.openmultinet.ontology.vocabulary.Epc.pdnGateway,pgwResource);
}",0.8788484606157537
25609,"private static void setPGW(Epc epc,Resource pgw){
  PDNGatewayContents pgwContents=new ObjectFactory().createPDNGatewayContents();
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCode)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCode).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRate(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode)) {
    int delay=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode).getObject().asLiteral().getInt();
    BigInteger bigDelay=BigInteger.valueOf(delay);
    pgwContents.setDelay(bigDelay);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode)) {
    int loss=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode).getObject().asLiteral().getInt();
    BigInteger bigLoss=BigInteger.valueOf(loss);
    pgwContents.setLoss(bigLoss);
  }
  if (pgw.hasProperty(RDFS.label)) {
    String name=pgw.getProperty(RDFS.label).getObject().asLiteral().getString();
    pgwContents.setName(name);
  }
  epc.getApnOrEnodebOrPdnGateway().add(pgwContents);
}","private static void setPGW(Epc epc,Resource pgw){
  PDNGatewayContents pgwContents=new ObjectFactory().createPDNGatewayContents();
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRateUp(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRateDown(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode)) {
    int delay=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode).getObject().asLiteral().getInt();
    BigInteger bigDelay=BigInteger.valueOf(delay);
    pgwContents.setDelay(bigDelay);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode)) {
    int loss=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode).getObject().asLiteral().getInt();
    BigInteger bigLoss=BigInteger.valueOf(loss);
    pgwContents.setLoss(bigLoss);
  }
  if (pgw.hasProperty(RDFS.label)) {
    String name=pgw.getProperty(RDFS.label).getObject().asLiteral().getString();
    pgwContents.setName(name);
  }
  epc.getApnOrEnodebOrPdnGateway().add(pgwContents);
}",0.8893854748603351
25610,"private static void extractPDNGateway(PDNGatewayContents pgwContents,Resource omnEpc){
  String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
  Resource pgwResource=omnEpc.getModel().createResource(uuid);
  pgwResource.addProperty(RDF.type,info.openmultinet.ontology.vocabulary.Epc.PDNGateway);
  String name=pgwContents.getName();
  if (name != null && name != ""String_Node_Str"") {
    pgwResource.addProperty(RDFS.label,name);
  }
  BigInteger rate=pgwContents.getRate();
  BigInteger minusOne=BigInteger.valueOf(-1);
  if (rate != null && rate.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCode,rate);
  }
  BigInteger delay=pgwContents.getDelay();
  if (delay != null && delay.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.delayCode,delay);
  }
  BigInteger loss=pgwContents.getLoss();
  if (loss != null && loss.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.packetlossCode,loss);
  }
  omnEpc.addProperty(info.openmultinet.ontology.vocabulary.Epc.pdnGateway,pgwResource);
}","private static void extractPDNGateway(PDNGatewayContents pgwContents,Resource omnEpc){
  String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
  Resource pgwResource=omnEpc.getModel().createResource(uuid);
  pgwResource.addProperty(RDF.type,info.openmultinet.ontology.vocabulary.Epc.PDNGateway);
  String name=pgwContents.getName();
  if (name != null && name != ""String_Node_Str"") {
    pgwResource.addProperty(RDFS.label,name);
  }
  BigInteger rateUp=pgwContents.getRateUp();
  BigInteger minusOne=BigInteger.valueOf(-1);
  if (rateUp != null && rateUp.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp,rateUp);
  }
  BigInteger rateDown=pgwContents.getRateDown();
  if (rateDown != null && rateDown.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown,rateDown);
  }
  BigInteger delay=pgwContents.getDelay();
  if (delay != null && delay.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.delayCode,delay);
  }
  BigInteger loss=pgwContents.getLoss();
  if (loss != null && loss.compareTo(minusOne) != 0) {
    pgwResource.addLiteral(info.openmultinet.ontology.vocabulary.Epc.packetlossCode,loss);
  }
  omnEpc.addProperty(info.openmultinet.ontology.vocabulary.Epc.pdnGateway,pgwResource);
}",0.876046233559187
25611,"private static void setPGW(Epc epc,Resource pgw){
  PDNGatewayContents pgwContents=new ObjectFactory().createPDNGatewayContents();
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCode)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCode).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRate(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode)) {
    int delay=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode).getObject().asLiteral().getInt();
    BigInteger bigDelay=BigInteger.valueOf(delay);
    pgwContents.setDelay(bigDelay);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode)) {
    int loss=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode).getObject().asLiteral().getInt();
    BigInteger bigLoss=BigInteger.valueOf(loss);
    pgwContents.setLoss(bigLoss);
  }
  if (pgw.hasProperty(RDFS.label)) {
    String name=pgw.getProperty(RDFS.label).getObject().asLiteral().getString();
    pgwContents.setName(name);
  }
  epc.getApnOrEnodebOrPdnGateway().add(pgwContents);
}","private static void setPGW(Epc epc,Resource pgw){
  PDNGatewayContents pgwContents=new ObjectFactory().createPDNGatewayContents();
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeUp).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRateUp(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown)) {
    int rate=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.rateCodeDown).getObject().asLiteral().getInt();
    BigInteger bigRate=BigInteger.valueOf(rate);
    pgwContents.setRateDown(bigRate);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode)) {
    int delay=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.delayCode).getObject().asLiteral().getInt();
    BigInteger bigDelay=BigInteger.valueOf(delay);
    pgwContents.setDelay(bigDelay);
  }
  if (pgw.hasProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode)) {
    int loss=pgw.getProperty(info.openmultinet.ontology.vocabulary.Epc.packetlossCode).getObject().asLiteral().getInt();
    BigInteger bigLoss=BigInteger.valueOf(loss);
    pgwContents.setLoss(bigLoss);
  }
  if (pgw.hasProperty(RDFS.label)) {
    String name=pgw.getProperty(RDFS.label).getObject().asLiteral().getString();
    pgwContents.setName(name);
  }
  epc.getApnOrEnodebOrPdnGateway().add(pgwContents);
}",0.8893854748603351
25612,"private void setSliverTypes(Statement resource,NodeContents geniNode){
  StmtIterator canImplement=resource.getResource().listProperties(Omn_lifecycle.canImplement);
  if (resource.getResource().hasProperty(Omn_resource.hasSliverType)) {
    final List<Statement> hasSliverNames=resource.getResource().listProperties(Omn_resource.hasSliverType).toList();
    if (hasSliverNames.get(0).getObject().asResource().hasProperty(RDF.type,Omn_resource.SliverType)) {
      for (      final Statement hasSliverName : hasSliverNames) {
        SliverType sliverType=new ObjectFactory().createNodeContentsSliverType();
        Resource sliverTypeResource=hasSliverName.getObject().asResource();
        if (sliverTypeResource.hasProperty(Omn_lifecycle.hasSliverName)) {
          String sliverName=sliverTypeResource.getProperty(Omn_lifecycle.hasSliverName).getObject().asLiteral().getString();
          sliverType.setName(sliverName);
        }
        if (sliverTypeResource != null) {
          setDiskImage(sliverTypeResource,sliverType);
          JAXBElement<SliverType> sliver=new ObjectFactory().createNodeContentsSliverType(sliverType);
          geniNode.getAnyOrRelationOrLocation().add(sliver);
        }
      }
    }
  }
 else   if (canImplement.hasNext()) {
    while (canImplement.hasNext()) {
      SliverType sliver1;
      Statement omnSliver=canImplement.next();
      sliver1=of.createNodeContentsSliverType();
      sliver1.setName(omnSliver.getObject().asResource().getURI());
      JAXBElement<SliverType> sliverType=new ObjectFactory().createNodeContentsSliverType(sliver1);
      geniNode.getAnyOrRelationOrLocation().add(sliverType);
    }
  }
 else {
    SliverType sliverType=new ObjectFactory().createNodeContentsSliverType();
    final List<Statement> hasTypes=resource.getResource().listProperties(RDF.type).toList();
    boolean sliverTypeNameExists=false;
    for (    final Statement hasType : hasTypes) {
      Resource sliverResource=hasType.getObject().asResource();
      if (AbstractConverter.nonGeneric(sliverResource.getURI())) {
        sliverType.setName(sliverResource.getURI());
        sliverTypeNameExists=true;
      }
    }
    if (sliverTypeNameExists) {
      JAXBElement<SliverType> sliver=new ObjectFactory().createNodeContentsSliverType(sliverType);
      geniNode.getAnyOrRelationOrLocation().add(sliver);
    }
  }
}","private void setSliverTypes(Statement resource,NodeContents geniNode){
  StmtIterator canImplement=resource.getResource().listProperties(Omn_lifecycle.canImplement);
  if (resource.getResource().hasProperty(Omn_resource.hasSliverType)) {
    final List<Statement> hasSliverNames=resource.getResource().listProperties(Omn_resource.hasSliverType).toList();
    if (hasSliverNames.get(0).getObject().asResource().hasProperty(RDF.type,Omn_resource.SliverType)) {
      for (      final Statement hasSliverName : hasSliverNames) {
        SliverType sliverType=new ObjectFactory().createNodeContentsSliverType();
        Resource sliverTypeResource=hasSliverName.getObject().asResource();
        if (sliverTypeResource.hasProperty(Omn_lifecycle.hasSliverName)) {
          String sliverName=sliverTypeResource.getProperty(Omn_lifecycle.hasSliverName).getObject().asLiteral().getString();
          sliverType.setName(sliverName);
        }
        if (sliverTypeResource != null) {
          setDiskImage(sliverTypeResource,sliverType);
          JAXBElement<SliverType> sliver=new ObjectFactory().createNodeContentsSliverType(sliverType);
          geniNode.getAnyOrRelationOrLocation().add(sliver);
        }
      }
    }
  }
 else   if (canImplement.hasNext()) {
    while (canImplement.hasNext()) {
      SliverType sliver1;
      Statement omnSliver=canImplement.next();
      sliver1=of.createNodeContentsSliverType();
      sliver1.setName(omnSliver.getObject().asResource().getURI());
      setDiskImage(omnSliver.getResource(),sliver1);
      JAXBElement<SliverType> sliverType=new ObjectFactory().createNodeContentsSliverType(sliver1);
      geniNode.getAnyOrRelationOrLocation().add(sliverType);
    }
  }
 else {
    SliverType sliverType=new ObjectFactory().createNodeContentsSliverType();
    final List<Statement> hasTypes=resource.getResource().listProperties(RDF.type).toList();
    Resource sliverResource=null;
    boolean sliverTypeNameExists=false;
    for (    final Statement hasType : hasTypes) {
      sliverResource=hasType.getObject().asResource();
      if (AbstractConverter.nonGeneric(sliverResource.getURI())) {
        sliverType.setName(sliverResource.getURI());
        sliverTypeNameExists=true;
      }
    }
    if (sliverTypeNameExists) {
      setDiskImage(sliverResource,sliverType);
      JAXBElement<SliverType> sliver=new ObjectFactory().createNodeContentsSliverType(sliverType);
      geniNode.getAnyOrRelationOrLocation().add(sliver);
    }
  }
}",0.9705215419501134
25613,"@Test public void testLoginRoundtrip() throws JAXBException, InvalidModelException, IOException, XMLStreamException, MissingRspecElementException {
  long start;
  start=System.nanoTime();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  parser.read(""String_Node_Str"");
  final Model model=parser.getModel();
  System.out.println(Parser.toString(model));
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  final String rspec=converter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + (System.nanoTime() - start));
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  start=System.nanoTime();
  InputStream input=IOUtils.toInputStream(rspec,""String_Node_Str"");
  RSpecContents rspecContents=converter.getRspec(input);
  final Model newModel=converter.getModel(rspecContents);
  System.out.println(""String_Node_Str"");
  String modStr=Parser.toString(newModel);
  System.out.println(StringUtils.abbreviateMiddle(modStr,""String_Node_Str"",4096));
  System.out.println(""String_Node_Str"" + (System.nanoTime() - start));
  final ResIterator topology=newModel.listResourcesWithProperty(RDF.type,Omn_lifecycle.Offering);
  Assert.assertTrue(""String_Node_Str"",topology.hasNext());
  Resource requestResource=topology.nextResource();
  StmtIterator nodes=requestResource.listProperties(Omn.hasResource);
  Assert.assertTrue(""String_Node_Str"",nodes.hasNext());
  Resource resourceResource=nodes.next().getResource();
  Assert.assertTrue(""String_Node_Str"",resourceResource.hasProperty(RDF.type,Omn_resource.Node));
  Assert.assertTrue(""String_Node_Str"",resourceResource.getURI().toString().equals(""String_Node_Str""));
  StmtIterator vms=resourceResource.listProperties(Omn_lifecycle.canImplement);
  Resource anyVm=vms.next().getResource();
  Assert.assertTrue(""String_Node_Str"",anyVm.getURI().toString().equals(""String_Node_Str"") || anyVm.getURI().toString().equals(""String_Node_Str"") || anyVm.getURI().toString().equals(""String_Node_Str""));
}","@Test public void testLoginRoundtrip() throws JAXBException, InvalidModelException, IOException, XMLStreamException, MissingRspecElementException {
  long start;
  start=System.nanoTime();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  parser.read(""String_Node_Str"");
  final Model model=parser.getModel();
  System.out.println(Parser.toString(model));
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  final String rspec=converter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + (System.nanoTime() - start));
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  start=System.nanoTime();
  InputStream input=IOUtils.toInputStream(rspec,""String_Node_Str"");
  RSpecContents rspecContents=converter.getRspec(input);
  final Model newModel=converter.getModel(rspecContents);
  System.out.println(""String_Node_Str"");
  String modStr=Parser.toString(newModel);
  System.out.println(StringUtils.abbreviateMiddle(modStr,""String_Node_Str"",4096));
  System.out.println(""String_Node_Str"" + (System.nanoTime() - start));
  final ResIterator topology=newModel.listResourcesWithProperty(RDF.type,Omn_lifecycle.Offering);
  Assert.assertTrue(""String_Node_Str"",topology.hasNext());
  Resource requestResource=topology.nextResource();
  StmtIterator nodes=requestResource.listProperties(Omn.hasResource);
  Assert.assertTrue(""String_Node_Str"",nodes.hasNext());
  Resource resourceResource=nodes.next().getResource();
  Assert.assertTrue(""String_Node_Str"",resourceResource.hasProperty(RDF.type,Omn_resource.Node));
  Assert.assertTrue(""String_Node_Str"",resourceResource.getURI().toString().equals(""String_Node_Str""));
  StmtIterator vms=resourceResource.listProperties(Omn_lifecycle.canImplement);
  Resource anyVm=vms.next().getResource();
  Assert.assertTrue(""String_Node_Str"",anyVm.getURI().toString().equals(""String_Node_Str"") || anyVm.getURI().toString().equals(""String_Node_Str"") || anyVm.getURI().toString().equals(""String_Node_Str""));
}",0.984201537147737
25614,"private void tryExtractDiskImage(Object rspecSliverObject,Resource omnSliver){
  try {
    @SuppressWarnings(""String_Node_Str"") JAXBElement<DiskImageContents> diJaxb=(JAXBElement<DiskImageContents>)rspecSliverObject;
    DiskImageContents diskImageContents=diJaxb.getValue();
    String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
    Resource diskImage=model.createResource(uuid);
    diskImage.addProperty(RDF.type,Omn_domain_pc.DiskImage);
    String name=diskImageContents.getName();
    diskImage.addLiteral(Omn_domain_pc.hasDiskimageLabel,name);
    omnSliver.addProperty(Omn_domain_pc.hasDiskImage,diskImage);
    String os=diskImageContents.getOs();
    if (os != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageOS,os);
    }
    String version=diskImageContents.getVersion();
    if (version != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageVersion,version);
    }
    String description=diskImageContents.getDescription();
    if (description != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageDescription,description);
    }
    String url=diskImageContents.getUrl();
    if (url != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageURI,url);
    }
    @SuppressWarnings(""String_Node_Str"") JAXBElement<DiskImage> diskImageElement=(JAXBElement<DiskImage>)rspecSliverObject;
    String defaultString=diskImageElement.getValue().getDefault();
    if (defaultString != null) {
      diskImage.addLiteral(Omn_domain_pc.diskimageDefault,defaultString);
    }
  }
 catch (  final ClassCastException e) {
    AdvertisementConverter.LOG.info(e.getMessage());
  }
catch (  final InvalidPropertyURIException e) {
    AdvertisementConverter.LOG.info(e.getMessage());
  }
}","private void tryExtractDiskImage(Object rspecSliverObject,Resource omnSliver){
  if (rspecSliverObject instanceof JAXBElement) {
    if (((JAXBElement<?>)rspecSliverObject).getDeclaredType().equals(SliverType.DiskImage.class)) {
      DiskImageContents diskImageContents=(DiskImageContents)((JAXBElement<?>)rspecSliverObject).getValue();
      String uuid=""String_Node_Str"" + UUID.randomUUID().toString();
      Resource diskImage=model.createResource(uuid);
      diskImage.addProperty(RDF.type,Omn_domain_pc.DiskImage);
      String name=diskImageContents.getName();
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageLabel,name);
      omnSliver.addProperty(Omn_domain_pc.hasDiskImage,diskImage);
      String os=diskImageContents.getOs();
      if (os != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageOS,os);
      }
      String version=diskImageContents.getVersion();
      if (version != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageVersion,version);
      }
      String description=diskImageContents.getDescription();
      if (description != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageDescription,description);
      }
      String url=diskImageContents.getUrl();
      if (url != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageURI,url);
      }
      @SuppressWarnings(""String_Node_Str"") JAXBElement<DiskImage> diskImageElement=(JAXBElement<DiskImage>)rspecSliverObject;
      String defaultString=diskImageElement.getValue().getDefault();
      if (defaultString != null) {
        diskImage.addLiteral(Omn_domain_pc.diskimageDefault,defaultString);
      }
    }
  }
}",0.2514757969303424
25615,"private static void tryExtractDiskImage(Object rspecSliverObject,Resource omnSliver) throws MissingRspecElementException {
  try {
    @SuppressWarnings(""String_Node_Str"") final JAXBElement<DiskImageContents> diJaxb=(JAXBElement<DiskImageContents>)rspecSliverObject;
    final DiskImageContents diskImageContents=diJaxb.getValue();
    String diskImageURL=diskImageContents.getUrl();
    Resource diskImage=omnSliver.getModel().createResource(diskImageURL);
    diskImage.addProperty(RDF.type,Omn_domain_pc.DiskImage);
    String name=diskImageContents.getName();
    if (name == null) {
      throw new MissingRspecElementException(""String_Node_Str"");
    }
    diskImage.addLiteral(Omn_domain_pc.hasDiskimageLabel,name);
    String os=diskImageContents.getOs();
    if (os != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageOS,os);
    }
    String version=diskImageContents.getVersion();
    if (version != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageVersion,version);
    }
    String url=diskImageContents.getUrl();
    if (url != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageURI,url);
    }
    String description=diskImageContents.getDescription();
    if (description != null) {
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageDescription,description);
    }
    boolean alreadyExists=false;
    if (omnSliver.hasProperty(Omn_domain_pc.hasDiskImage)) {
      StmtIterator diskImages=omnSliver.listProperties(Omn_domain_pc.hasDiskImage);
      while (diskImages.hasNext()) {
        Statement diskImageStatement=diskImages.next();
        Resource diskImageResource=diskImageStatement.getObject().asResource();
        if (diskImageResource.hasProperty(Omn_domain_pc.hasDiskimageLabel)) {
          String diskImageLabel=diskImageResource.getProperty(Omn_domain_pc.hasDiskimageLabel).getObject().asLiteral().getString();
          if (diskImageLabel.equals(name)) {
            alreadyExists=true;
          }
        }
      }
    }
    if (!alreadyExists) {
      omnSliver.addProperty(Omn_domain_pc.hasDiskImage,diskImage);
    }
  }
 catch (  final ClassCastException e) {
    RequestConverter.LOG.finer(e.getMessage());
  }
catch (  final InvalidPropertyURIException e) {
    RequestConverter.LOG.info(e.getMessage());
  }
}","private static void tryExtractDiskImage(Object rspecSliverObject,Resource omnSliver) throws MissingRspecElementException {
  if (rspecSliverObject instanceof JAXBElement) {
    if (((JAXBElement<?>)rspecSliverObject).getDeclaredType().equals(DiskImageContents.class)) {
      DiskImageContents diskImageContents=(DiskImageContents)((JAXBElement<?>)rspecSliverObject).getValue();
      String diskImageURL=diskImageContents.getUrl();
      Resource diskImage=omnSliver.getModel().createResource(diskImageURL);
      diskImage.addProperty(RDF.type,Omn_domain_pc.DiskImage);
      String name=diskImageContents.getName();
      if (name == null) {
        throw new MissingRspecElementException(""String_Node_Str"");
      }
      diskImage.addLiteral(Omn_domain_pc.hasDiskimageLabel,name);
      String os=diskImageContents.getOs();
      if (os != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageOS,os);
      }
      String version=diskImageContents.getVersion();
      if (version != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageVersion,version);
      }
      String url=diskImageContents.getUrl();
      if (url != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageURI,url);
      }
      String description=diskImageContents.getDescription();
      if (description != null) {
        diskImage.addLiteral(Omn_domain_pc.hasDiskimageDescription,description);
      }
      boolean alreadyExists=false;
      if (omnSliver.hasProperty(Omn_domain_pc.hasDiskImage)) {
        StmtIterator diskImages=omnSliver.listProperties(Omn_domain_pc.hasDiskImage);
        while (diskImages.hasNext()) {
          Statement diskImageStatement=diskImages.next();
          Resource diskImageResource=diskImageStatement.getObject().asResource();
          if (diskImageResource.hasProperty(Omn_domain_pc.hasDiskimageLabel)) {
            String diskImageLabel=diskImageResource.getProperty(Omn_domain_pc.hasDiskimageLabel).getObject().asLiteral().getString();
            if (diskImageLabel.equals(name)) {
              alreadyExists=true;
            }
          }
        }
      }
      if (!alreadyExists) {
        omnSliver.addProperty(Omn_domain_pc.hasDiskImage,diskImage);
      }
    }
  }
}",0.8596724214254094
25616,"private static void setValidSource(TRelationshipType relationshipType,Resource relationshipTypeResource) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Resource source=calculateInferredPropertyValue(relationshipTypeResource,(RDFS.domain));
  String namespace=getXMLNamespace(source);
  QName typeRef;
  try {
    typeRef=new QName(namespace,source.getLocalName(),getNSPrefix(source));
  }
 catch (  NoPrefixMappingFoundException e) {
    typeRef=new QName(namespace,source.getLocalName());
  }
  TRelationshipType.ValidSource validSource=objFactory.createTRelationshipTypeValidSource();
  validSource.setTypeRef(typeRef);
  relationshipType.setValidSource(validSource);
}","private static void setValidSource(TRelationshipType relationshipType,Resource relationshipTypeResource) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Resource source=calculateInferredPropertyValue(relationshipTypeResource,RDFS.domain);
  String namespace=getXMLNamespace(source);
  QName typeRef;
  try {
    typeRef=new QName(namespace,source.getLocalName(),getNSPrefix(source));
  }
 catch (  NoPrefixMappingFoundException e) {
    typeRef=new QName(namespace,source.getLocalName());
  }
  TRelationshipType.ValidSource validSource=objFactory.createTRelationshipTypeValidSource();
  validSource.setTypeRef(typeRef);
  relationshipType.setValidSource(validSource);
}",0.9985734664764622
25617,"private static TRelationshipType createRelationshipType(TRelationshipTemplate relationshipTemplate,Model model) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  TRelationshipType relationshipType=objFactory.createTRelationshipType();
  QName type=relationshipTemplate.getType();
  relationshipType.setName(type.getLocalPart());
  relationshipType.setTargetNamespace(type.getNamespaceURI());
  Resource relationshipTypeResource=model.getResource(type.getNamespaceURI() + type.getLocalPart());
  setValidSource(relationshipType,relationshipTypeResource);
  setValidTarget(relationshipType,relationshipTypeResource);
  return relationshipType;
}","private static TRelationshipType createRelationshipType(TRelationshipTemplate relationshipTemplate,Model model) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  TRelationshipType relationshipType=objFactory.createTRelationshipType();
  QName type=relationshipTemplate.getType();
  relationshipType.setName(type.getLocalPart());
  relationshipType.setTargetNamespace(type.getNamespaceURI());
  String namespace=Tosca2OMN.getRDFNamespace(type.getNamespaceURI());
  Resource relationshipTypeResource=model.getResource(namespace + type.getLocalPart());
  setValidSource(relationshipType,relationshipTypeResource);
  setValidTarget(relationshipType,relationshipTypeResource);
  return relationshipType;
}",0.8834882058613295
25618,"private static String getRDFNamespace(String namespace){
  if (namespace == null) {
    return ""String_Node_Str"";
  }
  if (!(namespace.endsWith(""String_Node_Str"") || namespace.endsWith(""String_Node_Str""))) {
    namespace=namespace.concat(""String_Node_Str"");
  }
  return namespace;
}","protected static String getRDFNamespace(String namespace){
  if (namespace == null || namespace.isEmpty()) {
    return ""String_Node_Str"";
  }
  if (!(namespace.endsWith(""String_Node_Str"") || namespace.endsWith(""String_Node_Str""))) {
    namespace=namespace.concat(""String_Node_Str"");
  }
  return namespace;
}",0.6621848739495798
25619,"private static void createPrefixMappingFromQName(final QName qname,final Model model){
  String prefix=qname.getPrefix();
  String namespace=qname.getNamespaceURI();
  if (prefix != null && !prefix.isEmpty()) {
    if (model.getNsPrefixURI(prefix) == null) {
      model.setNsPrefix(prefix,namespace);
    }
  }
}","private static void createPrefixMappingFromQName(final QName qname,final Model model){
  String prefix=qname.getPrefix();
  String namespace=qname.getNamespaceURI();
  if (prefix != null && !prefix.isEmpty()) {
    if (model.getNsPrefixURI(prefix) == null) {
      model.setNsPrefix(prefix,getRDFNamespace(namespace));
    }
  }
}",0.9455676516329704
25620,"private static void setNodeTypeProperties(Resource nodeTypeResource,TNodeType nodeType){
  PropertiesDefinition nodeTypeProperties=objFactory.createTEntityTypePropertiesDefinition();
  String nodeTypeNameSpace=getXMLNamespace(nodeTypeResource);
  String nodeTypePrefix=getNSPrefix(nodeTypeResource);
  QName propertiesReference=new QName(nodeTypeNameSpace,getNodeTypePropertiesName(nodeTypeResource),nodeTypePrefix);
  nodeTypeProperties.setElement(propertiesReference);
  nodeType.setPropertiesDefinition(nodeTypeProperties);
}","private static void setNodeTypeProperties(Resource nodeTypeResource,TNodeType nodeType){
  PropertiesDefinition nodeTypeProperties=objFactory.createTEntityTypePropertiesDefinition();
  String nodeTypeNameSpace=getXMLNamespace(nodeTypeResource);
  QName propertiesReference;
  try {
    propertiesReference=new QName(nodeTypeNameSpace,getNodeTypePropertiesName(nodeTypeResource),getNSPrefix(nodeTypeResource));
  }
 catch (  NoPrefixMappingFoundException e) {
    propertiesReference=new QName(nodeTypeNameSpace,getNodeTypePropertiesName(nodeTypeResource));
  }
  nodeTypeProperties.setElement(propertiesReference);
  nodeType.setPropertiesDefinition(nodeTypeProperties);
}",0.7733333333333333
25621,"private static void createProperties(Resource node,Resource nodeType,Element element,String namespace,String prefix,Element propertiesSeq) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  StmtIterator propertiesIterator=node.listProperties();
  while (propertiesIterator.hasNext()) {
    Statement propertyStatement=propertiesIterator.next();
    Property property=propertyStatement.getPredicate();
    if (!irrelevantProperties.contains(property)) {
      if (property.hasProperty(RDF.type,OWL.ObjectProperty)) {
        createObjectProperty(node,propertyStatement,element,namespace,prefix,propertiesSeq);
      }
 else       if (property.hasProperty(RDF.type,OWL.DatatypeProperty)) {
        createDatatypeProperty(propertyStatement,element,namespace,prefix,propertiesSeq);
      }
    }
  }
}","private static void createProperties(Resource node,Resource nodeType,Element element,String namespace,Element propertiesSeq) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  StmtIterator propertiesIterator=node.listProperties();
  while (propertiesIterator.hasNext()) {
    Statement propertyStatement=propertiesIterator.next();
    Property property=propertyStatement.getPredicate();
    if (!irrelevantProperties.contains(property)) {
      if (property.hasProperty(RDF.type,OWL.ObjectProperty)) {
        createObjectProperty(node,propertyStatement,element,namespace,nodeType,propertiesSeq);
      }
 else       if (property.hasProperty(RDF.type,OWL.DatatypeProperty)) {
        createDatatypeProperty(propertyStatement,element,namespace,nodeType,propertiesSeq);
      }
    }
  }
}",0.9743589743589745
25622,"private static Element createNodePropertiesAndTypes(Resource node,Resource nodeType,TNodeTemplate nodeTemplate,List<Object> types) throws NoPropertiesFoundException, RequiredResourceNotFoundException, MultiplePropertyValuesException, PropertiesTypesAlreadyExistsException {
  Element propertiesSeq=createTypes(nodeType,types);
  Document doc=createDocument();
  String nodeTypeNamespace=getXMLNamespace(nodeType);
  String nodeTypePrefix=getNSPrefix(nodeType);
  Element nodeProperties=doc.createElementNS(nodeTypeNamespace,nodeTypePrefix + ""String_Node_Str"" + getNodeTypePropertiesName(nodeType));
  doc.appendChild(nodeProperties);
  createProperties(node,nodeType,nodeProperties,nodeTypeNamespace,nodeTypePrefix,propertiesSeq);
  if (0 == nodeProperties.getChildNodes().getLength()) {
    throw new NoPropertiesFoundException();
  }
  return doc.getDocumentElement();
}","private static Element createNodePropertiesAndTypes(Resource node,Resource nodeType,TNodeTemplate nodeTemplate,List<Object> types) throws NoPropertiesFoundException, RequiredResourceNotFoundException, MultiplePropertyValuesException, PropertiesTypesAlreadyExistsException {
  Element propertiesSeq=createTypes(nodeType,types);
  Document doc=createDocument();
  String nodeTypeNamespace=getXMLNamespace(nodeType);
  Element nodeProperties;
  try {
    nodeProperties=doc.createElementNS(nodeTypeNamespace,getNSPrefix(nodeType) + ""String_Node_Str"" + getNodeTypePropertiesName(nodeType));
  }
 catch (  NoPrefixMappingFoundException e) {
    nodeProperties=doc.createElementNS(nodeTypeNamespace,getNodeTypePropertiesName(nodeType));
  }
  doc.appendChild(nodeProperties);
  createProperties(node,nodeType,nodeProperties,nodeTypeNamespace,propertiesSeq);
  if (0 == nodeProperties.getChildNodes().getLength()) {
    throw new NoPropertiesFoundException();
  }
  return doc.getDocumentElement();
}",0.7957104557640751
25623,"private static void setType(TRelationshipTemplate relationshipTemplate,Resource relationType){
  String namespace=getXMLNamespace(relationType);
  String prefix=getNSPrefix(relationType);
  QName type=new QName(namespace,relationType.getLocalName(),prefix);
  relationshipTemplate.setType(type);
}","private static void setType(TRelationshipTemplate relationshipTemplate,Resource relationType){
  String namespace=getXMLNamespace(relationType);
  QName type;
  try {
    type=new QName(namespace,relationType.getLocalName(),getNSPrefix(relationType));
  }
 catch (  NoPrefixMappingFoundException e) {
    type=new QName(namespace,relationType.getLocalName());
  }
  relationshipTemplate.setType(type);
}",0.7485714285714286
25624,"private static void setValidSource(TRelationshipType relationshipType,Resource relationshipTypeResource) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Resource source=calculateInferredPropertyValue(relationshipTypeResource,(RDFS.domain));
  String namespace=getXMLNamespace(source);
  String prefix=getNSPrefix(source);
  QName typeRef=new QName(namespace,source.getLocalName(),prefix);
  TRelationshipType.ValidSource validSource=objFactory.createTRelationshipTypeValidSource();
  validSource.setTypeRef(typeRef);
  relationshipType.setValidSource(validSource);
}","private static void setValidSource(TRelationshipType relationshipType,Resource relationshipTypeResource) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Resource source=calculateInferredPropertyValue(relationshipTypeResource,(RDFS.domain));
  String namespace=getXMLNamespace(source);
  QName typeRef;
  try {
    typeRef=new QName(namespace,source.getLocalName(),getNSPrefix(source));
  }
 catch (  NoPrefixMappingFoundException e) {
    typeRef=new QName(namespace,source.getLocalName());
  }
  TRelationshipType.ValidSource validSource=objFactory.createTRelationshipTypeValidSource();
  validSource.setTypeRef(typeRef);
  relationshipType.setValidSource(validSource);
}",0.8613251155624037
25625,"private static void setValidTarget(TRelationshipType relationshipType,Resource relationshipTypeResource) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Resource target=calculateInferredPropertyValue(relationshipTypeResource,(RDFS.range));
  String namespace=getXMLNamespace(target);
  String prefix=getNSPrefix(target);
  QName typeRef=new QName(namespace,target.getLocalName(),prefix);
  TRelationshipType.ValidTarget validTarget=objFactory.createTRelationshipTypeValidTarget();
  validTarget.setTypeRef(typeRef);
  relationshipType.setValidTarget(validTarget);
}","private static void setValidTarget(TRelationshipType relationshipType,Resource relationshipTypeResource) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Resource target=calculateInferredPropertyValue(relationshipTypeResource,(RDFS.range));
  String namespace=getXMLNamespace(target);
  QName typeRef;
  try {
    typeRef=new QName(namespace,target.getLocalName(),getNSPrefix(target));
  }
 catch (  NoPrefixMappingFoundException e) {
    typeRef=new QName(namespace,target.getLocalName());
  }
  TRelationshipType.ValidTarget validTarget=objFactory.createTRelationshipTypeValidTarget();
  validTarget.setTypeRef(typeRef);
  relationshipType.setValidTarget(validTarget);
}",0.8827160493827161
25626,"private static void createObjectProperty(Resource node,Statement propertyStatement,Element nodeProperties,String namespace,String prefix,Element propertiesSeq) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Element parameter=nodeProperties.getOwnerDocument().createElementNS(namespace,prefix + ""String_Node_Str"" + propertyStatement.getPredicate().getLocalName());
  if (!propertyStatement.getResource().isAnon()) {
    parameter.setAttribute(""String_Node_Str"",propertyStatement.getResource().getLocalName());
  }
  Element subSequence=createObjectPropertyType(propertyStatement.getPredicate(),propertiesSeq);
  node=propertyStatement.getResource();
  Resource nodeType=calculateInferredPropertyValue(node,RDF.type);
  createProperties(propertyStatement.getResource(),nodeType,parameter,namespace,prefix,subSequence);
  nodeProperties.appendChild(parameter);
}","private static void createObjectProperty(Resource node,Statement propertyStatement,Element nodeProperties,String namespace,Resource nodeType,Element propertiesSeq) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Element parameter;
  try {
    parameter=nodeProperties.getOwnerDocument().createElementNS(namespace,getNSPrefix(nodeType) + ""String_Node_Str"" + propertyStatement.getPredicate().getLocalName());
  }
 catch (  NoPrefixMappingFoundException e) {
    parameter=nodeProperties.getOwnerDocument().createElementNS(namespace,propertyStatement.getPredicate().getLocalName());
  }
  if (!propertyStatement.getResource().isAnon()) {
    parameter.setAttribute(""String_Node_Str"",propertyStatement.getResource().getLocalName());
  }
  Element subSequence=createObjectPropertyType(propertyStatement.getPredicate(),propertiesSeq);
  node=propertyStatement.getResource();
  Resource newNodeType=calculateInferredPropertyValue(node,RDF.type);
  createProperties(node,newNodeType,parameter,namespace,subSequence);
  nodeProperties.appendChild(parameter);
}",0.8483003551496702
25627,"private static void createDatatypeProperty(Statement propertyStatement,Element nodeProperties,String namespace,String prefix,Element propertiesSeq) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Element parameter=nodeProperties.getOwnerDocument().createElementNS(namespace,prefix + ""String_Node_Str"" + propertyStatement.getPredicate().getLocalName());
  parameter.setTextContent(propertyStatement.getLiteral().getString());
  nodeProperties.appendChild(parameter);
  createDatatypePropertyType(propertyStatement.getPredicate(),propertiesSeq);
}","private static void createDatatypeProperty(Statement propertyStatement,Element nodeProperties,String namespace,Resource nodeType,Element propertiesSeq) throws RequiredResourceNotFoundException, MultiplePropertyValuesException {
  Element parameter;
  try {
    parameter=nodeProperties.getOwnerDocument().createElementNS(namespace,getNSPrefix(nodeType) + ""String_Node_Str"" + propertyStatement.getPredicate().getLocalName());
  }
 catch (  NoPrefixMappingFoundException e) {
    parameter=nodeProperties.getOwnerDocument().createElementNS(namespace,propertyStatement.getPredicate().getLocalName());
  }
  parameter.setTextContent(propertyStatement.getLiteral().getString());
  nodeProperties.appendChild(parameter);
  createDatatypePropertyType(propertyStatement.getPredicate(),propertiesSeq);
}",0.8195763330898466
25628,"private static String getNSPrefix(Resource resource){
  Map<String,String> prefixMap=resource.getModel().getNsPrefixMap();
  for (  Map.Entry<String,String> mapping : prefixMap.entrySet()) {
    if (mapping.getValue().equals(resource.getNameSpace())) {
      return mapping.getKey();
    }
  }
  return ""String_Node_Str"";
}","private static String getNSPrefix(Resource resource) throws NoPrefixMappingFoundException {
  Map<String,String> prefixMap=resource.getModel().getNsPrefixMap();
  for (  Map.Entry<String,String> mapping : prefixMap.entrySet()) {
    if (mapping.getValue().equals(resource.getNameSpace())) {
      return mapping.getKey();
    }
  }
  throw new NoPrefixMappingFoundException();
}",0.8559201141226819
25629,"private static void setNameAndTypeAndID(Resource node,Resource nodeTypeResource,TNodeTemplate nodeTemplate){
  String name=getName(node);
  nodeTemplate.setName(name);
  nodeTemplate.setId(name);
  String nodeTypeNameSpace=getXMLNamespace(nodeTypeResource);
  String nodeTypePrefix=getNSPrefix(nodeTypeResource);
  QName type=new QName(nodeTypeNameSpace,nodeTypeResource.getLocalName(),nodeTypePrefix);
  nodeTemplate.setType(type);
}","private static void setNameAndTypeAndID(Resource node,Resource nodeTypeResource,TNodeTemplate nodeTemplate){
  String name=getName(node);
  nodeTemplate.setName(name);
  nodeTemplate.setId(name);
  String nodeTypeNameSpace=getXMLNamespace(nodeTypeResource);
  QName type;
  try {
    type=new QName(nodeTypeNameSpace,nodeTypeResource.getLocalName(),getNSPrefix(nodeTypeResource));
  }
 catch (  NoPrefixMappingFoundException e) {
    type=new QName(nodeTypeNameSpace,nodeTypeResource.getLocalName());
  }
  nodeTemplate.setType(type);
}",0.7793814432989691
25630,"private static void createType(Model model,String namespace,Resource superProperty,Node typesNode){
  for (int k=0; k < (typesNode.getChildNodes().getLength() - 1); k++) {
    final Node sequenceNode=typesNode.getChildNodes().item(k);
    if (sequenceNode.getLocalName().equals(""String_Node_Str"")) {
      for (int l=0; l < (sequenceNode.getChildNodes().getLength() - 1); l++) {
        final Node typeNode=sequenceNode.getChildNodes().item(l);
        if (typeNode.getLocalName().equals(""String_Node_Str"")) {
          final String name=typeNode.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
          final String type=typeNode.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
          Property property=model.createProperty(namespace + name);
          Resource propertyRangeClass;
          if (type.startsWith(""String_Node_Str"")) {
            propertyRangeClass=getXSDType(type,model);
            property.addProperty(RDF.type,OWL.DatatypeProperty);
          }
 else {
            propertyRangeClass=model.createResource(namespace + type);
            propertyRangeClass.addProperty(RDF.type,OWL2.Class);
            property.addProperty(RDF.type,OWL.ObjectProperty);
            createTypeProperty(model,namespace,typeNode,null);
          }
          if (superProperty != null) {
            property.addProperty(RDFS.subPropertyOf,superProperty);
          }
          property.addProperty(RDFS.range,propertyRangeClass);
        }
      }
    }
  }
}","private static void createType(Model model,String namespace,Resource superProperty,Node typesNode){
  for (int k=0; k < (typesNode.getChildNodes().getLength()); k++) {
    final Node sequenceNode=typesNode.getChildNodes().item(k);
    if (""String_Node_Str"".equals(sequenceNode.getLocalName())) {
      for (int l=0; l < (sequenceNode.getChildNodes().getLength()); l++) {
        final Node typeNode=sequenceNode.getChildNodes().item(l);
        if (""String_Node_Str"".equals(typeNode.getLocalName())) {
          final String name=typeNode.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
          final String type=typeNode.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
          Property property=model.createProperty(namespace + name);
          Resource propertyRangeClass;
          if (type.startsWith(""String_Node_Str"")) {
            propertyRangeClass=getXSDType(type,model);
            property.addProperty(RDF.type,OWL.DatatypeProperty);
          }
 else {
            propertyRangeClass=model.createResource(namespace + type);
            propertyRangeClass.addProperty(RDF.type,OWL2.Class);
            property.addProperty(RDF.type,OWL.ObjectProperty);
            createTypeProperty(model,namespace,typeNode,null);
          }
          if (superProperty != null) {
            property.addProperty(RDFS.subPropertyOf,superProperty);
          }
          property.addProperty(RDFS.range,propertyRangeClass);
        }
      }
    }
  }
}",0.96313672922252
25631,"private static void createTypeProperty(Model model,String namespace,Node elementNode,Resource superProperty){
  for (int j=0; j < (elementNode.getChildNodes().getLength() - 1); j++) {
    final Node typesNode=elementNode.getChildNodes().item(j);
    if (typesNode.getLocalName().equals(""String_Node_Str"")) {
      createType(model,namespace,superProperty,typesNode);
    }
  }
}","private static void createTypeProperty(Model model,String namespace,Node elementNode,Resource superProperty){
  for (int j=0; j < (elementNode.getChildNodes().getLength()); j++) {
    final Node typesNode=elementNode.getChildNodes().item(j);
    if (""String_Node_Str"".equals(typesNode.getLocalName())) {
      createType(model,namespace,superProperty,typesNode);
    }
  }
}",0.8856382978723404
25632,"public static Model getModel(final InputStream input) throws JAXBException, InvalidModelException, UnsupportedException {
  final JAXBContext context=JAXBContext.newInstance(Definitions.class);
  final Unmarshaller unmarshaller=context.createUnmarshaller();
  final Definitions definitions=unmarshaller.unmarshal(new StreamSource(input),Definitions.class).getValue();
  final Model model=tosca2Model(definitions);
  Parser.setCommonPrefixes(model);
  model.setNsPrefix(""String_Node_Str"",getRDFNamespace(definitions.getTargetNamespace()));
  return model;
}","public static Model getModel(final Definitions definitions) throws UnsupportedException {
  final Model model=ModelFactory.createDefaultModel();
  processTypes(definitions,model);
  processNodeTypes(definitions,model);
  processRelationshipTypes(definitions,model);
  processTemplates(definitions,model);
  Parser.setCommonPrefixes(model);
  model.setNsPrefix(""String_Node_Str"",getRDFNamespace(definitions.getTargetNamespace()));
  return model;
}",0.3888334995014955
25633,"private static void processTypes(final Definitions definitions,final Model model){
  if (definitions.getTypes() != null) {
    final List<Object> types=definitions.getTypes().getAny();
    for (    final Object schema : types) {
      if (schema instanceof Element) {
        final Element schemaElement=(Element)schema;
        if (isXMLSchemaElement(schemaElement)) {
          String namespace=getRDFNamespace(schemaElement.getAttribute(""String_Node_Str""));
          if (namespace.isEmpty() || namespace.equals(""String_Node_Str"")) {
            namespace=getRDFNamespace(definitions.getTargetNamespace());
          }
          for (int i=0; i < (schemaElement.getChildNodes().getLength() - 1); i++) {
            final Node elementNode=schemaElement.getChildNodes().item(i);
            final String superPropertyName=elementNode.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
            final Resource superProperty=model.createResource(namespace + superPropertyName);
            try {
              createTypeProperty(model,namespace,elementNode,superProperty);
            }
 catch (            PropertyNotFoundException e) {
              LOG.log(Level.WARNING,""String_Node_Str"" + superProperty + ""String_Node_Str"");
            }
          }
        }
      }
    }
  }
}","private static void processTypes(final Definitions definitions,final Model model){
  if (definitions.getTypes() != null) {
    final List<Object> types=definitions.getTypes().getAny();
    for (    final Object schema : types) {
      if (schema instanceof Element) {
        final Element schemaElement=(Element)schema;
        if (isXMLSchemaElement(schemaElement)) {
          String namespace=getRDFNamespace(schemaElement.getAttribute(""String_Node_Str""));
          if (namespace.isEmpty() || namespace.equals(""String_Node_Str"")) {
            namespace=getRDFNamespace(definitions.getTargetNamespace());
          }
          for (int i=0; i < (schemaElement.getChildNodes().getLength()); i++) {
            final Node elementNode=schemaElement.getChildNodes().item(i);
            if (elementNode.getAttributes() != null && elementNode.getAttributes().getNamedItem(""String_Node_Str"") != null) {
              final String superPropertyName=elementNode.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
              final Resource superProperty=model.createResource(namespace + superPropertyName);
              try {
                createTypeProperty(model,namespace,elementNode,superProperty);
              }
 catch (              PropertyNotFoundException e) {
                LOG.log(Level.WARNING,""String_Node_Str"" + superProperty + ""String_Node_Str"");
              }
            }
          }
        }
      }
    }
  }
}",0.9200581395348836
25634,"public void init(final Model model) throws InvalidModelException {
  Parser.reasoner=Parser.createReasoner();
  this.model=Parser.createInfModel(model);
  if (!Parser.isValid(this.model)) {
    throw new InvalidModelException(Parser.getValidationReport(this.model));
  }
}","public void init(final Model model) throws InvalidModelException {
  this.model=model;
  Parser.reasoner=Parser.createReasoner();
  this.infModel=Parser.createInfModel(model);
  if (!Parser.isValid(this.infModel)) {
    throw new InvalidModelException(Parser.getValidationReport(this.infModel));
  }
}",0.7923211169284468
25635,"public InfModel getModel(){
  return this.model;
}","public Model getModel(){
  return this.model;
}",0.9690721649484536
25636,"public void printStatements(final Resource s,final Property p,final Resource o){
  for (final StmtIterator i=this.model.listStatements(s,p,o); i.hasNext(); ) {
    final Statement stmt=i.nextStatement();
    System.out.println(""String_Node_Str"" + PrintUtil.print(stmt));
  }
}","public void printStatements(final Resource s,final Property p,final Resource o){
  for (final StmtIterator i=this.infModel.listStatements(s,p,o); i.hasNext(); ) {
    final Statement stmt=i.nextStatement();
    System.out.println(""String_Node_Str"" + PrintUtil.print(stmt));
  }
}",0.990990990990991
25637,"public ResultSetRewindable query(String queryString){
  queryString=Parser.getDefaultPrefixes() + queryString;
  final Query query=QueryFactory.create(queryString);
  final QueryExecution qexec=QueryExecutionFactory.create(query,this.model);
  final ResultSetRewindable rewindable=ResultSetFactory.makeRewindable(qexec.execSelect());
  return rewindable;
}","public ResultSetRewindable query(String queryString){
  queryString=Parser.getDefaultPrefixes() + queryString;
  final Query query=QueryFactory.create(queryString);
  final QueryExecution qexec=QueryExecutionFactory.create(query,this.infModel);
  final ResultSetRewindable rewindable=ResultSetFactory.makeRewindable(qexec.execSelect());
  return rewindable;
}",0.8167832167832167
25638,"public boolean isValid(){
  return Parser.isValid(this.model);
}","public boolean isValid(){
  return Parser.isValid(this.infModel);
}",0.9618320610687024
25639,"public String getValidationReport(){
  return Parser.getValidationReport(this.model);
}","public String getValidationReport(){
  return Parser.getValidationReport(this.infModel);
}",0.9717514124293786
25640,"public ResIterator getGroups(){
  return this.model.listSubjectsWithProperty(RDF.type,Omn.Group);
}","public ResIterator getGroups(){
  return this.infModel.listSubjectsWithProperty(RDF.type,Omn.Group);
}",0.9751243781094528
25641,"@POST @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String convert(@PathParam(""String_Node_Str"") final String from,@PathParam(""String_Node_Str"") final String to,@FormParam(""String_Node_Str"") final String content){
  RESTConverter.LOG.log(Level.INFO,""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str"");
  if ((null == content) || (0 == content.length())) {
    throw new ConverterWebApplicationException(Response.Status.NOT_ACCEPTABLE,""String_Node_Str"");
  }
  final ByteArrayOutputStream baos=new ByteArrayOutputStream();
  final InputStream stream=new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));
  Model model;
  try {
    if (AbstractConverter.RSPEC_REQUEST.equalsIgnoreCase(from)) {
      model=RequestConverter.getModel(stream);
    }
 else     if (AbstractConverter.RSPEC_ADVERTISEMENT.equalsIgnoreCase(from)) {
      model=AdvertisementConverter.getModel(stream);
    }
 else     if (AbstractConverter.RSPEC_MANIFEST.equalsIgnoreCase(from)) {
      model=ManifestConverter.getModel(stream);
    }
 else     if (AbstractConverter.TTL.equalsIgnoreCase(from)) {
      model=new Parser(stream).getModel();
    }
 else     if (AbstractConverter.TOSCA.equalsIgnoreCase(from)) {
      model=Tosca2OMN.getModel(stream);
    }
 else {
      throw new ConverterWebApplicationException(Response.Status.NOT_ACCEPTABLE,""String_Node_Str"" + from + ""String_Node_Str"");
    }
    if (AbstractConverter.RSPEC_ADVERTISEMENT.equalsIgnoreCase(to)) {
      final String rspec=AdvertisementConverter.getRSpec(model);
      baos.write(rspec.getBytes());
    }
 else     if (AbstractConverter.RSPEC_MANIFEST.equalsIgnoreCase(to)) {
      final String rspec=ManifestConverter.getRSpec(model);
      baos.write(rspec.getBytes());
    }
 else     if (AbstractConverter.TOSCA.equalsIgnoreCase(to)) {
      final String toplogy=OMN2Tosca.getTopology(model);
      baos.write(toplogy.getBytes());
    }
 else     if (AbstractConverter.TTL.equalsIgnoreCase(to)) {
      RDFDataMgr.write(baos,model,Lang.TTL);
    }
 else {
      throw new ConverterWebApplicationException(Response.Status.NOT_ACCEPTABLE,""String_Node_Str"" + to + ""String_Node_Str"");
    }
  }
 catch (  RiotException|MultipleNamespacesException|RequiredResourceNotFoundException|MultiplePropertyValuesException|UnsupportedException e) {
    throw new ConverterWebApplicationException(Response.Status.BAD_REQUEST,e);
  }
catch (  JAXBException|InvalidModelException|IOException e) {
    throw new ConverterWebApplicationException(Response.Status.INTERNAL_SERVER_ERROR,e);
  }
  return baos.toString();
}","@POST @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String convert(@PathParam(""String_Node_Str"") final String from,@PathParam(""String_Node_Str"") final String to,@FormParam(""String_Node_Str"") final String content){
  RESTConverter.LOG.log(Level.INFO,""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str"");
  if ((null == content) || (0 == content.length())) {
    throw new ConverterWebApplicationException(Response.Status.NOT_ACCEPTABLE,""String_Node_Str"");
  }
  final ByteArrayOutputStream baos=new ByteArrayOutputStream();
  final InputStream stream=new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));
  Model model;
  try {
    if (AbstractConverter.RSPEC_REQUEST.equalsIgnoreCase(from)) {
      model=RequestConverter.getModel(stream);
    }
 else     if (AbstractConverter.RSPEC_ADVERTISEMENT.equalsIgnoreCase(from)) {
      model=AdvertisementConverter.getModel(stream);
    }
 else     if (AbstractConverter.RSPEC_MANIFEST.equalsIgnoreCase(from)) {
      model=ManifestConverter.getModel(stream);
    }
 else     if (AbstractConverter.TTL.equalsIgnoreCase(from)) {
      model=new Parser(stream).getInfModel();
    }
 else     if (AbstractConverter.TOSCA.equalsIgnoreCase(from)) {
      model=Tosca2OMN.getModel(stream);
    }
 else {
      throw new ConverterWebApplicationException(Response.Status.NOT_ACCEPTABLE,""String_Node_Str"" + from + ""String_Node_Str"");
    }
    if (AbstractConverter.RSPEC_ADVERTISEMENT.equalsIgnoreCase(to)) {
      final String rspec=AdvertisementConverter.getRSpec(model);
      baos.write(rspec.getBytes());
    }
 else     if (AbstractConverter.RSPEC_MANIFEST.equalsIgnoreCase(to)) {
      final String rspec=ManifestConverter.getRSpec(model);
      baos.write(rspec.getBytes());
    }
 else     if (AbstractConverter.TOSCA.equalsIgnoreCase(to)) {
      final String toplogy=OMN2Tosca.getTopology(model);
      baos.write(toplogy.getBytes());
    }
 else     if (AbstractConverter.TTL.equalsIgnoreCase(to)) {
      RDFDataMgr.write(baos,model,Lang.TTL);
    }
 else {
      throw new ConverterWebApplicationException(Response.Status.NOT_ACCEPTABLE,""String_Node_Str"" + to + ""String_Node_Str"");
    }
  }
 catch (  RiotException|MultipleNamespacesException|RequiredResourceNotFoundException|MultiplePropertyValuesException|UnsupportedException e) {
    throw new ConverterWebApplicationException(Response.Status.BAD_REQUEST,e);
  }
catch (  JAXBException|InvalidModelException|IOException e) {
    throw new ConverterWebApplicationException(Response.Status.INTERNAL_SERVER_ERROR,e);
  }
  return baos.toString();
}",0.9994218539217576
25642,"private static void processPropertiesElement(Resource node,Model model,Node propertiesElement) throws UnsupportedException {
  for (int i=0; i < (propertiesElement.getChildNodes().getLength() - 1); i++) {
    Node propertyNode=propertiesElement.getChildNodes().item(i);
    String namespace=propertyNode.getNamespaceURI();
    Property property=model.getProperty(namespace + propertyNode.getLocalName());
    Resource propertyRange=getPropertyRange(property);
    Node childElement=propertyNode.getChildNodes().item(0);
    if (childElement.getNodeType() == Node.ELEMENT_NODE) {
      Resource propertyValue=model.createResource(namespace + childElement.getLocalName());
      propertyValue.addProperty(RDF.type,propertyRange);
      processPropertiesElement(propertyValue,model,childElement);
      node.addProperty(property,propertyValue);
    }
 else     if (childElement.getNodeType() == Node.TEXT_NODE) {
      final Literal literal=model.createTypedLiteral(propertyNode.getTextContent(),propertyRange.getURI());
      node.addLiteral(property,literal);
    }
 else {
      throw new UnsupportedException(""String_Node_Str"");
    }
  }
}","private static void processPropertiesElement(Resource node,Model model,Node propertiesElement) throws UnsupportedException {
  for (int i=0; i < (propertiesElement.getChildNodes().getLength() - 1); i++) {
    Node propertyNode=propertiesElement.getChildNodes().item(i);
    String namespace=propertyNode.getNamespaceURI();
    Property property=model.getProperty(namespace + propertyNode.getLocalName());
    Resource propertyRange=getPropertyRange(property);
    Node childElement=propertyNode.getChildNodes().item(0);
    if (childElement.getNodeType() == Node.ELEMENT_NODE) {
      Resource propertyValue=model.createResource(node.getNameSpace() + childElement.getLocalName());
      propertyValue.addProperty(RDF.type,propertyRange);
      propertyValue.addProperty(RDF.type,OWL2.NamedIndividual);
      processPropertiesElement(propertyValue,model,childElement);
      node.addProperty(property,propertyValue);
    }
 else     if (childElement.getNodeType() == Node.TEXT_NODE) {
      final Literal literal=model.createTypedLiteral(propertyNode.getTextContent(),propertyRange.getURI());
      node.addLiteral(property,literal);
    }
 else {
      throw new UnsupportedException(""String_Node_Str"");
    }
  }
}",0.9617996604414262
25643,"private static Resource createTopology(Model model,TServiceTemplate serviceTemplate){
  Resource topologyResource=model.createResource(serviceTemplate.getId());
  topologyResource.addProperty(RDF.type,Omn.Topology);
  return topologyResource;
}","private static Resource createTopology(Model model,TServiceTemplate serviceTemplate){
  Resource topologyResource=model.createResource(serviceTemplate.getId());
  topologyResource.addProperty(RDF.type,Omn.Topology);
  topologyResource.addProperty(RDF.type,OWL2.NamedIndividual);
  return topologyResource;
}",0.8058076225045372
25644,"private static void setNodeType(final TNodeTemplate nodeTemplate,final Resource node,final Model model){
  final QName type=nodeTemplate.getType();
  final Resource nodeType=createResourceFromQName(type,model);
  node.addProperty(RDF.type,nodeType);
}","private static void setNodeType(final TNodeTemplate nodeTemplate,final Resource node,final Model model){
  final QName type=nodeTemplate.getType();
  final Resource nodeType=createResourceFromQName(type,model);
  node.addProperty(RDF.type,nodeType);
  node.addProperty(RDF.type,OWL2.NamedIndividual);
}",0.9077757685352622
25645,"private static void setRelationshipType(TRelationshipTemplate relationshipTemplate,Property relationship,Model model){
  final QName type=relationshipTemplate.getType();
  final Resource relationshipType=createResourceFromQName(type,model);
  relationship.addProperty(RDF.type,relationshipType);
}","private static void setRelationshipType(TRelationshipTemplate relationshipTemplate,Property relationship,Model model){
  final QName type=relationshipTemplate.getType();
  final Resource relationshipType=createResourceFromQName(type,model);
  relationship.addProperty(RDF.type,relationshipType);
  relationship.addProperty(RDF.type,OWL2.NamedIndividual);
}",0.9096477794793262
25646,"@Test public void testModelQuery() throws IOException {
  final Model model=this.parser.getModel();
  ResIterator requests;
  requests=model.listSubjectsWithProperty(RDF.type,Omn_lifecycle.Request);
  Assert.assertTrue(""String_Node_Str"",requests.hasNext());
  requests=model.listSubjectsWithProperty(RDF.type,Omn.Group);
  Assert.assertTrue(""String_Node_Str"",requests.hasNext());
  while (requests.hasNext()) {
    final Resource request=requests.next();
    final StmtIterator statements=request.listProperties();
    System.out.println(""String_Node_Str"" + request);
    while (statements.hasNext()) {
      final Statement statement=statements.next();
      if (statement.getPredicate().equals(Omn.hasResource)) {
        System.out.println(""String_Node_Str"" + statement.getObject());
      }
 else       if (statement.getPredicate().equals(RDFS.comment)) {
        System.out.println(""String_Node_Str"" + statement.getObject());
      }
 else {
        System.out.println(""String_Node_Str"" + statement.getPredicate() + ""String_Node_Str""+ statement.getObject());
      }
    }
  }
}","@Test public void testModelQuery() throws IOException {
  final Model model=this.parser.getInfModel();
  ResIterator requests;
  requests=model.listSubjectsWithProperty(RDF.type,Omn_lifecycle.Request);
  Assert.assertTrue(""String_Node_Str"",requests.hasNext());
  requests=model.listSubjectsWithProperty(RDF.type,Omn.Group);
  Assert.assertTrue(""String_Node_Str"",requests.hasNext());
  while (requests.hasNext()) {
    final Resource request=requests.next();
    final StmtIterator statements=request.listProperties();
    System.out.println(""String_Node_Str"" + request);
    while (statements.hasNext()) {
      final Statement statement=statements.next();
      if (statement.getPredicate().equals(Omn.hasResource)) {
        System.out.println(""String_Node_Str"" + statement.getObject());
      }
 else       if (statement.getPredicate().equals(RDFS.comment)) {
        System.out.println(""String_Node_Str"" + statement.getObject());
      }
 else {
        System.out.println(""String_Node_Str"" + statement.getPredicate() + ""String_Node_Str""+ statement.getObject());
      }
    }
  }
}",0.9986168741355465
25647,"@Test public void testSPARQLQuery() throws IOException {
  final String queryString=""String_Node_Str"";
  final ResultSet result=this.parser.query(queryString);
  Assert.assertTrue(""String_Node_Str"",result.hasNext());
  while (result.hasNext()) {
    final QuerySolution solution=result.nextSolution();
    final RDFNode node=solution.get(""String_Node_Str"");
    final String groupURI=node.asNode().getURI();
    System.out.println(""String_Node_Str"" + groupURI);
    final Resource requestedGroupDetails=this.parser.getModel().getResource(groupURI);
    this.parser.printStatements(requestedGroupDetails,null,null);
    final Property requestedResourceDetails=this.parser.getModel().getProperty(Omn.hasResource.getURI());
    this.parser.printStatements(null,requestedResourceDetails,null);
  }
}","@Test public void testSPARQLQuery() throws IOException {
  final String queryString=""String_Node_Str"";
  final ResultSet result=this.parser.query(queryString);
  Assert.assertTrue(""String_Node_Str"",result.hasNext());
  while (result.hasNext()) {
    final QuerySolution solution=result.nextSolution();
    final RDFNode node=solution.get(""String_Node_Str"");
    final String groupURI=node.asNode().getURI();
    System.out.println(""String_Node_Str"" + groupURI);
    final Resource requestedGroupDetails=this.parser.getInfModel().getResource(groupURI);
    this.parser.printStatements(requestedGroupDetails,null,null);
    final Property requestedResourceDetails=this.parser.getInfModel().getProperty(Omn.hasResource.getURI());
    this.parser.printStatements(null,requestedResourceDetails,null);
  }
}",0.9962406015037594
25648,"@Test public void testNTUAAdvertisement() throws JAXBException, InvalidModelException {
  final Model model=new Parser(""String_Node_Str"").getModel();
  final String rspec=AdvertisementConverter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
}","@Test public void testNTUAAdvertisement() throws JAXBException, InvalidModelException {
  final Model model=new Parser(""String_Node_Str"").getInfModel();
  final String rspec=AdvertisementConverter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
}",0.9961587708066582
25649,"@Test public void testModel2Advertisement() throws JAXBException, InvalidModelException {
  final Model model=Omn4GeniTest.parser.getModel();
  final String rspec=AdvertisementConverter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
}","@Test public void testModel2Advertisement() throws JAXBException, InvalidModelException {
  final Model model=Omn4GeniTest.parser.getInfModel();
  final String rspec=AdvertisementConverter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
}",0.996078431372549
25650,"@Test public void testModel2Manifest() throws JAXBException, InvalidModelException {
  final Model model=Omn4GeniTest.parser.getModel();
  final String rspec=ManifestConverter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
}","@Test public void testModel2Manifest() throws JAXBException, InvalidModelException {
  final Model model=Omn4GeniTest.parser.getInfModel();
  final String rspec=ManifestConverter.getRSpec(model);
  System.out.println(rspec);
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",rspec.contains(""String_Node_Str""));
}",0.995973154362416
25651,"@Test public void testUnboundRequest() throws JAXBException, InvalidModelException, IOException {
  final String filename=""String_Node_Str"";
  final InputStream inputRspec=RequestConverterTest.class.getResourceAsStream(filename);
  System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(AbstractConverter.toString(filename));
  System.out.println(""String_Node_Str"");
  final Model model=RequestConverter.getModel(inputRspec);
  final ResIterator topology=model.listResourcesWithProperty(RDF.type,Omn_lifecycle.Request);
  Assert.assertTrue(""String_Node_Str"",topology.hasNext());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(Parser.toString(model));
  System.out.println(""String_Node_Str"");
  final InfModel infModel=new Parser(model).getModel();
  final String outputRspec=RequestConverter.getRSpec(infModel);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(outputRspec);
  System.out.println(""String_Node_Str"");
}","@Test public void testUnboundRequest() throws JAXBException, InvalidModelException, IOException {
  final String filename=""String_Node_Str"";
  final InputStream inputRspec=RequestConverterTest.class.getResourceAsStream(filename);
  System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(AbstractConverter.toString(filename));
  System.out.println(""String_Node_Str"");
  final Model model=RequestConverter.getModel(inputRspec);
  final ResIterator topology=model.listResourcesWithProperty(RDF.type,Omn_lifecycle.Request);
  Assert.assertTrue(""String_Node_Str"",topology.hasNext());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(Parser.toString(model));
  System.out.println(""String_Node_Str"");
  final InfModel infModel=new Parser(model).getInfModel();
  final String outputRspec=RequestConverter.getRSpec(infModel);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(outputRspec);
  System.out.println(""String_Node_Str"");
}",0.9986431478968792
25652,"@Test public void testAdvertismentRoundtrip() throws JAXBException, InvalidModelException {
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  final InputStream rspec=RoundtripTest.class.getResourceAsStream(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  final Model model=AdvertisementConverter.getModel(rspec);
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  final InfModel infModel=new Parser(model).getModel();
  final String advertisement=AdvertisementConverter.getRSpec(infModel);
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  System.out.println(advertisement);
}","@Test public void testAdvertismentRoundtrip() throws JAXBException, InvalidModelException {
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  final InputStream rspec=RoundtripTest.class.getResourceAsStream(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  final Model model=AdvertisementConverter.getModel(rspec);
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  final InfModel infModel=new Parser(model).getInfModel();
  final String advertisement=AdvertisementConverter.getRSpec(infModel);
  System.out.println(""String_Node_Str"");
  System.out.println(System.currentTimeMillis());
  System.out.println(advertisement);
}",0.9980506822612084
25653,"@Test public void testGetTopology() throws JAXBException, InvalidModelException, MultipleNamespacesException, RequiredResourceNotFoundException, MultiplePropertyValuesException {
  final InfModel model=this.parser.getModel();
  final String topology=OMN2Tosca.getTopology(model);
  System.out.println(topology);
  OMN2ToscaTest.testGeneralToscaDefinitions(topology);
  OMN2ToscaTest.testTypes(topology);
  OMN2ToscaTest.testNodeTypes(topology);
  OMN2ToscaTest.testNodeTemplates(topology);
  OMN2ToscaTest.testRelationshipTemplates(topology);
  this.testRelationshipTypes(topology);
}","@Test public void testGetTopology() throws JAXBException, InvalidModelException, MultipleNamespacesException, RequiredResourceNotFoundException, MultiplePropertyValuesException {
  InputStream input=this.getClass().getResourceAsStream(""String_Node_Str"");
  Parser parser=new Parser(input);
  final InfModel model=parser.getInfModel();
  final String topology=OMN2Tosca.getTopology(model);
  System.out.println(topology);
  OMN2ToscaTest.testGeneralToscaDefinitions(topology);
  OMN2ToscaTest.testTypes(topology);
  OMN2ToscaTest.testNodeTypes(topology);
  OMN2ToscaTest.testNodeTemplates(topology);
  OMN2ToscaTest.testRelationshipTemplates(topology);
  this.testRelationshipTypes(topology);
}",0.8911511354737667
25654,"@Test public void testGetTopology() throws JAXBException, InvalidModelException, UnsupportedException {
  final Model model=Tosca2OMN.getModel(this.input);
  final String serializedModel=Tosca2OMNTest.serializeModel(model,""String_Node_Str"");
  System.out.println(serializedModel);
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Omn.Topology));
  Assert.assertTrue(""String_Node_Str"",model.contains(Osco.dummy,RDFS.subClassOf,Tosca.Node));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Tosca.State));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.Active));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.parameter1));
  Assert.assertTrue(""String_Node_Str"",model.contains(Osco.port,RDFS.range,XSD.xint));
  Assert.assertTrue(""String_Node_Str"",model.contains(Osco.parameter1,RDFS.range,XSD.xstring));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.dummy));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.test_param));
}","@Test public void testGetTopology() throws JAXBException, InvalidModelException, UnsupportedException {
  InputStream input=this.getClass().getResourceAsStream(""String_Node_Str"");
  final Model model=Tosca2OMN.getModel(input);
  final String serializedModel=Tosca2OMNTest.serializeModel(model,""String_Node_Str"");
  System.out.println(serializedModel);
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Omn.Topology));
  Assert.assertTrue(""String_Node_Str"",model.contains(Osco.dummy,RDFS.subClassOf,Tosca.Node));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Tosca.State));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.Active));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.parameter1));
  Assert.assertTrue(""String_Node_Str"",model.contains(Osco.port,RDFS.range,XSD.xint));
  Assert.assertTrue(""String_Node_Str"",model.contains(Osco.parameter1,RDFS.range,XSD.xstring));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.dummy));
  Assert.assertTrue(""String_Node_Str"",model.containsResource(Osco.test_param));
}",0.9616658778987222
25655,"public void init(Model model) throws InvalidModelException {
  Parser.reasoner=createReasoner();
  this.model=createInfModel(model);
  if (!isValid(this.model))   throw new InvalidModelException(getValidationReport(this.model));
}","public void init(final Model model) throws InvalidModelException {
  Parser.reasoner=Parser.createReasoner();
  this.model=Parser.createInfModel(model);
  if (!Parser.isValid(this.model)) {
    throw new InvalidModelException(Parser.getValidationReport(this.model));
  }
}",0.9163346613545816
25656,"public static InfModel createInfModel(Model data) throws InvalidModelException {
  InfModel infModel=ModelFactory.createInfModel(reasoner,data);
  setCommonPrefixes(infModel);
  return infModel;
}","public static InfModel createInfModel(final Model data) throws InvalidModelException {
  final InfModel infModel=ModelFactory.createInfModel(Parser.reasoner,data);
  Parser.setCommonPrefixes(infModel);
  return infModel;
}",0.937799043062201
25657,"public void printStatements(Resource s,Property p,Resource o){
  for (StmtIterator i=model.listStatements(s,p,o); i.hasNext(); ) {
    Statement stmt=i.nextStatement();
    System.out.println(""String_Node_Str"" + PrintUtil.print(stmt));
  }
}","public void printStatements(final Resource s,final Property p,final Resource o){
  for (final StmtIterator i=this.model.listStatements(s,p,o); i.hasNext(); ) {
    final Statement stmt=i.nextStatement();
    System.out.println(""String_Node_Str"" + PrintUtil.print(stmt));
  }
}",0.9323017408123792
25658,"public ResultSetRewindable query(String queryString){
  queryString=getDefaultPrefixes() + queryString;
  Query query=QueryFactory.create(queryString);
  QueryExecution qexec=QueryExecutionFactory.create(query,this.model);
  ResultSetRewindable rewindable=ResultSetFactory.makeRewindable(qexec.execSelect());
  return rewindable;
}","public ResultSetRewindable query(String queryString){
  queryString=Parser.getDefaultPrefixes() + queryString;
  final Query query=QueryFactory.create(queryString);
  final QueryExecution qexec=QueryExecutionFactory.create(query,this.model);
  final ResultSetRewindable rewindable=ResultSetFactory.makeRewindable(qexec.execSelect());
  return rewindable;
}",0.9636098981077148
25659,"public static String getDefaultPrefixes(){
  return createPrefix(""String_Node_Str"",Omn.getURI()) + createPrefix(""String_Node_Str"",Omn_lifecycle.getURI()) + createPrefix(""String_Node_Str"",RDF.getURI())+ createPrefix(""String_Node_Str"",RDFS.getURI())+ createPrefix(""String_Node_Str"",OWL.getURI())+ createPrefix(""String_Node_Str"",Osco.getURI())+ createPrefix(""String_Node_Str"",Tosca.getURI());
}","public static String getDefaultPrefixes(){
  return Parser.createPrefix(""String_Node_Str"",Omn.getURI()) + Parser.createPrefix(""String_Node_Str"",Omn_lifecycle.getURI()) + Parser.createPrefix(""String_Node_Str"",RDF.getURI())+ Parser.createPrefix(""String_Node_Str"",RDFS.getURI())+ Parser.createPrefix(""String_Node_Str"",OWL.getURI())+ Parser.createPrefix(""String_Node_Str"",Osco.getURI())+ Parser.createPrefix(""String_Node_Str"",Tosca.getURI());
}",0.941034897713598
25660,"public static String createPrefix(String name,String URI){
  return ""String_Node_Str"" + name + ""String_Node_Str""+ URI+ ""String_Node_Str""+ NL;
}","public static String createPrefix(final String name,final String URI){
  return ""String_Node_Str"" + name + ""String_Node_Str""+ URI+ ""String_Node_Str""+ Parser.NL;
}",0.9377049180327868
25661,"public static Reasoner createReasoner(){
  Model schema=ModelFactory.createDefaultModel();
  schema.add(parse(""String_Node_Str""));
  schema.add(parse(""String_Node_Str""));
  schema.add(parse(""String_Node_Str""));
  schema.add(parse(""String_Node_Str""));
  schema.add(parse(""String_Node_Str""));
  schema.add(parse(""String_Node_Str""));
  schema.add(parse(""String_Node_Str""));
  schema.add(parse(""String_Node_Str""));
  Reasoner reasoner=ReasonerRegistry.getOWLMiniReasoner();
  reasoner=reasoner.bindSchema(schema);
  return reasoner;
}","public static Reasoner createReasoner(){
  final Model schema=ModelFactory.createDefaultModel();
  schema.add(Parser.parse(""String_Node_Str""));
  schema.add(Parser.parse(""String_Node_Str""));
  schema.add(Parser.parse(""String_Node_Str""));
  schema.add(Parser.parse(""String_Node_Str""));
  schema.add(Parser.parse(""String_Node_Str""));
  schema.add(Parser.parse(""String_Node_Str""));
  schema.add(Parser.parse(""String_Node_Str""));
  schema.add(Parser.parse(""String_Node_Str""));
  Reasoner reasoner=ReasonerRegistry.getOWLMiniReasoner();
  reasoner=reasoner.bindSchema(schema);
  return reasoner;
}",0.445632798573975
25662,"public static Model parse(String filename){
  InputStream stream=Parser.class.getResourceAsStream(filename);
  Model model=ModelFactory.createDefaultModel().read(stream,StandardCharsets.UTF_8.toString(),""String_Node_Str"");
  return model;
}","public static Model parse(final String filename){
  final InputStream stream=Parser.class.getResourceAsStream(filename);
  final Model model=ModelFactory.createDefaultModel().read(stream,StandardCharsets.UTF_8.toString(),""String_Node_Str"");
  return model;
}",0.963855421686747
25663,"public Parser(Model model) throws InvalidModelException {
  init(model);
}","public Parser(final Model model) throws InvalidModelException {
  this.init(model);
}",0.9308176100628932
25664,"public static String toString(Model model){
  String result=""String_Node_Str"";
  for (StmtIterator i=model.listStatements(); i.hasNext(); ) {
    Statement stmt=i.nextStatement();
    result+=PrintUtil.print(stmt) + NL;
  }
  return result;
}","public static String toString(final Model model){
  String result=""String_Node_Str"";
  for (final StmtIterator i=model.listStatements(); i.hasNext(); ) {
    final Statement stmt=i.nextStatement();
    result+=PrintUtil.print(stmt) + Parser.NL;
  }
  return result;
}",0.950884086444008
25665,"public static void setCommonPrefixes(Model model){
  model.setNsPrefix(""String_Node_Str"",Omn.getURI());
  model.setNsPrefix(""String_Node_Str"",Omn_lifecycle.getURI());
  model.setNsPrefix(""String_Node_Str"",RDF.getURI());
  model.setNsPrefix(""String_Node_Str"",RDFS.getURI());
  model.setNsPrefix(""String_Node_Str"",OWL.getURI());
  model.setNsPrefix(""String_Node_Str"",Tosca.getURI());
  model.setNsPrefix(""String_Node_Str"",Osco.getURI());
  model.setNsPrefix(""String_Node_Str"",""String_Node_Str"");
}","public static void setCommonPrefixes(final Model model){
  model.setNsPrefix(""String_Node_Str"",Omn.getURI());
  model.setNsPrefix(""String_Node_Str"",Omn_lifecycle.getURI());
  model.setNsPrefix(""String_Node_Str"",RDF.getURI());
  model.setNsPrefix(""String_Node_Str"",RDFS.getURI());
  model.setNsPrefix(""String_Node_Str"",OWL.getURI());
  model.setNsPrefix(""String_Node_Str"",Tosca.getURI());
  model.setNsPrefix(""String_Node_Str"",Osco.getURI());
  model.setNsPrefix(""String_Node_Str"",""String_Node_Str"");
}",0.993975903614458
25666,"public InvalidModelException(Throwable cause){
  super(cause);
}","public InvalidModelException(final Throwable cause){
  super(cause);
}",0.9552238805970148
25667,"protected static void validateModel(List<Resource> groups) throws InvalidModelException {
  if (groups.isEmpty())   throw new InvalidModelException(""String_Node_Str"");
  if (groups.size() > 1)   throw new InvalidModelException(""String_Node_Str"");
}","protected static void validateModel(final List<Resource> groups) throws InvalidModelException {
  if (groups.isEmpty()) {
    throw new InvalidModelException(""String_Node_Str"");
  }
  if (groups.size() > 1) {
    throw new InvalidModelException(""String_Node_Str"");
  }
}",0.9575289575289576
25668,"public static String toString(String filename) throws IOException {
  String result=""String_Node_Str"";
  InputStream inputStream=AbstractConverter.class.getResourceAsStream(filename);
  BufferedReader br=new BufferedReader(new InputStreamReader(inputStream));
  String line=null;
  while ((line=br.readLine()) != null) {
    result+=line + ""String_Node_Str"";
  }
  return result;
}","public static String toString(final String filename) throws IOException {
  String result=""String_Node_Str"";
  final InputStream inputStream=AbstractConverter.class.getResourceAsStream(filename);
  final BufferedReader br=new BufferedReader(new InputStreamReader(inputStream));
  String line=null;
  while ((line=br.readLine()) != null) {
    result+=line + ""String_Node_Str"";
  }
  return result;
}",0.9769230769230768
25669,"public static String toString(Model model){
  String result=""String_Node_Str"";
  for (StmtIterator i=model.listStatements(); i.hasNext(); ) {
    Statement stmt=i.nextStatement();
    result+=PrintUtil.print(stmt);
  }
  return result;
}","public static String toString(Model model){
  String result=""String_Node_Str"";
  for (StmtIterator i=model.listStatements(); i.hasNext(); ) {
    Statement stmt=i.nextStatement();
    result+=PrintUtil.print(stmt) + NL;
  }
  return result;
}",0.9895615866388308
25670,"@Override public void validate(Object target,Errors errors){
  ConsentSignature sig=(ConsentSignature)target;
  if (Strings.isNullOrEmpty(sig.getName())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (Strings.isNullOrEmpty(sig.getBirthdate())) {
    if (minAgeOfConsent > 0) {
      errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
    }
  }
 else {
    LocalDate birthdate=parseBirthday(sig.getBirthdate());
    if (birthdate == null) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (minAgeOfConsent > 0) {
      LocalDate now=LocalDate.now();
      Period period=new Period(birthdate,now);
      if (period.getYears() < minAgeOfConsent) {
        String message=String.format(TOO_YOUNG,minAgeOfConsent);
        errors.rejectValue(""String_Node_Str"",message);
      }
    }
  }
  if (sig.getSignedOn() <= 0L) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  String imageData=sig.getImageData();
  String imageMimeType=sig.getImageMimeType();
  if (imageData != null && imageData.isEmpty()) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_EMPTY_STRING);
  }
  if (imageMimeType != null && imageMimeType.isEmpty()) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_EMPTY_STRING);
  }
  if (imageData != null ^ imageMimeType != null) {
    errors.reject(""String_Node_Str"");
  }
}","@Override public void validate(Object target,Errors errors){
  ConsentSignature sig=(ConsentSignature)target;
  if (Strings.isNullOrEmpty(sig.getName())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (Strings.isNullOrEmpty(sig.getBirthdate())) {
    if (minAgeOfConsent > 0) {
      errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
    }
  }
 else {
    LocalDate birthdate=parseBirthday(sig.getBirthdate());
    if (birthdate == null) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (minAgeOfConsent > 0) {
      LocalDate now=LocalDate.now(DateTimeZone.UTC);
      Period period=new Period(birthdate,now);
      if (period.getYears() < minAgeOfConsent) {
        String message=String.format(TOO_YOUNG,minAgeOfConsent);
        errors.rejectValue(""String_Node_Str"",message);
      }
    }
  }
  if (sig.getSignedOn() <= 0L) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  String imageData=sig.getImageData();
  String imageMimeType=sig.getImageMimeType();
  if (imageData != null && imageData.isEmpty()) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_EMPTY_STRING);
  }
  if (imageMimeType != null && imageMimeType.isEmpty()) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_EMPTY_STRING);
  }
  if (imageData != null ^ imageMimeType != null) {
    errors.reject(""String_Node_Str"");
  }
}",0.994198694706309
25671,"@Test public void minAgeLimitBirthdateOK(){
  String birthdate=DateTime.now(DateTimeZone.UTC).minusYears(18).toString();
  validator=new ConsentSignatureValidator(18);
  ConsentSignature sig=new ConsentSignature.Builder().withName(""String_Node_Str"").withBirthdate(birthdate).build();
  Validate.entityThrowingException(validator,sig);
}","@Test public void minAgeLimitBirthdateOK(){
  String birthdate=NOW.minusYears(18).toLocalDate().toString();
  validator=new ConsentSignatureValidator(18);
  ConsentSignature sig=new ConsentSignature.Builder().withName(""String_Node_Str"").withBirthdate(birthdate).build();
  Validate.entityThrowingException(validator,sig);
}",0.928679817905918
25672,"@Before public void before(){
  DateTimeUtils.setCurrentMillisFixed(DateTime.parse(""String_Node_Str"").getMillis());
  validator=new ConsentSignatureValidator(0);
}","@Before public void before(){
  DateTimeUtils.setCurrentMillisFixed(NOW.getMillis());
  validator=new ConsentSignatureValidator(0);
}",0.8851351351351351
25673,"@Test public void minAgeLimitButBirthdateTooRecent(){
  String birthdate=LocalDate.now(DateTimeZone.UTC).minusYears(18).plusDays(1).toString();
  validator=new ConsentSignatureValidator(18);
  ConsentSignature sig=new ConsentSignature.Builder().withName(""String_Node_Str"").withBirthdate(birthdate).build();
  assertValidatorMessage(validator,sig,""String_Node_Str"",""String_Node_Str"");
}","@Test public void minAgeLimitButBirthdateTooRecent(){
  String birthdate=NOW.minusYears(18).plusDays(1).toLocalDate().toString();
  validator=new ConsentSignatureValidator(18);
  ConsentSignature sig=new ConsentSignature.Builder().withName(""String_Node_Str"").withBirthdate(birthdate).build();
  assertValidatorMessage(validator,sig,""String_Node_Str"",""String_Node_Str"");
}",0.9365079365079364
25674,"public Study updateStudy(Study study,boolean isAdminUpdate){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  Study originalStudy=studyDao.getStudy(study.getIdentifier());
  checkViolationConstraints(originalStudy,study);
  if (!isAdminUpdate) {
    if (!originalStudy.isActive()) {
      throw new EntityNotFoundException(Study.class,""String_Node_Str"" + study.getIdentifier() + ""String_Node_Str"");
    }
    study.setHealthCodeExportEnabled(originalStudy.isHealthCodeExportEnabled());
    study.setEmailVerificationEnabled(originalStudy.isEmailVerificationEnabled());
    study.setExternalIdValidationEnabled(originalStudy.isExternalIdValidationEnabled());
    study.setExternalIdRequiredOnSignup(originalStudy.isExternalIdRequiredOnSignup());
    study.setEmailSignInEnabled(originalStudy.isEmailSignInEnabled());
    study.setPhoneSignInEnabled(originalStudy.isPhoneSignInEnabled());
    study.setReauthenticationEnabled(originalStudy.isReauthenticationEnabled());
    study.setAccountLimit(originalStudy.getAccountLimit());
    study.setStudyIdExcludedInExport(originalStudy.isStudyIdExcludedInExport());
  }
  if (originalStudy.isActive() && !study.isActive()) {
    throw new BadRequestException(""String_Node_Str"");
  }
  setDefaultsIfAbsent(study);
  sanitizeHTML(study);
  Validate.entityThrowingException(validator,study);
  if (originalStudy.isConsentNotificationEmailVerified() == null) {
    study.setConsentNotificationEmailVerified(true);
  }
 else   if (!originalStudy.isConsentNotificationEmailVerified()) {
    study.setConsentNotificationEmailVerified(false);
  }
  boolean consentHasChanged=!Objects.equals(originalStudy.getConsentNotificationEmail(),study.getConsentNotificationEmail());
  if (consentHasChanged) {
    study.setConsentNotificationEmailVerified(false);
  }
  if (!isAdminUpdate) {
    checkUploadMetadataConstraints(originalStudy,study);
  }
  Study updatedStudy=updateAndCacheStudy(study);
  if (!originalStudy.getSupportEmail().equals(study.getSupportEmail())) {
    emailVerificationService.verifyEmailAddress(study.getSupportEmail());
  }
  if (consentHasChanged && study.getConsentNotificationEmail() != null) {
    sendVerifyEmail(study,StudyEmailType.CONSENT_NOTIFICATION);
  }
  return updatedStudy;
}","public Study updateStudy(Study study,boolean isAdminUpdate){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  Study originalStudy=studyDao.getStudy(study.getIdentifier());
  checkViolationConstraints(originalStudy,study);
  if (!isAdminUpdate) {
    if (!originalStudy.isActive()) {
      throw new EntityNotFoundException(Study.class,""String_Node_Str"" + study.getIdentifier() + ""String_Node_Str"");
    }
    study.setHealthCodeExportEnabled(originalStudy.isHealthCodeExportEnabled());
    study.setEmailVerificationEnabled(originalStudy.isEmailVerificationEnabled());
    study.setExternalIdValidationEnabled(originalStudy.isExternalIdValidationEnabled());
    study.setExternalIdRequiredOnSignup(originalStudy.isExternalIdRequiredOnSignup());
    study.setEmailSignInEnabled(originalStudy.isEmailSignInEnabled());
    study.setPhoneSignInEnabled(originalStudy.isPhoneSignInEnabled());
    study.setReauthenticationEnabled(originalStudy.isReauthenticationEnabled());
    study.setAccountLimit(originalStudy.getAccountLimit());
    study.setStudyIdExcludedInExport(originalStudy.isStudyIdExcludedInExport());
  }
  if (originalStudy.isActive() && !study.isActive()) {
    throw new BadRequestException(""String_Node_Str"");
  }
  setDefaultsIfAbsent(study);
  sanitizeHTML(study);
  Validate.entityThrowingException(validator,study);
  if (originalStudy.isConsentNotificationEmailVerified() == null) {
    study.setConsentNotificationEmailVerified(true);
  }
 else   if (!originalStudy.isConsentNotificationEmailVerified()) {
    study.setConsentNotificationEmailVerified(false);
  }
  boolean consentHasChanged=!Objects.equals(originalStudy.getConsentNotificationEmail(),study.getConsentNotificationEmail());
  if (consentHasChanged) {
    study.setConsentNotificationEmailVerified(false);
  }
  if (!isAdminUpdate) {
    checkUploadMetadataConstraints(originalStudy,study);
  }
  Study updatedStudy=updateAndCacheStudy(study);
  if (!originalStudy.getSupportEmail().equals(study.getSupportEmail())) {
    emailVerificationService.verifyEmailAddress(study.getSupportEmail());
  }
  if (consentHasChanged && StringUtils.isNotBlank(study.getConsentNotificationEmail())) {
    sendVerifyEmail(study,StudyEmailType.CONSENT_NOTIFICATION);
  }
  return updatedStudy;
}",0.9929546455306032
25675,"@Test public void updateStudyCorrectlyDetectsEmailChangesInvolvingNulls(){
  String originalEmail=TestUtils.getValidStudy(StudyServiceMockTest.class).getConsentNotificationEmail();
  String newEmail=""String_Node_Str"";
  setupConsentEmailChangeTest(null,null,false,false);
  setupConsentEmailChangeTest(originalEmail,originalEmail,false,false);
  setupConsentEmailChangeTest(null,newEmail,true,true);
  setupConsentEmailChangeTest(originalEmail,null,true,false);
  setupConsentEmailChangeTest(originalEmail,newEmail,true,true);
}","@Test public void updateStudyCorrectlyDetectsEmailChangesInvolvingNulls(){
  String originalEmail=TestUtils.getValidStudy(StudyServiceMockTest.class).getConsentNotificationEmail();
  String newEmail=""String_Node_Str"";
  setupConsentEmailChangeTest(null,null,false,false);
  setupConsentEmailChangeTest(originalEmail,originalEmail,false,false);
  setupConsentEmailChangeTest(null,newEmail,true,true);
  setupConsentEmailChangeTest(originalEmail,null,true,false);
  setupConsentEmailChangeTest(originalEmail,newEmail,true,true);
  setupConsentEmailChangeTest(originalEmail,""String_Node_Str"",true,false);
}",0.93368700265252
25676,"public static final CacheKey viewKey(Class<?> clazz,String... elements){
  List<String> list=Lists.newArrayList(elements);
  list.add(clazz.getSimpleName());
  list.add(""String_Node_Str"");
  return new CacheKey(COLON_JOINER.join(elements));
}","public static final CacheKey viewKey(Class<?> clazz,String... elements){
  List<String> list=Lists.newArrayList(elements);
  list.add(clazz.getSimpleName());
  list.add(""String_Node_Str"");
  return new CacheKey(COLON_JOINER.join(list));
}",0.975
25677,"/** 
 * Request a token to be sent via a link in an email message, that can be used to start a session on the Bridge server.  The installed application should intercept this link in order to complete the transaction within the app, where the  returned session can be captured. If the link is not captured, it retrieves a test page on the Bridge server as  configured by default. That test page will complete the transaction and return a session token.
 */
public void requestEmailSignIn(SignIn signIn){
  requestChannelSignIn(EMAIL,EMAIL_SIGNIN_REQUEST,EMAIL_CACHE_KEY_FUNC,emailSignInRequestInMillis,signIn,true,this::getNextToken,(study,token) -> {
    String url=getEmailSignInURL(signIn.getEmail(),study.getIdentifier(),token);
    String shortUrl=getShortEmailSignInURL(signIn.getEmail(),study.getIdentifier(),token);
    BasicEmailProvider provider=new BasicEmailProvider.Builder().withEmailTemplate(study.getEmailSignInTemplate()).withStudy(study).withRecipientEmail(signIn.getEmail()).withToken(EMAIL_KEY,BridgeUtils.encodeURIComponent(signIn.getEmail())).withToken(TOKEN_KEY,token).withToken(OLD_URL_KEY,url).withToken(OLD_SHORT_URL_KEY,shortUrl).withToken(EMAIL_SIGNIN_URL_KEY,shortUrl).withExpirationPeriod(EMAIL_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS).build();
    sendMailService.sendEmail(provider);
  }
);
}","/** 
 * Request a token to be sent via a link in an email message, that can be used to start a session on the Bridge server.  The installed application should intercept this link in order to complete the transaction within the app, where the  returned session can be captured. If the link is not captured, it retrieves a test page on the Bridge server as  configured by default. That test page will complete the transaction and return a session token.
 */
public void requestEmailSignIn(SignIn signIn){
  requestChannelSignIn(EMAIL,EMAIL_SIGNIN_REQUEST,emailSignInRequestInMillis,signIn,true,this::getNextToken,(study,token) -> {
    String url=getEmailSignInURL(signIn.getEmail(),study.getIdentifier(),token);
    String shortUrl=getShortEmailSignInURL(signIn.getEmail(),study.getIdentifier(),token);
    BasicEmailProvider provider=new BasicEmailProvider.Builder().withEmailTemplate(study.getEmailSignInTemplate()).withStudy(study).withRecipientEmail(signIn.getEmail()).withToken(EMAIL_KEY,BridgeUtils.encodeURIComponent(signIn.getEmail())).withToken(TOKEN_KEY,token).withToken(OLD_URL_KEY,url).withToken(OLD_SHORT_URL_KEY,shortUrl).withToken(EMAIL_SIGNIN_URL_KEY,shortUrl).withExpirationPeriod(EMAIL_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS).build();
    sendMailService.sendEmail(provider);
  }
);
}",0.9920604914933836
25678,"private void requestChannelSignIn(ChannelType channelType,Validator validator,Function<SignIn,CacheKey> cacheKeySupplier,AtomicLong atomicLong,SignIn signIn,boolean shouldThrottle,Supplier<String> tokenSupplier,BiConsumer<Study,String> messageSender){
  long startTime=System.currentTimeMillis();
  Validate.entityThrowingException(validator,signIn);
  Study study=studyService.getStudy(signIn.getStudyId());
  if (channelType == EMAIL && !study.isEmailSignInEnabled()) {
    throw new UnauthorizedException(""String_Node_Str"" + study.getName());
  }
 else   if (channelType == PHONE && !study.isPhoneSignInEnabled()) {
    throw new UnauthorizedException(""String_Node_Str"" + study.getName());
  }
  Account account=accountDao.getAccount(signIn.getAccountId());
  if (account == null) {
    try {
      TimeUnit.MILLISECONDS.sleep(atomicLong.get());
    }
 catch (    InterruptedException e) {
    }
    return;
  }
  ThrottleRequestType throttleType=channelType == EMAIL ? ThrottleRequestType.EMAIL_SIGNIN : ThrottleRequestType.PHONE_SIGNIN;
  if (shouldThrottle && isRequestThrottled(throttleType,account.getId())) {
    return;
  }
  CacheKey cacheKey=cacheKeySupplier.apply(signIn);
  String token=cacheProvider.getObject(cacheKey,String.class);
  if (token == null) {
    token=tokenSupplier.get();
    cacheProvider.setObject(cacheKey,token,SIGNIN_EXPIRE_IN_SECONDS);
  }
  messageSender.accept(study,token);
  atomicLong.set(System.currentTimeMillis() - startTime);
}","private void requestChannelSignIn(ChannelType channelType,Validator validator,AtomicLong atomicLong,SignIn signIn,boolean shouldThrottle,Supplier<String> tokenSupplier,BiConsumer<Study,String> messageSender){
  long startTime=System.currentTimeMillis();
  Validate.entityThrowingException(validator,signIn);
  Study study=studyService.getStudy(signIn.getStudyId());
  if (channelType == EMAIL && !study.isEmailSignInEnabled()) {
    throw new UnauthorizedException(""String_Node_Str"" + study.getName());
  }
 else   if (channelType == PHONE && !study.isPhoneSignInEnabled()) {
    throw new UnauthorizedException(""String_Node_Str"" + study.getName());
  }
  Account account=accountDao.getAccount(signIn.getAccountId());
  if (account == null) {
    try {
      TimeUnit.MILLISECONDS.sleep(atomicLong.get());
    }
 catch (    InterruptedException e) {
    }
    return;
  }
  ThrottleRequestType throttleType=channelType == EMAIL ? ThrottleRequestType.EMAIL_SIGNIN : ThrottleRequestType.PHONE_SIGNIN;
  if (shouldThrottle && isRequestThrottled(throttleType,account.getId())) {
    return;
  }
  CacheKey cacheKey=null;
  if (channelType == EMAIL) {
    cacheKey=CacheKeys.emailSignInRequest(signIn);
  }
 else   if (channelType == PHONE) {
    cacheKey=CacheKeys.phoneSignInRequest(signIn);
  }
  String token=cacheProvider.getObject(cacheKey,String.class);
  if (token == null) {
    token=tokenSupplier.get();
    cacheProvider.setObject(cacheKey,token,SIGNIN_EXPIRE_IN_SECONDS);
  }
  messageSender.accept(study,token);
  atomicLong.set(System.currentTimeMillis() - startTime);
}",0.9217163445791026
25679,"private void sendPasswordResetRelatedSMS(Study study,Phone phone,boolean includePhoneSignIn,SmsTemplate template){
  String sptoken=getNextToken();
  CacheKey cacheKey=CacheKeys.passwordResetForPhone(sptoken,study.getIdentifier());
  cacheProvider.setObject(cacheKey,getPhoneString(phone),VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  String url=getShortResetPasswordURL(study,sptoken);
  SmsMessageProvider.Builder builder=new SmsMessageProvider.Builder();
  builder.withSmsTemplate(template);
  builder.withStudy(study);
  builder.withPhone(phone);
  builder.withToken(SPTOKEN_KEY,sptoken);
  builder.withToken(RESET_PASSWORD_URL_KEY,url);
  builder.withExpirationPeriod(RESET_PASSWORD_EXPIRATION_PERIOD,VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  if (includePhoneSignIn) {
    SignIn signIn=new SignIn.Builder().withPhone(phone).withStudy(study.getIdentifier()).build();
    requestChannelSignIn(PHONE,PHONE_SIGNIN_REQUEST,PHONE_CACHE_KEY_FUNC,phoneSignInRequestInMillis,signIn,false,this::getNextToken,(theStudy,token) -> {
      String formattedToken=token.substring(0,3) + ""String_Node_Str"" + token.substring(3,6);
      builder.withToken(TOKEN_KEY,formattedToken);
      builder.withExpirationPeriod(PHONE_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS);
    }
);
  }
  notificationsService.sendSmsMessage(builder.build());
}","private void sendPasswordResetRelatedSMS(Study study,Phone phone,boolean includePhoneSignIn,SmsTemplate template){
  String sptoken=getNextToken();
  CacheKey cacheKey=CacheKeys.passwordResetForPhone(sptoken,study.getIdentifier());
  cacheProvider.setObject(cacheKey,getPhoneString(phone),VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  String url=getShortResetPasswordURL(study,sptoken);
  SmsMessageProvider.Builder builder=new SmsMessageProvider.Builder();
  builder.withSmsTemplate(template);
  builder.withStudy(study);
  builder.withPhone(phone);
  builder.withToken(SPTOKEN_KEY,sptoken);
  builder.withToken(RESET_PASSWORD_URL_KEY,url);
  builder.withExpirationPeriod(RESET_PASSWORD_EXPIRATION_PERIOD,VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  if (includePhoneSignIn) {
    SignIn signIn=new SignIn.Builder().withPhone(phone).withStudy(study.getIdentifier()).build();
    requestChannelSignIn(PHONE,PHONE_SIGNIN_REQUEST,phoneSignInRequestInMillis,signIn,false,this::getNextToken,(theStudy,token) -> {
      String formattedToken=token.substring(0,3) + ""String_Node_Str"" + token.substring(3,6);
      builder.withToken(TOKEN_KEY,formattedToken);
      builder.withExpirationPeriod(PHONE_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS);
    }
);
  }
  notificationsService.sendSmsMessage(builder.build());
}",0.9919877909194964
25680,"/** 
 * Attempts to validate a sign in request using a token that was stored and then sent  via SMS or an email message. 
 * @return AccountId the accountId of the account if the sign in is successful.
 * @throws AuthenticationFailedException if the token is missing or invalid (not a successful sign in attempt).
 */
public AccountId channelSignIn(ChannelType channelType,CriteriaContext context,SignIn signIn,Validator validator){
  Validate.entityThrowingException(validator,signIn);
  CacheKey cacheKey=null;
  if (channelType == EMAIL) {
    cacheKey=EMAIL_CACHE_KEY_FUNC.apply(signIn);
  }
 else   if (channelType == PHONE) {
    cacheKey=PHONE_CACHE_KEY_FUNC.apply(signIn);
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  String storedToken=cacheProvider.getObject(cacheKey,String.class);
  if (storedToken == null || !storedToken.equals(signIn.getToken())) {
    throw new AuthenticationFailedException();
  }
  cacheProvider.removeObject(cacheKey);
  return signIn.getAccountId();
}","/** 
 * Attempts to validate a sign in request using a token that was stored and then sent  via SMS or an email message. 
 * @return AccountId the accountId of the account if the sign in is successful.
 * @throws AuthenticationFailedException if the token is missing or invalid (not a successful sign in attempt).
 */
public AccountId channelSignIn(ChannelType channelType,CriteriaContext context,SignIn signIn,Validator validator){
  Validate.entityThrowingException(validator,signIn);
  CacheKey cacheKey=null;
  if (channelType == EMAIL) {
    cacheKey=CacheKeys.emailSignInRequest(signIn);
  }
 else   if (channelType == PHONE) {
    cacheKey=CacheKeys.phoneSignInRequest(signIn);
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  String storedToken=cacheProvider.getObject(cacheKey,String.class);
  if (storedToken == null || !storedToken.equals(signIn.getToken())) {
    throw new AuthenticationFailedException();
  }
  cacheProvider.removeObject(cacheKey);
  return signIn.getAccountId();
}",0.9513145082765336
25681,"/** 
 * Request a token to be sent via SMS to the user, that can be used to start a session on the Bridge server.
 */
public void requestPhoneSignIn(SignIn signIn){
  requestChannelSignIn(PHONE,PHONE_SIGNIN_REQUEST,PHONE_CACHE_KEY_FUNC,phoneSignInRequestInMillis,signIn,true,this::getNextPhoneToken,(study,token) -> {
    String formattedToken=token.substring(0,3) + ""String_Node_Str"" + token.substring(3,6);
    SmsMessageProvider provider=new SmsMessageProvider.Builder().withStudy(study).withSmsTemplate(study.getPhoneSignInSmsTemplate()).withPhone(signIn.getPhone()).withExpirationPeriod(PHONE_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS).withToken(TOKEN_KEY,formattedToken).build();
    notificationsService.sendSmsMessage(provider);
  }
);
}","/** 
 * Request a token to be sent via SMS to the user, that can be used to start a session on the Bridge server.
 */
public void requestPhoneSignIn(SignIn signIn){
  requestChannelSignIn(PHONE,PHONE_SIGNIN_REQUEST,phoneSignInRequestInMillis,signIn,true,this::getNextPhoneToken,(study,token) -> {
    String formattedToken=token.substring(0,3) + ""String_Node_Str"" + token.substring(3,6);
    SmsMessageProvider provider=new SmsMessageProvider.Builder().withStudy(study).withSmsTemplate(study.getPhoneSignInSmsTemplate()).withPhone(signIn.getPhone()).withExpirationPeriod(PHONE_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS).withToken(TOKEN_KEY,formattedToken).build();
    notificationsService.sendSmsMessage(provider);
  }
);
}",0.5063973063973064
25682,"private void sendPasswordResetRelatedEmail(Study study,String email,boolean includeEmailSignIn,EmailTemplate template){
  String sptoken=getNextToken();
  CacheKey cacheKey=CacheKeys.passwordResetForEmail(sptoken,study.getIdentifier());
  cacheProvider.setObject(cacheKey,email,VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  String url=getResetPasswordURL(study,sptoken);
  String shortUrl=getShortResetPasswordURL(study,sptoken);
  BasicEmailProvider.Builder builder=new BasicEmailProvider.Builder().withStudy(study).withEmailTemplate(template).withRecipientEmail(email).withToken(SPTOKEN_KEY,sptoken).withToken(OLD_URL_KEY,url).withToken(OLD_SHORT_URL_KEY,shortUrl).withToken(OLD_EXP_WINDOW_TOKEN,Integer.toString(VERIFY_OR_RESET_EXPIRE_IN_SECONDS / 60 / 60)).withExpirationPeriod(OLD_EXPIRATION_PERIOD,VERIFY_OR_RESET_EXPIRE_IN_SECONDS).withToken(RESET_PASSWORD_URL_KEY,shortUrl).withExpirationPeriod(RESET_PASSWORD_EXPIRATION_PERIOD,VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  if (includeEmailSignIn && study.isEmailSignInEnabled()) {
    SignIn signIn=new SignIn.Builder().withEmail(email).withStudy(study.getIdentifier()).build();
    requestChannelSignIn(EMAIL,EMAIL_SIGNIN_REQUEST,EMAIL_CACHE_KEY_FUNC,emailSignInRequestInMillis,signIn,false,this::getNextToken,(theStudy,token) -> {
      String emailShortUrl=getShortEmailSignInURL(signIn.getEmail(),theStudy.getIdentifier(),token);
      builder.withToken(EMAIL_KEY,BridgeUtils.encodeURIComponent(signIn.getEmail()));
      builder.withToken(TOKEN_KEY,token);
      builder.withToken(OLD_SHORT_URL_KEY,emailShortUrl);
      builder.withToken(EMAIL_SIGNIN_URL_KEY,emailShortUrl);
      builder.withExpirationPeriod(EMAIL_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS);
    }
);
  }
  sendMailService.sendEmail(builder.build());
}","private void sendPasswordResetRelatedEmail(Study study,String email,boolean includeEmailSignIn,EmailTemplate template){
  String sptoken=getNextToken();
  CacheKey cacheKey=CacheKeys.passwordResetForEmail(sptoken,study.getIdentifier());
  cacheProvider.setObject(cacheKey,email,VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  String url=getResetPasswordURL(study,sptoken);
  String shortUrl=getShortResetPasswordURL(study,sptoken);
  BasicEmailProvider.Builder builder=new BasicEmailProvider.Builder().withStudy(study).withEmailTemplate(template).withRecipientEmail(email).withToken(SPTOKEN_KEY,sptoken).withToken(OLD_URL_KEY,url).withToken(OLD_SHORT_URL_KEY,shortUrl).withToken(OLD_EXP_WINDOW_TOKEN,Integer.toString(VERIFY_OR_RESET_EXPIRE_IN_SECONDS / 60 / 60)).withExpirationPeriod(OLD_EXPIRATION_PERIOD,VERIFY_OR_RESET_EXPIRE_IN_SECONDS).withToken(RESET_PASSWORD_URL_KEY,shortUrl).withExpirationPeriod(RESET_PASSWORD_EXPIRATION_PERIOD,VERIFY_OR_RESET_EXPIRE_IN_SECONDS);
  if (includeEmailSignIn && study.isEmailSignInEnabled()) {
    SignIn signIn=new SignIn.Builder().withEmail(email).withStudy(study.getIdentifier()).build();
    requestChannelSignIn(EMAIL,EMAIL_SIGNIN_REQUEST,emailSignInRequestInMillis,signIn,false,this::getNextToken,(theStudy,token) -> {
      String emailShortUrl=getShortEmailSignInURL(signIn.getEmail(),theStudy.getIdentifier(),token);
      builder.withToken(EMAIL_KEY,BridgeUtils.encodeURIComponent(signIn.getEmail()));
      builder.withToken(TOKEN_KEY,token);
      builder.withToken(OLD_SHORT_URL_KEY,emailShortUrl);
      builder.withToken(EMAIL_SIGNIN_URL_KEY,emailShortUrl);
      builder.withExpirationPeriod(EMAIL_SIGNIN_EXPIRATION_PERIOD,SIGNIN_EXPIRE_IN_SECONDS);
    }
);
  }
  sendMailService.sendEmail(builder.build());
}",0.7127087461081234
25683,"@Before public void before(){
  DateTimeUtils.setCurrentMillisFixed(NOW.getMillis());
  BridgeConfig mockConfig=mock(BridgeConfig.class);
  when(mockConfig.get(""String_Node_Str"")).thenReturn(BridgeConfigFactory.getConfig().get(""String_Node_Str""));
  when(mockConfig.getEnvironment()).thenReturn(Environment.UAT);
  controller=spy(new AuthenticationController());
  controller.setBridgeConfig(mockConfig);
  controller.setAuthenticationService(authenticationService);
  controller.setCacheProvider(cacheProvider);
  controller.setAccountWorkflowService(accountWorkflowService);
  userSession=new UserSession();
  userSession.setReauthToken(REAUTH_TOKEN);
  userSession.setSessionToken(TEST_SESSION_TOKEN);
  userSession.setParticipant(new StudyParticipant.Builder().withId(TEST_ACCOUNT_ID).build());
  userSession.setInternalSessionToken(TEST_INTERNAL_SESSION_ID);
  userSession.setStudyIdentifier(TEST_STUDY_ID);
  study=new DynamoStudy();
  study.setIdentifier(TEST_STUDY_ID_STRING);
  study.setDataGroups(TestConstants.USER_DATA_GROUPS);
  when(studyService.getStudy(TEST_STUDY_ID_STRING)).thenReturn(study);
  when(studyService.getStudy(TEST_STUDY_ID)).thenReturn(study);
  controller.setStudyService(studyService);
  doReturn(metrics).when(controller).getMetrics();
}","@Before public void before(){
  DateTimeUtils.setCurrentMillisFixed(NOW.getMillis());
  BridgeConfig mockConfig=mock(BridgeConfig.class);
  when(mockConfig.get(""String_Node_Str"")).thenReturn(WEBSERVICES_URL);
  when(mockConfig.getEnvironment()).thenReturn(Environment.UAT);
  controller=spy(new AuthenticationController());
  controller.setBridgeConfig(mockConfig);
  controller.setAuthenticationService(authenticationService);
  controller.setCacheProvider(cacheProvider);
  controller.setAccountWorkflowService(accountWorkflowService);
  userSession=new UserSession();
  userSession.setReauthToken(REAUTH_TOKEN);
  userSession.setSessionToken(TEST_SESSION_TOKEN);
  userSession.setParticipant(new StudyParticipant.Builder().withId(TEST_ACCOUNT_ID).build());
  userSession.setInternalSessionToken(TEST_INTERNAL_SESSION_ID);
  userSession.setStudyIdentifier(TEST_STUDY_ID);
  study=new DynamoStudy();
  study.setIdentifier(TEST_STUDY_ID_STRING);
  study.setDataGroups(TestConstants.USER_DATA_GROUPS);
  when(studyService.getStudy(TEST_STUDY_ID_STRING)).thenReturn(study);
  when(studyService.getStudy(TEST_STUDY_ID)).thenReturn(study);
  controller.setStudyService(studyService);
  doReturn(metrics).when(controller).getMetrics();
}",0.9732321214542548
25684,"private void verifyCommonLoggingForSignIns() throws Exception {
  verifyMetrics();
  verify(response).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,TEST_SESSION_TOKEN,BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",BridgeConfigFactory.getConfig().get(""String_Node_Str""),true,true);
  verify(cacheProvider).updateRequestInfo(requestInfoCaptor.capture());
  RequestInfo info=requestInfoCaptor.getValue();
  assertEquals(NOW.getMillis(),info.getSignedInOn().getMillis());
}","private void verifyCommonLoggingForSignIns() throws Exception {
  verifyMetrics();
  verify(response).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,TEST_SESSION_TOKEN,BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",WEBSERVICES_URL,true,true);
  verify(cacheProvider).updateRequestInfo(requestInfoCaptor.capture());
  RequestInfo info=requestInfoCaptor.getValue();
  assertEquals(NOW.getMillis(),info.getSignedInOn().getMillis());
}",0.9287991498405952
25685,"@Test public void signInOnLocalDoesNotSetCookieWithSSL() throws Exception {
  String json=TestUtils.createJson(""String_Node_Str"" + TEST_STUDY_ID_STRING + ""String_Node_Str"");
  response=mockPlayContextWithJson(json);
  when(controller.bridgeConfig.getEnvironment()).thenReturn(Environment.LOCAL);
  when(controller.bridgeConfig.get(""String_Node_Str"")).thenReturn(""String_Node_Str"");
  UserSession session=createSession(null,null);
  when(authenticationService.signIn(any(),any(),any())).thenReturn(session);
  controller.signIn();
  verify(response).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,TEST_SESSION_TOKEN,BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",BridgeConfigFactory.getConfig().get(""String_Node_Str""),false,false);
}","@Test public void signInOnLocalDoesNotSetCookieWithSSL() throws Exception {
  String json=TestUtils.createJson(""String_Node_Str"" + TEST_STUDY_ID_STRING + ""String_Node_Str"");
  response=mockPlayContextWithJson(json);
  when(controller.bridgeConfig.getEnvironment()).thenReturn(Environment.LOCAL);
  UserSession session=createSession(null,null);
  when(authenticationService.signIn(any(),any(),any())).thenReturn(session);
  controller.signIn();
  verify(response).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,TEST_SESSION_TOKEN,BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",WEBSERVICES_URL,false,false);
}",0.8803480783176215
25686,"@Test public void ifClientSendsCookieRetrieveAndResetIt(){
  Http.Cookie mockCookie=mock(Http.Cookie.class);
  doReturn(""String_Node_Str"").when(mockCookie).value();
  Http.Request mockRequest=mock(Http.Request.class);
  doReturn(mockCookie).when(mockRequest).cookie(BridgeConstants.SESSION_TOKEN_HEADER);
  Http.Context context=mock(Http.Context.class);
  when(context.request()).thenReturn(mockRequest);
  Http.Response mockResponse=mock(Http.Response.class);
  when(context.response()).thenReturn(mockResponse);
  Http.Context.current.set(context);
  BaseController controller=new SchedulePlanController();
  controller.setBridgeConfig(BridgeConfigFactory.getConfig());
  String token=controller.getSessionToken();
  assertEquals(""String_Node_Str"",token);
  verify(mockResponse).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,""String_Node_Str"",BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",BridgeConfigFactory.getConfig().get(""String_Node_Str""),false,false);
}","@Test public void ifClientSendsCookieRetrieveAndResetIt(){
  Http.Cookie mockCookie=mock(Http.Cookie.class);
  doReturn(""String_Node_Str"").when(mockCookie).value();
  Http.Request mockRequest=mock(Http.Request.class);
  doReturn(mockCookie).when(mockRequest).cookie(BridgeConstants.SESSION_TOKEN_HEADER);
  Http.Context context=mock(Http.Context.class);
  when(context.request()).thenReturn(mockRequest);
  Http.Response mockResponse=mock(Http.Response.class);
  when(context.response()).thenReturn(mockResponse);
  Http.Context.current.set(context);
  BridgeConfig mockConfig=mock(BridgeConfig.class);
  when(mockConfig.get(""String_Node_Str"")).thenReturn(WEBSERVICE_URL);
  when(mockConfig.getEnvironment()).thenReturn(Environment.LOCAL);
  BaseController controller=new SchedulePlanController();
  controller.setBridgeConfig(mockConfig);
  String token=controller.getSessionToken();
  assertEquals(""String_Node_Str"",token);
  verify(mockResponse).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,""String_Node_Str"",BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",WEBSERVICE_URL,false,false);
}",0.836676217765043
25687,"@Test public void requireSslOnCookies(){
  Http.Cookie mockCookie=mock(Http.Cookie.class);
  doReturn(""String_Node_Str"").when(mockCookie).value();
  Http.Request mockRequest=mock(Http.Request.class);
  doReturn(mockCookie).when(mockRequest).cookie(BridgeConstants.SESSION_TOKEN_HEADER);
  Http.Context context=mock(Http.Context.class);
  when(context.request()).thenReturn(mockRequest);
  Http.Response mockResponse=mock(Http.Response.class);
  when(context.response()).thenReturn(mockResponse);
  Http.Context.current.set(context);
  BaseController controller=new SchedulePlanController();
  BridgeConfig mockConfig=mock(BridgeConfig.class);
  when(mockConfig.get(""String_Node_Str"")).thenReturn(BridgeConfigFactory.getConfig().get(""String_Node_Str""));
  when(mockConfig.getEnvironment()).thenReturn(Environment.PROD);
  controller.setBridgeConfig(mockConfig);
  String token=controller.getSessionToken();
  assertEquals(""String_Node_Str"",token);
  verify(mockResponse).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,""String_Node_Str"",BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",BridgeConfigFactory.getConfig().get(""String_Node_Str""),true,true);
}","@Test public void requireSslOnCookies(){
  Http.Cookie mockCookie=mock(Http.Cookie.class);
  doReturn(""String_Node_Str"").when(mockCookie).value();
  Http.Request mockRequest=mock(Http.Request.class);
  doReturn(mockCookie).when(mockRequest).cookie(BridgeConstants.SESSION_TOKEN_HEADER);
  Http.Context context=mock(Http.Context.class);
  when(context.request()).thenReturn(mockRequest);
  Http.Response mockResponse=mock(Http.Response.class);
  when(context.response()).thenReturn(mockResponse);
  Http.Context.current.set(context);
  BaseController controller=new SchedulePlanController();
  BridgeConfig mockConfig=mock(BridgeConfig.class);
  when(mockConfig.get(""String_Node_Str"")).thenReturn(WEBSERVICE_URL);
  when(mockConfig.getEnvironment()).thenReturn(Environment.PROD);
  controller.setBridgeConfig(mockConfig);
  String token=controller.getSessionToken();
  assertEquals(""String_Node_Str"",token);
  verify(mockResponse).setCookie(BridgeConstants.SESSION_TOKEN_HEADER,""String_Node_Str"",BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS,""String_Node_Str"",WEBSERVICE_URL,true,true);
}",0.9415929203539825
25688,"public void verifyExternalIdentifier(ExternalIdentifier externalId) throws Exception {
  checkNotNull(externalId);
  if (isBlank(externalId.getIdentifier())) {
    throw new InvalidEntityException(externalId);
  }
  fphsDao.verifyExternalId(externalId);
}","public void verifyExternalIdentifier(ExternalIdentifier externalId) throws Exception {
  checkNotNull(externalId);
  if (isBlank(externalId.getIdentifier())) {
    throw new InvalidEntityException(externalId,""String_Node_Str"");
  }
  fphsDao.verifyExternalId(externalId);
}",0.9659090909090908
25689,"public void registerExternalIdentifier(StudyIdentifier studyId,String healthCode,ExternalIdentifier externalId) throws Exception {
  checkNotNull(studyId);
  checkNotNull(healthCode);
  checkNotNull(externalId);
  if (isBlank(externalId.getIdentifier())) {
    throw new InvalidEntityException(externalId);
  }
  verifyExternalIdentifier(externalId);
  Set<String> dataGroups=optionsService.getOptions(healthCode).getStringSet(DATA_GROUPS);
  dataGroups.add(""String_Node_Str"");
  optionsService.setString(studyId,healthCode,EXTERNAL_IDENTIFIER,externalId.getIdentifier());
  optionsService.setStringSet(studyId,healthCode,DATA_GROUPS,dataGroups);
  fphsDao.registerExternalId(externalId);
}","public void registerExternalIdentifier(StudyIdentifier studyId,String healthCode,ExternalIdentifier externalId) throws Exception {
  checkNotNull(studyId);
  checkNotNull(healthCode);
  checkNotNull(externalId);
  if (isBlank(externalId.getIdentifier())) {
    throw new InvalidEntityException(externalId,""String_Node_Str"");
  }
  verifyExternalIdentifier(externalId);
  Set<String> dataGroups=optionsService.getOptions(healthCode).getStringSet(DATA_GROUPS);
  dataGroups.add(""String_Node_Str"");
  optionsService.setString(studyId,healthCode,EXTERNAL_IDENTIFIER,externalId.getIdentifier());
  optionsService.setStringSet(studyId,healthCode,DATA_GROUPS,dataGroups);
  fphsDao.registerExternalId(externalId);
}",0.9871244635193132
25690,"@JsonCreator public EmailTemplate(@JsonProperty(""String_Node_Str"") String subject,@JsonProperty(""String_Node_Str"") String body,@JsonProperty(""String_Node_Str"") MimeType mimeType){
  this.subject=subject;
  this.mimeType=mimeType;
  this.body=body;
}","@JsonCreator public EmailTemplate(@JsonProperty(""String_Node_Str"") String subject,@JsonProperty(""String_Node_Str"") String body,@JsonProperty(""String_Node_Str"") MimeType mimeType){
  this.subject=subject;
  this.mimeType=(mimeType == null) ? MimeType.HTML : mimeType;
  this.body=body;
}",0.930841121495327
25691,"@Test public void bridgeServiceExceptionCorrectlyReported() throws Throwable {
  Study study=new DynamoStudy();
  try {
    Validate.entityThrowingException(new StudyValidator(),study);
    fail(""String_Node_Str"");
  }
 catch (  InvalidEntityException e) {
    MethodInvocation invocation=mock(MethodInvocation.class);
    when(invocation.proceed()).thenThrow(e);
    Result result=(Result)interceptor.invoke(invocation);
    JsonNode node=new ObjectMapper().readTree(contentAsString(result));
    assertEquals(6,node.size());
    assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").get(""String_Node_Str"").get(0).asText());
    assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
    assertNotNull(node.get(""String_Node_Str""));
    assertNotNull(node.get(""String_Node_Str""));
    assertNotNull(node.get(""String_Node_Str""));
    assertStatusCode(400,result,node);
  }
}","@Test public void bridgeServiceExceptionCorrectlyReported() throws Throwable {
  Study study=new DynamoStudy();
  try {
    Validate.entityThrowingException(new StudyValidator(),study);
    fail(""String_Node_Str"");
  }
 catch (  InvalidEntityException e) {
    MethodInvocation invocation=mock(MethodInvocation.class);
    when(invocation.proceed()).thenThrow(e);
    Result result=(Result)interceptor.invoke(invocation);
    JsonNode node=new ObjectMapper().readTree(contentAsString(result));
    assertEquals(5,node.size());
    assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").get(""String_Node_Str"").get(0).asText());
    assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
    assertNotNull(node.get(""String_Node_Str""));
    assertNotNull(node.get(""String_Node_Str""));
    assertStatusCode(400,result,node);
  }
}",0.9712313003452244
25692,"/** 
 * Get paged results of scheduled activities by an activity GUID.
 */
ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistoryV2(String healthCode,String activityGuid,DateTime scheduledOnStart,DateTime scheduledOnEnd,String offsetBy,int pageSize);","/** 
 * Get paged results of scheduled activities by an activity GUID.
 */
ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistoryV2(String healthCode,String activityGuid,DateTime scheduledOnStart,DateTime scheduledOnEnd,DateTimeZone timezone,String offsetBy,int pageSize);",0.96
25693,"@Override public ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistoryV2(String healthCode,String activityGuid,DateTime scheduledOnStart,DateTime scheduledOnEnd,String offsetBy,int pageSize){
  checkNotNull(healthCode);
  checkNotNull(scheduledOnStart);
  checkNotNull(scheduledOnEnd);
  checkNotNull(activityGuid);
  if (pageSize < API_MINIMUM_PAGE_SIZE || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  DynamoScheduledActivity hashKey=new DynamoScheduledActivity();
  hashKey.setHealthCode(healthCode);
  String start=activityGuid + ""String_Node_Str"" + scheduledOnStart.toLocalDateTime().toString();
  String end=activityGuid + ""String_Node_Str"" + scheduledOnEnd.toLocalDateTime().toString();
  Condition dateCondition=new Condition().withComparisonOperator(ComparisonOperator.BETWEEN).withAttributeValueList(new AttributeValue().withS(start),new AttributeValue().withS(end));
  DynamoDBQueryExpression<DynamoScheduledActivity> query=new DynamoDBQueryExpression<DynamoScheduledActivity>().withHashKeyValues(hashKey).withLimit(pageSize).withScanIndexForward(false).withRangeKeyCondition(GUID,dateCondition);
  if (offsetBy != null) {
    Map<String,AttributeValue> map=Maps.newHashMap();
    map.put(HEALTH_CODE,new AttributeValue(healthCode));
    map.put(GUID,new AttributeValue(activityGuid + ""String_Node_Str"" + offsetBy));
    query.withExclusiveStartKey(map);
  }
  QueryResultPage<DynamoScheduledActivity> queryResult=mapper.queryPage(DynamoScheduledActivity.class,query);
  List<ScheduledActivity> activities=Lists.newArrayListWithCapacity(queryResult.getResults().size());
  for (  DynamoScheduledActivity act : queryResult.getResults()) {
    act.setTimeZone(DateTimeZone.UTC);
    activities.add((ScheduledActivity)act);
  }
  String nextOffsetBy=null;
  if (queryResult.getLastEvaluatedKey() != null) {
    nextOffsetBy=queryResult.getLastEvaluatedKey().get(GUID).getS().split(""String_Node_Str"",2)[1];
  }
  return new ForwardCursorPagedResourceList<ScheduledActivity>(activities,nextOffsetBy,pageSize).withFilter(SCHEDULED_ON_START,scheduledOnStart).withFilter(SCHEDULED_ON_END,scheduledOnEnd);
}","@Override public ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistoryV2(String healthCode,String activityGuid,DateTime scheduledOnStart,DateTime scheduledOnEnd,DateTimeZone timezone,String offsetBy,int pageSize){
  checkNotNull(healthCode);
  checkNotNull(scheduledOnStart);
  checkNotNull(scheduledOnEnd);
  checkNotNull(timezone);
  checkNotNull(activityGuid);
  if (pageSize < API_MINIMUM_PAGE_SIZE || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  DynamoScheduledActivity hashKey=new DynamoScheduledActivity();
  hashKey.setHealthCode(healthCode);
  String start=activityGuid + ""String_Node_Str"" + scheduledOnStart.toLocalDateTime().toString();
  String end=activityGuid + ""String_Node_Str"" + scheduledOnEnd.toLocalDateTime().toString();
  Condition dateCondition=new Condition().withComparisonOperator(ComparisonOperator.BETWEEN).withAttributeValueList(new AttributeValue().withS(start),new AttributeValue().withS(end));
  DynamoDBQueryExpression<DynamoScheduledActivity> query=new DynamoDBQueryExpression<DynamoScheduledActivity>().withHashKeyValues(hashKey).withLimit(pageSize).withScanIndexForward(false).withRangeKeyCondition(GUID,dateCondition);
  if (offsetBy != null) {
    Map<String,AttributeValue> map=Maps.newHashMap();
    map.put(HEALTH_CODE,new AttributeValue(healthCode));
    map.put(GUID,new AttributeValue(activityGuid + ""String_Node_Str"" + offsetBy));
    query.withExclusiveStartKey(map);
  }
  QueryResultPage<DynamoScheduledActivity> queryResult=mapper.queryPage(DynamoScheduledActivity.class,query);
  List<ScheduledActivity> activities=Lists.newArrayListWithCapacity(queryResult.getResults().size());
  for (  DynamoScheduledActivity act : queryResult.getResults()) {
    act.setTimeZone(timezone);
    activities.add((ScheduledActivity)act);
  }
  String nextOffsetBy=null;
  if (queryResult.getLastEvaluatedKey() != null) {
    nextOffsetBy=queryResult.getLastEvaluatedKey().get(GUID).getS().split(""String_Node_Str"",2)[1];
  }
  return new ForwardCursorPagedResourceList<ScheduledActivity>(activities,nextOffsetBy,pageSize).withFilter(SCHEDULED_ON_START,scheduledOnStart).withFilter(SCHEDULED_ON_END,scheduledOnEnd);
}",0.9835766423357664
25694,"/** 
 * If the client data is being added or removed, or if it is different, then the activity is being  updated.
 */
protected boolean hasUpdatedClientData(ScheduledActivity schActivity,ScheduledActivity dbActivity){
  JsonNode schNode=(schActivity == null) ? null : schActivity.getClientData();
  JsonNode dbNode=(dbActivity == null) ? null : dbActivity.getClientData();
  return !Objects.equals(schNode,dbNode);
}","/** 
 * If the client data is being added or removed, or if it is different, then the activity is being updated.
 */
protected boolean hasUpdatedClientData(ScheduledActivity schActivity,ScheduledActivity dbActivity){
  JsonNode schNode=(schActivity == null) ? null : schActivity.getClientData();
  JsonNode dbNode=(dbActivity == null) ? null : dbActivity.getClientData();
  return !Objects.equals(schNode,dbNode);
}",0.9987966305655837
25695,"public ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistory(String healthCode,String activityGuid,DateTime scheduledOnStart,DateTime scheduledOnEnd,String offsetBy,int pageSize){
  checkArgument(isNotBlank(healthCode));
  checkArgument(isNotBlank(activityGuid));
  if (pageSize < API_MINIMUM_PAGE_SIZE || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  if (scheduledOnStart == null && scheduledOnEnd == null) {
    scheduledOnEnd=DateTime.now().plusDays(MAX_EXPIRES_ON_DAYS);
    scheduledOnStart=scheduledOnEnd.minusWeeks(2);
  }
  if (scheduledOnStart == null || scheduledOnEnd == null) {
    throw new BadRequestException(EITHER_BOTH_DATES_OR_NEITHER);
  }
  return activityDao.getActivityHistoryV2(healthCode,activityGuid,scheduledOnStart,scheduledOnEnd,offsetBy,pageSize);
}","public ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistory(String healthCode,String activityGuid,DateTime scheduledOnStart,DateTime scheduledOnEnd,String offsetBy,int pageSize){
  checkArgument(isNotBlank(healthCode));
  checkArgument(isNotBlank(activityGuid));
  if (pageSize < API_MINIMUM_PAGE_SIZE || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  if (scheduledOnStart == null && scheduledOnEnd == null) {
    scheduledOnEnd=DateTime.now().plusDays(MAX_EXPIRES_ON_DAYS);
    scheduledOnStart=scheduledOnEnd.minusWeeks(2);
  }
  if (scheduledOnStart == null || scheduledOnEnd == null) {
    throw new BadRequestException(EITHER_BOTH_DATES_OR_NEITHER);
  }
  DateTimeZone timezone=scheduledOnStart.getZone();
  if (!timezone.equals(scheduledOnEnd.getZone())) {
    throw new BadRequestException(AMBIGUOUS_TIMEZONE_ERROR);
  }
  return activityDao.getActivityHistoryV2(healthCode,activityGuid,scheduledOnStart,scheduledOnEnd,timezone,offsetBy,pageSize);
}",0.9043010752688172
25696,"@Test public void getScheduledActivityHistoryV2() throws Exception {
  DateTimeZone MSK=DateTimeZone.forOffsetHours(3);
  DateTime endsOn=DateTime.now(MSK).plus(Period.parse(""String_Node_Str""));
  DateTime startDateTime=DateTime.now().minusDays(20);
  DateTime endDateTime=DateTime.now().plusDays(20);
  ScheduleContext context=new ScheduleContext.Builder().withHealthCode(healthCode).withStudyIdentifier(TEST_STUDY_IDENTIFIER).withClientInfo(ClientInfo.UNKNOWN_CLIENT).withInitialTimeZone(MSK).withEndsOn(endsOn).withEvents(eventMap()).build();
  Schedule schedule=plan.getStrategy().getScheduleForUser(plan,context);
  List<ScheduledActivity> activitiesToSchedule=schedule.getScheduler().getScheduledActivities(plan,context);
  activityDao.saveActivities(activitiesToSchedule);
  String activityGuid=extractActivityGuid();
  ForwardCursorPagedResourceList<ScheduledActivity> history=activityDao.getActivityHistoryV2(healthCode,activityGuid,startDateTime,endDateTime,null,10);
  assertEquals(10,history.getItems().size());
  Set<String> allTaskGuids=history.getItems().stream().map(ScheduledActivity::getGuid).collect(toSet());
  history=activityDao.getActivityHistoryV2(healthCode,activityGuid,startDateTime,endDateTime,history.getOffsetBy(),10);
  assertEquals(10,history.getItems().size());
  allTaskGuids.addAll(history.getItems().stream().map(ScheduledActivity::getGuid).collect(toSet()));
  assertEquals(20,allTaskGuids.size());
  history=activityDao.getActivityHistoryV2(healthCode,activityGuid,startDateTime,startDateTime,null,10);
  assertEquals(0,history.getItems().size());
  assertNull(history.getOffsetBy());
}","@Test public void getScheduledActivityHistoryV2() throws Exception {
  DateTimeZone MSK=DateTimeZone.forOffsetHours(3);
  DateTime endsOn=DateTime.now(MSK).plus(Period.parse(""String_Node_Str""));
  DateTime startDateTime=DateTime.now().minusDays(20);
  DateTime endDateTime=DateTime.now().plusDays(20);
  ScheduleContext context=new ScheduleContext.Builder().withHealthCode(healthCode).withStudyIdentifier(TEST_STUDY_IDENTIFIER).withClientInfo(ClientInfo.UNKNOWN_CLIENT).withInitialTimeZone(MSK).withEndsOn(endsOn).withEvents(eventMap()).build();
  Schedule schedule=plan.getStrategy().getScheduleForUser(plan,context);
  List<ScheduledActivity> activitiesToSchedule=schedule.getScheduler().getScheduledActivities(plan,context);
  activityDao.saveActivities(activitiesToSchedule);
  String activityGuid=extractActivityGuid();
  ForwardCursorPagedResourceList<ScheduledActivity> history=activityDao.getActivityHistoryV2(healthCode,activityGuid,startDateTime,endDateTime,MSK,null,10);
  assertEquals(10,history.getItems().size());
  history.getItems().stream().forEach(scheduledActivity -> assertEquals(MSK,scheduledActivity.getTimeZone()));
  Set<String> allTaskGuids=history.getItems().stream().map(ScheduledActivity::getGuid).collect(toSet());
  history=activityDao.getActivityHistoryV2(healthCode,activityGuid,startDateTime,endDateTime,MSK,history.getOffsetBy(),10);
  assertEquals(10,history.getItems().size());
  history.getItems().stream().forEach(scheduledActivity -> assertEquals(MSK,scheduledActivity.getTimeZone()));
  allTaskGuids.addAll(history.getItems().stream().map(ScheduledActivity::getGuid).collect(toSet()));
  assertEquals(20,allTaskGuids.size());
  history=activityDao.getActivityHistoryV2(healthCode,activityGuid,startDateTime,startDateTime,MSK,null,10);
  assertEquals(0,history.getItems().size());
  assertNull(history.getOffsetBy());
}",0.932797242963814
25697,"@Test public void activityHistoryDefaultsDateRange(){
  DateTimeUtils.setCurrentMillisFixed(STARTS_ON.getMillis());
  service.getActivityHistory(HEALTH_CODE,ACTIVITY_GUID,null,null,null,40);
  verify(activityDao).getActivityHistoryV2(HEALTH_CODE,ACTIVITY_GUID,STARTS_ON.minusDays(9),STARTS_ON.plusDays(5),null,40);
  DateTimeUtils.setCurrentMillisSystem();
}","@Test public void activityHistoryDefaultsDateRange(){
  DateTimeUtils.setCurrentMillisFixed(STARTS_ON.getMillis());
  service.getActivityHistory(HEALTH_CODE,ACTIVITY_GUID,null,null,null,40);
  verify(activityDao).getActivityHistoryV2(HEALTH_CODE,ACTIVITY_GUID,STARTS_ON.minusDays(9),STARTS_ON.plusDays(5),TIME_ZONE,null,40);
  DateTimeUtils.setCurrentMillisSystem();
}",0.9862258953168044
25698,"public NumericalConstraints(){
  setSupportedHints(EnumSet.of(UIHint.NUMBERFIELD,UIHint.SLIDER));
}","public NumericalConstraints(){
  setSupportedHints(EnumSet.of(UIHint.NUMBERFIELD,UIHint.SLIDER,UIHint.SELECT));
}",0.9339622641509434
25699,"private void doValidateConstraintsType(Errors errors,UIHint hint,NumericalConstraints con){
  Double min=con.getMinValue();
  Double max=con.getMaxValue();
  if (min != null && max != null) {
    if (max < min) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    double diff=max - min;
    if (con.getStep() != null && con.getStep() > diff) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
  }
}","private void doValidateConstraintsType(Errors errors,UIHint hint,NumericalConstraints con){
  Double min=con.getMinValue();
  Double max=con.getMaxValue();
  if (min != null && max != null) {
    if (max < min) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    double diff=max - min;
    if (con.getStep() != null && con.getStep() > diff) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
  }
 else   if (UIHint.SELECT == hint || UIHint.SLIDER == hint) {
    if (min == null) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"" + hint.name().toLowerCase());
    }
    if (max == null) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"" + hint.name().toLowerCase());
    }
  }
}",0.7419898819561551
25700,"/** 
 * Try Redis providers to find one that is provisioned. Using this URL in the environment variables is the documented way to interact with these services.
 */
private String getRedisURL(){
}","/** 
 * Try Redis providers to find one that is provisioned. Using this URL in the environment variables is the documented way to interact with these services.
 */
private String getRedisURL(){
  for (  String provider : redisProviders) {
    if (System.getenv(provider) != null) {
      LOG.info(""String_Node_Str"" + provider);
      return System.getenv(provider);
    }
  }
  LOG.info(""String_Node_Str"");
  return bridgeConfig.getProperty(""String_Node_Str"");
}",0.593607305936073
25701,"@Override public ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistoryV2(String activityGuid,String healthCode,DateTime scheduledOnOrAfter,DateTime scheduledOnOrBefore,Long offsetBy,int pageSize){
  checkNotNull(healthCode);
  checkNotNull(scheduledOnOrAfter);
  checkNotNull(scheduledOnOrBefore);
  checkNotNull(activityGuid);
  if (pageSize < API_MINIMUM_PAGE_SIZE || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  String healthCodeActivityGuid=healthCode + ""String_Node_Str"" + activityGuid;
  long startTimestamp=scheduledOnOrAfter.minusMillis(1).getMillis();
  long endTimestamp=scheduledOnOrBefore.plusMillis(1).getMillis();
  RangeKeyCondition dateRangeCondition=new RangeKeyCondition(SCHEDULED_ON_UTC).between(startTimestamp,endTimestamp);
  QuerySpec spec=new QuerySpec().withHashKey(new KeyAttribute(HEALTH_CODE_ACTIVITY_GUID,healthCodeActivityGuid)).withMaxPageSize(pageSize).withScanIndexForward(false).withRangeKeyCondition(dateRangeCondition);
  if (offsetBy != null) {
    RangeKeyCondition cursorPosCondition=new RangeKeyCondition(SCHEDULED_ON_UTC).gt(offsetBy);
    spec.withRangeKeyCondition(cursorPosCondition);
  }
  QueryOutcome queryOutcome=indexHelper.query(spec);
  List<Item> items=queryOutcome.getItems();
  QueryResult queryResult=queryOutcome.getQueryResult();
  List<ScheduledActivity> results=new ArrayList<>(items.size());
  for (  Item item : items) {
    ScheduledActivity activity=getActivity(healthCode,item.getString(GUID));
    results.add(activity);
  }
  Long nextPageOffsetBy=null;
  if (queryResult.getLastEvaluatedKey() != null) {
    nextPageOffsetBy=Long.parseLong(queryResult.getLastEvaluatedKey().get(SCHEDULED_ON_UTC).getN());
  }
  return new ForwardCursorPagedResourceList<ScheduledActivity>(results,nextPageOffsetBy,pageSize).withFilter(SCHEDULED_ON_OR_AFTER,scheduledOnOrAfter).withFilter(SCHEDULED_ON_OR_BEFORE,scheduledOnOrBefore);
}","@Override public ForwardCursorPagedResourceList<ScheduledActivity> getActivityHistoryV2(String healthCode,String activityGuid,DateTime scheduledOnOrAfter,DateTime scheduledOnOrBefore,Long offsetBy,int pageSize){
  checkNotNull(healthCode);
  checkNotNull(scheduledOnOrAfter);
  checkNotNull(scheduledOnOrBefore);
  checkNotNull(activityGuid);
  if (pageSize < API_MINIMUM_PAGE_SIZE || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  String healthCodeActivityGuid=healthCode + ""String_Node_Str"" + activityGuid;
  long startTimestamp=scheduledOnOrAfter.minusMillis(1).getMillis();
  long endTimestamp=scheduledOnOrBefore.plusMillis(1).getMillis();
  RangeKeyCondition dateRangeCondition=new RangeKeyCondition(SCHEDULED_ON_UTC).between(startTimestamp,endTimestamp);
  QuerySpec spec=new QuerySpec().withHashKey(new KeyAttribute(HEALTH_CODE_ACTIVITY_GUID,healthCodeActivityGuid)).withMaxResultSize(100000).withMaxPageSize(pageSize).withScanIndexForward(false).withRangeKeyCondition(dateRangeCondition);
  if (offsetBy != null) {
    RangeKeyCondition cursorPosCondition=new RangeKeyCondition(SCHEDULED_ON_UTC).lt(offsetBy);
    spec.withRangeKeyCondition(cursorPosCondition);
  }
  QueryOutcome queryOutcome=indexHelper.query(spec);
  List<Item> items=queryOutcome.getItems();
  QueryResult queryResult=queryOutcome.getQueryResult();
  List<ScheduledActivity> results=new ArrayList<>(items.size());
  for (  Item item : items) {
    ScheduledActivity activity=getActivity(healthCode,item.getString(GUID));
    activity.setTimeZone(DateTimeZone.UTC);
    results.add(activity);
  }
  Long nextPageOffsetBy=null;
  if (queryResult.getLastEvaluatedKey() != null) {
    nextPageOffsetBy=Long.parseLong(queryResult.getLastEvaluatedKey().get(SCHEDULED_ON_UTC).getN());
  }
  return new ForwardCursorPagedResourceList<ScheduledActivity>(results,nextPageOffsetBy,pageSize).withFilter(SCHEDULED_ON_OR_AFTER,scheduledOnOrAfter).withFilter(SCHEDULED_ON_OR_BEFORE,scheduledOnOrBefore);
}",0.9727547931382442
25702,"public Class<? extends BridgeEntity> getEntityClass(){
  return entity.getClass();
}","public Class<? extends BridgeEntity> getEntityClass(){
  return entity != null ? entity.getClass() : null;
}",0.875
25703,"private List<ScheduledActivity> resolveLinks(CriteriaContext context,Map<String,CompoundActivity> compoundActivityCache,Map<String,SchemaReference> schemaCache,Map<String,SurveyReference> surveyCache,List<ScheduledActivity> activities){
  return activities.stream().map(schActivity -> {
    Activity activity=schActivity.getActivity();
    ActivityType activityType=activity.getActivityType();
    Activity resolvedActivity=null;
    if (activityType == ActivityType.COMPOUND) {
      CompoundActivity compoundActivity=activity.getCompoundActivity();
      CompoundActivity resolvedCompoundActivity=resolveCompoundActivity(context,compoundActivityCache,schemaCache,surveyCache,compoundActivity);
      if (!resolvedCompoundActivity.equals(compoundActivity)) {
        resolvedActivity=new Activity.Builder().withActivity(activity).withCompoundActivity(resolvedCompoundActivity).build();
      }
    }
 else     if (activityType == ActivityType.SURVEY) {
      SurveyReference surveyRef=activity.getSurvey();
      SurveyReference resolvedSurveyRef=resolveSurvey(context,surveyCache,surveyRef);
      if (!resolvedSurveyRef.equals(surveyRef)) {
        resolvedActivity=new Activity.Builder().withActivity(activity).withSurvey(resolvedSurveyRef).build();
      }
    }
 else     if (activityType == ActivityType.TASK) {
      TaskReference taskRef=activity.getTask();
      SchemaReference schemaRef=taskRef.getSchema();
      if (schemaRef != null) {
        SchemaReference resolvedSchemaRef=resolveSchema(context,schemaCache,schemaRef);
        if (!resolvedSchemaRef.equals(schemaRef)) {
          TaskReference resolvedTaskRef=new TaskReference(taskRef.getIdentifier(),resolvedSchemaRef);
          resolvedActivity=new Activity.Builder().withTask(resolvedTaskRef).build();
        }
      }
    }
    if (resolvedActivity != null) {
      schActivity.setActivity(resolvedActivity);
    }
    return schActivity;
  }
).collect(toList());
}","private List<ScheduledActivity> resolveLinks(CriteriaContext context,Map<String,CompoundActivity> compoundActivityCache,Map<String,SchemaReference> schemaCache,Map<String,SurveyReference> surveyCache,List<ScheduledActivity> activities){
  return activities.stream().map(schActivity -> {
    Activity activity=schActivity.getActivity();
    ActivityType activityType=activity.getActivityType();
    Activity resolvedActivity=null;
    if (activityType == ActivityType.COMPOUND) {
      CompoundActivity compoundActivity=activity.getCompoundActivity();
      CompoundActivity resolvedCompoundActivity=resolveCompoundActivity(context,compoundActivityCache,schemaCache,surveyCache,compoundActivity);
      if (!resolvedCompoundActivity.equals(compoundActivity)) {
        resolvedActivity=new Activity.Builder().withActivity(activity).withCompoundActivity(resolvedCompoundActivity).build();
      }
    }
 else     if (activityType == ActivityType.SURVEY) {
      SurveyReference surveyRef=activity.getSurvey();
      SurveyReference resolvedSurveyRef=resolveSurvey(context,surveyCache,surveyRef);
      if (!resolvedSurveyRef.equals(surveyRef)) {
        resolvedActivity=new Activity.Builder().withActivity(activity).withSurvey(resolvedSurveyRef).build();
      }
    }
 else     if (activityType == ActivityType.TASK) {
      TaskReference taskRef=activity.getTask();
      SchemaReference schemaRef=taskRef.getSchema();
      if (schemaRef != null) {
        SchemaReference resolvedSchemaRef=resolveSchema(context,schemaCache,schemaRef);
        if (!resolvedSchemaRef.equals(schemaRef)) {
          TaskReference resolvedTaskRef=new TaskReference(taskRef.getIdentifier(),resolvedSchemaRef);
          resolvedActivity=new Activity.Builder().withActivity(activity).withTask(resolvedTaskRef).build();
        }
      }
    }
    if (resolvedActivity != null) {
      schActivity.setActivity(resolvedActivity);
    }
    return schActivity;
  }
).collect(toList());
}",0.994116142235866
25704,"@Test public void resolveTaskRefWithoutSchema(){
  Activity activity=new Activity.Builder().withTask(TASK_ID).build();
  setupSchedulePlanServiceWithActivity(activity);
  List<ScheduledActivity> scheduledActivityList=scheduledActivityService.scheduleActivitiesForPlans(SCHEDULE_CONTEXT);
  assertEquals(scheduledActivityList.size(),2);
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    TaskReference taskRef=oneScheduledActivity.getActivity().getTask();
    assertEquals(TASK_ID,taskRef.getIdentifier());
    assertNull(taskRef.getSchema());
  }
  verify(mockCompoundActivityDefinitionService,never()).getCompoundActivityDefinition(any(),any());
  verify(mockSchemaService,never()).getLatestUploadSchemaRevisionForAppVersion(any(),any(),any());
  verify(mockSurveyService,never()).getSurveyMostRecentlyPublishedVersion(any(),any());
}","@Test public void resolveTaskRefWithoutSchema(){
  Activity activity=new Activity.Builder().withTask(TASK_ID).build();
  setupSchedulePlanServiceWithActivity(activity);
  List<ScheduledActivity> scheduledActivityList=scheduledActivityService.scheduleActivitiesForPlans(SCHEDULE_CONTEXT);
  verifyActivityListSizeAndLabels(scheduledActivityList);
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    TaskReference taskRef=oneScheduledActivity.getActivity().getTask();
    assertEquals(TASK_ID,taskRef.getIdentifier());
    assertNull(taskRef.getSchema());
  }
  verify(mockCompoundActivityDefinitionService,never()).getCompoundActivityDefinition(any(),any());
  verify(mockSchemaService,never()).getLatestUploadSchemaRevisionForAppVersion(any(),any(),any());
  verify(mockSurveyService,never()).getSurveyMostRecentlyPublishedVersion(any(),any());
}",0.9619815668202764
25705,"private static void verifySurveys(List<ScheduledActivity> scheduledActivityList){
  assertEquals(2,scheduledActivityList.size());
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    SurveyReference surveyRef=oneScheduledActivity.getActivity().getSurvey();
    assertEquals(SURVEY_ID,surveyRef.getIdentifier());
    assertEquals(SURVEY_GUID,surveyRef.getGuid());
    assertEquals(SURVEY_CREATED_ON_MILLIS,surveyRef.getCreatedOn().getMillis());
  }
}","private static void verifySurveys(List<ScheduledActivity> scheduledActivityList){
  verifyActivityListSizeAndLabels(scheduledActivityList);
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    SurveyReference surveyRef=oneScheduledActivity.getActivity().getSurvey();
    assertEquals(SURVEY_ID,surveyRef.getIdentifier());
    assertEquals(SURVEY_GUID,surveyRef.getGuid());
    assertEquals(SURVEY_CREATED_ON_MILLIS,surveyRef.getCreatedOn().getMillis());
  }
}",0.90625
25706,"private void setupSchedulePlanServiceWithActivity(Activity activity){
  SchedulePlan plan=SchedulePlan.create();
  Activity activityCopy=new Activity.Builder().withActivity(activity).build();
  ScheduledActivity scheduledActivity=ScheduledActivity.create();
  scheduledActivity.setActivity(activity);
  ScheduledActivity scheduledActivityCopy=ScheduledActivity.create();
  scheduledActivityCopy.setActivity(activityCopy);
  List<ScheduledActivity> scheduledActivityList=ImmutableList.of(scheduledActivity,scheduledActivityCopy);
  ActivityScheduler mockScheduler=mock(ActivityScheduler.class);
  when(mockScheduler.getScheduledActivities(plan,SCHEDULE_CONTEXT)).thenReturn(scheduledActivityList);
  Schedule mockSchedule=mock(Schedule.class);
  when(mockSchedule.getScheduler()).thenReturn(mockScheduler);
  SimpleScheduleStrategy strategy=new SimpleScheduleStrategy();
  strategy.setSchedule(mockSchedule);
  plan.setStrategy(strategy);
  when(mockSchedulePlanService.getSchedulePlans(ClientInfo.UNKNOWN_CLIENT,TestConstants.TEST_STUDY)).thenReturn(ImmutableList.of(plan));
}","private void setupSchedulePlanServiceWithActivity(Activity activity){
  SchedulePlan plan=SchedulePlan.create();
  Activity activityCopy1=new Activity.Builder().withActivity(activity).withLabel(ACTIVITY_LABEL_PREFIX + ""String_Node_Str"").build();
  Activity activityCopy2=new Activity.Builder().withActivity(activity).withLabel(ACTIVITY_LABEL_PREFIX + ""String_Node_Str"").build();
  ScheduledActivity scheduledActivity=ScheduledActivity.create();
  scheduledActivity.setActivity(activityCopy1);
  ScheduledActivity scheduledActivityCopy=ScheduledActivity.create();
  scheduledActivityCopy.setActivity(activityCopy2);
  List<ScheduledActivity> scheduledActivityList=ImmutableList.of(scheduledActivity,scheduledActivityCopy);
  ActivityScheduler mockScheduler=mock(ActivityScheduler.class);
  when(mockScheduler.getScheduledActivities(plan,SCHEDULE_CONTEXT)).thenReturn(scheduledActivityList);
  Schedule mockSchedule=mock(Schedule.class);
  when(mockSchedule.getScheduler()).thenReturn(mockScheduler);
  SimpleScheduleStrategy strategy=new SimpleScheduleStrategy();
  strategy.setSchedule(mockSchedule);
  plan.setStrategy(strategy);
  when(mockSchedulePlanService.getSchedulePlans(ClientInfo.UNKNOWN_CLIENT,TestConstants.TEST_STUDY)).thenReturn(ImmutableList.of(plan));
}",0.7599147121535181
25707,"private static void verifyCompoundActivities(List<ScheduledActivity> scheduledActivityList){
  assertEquals(2,scheduledActivityList.size());
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    CompoundActivity compoundActivity=oneScheduledActivity.getActivity().getCompoundActivity();
    assertEquals(COMPOUND_ACTIVITY_REF_TASK_ID,compoundActivity.getTaskIdentifier());
    assertEquals(1,compoundActivity.getSchemaList().size());
    assertEquals(SCHEMA_ID,compoundActivity.getSchemaList().get(0).getId());
    assertEquals(SCHEMA_REV,compoundActivity.getSchemaList().get(0).getRevision().intValue());
    assertEquals(1,compoundActivity.getSurveyList().size());
    assertEquals(SURVEY_ID,compoundActivity.getSurveyList().get(0).getIdentifier());
    assertEquals(SURVEY_GUID,compoundActivity.getSurveyList().get(0).getGuid());
    assertEquals(SURVEY_CREATED_ON_MILLIS,compoundActivity.getSurveyList().get(0).getCreatedOn().getMillis());
  }
}","private static void verifyCompoundActivities(List<ScheduledActivity> scheduledActivityList){
  verifyActivityListSizeAndLabels(scheduledActivityList);
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    CompoundActivity compoundActivity=oneScheduledActivity.getActivity().getCompoundActivity();
    assertEquals(COMPOUND_ACTIVITY_REF_TASK_ID,compoundActivity.getTaskIdentifier());
    assertEquals(1,compoundActivity.getSchemaList().size());
    assertEquals(SCHEMA_ID,compoundActivity.getSchemaList().get(0).getId());
    assertEquals(SCHEMA_REV,compoundActivity.getSchemaList().get(0).getRevision().intValue());
    assertEquals(1,compoundActivity.getSurveyList().size());
    assertEquals(SURVEY_ID,compoundActivity.getSurveyList().get(0).getIdentifier());
    assertEquals(SURVEY_GUID,compoundActivity.getSurveyList().get(0).getGuid());
    assertEquals(SURVEY_CREATED_ON_MILLIS,compoundActivity.getSurveyList().get(0).getCreatedOn().getMillis());
  }
}",0.9724208375893768
25708,"private static void verifySchemas(List<ScheduledActivity> scheduledActivityList){
  assertEquals(2,scheduledActivityList.size());
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    SchemaReference schemaRef=oneScheduledActivity.getActivity().getTask().getSchema();
    assertEquals(SCHEMA_ID,schemaRef.getId());
    assertEquals(SCHEMA_REV,schemaRef.getRevision().intValue());
  }
}","private static void verifySchemas(List<ScheduledActivity> scheduledActivityList){
  verifyActivityListSizeAndLabels(scheduledActivityList);
  for (  ScheduledActivity oneScheduledActivity : scheduledActivityList) {
    SchemaReference schemaRef=oneScheduledActivity.getActivity().getTask().getSchema();
    assertEquals(SCHEMA_ID,schemaRef.getId());
    assertEquals(SCHEMA_REV,schemaRef.getRevision().intValue());
  }
}",0.891566265060241
25709,"@Before public void before() throws Exception {
  service=new ReportService();
  service.setReportDataDao(mockReportDataDao);
  service.setReportIndexDao(mockReportIndexDao);
  List<ReportData> list=Lists.newArrayList();
  list.add(createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  list.add(createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  results=new DateRangeResourceList<ReportData>(list,START_DATE,END_DATE);
  ReportIndex index=ReportIndex.create();
  index.setIdentifier(IDENTIFIER);
  indices=new ReportTypeResourceList<>(Lists.newArrayList(index),ReportType.STUDY);
}","@Before public void before() throws Exception {
  service=new ReportService();
  service.setReportDataDao(mockReportDataDao);
  service.setReportIndexDao(mockReportIndexDao);
  List<ReportData> list=Lists.newArrayList();
  list.add(createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  list.add(createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str""));
  results=new DateRangeResourceList<>(list,START_DATE,END_DATE);
  ReportIndex index=ReportIndex.create();
  index.setIdentifier(IDENTIFIER);
  indices=new ReportTypeResourceList<>(Lists.newArrayList(index),ReportType.STUDY);
}",0.9922958397534668
25710,"@Test public void deleteStudyReportRecord(){
  LocalDate startDate=LocalDate.parse(""String_Node_Str"").minusDays(45);
  LocalDate endDate=LocalDate.parse(""String_Node_Str"");
  DateRangeResourceList<ReportData> emptyResults=new DateRangeResourceList<ReportData>(Lists.newArrayList(),START_DATE,END_DATE);
  doReturn(emptyResults).when(mockReportDataDao).getReportData(STUDY_REPORT_DATA_KEY,startDate,endDate);
  DateTimeUtils.setCurrentMillisFixed(DateTime.parse(""String_Node_Str"").getMillis());
  try {
    service.deleteStudyReportRecord(TEST_STUDY,IDENTIFIER,DATE);
    verify(mockReportDataDao).deleteReportDataRecord(STUDY_REPORT_DATA_KEY,DATE);
    verify(mockReportDataDao).getReportData(STUDY_REPORT_DATA_KEY,startDate,endDate);
    verify(mockReportIndexDao).removeIndex(STUDY_REPORT_DATA_KEY);
  }
  finally {
    DateTimeUtils.setCurrentMillisSystem();
  }
}","@Test public void deleteStudyReportRecord(){
  LocalDate startDate=LocalDate.parse(""String_Node_Str"").minusDays(45);
  LocalDate endDate=LocalDate.parse(""String_Node_Str"");
  DateRangeResourceList<ReportData> emptyResults=new DateRangeResourceList<>(Lists.newArrayList(),START_DATE,END_DATE);
  doReturn(emptyResults).when(mockReportDataDao).getReportData(STUDY_REPORT_DATA_KEY,startDate,endDate);
  DateTimeUtils.setCurrentMillisFixed(DateTime.parse(""String_Node_Str"").getMillis());
  try {
    service.deleteStudyReportRecord(TEST_STUDY,IDENTIFIER,DATE);
    verify(mockReportDataDao).deleteReportDataRecord(STUDY_REPORT_DATA_KEY,DATE);
    verify(mockReportDataDao).getReportData(STUDY_REPORT_DATA_KEY,startDate,endDate);
    verify(mockReportIndexDao).removeIndex(STUDY_REPORT_DATA_KEY);
  }
  finally {
    DateTimeUtils.setCurrentMillisSystem();
  }
}",0.994199535962877
25711,"@Test public void getReportIndex(){
  ReportDataKey key=new ReportDataKey.Builder().withIdentifier(IDENTIFIER).withReportType(ReportType.STUDY).withStudyIdentifier(TEST_STUDY).build();
  ReportIndex index=ReportIndex.create();
  index.setIdentifier(IDENTIFIER);
  index.setIdentifier(IDENTIFIER);
  doReturn(index).when(mockReportIndexDao).getIndex(key);
  ReportIndex retrievedKey=service.getReportIndex(key);
  assertEquals(key.getIdentifier(),retrievedKey.getIdentifier());
  verify(mockReportIndexDao).getIndex(key);
}","@Test public void getReportIndex(){
  ReportDataKey key=new ReportDataKey.Builder().withIdentifier(IDENTIFIER).withReportType(ReportType.STUDY).withStudyIdentifier(TEST_STUDY).build();
  ReportIndex index=ReportIndex.create();
  index.setIdentifier(IDENTIFIER);
  doReturn(index).when(mockReportIndexDao).getIndex(key);
  ReportIndex retrievedKey=service.getReportIndex(key);
  assertEquals(key.getIdentifier(),retrievedKey.getIdentifier());
  verify(mockReportIndexDao).getIndex(key);
}",0.9653121902874132
25712,"@Test public void saveParticipantReportData() throws Exception {
  ReportData someData=createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str"");
  service.saveParticipantReport(TEST_STUDY,IDENTIFIER,HEALTH_CODE,someData);
  service.saveParticipantReport(TEST_STUDY,IDENTIFIER,HEALTH_CODE,someData);
  verify(mockReportDataDao,times(2)).saveReportData(reportDataCaptor.capture());
  ReportData retrieved=reportDataCaptor.getValue();
  assertEquals(someData,retrieved);
  assertEquals(PARTICIPANT_REPORT_DATA_KEY.getKeyString(),retrieved.getKey());
  assertEquals(LocalDate.parse(""String_Node_Str""),retrieved.getDate());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  verify(mockReportIndexDao,times(1)).addIndex(new ReportDataKey.Builder().withHealthCode(HEALTH_CODE).withStudyIdentifier(TEST_STUDY).withReportType(ReportType.PARTICIPANT).withIdentifier(IDENTIFIER).build());
}","@Test public void saveParticipantReportData() throws Exception {
  ReportData someData=createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str"");
  service.saveParticipantReport(TEST_STUDY,IDENTIFIER,HEALTH_CODE,someData);
  verify(mockReportDataDao).saveReportData(reportDataCaptor.capture());
  ReportData retrieved=reportDataCaptor.getValue();
  assertEquals(someData,retrieved);
  assertEquals(PARTICIPANT_REPORT_DATA_KEY.getKeyString(),retrieved.getKey());
  assertEquals(LocalDate.parse(""String_Node_Str""),retrieved.getDate());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  verify(mockReportIndexDao).addIndex(new ReportDataKey.Builder().withHealthCode(HEALTH_CODE).withStudyIdentifier(TEST_STUDY).withReportType(ReportType.PARTICIPANT).withIdentifier(IDENTIFIER).build());
}",0.2912227295788939
25713,"@Test public void saveStudyReportData(){
  ReportData someData=createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str"");
  service.saveStudyReport(TEST_STUDY,IDENTIFIER,someData);
  service.saveStudyReport(TEST_STUDY,IDENTIFIER,someData);
  verify(mockReportDataDao,times(2)).saveReportData(reportDataCaptor.capture());
  ReportData retrieved=reportDataCaptor.getValue();
  assertEquals(someData,retrieved);
  assertEquals(STUDY_REPORT_DATA_KEY.getKeyString(),retrieved.getKey());
  assertEquals(LocalDate.parse(""String_Node_Str""),retrieved.getDate());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  verify(mockReportIndexDao,times(1)).addIndex(new ReportDataKey.Builder().withStudyIdentifier(TEST_STUDY).withReportType(ReportType.STUDY).withIdentifier(IDENTIFIER).build());
}","@Test public void saveStudyReportData(){
  ReportData someData=createReport(LocalDate.parse(""String_Node_Str""),""String_Node_Str"",""String_Node_Str"");
  service.saveStudyReport(TEST_STUDY,IDENTIFIER,someData);
  verify(mockReportDataDao).saveReportData(reportDataCaptor.capture());
  ReportData retrieved=reportDataCaptor.getValue();
  assertEquals(someData,retrieved);
  assertEquals(STUDY_REPORT_DATA_KEY.getKeyString(),retrieved.getKey());
  assertEquals(LocalDate.parse(""String_Node_Str""),retrieved.getDate());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",retrieved.getData().get(""String_Node_Str"").asText());
  verify(mockReportIndexDao).addIndex(new ReportDataKey.Builder().withStudyIdentifier(TEST_STUDY).withReportType(ReportType.STUDY).withIdentifier(IDENTIFIER).build());
}",0.9569591950810508
25714,"public Result getStudy(String identifier) throws Exception {
  getAuthenticatedSession(ADMIN);
  Study study=studyService.getStudy(identifier);
  return ok(Study.STUDY_WRITER.writeValueAsString(study));
}","public Result getStudy(String identifier) throws Exception {
  getAuthenticatedSession(ADMIN);
  Study study=studyService.getStudy(identifier,true);
  return ok(Study.STUDY_WRITER.writeValueAsString(study));
}",0.9878934624697336
25715,"/** 
 * A similar method as above but specifying study id only for WORKER
 */
public Result saveStudyReportForSpecifiedStudy(String studyId,String identifier) throws Exception {
  getAuthenticatedSession(WORKER);
  ReportData reportData=parseJson(request(),ReportData.class);
  reportData.setKey(null);
  Study study=studyService.getStudy(studyId);
  reportService.saveStudyReport(study.getStudyIdentifier(),identifier,reportData);
  return createdResult(""String_Node_Str"");
}","/** 
 * A similar method as above but specifying study id only for WORKER
 */
public Result saveStudyReportForSpecifiedStudy(String studyIdString,String identifier) throws Exception {
  getAuthenticatedSession(WORKER);
  ReportData reportData=parseJson(request(),ReportData.class);
  reportData.setKey(null);
  StudyIdentifier studyId=new StudyIdentifierImpl(studyIdString);
  reportService.saveStudyReport(studyId,identifier,reportData);
  return createdResult(""String_Node_Str"");
}",0.8112617309697602
25716,"/** 
 * another version of getUploads for workers to specify any studyid to get uploads
 * @param startTimeString
 * @param endTimeString
 * @return
 */
public Result getUploadsForStudy(String studyId,String startTimeString,String endTimeString) throws EntityNotFoundException {
  getAuthenticatedSession(WORKER);
  DateTime startTime=DateUtils.getDateTimeOrDefault(startTimeString,null);
  DateTime endTime=DateUtils.getDateTimeOrDefault(endTimeString,null);
  Study study=studyService.getStudy(studyId);
  DateTimeRangeResourceList<? extends UploadView> uploads=uploadService.getStudyUploads(study.getStudyIdentifier(),startTime,endTime);
  return okResult(uploads);
}","/** 
 * another version of getUploads for workers to specify any studyid to get uploads
 * @param startTimeString
 * @param endTimeString
 * @return
 */
public Result getUploadsForStudy(String studyIdString,String startTimeString,String endTimeString) throws EntityNotFoundException {
  getAuthenticatedSession(WORKER);
  DateTime startTime=DateUtils.getDateTimeOrDefault(startTimeString,null);
  DateTime endTime=DateUtils.getDateTimeOrDefault(endTimeString,null);
  StudyIdentifier studyId=new StudyIdentifierImpl(studyIdString);
  DateTimeRangeResourceList<? extends UploadView> uploads=uploadService.getStudyUploads(studyId,startTime,endTime);
  return okResult(uploads);
}",0.9265033407572384
25717,"public Study createSynapseProjectTeam(Long userId,Study study) throws SynapseException {
  checkNewEntity(study,study.getSynapseDataAccessTeamId(),""String_Node_Str"");
  checkNewEntity(study,study.getSynapseProjectId(),""String_Node_Str"");
  Team team=new Team();
  team.setName(study.getName().trim().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  Project project=new Project();
  project.setName(study.getName().trim().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  Team newTeam=synapseClient.createTeam(team);
  Project newProject=synapseClient.createEntity(project);
  org.sagebionetworks.repo.model.AccessControlList acl=synapseClient.getACL(newProject.getId());
  ResourceAccess toSet=new ResourceAccess();
  toSet.setPrincipalId(Long.parseLong(EXPORTER_SYNAPSE_USER_ID));
  toSet.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSet);
  ResourceAccess toSetUser=new ResourceAccess();
  toSetUser.setPrincipalId(userId);
  toSetUser.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSetUser);
  synapseClient.updateACL(acl);
  MembershipInvtnSubmission teamMemberInvitation=new MembershipInvtnSubmission();
  teamMemberInvitation.setInviteeId(userId.toString());
  teamMemberInvitation.setTeamId(newTeam.getId());
  synapseClient.createMembershipInvitation(teamMemberInvitation,null,null);
  synapseClient.setTeamMemberPermissions(newTeam.getId(),userId.toString(),true);
  String newTeamId=newTeam.getId();
  String newProjectId=newProject.getId();
  study.setSynapseProjectId(newProjectId);
  study.setSynapseDataAccessTeamId(Long.parseLong(newTeamId));
  updateStudy(study,false);
  return study;
}","public Study createSynapseProjectTeam(Long userId,Study study) throws SynapseException {
  checkNewEntity(study,study.getSynapseDataAccessTeamId(),""String_Node_Str"");
  checkNewEntity(study,study.getSynapseProjectId(),""String_Node_Str"");
  try {
    synapseClient.getUserProfile(userId.toString());
  }
 catch (  SynapseNotFoundException e) {
    throw new BadRequestException(""String_Node_Str"");
  }
  Team team=new Team();
  team.setName(study.getName().trim().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  Project project=new Project();
  project.setName(study.getName().trim().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  Team newTeam=synapseClient.createTeam(team);
  Project newProject=synapseClient.createEntity(project);
  org.sagebionetworks.repo.model.AccessControlList acl=synapseClient.getACL(newProject.getId());
  ResourceAccess toSet=new ResourceAccess();
  toSet.setPrincipalId(Long.parseLong(EXPORTER_SYNAPSE_USER_ID));
  toSet.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSet);
  ResourceAccess toSetUser=new ResourceAccess();
  toSetUser.setPrincipalId(userId);
  toSetUser.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSetUser);
  synapseClient.updateACL(acl);
  MembershipInvtnSubmission teamMemberInvitation=new MembershipInvtnSubmission();
  teamMemberInvitation.setInviteeId(userId.toString());
  teamMemberInvitation.setTeamId(newTeam.getId());
  synapseClient.createMembershipInvitation(teamMemberInvitation,null,null);
  synapseClient.setTeamMemberPermissions(newTeam.getId(),userId.toString(),true);
  String newTeamId=newTeam.getId();
  String newProjectId=newProject.getId();
  study.setSynapseProjectId(newProjectId);
  study.setSynapseDataAccessTeamId(Long.parseLong(newTeamId));
  updateStudy(study,false);
  return study;
}",0.9553546973431936
25718,"@Before public void before(){
  mockCache=mock(CacheProvider.class);
  studyService.setCacheProvider(mockCache);
  studyService.setSynapseClient(synapseClient);
}","@Before public void before() throws SynapseException {
  mockCache=mock(CacheProvider.class);
  studyService.setCacheProvider(mockCache);
  studyService.setSynapseClient(synapseClient);
  if (project != null) {
    synapseClient.deleteEntityById(project.getId());
  }
  if (team != null) {
    synapseClient.deleteTeam(team.getId());
  }
}",0.6467065868263473
25719,"@Test public void createSynapseProjectTeam() throws SynapseException {
  study=TestUtils.getValidStudy(StudyServiceTest.class);
  study.setSynapseDataAccessTeamId(null);
  study.setSynapseProjectId(null);
  studyService.createStudy(study);
  Study retStudy=studyService.createSynapseProjectTeam(TEST_USER_ID,study);
  assertEquals(retStudy.getIdentifier(),study.getIdentifier());
  String projectId=retStudy.getSynapseProjectId();
  Long teamId=retStudy.getSynapseDataAccessTeamId();
  Entity project=synapseClient.getEntityById(projectId);
  assertNotNull(project);
  assertEquals(project.getEntityType(),""String_Node_Str"");
  this.project=(Project)project;
  Team team=synapseClient.getTeam(teamId.toString());
  assertNotNull(team);
  this.team=team;
  AccessControlList projectAcl=synapseClient.getACL(projectId);
  Set<ResourceAccess> projectRa=projectAcl.getResourceAccess();
  assertNotNull(projectRa);
  assertEquals(projectRa.size(),3);
  List<ResourceAccess> retListForExporter=projectRa.stream().filter(ra -> ra.getPrincipalId().equals(Long.parseLong(EXPORTER_SYNAPSE_USER_ID))).collect(Collectors.toList());
  assertNotNull(retListForExporter);
  assertEquals(retListForExporter.size(),1);
  ResourceAccess exporterRa=retListForExporter.get(0);
  assertNotNull(exporterRa);
  assertEquals(exporterRa.getPrincipalId().toString(),EXPORTER_SYNAPSE_USER_ID);
  assertEquals(exporterRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  List<ResourceAccess> retListForUser=projectRa.stream().filter(ra -> ra.getPrincipalId().equals(TEST_USER_ID)).collect(Collectors.toList());
  assertNotNull(retListForUser);
  assertEquals(retListForUser.size(),1);
  ResourceAccess userRa=retListForUser.get(0);
  assertNotNull(userRa);
  assertEquals(userRa.getPrincipalId(),TEST_USER_ID);
  assertEquals(userRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  PaginatedResults<MembershipInvtnSubmission> retInvitations=synapseClient.getOpenMembershipInvitationSubmissions(teamId.toString(),TEST_USER_ID.toString(),1,0);
  List<MembershipInvtnSubmission> invitationList=retInvitations.getResults();
  assertEquals(invitationList.size(),1);
  MembershipInvtnSubmission invtnSubmission=invitationList.get(0);
  assertEquals(invtnSubmission.getInviteeId(),TEST_USER_ID.toString());
  assertEquals(invtnSubmission.getTeamId(),teamId.toString());
}","@Test public void createSynapseProjectTeam() throws SynapseException {
  study=TestUtils.getValidStudy(StudyServiceTest.class);
  study.setSynapseDataAccessTeamId(null);
  study.setSynapseProjectId(null);
  studyService.createStudy(study);
  Study retStudy=studyService.createSynapseProjectTeam(TEST_USER_ID,study);
  String projectId=retStudy.getSynapseProjectId();
  Long teamId=retStudy.getSynapseDataAccessTeamId();
  Entity project=synapseClient.getEntityById(projectId);
  this.project=(Project)project;
  Team team=synapseClient.getTeam(teamId.toString());
  this.team=team;
  assertEquals(retStudy.getIdentifier(),study.getIdentifier());
  assertNotNull(project);
  assertEquals(project.getEntityType(),""String_Node_Str"");
  assertNotNull(team);
  AccessControlList projectAcl=synapseClient.getACL(projectId);
  Set<ResourceAccess> projectRa=projectAcl.getResourceAccess();
  assertNotNull(projectRa);
  assertEquals(projectRa.size(),3);
  List<ResourceAccess> retListForExporter=projectRa.stream().filter(ra -> ra.getPrincipalId().equals(Long.parseLong(EXPORTER_SYNAPSE_USER_ID))).collect(Collectors.toList());
  assertNotNull(retListForExporter);
  assertEquals(retListForExporter.size(),1);
  ResourceAccess exporterRa=retListForExporter.get(0);
  assertNotNull(exporterRa);
  assertEquals(exporterRa.getPrincipalId().toString(),EXPORTER_SYNAPSE_USER_ID);
  assertEquals(exporterRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  List<ResourceAccess> retListForUser=projectRa.stream().filter(ra -> ra.getPrincipalId().equals(TEST_USER_ID)).collect(Collectors.toList());
  assertNotNull(retListForUser);
  assertEquals(retListForUser.size(),1);
  ResourceAccess userRa=retListForUser.get(0);
  assertNotNull(userRa);
  assertEquals(userRa.getPrincipalId(),TEST_USER_ID);
  assertEquals(userRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  PaginatedResults<MembershipInvtnSubmission> retInvitations=synapseClient.getOpenMembershipInvitationSubmissions(teamId.toString(),TEST_USER_ID.toString(),1,0);
  List<MembershipInvtnSubmission> invitationList=retInvitations.getResults();
  assertEquals(invitationList.size(),1);
  MembershipInvtnSubmission invtnSubmission=invitationList.get(0);
  assertEquals(invtnSubmission.getInviteeId(),TEST_USER_ID.toString());
  assertEquals(invtnSubmission.getTeamId(),teamId.toString());
}",0.8877163360067539
25720,"@Test public void createSynapseProjectTeam() throws SynapseException {
  Study study=getTestStudy();
  AccessControlList mockAcl=new AccessControlList();
  AccessControlList mockTeamAcl=new AccessControlList();
  mockAcl.setResourceAccess(new HashSet<ResourceAccess>());
  mockTeamAcl.setResourceAccess(new HashSet<ResourceAccess>());
  when(mockSynapseClient.createTeam(any())).thenReturn(mockTeam);
  when(mockSynapseClient.createEntity(any())).thenReturn(mockProject);
  when(mockSynapseClient.getACL(any())).thenReturn(mockAcl);
  when(mockSynapseClient.getTeamACL(any())).thenReturn(mockTeamAcl);
  Study retStudy=service.createSynapseProjectTeam(TEST_USER_ID,study);
  verify(mockSynapseClient).createTeam(any());
  verify(mockSynapseClient).createEntity(any());
  verify(mockSynapseClient).getACL(eq(TEST_PROJECT_ID));
  ArgumentCaptor<AccessControlList> argumentProjectAcl=ArgumentCaptor.forClass(AccessControlList.class);
  verify(mockSynapseClient).updateACL(argumentProjectAcl.capture());
  AccessControlList capturedProjectAcl=argumentProjectAcl.getValue();
  Set<ResourceAccess> capturedProjectAclSet=capturedProjectAcl.getResourceAccess();
  assertNotNull(capturedProjectAclSet);
  assertEquals(capturedProjectAclSet.size(),2);
  List<ResourceAccess> retListForExporter=capturedProjectAclSet.stream().filter(ra -> ra.getPrincipalId().equals(Long.parseLong(EXPORTER_SYNAPSE_USER_ID))).collect(Collectors.toList());
  assertNotNull(retListForExporter);
  assertEquals(retListForExporter.size(),1);
  ResourceAccess capturedExporterRa=retListForExporter.get(0);
  assertNotNull(capturedExporterRa);
  assertEquals(capturedExporterRa.getPrincipalId().toString(),EXPORTER_SYNAPSE_USER_ID);
  assertEquals(capturedExporterRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  List<ResourceAccess> retListForUser=capturedProjectAclSet.stream().filter(ra -> ra.getPrincipalId().equals(TEST_USER_ID)).collect(Collectors.toList());
  assertNotNull(retListForUser);
  assertEquals(retListForUser.size(),1);
  ResourceAccess capturedUserRa=retListForUser.get(0);
  assertNotNull(capturedUserRa);
  assertEquals(capturedUserRa.getPrincipalId(),TEST_USER_ID);
  assertEquals(capturedUserRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  verify(mockSynapseClient).createMembershipInvitation(eq(mockTeamMemberInvitation),any(),any());
  verify(mockSynapseClient).setTeamMemberPermissions(eq(TEST_TEAM_ID),eq(TEST_USER_ID.toString()),anyBoolean());
  assertNotNull(retStudy);
  assertEquals(retStudy.getIdentifier(),study.getIdentifier());
  assertEquals(retStudy.getName(),study.getName());
  assertEquals(retStudy.getSynapseProjectId(),TEST_PROJECT_ID);
  assertEquals(retStudy.getSynapseDataAccessTeamId().toString(),TEST_TEAM_ID);
}","@Test public void createSynapseProjectTeam() throws SynapseException {
  Study study=getTestStudy();
  study.setSynapseProjectId(null);
  study.setSynapseDataAccessTeamId(null);
  AccessControlList mockAcl=new AccessControlList();
  AccessControlList mockTeamAcl=new AccessControlList();
  mockAcl.setResourceAccess(new HashSet<ResourceAccess>());
  mockTeamAcl.setResourceAccess(new HashSet<ResourceAccess>());
  when(mockSynapseClient.createTeam(any())).thenReturn(mockTeam);
  when(mockSynapseClient.createEntity(any())).thenReturn(mockProject);
  when(mockSynapseClient.getACL(any())).thenReturn(mockAcl);
  when(mockSynapseClient.getTeamACL(any())).thenReturn(mockTeamAcl);
  Study retStudy=service.createSynapseProjectTeam(TEST_USER_ID,study);
  verify(mockSynapseClient).createTeam(any());
  verify(mockSynapseClient).createEntity(any());
  verify(mockSynapseClient).getACL(eq(TEST_PROJECT_ID));
  ArgumentCaptor<AccessControlList> argumentProjectAcl=ArgumentCaptor.forClass(AccessControlList.class);
  verify(mockSynapseClient).updateACL(argumentProjectAcl.capture());
  AccessControlList capturedProjectAcl=argumentProjectAcl.getValue();
  Set<ResourceAccess> capturedProjectAclSet=capturedProjectAcl.getResourceAccess();
  assertNotNull(capturedProjectAclSet);
  assertEquals(capturedProjectAclSet.size(),2);
  List<ResourceAccess> retListForExporter=capturedProjectAclSet.stream().filter(ra -> ra.getPrincipalId().equals(Long.parseLong(EXPORTER_SYNAPSE_USER_ID))).collect(Collectors.toList());
  assertNotNull(retListForExporter);
  assertEquals(retListForExporter.size(),1);
  ResourceAccess capturedExporterRa=retListForExporter.get(0);
  assertNotNull(capturedExporterRa);
  assertEquals(capturedExporterRa.getPrincipalId().toString(),EXPORTER_SYNAPSE_USER_ID);
  assertEquals(capturedExporterRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  List<ResourceAccess> retListForUser=capturedProjectAclSet.stream().filter(ra -> ra.getPrincipalId().equals(TEST_USER_ID)).collect(Collectors.toList());
  assertNotNull(retListForUser);
  assertEquals(retListForUser.size(),1);
  ResourceAccess capturedUserRa=retListForUser.get(0);
  assertNotNull(capturedUserRa);
  assertEquals(capturedUserRa.getPrincipalId(),TEST_USER_ID);
  assertEquals(capturedUserRa.getAccessType(),ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  verify(mockSynapseClient).createMembershipInvitation(eq(mockTeamMemberInvitation),any(),any());
  verify(mockSynapseClient).setTeamMemberPermissions(eq(TEST_TEAM_ID),eq(TEST_USER_ID.toString()),anyBoolean());
  assertNotNull(retStudy);
  assertEquals(retStudy.getIdentifier(),study.getIdentifier());
  assertEquals(retStudy.getName(),study.getName());
  assertEquals(retStudy.getSynapseProjectId(),TEST_PROJECT_ID);
  assertEquals(retStudy.getSynapseDataAccessTeamId().toString(),TEST_TEAM_ID);
}",0.9862769559793264
25721,"public Result createSynapse(String userId) throws Exception {
  UserSession session=getAuthenticatedSession(DEVELOPER,RESEARCHER,ADMIN);
  Study study=studyService.getStudy(session.getStudyIdentifier());
  Long userIdNum=Long.parseLong(userId);
  studyService.createSynapseProjectTeam(userIdNum,study);
  return okResult(new SynapseProjectTeamCreationHolder(study.getSynapseProjectId(),study.getSynapseDataAccessTeamId()));
}","public Result createSynapse(String userId) throws Exception {
  UserSession session=getAuthenticatedSession(DEVELOPER);
  Study study=studyService.getStudy(session.getStudyIdentifier());
  Long userIdNum=Long.parseLong(userId);
  studyService.createSynapseProjectTeam(userIdNum,study);
  return createdResult(new SynapseProjectIdTeamIdHolder(study.getSynapseProjectId(),study.getSynapseDataAccessTeamId()));
}",0.9544364508393284
25722,"public Study createSynapseProjectTeam(Long userId,Study study) throws SynapseException {
  Team team=new Team();
  team.setName(randomAlphanumeric(5) + ""String_Node_Str"");
  Project project=new Project();
  project.setName(randomAlphanumeric(5) + ""String_Node_Str"");
  Team newTeam=synapseClient.createTeam(team);
  Project newProject=synapseClient.createEntity(project);
  org.sagebionetworks.repo.model.AccessControlList acl=synapseClient.getACL(newProject.getId());
  ResourceAccess toSet=new ResourceAccess();
  toSet.setPrincipalId(Long.parseLong(EXPORTER_SYNAPSE_USER_ID));
  toSet.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSet);
  ResourceAccess toSetUser=new ResourceAccess();
  toSetUser.setPrincipalId(userId);
  toSetUser.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSetUser);
  synapseClient.updateACL(acl);
  MembershipInvtnSubmission teamMemberInvitation=new MembershipInvtnSubmission();
  teamMemberInvitation.setInviteeId(userId.toString());
  teamMemberInvitation.setTeamId(newTeam.getId());
  synapseClient.createMembershipInvitation(teamMemberInvitation,null,null);
  synapseClient.setTeamMemberPermissions(newTeam.getId(),userId.toString(),true);
  String newTeamId=newTeam.getId();
  String newProjectId=newProject.getId();
  study.setSynapseProjectId(newProjectId);
  study.setSynapseDataAccessTeamId(Long.parseLong(newTeamId));
  updateStudy(study,false);
  return study;
}","public Study createSynapseProjectTeam(Long userId,Study study) throws SynapseException {
  Team team=new Team();
  team.setName(study.getName() + ""String_Node_Str"");
  Project project=new Project();
  project.setName(study.getName() + ""String_Node_Str"");
  Team newTeam=synapseClient.createTeam(team);
  Project newProject=synapseClient.createEntity(project);
  org.sagebionetworks.repo.model.AccessControlList acl=synapseClient.getACL(newProject.getId());
  ResourceAccess toSet=new ResourceAccess();
  toSet.setPrincipalId(Long.parseLong(EXPORTER_SYNAPSE_USER_ID));
  toSet.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSet);
  ResourceAccess toSetUser=new ResourceAccess();
  toSetUser.setPrincipalId(userId);
  toSetUser.setAccessType(ModelConstants.ENITY_ADMIN_ACCESS_PERMISSIONS);
  acl.getResourceAccess().add(toSetUser);
  synapseClient.updateACL(acl);
  MembershipInvtnSubmission teamMemberInvitation=new MembershipInvtnSubmission();
  teamMemberInvitation.setInviteeId(userId.toString());
  teamMemberInvitation.setTeamId(newTeam.getId());
  synapseClient.createMembershipInvitation(teamMemberInvitation,null,null);
  synapseClient.setTeamMemberPermissions(newTeam.getId(),userId.toString(),true);
  String newTeamId=newTeam.getId();
  String newProjectId=newProject.getId();
  study.setSynapseProjectId(newProjectId);
  study.setSynapseDataAccessTeamId(Long.parseLong(newTeamId));
  updateStudy(study,false);
  return study;
}",0.97719651240778
25723,"/** 
 * Gets validation status and messages for the given upload ID. 
 */
public Result getValidationStatus(String uploadId) throws JsonProcessingException {
  UserSession session=getAuthenticatedAndConsentedSession();
  UploadValidationStatus validationStatus=uploadService.getUploadValidationStatus(uploadId);
  if (!session.getHealthCode().equals(validationStatus.getRecord().getHealthCode())) {
    throw new UnauthorizedException();
  }
  return ok(HealthDataRecord.PUBLIC_RECORD_WRITER.writeValueAsString(validationStatus));
}","/** 
 * Gets validation status and messages for the given upload ID. 
 */
public Result getValidationStatus(String uploadId) throws JsonProcessingException {
  UserSession session=getAuthenticatedAndConsentedSession();
  Upload upload=uploadService.getUpload(uploadId);
  if (!session.getHealthCode().equals(upload.getHealthCode())) {
    throw new UnauthorizedException();
  }
  UploadValidationStatus validationStatus=uploadService.getUploadValidationStatus(uploadId);
  return ok(HealthDataRecord.PUBLIC_RECORD_WRITER.writeValueAsString(validationStatus));
}",0.7904849039341263
25724,"@Before public void before(){
  controller.setUploadService(uploadService);
  controller.setHealthCodeDao(healthCodeDao);
  DynamoUpload2 upload=new DynamoUpload2();
  upload.setHealthCode(""String_Node_Str"");
  upload.setUploadId(""String_Node_Str"");
  doReturn(upload).when(uploadService).getUpload(""String_Node_Str"");
  doReturn(metrics).when(controller).getMetrics();
  doReturn(""String_Node_Str"").when(workerSession).getHealthCode();
  doReturn(new StudyIdentifierImpl(""String_Node_Str"")).when(workerSession).getStudyIdentifier();
  doReturn(true).when(workerSession).isInRole(Roles.WORKER);
  doReturn(""String_Node_Str"").when(consentedUserSession).getHealthCode();
  doReturn(new StudyIdentifierImpl(""String_Node_Str"")).when(consentedUserSession).getStudyIdentifier();
  doReturn(false).when(consentedUserSession).isInRole(Roles.WORKER);
  doReturn(""String_Node_Str"").when(healthCodeDao).getStudyIdentifier(""String_Node_Str"");
  doReturn(""String_Node_Str"").when(healthCodeDao).getStudyIdentifier(""String_Node_Str"");
}","@Before public void before(){
  controller.setUploadService(uploadService);
  controller.setHealthCodeDao(healthCodeDao);
  DynamoUpload2 upload=new DynamoUpload2();
  upload.setHealthCode(""String_Node_Str"");
  upload.setUploadId(""String_Node_Str"");
  doReturn(upload).when(uploadService).getUpload(""String_Node_Str"");
  doReturn(metrics).when(controller).getMetrics();
  doReturn(""String_Node_Str"").when(workerSession).getHealthCode();
  doReturn(new StudyIdentifierImpl(""String_Node_Str"")).when(workerSession).getStudyIdentifier();
  doReturn(true).when(workerSession).isInRole(Roles.WORKER);
  doReturn(""String_Node_Str"").when(consentedUserSession).getHealthCode();
  doReturn(new StudyIdentifierImpl(""String_Node_Str"")).when(consentedUserSession).getStudyIdentifier();
  doReturn(false).when(consentedUserSession).isInRole(Roles.WORKER);
  doReturn(""String_Node_Str"").when(otherUserSession).getHealthCode();
  doReturn(""String_Node_Str"").when(healthCodeDao).getStudyIdentifier(""String_Node_Str"");
  doReturn(""String_Node_Str"").when(healthCodeDao).getStudyIdentifier(""String_Node_Str"");
}",0.9668560606060606
25725,"/** 
 * Retrieve external IDs that match the ID and/or assignment filters. These records are returned in pages of pageSize  records. Each page is identified by the offsetKey of the last record of the immediately prior page. If that value is  null, there is not a further page of IDs to retrieve. More interestingly, you can retrieve the next available ID by asking for pageSize=1, assignmentFilter=FALSE.
 * @param studyId study of caller
 * @param offsetKey if it exists, the key that must be passed to the next call of getExternalIds() to move the cursor forward one  more page.
 * @param pageSize the number of records to return
 * @param idFilter a case-sensitive string that must be found in an external identifier to return it in the results
 * @param assignmentFilter an optional boolean (can be null). If TRUE, all records returned will be assigned. More usefully, if FALSE, will return unassigned external identifiers. 
 */
PagedResourceList<String> getExternalIds(StudyIdentifier studyId,String offsetKey,int pageSize,String idFilter,Boolean assignmentFilter);","/** 
 * Retrieve external IDs that match the ID and/or assignment filters. These records are returned in pages of pageSize  records. Each page is identified by the offsetKey of the last record of the immediately prior page. If that value is  null, there is not a further page of IDs to retrieve. More interestingly, you can retrieve the next available ID by asking for pageSize=1, assignmentFilter=FALSE.
 * @param studyId study of caller
 * @param offsetKey if it exists, the key that must be passed to the next call of getExternalIds() to move the cursor forward one  more page.
 * @param pageSize the number of records to return
 * @param idFilter a case-sensitive string that must be found in an external identifier to return it in the results
 * @param assignmentFilter an optional boolean (can be null). If TRUE, all records returned will be assigned. More usefully, if FALSE, will return unassigned external identifiers. 
 */
PagedResourceList<ExternalIdentifierInfo> getExternalIds(StudyIdentifier studyId,String offsetKey,int pageSize,String idFilter,Boolean assignmentFilter);",0.9823747680890538
25726,"@Override public void addExternalIds(StudyIdentifier studyId,List<String> externalIds){
  checkNotNull(studyId);
  checkNotNull(externalIds);
  if (externalIds.size() > addLimit) {
    throw new BadRequestException(""String_Node_Str"" + externalIds.size() + ""String_Node_Str""+ addLimit);
  }
  for (  String id : externalIds) {
    if (StringUtils.isBlank(id)) {
      throw new BadRequestException(""String_Node_Str"");
    }
  }
  if (!externalIds.isEmpty()) {
    List<DynamoExternalIdentifier> idsToSave=externalIds.stream().map(id -> {
      return new DynamoExternalIdentifier(studyId,id);
    }
).filter(externalId -> {
      return mapper.load(externalId) == null;
    }
).collect(Collectors.toList());
    if (!idsToSave.isEmpty()) {
      List<FailedBatch> failures=mapper.batchSave(idsToSave);
      BridgeUtils.ifFailuresThrowException(failures);
    }
  }
}","@Override public void addExternalIds(StudyIdentifier studyId,List<String> externalIds){
  checkNotNull(studyId);
  checkNotNull(externalIds);
  if (externalIds.size() > addLimit) {
    throw new BadRequestException(""String_Node_Str"" + externalIds.size() + ""String_Node_Str""+ addLimit);
  }
  List<DynamoExternalIdentifier> idsToSave=externalIds.stream().map(id -> {
    return new DynamoExternalIdentifier(studyId,id);
  }
).filter(externalId -> {
    return mapper.load(externalId) == null;
  }
).collect(Collectors.toList());
  if (!idsToSave.isEmpty()) {
    List<FailedBatch> failures=mapper.batchSave(idsToSave);
    BridgeUtils.ifFailuresThrowException(failures);
  }
}",0.8760545100584036
25727,"@Override public PagedResourceList<String> getExternalIds(StudyIdentifier studyId,String offsetKey,int pageSize,String idFilter,Boolean assignmentFilter){
  checkNotNull(studyId);
  if (pageSize < 1 || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  PaginatedQueryList<DynamoExternalIdentifier> list=mapper.query(DynamoExternalIdentifier.class,createGetQuery(studyId,offsetKey,pageSize,idFilter,assignmentFilter));
  int total=mapper.count(DynamoExternalIdentifier.class,createCountQuery(studyId,idFilter,assignmentFilter));
  List<String> identifiers=Lists.newArrayListWithCapacity(pageSize);
  Iterator<? extends ExternalIdentifier> iterator=list.iterator();
  while (iterator.hasNext() && identifiers.size() < pageSize) {
    identifiers.add(iterator.next().getIdentifier());
  }
  String lastKey=(iterator.hasNext()) ? last(identifiers) : null;
  PagedResourceList<String> resourceList=new PagedResourceList<String>(identifiers,null,pageSize,total).withLastKey(lastKey).withFilter(ID_FILTER,idFilter);
  if (assignmentFilter != null) {
    resourceList=resourceList.withFilter(ASSIGNMENT_FILTER,assignmentFilter.toString());
  }
  return resourceList;
}","@Override public PagedResourceList<ExternalIdentifierInfo> getExternalIds(StudyIdentifier studyId,String offsetKey,int pageSize,String idFilter,Boolean assignmentFilter){
  checkNotNull(studyId);
  if (pageSize < 1 || pageSize > API_MAXIMUM_PAGE_SIZE) {
    throw new BadRequestException(PAGE_SIZE_ERROR);
  }
  if (offsetKey != null && idFilter != null && idFilter.indexOf(offsetKey) != 0) {
    offsetKey=null;
  }
  PaginatedQueryList<DynamoExternalIdentifier> list=mapper.query(DynamoExternalIdentifier.class,createGetQuery(studyId,offsetKey,pageSize,idFilter,assignmentFilter));
  int total=mapper.count(DynamoExternalIdentifier.class,createCountQuery(studyId,idFilter,assignmentFilter));
  List<ExternalIdentifierInfo> identifiers=Lists.newArrayListWithCapacity(pageSize);
  Iterator<? extends ExternalIdentifier> iterator=list.iterator();
  while (iterator.hasNext() && identifiers.size() < pageSize) {
    ExternalIdentifier id=iterator.next();
    identifiers.add(createInfo(id,lockDuration));
  }
  String nextPageOffsetKey=(iterator.hasNext()) ? last(identifiers).getIdentifier() : null;
  PagedResourceList<ExternalIdentifierInfo> resourceList=new PagedResourceList<ExternalIdentifierInfo>(identifiers,null,pageSize,total).withOffsetKey(nextPageOffsetKey).withFilter(ID_FILTER,idFilter);
  if (assignmentFilter != null) {
    resourceList=resourceList.withFilter(ASSIGNMENT_FILTER,assignmentFilter.toString());
  }
  return resourceList;
}",0.8462697814619442
25728,"public Result getExternalIds(String offsetKey,String pageSizeString,String idFilter,String assignmentFilterString){
  UserSession session=getAuthenticatedSession(DEVELOPER);
  Study study=studyService.getStudy(session.getStudyIdentifier());
  Integer pageSize=(pageSizeString != null) ? Integer.parseInt(pageSizeString,10) : null;
  Boolean assignmentFilter=(assignmentFilterString != null) ? Boolean.valueOf(assignmentFilterString) : null;
  PagedResourceList<String> page=externalIdService.getExternalIds(study,offsetKey,pageSize,idFilter,assignmentFilter);
  return okResult(page);
}","public Result getExternalIds(String offsetKey,String pageSizeString,String idFilter,String assignmentFilterString){
  UserSession session=getAuthenticatedSession(DEVELOPER);
  Study study=studyService.getStudy(session.getStudyIdentifier());
  Integer pageSize=(pageSizeString != null) ? Integer.parseInt(pageSizeString,10) : null;
  Boolean assignmentFilter=(assignmentFilterString != null) ? Boolean.valueOf(assignmentFilterString) : null;
  PagedResourceList<ExternalIdentifierInfo> page=externalIdService.getExternalIds(study,offsetKey,pageSize,idFilter,assignmentFilter);
  return okResult(page);
}",0.9764309764309764
25729,"public void addExternalIds(Study study,List<String> externalIdentifiers){
  checkNotNull(study);
  checkNotNull(externalIdentifiers);
  externalIdDao.addExternalIds(study.getStudyIdentifier(),externalIdentifiers);
}","public void addExternalIds(Study study,List<String> externalIdentifiers){
  checkNotNull(study);
  checkNotNull(externalIdentifiers);
  Validate.entityThrowingException(validator,new ExternalIdsValidator.ExternalIdList(externalIdentifiers));
  externalIdDao.addExternalIds(study.getStudyIdentifier(),externalIdentifiers);
}",0.7992565055762082
25730,"public PagedResourceList<String> getExternalIds(Study study,String offsetKey,Integer pageSize,String idFilter,Boolean assignmentFilter){
  checkNotNull(study);
  if (pageSize == null) {
    pageSize=BridgeConstants.API_DEFAULT_PAGE_SIZE;
  }
  return externalIdDao.getExternalIds(study.getStudyIdentifier(),offsetKey,pageSize,idFilter,assignmentFilter);
}","public PagedResourceList<ExternalIdentifierInfo> getExternalIds(Study study,String offsetKey,Integer pageSize,String idFilter,Boolean assignmentFilter){
  checkNotNull(study);
  if (pageSize == null) {
    pageSize=BridgeConstants.API_DEFAULT_PAGE_SIZE;
  }
  return externalIdDao.getExternalIds(study.getStudyIdentifier(),offsetKey,pageSize,idFilter,assignmentFilter);
}",0.9614325068870524
25731,"private UserSession getSessionFromAccount(Study study,CriteriaContext context,Account account){
  final UserSession session=getSession(account);
  session.setAuthenticated(true);
  session.setEnvironment(config.getEnvironment());
  session.setStudyIdentifier(study.getStudyIdentifier());
  final User user=new User(account);
  user.setStudyKey(study.getIdentifier());
  final String healthCode=getHealthCode(study,account);
  user.setHealthCode(healthCode);
  ParticipantOptionsLookup lookup=optionsService.getOptions(healthCode);
  user.setSharingScope(lookup.getEnum(SHARING_SCOPE,SharingScope.class));
  user.setDataGroups(lookup.getStringSet(DATA_GROUPS));
  user.setLanguages(lookup.getOrderedStringSet(LANGUAGES));
  if (user.getLanguages().isEmpty() && !context.getLanguages().isEmpty()) {
    user.setLanguages(context.getLanguages());
    optionsService.setOrderedStringSet(study,healthCode,LANGUAGES,context.getLanguages());
  }
  CriteriaContext newContext=new CriteriaContext.Builder().withContext(context).withLanguages(user.getLanguages()).withHealthCode(user.getHealthCode()).withUserDataGroups(user.getDataGroups()).build();
  user.setConsentStatuses(consentService.getConsentStatuses(newContext));
  session.setUser(user);
  return session;
}","private UserSession getSessionFromAccount(Study study,CriteriaContext context,Account account){
  final UserSession session=getSession(account);
  session.setAuthenticated(true);
  session.setEnvironment(config.getEnvironment());
  session.setStudyIdentifier(study.getStudyIdentifier());
  final User user=new User(account);
  user.setStudyKey(study.getIdentifier());
  final String healthCode=getHealthCode(study,account);
  user.setHealthCode(healthCode);
  ParticipantOptionsLookup lookup=optionsService.getOptions(healthCode);
  user.setSharingScope(lookup.getEnum(SHARING_SCOPE,SharingScope.class));
  user.setDataGroups(lookup.getStringSet(DATA_GROUPS));
  user.setLanguages(lookup.getOrderedStringSet(LANGUAGES));
  if (user.getLanguages().isEmpty() && !context.getLanguages().isEmpty()) {
    user.setLanguages(context.getLanguages());
    optionsService.setOrderedStringSet(study,healthCode,LANGUAGES,context.getLanguages());
  }
  CriteriaContext newContext=new CriteriaContext.Builder().withContext(context).withLanguages(user.getLanguages()).withHealthCode(user.getHealthCode()).withUserDataGroups(user.getDataGroups()).build();
  user.setConsentStatuses(consentService.getConsentStatuses(newContext));
  session.setUser(user);
  repairConsents(account,session,newContext);
  return session;
}",0.9820592823712948
25732,"public UserSession signIn(Study study,CriteriaContext context,SignIn signIn) throws EntityNotFoundException {
  checkNotNull(study,""String_Node_Str"");
  checkNotNull(signIn,""String_Node_Str"");
  Validate.entityThrowingException(signInValidator,signIn);
  final String signInLock=study.getIdentifier() + RedisKey.SEPARATOR + signIn.getEmail();
  String lockId=null;
  try {
    lockId=lockDao.acquireLock(SignIn.class,signInLock,LOCK_EXPIRE_IN_SECONDS);
    Account account=accountDao.authenticate(study,signIn);
    UserSession session=getSessionFromAccount(study,context,account);
    repairConsents(account,session,context);
    cacheProvider.setUserSession(session);
    return session;
  }
  finally {
    if (lockId != null) {
      lockDao.releaseLock(SignIn.class,signInLock,lockId);
    }
  }
}","public UserSession signIn(Study study,CriteriaContext context,SignIn signIn) throws EntityNotFoundException {
  checkNotNull(study,""String_Node_Str"");
  checkNotNull(signIn,""String_Node_Str"");
  Validate.entityThrowingException(signInValidator,signIn);
  final String signInLock=study.getIdentifier() + RedisKey.SEPARATOR + signIn.getEmail();
  String lockId=null;
  try {
    lockId=lockDao.acquireLock(SignIn.class,signInLock,LOCK_EXPIRE_IN_SECONDS);
    Account account=accountDao.authenticate(study,signIn);
    UserSession session=getSessionFromAccount(study,context,account);
    cacheProvider.setUserSession(session);
    return session;
  }
  finally {
    if (lockId != null) {
      lockDao.releaseLock(SignIn.class,signInLock,lockId);
    }
  }
}",0.971135343168698
25733,"@Test public void userWithSignatureAndNoDbRecordIsRepaired() throws Exception {
  TestUser user=helper.getBuilder(AuthenticationServiceTest.class).withConsent(true).withSignIn(true).build();
  try {
    authService.signOut(user.getSession());
    Account account=accountDao.getAccount(testUser.getStudy(),testUser.getEmail());
    List<Subpopulation> subpops=subpopService.getSubpopulations(user.getStudyIdentifier());
    for (    Subpopulation subpop : subpops) {
      userConsentDao.deleteAllConsents(user.getUser().getHealthCode(),subpop.getGuid());
      ConsentSignature sig=account.getConsentSignatureHistory(subpop.getGuid()).get(0);
      sig=new ConsentSignature.Builder().withConsentSignature(sig).withSignedOn(0L).build();
      com.stormpath.sdk.account.Account stormpathAcct=((StormpathAccount)account).getAccount();
      CustomData data=stormpathAcct.getCustomData();
      data.put(subpop.getGuidString() + ""String_Node_Str"",BridgeObjectMapper.get().writeValueAsString(sig));
      data.put(subpop.getGuidString() + ""String_Node_Str"",2);
      data.remove(subpop.getGuidString() + ""String_Node_Str"");
      data.remove(subpop.getGuidString() + ""String_Node_Str"");
    }
    accountDao.updateAccount(testUser.getStudy(),account);
    Study study=studyService.getStudy(user.getStudyIdentifier());
    CriteriaContext context=testUser.getCriteriaContext();
    UserSession session=authService.signIn(study,context,user.getSignIn());
    for (    ConsentStatus status : session.getUser().getConsentStatuses().values()) {
      assertTrue(!status.isRequired() || status.isConsented());
      UserConsent consent=userConsentDao.getActiveUserConsent(session.getUser().getHealthCode(),SubpopulationGuid.create(status.getSubpopulationGuid()));
      assertTrue(consent.getSignedOn() > 0L);
    }
  }
  finally {
    helper.deleteUser(user);
  }
}","@Test public void userWithSignatureAndNoDbRecordIsRepaired() throws Exception {
  TestUser user=helper.getBuilder(AuthenticationServiceTest.class).withConsent(true).withSignIn(true).build();
  try {
    authService.signOut(user.getSession());
    Account account=accountDao.getAccount(testUser.getStudy(),testUser.getEmail());
    List<Subpopulation> subpops=subpopService.getSubpopulations(user.getStudyIdentifier());
    for (    Subpopulation subpop : subpops) {
      userConsentDao.deleteAllConsents(user.getUser().getHealthCode(),subpop.getGuid());
      ConsentSignature sig=account.getConsentSignatureHistory(subpop.getGuid()).get(0);
      sig=new ConsentSignature.Builder().withConsentSignature(sig).withSignedOn(0L).build();
      com.stormpath.sdk.account.Account stormpathAcct=((StormpathAccount)account).getAccount();
      CustomData data=stormpathAcct.getCustomData();
      data.put(subpop.getGuidString() + ""String_Node_Str"",BridgeObjectMapper.get().writeValueAsString(sig));
      data.put(subpop.getGuidString() + ""String_Node_Str"",2);
      data.remove(subpop.getGuidString() + ""String_Node_Str"");
      data.remove(subpop.getGuidString() + ""String_Node_Str"");
    }
    accountDao.updateAccount(testUser.getStudy(),account);
    Study study=studyService.getStudy(user.getStudyIdentifier());
    CriteriaContext context=new CriteriaContext.Builder().withStudyIdentifier(study.getStudyIdentifier()).withLanguages(TestUtils.newLinkedHashSet(""String_Node_Str"")).withClientInfo(ClientInfo.UNKNOWN_CLIENT).build();
    UserSession session=authService.signIn(study,context,user.getSignIn());
    for (    ConsentStatus status : session.getUser().getConsentStatuses().values()) {
      assertTrue(!status.isRequired() || status.isConsented());
      UserConsent consent=userConsentDao.getActiveUserConsent(session.getUser().getHealthCode(),SubpopulationGuid.create(status.getSubpopulationGuid()));
      assertTrue(consent.getSignedOn() > 0L);
    }
  }
  finally {
    helper.deleteUser(user);
  }
}",0.9470147324890152
25734,"@Test public void testWrite() throws Exception {
  MpowerVisualizationController controller=spy(new MpowerVisualizationController());
  doReturn(new UserSession()).when(controller).getAuthenticatedSession(Roles.WORKER);
  MpowerVisualizationService mockSvc=mock(MpowerVisualizationService.class);
  controller.setMpowerVisualizationService(mockSvc);
  String requestJsonText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  Http.Context.current.set(TestUtils.mockPlayContextWithJson(requestJsonText));
  Result result=controller.writeVisualization();
  assertEquals(201,result.status());
  ArgumentCaptor<MpowerVisualization> vizCaptor=ArgumentCaptor.forClass(MpowerVisualization.class);
  verify(mockSvc).writeVisualization(vizCaptor.capture());
  MpowerVisualization viz=vizCaptor.getValue();
  assertEquals(""String_Node_Str"",viz.getVisualization().textValue());
  verify(controller).getAuthenticatedSession(Roles.WORKER);
}","@Test public void testWrite() throws Exception {
  MpowerVisualizationController controller=spy(new MpowerVisualizationController());
  doReturn(new UserSession()).when(controller).getAuthenticatedSession(Roles.WORKER);
  MpowerVisualizationService mockSvc=mock(MpowerVisualizationService.class);
  controller.setMpowerVisualizationService(mockSvc);
  String requestJsonText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  TestUtils.mockPlayContextWithJson(requestJsonText);
  Result result=controller.writeVisualization();
  assertEquals(201,result.status());
  ArgumentCaptor<MpowerVisualization> vizCaptor=ArgumentCaptor.forClass(MpowerVisualization.class);
  verify(mockSvc).writeVisualization(vizCaptor.capture());
  MpowerVisualization viz=vizCaptor.getValue();
  assertEquals(""String_Node_Str"",viz.getVisualization().textValue());
  verify(controller).getAuthenticatedSession(Roles.WORKER);
}",0.985945945945946
25735,"@Override public Account authenticate(Study study,SignIn signIn){
  checkNotNull(study);
  checkNotNull(signIn);
  checkArgument(isNotBlank(signIn.getUsername()));
  checkArgument(isNotBlank(signIn.getPassword()));
  try {
    Directory directory=client.getResource(study.getStormpathHref(),Directory.class);
    List<SubpopulationGuid> subpopGuids=getSubpopulationGuids(study);
    UsernamePasswordRequest request=new UsernamePasswordRequest(signIn.getUsername(),signIn.getPassword(),directory);
    AuthenticationResult result=application.authenticateAccount(request);
    if (result.getAccount() != null) {
      return new StormpathAccount(study.getStudyIdentifier(),subpopGuids,result.getAccount(),encryptors);
    }
  }
 catch (  ResourceException e) {
    rethrowResourceException(e,null);
  }
  throw new BridgeServiceException(""String_Node_Str"");
}","@Override public Account authenticate(Study study,SignIn signIn){
  checkNotNull(study);
  checkNotNull(signIn);
  checkArgument(isNotBlank(signIn.getUsername()));
  checkArgument(isNotBlank(signIn.getPassword()));
  try {
    Directory directory=client.getResource(study.getStormpathHref(),Directory.class);
    List<SubpopulationGuid> subpopGuids=getSubpopulationGuids(study);
    AuthenticationRequest<?,?> request=UsernamePasswordRequest.builder().setUsernameOrEmail(signIn.getUsername()).setPassword(signIn.getPassword()).inAccountStore(directory).build();
    AuthenticationResult result=application.authenticateAccount(request);
    if (result.getAccount() != null) {
      return new StormpathAccount(study.getStudyIdentifier(),subpopGuids,result.getAccount(),encryptors);
    }
  }
 catch (  ResourceException e) {
    rethrowResourceException(e,null);
  }
  throw new BridgeServiceException(""String_Node_Str"");
}",0.8746486790331647
25736,"@Override public void deleteDirectoryForStudy(Study study){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  Application app=getApplication();
  checkNotNull(app);
  Directory existing=getDirectoryForStudy(study);
  AccountStoreMapping mapping=getApplicationMapping(existing.getHref(),app);
  if (mapping != null) {
    mapping.delete();
  }
 else {
    logger.warn(""String_Node_Str"" + app.getName() + ""String_Node_Str""+ existing.getHref());
  }
  Directory directory=client.getResource(existing.getHref(),Directory.class);
  if (directory != null) {
    directory.delete();
  }
 else {
    logger.warn(""String_Node_Str"" + existing.getHref());
  }
}","@Override public void deleteDirectoryForStudy(Study study){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  Application app=getApplication();
  checkNotNull(app);
  Directory existing=getDirectoryForStudy(study);
  ApplicationAccountStoreMapping mapping=getApplicationMapping(existing.getHref(),app);
  if (mapping != null) {
    mapping.delete();
  }
 else {
    logger.warn(""String_Node_Str"" + app.getName() + ""String_Node_Str""+ existing.getHref());
  }
  Directory directory=client.getResource(existing.getHref(),Directory.class);
  if (directory != null) {
    directory.delete();
  }
 else {
    logger.warn(""String_Node_Str"" + existing.getHref());
  }
}",0.99182156133829
25737,"private void adjustVerifyEmailPolicies(Study study,Directory directory){
  AccountCreationPolicy policy=directory.getAccountCreationPolicy();
  ModeledEmailTemplate template=policy.getAccountVerificationEmailTemplates().iterator().next();
  updateTemplate(study,template,study.getVerifyEmailTemplate(),""String_Node_Str"");
  policy.setVerificationEmailStatus(EmailStatus.ENABLED);
  policy.setVerificationSuccessEmailStatus(EmailStatus.DISABLED);
  policy.setWelcomeEmailStatus(EmailStatus.DISABLED);
  policy.save();
}","private void adjustVerifyEmailPolicies(Study study,Directory directory){
  AccountCreationPolicy policy=directory.getAccountCreationPolicy();
  for (  ModeledEmailTemplate template : policy.getAccountVerificationEmailTemplates()) {
    updateTemplate(study,template,study.getVerifyEmailTemplate(),""String_Node_Str"");
  }
  policy.setVerificationEmailStatus(EmailStatus.ENABLED);
  policy.setVerificationSuccessEmailStatus(EmailStatus.DISABLED);
  policy.setWelcomeEmailStatus(EmailStatus.DISABLED);
  policy.save();
}",0.9603864734299516
25738,"private static AccountStoreMapping getApplicationMapping(String href,Application app){
  for (  AccountStoreMapping mapping : app.getAccountStoreMappings(asmCriteria)) {
    if (mapping.getAccountStore().getHref().equals(href)) {
      return mapping;
    }
  }
  return null;
}","private static ApplicationAccountStoreMapping getApplicationMapping(String href,Application app){
  for (  ApplicationAccountStoreMapping mapping : app.getApplicationAccountStoreMappings(asmCriteria)) {
    if (mapping.getAccountStore().getHref().equals(href)) {
      return mapping;
    }
  }
  return null;
}",0.9439728353140916
25739,"@Override public String createDirectoryForStudy(Study study){
  checkNotNull(study);
  checkArgument(isNotBlank(study.getIdentifier()),Validate.CANNOT_BE_BLANK,""String_Node_Str"");
  Application app=getApplication();
  checkNotNull(app);
  String dirName=createDirectoryName(study.getIdentifier());
  Directory directory=getDirectoryForStudy(study);
  if (directory == null) {
    directory=client.instantiate(Directory.class);
    directory.setName(dirName);
    directory=client.createDirectory(directory);
  }
  adjustPasswordPolicies(study,directory);
  adjustVerifyEmailPolicies(study,directory);
  AccountStoreMapping mapping=getApplicationMapping(directory.getHref(),app);
  if (mapping == null) {
    mapping=client.instantiate(AccountStoreMapping.class);
    mapping.setAccountStore(directory);
    mapping.setApplication(app);
    mapping.setDefaultAccountStore(Boolean.FALSE);
    mapping.setDefaultGroupStore(Boolean.FALSE);
    mapping.setListIndex(10);
    app.createAccountStoreMapping(mapping);
  }
  for (  Roles role : Roles.values()) {
    Group group=getGroup(directory,role);
    if (group == null) {
      group=client.instantiate(Group.class);
      group.setName(role.name().toLowerCase());
      directory.createGroup(group);
    }
  }
  return directory.getHref();
}","@Override public String createDirectoryForStudy(Study study){
  checkNotNull(study);
  checkArgument(isNotBlank(study.getIdentifier()),Validate.CANNOT_BE_BLANK,""String_Node_Str"");
  Application app=getApplication();
  checkNotNull(app);
  String dirName=createDirectoryName(study.getIdentifier());
  Directory directory=getDirectoryForStudy(study);
  if (directory == null) {
    directory=client.instantiate(Directory.class);
    directory.setName(dirName);
    directory=client.createDirectory(directory);
  }
  adjustPasswordPolicies(study,directory);
  adjustVerifyEmailPolicies(study,directory);
  ApplicationAccountStoreMapping mapping=getApplicationMapping(directory.getHref(),app);
  if (mapping == null) {
    mapping=client.instantiate(ApplicationAccountStoreMapping.class);
    mapping.setAccountStore(directory);
    mapping.setApplication(app);
    mapping.setDefaultAccountStore(Boolean.FALSE);
    mapping.setDefaultGroupStore(Boolean.FALSE);
    mapping.setListIndex(10);
    app.createAccountStoreMapping(mapping);
  }
  for (  Roles role : Roles.values()) {
    Group group=getGroup(directory,role);
    if (group == null) {
      group=client.instantiate(Group.class);
      group.setName(role.name().toLowerCase());
      directory.createGroup(group);
    }
  }
  return directory.getHref();
}",0.9915514592933948
25740,"private void adjustPasswordPolicies(Study study,Directory directory){
  PasswordPolicy passwordPolicy=directory.getPasswordPolicy();
  ModeledEmailTemplate template=passwordPolicy.getResetEmailTemplates().iterator().next();
  updateTemplate(study,template,study.getResetPasswordTemplate(),""String_Node_Str"");
  PasswordStrength strength=passwordPolicy.getStrength();
  strength.setMaxLength(org.sagebionetworks.bridge.models.studies.PasswordPolicy.FIXED_MAX_LENGTH);
  strength.setMinDiacritic(0);
  strength.setMinLength(study.getPasswordPolicy().getMinLength());
  strength.setMinNumeric(study.getPasswordPolicy().isNumericRequired() ? 1 : 0);
  strength.setMinSymbol(study.getPasswordPolicy().isSymbolRequired() ? 1 : 0);
  strength.setMinLowerCase(study.getPasswordPolicy().isLowerCaseRequired() ? 1 : 0);
  strength.setMinUpperCase(study.getPasswordPolicy().isUpperCaseRequired() ? 1 : 0);
  strength.save();
  passwordPolicy.setResetEmailStatus(EmailStatus.ENABLED);
  passwordPolicy.setResetSuccessEmailStatus(EmailStatus.DISABLED);
  passwordPolicy.save();
}","private void adjustPasswordPolicies(Study study,Directory directory){
  PasswordPolicy passwordPolicy=directory.getPasswordPolicy();
  for (  ModeledEmailTemplate template : passwordPolicy.getResetEmailTemplates()) {
    updateTemplate(study,template,study.getResetPasswordTemplate(),""String_Node_Str"");
  }
  PasswordStrength strength=passwordPolicy.getStrength();
  strength.setMaxLength(org.sagebionetworks.bridge.models.studies.PasswordPolicy.FIXED_MAX_LENGTH);
  strength.setMinDiacritic(0);
  strength.setMinLength(study.getPasswordPolicy().getMinLength());
  strength.setMinNumeric(study.getPasswordPolicy().isNumericRequired() ? 1 : 0);
  strength.setMinSymbol(study.getPasswordPolicy().isSymbolRequired() ? 1 : 0);
  strength.setMinLowerCase(study.getPasswordPolicy().isLowerCaseRequired() ? 1 : 0);
  strength.setMinUpperCase(study.getPasswordPolicy().isUpperCaseRequired() ? 1 : 0);
  strength.save();
  passwordPolicy.setResetEmailStatus(EmailStatus.ENABLED);
  passwordPolicy.setResetSuccessEmailStatus(EmailStatus.DISABLED);
  passwordPolicy.save();
}",0.980760206475833
25741,"private void validateRules(Errors errors,List<SurveyQuestion> questions){
  Set<String> alreadySeenIdentifiers=Sets.newHashSet();
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
    alreadySeenIdentifiers.add(question.getIdentifier());
  }
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (!alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
  }
}","private void validateRules(Errors errors,List<SurveyElement> elements){
  Set<String> alreadySeenIdentifiers=Sets.newHashSet();
  for (int i=0; i < elements.size(); i++) {
    SurveyElement element=elements.get(i);
    if (element instanceof SurveyQuestion) {
      for (      SurveyRule rule : ((SurveyQuestion)element).getConstraints().getRules()) {
        if (alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
          errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
          rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
          errors.popNestedPath();
        }
      }
    }
    alreadySeenIdentifiers.add(element.getIdentifier());
  }
  for (int i=0; i < elements.size(); i++) {
    SurveyElement element=elements.get(i);
    if (element instanceof SurveyQuestion) {
      for (      SurveyRule rule : ((SurveyQuestion)element).getConstraints().getRules()) {
        if (!alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
          errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
          rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
          errors.popNestedPath();
        }
      }
    }
  }
}",0.819402338674751
25742,"@Override public void validate(Object object,Errors errors){
  Survey survey=(Survey)object;
  if (StringUtils.isBlank(survey.getName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getStudyIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getGuid())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  Set<String> foundIdentifiers=Sets.newHashSet();
  for (int i=0; i < survey.getElements().size(); i++) {
    SurveyElement element=survey.getElements().get(i);
    errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
    if (SURVEY_QUESTION_TYPE.equals(element.getType())) {
      doValidateQuestion((SurveyQuestion)element,errors);
    }
 else     if (SURVEY_INFO_SCREEN_TYPE.equals(element.getType())) {
      doValidateInfoScreen((SurveyInfoScreen)element,errors);
    }
    if (foundIdentifiers.contains(element.getIdentifier())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    foundIdentifiers.add(element.getIdentifier());
    errors.popNestedPath();
  }
  if (!errors.hasErrors()) {
    List<SurveyQuestion> questions=survey.getUnmodifiableQuestionList();
    validateRules(errors,questions);
  }
}","@Override public void validate(Object object,Errors errors){
  Survey survey=(Survey)object;
  if (StringUtils.isBlank(survey.getName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getStudyIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getGuid())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  Set<String> foundIdentifiers=Sets.newHashSet();
  for (int i=0; i < survey.getElements().size(); i++) {
    SurveyElement element=survey.getElements().get(i);
    errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
    if (SURVEY_QUESTION_TYPE.equals(element.getType())) {
      doValidateQuestion((SurveyQuestion)element,errors);
    }
 else     if (SURVEY_INFO_SCREEN_TYPE.equals(element.getType())) {
      doValidateInfoScreen((SurveyInfoScreen)element,errors);
    }
    if (foundIdentifiers.contains(element.getIdentifier())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    foundIdentifiers.add(element.getIdentifier());
    errors.popNestedPath();
  }
  if (!errors.hasErrors()) {
    validateRules(errors,survey.getElements());
  }
}",0.9482884195193008
25743,"/** 
 * Copies all fields from the specified record into the builder. This is useful for updating records. 
 */
public HealthDataRecordBuilder copyOf(HealthDataRecord record){
  createdOn=record.getCreatedOn();
  data=record.getData();
  healthCode=record.getHealthCode();
  id=record.getId();
  metadata=record.getMetadata();
  schemaId=record.getSchemaId();
  schemaRevision=record.getSchemaRevision();
  studyId=record.getStudyId();
  uploadDate=record.getUploadDate();
  uploadId=record.getUploadId();
  userSharingScope=record.getUserSharingScope();
  version=record.getVersion();
  return this;
}","/** 
 * Copies all fields from the specified record into the builder. This is useful for updating records. 
 */
public HealthDataRecordBuilder copyOf(HealthDataRecord record){
  createdOn=record.getCreatedOn();
  data=record.getData();
  healthCode=record.getHealthCode();
  id=record.getId();
  metadata=record.getMetadata();
  schemaId=record.getSchemaId();
  schemaRevision=record.getSchemaRevision();
  studyId=record.getStudyId();
  uploadDate=record.getUploadDate();
  uploadId=record.getUploadId();
  userExternalId=record.getUserExternalId();
  userSharingScope=record.getUserSharingScope();
  version=record.getVersion();
  return this;
}",0.9639711769415532
25744,"@Test public void optionalValues() throws Exception {
  JsonNode data=BridgeObjectMapper.get().readTree(""String_Node_Str"");
  JsonNode metadata=BridgeObjectMapper.get().readTree(""String_Node_Str"");
  long arbitraryTimestamp=1424136378727L;
  LocalDate uploadDate=new LocalDate(2014,2,12);
  HealthDataRecord record=DAO.getRecordBuilder().withData(data).withHealthCode(""String_Node_Str"").withId(""String_Node_Str"").withCreatedOn(arbitraryTimestamp).withMetadata(metadata).withSchemaId(""String_Node_Str"").withSchemaRevision(3).withStudyId(""String_Node_Str"").withUploadDate(uploadDate).build();
  assertEquals(""String_Node_Str"",record.getHealthCode());
  assertEquals(""String_Node_Str"",record.getId());
  assertEquals(arbitraryTimestamp,record.getCreatedOn().longValue());
  assertEquals(""String_Node_Str"",record.getSchemaId());
  assertEquals(3,record.getSchemaRevision());
  assertEquals(""String_Node_Str"",record.getStudyId());
  assertEquals(""String_Node_Str"",record.getUploadDate().toString(ISODateTimeFormat.date()));
  assertEquals(1,record.getData().size());
  assertEquals(""String_Node_Str"",record.getData().get(""String_Node_Str"").asText());
  assertEquals(1,record.getMetadata().size());
  assertEquals(""String_Node_Str"",record.getMetadata().get(""String_Node_Str"").asText());
}","@Test public void optionalValues() throws Exception {
  JsonNode data=BridgeObjectMapper.get().readTree(""String_Node_Str"");
  JsonNode metadata=BridgeObjectMapper.get().readTree(""String_Node_Str"");
  long arbitraryTimestamp=1424136378727L;
  LocalDate uploadDate=new LocalDate(2014,2,12);
  HealthDataRecord record=DAO.getRecordBuilder().withData(data).withHealthCode(""String_Node_Str"").withId(""String_Node_Str"").withCreatedOn(arbitraryTimestamp).withMetadata(metadata).withSchemaId(""String_Node_Str"").withSchemaRevision(3).withStudyId(""String_Node_Str"").withUploadDate(uploadDate).withUploadId(""String_Node_Str"").withUserExternalId(""String_Node_Str"").withUserSharingScope(ParticipantOption.SharingScope.SPONSORS_AND_PARTNERS).withVersion(42L).build();
  assertEquals(""String_Node_Str"",record.getHealthCode());
  assertEquals(""String_Node_Str"",record.getId());
  assertEquals(arbitraryTimestamp,record.getCreatedOn().longValue());
  assertEquals(""String_Node_Str"",record.getSchemaId());
  assertEquals(3,record.getSchemaRevision());
  assertEquals(""String_Node_Str"",record.getStudyId());
  assertEquals(""String_Node_Str"",record.getUploadDate().toString(ISODateTimeFormat.date()));
  assertEquals(""String_Node_Str"",record.getUploadId());
  assertEquals(""String_Node_Str"",record.getUserExternalId());
  assertEquals(ParticipantOption.SharingScope.SPONSORS_AND_PARTNERS,record.getUserSharingScope());
  assertEquals(42,record.getVersion().longValue());
  assertEquals(1,record.getData().size());
  assertEquals(""String_Node_Str"",record.getData().get(""String_Node_Str"").asText());
  assertEquals(1,record.getMetadata().size());
  assertEquals(""String_Node_Str"",record.getMetadata().get(""String_Node_Str"").asText());
  HealthDataRecord copyRecord=DAO.getRecordBuilder().copyOf(record).build();
  assertEquals(""String_Node_Str"",copyRecord.getHealthCode());
  assertEquals(""String_Node_Str"",copyRecord.getId());
  assertEquals(arbitraryTimestamp,copyRecord.getCreatedOn().longValue());
  assertEquals(""String_Node_Str"",copyRecord.getSchemaId());
  assertEquals(3,copyRecord.getSchemaRevision());
  assertEquals(""String_Node_Str"",copyRecord.getStudyId());
  assertEquals(""String_Node_Str"",copyRecord.getUploadDate().toString(ISODateTimeFormat.date()));
  assertEquals(""String_Node_Str"",copyRecord.getUploadId());
  assertEquals(""String_Node_Str"",copyRecord.getUserExternalId());
  assertEquals(ParticipantOption.SharingScope.SPONSORS_AND_PARTNERS,copyRecord.getUserSharingScope());
  assertEquals(42,copyRecord.getVersion().longValue());
  assertEquals(1,copyRecord.getData().size());
  assertEquals(""String_Node_Str"",copyRecord.getData().get(""String_Node_Str"").asText());
  assertEquals(1,copyRecord.getMetadata().size());
  assertEquals(""String_Node_Str"",copyRecord.getMetadata().get(""String_Node_Str"").asText());
}",0.626741627963823
25745,"@Test public void test() throws Exception {
  String dataJsonText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  JsonNode dataJson=BridgeObjectMapper.get().readTree(dataJsonText);
  HealthDataRecord intermediateRecord=createValidRecordBuilder(dataJson).withId(TEST_RECORD_ID).build();
  HealthDataService mockHealthDataService=mock(HealthDataService.class);
  ArgumentCaptor<HealthDataRecord> createRecordArgCaptor=ArgumentCaptor.forClass(HealthDataRecord.class);
  when(mockHealthDataService.createOrUpdateRecord(createRecordArgCaptor.capture())).thenReturn(TEST_RECORD_ID);
  ArgumentCaptor<HealthDataAttachment> createAttachmentArgCaptor=ArgumentCaptor.forClass(HealthDataAttachment.class);
  when(mockHealthDataService.createOrUpdateAttachment(createAttachmentArgCaptor.capture())).thenReturn(ATTACHMENT_ID_BAR,ATTACHMENT_ID_FOO);
  when(mockHealthDataService.getRecordById(TEST_RECORD_ID)).thenReturn(intermediateRecord);
  when(mockHealthDataService.getAttachmentBuilder()).thenAnswer(new Answer<HealthDataAttachmentBuilder>(){
    @Override public HealthDataAttachmentBuilder answer(    InvocationOnMock invocation){
      return new DynamoHealthDataAttachment.Builder();
    }
  }
);
  when(mockHealthDataService.getRecordBuilder()).thenAnswer(new Answer<HealthDataRecordBuilder>(){
    @Override public HealthDataRecordBuilder answer(    InvocationOnMock invocation){
      return new DynamoHealthDataRecord.Builder();
    }
  }
);
  S3Helper mockS3Helper=mock(S3Helper.class);
  UploadArtifactsHandler handler=new UploadArtifactsHandler();
  handler.setHealthDataService(mockHealthDataService);
  handler.setS3Helper(mockS3Helper);
  Map<String,byte[]> attachmentMap=new TreeMap<>();
  attachmentMap.put(""String_Node_Str"",""String_Node_Str"".getBytes(Charsets.UTF_8));
  attachmentMap.put(""String_Node_Str"",""String_Node_Str"".getBytes(Charsets.UTF_8));
  HealthDataRecordBuilder recordBuilder=createValidRecordBuilder(dataJson);
  DynamoUpload2 upload=new DynamoUpload2();
  upload.setUploadId(TEST_UPLOAD_ID);
  UploadValidationContext context=new UploadValidationContext();
  context.setAttachmentsByFieldName(attachmentMap);
  context.setHealthDataRecordBuilder(recordBuilder);
  context.setUpload(upload);
  handler.handle(context);
  List<HealthDataRecord> createRecordArgList=createRecordArgCaptor.getAllValues();
  assertEquals(2,createRecordArgList.size());
  HealthDataRecord createIntermediateRecordArg=createRecordArgList.get(0);
  JsonNode createIntermediateRecordDataJson=createIntermediateRecordArg.getData();
  assertEquals(2,createIntermediateRecordDataJson.size());
  assertEquals(""String_Node_Str"",createIntermediateRecordDataJson.get(""String_Node_Str"").textValue());
  assertEquals(42,createIntermediateRecordDataJson.get(""String_Node_Str"").intValue());
  HealthDataRecord createFinalRecordArg=createRecordArgList.get(1);
  assertEquals(TEST_RECORD_ID,createFinalRecordArg.getId());
  JsonNode createFinalRecordDataJson=createFinalRecordArg.getData();
  assertEquals(4,createFinalRecordDataJson.size());
  assertEquals(""String_Node_Str"",createFinalRecordDataJson.get(""String_Node_Str"").textValue());
  assertEquals(42,createFinalRecordDataJson.get(""String_Node_Str"").intValue());
  assertEquals(ATTACHMENT_ID_BAR,createFinalRecordDataJson.get(""String_Node_Str"").textValue());
  assertEquals(ATTACHMENT_ID_FOO,createFinalRecordDataJson.get(""String_Node_Str"").textValue());
  List<HealthDataAttachment> createAttachmentArgList=createAttachmentArgCaptor.getAllValues();
  assertEquals(2,createAttachmentArgList.size());
  for (  HealthDataAttachment oneAttachment : createAttachmentArgList) {
    assertEquals(TEST_RECORD_ID,oneAttachment.getRecordId());
  }
  verify(mockS3Helper).writeBytesToS3(TestConstants.ATTACHMENT_BUCKET,ATTACHMENT_ID_BAR,BYTES_BAR);
  verify(mockS3Helper).writeBytesToS3(TestConstants.ATTACHMENT_BUCKET,ATTACHMENT_ID_FOO,BYTES_FOO);
  assertEquals(TEST_RECORD_ID,context.getRecordId());
  assertTrue(context.getMessageList().isEmpty());
}","@Test public void test() throws Exception {
  String dataJsonText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  JsonNode dataJson=BridgeObjectMapper.get().readTree(dataJsonText);
  HealthDataRecord intermediateRecord=createValidRecordBuilder(dataJson).withId(TEST_RECORD_ID).build();
  HealthDataService mockHealthDataService=mock(HealthDataService.class);
  ArgumentCaptor<HealthDataRecord> createRecordArgCaptor=ArgumentCaptor.forClass(HealthDataRecord.class);
  when(mockHealthDataService.createOrUpdateRecord(createRecordArgCaptor.capture())).thenReturn(TEST_RECORD_ID);
  ArgumentCaptor<HealthDataAttachment> createAttachmentArgCaptor=ArgumentCaptor.forClass(HealthDataAttachment.class);
  when(mockHealthDataService.createOrUpdateAttachment(createAttachmentArgCaptor.capture())).thenReturn(ATTACHMENT_ID_BAR,ATTACHMENT_ID_FOO);
  when(mockHealthDataService.getRecordById(TEST_RECORD_ID)).thenReturn(intermediateRecord);
  when(mockHealthDataService.getAttachmentBuilder()).thenAnswer(invocation -> new DynamoHealthDataAttachment.Builder());
  when(mockHealthDataService.getRecordBuilder()).thenAnswer(invocation -> new DynamoHealthDataRecord.Builder());
  S3Helper mockS3Helper=mock(S3Helper.class);
  UploadArtifactsHandler handler=new UploadArtifactsHandler();
  handler.setHealthDataService(mockHealthDataService);
  handler.setS3Helper(mockS3Helper);
  Map<String,byte[]> attachmentMap=new TreeMap<>();
  attachmentMap.put(""String_Node_Str"",""String_Node_Str"".getBytes(Charsets.UTF_8));
  attachmentMap.put(""String_Node_Str"",""String_Node_Str"".getBytes(Charsets.UTF_8));
  HealthDataRecordBuilder recordBuilder=createValidRecordBuilder(dataJson);
  DynamoUpload2 upload=new DynamoUpload2();
  upload.setUploadId(TEST_UPLOAD_ID);
  UploadValidationContext context=new UploadValidationContext();
  context.setAttachmentsByFieldName(attachmentMap);
  context.setHealthDataRecordBuilder(recordBuilder);
  context.setUpload(upload);
  handler.handle(context);
  List<HealthDataRecord> createRecordArgList=createRecordArgCaptor.getAllValues();
  assertEquals(2,createRecordArgList.size());
  HealthDataRecord createIntermediateRecordArg=createRecordArgList.get(0);
  assertEquals(""String_Node_Str"",createIntermediateRecordArg.getHealthCode());
  assertNull(createIntermediateRecordArg.getId());
  assertEquals(ARBITRARY_TIMESTAMP,createIntermediateRecordArg.getCreatedOn().longValue());
  assertEquals(""String_Node_Str"",createIntermediateRecordArg.getSchemaId());
  assertEquals(1,createIntermediateRecordArg.getSchemaRevision());
  assertEquals(""String_Node_Str"",createIntermediateRecordArg.getStudyId());
  assertEquals(""String_Node_Str"",createIntermediateRecordArg.getUploadDate().toString(ISODateTimeFormat.date()));
  assertEquals(TEST_UPLOAD_ID,createIntermediateRecordArg.getUploadId());
  assertEquals(""String_Node_Str"",createIntermediateRecordArg.getUserExternalId());
  assertEquals(ParticipantOption.SharingScope.SPONSORS_AND_PARTNERS,createIntermediateRecordArg.getUserSharingScope());
  assertEquals(42,createIntermediateRecordArg.getVersion().longValue());
  assertTrue(createIntermediateRecordArg.getMetadata().isObject());
  assertEquals(0,createIntermediateRecordArg.getMetadata().size());
  JsonNode createIntermediateRecordDataJson=createIntermediateRecordArg.getData();
  assertEquals(2,createIntermediateRecordDataJson.size());
  assertEquals(""String_Node_Str"",createIntermediateRecordDataJson.get(""String_Node_Str"").textValue());
  assertEquals(42,createIntermediateRecordDataJson.get(""String_Node_Str"").intValue());
  HealthDataRecord createFinalRecordArg=createRecordArgList.get(1);
  assertEquals(""String_Node_Str"",createFinalRecordArg.getHealthCode());
  assertEquals(TEST_RECORD_ID,createFinalRecordArg.getId());
  assertEquals(ARBITRARY_TIMESTAMP,createFinalRecordArg.getCreatedOn().longValue());
  assertEquals(""String_Node_Str"",createFinalRecordArg.getSchemaId());
  assertEquals(1,createFinalRecordArg.getSchemaRevision());
  assertEquals(""String_Node_Str"",createFinalRecordArg.getStudyId());
  assertEquals(""String_Node_Str"",createFinalRecordArg.getUploadDate().toString(ISODateTimeFormat.date()));
  assertEquals(TEST_UPLOAD_ID,createFinalRecordArg.getUploadId());
  assertEquals(""String_Node_Str"",createFinalRecordArg.getUserExternalId());
  assertEquals(ParticipantOption.SharingScope.SPONSORS_AND_PARTNERS,createFinalRecordArg.getUserSharingScope());
  assertEquals(42,createFinalRecordArg.getVersion().longValue());
  assertTrue(createFinalRecordArg.getMetadata().isObject());
  assertEquals(0,createFinalRecordArg.getMetadata().size());
  JsonNode createFinalRecordDataJson=createFinalRecordArg.getData();
  assertEquals(4,createFinalRecordDataJson.size());
  assertEquals(""String_Node_Str"",createFinalRecordDataJson.get(""String_Node_Str"").textValue());
  assertEquals(42,createFinalRecordDataJson.get(""String_Node_Str"").intValue());
  assertEquals(ATTACHMENT_ID_BAR,createFinalRecordDataJson.get(""String_Node_Str"").textValue());
  assertEquals(ATTACHMENT_ID_FOO,createFinalRecordDataJson.get(""String_Node_Str"").textValue());
  List<HealthDataAttachment> createAttachmentArgList=createAttachmentArgCaptor.getAllValues();
  assertEquals(2,createAttachmentArgList.size());
  for (  HealthDataAttachment oneAttachment : createAttachmentArgList) {
    assertEquals(TEST_RECORD_ID,oneAttachment.getRecordId());
  }
  verify(mockS3Helper).writeBytesToS3(TestConstants.ATTACHMENT_BUCKET,ATTACHMENT_ID_BAR,BYTES_BAR);
  verify(mockS3Helper).writeBytesToS3(TestConstants.ATTACHMENT_BUCKET,ATTACHMENT_ID_FOO,BYTES_FOO);
  assertEquals(TEST_RECORD_ID,context.getRecordId());
  assertTrue(context.getMessageList().isEmpty());
}",0.7251004222885982
25746,"private static HealthDataRecordBuilder createValidRecordBuilder(JsonNode dataNode){
  return new DynamoHealthDataRecord.Builder().withCreatedOn(DateTime.now().getMillis()).withData(dataNode).withHealthCode(""String_Node_Str"").withMetadata(BridgeObjectMapper.get().createObjectNode()).withSchemaId(""String_Node_Str"").withSchemaRevision(1).withStudyId(""String_Node_Str"").withUploadDate(LocalDate.now()).withUserSharingScope(ParticipantOption.SharingScope.SPONSORS_AND_PARTNERS);
}","private static HealthDataRecordBuilder createValidRecordBuilder(JsonNode dataNode){
  return new DynamoHealthDataRecord.Builder().withCreatedOn(ARBITRARY_TIMESTAMP).withData(dataNode).withHealthCode(""String_Node_Str"").withMetadata(BridgeObjectMapper.get().createObjectNode()).withSchemaId(""String_Node_Str"").withSchemaRevision(1).withStudyId(""String_Node_Str"").withUploadDate(LocalDate.parse(""String_Node_Str"")).withUploadId(TEST_UPLOAD_ID).withUserExternalId(""String_Node_Str"").withUserSharingScope(ParticipantOption.SharingScope.SPONSORS_AND_PARTNERS).withVersion(42L);
}",0.8533333333333334
25747,"public Result verifyEmail(String study){
  Study studyObj=studyService.getStudy(study);
  return ok(views.html.verifyEmail.render(ASSETS_HOST,ASSETS_BUILD,studyObj.getName(),studyObj.getSupportEmail()));
}","public Result verifyEmail(String study){
  Study studyObj=studyService.getStudy(study);
  return ok(views.html.verifyEmail.render(ASSETS_HOST,ASSETS_BUILD,StringEscapeUtils.escapeHtml4(""String_Node_Str""),studyObj.getSupportEmail()));
}",0.8454545454545455
25748,"private void validateRules(Errors errors,List<SurveyQuestion> questions){
  Set<String> alreadySeenIdentifiers=Sets.newHashSet();
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i);
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
    alreadySeenIdentifiers.add(question.getIdentifier());
  }
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (!alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i);
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
  }
}","private void validateRules(Errors errors,List<SurveyQuestion> questions){
  Set<String> alreadySeenIdentifiers=Sets.newHashSet();
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
    alreadySeenIdentifiers.add(question.getIdentifier());
  }
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (!alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
  }
}",0.981060606060606
25749,"@Override public void validate(Object object,Errors errors){
  Survey survey=(Survey)object;
  if (StringUtils.isBlank(survey.getName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getStudyIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getGuid())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  Set<String> foundIdentifiers=Sets.newHashSet();
  for (int i=0; i < survey.getElements().size(); i++) {
    SurveyElement element=survey.getElements().get(i);
    errors.pushNestedPath(""String_Node_Str"" + i);
    if (SURVEY_QUESTION_TYPE.equals(element.getType())) {
      doValidateQuestion((SurveyQuestion)element,errors);
    }
 else     if (SURVEY_INFO_SCREEN_TYPE.equals(element.getType())) {
      doValidateInfoScreen((SurveyInfoScreen)element,errors);
    }
    if (foundIdentifiers.contains(element.getIdentifier())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    foundIdentifiers.add(element.getIdentifier());
    errors.popNestedPath();
  }
  if (!errors.hasErrors()) {
    List<SurveyQuestion> questions=survey.getUnmodifiableQuestionList();
    validateRules(errors,questions);
  }
}","@Override public void validate(Object object,Errors errors){
  Survey survey=(Survey)object;
  if (StringUtils.isBlank(survey.getName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getStudyIdentifier())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getGuid())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  Set<String> foundIdentifiers=Sets.newHashSet();
  for (int i=0; i < survey.getElements().size(); i++) {
    SurveyElement element=survey.getElements().get(i);
    errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
    if (SURVEY_QUESTION_TYPE.equals(element.getType())) {
      doValidateQuestion((SurveyQuestion)element,errors);
    }
 else     if (SURVEY_INFO_SCREEN_TYPE.equals(element.getType())) {
      doValidateInfoScreen((SurveyInfoScreen)element,errors);
    }
    if (foundIdentifiers.contains(element.getIdentifier())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    foundIdentifiers.add(element.getIdentifier());
    errors.popNestedPath();
  }
  if (!errors.hasErrors()) {
    List<SurveyQuestion> questions=survey.getUnmodifiableQuestionList();
    validateRules(errors,questions);
  }
}",0.9928263988522238
25750,"/** 
 * <p> Validates the given object as a valid UploadSchema instance. This will flag errors in the following conditions: <ul> <li>value is null or not an UploadSchema</li> <li>fieldDefinitions is null or empty</li> <li>fieldDefinitions contains null or invalid entries</li> <li>name is null or empty</li> <li>revision is negative</li> <li>schemaId is null or empty</li> <li>schemaType is null</li> </ul> </p>
 * @see org.springframework.validation.Validator#validate
 */
@Override public void validate(Object target,Errors errors){
  if (target == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (!(target instanceof UploadSchema)) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    UploadSchema uploadSchema=(UploadSchema)target;
    if (Strings.isNullOrEmpty(uploadSchema.getName())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    if (uploadSchema.getRevision() < 0) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    if (Strings.isNullOrEmpty(uploadSchema.getSchemaId())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    if (uploadSchema.getSchemaType() == null) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    List<UploadFieldDefinition> fieldDefList=uploadSchema.getFieldDefinitions();
    if (fieldDefList == null || fieldDefList.isEmpty()) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      Set<String> fieldNameSet=new HashSet<>();
      for (int i=0; i < fieldDefList.size(); i++) {
        UploadFieldDefinition fieldDef=fieldDefList.get(i);
        if (fieldDef == null) {
          errors.rejectValue(""String_Node_Str"" + i,""String_Node_Str"");
        }
 else {
          errors.pushNestedPath(""String_Node_Str"" + i);
          String fieldName=fieldDef.getName();
          if (Strings.isNullOrEmpty(fieldName)) {
            errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
          }
 else {
            if (fieldNameSet.contains(fieldName)) {
              errors.rejectValue(""String_Node_Str"",""String_Node_Str"" + fieldName + ""String_Node_Str"");
            }
            fieldNameSet.add(fieldName);
          }
          if (fieldDef.getType() == null) {
            errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
          }
          errors.popNestedPath();
        }
      }
    }
  }
}","/** 
 * <p> Validates the given object as a valid UploadSchema instance. This will flag errors in the following conditions: <ul> <li>value is null or not an UploadSchema</li> <li>fieldDefinitions is null or empty</li> <li>fieldDefinitions contains null or invalid entries</li> <li>name is null or empty</li> <li>revision is negative</li> <li>schemaId is null or empty</li> <li>schemaType is null</li> </ul> </p>
 * @see org.springframework.validation.Validator#validate
 */
@Override public void validate(Object target,Errors errors){
  if (target == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (!(target instanceof UploadSchema)) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    UploadSchema uploadSchema=(UploadSchema)target;
    if (Strings.isNullOrEmpty(uploadSchema.getName())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    if (uploadSchema.getRevision() < 0) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    if (Strings.isNullOrEmpty(uploadSchema.getSchemaId())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    if (uploadSchema.getSchemaType() == null) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
    List<UploadFieldDefinition> fieldDefList=uploadSchema.getFieldDefinitions();
    if (fieldDefList == null || fieldDefList.isEmpty()) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      Set<String> fieldNameSet=new HashSet<>();
      for (int i=0; i < fieldDefList.size(); i++) {
        UploadFieldDefinition fieldDef=fieldDefList.get(i);
        String fieldDefinitionKey=""String_Node_Str"" + i + ""String_Node_Str"";
        if (fieldDef == null) {
          errors.rejectValue(fieldDefinitionKey,""String_Node_Str"");
        }
 else {
          errors.pushNestedPath(fieldDefinitionKey);
          String fieldName=fieldDef.getName();
          if (Strings.isNullOrEmpty(fieldName)) {
            errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
          }
 else {
            if (fieldNameSet.contains(fieldName)) {
              errors.rejectValue(""String_Node_Str"",""String_Node_Str"" + fieldName + ""String_Node_Str"");
            }
            fieldNameSet.add(fieldName);
          }
          if (fieldDef.getType() == null) {
            errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
          }
          errors.popNestedPath();
        }
      }
    }
  }
}",0.9685789580377052
25751,"private String getRedisURL(final BridgeConfig config){
  String url=System.getenv(""String_Node_Str"");
  if (url != null) {
    url=System.getenv(""String_Node_Str"");
  }
  if (url != null) {
    url=config.getProperty(""String_Node_Str"");
  }
  return url;
}","private String getRedisURL(final BridgeConfig config){
  String url=System.getenv(""String_Node_Str"");
  if (url == null) {
    url=System.getenv(""String_Node_Str"");
  }
  if (url == null) {
    url=config.getProperty(""String_Node_Str"");
  }
  return url;
}",0.9921875
25752,"@Resource(name=""String_Node_Str"") public void setDdbMapper(DynamoDBMapper mapper){
  this.mapper=mapper;
}","@Resource(name=""String_Node_Str"") public final void setDdbMapper(DynamoDBMapper mapper){
  this.mapper=mapper;
}",0.9724770642201837
25753,"@Override public void publishEvent(ActivityEvent event){
  checkNotNull(event);
  DynamoActivityEvent hashKey=new DynamoActivityEvent();
  hashKey.setHealthCode(event.getHealthCode());
  hashKey.setEventId(event.getEventId());
  ActivityEvent savedEvent=mapper.load(hashKey);
  if (savedEvent == null || event.getTimestamp() > savedEvent.getTimestamp()) {
    mapper.save(event);
  }
}","@Override public void publishEvent(ActivityEvent event){
  checkNotNull(event);
  DynamoActivityEvent hashKey=new DynamoActivityEvent();
  hashKey.setHealthCode(event.getHealthCode());
  hashKey.setEventId(event.getEventId());
  ActivityEvent savedEvent=mapper.load(hashKey);
  if (isLaterNonEnrollmentEvent(savedEvent,event)) {
    mapper.save(event);
  }
}",0.8506056527590848
25754,"@Test public void canWithdrawConsent() throws Exception {
  String json=""String_Node_Str"";
  Context context=TestUtils.mockPlayContextWithJson(json);
  Http.Context.current.set(context);
  ArgumentCaptor<Withdrawal> captor=ArgumentCaptor.forClass(Withdrawal.class);
  Result result=controller.withdrawConsent();
  String response=Helpers.contentAsString(result);
  JsonNode node=BridgeObjectMapper.get().readTree(response);
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  verify(consentService).withdrawConsent(any(Study.class),any(User.class),captor.capture(),any(Long.class));
  assertEquals(""String_Node_Str"",captor.getValue().getReason());
}","@Test public void canWithdrawConsent() throws Exception {
  CacheProvider cacheProvider=mock(CacheProvider.class);
  controller.setCacheProvider(cacheProvider);
  String json=""String_Node_Str"";
  Context context=TestUtils.mockPlayContextWithJson(json);
  Http.Context.current.set(context);
  ArgumentCaptor<Withdrawal> captor=ArgumentCaptor.forClass(Withdrawal.class);
  Result result=controller.withdrawConsent();
  String response=Helpers.contentAsString(result);
  JsonNode node=BridgeObjectMapper.get().readTree(response);
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  verify(consentService).withdrawConsent(any(Study.class),any(User.class),captor.capture(),any(Long.class));
  assertEquals(""String_Node_Str"",captor.getValue().getReason());
  ArgumentCaptor<UserSession> sessionCaptor=ArgumentCaptor.forClass(UserSession.class);
  verify(cacheProvider).setUserSession(sessionCaptor.capture());
  assertFalse(sessionCaptor.getValue().getUser().doesConsent());
}",0.8069753457606735
25755,"@Before public void before(){
  Study study=new DynamoStudy();
  study.setTaskIdentifiers(Sets.newHashSet(""String_Node_Str""));
  Schedule schedule=new Schedule();
  schedule.setLabel(""String_Node_Str"");
  schedule.setScheduleType(ScheduleType.RECURRING);
  schedule.setInterval(""String_Node_Str"");
  schedule.setExpires(""String_Node_Str"");
  schedule.addTimes(""String_Node_Str"",""String_Node_Str"");
  schedule.addActivity(TestConstants.TEST_3_ACTIVITY);
  SimpleScheduleStrategy strategy=new SimpleScheduleStrategy();
  strategy.setSchedule(schedule);
  plan=new DynamoSchedulePlan();
  plan.setLabel(""String_Node_Str"");
  plan.setStudyKey(TEST_STUDY_IDENTIFIER);
  plan.setStrategy(strategy);
  plan=schedulePlanService.createSchedulePlan(study,plan);
  String healthCode=BridgeUtils.generateGuid();
  UserConsent consent=mock(DynamoUserConsent3.class);
  when(consent.getSignedOn()).thenReturn(new DateTime().minusDays(2).getMillis());
  user=new User();
  user.setHealthCode(healthCode);
  user.setStudyKey(TEST_STUDY_IDENTIFIER);
}","@Before public void before(){
  Study study=new DynamoStudy();
  study.setIdentifier(TEST_STUDY_IDENTIFIER);
  study.setTaskIdentifiers(Sets.newHashSet(""String_Node_Str""));
  Schedule schedule=new Schedule();
  schedule.setLabel(""String_Node_Str"");
  schedule.setScheduleType(ScheduleType.RECURRING);
  schedule.setInterval(""String_Node_Str"");
  schedule.setExpires(""String_Node_Str"");
  schedule.addTimes(""String_Node_Str"",""String_Node_Str"");
  schedule.addActivity(TestConstants.TEST_3_ACTIVITY);
  SimpleScheduleStrategy strategy=new SimpleScheduleStrategy();
  strategy.setSchedule(schedule);
  plan=new DynamoSchedulePlan();
  plan.setLabel(""String_Node_Str"");
  plan.setStudyKey(TEST_STUDY_IDENTIFIER);
  plan.setStrategy(strategy);
  plan=schedulePlanService.createSchedulePlan(study,plan);
  String healthCode=BridgeUtils.generateGuid();
  UserConsent consent=mock(DynamoUserConsent3.class);
  when(consent.getSignedOn()).thenReturn(new DateTime().minusDays(2).getMillis());
  user=new User();
  user.setHealthCode(healthCode);
  user.setStudyKey(TEST_STUDY_IDENTIFIER);
}",0.978240302743614
25756,"@Before public void before(){
  study=new DynamoStudy();
  study.setTaskIdentifiers(Sets.newHashSet(""String_Node_Str""));
  service=new SchedulePlanServiceImpl();
  schedulePlanDao=mock(SchedulePlanDao.class);
  surveyService=mock(SurveyService.class);
  activityService=mock(ScheduledActivityService.class);
  service.setSchedulePlanDao(schedulePlanDao);
  service.setSurveyService(surveyService);
  service.setScheduledActivityService(activityService);
}","@Before public void before(){
  study=new DynamoStudy();
  study.setIdentifier(TEST_STUDY_IDENTIFIER);
  study.setTaskIdentifiers(Sets.newHashSet(""String_Node_Str""));
  service=new SchedulePlanServiceImpl();
  schedulePlanDao=mock(SchedulePlanDao.class);
  surveyService=mock(SurveyService.class);
  activityService=mock(ScheduledActivityService.class);
  service.setSchedulePlanDao(schedulePlanDao);
  service.setSurveyService(surveyService);
  service.setScheduledActivityService(activityService);
}",0.9518828451882844
25757,"@Before public void before(){
  study=new DynamoStudy();
  study.setTaskIdentifiers(Sets.newHashSet(""String_Node_Str"",""String_Node_Str""));
  mockSchedulePlanDao=mock(SchedulePlanDao.class);
  mockSurveyService=mock(SurveyService.class);
  mockActivityService=mock(ScheduledActivityService.class);
  service=new SchedulePlanServiceImpl();
  service.setSchedulePlanDao(mockSchedulePlanDao);
  service.setSurveyService(mockSurveyService);
  service.setScheduledActivityService(mockActivityService);
  Survey survey1=TestUtils.getSurvey(false);
  survey1.setIdentifier(""String_Node_Str"");
  Survey survey2=TestUtils.getSurvey(false);
  survey2.setIdentifier(""String_Node_Str"");
  when(mockSurveyService.getSurveyMostRecentlyPublishedVersion(any(),any())).thenReturn(survey1);
  when(mockSurveyService.getSurvey(any())).thenReturn(survey2);
  surveyGuid1=survey1.getGuid();
  surveyGuid2=survey2.getGuid();
}","@Before public void before(){
  study=new DynamoStudy();
  study.setIdentifier(TEST_STUDY_IDENTIFIER);
  study.setTaskIdentifiers(Sets.newHashSet(""String_Node_Str"",""String_Node_Str""));
  mockSchedulePlanDao=mock(SchedulePlanDao.class);
  mockSurveyService=mock(SurveyService.class);
  mockActivityService=mock(ScheduledActivityService.class);
  service=new SchedulePlanServiceImpl();
  service.setSchedulePlanDao(mockSchedulePlanDao);
  service.setSurveyService(mockSurveyService);
  service.setScheduledActivityService(mockActivityService);
  Survey survey1=TestUtils.getSurvey(false);
  survey1.setIdentifier(""String_Node_Str"");
  Survey survey2=TestUtils.getSurvey(false);
  survey2.setIdentifier(""String_Node_Str"");
  when(mockSurveyService.getSurveyMostRecentlyPublishedVersion(any(),any())).thenReturn(survey1);
  when(mockSurveyService.getSurvey(any())).thenReturn(survey2);
  surveyGuid1=survey1.getGuid();
  surveyGuid2=survey2.getGuid();
}",0.9751619870410368
25758,"<T>Result okResult(List<T> list,String typeName){
  JsonNode node=mapper.valueToTree(new ResourceList<T>(list));
  ArrayNode items=(ArrayNode)node.get(""String_Node_Str"");
  for (int i=0; i < items.size(); i++) {
    ((ObjectNode)items.get(0)).put(""String_Node_Str"",typeName);
  }
  return ok(node);
}","<T>Result okResult(List<T> list,String typeName){
  JsonNode node=mapper.valueToTree(new ResourceList<T>(list));
  ArrayNode items=(ArrayNode)node.get(""String_Node_Str"");
  for (int i=0; i < items.size(); i++) {
    ((ObjectNode)items.get(i)).put(""String_Node_Str"",typeName);
  }
  return ok(node);
}",0.9966666666666668
25759,"@SuppressWarnings(""String_Node_Str"") private void assertTask(String dateString,String ref,Task task){
  if (""String_Node_Str"".equals(dateString)) {
    assertEquals(ref,task.getActivity().getRef());
    return;
  }
  DateTime date=DateTime.parse(dateString);
  assertTrue(date.isEqual(task.getScheduledOn()));
  assertEquals(ref,task.getActivity().getRef());
}","@SuppressWarnings(""String_Node_Str"") private void assertTask(String dateString,String ref,Task task){
  if (""String_Node_Str"".equals(dateString)) {
    assertEquals(ref,task.getActivity().getRef());
    return;
  }
  DateTime date=ISODateTimeFormat.dateOptionalTimeParser().withZone(PACIFIC_TIME_ZONE).parseDateTime(dateString);
  assertTrue(date.isEqual(task.getScheduledOn()));
  assertEquals(ref,task.getActivity().getRef());
}",0.9012658227848102
25760,"private void assertTask(String dateString,String ref,Task task){
  if (""String_Node_Str"".equals(dateString)) {
    assertEquals(ref,task.getActivity().getRef());
    return;
  }
  DateTime date=DateTime.parse(dateString);
  assertEquals((long)date.getMillis(),(long)task.getScheduledOn());
  assertEquals(ref,task.getActivity().getRef());
}","@SuppressWarnings(""String_Node_Str"") private void assertTask(String dateString,String ref,Task task){
  if (""String_Node_Str"".equals(dateString)) {
    assertEquals(ref,task.getActivity().getRef());
    return;
  }
  DateTime date=DateTime.parse(dateString);
  assertEquals((long)date.getMillis(),(long)task.getScheduledOn());
  assertEquals(ref,task.getActivity().getRef());
}",0.7559274755927475
25761,"@Test public void canRountripSerialize() throws Exception {
  Activity activity=new Activity.Builder().withLabel(""String_Node_Str"").withTask(""String_Node_Str"").build();
  Schedule schedule=new Schedule();
  schedule.getActivities().add(activity);
  schedule.setCronTrigger(""String_Node_Str"");
  schedule.setDelay(Period.parse(""String_Node_Str""));
  schedule.setExpires(Period.parse(""String_Node_Str""));
  schedule.setStartsOn(DateTime.parse(""String_Node_Str""));
  schedule.setEndsOn(DateTime.parse(""String_Node_Str""));
  schedule.setEventId(""String_Node_Str"");
  schedule.setInterval(Period.parse(""String_Node_Str""));
  schedule.setLabel(""String_Node_Str"");
  schedule.setScheduleType(ScheduleType.RECURRING);
  schedule.setTimes(Lists.newArrayList(LocalTime.parse(""String_Node_Str""),LocalTime.parse(""String_Node_Str"")));
  BridgeObjectMapper mapper=BridgeObjectMapper.get();
  String string=mapper.writeValueAsString(schedule);
  JsonNode node=mapper.readTree(string);
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  ArrayNode times=(ArrayNode)node.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",times.get(0).asText());
  assertEquals(""String_Node_Str"",times.get(1).asText());
  JsonNode actNode=node.get(""String_Node_Str"").get(0);
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  JsonNode taskNode=actNode.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",taskNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",taskNode.get(""String_Node_Str"").asText());
  schedule=mapper.readValue(string,Schedule.class);
  assertEquals(""String_Node_Str"",schedule.getCronTrigger());
  assertEquals(""String_Node_Str"",schedule.getDelay().toString());
  assertEquals(""String_Node_Str"",schedule.getExpires().toString());
  assertEquals(""String_Node_Str"",schedule.getEventId());
  assertEquals(""String_Node_Str"",schedule.getLabel());
  assertEquals(""String_Node_Str"",schedule.getInterval().toString());
  assertEquals(ScheduleType.RECURRING,schedule.getScheduleType());
  assertEquals(""String_Node_Str"",schedule.getStartsOn().toString());
  assertEquals(""String_Node_Str"",schedule.getEndsOn().toString());
  assertEquals(""String_Node_Str"",schedule.getTimes().get(0).toString());
  assertEquals(""String_Node_Str"",schedule.getTimes().get(1).toString());
  activity=schedule.getActivities().get(0);
  assertEquals(""String_Node_Str"",activity.getLabel());
  assertEquals(""String_Node_Str"",activity.getRef());
  assertEquals(""String_Node_Str"",activity.getTask().getIdentifier());
}","@SuppressWarnings(""String_Node_Str"") @Test public void canRountripSerialize() throws Exception {
  Activity activity=new Activity.Builder().withLabel(""String_Node_Str"").withTask(""String_Node_Str"").build();
  Schedule schedule=new Schedule();
  schedule.getActivities().add(activity);
  schedule.setCronTrigger(""String_Node_Str"");
  schedule.setDelay(Period.parse(""String_Node_Str""));
  schedule.setExpires(Period.parse(""String_Node_Str""));
  schedule.setStartsOn(DateTime.parse(""String_Node_Str""));
  schedule.setEndsOn(DateTime.parse(""String_Node_Str""));
  schedule.setEventId(""String_Node_Str"");
  schedule.setInterval(Period.parse(""String_Node_Str""));
  schedule.setLabel(""String_Node_Str"");
  schedule.setScheduleType(ScheduleType.RECURRING);
  schedule.setTimes(Lists.newArrayList(LocalTime.parse(""String_Node_Str""),LocalTime.parse(""String_Node_Str"")));
  BridgeObjectMapper mapper=BridgeObjectMapper.get();
  String string=mapper.writeValueAsString(schedule);
  JsonNode node=mapper.readTree(string);
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",node.get(""String_Node_Str"").asText());
  ArrayNode times=(ArrayNode)node.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",times.get(0).asText());
  assertEquals(""String_Node_Str"",times.get(1).asText());
  JsonNode actNode=node.get(""String_Node_Str"").get(0);
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",actNode.get(""String_Node_Str"").asText());
  JsonNode taskNode=actNode.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",taskNode.get(""String_Node_Str"").asText());
  assertEquals(""String_Node_Str"",taskNode.get(""String_Node_Str"").asText());
  schedule=mapper.readValue(string,Schedule.class);
  assertEquals(""String_Node_Str"",schedule.getCronTrigger());
  assertEquals(""String_Node_Str"",schedule.getDelay().toString());
  assertEquals(""String_Node_Str"",schedule.getExpires().toString());
  assertEquals(""String_Node_Str"",schedule.getEventId());
  assertEquals(""String_Node_Str"",schedule.getLabel());
  assertEquals(""String_Node_Str"",schedule.getInterval().toString());
  assertEquals(ScheduleType.RECURRING,schedule.getScheduleType());
  assertEquals(""String_Node_Str"",schedule.getStartsOn().toString());
  assertEquals(""String_Node_Str"",schedule.getEndsOn().toString());
  assertEquals(""String_Node_Str"",schedule.getTimes().get(0).toString());
  assertEquals(""String_Node_Str"",schedule.getTimes().get(1).toString());
  activity=schedule.getActivities().get(0);
  assertEquals(""String_Node_Str"",activity.getLabel());
  assertEquals(""String_Node_Str"",activity.getRef());
  assertEquals(""String_Node_Str"",activity.getTask().getIdentifier());
}",0.9946213112370984
25762,"@Test public void taskIsComplete(){
  Schedule schedule=new Schedule();
  schedule.setScheduleType(ScheduleType.ONCE);
  schedule.setLabel(""String_Node_Str"");
  schedule.addActivity(TestConstants.TEST_ACTIVITY);
  schedule.setExpires(""String_Node_Str"");
  tasks=SchedulerFactory.getScheduler(""String_Node_Str"",schedule).getTasks(events,NOW.plusWeeks(1));
  Task task=tasks.get(0);
  assertEquals(""String_Node_Str"",task.getSchedulePlanGuid());
  assertNotNull(task.getGuid());
  assertEquals(""String_Node_Str"",task.getActivity().getLabel());
  assertEquals(""String_Node_Str"",task.getActivity().getRef());
  assertNotNull(task.getScheduledOn());
  assertNotNull(task.getExpiresOn());
}","@SuppressWarnings(""String_Node_Str"") @Test public void taskIsComplete(){
  Schedule schedule=new Schedule();
  schedule.setScheduleType(ScheduleType.ONCE);
  schedule.setLabel(""String_Node_Str"");
  schedule.addActivity(TestConstants.TEST_ACTIVITY);
  schedule.setExpires(""String_Node_Str"");
  tasks=SchedulerFactory.getScheduler(""String_Node_Str"",schedule).getTasks(events,NOW.plusWeeks(1));
  Task task=tasks.get(0);
  assertEquals(""String_Node_Str"",task.getSchedulePlanGuid());
  assertNotNull(task.getGuid());
  assertEquals(""String_Node_Str"",task.getActivity().getLabel());
  assertEquals(""String_Node_Str"",task.getActivity().getRef());
  assertNotNull(task.getScheduledOn());
  assertNotNull(task.getExpiresOn());
}",0.9736279401282965
25763,"@Test public void olderPublishedActivitiesCanBeDeserialized() throws Exception {
  String oldJson=""String_Node_Str"";
  BridgeObjectMapper mapper=BridgeObjectMapper.get();
  Activity activity=mapper.readValue(oldJson,Activity.class);
  assertEquals(""String_Node_Str"",activity.getLabel());
  assertTrue(activity.getRef().matches(""String_Node_Str""));
  assertEquals(ActivityType.SURVEY,activity.getActivityType());
  SurveyReference ref=activity.getSurvey();
  assertNull(""String_Node_Str"",ref.getIdentifier());
  assertNull(""String_Node_Str"",ref.getCreatedOn());
  assertEquals(""String_Node_Str"",""String_Node_Str"",ref.getGuid());
  assertTrue(ref.getHref().matches(""String_Node_Str""));
}","@SuppressWarnings(""String_Node_Str"") @Test public void olderPublishedActivitiesCanBeDeserialized() throws Exception {
  String oldJson=""String_Node_Str"";
  BridgeObjectMapper mapper=BridgeObjectMapper.get();
  Activity activity=mapper.readValue(oldJson,Activity.class);
  assertEquals(""String_Node_Str"",activity.getLabel());
  assertTrue(activity.getRef().matches(""String_Node_Str""));
  assertEquals(ActivityType.SURVEY,activity.getActivityType());
  SurveyReference ref=activity.getSurvey();
  assertNull(""String_Node_Str"",ref.getIdentifier());
  assertNull(""String_Node_Str"",ref.getCreatedOn());
  assertEquals(""String_Node_Str"",""String_Node_Str"",ref.getGuid());
  assertTrue(ref.getHref().matches(""String_Node_Str""));
}",0.9737029140014216
25764,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void changePublishedAndAbsoluteSurveyActivity(){
  service.getTasks(user,endsOn.plusDays(2));
  ArgumentCaptor<List> argument=ArgumentCaptor.forClass(List.class);
  verify(taskDao).saveTasks(anyString(),argument.capture());
  boolean foundTask3=false;
  for (  Task task : (List<Task>)argument.getValue()) {
    if (!""String_Node_Str"".equals(task.getActivity().getRef())) {
      String ref=task.getActivity().getSurveyResponse().getHref();
      assertTrue(""String_Node_Str"",ref.contains(""String_Node_Str""));
    }
 else {
      foundTask3=true;
    }
  }
  assertTrue(""String_Node_Str"",foundTask3);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @Test public void changePublishedAndAbsoluteSurveyActivity(){
  service.getTasks(user,endsOn.plusDays(2));
  ArgumentCaptor<List> argument=ArgumentCaptor.forClass(List.class);
  verify(taskDao).saveTasks(anyString(),argument.capture());
  boolean foundTask3=false;
  for (  Task task : (List<Task>)argument.getValue()) {
    if (!""String_Node_Str"".equals(task.getActivity().getRef())) {
      String ref=task.getActivity().getSurveyResponse().getHref();
      assertTrue(""String_Node_Str"",ref.contains(""String_Node_Str""));
    }
 else {
      foundTask3=true;
    }
  }
  assertTrue(""String_Node_Str"",foundTask3);
}",0.986784140969163
25765,"MimeTypeEmail(String subject,String senderAddress,List<String> recipientAddresses,List<MimeBodyPart> messageParts){
  checkArgument(isNotBlank(senderAddress));
  checkArgument(isNotBlank(subject));
  checkArgument(isNotBlank(senderAddress));
  checkArgument(recipientAddresses != null && !recipientAddresses.isEmpty());
  checkArgument(messageParts != null && !messageParts.isEmpty());
  this.subject=subject;
  this.senderAddress=senderAddress;
  this.recipientAddresses=recipientAddresses;
  this.messageParts=ImmutableList.copyOf(messageParts);
}","MimeTypeEmail(String subject,String senderAddress,List<String> recipientAddresses,List<MimeBodyPart> messageParts){
  checkArgument(isNotBlank(senderAddress));
  checkArgument(isNotBlank(subject));
  checkArgument(isNotBlank(senderAddress));
  checkArgument(recipientAddresses != null && !recipientAddresses.isEmpty());
  checkArgument(messageParts != null && !messageParts.isEmpty());
  this.subject=subject;
  this.senderAddress=escapeEmailAddress(senderAddress);
  this.recipientAddresses=Lists.transform(recipientAddresses,new Function<String,String>(){
    @Override public String apply(    String address){
      return escapeEmailAddress(address);
    }
  }
);
  this.messageParts=ImmutableList.copyOf(messageParts);
}",0.8131868131868132
25766,"@Value(""String_Node_Str"") public void setDefaultEmailVerificationTemplate(org.springframework.core.io.Resource resource){
  this.defaultEmailVerificationTemplate=BridgeUtils.toStringQuietly(resource);
}","@Value(""String_Node_Str"") void setDefaultEmailVerificationTemplate(org.springframework.core.io.Resource resource){
  this.defaultEmailVerificationTemplate=BridgeUtils.toStringQuietly(resource);
}",0.982367758186398
25767,"@Value(""String_Node_Str"") public void setDefaultConsentDocument(org.springframework.core.io.Resource resource){
  this.defaultConsentDocument=new StudyConsentForm(BridgeUtils.toStringQuietly(resource));
}","@Value(""String_Node_Str"") void setDefaultConsentDocument(org.springframework.core.io.Resource resource){
  this.defaultConsentDocument=new StudyConsentForm(BridgeUtils.toStringQuietly(resource));
}",0.9825436408977556
25768,"@Value(""String_Node_Str"") public void setDefaultPasswordTemplate(org.springframework.core.io.Resource resource){
  this.defaultResetPasswordTemplate=BridgeUtils.toStringQuietly(resource);
}","@Value(""String_Node_Str"") void setDefaultPasswordTemplate(org.springframework.core.io.Resource resource){
  this.defaultResetPasswordTemplate=BridgeUtils.toStringQuietly(resource);
}",0.981132075471698
25769,"@Value(""String_Node_Str"") public void setDefaultEmailVerificationTemplateSubject(org.springframework.core.io.Resource resource){
  this.defaultEmailVerificationTemplateSubject=BridgeUtils.toStringQuietly(resource);
}","@Value(""String_Node_Str"") void setDefaultEmailVerificationTemplateSubject(org.springframework.core.io.Resource resource){
  this.defaultEmailVerificationTemplateSubject=BridgeUtils.toStringQuietly(resource);
}",0.983529411764706
25770,"@Override public Study createStudy(Study study){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  checkNewEntity(study,study.getVersion(),""String_Node_Str"");
  setDefaultsIfAbsent(study);
  Validate.entityThrowingException(validator,study);
  String id=study.getIdentifier();
  String lockId=null;
  try {
    lockId=lockDao.acquireLock(Study.class,id);
    if (studyDao.doesIdentifierExist(study.getIdentifier())) {
      throw new EntityAlreadyExistsException(study);
    }
    StudyConsentView view=studyConsentService.addConsent(study.getStudyIdentifier(),defaultConsentDocument);
    studyConsentService.activateConsent(study.getStudyIdentifier(),view.getCreatedOn());
    study.setResearcherRole(study.getIdentifier() + ""String_Node_Str"");
    String directory=directoryDao.createDirectoryForStudy(study);
    study.setStormpathHref(directory);
    uploadCertService.createCmsKeyPair(study.getIdentifier());
    study=studyDao.createStudy(study);
    cacheProvider.setStudy(study);
  }
  finally {
    lockDao.releaseLock(Study.class,id,lockId);
  }
  return study;
}","@Override public Study createStudy(Study study){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  checkNewEntity(study,study.getVersion(),""String_Node_Str"");
  setDefaultsIfAbsent(study);
  Validate.entityThrowingException(validator,study);
  String id=study.getIdentifier();
  String lockId=null;
  try {
    lockId=lockDao.acquireLock(Study.class,id);
    if (studyDao.doesIdentifierExist(study.getIdentifier())) {
      throw new EntityAlreadyExistsException(study);
    }
    StudyConsentView view=studyConsentService.addConsent(study.getStudyIdentifier(),defaultConsentDocument);
    studyConsentService.activateConsent(study.getStudyIdentifier(),view.getCreatedOn());
    study.setActive(true);
    study.setResearcherRole(study.getIdentifier() + ""String_Node_Str"");
    String directory=directoryDao.createDirectoryForStudy(study);
    study.setStormpathHref(directory);
    uploadCertService.createCmsKeyPair(study.getIdentifier());
    study=studyDao.createStudy(study);
    cacheProvider.setStudy(study);
  }
  finally {
    lockDao.releaseLock(Study.class,id,lockId);
  }
  return study;
}",0.9877772747849706
25771,"/** 
 * When certain aspects of as study are excluded on a save, they revert to defaults.
 * @param study
 */
private void setDefaultsIfAbsent(Study study){
  if (study.getPasswordPolicy() == null) {
    study.setPasswordPolicy(PasswordPolicy.DEFAULT_PASSWORD_POLICY);
  }
  study.setVerifyEmailTemplate(fillOutTemplate(study.getVerifyEmailTemplate(),defaultEmailVerificationTemplateSubject,defaultEmailVerificationTemplate));
  study.setResetPasswordTemplate(fillOutTemplate(study.getResetPasswordTemplate(),defaultResetPasswordTemplateSubject,defaultResetPasswordTemplate));
}","/** 
 * When certain aspects of as study are excluded on a save, they revert to defaults. 
 * @param study
 */
private void setDefaultsIfAbsent(Study study){
  if (study.getPasswordPolicy() == null) {
    study.setPasswordPolicy(PasswordPolicy.DEFAULT_PASSWORD_POLICY);
  }
  study.setVerifyEmailTemplate(fillOutTemplate(study.getVerifyEmailTemplate(),defaultEmailVerificationTemplateSubject,defaultEmailVerificationTemplate));
  study.setResetPasswordTemplate(fillOutTemplate(study.getResetPasswordTemplate(),defaultResetPasswordTemplateSubject,defaultResetPasswordTemplate));
}",0.9991356957649092
25772,"@Autowired public void setStudyDao(StudyDao studyDao){
  this.studyDao=studyDao;
}","@Autowired void setStudyDao(StudyDao studyDao){
  this.studyDao=studyDao;
}",0.9554140127388536
25773,"@Autowired public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}","@Autowired void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}",0.966183574879227
25774,"@Override public Study updateStudy(Study study){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  setDefaultsIfAbsent(study);
  Validate.entityThrowingException(validator,study);
  Study originalStudy=studyDao.getStudy(study.getIdentifier());
  study.setStormpathHref(originalStudy.getStormpathHref());
  study.setResearcherRole(originalStudy.getResearcherRole());
  cacheProvider.removeStudy(study.getIdentifier());
  if (studyDirectoryHasChanged(originalStudy,study)) {
    directoryDao.updateDirectoryForStudy(study);
  }
  Study updatedStudy=studyDao.updateStudy(study);
  cacheProvider.setStudy(updatedStudy);
  return updatedStudy;
}","@Override public Study updateStudy(Study study){
  checkNotNull(study,Validate.CANNOT_BE_NULL,""String_Node_Str"");
  setDefaultsIfAbsent(study);
  Validate.entityThrowingException(validator,study);
  Study originalStudy=studyDao.getStudy(study.getIdentifier());
  study.setStormpathHref(originalStudy.getStormpathHref());
  study.setResearcherRole(originalStudy.getResearcherRole());
  study.setActive(originalStudy.isActive());
  cacheProvider.removeStudy(study.getIdentifier());
  if (studyDirectoryHasChanged(originalStudy,study)) {
    directoryDao.updateDirectoryForStudy(study);
  }
  Study updatedStudy=studyDao.updateStudy(study);
  cacheProvider.setStudy(updatedStudy);
  return updatedStudy;
}",0.9668874172185432
25775,"@Autowired public void setValidator(StudyValidator validator){
  this.validator=validator;
}","@Autowired void setValidator(StudyValidator validator){
  this.validator=validator;
}",0.96045197740113
25776,"@Value(""String_Node_Str"") public void setDefaultPasswordTemplateSubject(org.springframework.core.io.Resource resource){
  this.defaultResetPasswordTemplateSubject=BridgeUtils.toStringQuietly(resource);
}","@Value(""String_Node_Str"") void setDefaultPasswordTemplateSubject(org.springframework.core.io.Resource resource){
  this.defaultResetPasswordTemplateSubject=BridgeUtils.toStringQuietly(resource);
}",0.9824561403508772
25777,"@Resource(name=""String_Node_Str"") public void setUploadCertificateService(UploadCertificateService uploadCertService){
  this.uploadCertService=uploadCertService;
}","@Resource(name=""String_Node_Str"") void setUploadCertificateService(UploadCertificateService uploadCertService){
  this.uploadCertService=uploadCertService;
}",0.9781931464174456
25778,"@Autowired public void setDistributedLockDao(DistributedLockDao lockDao){
  this.lockDao=lockDao;
}","@Autowired void setDistributedLockDao(DistributedLockDao lockDao){
  this.lockDao=lockDao;
}",0.9633507853403142
25779,"@Autowired public void setDirectoryDao(DirectoryDao directoryDao){
  this.directoryDao=directoryDao;
}","@Autowired void setDirectoryDao(DirectoryDao directoryDao){
  this.directoryDao=directoryDao;
}",0.964467005076142
25780,"@Override public List<Study> getStudies(){
  return Lists.transform(studyDao.getStudies(),new Function<Study,Study>(){
    @Override public Study apply(    Study study){
      setLegacyFieldsIfAbsent(study);
      return study;
    }
  }
);
}","@Override public List<Study> getStudies(){
  return studyDao.getStudies();
}",0.4779874213836478
25781,"@Autowired public void setStudyConsentService(StudyConsentService studyConsentService){
  this.studyConsentService=studyConsentService;
}","@Autowired void setStudyConsentService(StudyConsentService studyConsentService){
  this.studyConsentService=studyConsentService;
}",0.9737827715355806
25782,"private static ObjectNode getGet(HttpClient client,String url) throws Exception {
  ObjectMapper mapper=new ObjectMapper();
  HttpGet get=new HttpGet(url);
  get.setHeader(""String_Node_Str"",""String_Node_Str"");
  HttpResponse response=client.execute(get);
  ObjectNode object=(ObjectNode)mapper.readTree(EntityUtils.toString(response.getEntity(),""String_Node_Str""));
  System.out.println(""String_Node_Str"" + url + ""String_Node_Str""+ mapper.writeValueAsString(object));
  return object;
}","private ObjectNode getGet(HttpClient client,String url) throws Exception {
  HttpGet get=new HttpGet(url);
  get.setHeader(""String_Node_Str"",""String_Node_Str"");
  HttpResponse response=client.execute(get);
  ObjectNode object=(ObjectNode)MAPPER.readTree(EntityUtils.toString(response.getEntity(),""String_Node_Str""));
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + url + ""String_Node_Str""+ MAPPER.writeValueAsString(object));
  }
  return object;
}",0.3828451882845188
25783,"private void adjustVerifyEmailPolicies(Study study,Directory directory){
}","/** 
 * There is a pull request pending to add this to the Stormpath Java SDK. So this code should be temporary.
 * @param study
 * @param directory
 */
private void adjustVerifyEmailPolicies(Study study,Directory directory){
  logger.info(""String_Node_Str"");
  try {
    EmailTemplate ve=study.getVerifyEmailTemplate();
    BridgeConfig config=BridgeConfigFactory.getConfig();
    CredentialsProvider provider=new BasicCredentialsProvider();
    UsernamePasswordCredentials credentials=new UsernamePasswordCredentials(config.getStormpathId(),config.getStormpathSecret());
    provider.setCredentials(AuthScope.ANY,credentials);
    HttpClient client=HttpClientBuilder.create().setDefaultCredentialsProvider(provider).build();
    ObjectNode directoryNode=getGet(client,directory.getHref());
    String accountCreationUrl=directoryNode.get(""String_Node_Str"").get(""String_Node_Str"").asText();
    ObjectNode accountPolicyNode=getGet(client,accountCreationUrl);
    String verificationEmailTemplatesUrl=accountPolicyNode.get(""String_Node_Str"").get(""String_Node_Str"").asText();
    accountPolicyNode.put(""String_Node_Str"",""String_Node_Str"");
    accountPolicyNode.put(""String_Node_Str"",""String_Node_Str"");
    accountPolicyNode.put(""String_Node_Str"",""String_Node_Str"");
    getPost(client,accountCreationUrl,accountPolicyNode);
    ObjectNode templateNode=getGet(client,verificationEmailTemplatesUrl);
    String templateUrl=templateNode.get(""String_Node_Str"").get(0).get(""String_Node_Str"").asText();
    ObjectNode template=getGet(client,templateUrl);
    template.put(""String_Node_Str"",study.getSponsorName());
    template.put(""String_Node_Str"",String.format(""String_Node_Str"",study.getSponsorName(),study.getSupportEmail()));
    String subject=partiallyResolveTemplate(ve.getSubject(),study);
    template.put(""String_Node_Str"",subject);
    String body=partiallyResolveTemplate(ve.getBody(),study);
    template.put(""String_Node_Str"",body);
    template.remove(""String_Node_Str"");
    template.put(""String_Node_Str"",ve.getMimeType() == MimeType.HTML ? ""String_Node_Str"" : ""String_Node_Str"");
    String link=String.format(""String_Node_Str"",BridgeConfigFactory.getConfig().getBaseURL(),study.getIdentifier());
    ((ObjectNode)template.get(""String_Node_Str"")).put(""String_Node_Str"",link);
    getPost(client,templateUrl,template);
  }
 catch (  Throwable throwable) {
    throw new BridgeServiceException(throwable);
  }
}",0.0544435548438751
25784,"private static ObjectNode getPost(HttpClient client,String url,ObjectNode node) throws Exception {
  ObjectMapper mapper=new ObjectMapper();
  HttpPost post=new HttpPost(url);
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  post.setEntity(new StringEntity(mapper.writeValueAsString(mapper.writeValueAsString(node)),""String_Node_Str""));
  HttpResponse response=client.execute(post);
  ObjectNode object=(ObjectNode)mapper.readTree(EntityUtils.toString(response.getEntity(),""String_Node_Str""));
  System.out.println(""String_Node_Str"" + url + ""String_Node_Str""+ mapper.writeValueAsString(node)+ ""String_Node_Str""+ mapper.writeValueAsString(object));
  return object;
}","private ObjectNode getPost(HttpClient client,String url,ObjectNode node) throws Exception {
  HttpPost post=new HttpPost(url);
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  post.setHeader(""String_Node_Str"",""String_Node_Str"");
  post.setEntity(new StringEntity(MAPPER.writeValueAsString(node),""String_Node_Str""));
  HttpResponse response=client.execute(post);
  ObjectNode object=(ObjectNode)MAPPER.readTree(EntityUtils.toString(response.getEntity(),""String_Node_Str""));
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + url + ""String_Node_Str""+ MAPPER.writeValueAsString(node)+ ""String_Node_Str""+ MAPPER.writeValueAsString(object));
  }
  return object;
}",0.4494699646643109
25785,"public DynamoTaskEvent build(){
  DynamoTaskEvent event=new DynamoTaskEvent();
  event.setHealthCode(healthCode);
  event.setTimestamp((timestamp == null) ? null : timestamp);
  event.setEventId(getEventId());
  Validate.entityThrowingException(TaskEventValidator.INSTANCE,event);
  return event;
}","public DynamoTaskEvent build(){
  DynamoTaskEvent event=new DynamoTaskEvent();
  event.setHealthCode(healthCode);
  event.setTimestamp((timestamp == null) ? null : timestamp);
  event.setEventId(getEventId());
  event.setAnswerValue(answerValue);
  Validate.entityThrowingException(TaskEventValidator.INSTANCE,event);
  return event;
}",0.9415481832543444
25786,"private String getEventId(){
  if (type == null) {
    return null;
  }
  String typeName=type.name().toLowerCase();
  if (objectId != null && eventType != null && value != null) {
    return String.format(""String_Node_Str"",typeName,objectId,eventType.name().toLowerCase(),value);
  }
 else   if (objectId != null && eventType != null) {
    return String.format(""String_Node_Str"",typeName,objectId,eventType.name().toLowerCase());
  }
 else   if (objectId != null) {
    return String.format(""String_Node_Str"",typeName,objectId);
  }
  return typeName;
}","private String getEventId(){
  if (type == null) {
    return null;
  }
  if (type == TaskEventObjectType.ENROLLMENT) {
    return type.name().toLowerCase();
  }
  String typeName=type.name().toLowerCase();
  if (objectId != null && eventType != null) {
    return String.format(""String_Node_Str"",typeName,objectId,eventType.name().toLowerCase());
  }
 else   if (objectId != null) {
    return String.format(""String_Node_Str"",typeName,objectId);
  }
  return typeName;
}",0.6140350877192983
25787,"@Override public Map<String,DateTime> getTaskEventMap(String healthCode){
  checkNotNull(healthCode);
  DynamoTaskEvent hashKey=new DynamoTaskEvent();
  hashKey.setHealthCode(healthCode);
  DynamoDBQueryExpression<DynamoTaskEvent> query=new DynamoDBQueryExpression<DynamoTaskEvent>().withHashKeyValues(hashKey);
  PaginatedQueryList<DynamoTaskEvent> queryResults=mapper.query(DynamoTaskEvent.class,query);
  Builder<String,DateTime> builder=ImmutableMap.<String,DateTime>builder();
  for (  DynamoTaskEvent event : queryResults) {
    builder.put(event.getEventId(),new DateTime(event.getTimestamp()));
  }
  return builder.build();
}","@Override public Map<String,DateTime> getTaskEventMap(String healthCode){
  checkNotNull(healthCode);
  DynamoTaskEvent hashKey=new DynamoTaskEvent();
  hashKey.setHealthCode(healthCode);
  DynamoDBQueryExpression<DynamoTaskEvent> query=new DynamoDBQueryExpression<DynamoTaskEvent>().withHashKeyValues(hashKey);
  PaginatedQueryList<DynamoTaskEvent> queryResults=mapper.query(DynamoTaskEvent.class,query);
  Builder<String,DateTime> builder=ImmutableMap.<String,DateTime>builder();
  for (  DynamoTaskEvent event : queryResults) {
    builder.put(getEventMapKey(event),new DateTime(event.getTimestamp()));
  }
  return builder.build();
}",0.970889063729347
25788,"@Override public void validate(Object object,Errors errors){
  DynamoTaskEvent event=(DynamoTaskEvent)object;
  if (isBlank(event.getHealthCode())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (event.getTimestamp() == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (event.getEventId() == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
}","@Override public void validate(Object object,Errors errors){
  DynamoTaskEvent event=(DynamoTaskEvent)object;
  if (isBlank(event.getHealthCode())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (event.getTimestamp() == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (event.getEventId() == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (event.getEventId().endsWith(""String_Node_Str"") && isBlank(event.getAnswerValue())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
}",0.8383233532934131
25789,"@Test public void canCrudEvent(){
  DateTime time1=DateTime.now();
  DateTime time2=time1.plusDays(1);
  DateTime time3=time2.plusDays(1);
  TaskEvent event=new DynamoTaskEvent.Builder().withHealthCode(""String_Node_Str"").withObjectType(TaskEventObjectType.ENROLLMENT).withTimestamp(time1).build();
  taskEventDao.publishEvent(event);
  event=new DynamoTaskEvent.Builder().withHealthCode(""String_Node_Str"").withObjectType(TaskEventObjectType.SURVEY).withEventType(TaskEventType.FINISHED).withTimestamp(time3).withObjectId(""String_Node_Str"").build();
  taskEventDao.publishEvent(event);
  Map<String,DateTime> map=taskEventDao.getTaskEventMap(""String_Node_Str"");
  assertEquals(2,map.size());
  assertEquals(time1,map.get(""String_Node_Str""));
  assertEquals(time3,map.get(""String_Node_Str""));
  event=new DynamoTaskEvent.Builder().withHealthCode(""String_Node_Str"").withObjectType(TaskEventObjectType.ENROLLMENT).withTimestamp(time2).build();
  taskEventDao.publishEvent(event);
  map=taskEventDao.getTaskEventMap(""String_Node_Str"");
  assertEquals(time2,map.get(""String_Node_Str""));
  taskEventDao.deleteTaskEvents(""String_Node_Str"");
  map=taskEventDao.getTaskEventMap(""String_Node_Str"");
  assertEquals(0,map.size());
}","@Test public void canCrudEvent(){
  DateTime time1=DateTime.now();
  DateTime time2=time1.plusDays(1);
  DateTime time3=time1.plusDays(2);
  DateTime time4=time1.plusDays(3);
  DateTime time5=time1.plusDays(4);
  TaskEvent event=getEnrollmentEvent(time1);
  taskEventDao.publishEvent(event);
  event=getSurveyFinishedEvent(time2);
  taskEventDao.publishEvent(event);
  event=getQuestionAnsweredEvent(time3,""String_Node_Str"");
  taskEventDao.publishEvent(event);
  Map<String,DateTime> map=taskEventDao.getTaskEventMap(""String_Node_Str"");
  assertEquals(3,map.size());
  assertEquals(time1,map.get(""String_Node_Str""));
  assertEquals(time2,map.get(""String_Node_Str""));
  assertEquals(time3,map.get(""String_Node_Str""));
  event=getQuestionAnsweredEvent(time4,""String_Node_Str"");
  taskEventDao.publishEvent(event);
  map=taskEventDao.getTaskEventMap(""String_Node_Str"");
  assertEquals(time4,map.get(""String_Node_Str""));
  event=getQuestionAnsweredEvent(time5,""String_Node_Str"");
  taskEventDao.publishEvent(event);
  map=taskEventDao.getTaskEventMap(""String_Node_Str"");
  assertEquals(time5,map.get(""String_Node_Str""));
  assertNull(map.get(""String_Node_Str""));
  taskEventDao.deleteTaskEvents(""String_Node_Str"");
  map=taskEventDao.getTaskEventMap(""String_Node_Str"");
  assertEquals(0,map.size());
}",0.3710766785856178
25790,"/** 
 * {@inheritDoc} 
 */
@Override public void run(){
  Stopwatch stopwatch=Stopwatch.createUnstarted();
  for (  UploadValidationHandler oneHandler : handlerList) {
    String handlerName=oneHandler.getClass().getName();
    stopwatch.start();
    try {
      oneHandler.handle(context);
    }
 catch (    RuntimeException|UploadValidationException ex) {
      context.setSuccess(false);
      context.addMessage(String.format(""String_Node_Str"",handlerName,ex.getClass().getName(),ex.getMessage()));
      logger.info(String.format(""String_Node_Str"" + ""String_Node_Str"",handlerName,context.getStudy().getIdentifier(),context.getUpload().getUploadId(),context.getUpload().getFilename(),ex.getClass().getName(),ex.getMessage()),ex);
      break;
    }
catch (    Throwable t) {
      logger.error(String.format(""String_Node_Str"" + ""String_Node_Str"",handlerName,context.getStudy().getIdentifier(),context.getUpload().getUploadId(),context.getUpload().getFilename(),t.getClass().getName(),t.getMessage()),t);
      break;
    }
 finally {
      long elapsedMillis=stopwatch.elapsed(TimeUnit.MILLISECONDS);
      stopwatch.reset();
      logger.info(String.format(""String_Node_Str"",handlerName,elapsedMillis));
    }
  }
  UploadStatus status=context.getSuccess() ? UploadStatus.SUCCEEDED : UploadStatus.VALIDATION_FAILED;
  uploadDao.writeValidationStatus(context.getUpload(),status,context.getMessageList());
  logger.info(String.format(""String_Node_Str"",context.getStudy().getIdentifier(),context.getUpload().getUploadId(),status));
}","/** 
 * {@inheritDoc} 
 */
@Override public void run(){
  Stopwatch stopwatch=Stopwatch.createUnstarted();
  for (  UploadValidationHandler oneHandler : handlerList) {
    String handlerName=oneHandler.getClass().getName();
    stopwatch.start();
    try {
      oneHandler.handle(context);
    }
 catch (    Throwable ex) {
      context.setSuccess(false);
      context.addMessage(String.format(""String_Node_Str"",handlerName,ex.getClass().getName(),ex.getMessage()));
      if (ex instanceof Error) {
        logger.error(String.format(""String_Node_Str"" + ""String_Node_Str"",handlerName,context.getStudy().getIdentifier(),context.getUpload().getUploadId(),context.getUpload().getFilename(),ex.getClass().getName(),ex.getMessage()),ex);
      }
 else {
        logger.info(String.format(""String_Node_Str"" + ""String_Node_Str"",handlerName,context.getStudy().getIdentifier(),context.getUpload().getUploadId(),context.getUpload().getFilename(),ex.getClass().getName(),ex.getMessage()),ex);
      }
      break;
    }
 finally {
      long elapsedMillis=stopwatch.elapsed(TimeUnit.MILLISECONDS);
      stopwatch.reset();
      logger.info(String.format(""String_Node_Str"",handlerName,elapsedMillis));
    }
  }
  UploadStatus status=context.getSuccess() ? UploadStatus.SUCCEEDED : UploadStatus.VALIDATION_FAILED;
  uploadDao.writeValidationStatus(context.getUpload(),status,context.getMessageList());
  logger.info(String.format(""String_Node_Str"",context.getStudy().getIdentifier(),context.getUpload().getUploadId(),status));
}",0.6910994764397905
25791,"@Test public void happyCase(){
  List<UploadValidationHandler> handlerList=ImmutableList.<UploadValidationHandler>of(new MessageHandler(""String_Node_Str""),new MessageHandler(""String_Node_Str""),new MessageHandler(""String_Node_Str""));
  UploadValidationContext ctx=testHelper(handlerList,UploadStatus.SUCCEEDED);
  List<String> messageList=ctx.getMessageList();
  assertEquals(3,messageList.size());
  assertEquals(""String_Node_Str"",messageList.get(0));
  assertEquals(""String_Node_Str"",messageList.get(1));
  assertEquals(""String_Node_Str"",messageList.get(2));
}","@Test public void happyCase(){
  List<UploadValidationHandler> handlerList=ImmutableList.<UploadValidationHandler>of(new MessageHandler(""String_Node_Str""),new MessageHandler(""String_Node_Str""),new MessageHandler(""String_Node_Str""));
  UploadValidationContext ctx=testHelper(handlerList,UploadStatus.SUCCEEDED);
  assertTrue(ctx.getSuccess());
  List<String> messageList=ctx.getMessageList();
  assertEquals(3,messageList.size());
  assertEquals(""String_Node_Str"",messageList.get(0));
  assertEquals(""String_Node_Str"",messageList.get(1));
  assertEquals(""String_Node_Str"",messageList.get(2));
}",0.9722703639514731
25792,"private static void testExceptionHelper(Class<? extends Exception> exClass) throws Exception {
  UploadValidationHandler fooHandler=new MessageHandler(""String_Node_Str"");
  UploadValidationHandler barHandler=mock(UploadValidationHandler.class);
  doThrow(exClass).when(barHandler).handle(notNull(UploadValidationContext.class));
  UploadValidationHandler bazHandler=mock(UploadValidationHandler.class);
  verifyZeroInteractions(bazHandler);
  List<UploadValidationHandler> handlerList=ImmutableList.of(fooHandler,barHandler,bazHandler);
  UploadValidationContext ctx=testHelper(handlerList,UploadStatus.VALIDATION_FAILED);
  List<String> messageList=ctx.getMessageList();
  assertEquals(2,messageList.size());
  assertEquals(""String_Node_Str"",messageList.get(0));
  assertFalse(Strings.isNullOrEmpty(messageList.get(1)));
}","private static void testExceptionHelper(Class<? extends Throwable> exClass) throws Exception {
  UploadValidationHandler fooHandler=new MessageHandler(""String_Node_Str"");
  UploadValidationHandler barHandler=mock(UploadValidationHandler.class);
  doThrow(exClass).when(barHandler).handle(notNull(UploadValidationContext.class));
  UploadValidationHandler bazHandler=mock(UploadValidationHandler.class);
  verifyZeroInteractions(bazHandler);
  List<UploadValidationHandler> handlerList=ImmutableList.of(fooHandler,barHandler,bazHandler);
  UploadValidationContext ctx=testHelper(handlerList,UploadStatus.VALIDATION_FAILED);
  assertFalse(ctx.getSuccess());
  List<String> messageList=ctx.getMessageList();
  assertEquals(2,messageList.size());
  assertEquals(""String_Node_Str"",messageList.get(0));
  assertFalse(Strings.isNullOrEmpty(messageList.get(1)));
}",0.9696247766527696
25793,"@Override public Account getAccount(Study study,String email){
  checkNotNull(study);
  checkArgument(isNotBlank(email));
  Directory directory=client.getResource(study.getStormpathHref(),Directory.class);
  AccountList accounts=directory.getAccounts(Accounts.where(Accounts.email().eqIgnoreCase(email)).withGroups().withGroupMemberships());
  if (accounts.iterator().hasNext()) {
    com.stormpath.sdk.account.Account acct=accounts.iterator().next();
    return new StormpathAccount(study.getStudyIdentifier(),acct,encryptors);
  }
  return null;
}","@Override public Account getAccount(Study study,String email){
  checkNotNull(study);
  checkArgument(isNotBlank(email));
  Directory directory=client.getResource(study.getStormpathHref(),Directory.class);
  AccountList accounts=directory.getAccounts(Accounts.where(Accounts.email().eqIgnoreCase(email)).withCustomData().withGroups().withGroupMemberships());
  if (accounts.iterator().hasNext()) {
    com.stormpath.sdk.account.Account acct=accounts.iterator().next();
    return new StormpathAccount(study.getStudyIdentifier(),acct,encryptors);
  }
  return null;
}",0.9847533632286996
25794,"public String getStormpathSecret(){
  return getProperty(STORMPATH_SECRET);
}","public String getStormpathSecret(){
  return getProperty(ENTERPRISE_STORMPATH_SECRET);
}",0.9333333333333332
25795,"public String getStormpathApplicationHref(){
  return getProperty(STORMPATH_APPLICATION_HREF);
}","public String getStormpathApplicationHref(){
  return getProperty(ENTERPRISE_STORMPATH_APPLICATION_HREF);
}",0.9458128078817734
25796,"public String getStormpathId(){
  return getProperty(STORMPATH_ID);
}","public String getStormpathId(){
  return getProperty(ENTERPRISE_STORMPATH_ID);
}",0.9261744966442952
25797,"@Bean(name=""String_Node_Str"") @Autowired public Client getStormpathClient(BridgeConfig bridgeConfig){
  ApiKey apiKey=ApiKeys.builder().setId(bridgeConfig.getStormpathId().trim()).setSecret(bridgeConfig.getStormpathSecret().trim()).build();
  return Clients.builder().setApiKey(apiKey).build();
}","@Bean(name=""String_Node_Str"") @Autowired public Client getStormpathClient(BridgeConfig bridgeConfig){
  ApiKey apiKey=ApiKeys.builder().setId(bridgeConfig.getStormpathId().trim()).setSecret(bridgeConfig.getStormpathSecret().trim()).build();
  ClientBuilder clientBuilder=Clients.builder().setApiKey(apiKey);
  ((DefaultClientBuilder)clientBuilder).setBaseUrl(""String_Node_Str"");
  return clientBuilder.build();
}",0.8163841807909604
25798,"@Override public void onApplicationEvent(final ContextRefreshedEvent event){
  Map<Environment,Map<String,String>> targetMap=backMap;
  Environment env=BridgeConfigFactory.getConfig().getEnvironment();
  for (  Study study : studyService.getStudies()) {
    String studyId=study.getIdentifier();
    String targetHref=targetMap.get(env).get(studyId);
    try {
      if (targetHref != null) {
        if (!study.getStormpathHref().equals(targetHref)) {
          log(""String_Node_Str"",studyId,targetHref);
          study.setStormpathHref(targetHref);
          studyDao.updateStudy(study);
          cacheProvider.setStudy(study);
        }
 else {
          log(""String_Node_Str"",studyId,targetHref);
        }
      }
 else {
        log(""String_Node_Str"",studyId,""String_Node_Str"");
      }
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}","@Override public void onApplicationEvent(final ContextRefreshedEvent event){
  Map<Environment,Map<String,String>> targetMap=foreMap;
  Environment env=BridgeConfigFactory.getConfig().getEnvironment();
  for (  Study study : studyService.getStudies()) {
    String studyId=study.getIdentifier();
    String targetHref=targetMap.get(env).get(studyId);
    try {
      if (targetHref != null) {
        if (!study.getStormpathHref().equals(targetHref)) {
          log(""String_Node_Str"",studyId,targetHref);
          study.setStormpathHref(targetHref);
          studyDao.updateStudy(study);
          cacheProvider.setStudy(study);
        }
 else {
          log(""String_Node_Str"",studyId,targetHref);
        }
      }
 else {
        log(""String_Node_Str"",studyId,""String_Node_Str"");
      }
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}",0.9953810623556582
25799,"@Override public Account verifyEmail(StudyIdentifier study,EmailVerification verification){
  checkNotNull(study);
  checkNotNull(verification);
  try {
    com.stormpath.sdk.account.Account acct=client.getCurrentTenant().verifyAccountEmail(verification.getSptoken());
    return (acct == null) ? null : new StormpathAccount(study,acct,encryptors);
  }
 catch (  ResourceException e) {
    rethrowResourceException(e,null);
  }
  return null;
}","@Override public Account verifyEmail(StudyIdentifier study,EmailVerification verification){
  checkNotNull(study);
  checkNotNull(verification);
  try {
    com.stormpath.sdk.account.Account acct=client.verifyAccountEmail(verification.getSptoken());
    return (acct == null) ? null : new StormpathAccount(study,acct,encryptors);
  }
 catch (  ResourceException e) {
    rethrowResourceException(e,null);
  }
  return null;
}",0.9781357882623706
25800,"/** 
 * Compare lists of indices from 2 different tables. If isGlobal is true, then this function compares global secondary indices, and the elements of the list should be GlobalSecondaryIndexDescriptions. If isGlobal is false, then this function compares local secondary indices, and the elements of the list should be LocalSecondaryIndexDescriptions.
 * @param tableName name of table to compare against (generally table 1, but they should be the same)
 * @param indices1 a list of index descriptions from table 1
 * @param indices2 a list of index descriptions from table 2
 * @param isGlobal true if these are glocal indices, false otherwise
 */
static void compareSecondaryIndices(String tableName,List<?> indices1,List<?> indices2,boolean isGlobal){
  int numIndices1=indices1 == null ? 0 : indices1.size();
  int numIndices2=indices2 == null ? 0 : indices2.size();
  if (numIndices1 != numIndices2) {
    throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str"");
  }
  if (numIndices1 == 0) {
    return;
  }
  Map<String,Object> indexMap1=new HashMap<>();
  for (  Object index1 : indices1) {
    String indexName;
    if (isGlobal) {
      indexName=((GlobalSecondaryIndexDescription)index1).getIndexName();
    }
 else {
      indexName=((LocalSecondaryIndexDescription)index1).getIndexName();
    }
    indexMap1.put(indexName,index1);
  }
  for (  Object index2 : indices2) {
    String indexName;
    if (isGlobal) {
      indexName=((GlobalSecondaryIndexDescription)index2).getIndexName();
    }
 else {
      indexName=((LocalSecondaryIndexDescription)index2).getIndexName();
    }
    Object index1=indexMap1.get(indexName);
    if (index1 == null) {
      throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str"");
    }
    if (isGlobal) {
      GlobalSecondaryIndexDescription globalIndex1=(GlobalSecondaryIndexDescription)index1;
      GlobalSecondaryIndexDescription globalIndex2=(GlobalSecondaryIndexDescription)index2;
      compareKeySchema(globalIndex1.getKeySchema(),globalIndex2.getKeySchema());
      if (!globalIndex1.getProjection().equals(globalIndex2.getProjection())) {
        throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str""+ indexName+ ""String_Node_Str"");
      }
      if (!globalIndex1.getProvisionedThroughput().equals(globalIndex2.getProvisionedThroughput())) {
        throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str""+ indexName+ ""String_Node_Str"");
      }
    }
 else {
      LocalSecondaryIndexDescription localIndex1=(LocalSecondaryIndexDescription)index1;
      LocalSecondaryIndexDescription localIndex2=(LocalSecondaryIndexDescription)index2;
      compareKeySchema(localIndex1.getKeySchema(),localIndex2.getKeySchema());
      if (!localIndex1.getProjection().equals(localIndex2.getProjection())) {
        throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str""+ indexName+ ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Compare lists of indices from 2 different tables. If isGlobal is true, then this function compares global secondary indices, and the elements of the list should be GlobalSecondaryIndexDescriptions. If isGlobal is false, then this function compares local secondary indices, and the elements of the list should be LocalSecondaryIndexDescriptions.
 * @param tableName name of table to compare against (generally table 1, but they should be the same)
 * @param indices1 a list of index descriptions from table 1
 * @param indices2 a list of index descriptions from table 2
 * @param isGlobal true if these are glocal indices, false otherwise
 */
static void compareSecondaryIndices(String tableName,List<?> indices1,List<?> indices2,boolean isGlobal){
  int numIndices1=indices1 == null ? 0 : indices1.size();
  int numIndices2=indices2 == null ? 0 : indices2.size();
  if (numIndices1 != numIndices2) {
    throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str"");
  }
  if (numIndices1 == 0) {
    return;
  }
  Map<String,Object> indexMap1=new HashMap<>();
  for (  Object index1 : indices1) {
    String indexName;
    if (isGlobal) {
      indexName=((GlobalSecondaryIndexDescription)index1).getIndexName();
    }
 else {
      indexName=((LocalSecondaryIndexDescription)index1).getIndexName();
    }
    indexMap1.put(indexName,index1);
  }
  for (  Object index2 : indices2) {
    String indexName;
    if (isGlobal) {
      indexName=((GlobalSecondaryIndexDescription)index2).getIndexName();
    }
 else {
      indexName=((LocalSecondaryIndexDescription)index2).getIndexName();
    }
    Object index1=indexMap1.get(indexName);
    if (index1 == null) {
      throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str"");
    }
    if (isGlobal) {
      GlobalSecondaryIndexDescription globalIndex1=(GlobalSecondaryIndexDescription)index1;
      GlobalSecondaryIndexDescription globalIndex2=(GlobalSecondaryIndexDescription)index2;
      compareKeySchema(globalIndex1.getKeySchema(),globalIndex2.getKeySchema());
      if (!globalIndex1.getProjection().equals(globalIndex2.getProjection())) {
        throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str""+ indexName+ ""String_Node_Str"");
      }
      if (!globalIndex1.getProvisionedThroughput().getReadCapacityUnits().equals(globalIndex2.getProvisionedThroughput().getReadCapacityUnits())) {
        throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str""+ indexName+ ""String_Node_Str"");
      }
      if (!globalIndex1.getProvisionedThroughput().getWriteCapacityUnits().equals(globalIndex2.getProvisionedThroughput().getWriteCapacityUnits())) {
        throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str""+ indexName+ ""String_Node_Str"");
      }
    }
 else {
      LocalSecondaryIndexDescription localIndex1=(LocalSecondaryIndexDescription)index1;
      LocalSecondaryIndexDescription localIndex2=(LocalSecondaryIndexDescription)index2;
      compareKeySchema(localIndex1.getKeySchema(),localIndex2.getKeySchema());
      if (!localIndex1.getProjection().equals(localIndex2.getProjection())) {
        throw new BridgeInitializationException(""String_Node_Str"" + tableName + ""String_Node_Str""+ indexName+ ""String_Node_Str"");
      }
    }
  }
}",0.9480236539060068
25801,"public Study getStudy(String identifier){
  try {
    String redisKey=RedisKey.STUDY.getRedisKey(identifier);
    String ser=stringOps.get(redisKey).execute();
    if (ser != null) {
      stringOps.expire(redisKey,BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS);
      return DynamoStudy.fromJson(BridgeObjectMapper.get().readTree(ser));
    }
  }
 catch (  Throwable e) {
    promptToStartRedisIfLocalEnv(e);
    throw new BridgeServiceException(e);
  }
  return null;
}","public Study getStudy(String identifier){
  try {
    String redisKey=RedisKey.STUDY.getRedisKey(identifier);
    String ser=stringOps.get(redisKey).execute();
    if (ser != null) {
      stringOps.expire(redisKey,BridgeConstants.BRIDGE_SESSION_EXPIRE_IN_SECONDS);
      return DynamoStudy.fromCacheJson(BridgeObjectMapper.get().readTree(ser));
    }
  }
 catch (  Throwable e) {
    promptToStartRedisIfLocalEnv(e);
    throw new BridgeServiceException(e);
  }
  return null;
}",0.994753410283316
25802,"private UserSession createSessionFromAccount(Study study,Account account){
  final UserSession session=new UserSession();
  session.setAuthenticated(true);
  session.setEnvironment(config.getEnvironment().name().toLowerCase());
  session.setSessionToken(BridgeUtils.generateGuid());
  final User user=new User(account);
  user.setStudyKey(study.getIdentifier());
  HealthId healthId=accountEncryptionService.getHealthCode(study,account);
  if (healthId != null) {
    String healthCode=healthId.getCode();
    user.setHealthCode(healthCode);
    boolean consent=consentService.hasUserConsentedToResearch(user,study);
    user.setConsent(consent);
    if (healthCode != null) {
      boolean dataSharing=optionsService.getBooleanOption(healthCode,Option.DATA_SHARING);
      user.setDataSharing(dataSharing);
    }
  }
  if (user.isInRole(BridgeConstants.ADMIN_GROUP) || user.isInRole(study.getResearcherRole())) {
    user.setConsent(true);
  }
  String adminUser=BridgeConfigFactory.getConfig().getProperty(""String_Node_Str"");
  if (adminUser != null && adminUser.equals(account.getEmail())) {
    user.setConsent(true);
  }
  session.setUser(user);
  return session;
}","private UserSession createSessionFromAccount(Study study,Account account){
  final UserSession session=new UserSession();
  session.setAuthenticated(true);
  session.setEnvironment(config.getEnvironment().name().toLowerCase());
  session.setSessionToken(BridgeUtils.generateGuid());
  final User user=new User(account);
  user.setStudyKey(study.getIdentifier());
  final String healthCode=getHealthCode(study,account);
  user.setHealthCode(healthCode);
  user.setConsent(consentService.hasUserConsentedToResearch(user,study));
  user.setDataSharing(optionsService.getBooleanOption(healthCode,Option.DATA_SHARING));
  if (user.isInRole(BridgeConstants.ADMIN_GROUP) || user.isInRole(study.getResearcherRole())) {
    user.setConsent(true);
  }
  String adminUser=BridgeConfigFactory.getConfig().getProperty(""String_Node_Str"");
  if (adminUser != null && adminUser.equals(account.getEmail())) {
    user.setConsent(true);
  }
  session.setUser(user);
  return session;
}",0.843238184370613
25803,"private int backfillForStudy(Study study){
  int count=0;
  Application application=StormpathFactory.getStormpathApplication(stormpathClient);
  StormpathAccountIterator iterator=new StormpathAccountIterator(application);
  while (iterator.hasNext()) {
    List<Account> accountList=iterator.next();
    for (    Account account : accountList) {
      final CustomData customData=account.getCustomData();
      final String studyKey=study.getIdentifier();
      final String healthIdKey=studyKey + BridgeConstants.CUSTOM_DATA_HEALTH_CODE_SUFFIX;
      final Object healthIdObj=customData.get(healthIdKey);
      if (healthIdObj == null) {
        accountEncryptionService.createAndSaveHealthCode(study,account);
        count++;
        logger.info(""String_Node_Str"" + account.getEmail() + ""String_Node_Str""+ study.getName());
      }
 else {
        int version=1;
        Object versionObj=customData.get(BridgeConstants.CUSTOM_DATA_VERSION);
        if (versionObj != null) {
          version=(Integer)versionObj;
        }
        if (version < 2) {
          String healthId=healthCodeEncryptorOld.decrypt((String)healthIdObj);
          String encryptedHealthId=healthCodeEncryptor.encrypt(healthId);
          customData.put(healthIdKey,encryptedHealthId);
          customData.put(BridgeConstants.CUSTOM_DATA_VERSION,2);
          customData.save();
          count++;
          logger.info(""String_Node_Str"" + account.getEmail() + ""String_Node_Str""+ study.getName());
        }
      }
    }
  }
  return count;
}","private int backfillForStudy(Study study){
  int count=0;
  Application application=StormpathFactory.getStormpathApplication(stormpathClient);
  StormpathAccountIterator iterator=new StormpathAccountIterator(application);
  while (iterator.hasNext()) {
    List<Account> accountList=iterator.next();
    for (    Account account : accountList) {
      final CustomData customData=account.getCustomData();
      final String studyKey=study.getIdentifier();
      final String healthIdKey=studyKey + BridgeConstants.CUSTOM_DATA_HEALTH_CODE_SUFFIX;
      final Object healthIdObj=customData.get(healthIdKey);
      if (healthIdObj == null) {
        accountEncryptionService.createAndSaveHealthCode(study,account);
        count++;
        logger.info(""String_Node_Str"" + account.getEmail() + ""String_Node_Str""+ study.getName());
      }
 else {
        int version=1;
        Object versionObj=customData.get(BridgeConstants.CUSTOM_DATA_VERSION);
        if (versionObj != null) {
          version=(Integer)versionObj;
        }
        if (version < 2) {
          String healthId=healthCodeEncryptorOld.decrypt((String)healthIdObj);
          String encryptedHealthId=healthCodeEncryptor.encrypt(healthId);
          customData.put(healthIdKey,encryptedHealthId);
          customData.put(BridgeConstants.CUSTOM_DATA_VERSION,2);
          customData.save();
          count++;
          logger.info(""String_Node_Str"" + account.getEmail() + ""String_Node_Str""+ study.getName());
        }
        HealthId healthId=accountEncryptionService.getHealthCode(study,account);
        String healthCode=healthId.getCode();
        if (healthCode == null) {
          customData.remove(healthIdKey);
          accountEncryptionService.createAndSaveHealthCode(study,account);
          logger.info(""String_Node_Str"" + account.getEmail() + ""String_Node_Str""+ study.getName());
        }
      }
    }
  }
  return count;
}",0.8788584740827023
25804,"@Override public void validate(Errors errors){
  int percentage=0;
  for (  ScheduleGroup group : groups) {
    percentage+=group.getPercentage();
  }
  if (percentage != 100) {
    errors.reject(String.format(""String_Node_Str"",percentage));
  }
  for (  ScheduleGroup group : groups) {
    if (group.getSchedule() == null) {
      errors.reject(""String_Node_Str"");
      return;
    }
  }
}","@Override public void validate(Errors errors){
  int percentage=0;
  for (  ScheduleGroup group : groups) {
    percentage+=group.getPercentage();
  }
  if (percentage != 100) {
    errors.reject(String.format(""String_Node_Str"",percentage));
  }
  for (int i=0; i < groups.size(); i++) {
    ScheduleGroup group=groups.get(i);
    errors.pushNestedPath(""String_Node_Str"" + i + ""String_Node_Str"");
    if (group.getSchedule() == null) {
      errors.reject(""String_Node_Str"");
      errors.popNestedPath();
      return;
    }
 else {
      errors.pushNestedPath(""String_Node_Str"");
      new ScheduleValidator().validate(group.getSchedule(),errors);
      errors.popNestedPath();
    }
    errors.popNestedPath();
  }
  for (  ScheduleGroup group : groups) {
    if (group.getSchedule() == null) {
      errors.reject(""String_Node_Str"");
      return;
    }
 else {
      errors.pushNestedPath(""String_Node_Str"");
      new ScheduleValidator().validate(group.getSchedule(),errors);
      errors.popNestedPath();
    }
  }
}",0.536067892503536
25805,"@Override public void validate(Errors errors){
  if (schedule == null) {
    errors.reject(""String_Node_Str"");
  }
}","@Override public void validate(Errors errors){
  if (schedule == null) {
    errors.reject(""String_Node_Str"");
  }
 else {
    errors.pushNestedPath(""String_Node_Str"");
    new ScheduleValidator().validate(schedule,errors);
    errors.popNestedPath();
  }
}",0.6219839142091153
25806,"@Override public void validate(Object obj,Errors errors){
  SchedulePlan plan=(SchedulePlan)obj;
  if (StringUtils.isBlank(plan.getStudyKey())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (plan.getStrategy() == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    plan.getStrategy().validate(errors);
  }
}","@Override public void validate(Object obj,Errors errors){
  SchedulePlan plan=(SchedulePlan)obj;
  if (StringUtils.isBlank(plan.getStudyKey())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (plan.getStrategy() == null) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    errors.pushNestedPath(""String_Node_Str"");
    plan.getStrategy().validate(errors);
    errors.popNestedPath();
  }
}",0.9081885856079404
25807,"@Override public void validate(Object object,Errors errors){
  Schedule schedule=(Schedule)object;
  if (StringUtils.isBlank(schedule.getLabel())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (StringUtils.isBlank(schedule.getActivityRef())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (StringUtils.isBlank(schedule.getSchedulePlanGuid())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (StringUtils.isBlank(schedule.getStudyUserCompoundKey())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (schedule.getActivityType() == null) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_NULL);
  }
  if (schedule.getScheduleType() == null) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_NULL);
  }
  if (schedule.getScheduleType() == ScheduleType.ONCE) {
    if (StringUtils.isNotBlank(schedule.getCronTrigger())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
  }
  if (schedule.getScheduleType() == ScheduleType.RECURRING) {
    if (StringUtils.isBlank(schedule.getCronTrigger())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
  }
}","@Override public void validate(Object object,Errors errors){
  Schedule schedule=(Schedule)object;
  if (StringUtils.isBlank(schedule.getLabel())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (StringUtils.isBlank(schedule.getActivityRef())) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_BLANK);
  }
  if (schedule.getActivityType() == null) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_NULL);
  }
  if (schedule.getScheduleType() == null) {
    errors.rejectValue(""String_Node_Str"",CANNOT_BE_NULL);
  }
  if (schedule.getScheduleType() == ScheduleType.ONCE) {
    if (StringUtils.isNotBlank(schedule.getCronTrigger())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
  }
  if (schedule.getScheduleType() == ScheduleType.RECURRING) {
    if (StringUtils.isBlank(schedule.getCronTrigger())) {
      errors.rejectValue(""String_Node_Str"",""String_Node_Str"");
    }
  }
}",0.8804554079696395
25808,"private void validateRules(Errors errors,List<SurveyQuestion> questions){
  Set<String> alreadySeenIdentifiers=Sets.newHashSet();
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    Constraints c=question.getConstraints();
    if (c != null && c.getRules() != null) {
      for (      SurveyRule rule : c.getRules()) {
        if (alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
          errors.pushNestedPath(""String_Node_Str"" + i);
          rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
          errors.popNestedPath();
        }
      }
    }
    alreadySeenIdentifiers.add(question.getIdentifier());
  }
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    Constraints c=question.getConstraints();
    if (c != null && c.getRules() != null) {
      for (      SurveyRule rule : c.getRules()) {
        if (!alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
          errors.pushNestedPath(""String_Node_Str"" + i);
          rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
          errors.popNestedPath();
        }
      }
    }
  }
}","private void validateRules(Errors errors,List<SurveyQuestion> questions){
  Set<String> alreadySeenIdentifiers=Sets.newHashSet();
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i);
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
    alreadySeenIdentifiers.add(question.getIdentifier());
  }
  for (int i=0; i < questions.size(); i++) {
    SurveyQuestion question=questions.get(i);
    for (    SurveyRule rule : question.getConstraints().getRules()) {
      if (!alreadySeenIdentifiers.contains(rule.getSkipToTarget())) {
        errors.pushNestedPath(""String_Node_Str"" + i);
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",rule.getSkipToTarget());
        errors.popNestedPath();
      }
    }
  }
}",0.4857651245551601
25809,"private void doValidateConstraints(SurveyQuestion question,Constraints con,Errors errors){
  if (con.getDataType() == null) {
    errors.reject(""String_Node_Str"");
    return;
  }
  UIHint hint=question.getUiHint();
  if (hint == null) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"");
  }
 else   if (!con.getSupportedHints().contains(hint)) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",con.getDataType().name().toLowerCase(),hint.name().toLowerCase());
  }
 else   if (con instanceof MultiValueConstraints) {
    MultiValueConstraints mcon=(MultiValueConstraints)con;
    String hintName=hint.name().toLowerCase();
    if (hint == UIHint.COMBOBOX && (mcon.getAllowMultiple() || !mcon.getAllowOther())) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (mcon.getAllowMultiple() && hint != UIHint.CHECKBOX && hint != UIHint.LIST) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (!mcon.getAllowMultiple() && (hint == UIHint.CHECKBOX || hint == UIHint.LIST)) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
  }
 else   if (con instanceof StringConstraints) {
    StringConstraints scon=(StringConstraints)con;
    if (StringUtils.isNotBlank(scon.getPattern())) {
      try {
        Pattern.compile(scon.getPattern());
      }
 catch (      PatternSyntaxException exception) {
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",scon.getPattern());
      }
    }
  }
}","private void doValidateConstraints(SurveyQuestion question,Constraints con,Errors errors){
  if (con.getDataType() == null) {
    errors.reject(""String_Node_Str"");
    return;
  }
  UIHint hint=question.getUiHint();
  if (hint == null) {
    return;
  }
  if (!con.getSupportedHints().contains(hint)) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",con.getDataType().name().toLowerCase(),hint.name().toLowerCase());
  }
 else   if (con instanceof MultiValueConstraints) {
    MultiValueConstraints mcon=(MultiValueConstraints)con;
    String hintName=hint.name().toLowerCase();
    if (hint == UIHint.COMBOBOX && (mcon.getAllowMultiple() || !mcon.getAllowOther())) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (mcon.getAllowMultiple() && hint != UIHint.CHECKBOX && hint != UIHint.LIST) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (!mcon.getAllowMultiple() && (hint == UIHint.CHECKBOX || hint == UIHint.LIST)) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
  }
 else   if (con instanceof StringConstraints) {
    StringConstraints scon=(StringConstraints)con;
    if (StringUtils.isNotBlank(scon.getPattern())) {
      try {
        Pattern.compile(scon.getPattern());
      }
 catch (      PatternSyntaxException exception) {
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",scon.getPattern());
      }
    }
  }
}",0.978978978978979
25810,"@Override public void validate(Object object,Errors errors){
  Survey survey=(Survey)object;
  if (StringUtils.isBlank(survey.getIdentifier())) {
    errors.reject(""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getStudyKey())) {
    errors.reject(""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getGuid())) {
    errors.reject(""String_Node_Str"");
  }
  for (int i=0; i < survey.getQuestions().size(); i++) {
    SurveyQuestion question=survey.getQuestions().get(i);
    errors.pushNestedPath(""String_Node_Str"" + i);
    doValidateQuestion(question,i,errors);
    errors.popNestedPath();
  }
  validateRules(errors,survey.getQuestions());
}","@Override public void validate(Object object,Errors errors){
  Survey survey=(Survey)object;
  if (StringUtils.isBlank(survey.getIdentifier())) {
    errors.reject(""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getStudyKey())) {
    errors.reject(""String_Node_Str"");
  }
  if (StringUtils.isBlank(survey.getGuid())) {
    errors.reject(""String_Node_Str"");
  }
  for (int i=0; i < survey.getQuestions().size(); i++) {
    SurveyQuestion question=survey.getQuestions().get(i);
    errors.pushNestedPath(""String_Node_Str"" + i);
    doValidateQuestion(question,i,errors);
    errors.popNestedPath();
  }
  if (!errors.hasErrors()) {
    validateRules(errors,survey.getQuestions());
  }
}",0.9740932642487048
25811,"static Map<String,TableDescription> getExistingTables(){
  Map<String,TableDescription> existingTables=new HashMap<String,TableDescription>();
  ListTablesResult listResult=DYNAMO.listTables();
  for (  String tableName : listResult.getTableNames()) {
    DescribeTableResult describeResult=DYNAMO.describeTable(new DescribeTableRequest(tableName));
    TableDescription table=describeResult.getTable();
    existingTables.put(tableName,table);
  }
  return existingTables;
}","static Map<String,TableDescription> getExistingTables(){
  Map<String,TableDescription> existingTables=new HashMap<String,TableDescription>();
  ListTablesResult listResult=DYNAMO.listTables(Integer.MAX_VALUE);
  for (  String tableName : listResult.getTableNames()) {
    DescribeTableResult describeResult=DYNAMO.describeTable(new DescribeTableRequest(tableName));
    TableDescription table=describeResult.getTable();
    existingTables.put(tableName,table);
  }
  return existingTables;
}",0.9824198552223372
25812,"static Map<String,TableDescription> getExistingTables(){
  Map<String,TableDescription> existingTables=new HashMap<String,TableDescription>();
  ListTablesResult listResult=DYNAMO.listTables(Integer.MAX_VALUE);
  for (  String tableName : listResult.getTableNames()) {
    DescribeTableResult describeResult=DYNAMO.describeTable(new DescribeTableRequest(tableName));
    TableDescription table=describeResult.getTable();
    existingTables.put(tableName,table);
  }
  return existingTables;
}","static Map<String,TableDescription> getExistingTables(){
  Map<String,TableDescription> existingTables=new HashMap<String,TableDescription>();
  String lastTableName=null;
  ListTablesResult listTablesResult=DYNAMO.listTables();
  do {
    for (    String tableName : listTablesResult.getTableNames()) {
      DescribeTableResult describeResult=DYNAMO.describeTable(new DescribeTableRequest(tableName));
      TableDescription table=describeResult.getTable();
      existingTables.put(tableName,table);
    }
    lastTableName=listTablesResult.getLastEvaluatedTableName();
    if (lastTableName != null) {
      listTablesResult=DYNAMO.listTables(lastTableName);
    }
  }
 while (lastTableName != null);
  return existingTables;
}",0.7718724448078496
25813,"public Result resetPassword() throws Exception {
  PasswordReset passwordReset=PasswordReset.fromJson(request().body().asJson());
  authenticationService.resetPassword(passwordReset);
  return okResult(""String_Node_Str"");
}","public Result resetPassword() throws Exception {
  PasswordReset passwordReset=PasswordReset.fromJson(requestToJSON(request()));
  authenticationService.resetPassword(passwordReset);
  return okResult(""String_Node_Str"");
}",0.9303370786516854
25814,"public Result requestResetPassword() throws Exception {
  Email email=Email.fromJson(request().body().asJson());
  authenticationService.requestResetPassword(email);
  return okResult(""String_Node_Str"");
}","public Result requestResetPassword() throws Exception {
  Email email=Email.fromJson(requestToJSON(request()));
  authenticationService.requestResetPassword(email);
  return okResult(""String_Node_Str"");
}",0.9242053789731052
25815,"public Result signIn() throws Exception {
  final long start=System.nanoTime();
  UserSession session=getSessionIfItExists();
  if (session != null) {
    setSessionToken(session.getSessionToken());
    return okResult(new UserSessionInfo(session));
  }
  Study study=studyService.getStudyByHostname(getHostname());
  SignIn signIn=SignIn.fromJson(request().body().asJson());
  session=authenticationService.signIn(study,signIn);
  setSessionToken(session.getSessionToken());
  Result result=okResult(new UserSessionInfo(session));
  final long end=System.nanoTime();
  logger.info(""String_Node_Str"" + (end - start));
  return result;
}","public Result signIn() throws Exception {
  final long start=System.nanoTime();
  UserSession session=getSessionIfItExists();
  if (session != null) {
    setSessionToken(session.getSessionToken());
    return okResult(new UserSessionInfo(session));
  }
  Study study=studyService.getStudyByHostname(getHostname());
  SignIn signIn=SignIn.fromJson(requestToJSON(request()));
  session=authenticationService.signIn(study,signIn);
  setSessionToken(session.getSessionToken());
  Result result=okResult(new UserSessionInfo(session));
  final long end=System.nanoTime();
  logger.info(""String_Node_Str"" + (end - start));
  return result;
}",0.975609756097561
25816,"public Result signUp() throws Exception {
  SignUp signUp=SignUp.fromJson(request().body().asJson(),false);
  Study study=studyService.getStudyByHostname(getHostname());
  authenticationService.signUp(signUp,study,true);
  return createdResult(""String_Node_Str"");
}","public Result signUp() throws Exception {
  SignUp signUp=SignUp.fromJson(requestToJSON(request()),false);
  Study study=studyService.getStudyByHostname(getHostname());
  authenticationService.signUp(signUp,study,true);
  return createdResult(""String_Node_Str"");
}",0.941398865784499
25817,"public Result verifyEmail() throws Exception {
  Study study=studyService.getStudyByHostname(getHostname());
  EmailVerification ev=EmailVerification.fromJson(request().body().asJson());
  UserSession session=authenticationService.verifyEmail(study,ev);
  setSessionToken(session.getSessionToken());
  return okResult(new UserSessionInfo(session));
}","public Result verifyEmail() throws Exception {
  Study study=studyService.getStudyByHostname(getHostname());
  EmailVerification ev=EmailVerification.fromJson(requestToJSON(request()));
  UserSession session=authenticationService.verifyEmail(study,ev);
  setSessionToken(session.getSessionToken());
  return okResult(new UserSessionInfo(session));
}",0.9556509298998568
25818,"public boolean setIfNotExist(String code){
  try {
    DynamoHealthCode toSave=new DynamoHealthCode(code);
    mapper.save(toSave);
    return true;
  }
 catch (  ConditionalCheckFailedException e) {
    return false;
  }
}","@Override public boolean setIfNotExist(String code){
  try {
    DynamoHealthCode toSave=new DynamoHealthCode(code);
    mapper.save(toSave);
    return true;
  }
 catch (  ConditionalCheckFailedException e) {
    return false;
  }
}",0.9780701754385964
25819,"public boolean setIfNotExist(String id,String code){
  checkArgument(StringUtils.isNotBlank(id),""String_Node_Str"");
  checkArgument(StringUtils.isNotBlank(code),""String_Node_Str"");
  try {
    DynamoHealthId toSave=new DynamoHealthId();
    toSave.setId(id);
    toSave.setCode(code);
    mapper.save(toSave);
    return true;
  }
 catch (  ConditionalCheckFailedException e) {
    return false;
  }
}","@Override public boolean setIfNotExist(String id,String code){
  checkArgument(StringUtils.isNotBlank(id),""String_Node_Str"");
  checkArgument(StringUtils.isNotBlank(code),""String_Node_Str"");
  try {
    DynamoHealthId toSave=new DynamoHealthId();
    toSave.setId(id);
    toSave.setCode(code);
    mapper.save(toSave);
    return true;
  }
 catch (  ConditionalCheckFailedException e) {
    return false;
  }
}",0.9876847290640394
25820,"public String getCode(String id){
  checkArgument(StringUtils.isNotBlank(id),""String_Node_Str"");
  DynamoHealthId healthId=mapper.load(DynamoHealthId.class,id);
  if (healthId != null) {
    return healthId.getCode();
  }
  return null;
}","@Override public String getCode(String id){
  checkArgument(StringUtils.isNotBlank(id),""String_Node_Str"");
  DynamoHealthId healthId=mapper.load(DynamoHealthId.class,id);
  if (healthId != null) {
    return healthId.getCode();
  }
  return null;
}",0.9794238683127572
25821,"private void deleteUserInStudy(User user,Study study) throws BridgeServiceException {
  checkNotNull(user,""String_Node_Str"");
  checkNotNull(study,""String_Node_Str"");
  final String lock=study.getKey() + ""String_Node_Str"" + user.getId();
  String uuid=null;
  try {
    uuid=lockDao.createLock(User.class,lock);
    Directory directory=getDirectory(study);
    Account account=getUserAccountByEmail(directory,user.getEmail());
    if (account != null) {
      revokeAllConsentRecords(user,study);
      removeAllHealthDataRecords(user,study);
      deleteUserAccount(study,user.getEmail());
    }
  }
  finally {
    if (uuid != null) {
      lockDao.releaseLock(User.class,lock,uuid);
    }
  }
}","private void deleteUserInStudy(User user,Study study) throws BridgeServiceException {
  checkNotNull(user,""String_Node_Str"");
  checkNotNull(study,""String_Node_Str"");
  final String lock=study.getKey() + ""String_Node_Str"" + user.getId();
  String uuid=null;
  try {
    uuid=lockDao.createLock(User.class,lock);
    Directory directory=getDirectory(study);
    Account account=getUserAccountByEmail(directory,user.getEmail());
    if (account != null) {
      revokeAllConsentRecords(user,study);
      removeAllHealthDataRecords(user,study);
      removeHealthCodeAndIdMappings(user);
      deleteUserAccount(study,user.getEmail());
    }
  }
  finally {
    if (uuid != null) {
      lockDao.releaseLock(User.class,lock,uuid);
    }
  }
}",0.9700765483646486
25822,"private void validate(List<SurveyAnswer> answers,Survey survey){
  Map<String,SurveyQuestion> questions=getQuestionsMap(survey);
  for (int i=0; i < answers.size(); i++) {
    SurveyAnswer answer=answers.get(i);
    SurveyAnswerValidator validator=new SurveyAnswerValidator(questions.get(answer.getQuestionGuid()));
    Validate.entityThrowingException(validator,answer);
  }
}","private void validate(List<SurveyAnswer> answers,Survey survey){
  Map<String,SurveyQuestion> questions=getQuestionsMap(survey);
  MapBindingResult errors=new MapBindingResult(Maps.newHashMap(),""String_Node_Str"");
  for (int i=0; i < answers.size(); i++) {
    SurveyAnswer answer=answers.get(i);
    SurveyQuestion question=questions.get(answer.getQuestionGuid());
    SurveyAnswerValidator validator=new SurveyAnswerValidator(question);
    Validate.entity(validator,errors,answer);
  }
  Validate.throwException(errors,survey);
}",0.7040704070407041
25823,"@Override public void validate(Object object,Errors errors){
  SurveyAnswer answer=(SurveyAnswer)object;
  if (answer.getAnsweredOn() == 0L) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",answer.getQuestionGuid());
  }
  if (StringUtils.isBlank(answer.getClient())) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",answer.getQuestionGuid());
  }
  if (StringUtils.isBlank(answer.getQuestionGuid())) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",answer.getQuestionGuid());
  }
  if (answer.isDeclined()) {
    answer.setAnswer(null);
    answer.setAnswers(null);
  }
 else   if (hasNoAnswer(answer)) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"");
  }
 else   if (expectsMultipleValues()) {
    validateType(errors,(MultiValueConstraints)question.getConstraints(),answer.getAnswers());
  }
 else   if (isMultiValue()) {
    validateType(errors,(MultiValueConstraints)question.getConstraints(),answer.getAnswer());
  }
 else {
switch (question.getConstraints().getDataType()) {
case DURATION:
      validateType(errors,(DurationConstraints)question.getConstraints(),answer.getAnswer());
    break;
case STRING:
  validateType(errors,(StringConstraints)question.getConstraints(),answer.getAnswer());
break;
case INTEGER:
validateType(errors,(IntegerConstraints)question.getConstraints(),answer.getAnswer());
break;
case DECIMAL:
validateType(errors,(DecimalConstraints)question.getConstraints(),answer.getAnswer());
break;
case BOOLEAN:
validateType(errors,(BooleanConstraints)question.getConstraints(),answer.getAnswer());
break;
case DATE:
case DATETIME:
validateType(errors,(TimeBasedConstraints)question.getConstraints(),answer.getAnswer());
break;
case TIME:
validateType(errors,(TimeConstraints)question.getConstraints(),answer.getAnswer());
break;
}
}
}","@Override public void validate(Object object,Errors errors){
  SurveyAnswer answer=(SurveyAnswer)object;
  if (question == null) {
    errors.reject(""String_Node_Str"" + answer.getQuestionGuid());
    return;
  }
  errors.pushNestedPath(question.getIdentifier());
  if (answer.getAnsweredOn() == 0L) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",answer.getQuestionGuid());
  }
  if (StringUtils.isBlank(answer.getClient())) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",answer.getQuestionGuid());
  }
  if (StringUtils.isBlank(answer.getQuestionGuid())) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",answer.getQuestionGuid());
  }
  if (answer.isDeclined()) {
    answer.setAnswer(null);
    answer.setAnswers(null);
  }
 else   if (hasNoAnswer(answer)) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"");
  }
 else   if (expectsMultipleValues()) {
    validateType(errors,(MultiValueConstraints)question.getConstraints(),answer.getAnswers());
  }
 else   if (isMultiValue()) {
    validateType(errors,(MultiValueConstraints)question.getConstraints(),answer.getAnswer());
  }
 else {
switch (question.getConstraints().getDataType()) {
case DURATION:
      validateType(errors,(DurationConstraints)question.getConstraints(),answer.getAnswer());
    break;
case STRING:
  validateType(errors,(StringConstraints)question.getConstraints(),answer.getAnswer());
break;
case INTEGER:
validateType(errors,(IntegerConstraints)question.getConstraints(),answer.getAnswer());
break;
case DECIMAL:
validateType(errors,(DecimalConstraints)question.getConstraints(),answer.getAnswer());
break;
case BOOLEAN:
validateType(errors,(BooleanConstraints)question.getConstraints(),answer.getAnswer());
break;
case DATE:
case DATETIME:
validateType(errors,(TimeBasedConstraints)question.getConstraints(),answer.getAnswer());
break;
case TIME:
validateType(errors,(TimeConstraints)question.getConstraints(),answer.getAnswer());
break;
}
}
errors.popNestedPath();
}",0.9522058823529412
25824,"private void doValidateConstraints(SurveyQuestion question,Constraints con,Errors errors){
  if (con.getDataType() == null) {
    errors.reject(""String_Node_Str"");
    return;
  }
  UIHint hint=question.getUiHint();
  if (!con.getSupportedHints().contains(hint)) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",con.getDataType().name().toLowerCase(),hint.name().toLowerCase());
  }
 else   if (con instanceof MultiValueConstraints) {
    MultiValueConstraints mcon=(MultiValueConstraints)con;
    String hintName=hint.name().toLowerCase();
    if (hint == UIHint.COMBOBOX && (mcon.getAllowMultiple() || !mcon.getAllowOther())) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (mcon.getAllowMultiple() && hint != UIHint.CHECKBOX && hint != UIHint.LIST) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (!mcon.getAllowMultiple() && (hint == UIHint.CHECKBOX || hint == UIHint.LIST)) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
  }
 else   if (con instanceof StringConstraints) {
    StringConstraints scon=(StringConstraints)con;
    if (StringUtils.isNotBlank(scon.getPattern())) {
      try {
        Pattern.compile(scon.getPattern());
      }
 catch (      PatternSyntaxException exception) {
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",scon.getPattern());
      }
    }
  }
}","private void doValidateConstraints(SurveyQuestion question,Constraints con,Errors errors){
  if (con.getDataType() == null) {
    errors.reject(""String_Node_Str"");
    return;
  }
  UIHint hint=question.getUiHint();
  if (hint == null) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"");
  }
 else   if (!con.getSupportedHints().contains(hint)) {
    rejectField(errors,""String_Node_Str"",""String_Node_Str"",con.getDataType().name().toLowerCase(),hint.name().toLowerCase());
  }
 else   if (con instanceof MultiValueConstraints) {
    MultiValueConstraints mcon=(MultiValueConstraints)con;
    String hintName=hint.name().toLowerCase();
    if (hint == UIHint.COMBOBOX && (mcon.getAllowMultiple() || !mcon.getAllowOther())) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (mcon.getAllowMultiple() && hint != UIHint.CHECKBOX && hint != UIHint.LIST) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
 else     if (!mcon.getAllowMultiple() && (hint == UIHint.CHECKBOX || hint == UIHint.LIST)) {
      rejectField(errors,""String_Node_Str"",""String_Node_Str"",hintName);
    }
  }
 else   if (con instanceof StringConstraints) {
    StringConstraints scon=(StringConstraints)con;
    if (StringUtils.isNotBlank(scon.getPattern())) {
      try {
        Pattern.compile(scon.getPattern());
      }
 catch (      PatternSyntaxException exception) {
        rejectField(errors,""String_Node_Str"",""String_Node_Str"",scon.getPattern());
      }
    }
  }
}",0.9685704629942548
25825,"public BeanSerializerBase withFilterId(Object object){
  return this;
}","public BeanSerializerBase withFilterId(Object object){
  return null;
}",0.943661971830986
25826,"public Result createSurveyResponse(String surveyGuid,Long surveyVersion) throws Exception {
  UserSession session=getAuthenticatedAndConsentedSession();
  List<SurveyAnswer> answers=deserializeSurveyAnswers();
  SurveyResponse response=responseDao.createSurveyResponse(surveyGuid,surveyVersion,session.getUser().getHealthDataCode(),answers);
  return createdResult(new GuidHolder(response.getGuid()));
}","public Result createSurveyResponse(String surveyGuid,String surveyVersionString) throws Exception {
  UserSession session=getAuthenticatedAndConsentedSession();
  List<SurveyAnswer> answers=deserializeSurveyAnswers();
  Long surveyVersion=DateUtils.convertToMillisFromEpoch(surveyVersionString);
  SurveyResponse response=responseDao.createSurveyResponse(surveyGuid,surveyVersion,session.getUser().getHealthDataCode(),answers);
  return createdResult(new GuidHolder(response.getGuid()));
}",0.899103139013453
25827,"public void validate(Messages messages,SurveyAnswer answer){
  long time=(Long)answer.getAnswer();
  if (!allowFuture && time > (DateUtils.getCurrentMillisFromEpoch() + FIVE_MINUTES)) {
    messages.add(""String_Node_Str"");
  }
}","public void validate(Messages messages,SurveyAnswer answer){
  long time=(Long)answer.getAnswer();
  long now=(DateUtils.getCurrentMillisFromEpoch() + FIVE_MINUTES);
  if (!allowFuture && time > now) {
    messages.add(""String_Node_Str"",time,now);
  }
}",0.8357588357588358
25828,"private Body createSignedDocument(ConsentSignature consent,Study study) throws UnsupportedEncodingException, IOException {
  InputStreamReader isr=new InputStreamReader(study.getConsentAgreement().getInputStream(),""String_Node_Str"");
  String consentAgreementHTML=CharStreams.toString(isr);
  String signingDate=fmt.print(DateUtils.getCurrentMillisFromEpoch());
  String birthdate=fmt.print(DateUtils.convertToMillisFromEpoch(consent.getBirthdate()));
  String html=consentAgreementHTML.replace(""String_Node_Str"",consent.getName());
  html=html.replace(""String_Node_Str"",birthdate);
  html=html.replace(""String_Node_Str"",signingDate);
  Content textBody=new Content().withData(html);
  return new Body().withHtml(textBody);
}","private Body createSignedDocument(ConsentSignature consent,Study study) throws UnsupportedEncodingException, IOException {
  InputStreamReader isr=new InputStreamReader(study.getConsentAgreement().getInputStream(),""String_Node_Str"");
  String consentAgreementHTML=CharStreams.toString(isr);
  String signingDate=fmt.print(DateUtils.getCurrentMillisFromEpoch());
  LocalDate localDate=LocalDate.parse(consent.getBirthdate());
  String birthdate=fmt.print(localDate);
  String html=consentAgreementHTML.replace(""String_Node_Str"",consent.getName());
  html=html.replace(""String_Node_Str"",birthdate);
  html=html.replace(""String_Node_Str"",signingDate);
  Content textBody=new Content().withData(html);
  return new Body().withHtml(textBody);
}",0.9112021857923496
25829,"/** 
 * Backfill user consent from Stormpath.
 */
private int stormpathUserConsent(Study study){
  int count=0;
  Application application=StormpathFactory.createStormpathApplication(stormpathClient);
  AccountList accounts=application.getAccounts();
  for (  Account account : accounts) {
    final CustomData customData=account.getCustomData();
    final String studyKey=study.getKey();
    final String consentedKey=studyKey + BridgeConstants.CUSTOM_DATA_CONSENT_SUFFIX;
    final Object consentedObj=customData.get(consentedKey);
    final String healthIdKey=studyKey + BridgeConstants.CUSTOM_DATA_HEALTH_CODE_SUFFIX;
    final Object healthIdObj=customData.get(healthIdKey);
    if (consentedObj != null && healthIdObj != null) {
      boolean consented=(Boolean)consentedObj;
      if (consented) {
        String healthId=healthCodeEncryptor.decrypt((String)healthIdObj);
        String healthCode=healthCodeService.getHealthCode(healthId);
        StudyConsent studyConsent=studyConsentDao.getConsent(studyKey);
        if (!userConsentDao.hasConsented(healthCode,studyConsent)) {
          String userName=account.getUsername();
          ConsentSignature researchConsent=new ConsentSignature(userName,""String_Node_Str"");
          userConsentDao.giveConsent(healthCode,studyConsent,researchConsent);
          count++;
        }
      }
    }
  }
  return count;
}","/** 
 * Backfill user consent from Stormpath.
 */
private int stormpathUserConsent(Study study){
  int count=0;
  Application application=StormpathFactory.createStormpathApplication(stormpathClient);
  AccountList accounts=application.getAccounts();
  for (  Account account : accounts) {
    final CustomData customData=account.getCustomData();
    final String studyKey=study.getKey();
    final String consentedKey=studyKey + BridgeConstants.CUSTOM_DATA_CONSENT_SUFFIX;
    final Object consentedObj=customData.get(consentedKey);
    final String healthIdKey=studyKey + BridgeConstants.CUSTOM_DATA_HEALTH_CODE_SUFFIX;
    final Object healthIdObj=customData.get(healthIdKey);
    if (consentedObj != null && healthIdObj != null) {
      boolean consented=""String_Node_Str"".equals(((String)consentedObj).toLowerCase());
      if (consented) {
        String healthId=healthCodeEncryptor.decrypt((String)healthIdObj);
        String healthCode=healthCodeService.getHealthCode(healthId);
        StudyConsent studyConsent=studyConsentDao.getConsent(studyKey);
        if (studyConsent == null) {
          studyConsent=new StudyConsent(){
            @Override public String getStudyKey(){
              return studyKey;
            }
            @Override public long getCreatedOn(){
              return 1406325157000L;
            }
            @Override public boolean getActive(){
              return true;
            }
            @Override public String getPath(){
              return ""String_Node_Str"";
            }
            @Override public int getMinAge(){
              return 17;
            }
          }
;
        }
        if (!userConsentDao.hasConsented(healthCode,studyConsent)) {
          String userName=account.getUsername();
          ConsentSignature researchConsent=new ConsentSignature(userName,""String_Node_Str"");
          userConsentDao.giveConsent(healthCode,studyConsent,researchConsent);
          count++;
        }
      }
    }
  }
  return count;
}",0.8115338882282996
25830,"public void setDynamoDbClient(AmazonDynamoDB client){
  DynamoDBMapperConfig mapperConfig=new DynamoDBMapperConfig(SaveBehavior.UPDATE_SKIP_NULL_ATTRIBUTES,ConsistentReads.CONSISTENT,TableNameOverrideFactory.getTableNameOverride(DynamoUserConsent.class));
  mapper=new DynamoDBMapper(client,mapperConfig);
}","public void setDynamoDbClient(AmazonDynamoDB client){
  DynamoDBMapperConfig mapperConfig=new DynamoDBMapperConfig(SaveBehavior.UPDATE_SKIP_NULL_ATTRIBUTES,ConsistentReads.CONSISTENT,TableNameOverrideFactory.getTableNameOverride(DynamoUserConsent.class));
  mapperOld=new DynamoDBMapper(client,mapperConfig);
  mapperConfig=new DynamoDBMapperConfig(SaveBehavior.UPDATE_SKIP_NULL_ATTRIBUTES,ConsistentReads.CONSISTENT,TableNameOverrideFactory.getTableNameOverride(DynamoUserConsent1.class));
  mapper=new DynamoDBMapper(client,mapperConfig);
}",0.7232037691401649
25831,"private ResearchConsent getConsentSignatureOld(String healthCode,StudyConsent studyConsent){
  DynamoUserConsent consent=new DynamoUserConsent(healthCode,studyConsent);
  consent=mapper.load(consent);
  return new ResearchConsent(consent.getName(),consent.getBirthdate());
}","private ResearchConsent getConsentSignatureOld(String healthCode,StudyConsent studyConsent){
  DynamoUserConsent consent=new DynamoUserConsent(healthCode,studyConsent);
  consent=mapperOld.load(consent);
  return new ResearchConsent(consent.getName(),consent.getBirthdate());
}",0.9945553539019965
25832,"private void withdrawConsentOld(String healthCode,StudyConsent studyConsent){
  DynamoUserConsent consentToDelete=new DynamoUserConsent(healthCode,studyConsent);
  consentToDelete.setWithdraw(NOT_WITHDRAW_YET);
  consentToDelete=mapper.load(consentToDelete);
  mapper.delete(consentToDelete);
  DynamoUserConsent consentToWithdraw=new DynamoUserConsent(consentToDelete);
  consentToWithdraw.setWithdraw(DateTime.now(DateTimeZone.UTC).getMillis());
  consentToWithdraw.setVersion(null);
  mapper.save(consentToWithdraw);
}","private void withdrawConsentOld(String healthCode,StudyConsent studyConsent){
  DynamoUserConsent consentToDelete=new DynamoUserConsent(healthCode,studyConsent);
  consentToDelete.setWithdraw(NOT_WITHDRAW_YET);
  consentToDelete=mapperOld.load(consentToDelete);
  mapperOld.delete(consentToDelete);
  DynamoUserConsent consentToWithdraw=new DynamoUserConsent(consentToDelete);
  consentToWithdraw.setWithdraw(DateTime.now(DateTimeZone.UTC).getMillis());
  consentToWithdraw.setVersion(null);
  mapperOld.save(consentToWithdraw);
}",0.9305423406279734
25833,"private void giveConsentOld(String healthCode,StudyConsent studyConsent,ResearchConsent researchConsent){
  try {
    DynamoUserConsent consent=new DynamoUserConsent(healthCode,studyConsent);
    consent.setName(researchConsent.getName());
    consent.setBirthdate(researchConsent.getBirthdate());
    consent.setGive(DateTime.now(DateTimeZone.UTC).getMillis());
    consent.setWithdraw(NOT_WITHDRAW_YET);
    mapper.save(consent);
  }
 catch (  ConditionalCheckFailedException e) {
    throw new ConsentAlreadyExistsException();
  }
}","private void giveConsentOld(String healthCode,StudyConsent studyConsent,ResearchConsent researchConsent){
  try {
    DynamoUserConsent consent=new DynamoUserConsent(healthCode,studyConsent);
    consent.setName(researchConsent.getName());
    consent.setBirthdate(researchConsent.getBirthdate());
    consent.setGive(DateTime.now(DateTimeZone.UTC).getMillis());
    consent.setWithdraw(NOT_WITHDRAW_YET);
    mapperOld.save(consent);
  }
 catch (  ConditionalCheckFailedException e) {
    throw new ConsentAlreadyExistsException();
  }
}",0.9972041006523764
25834,"private boolean hasConsentedOld(String healthCode,StudyConsent studyConsent){
  DynamoUserConsent consent=new DynamoUserConsent(healthCode,studyConsent);
  consent.setWithdraw(NOT_WITHDRAW_YET);
  return mapper.load(consent) != null;
}","private boolean hasConsentedOld(String healthCode,StudyConsent studyConsent){
  DynamoUserConsent consent=new DynamoUserConsent(healthCode,studyConsent);
  consent.setWithdraw(NOT_WITHDRAW_YET);
  return mapperOld.load(consent) != null;
}",0.9936575052854124
25835,"@Before public void before(){
  DynamoTestUtil.clearTable(DynamoUserConsent.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DynamoTestUtil.clearTable(DynamoUserConsent1.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Before public void before(){
  DynamoInitializer.init(""String_Node_Str"");
  DynamoTestUtil.clearTable(DynamoUserConsent.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DynamoTestUtil.clearTable(DynamoUserConsent1.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.940554821664465
25836,"public void setDynamoDbClient(AmazonDynamoDB client){
  DynamoDBMapperConfig mapperConfig=new DynamoDBMapperConfig(SaveBehavior.UPDATE_SKIP_NULL_ATTRIBUTES,ConsistentReads.CONSISTENT,TableNameOverrideFactory.getTableNameOverride(DynamoStudyConsent.class));
  mapper=new DynamoDBMapper(client,mapperConfig);
}","public void setDynamoDbClient(AmazonDynamoDB client){
  DynamoDBMapperConfig mapperConfig=new DynamoDBMapperConfig(SaveBehavior.UPDATE_SKIP_NULL_ATTRIBUTES,ConsistentReads.CONSISTENT,TableNameOverrideFactory.getTableNameOverride(DynamoUserConsent.class));
  mapper=new DynamoDBMapper(client,mapperConfig);
}",0.9853658536585366
25837,"public Result signUp() throws Exception {
  UserSession session=getSession();
  return jsonResult(Boolean.toString(session.isConsent()));
}","public Result signUp() throws Exception {
  UserSession session=getSession();
  return ok(Boolean.toString(session.isConsent()));
}",0.9629629629629628
25838,"public Result send() throws Exception {
  UserSession session=getSession();
  return jsonResult(Boolean.toString(session.isConsent()));
}","public Result send() throws Exception {
  UserSession session=getSession();
  return ok(Boolean.toString(session.isConsent()));
}",0.962406015037594
25839,"public Result withdraw() throws Exception {
  UserSession session=getSession();
  return jsonResult(Boolean.toString(session.isConsent()));
}","public Result withdraw() throws Exception {
  UserSession session=getSession();
  return ok(Boolean.toString(session.isConsent()));
}",0.9635036496350364
25840,"@Override public void signUp(SignUp signUp,Study study) throws BridgeServiceException {
  if (study == null) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (StringUtils.isBlank(study.getStormpathDirectoryHref())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (signUp == null) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (StringUtils.isBlank(signUp.getEmail())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (StringUtils.isBlank(signUp.getPassword())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (!emailValidator.isValid(signUp.getEmail())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
  try {
    Directory directory=null;
    if (config.isProduction()) {
      directory=stormpathClient.getResource(study.getStormpathDirectoryHref(),Directory.class);
    }
 else {
      Application application=StormpathFactory.createStormpathApplication(stormpathClient);
      AccountStore store=application.getDefaultAccountStore();
      directory=stormpathClient.getResource(store.getHref(),Directory.class);
    }
    Account account=stormpathClient.instantiate(Account.class);
    account.setGivenName(""String_Node_Str"");
    account.setSurname(""String_Node_Str"");
    account.setEmail(signUp.getEmail());
    account.setUsername(signUp.getUsername());
    account.setPassword(signUp.getPassword());
    directory.createAccount(account);
  }
 catch (  ResourceException re) {
    throw new BridgeServiceException(re.getDeveloperMessage(),HttpStatus.SC_BAD_REQUEST);
  }
}","@Override public void signUp(SignUp signUp,Study study) throws BridgeServiceException {
  if (study == null) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (StringUtils.isBlank(study.getStormpathDirectoryHref())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (signUp == null) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (StringUtils.isBlank(signUp.getEmail())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (StringUtils.isBlank(signUp.getPassword())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
 else   if (!emailValidator.isValid(signUp.getEmail())) {
    throw new BridgeServiceException(""String_Node_Str"",HttpStatus.SC_BAD_REQUEST);
  }
  try {
    Directory directory=stormpathClient.getResource(study.getStormpathDirectoryHref(),Directory.class);
    Account account=stormpathClient.instantiate(Account.class);
    account.setGivenName(""String_Node_Str"");
    account.setSurname(""String_Node_Str"");
    account.setEmail(signUp.getEmail());
    account.setUsername(signUp.getUsername());
    account.setPassword(signUp.getPassword());
    directory.createAccount(account);
  }
 catch (  ResourceException re) {
    throw new BridgeServiceException(re.getDeveloperMessage(),HttpStatus.SC_BAD_REQUEST);
  }
}",0.8966789667896679
25841,"public DynamoRecord(String key,HealthDataEntry entry){
  this.key=key;
  this.recordId=entry.getRecordId();
  this.startDate=entry.getStartDate();
  this.endDate=entry.getEndDate();
  this.data=entry.getData();
}","public DynamoRecord(String key,String recordId,HealthDataEntry entry){
  this.key=key;
  this.recordId=recordId;
  this.startDate=entry.getStartDate();
  this.endDate=entry.getEndDate();
  this.data=entry.getData();
}",0.9324009324009324
25842,"@Override public void deleteHealthDataEntry(HealthDataKey key,String recordId) throws BridgeServiceException {
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (recordId == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    HealthDataEntry entry=getHealthDataEntry(key,recordId);
    if (entry == null) {
      throw new BridgeServiceException(""String_Node_Str"" + key.toString() + ""String_Node_Str""+ recordId);
    }
    DynamoDBMapper mapper=getUpdateMapper();
    mapper.delete(entry);
  }
 catch (  Exception e) {
    throw new BridgeServiceException(e);
  }
}","@Override public void deleteHealthDataEntry(HealthDataKey key,String recordId) throws BridgeServiceException {
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (recordId == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    HealthDataEntry entry=getHealthDataEntry(key,recordId);
    if (entry == null) {
      throw new BridgeServiceException(""String_Node_Str"" + key.toString() + ""String_Node_Str""+ recordId);
    }
    DynamoDBMapper mapper=getUpdateMapper();
    String anonKey=healthDataKeyToAnonimizedKeyString(key);
    DynamoRecord record=new DynamoRecord(anonKey,recordId,entry);
    mapper.delete(record);
  }
 catch (  Exception e) {
    throw new BridgeServiceException(e);
  }
}",0.9022127052105638
25843,"@Override public void updateHealthDataEntry(HealthDataKey key,HealthDataEntry entry) throws BridgeServiceException {
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (entry == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (entry.getStartDate() == 0L) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (entry.getRecordId() == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    DynamoDBMapper mapper=getUpdateMapper();
    String recordId=healthDataKeyToAnonimizedKeyString(key);
    DynamoRecord record=new DynamoRecord(recordId,entry);
    mapper.save(record);
  }
 catch (  BridgeServiceException e) {
    throw new BridgeServiceException(e);
  }
}","@Override public void updateHealthDataEntry(HealthDataKey key,HealthDataEntry entry) throws BridgeServiceException {
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (entry == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (entry.getStartDate() == 0L) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (entry.getRecordId() == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    DynamoDBMapper mapper=getUpdateMapper();
    String anonKey=healthDataKeyToAnonimizedKeyString(key);
    DynamoRecord record=new DynamoRecord(anonKey,entry);
    mapper.save(record);
  }
 catch (  Exception e) {
    throw new BridgeServiceException(e);
  }
}",0.92049127343245
25844,"@Override public List<HealthDataEntry> getHealthDataByDateRange(HealthDataKey key,Date startDate,Date endDate) throws BridgeServiceException {
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (startDate == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (endDate == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    DynamoDBMapper mapper=getCreateMapper();
    DynamoRecord record=new DynamoRecord(healthDataKeyToAnonimizedKeyString(key));
    AttributeValue endDateWindow=new AttributeValue().withN(Long.toString(endDate.getTime()));
    Condition startDateCondition=new Condition().withComparisonOperator(ComparisonOperator.LE).withAttributeValueList(endDateWindow);
    Map<String,Condition> keyConditions=new HashMap<String,Condition>();
    keyConditions.put(""String_Node_Str"",startDateCondition);
    DynamoDBQueryExpression<DynamoRecord> query=new DynamoDBQueryExpression<DynamoRecord>().withHashKeyValues(record).withRangeKeyConditions(keyConditions);
    List<DynamoRecord> records1=mapper.query(DynamoRecord.class,query);
    AttributeValue startDateWindow=new AttributeValue().withN(Long.toString(startDate.getTime()));
    Condition endDateCondition=new Condition().withComparisonOperator(ComparisonOperator.GE).withAttributeValueList(startDateWindow);
    query=new DynamoDBQueryExpression<DynamoRecord>().withHashKeyValues(record).withRangeKeyCondition(""String_Node_Str"",endDateCondition);
    List<DynamoRecord> records2=mapper.query(DynamoRecord.class,query);
    Set<DynamoRecord> intersection=new HashSet<DynamoRecord>(records1);
    intersection.retainAll(new HashSet<DynamoRecord>(records2));
    return toHealthDataEntries(intersection);
  }
 catch (  BridgeServiceException e) {
    throw new BridgeServiceException(e);
  }
}","@Override public List<HealthDataEntry> getHealthDataByDateRange(HealthDataKey key,Date startDate,Date endDate) throws BridgeServiceException {
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (startDate == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (endDate == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    DynamoDBMapper mapper=getCreateMapper();
    DynamoRecord record=new DynamoRecord(healthDataKeyToAnonimizedKeyString(key));
    AttributeValue endDateWindow=new AttributeValue().withN(Long.toString(endDate.getTime()));
    Condition startDateCondition=new Condition().withComparisonOperator(ComparisonOperator.LE).withAttributeValueList(endDateWindow);
    Map<String,Condition> keyConditions=new HashMap<String,Condition>();
    keyConditions.put(""String_Node_Str"",startDateCondition);
    DynamoDBQueryExpression<DynamoRecord> query=new DynamoDBQueryExpression<DynamoRecord>().withHashKeyValues(record).withRangeKeyConditions(keyConditions);
    List<DynamoRecord> records1=mapper.query(DynamoRecord.class,query);
    AttributeValue startDateWindow=new AttributeValue().withN(Long.toString(startDate.getTime()));
    Condition endDateCondition=new Condition().withComparisonOperator(ComparisonOperator.GE).withAttributeValueList(startDateWindow);
    query=new DynamoDBQueryExpression<DynamoRecord>().withHashKeyValues(record).withRangeKeyCondition(""String_Node_Str"",endDateCondition);
    List<DynamoRecord> records2=mapper.query(DynamoRecord.class,query);
    Set<DynamoRecord> intersection=new HashSet<DynamoRecord>(records1);
    intersection.retainAll(new HashSet<DynamoRecord>(records2));
    return toHealthDataEntries(intersection);
  }
 catch (  Exception e) {
    throw new BridgeServiceException(e);
  }
}",0.9964817320703654
25845,"private String healthDataKeyToAnonimizedKeyString(HealthDataKey key){
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (key.getStudyId() == 0) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (key.getTrackerId() == 0) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (key.getSessionToken() == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  return String.format(""String_Node_Str"",key.getStudyId(),key.getTrackerId(),""String_Node_Str"");
}","private String healthDataKeyToAnonimizedKeyString(HealthDataKey key) throws BridgeServiceException, SynapseException {
  if (key == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (key.getStudyId() == 0) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (key.getTrackerId() == 0) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
 else   if (key.getSessionToken() == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  UserSessionData data=getSynapseClient(key.getSessionToken()).getUserSessionData();
  String ownerId=data.getProfile().getOwnerId();
  if (StringUtils.isBlank(ownerId)) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  String encryptedValue=encryptor.encrypt(ownerId);
  return String.format(""String_Node_Str"",key.getStudyId(),key.getTrackerId(),encryptedValue);
}",0.4642112578179291
25846,"@Override public HealthDataEntry getHealthDataEntry(HealthDataKey key,String recordId) throws BridgeServiceException {
  if (recordId == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    DynamoDBMapper mapper=getCreateMapper();
    DynamoRecord record=new DynamoRecord(healthDataKeyToAnonimizedKeyString(key));
    Condition rangeKeyCondition=new Condition().withComparisonOperator(ComparisonOperator.EQ).withAttributeValueList(new AttributeValue().withS(recordId));
    DynamoDBQueryExpression<DynamoRecord> queryExpression=new DynamoDBQueryExpression<DynamoRecord>().withHashKeyValues(record).withRangeKeyCondition(""String_Node_Str"",rangeKeyCondition);
    List<DynamoRecord> results=mapper.query(DynamoRecord.class,queryExpression);
    if (results.size() > 1) {
      throw new BridgeServiceException(""String_Node_Str"" + recordId + ""String_Node_Str"");
    }
    return (results.isEmpty()) ? null : results.get(0).toEntry();
  }
 catch (  BridgeServiceException e) {
    throw new BridgeServiceException(e);
  }
}","@Override public HealthDataEntry getHealthDataEntry(HealthDataKey key,String recordId) throws BridgeServiceException {
  if (recordId == null) {
    throw new BridgeServiceException(""String_Node_Str"");
  }
  try {
    DynamoDBMapper mapper=getCreateMapper();
    DynamoRecord record=new DynamoRecord(healthDataKeyToAnonimizedKeyString(key));
    Condition rangeKeyCondition=new Condition().withComparisonOperator(ComparisonOperator.EQ).withAttributeValueList(new AttributeValue().withS(recordId));
    DynamoDBQueryExpression<DynamoRecord> queryExpression=new DynamoDBQueryExpression<DynamoRecord>().withHashKeyValues(record).withRangeKeyCondition(""String_Node_Str"",rangeKeyCondition);
    List<DynamoRecord> results=mapper.query(DynamoRecord.class,queryExpression);
    if (results.size() > 1) {
      throw new BridgeServiceException(""String_Node_Str"" + recordId + ""String_Node_Str"");
    }
    return (results.isEmpty()) ? null : results.get(0).toEntry();
  }
 catch (  Exception e) {
    throw new BridgeServiceException(e);
  }
}",0.9658817876021144
25847,"/** 
 * Handler for when an image failed to load.
 * @param cacheKey The cache key that is associated with the image request.
 */
private void onGetImageError(String cacheKey,VolleyError error){
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  if (request != null) {
    batchResponse(cacheKey,request,error);
  }
}","/** 
 * Handler for when an image failed to load.
 * @param cacheKey The cache key that is associated with the image request.
 */
private void onGetImageError(String cacheKey,VolleyError error){
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  request.setError(error);
  if (request != null) {
    batchResponse(cacheKey,request);
  }
}",0.9521044992743106
25848,"/** 
 * Starts the runnable for batched delivery of responses if it is not already started.
 * @param cacheKey The cacheKey of the response being delivered.
 * @param request The BatchedImageRequest to be delivered.
 * @param error The volley error associated with the request (if applicable).
 */
private void batchResponse(String cacheKey,BatchedImageRequest request,final VolleyError error){
  mBatchedResponses.put(cacheKey,request);
  if (mRunnable == null) {
    mRunnable=new Runnable(){
      @Override public void run(){
        for (        BatchedImageRequest bir : mBatchedResponses.values()) {
          for (          ImageContainer container : bir.mContainers) {
            if (container.mListener == null) {
              continue;
            }
            if (error == null) {
              container.mBitmap=bir.mResponseBitmap;
              container.mListener.onResponse(container,false);
            }
 else {
              container.mListener.onErrorResponse(error);
            }
          }
        }
        mBatchedResponses.clear();
        mRunnable=null;
      }
    }
;
    mHandler.postDelayed(mRunnable,mBatchResponseDelayMs);
  }
}","/** 
 * Starts the runnable for batched delivery of responses if it is not already started.
 * @param cacheKey The cacheKey of the response being delivered.
 * @param request The BatchedImageRequest to be delivered.
 * @param error The volley error associated with the request (if applicable).
 */
private void batchResponse(String cacheKey,BatchedImageRequest request){
  mBatchedResponses.put(cacheKey,request);
  if (mRunnable == null) {
    mRunnable=new Runnable(){
      @Override public void run(){
        for (        BatchedImageRequest bir : mBatchedResponses.values()) {
          for (          ImageContainer container : bir.mContainers) {
            if (container.mListener == null) {
              continue;
            }
            if (bir.getError() == null) {
              container.mBitmap=bir.mResponseBitmap;
              container.mListener.onResponse(container,false);
            }
 else {
              container.mListener.onErrorResponse(bir.getError());
            }
          }
        }
        mBatchedResponses.clear();
        mRunnable=null;
      }
    }
;
    mHandler.postDelayed(mRunnable,mBatchResponseDelayMs);
  }
}",0.9733676975945016
25849,"/** 
 * Handler for when an image was successfully loaded.
 * @param cacheKey The cache key that is associated with the image request.
 * @param response The bitmap that was returned from the network.
 */
private void onGetImageSuccess(String cacheKey,Bitmap response){
  mCache.putBitmap(cacheKey,response);
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  if (request != null) {
    request.mResponseBitmap=response;
    batchResponse(cacheKey,request,null);
  }
}","/** 
 * Handler for when an image was successfully loaded.
 * @param cacheKey The cache key that is associated with the image request.
 * @param response The bitmap that was returned from the network.
 */
private void onGetImageSuccess(String cacheKey,Bitmap response){
  mCache.putBitmap(cacheKey,response);
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  if (request != null) {
    request.mResponseBitmap=response;
    batchResponse(cacheKey,request);
  }
}",0.9948186528497408
25850,"@Override public void run(){
  for (  BatchedImageRequest bir : mBatchedResponses.values()) {
    for (    ImageContainer container : bir.mContainers) {
      if (container.mListener == null) {
        continue;
      }
      if (error == null) {
        container.mBitmap=bir.mResponseBitmap;
        container.mListener.onResponse(container,false);
      }
 else {
        container.mListener.onErrorResponse(error);
      }
    }
  }
  mBatchedResponses.clear();
  mRunnable=null;
}","@Override public void run(){
  for (  BatchedImageRequest bir : mBatchedResponses.values()) {
    for (    ImageContainer container : bir.mContainers) {
      if (container.mListener == null) {
        continue;
      }
      if (bir.getError() == null) {
        container.mBitmap=bir.mResponseBitmap;
        container.mListener.onResponse(container,false);
      }
 else {
        container.mListener.onErrorResponse(bir.getError());
      }
    }
  }
  mBatchedResponses.clear();
  mRunnable=null;
}",0.9615384615384616
25851,"/** 
 * Handler for when an image failed to load.
 * @param cacheKey The cache key that is associated with the image request.
 */
private void onGetImageError(String cacheKey,VolleyError error){
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  if (request != null) {
    batchResponse(cacheKey,request,error);
  }
}","/** 
 * Handler for when an image failed to load.
 * @param cacheKey The cache key that is associated with the image request.
 */
private void onGetImageError(String cacheKey,VolleyError error){
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  request.setError(error);
  if (request != null) {
    batchResponse(cacheKey,request);
  }
}",0.9521044992743106
25852,"/** 
 * Starts the runnable for batched delivery of responses if it is not already started.
 * @param cacheKey The cacheKey of the response being delivered.
 * @param request The BatchedImageRequest to be delivered.
 * @param error The volley error associated with the request (if applicable).
 */
private void batchResponse(String cacheKey,BatchedImageRequest request,final VolleyError error){
  mBatchedResponses.put(cacheKey,request);
  if (mRunnable == null) {
    mRunnable=new Runnable(){
      @Override public void run(){
        for (        BatchedImageRequest bir : mBatchedResponses.values()) {
          for (          ImageContainer container : bir.mContainers) {
            if (container.mListener == null) {
              continue;
            }
            if (error == null) {
              container.mBitmap=bir.mResponseBitmap;
              container.mListener.onResponse(container,false);
            }
 else {
              container.mListener.onErrorResponse(error);
            }
          }
        }
        mBatchedResponses.clear();
        mRunnable=null;
      }
    }
;
    mHandler.postDelayed(mRunnable,mBatchResponseDelayMs);
  }
}","/** 
 * Starts the runnable for batched delivery of responses if it is not already started.
 * @param cacheKey The cacheKey of the response being delivered.
 * @param request The BatchedImageRequest to be delivered.
 * @param error The volley error associated with the request (if applicable).
 */
private void batchResponse(String cacheKey,BatchedImageRequest request){
  mBatchedResponses.put(cacheKey,request);
  if (mRunnable == null) {
    mRunnable=new Runnable(){
      @Override public void run(){
        for (        BatchedImageRequest bir : mBatchedResponses.values()) {
          for (          ImageContainer container : bir.mContainers) {
            if (container.mListener == null) {
              continue;
            }
            if (bir.getError() == null) {
              container.mBitmap=bir.mResponseBitmap;
              container.mListener.onResponse(container,false);
            }
 else {
              container.mListener.onErrorResponse(bir.getError());
            }
          }
        }
        mBatchedResponses.clear();
        mRunnable=null;
      }
    }
;
    mHandler.postDelayed(mRunnable,mBatchResponseDelayMs);
  }
}",0.9733676975945016
25853,"/** 
 * Handler for when an image was successfully loaded.
 * @param cacheKey The cache key that is associated with the image request.
 * @param response The bitmap that was returned from the network.
 */
private void onGetImageSuccess(String cacheKey,Bitmap response){
  mCache.putBitmap(cacheKey,response);
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  if (request != null) {
    request.mResponseBitmap=response;
    batchResponse(cacheKey,request,null);
  }
}","/** 
 * Handler for when an image was successfully loaded.
 * @param cacheKey The cache key that is associated with the image request.
 * @param response The bitmap that was returned from the network.
 */
private void onGetImageSuccess(String cacheKey,Bitmap response){
  mCache.putBitmap(cacheKey,response);
  BatchedImageRequest request=mInFlightRequests.remove(cacheKey);
  if (request != null) {
    request.mResponseBitmap=response;
    batchResponse(cacheKey,request);
  }
}",0.9948186528497408
25854,"@Override public void run(){
  for (  BatchedImageRequest bir : mBatchedResponses.values()) {
    for (    ImageContainer container : bir.mContainers) {
      if (container.mListener == null) {
        continue;
      }
      if (error == null) {
        container.mBitmap=bir.mResponseBitmap;
        container.mListener.onResponse(container,false);
      }
 else {
        container.mListener.onErrorResponse(error);
      }
    }
  }
  mBatchedResponses.clear();
  mRunnable=null;
}","@Override public void run(){
  for (  BatchedImageRequest bir : mBatchedResponses.values()) {
    for (    ImageContainer container : bir.mContainers) {
      if (container.mListener == null) {
        continue;
      }
      if (bir.getError() == null) {
        container.mBitmap=bir.mResponseBitmap;
        container.mListener.onResponse(container,false);
      }
 else {
        container.mListener.onErrorResponse(bir.getError());
      }
    }
  }
  mBatchedResponses.clear();
  mRunnable=null;
}",0.9615384615384616
25855,"@SuppressWarnings(""String_Node_Str"") static void setConnectionParametersForRequest(HttpURLConnection connection,Request<?> request) throws IOException, AuthFailureError {
switch (request.getMethod()) {
case Method.DEPRECATED_GET_OR_POST:
    byte[] postBody=request.getPostBody();
  if (postBody != null) {
    connection.setDoOutput(true);
    connection.setRequestMethod(""String_Node_Str"");
    connection.addRequestProperty(HEADER_CONTENT_TYPE,request.getPostBodyContentType());
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(postBody);
    out.close();
  }
break;
case Method.GET:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.DELETE:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.POST:
addBodyIfExists(connection,request);
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.PUT:
addBodyIfExists(connection,request);
connection.setRequestMethod(""String_Node_Str"");
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","@SuppressWarnings(""String_Node_Str"") static void setConnectionParametersForRequest(HttpURLConnection connection,Request<?> request) throws IOException, AuthFailureError {
switch (request.getMethod()) {
case Method.DEPRECATED_GET_OR_POST:
    byte[] postBody=request.getPostBody();
  if (postBody != null) {
    connection.setDoOutput(true);
    connection.setRequestMethod(""String_Node_Str"");
    connection.addRequestProperty(HEADER_CONTENT_TYPE,request.getPostBodyContentType());
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(postBody);
    out.close();
  }
break;
case Method.GET:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.DELETE:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.POST:
connection.setRequestMethod(""String_Node_Str"");
addBodyIfExists(connection,request);
break;
case Method.PUT:
connection.setRequestMethod(""String_Node_Str"");
addBodyIfExists(connection,request);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.9079578139980824
25856,"/** 
 * @param urlRewriter Rewriter to use for request URLs
 */
public HurlStack(UrlRewriter urlRewriter){
  mUrlRewriter=urlRewriter;
}","/** 
 * @param urlRewriter Rewriter to use for request URLs
 * @param sslSocketFactory SSL factory to use for HTTPS connections
 */
public HurlStack(UrlRewriter urlRewriter,SSLSocketFactory sslSocketFactory){
  mUrlRewriter=urlRewriter;
  mSslSocketFactory=sslSocketFactory;
}",0.6601941747572816
25857,"/** 
 * Opens an   {@link HttpURLConnection} with parameters.
 * @param url
 * @return an open connection
 * @throws IOException
 */
private HttpURLConnection openConnection(URL url,Request<?> request) throws IOException {
  HttpURLConnection connection=(HttpURLConnection)url.openConnection();
  int timeoutMs=request.getTimeoutMs();
  connection.setConnectTimeout(timeoutMs);
  connection.setReadTimeout(timeoutMs);
  connection.setUseCaches(false);
  connection.setDoInput(true);
  return connection;
}","/** 
 * Opens an   {@link HttpURLConnection} with parameters.
 * @param url
 * @return an open connection
 * @throws IOException
 */
private HttpURLConnection openConnection(URL url,Request<?> request) throws IOException {
  HttpURLConnection connection=(HttpURLConnection)url.openConnection();
  int timeoutMs=request.getTimeoutMs();
  connection.setConnectTimeout(timeoutMs);
  connection.setReadTimeout(timeoutMs);
  connection.setUseCaches(false);
  connection.setDoInput(true);
  if (""String_Node_Str"".equals(url.getProtocol()) && mSslSocketFactory != null) {
    ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);
  }
  return connection;
}",0.8286445012787724
25858,"@SuppressWarnings(""String_Node_Str"") static void setConnectionParametersForRequest(HttpURLConnection connection,Request<?> request) throws IOException, AuthFailureError {
switch (request.getMethod()) {
case Method.DEPRECATED_GET_OR_POST:
    byte[] postBody=request.getPostBody();
  if (postBody != null) {
    connection.setDoOutput(true);
    connection.setRequestMethod(""String_Node_Str"");
    connection.addRequestProperty(HEADER_CONTENT_TYPE,request.getPostBodyContentType());
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(postBody);
    out.close();
  }
break;
case Method.GET:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.DELETE:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.POST:
addBodyIfExists(connection,request);
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.PUT:
addBodyIfExists(connection,request);
connection.setRequestMethod(""String_Node_Str"");
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","@SuppressWarnings(""String_Node_Str"") static void setConnectionParametersForRequest(HttpURLConnection connection,Request<?> request) throws IOException, AuthFailureError {
switch (request.getMethod()) {
case Method.DEPRECATED_GET_OR_POST:
    byte[] postBody=request.getPostBody();
  if (postBody != null) {
    connection.setDoOutput(true);
    connection.setRequestMethod(""String_Node_Str"");
    connection.addRequestProperty(HEADER_CONTENT_TYPE,request.getPostBodyContentType());
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(postBody);
    out.close();
  }
break;
case Method.GET:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.DELETE:
connection.setRequestMethod(""String_Node_Str"");
break;
case Method.POST:
connection.setRequestMethod(""String_Node_Str"");
addBodyIfExists(connection,request);
break;
case Method.PUT:
connection.setRequestMethod(""String_Node_Str"");
addBodyIfExists(connection,request);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.9079578139980824
25859,"/** 
 * @param urlRewriter Rewriter to use for request URLs
 */
public HurlStack(UrlRewriter urlRewriter){
  mUrlRewriter=urlRewriter;
}","/** 
 * @param urlRewriter Rewriter to use for request URLs
 * @param sslSocketFactory SSL factory to use for HTTPS connections
 */
public HurlStack(UrlRewriter urlRewriter,SSLSocketFactory sslSocketFactory){
  mUrlRewriter=urlRewriter;
  mSslSocketFactory=sslSocketFactory;
}",0.6601941747572816
25860,"/** 
 * Opens an   {@link HttpURLConnection} with parameters.
 * @param url
 * @return an open connection
 * @throws IOException
 */
private HttpURLConnection openConnection(URL url,Request<?> request) throws IOException {
  HttpURLConnection connection=(HttpURLConnection)url.openConnection();
  int timeoutMs=request.getTimeoutMs();
  connection.setConnectTimeout(timeoutMs);
  connection.setReadTimeout(timeoutMs);
  connection.setUseCaches(false);
  connection.setDoInput(true);
  return connection;
}","/** 
 * Opens an   {@link HttpURLConnection} with parameters.
 * @param url
 * @return an open connection
 * @throws IOException
 */
private HttpURLConnection openConnection(URL url,Request<?> request) throws IOException {
  HttpURLConnection connection=(HttpURLConnection)url.openConnection();
  int timeoutMs=request.getTimeoutMs();
  connection.setConnectTimeout(timeoutMs);
  connection.setReadTimeout(timeoutMs);
  connection.setUseCaches(false);
  connection.setDoInput(true);
  if (""String_Node_Str"".equals(url.getProtocol()) && mSslSocketFactory != null) {
    ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);
  }
  return connection;
}",0.8286445012787724
25861,"@Override public boolean onQueryTextChange(String text){
  if (text.isEmpty() || disableAutoComplete) {
    disableAutoComplete=false;
    return false;
  }
 else   if (text.length() < 3) {
    setAutoCompleteAdapterIcon(recentSearchIconResourceId);
    loadSavedSearches();
  }
 else {
    setAutoCompleteAdapterIcon(autoCompleteIconResourceId);
    fetchAutoCompleteSuggestions(text);
  }
  return false;
}","@Override public boolean onQueryTextChange(String text){
  if (text.isEmpty() || disableAutoComplete) {
    setAutoCompleteAdapterIcon(autoCompleteIconResourceId);
    disableAutoComplete=false;
    return false;
  }
 else   if (text.length() < 3) {
    setAutoCompleteAdapterIcon(recentSearchIconResourceId);
    loadSavedSearches();
  }
 else {
    setAutoCompleteAdapterIcon(autoCompleteIconResourceId);
    fetchAutoCompleteSuggestions(text);
  }
  return false;
}",0.9315068493150684
25862,"public void loadData(String fileName){
  try {
    IndexTask indexTask=this.client.createIndex(this.policy,this.namespace,FLIGHTS,FL_DATE_INDEX,FL_DATE_BIN,IndexType.NUMERIC);
    indexTask.waitTillComplete();
    log.info(""String_Node_Str"");
    File file=new File(fileName);
    if (file.exists()) {
      if (file.isDirectory()) {
        File[] csvFiles=file.listFiles();
        for (        final File aFile : csvFiles) {
          loadFile(aFile);
        }
      }
 else {
        loadFile(file);
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + fileName,e);
  }
}","public void loadData(String fileName){
  try {
    IndexTask indexTask=this.client.createIndex(this.policy,this.namespace,FLIGHTS,FL_DATE_INDEX,FL_DATE_BIN,IndexType.NUMERIC);
    indexTask.waitTillComplete();
    log.info(""String_Node_Str"");
    File file=new File(fileName);
    if (file.exists()) {
      if (file.isDirectory()) {
        File[] csvFiles=file.listFiles();
        for (        final File aFile : csvFiles) {
          if (aFile.getName().startsWith(""String_Node_Str""))           continue;
          loadFile(aFile);
        }
      }
 else {
        loadFile(file);
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + fileName,e);
  }
}",0.936768149882904
25863,"public void performMove(int x,int y){
  if (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O) {
    this.board.set(this.turn,x,y);
  }
  if (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O) {
    this.switchTurns();
  }
}","public void performMove(int x,int y){
  if (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O) {
    boolean res=this.board.set(this.turn,x,y);
    if (res && (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O)) {
      this.switchTurns();
    }
  }
}",0.5784832451499118
25864,"public void performMove(int x,int y){
  if (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O) {
    this.board.set(this.turn,x,y);
  }
  if (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O) {
    this.switchTurns();
  }
}","public void performMove(int x,int y){
  if (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O) {
    boolean res=this.board.set(this.turn,x,y);
    if (res && (this.gameState == GameState.TURN_X || this.gameState == GameState.TURN_O)) {
      this.switchTurns();
    }
  }
}",0.5784832451499118
25865,"@Override public void prefChanged(String key){
switch (key) {
case Prefs.FILT_LANG:
case Prefs.SORT_CARD:
    adapter.rebuild();
  break;
}
}","@Override public void prefChanged(String key){
switch (key) {
case Prefs.FILT_LANG:
case Prefs.SORT_CARD:
    if (adapter != null)     adapter.rebuild();
  break;
}
}",0.9185667752442996
25866,"@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  if (card_list != null) {
    empty.setVisibility(View.GONE);
    loading.setVisibility(View.GONE);
    card_list.setEmptyView(loading);
  }
  adapter.changeCursor(null);
  CursorLoader c=new CursorLoader(getActivity());
  c.setUri(Provider.URI_CARD_ALL);
  c.setProjection(AdapterCardsFilter.COLS_USED);
  String sel=""String_Node_Str"";
  SharedPreferences pref=PreferenceManager.getDefaultSharedPreferences(getActivity());
  ArrayList<CharSequence> sel_args=new ArrayList<>();
  String[] sort_col=getResources().getStringArray(R.array.sort_card_col);
  String[] sort_pref=pref.getString(Prefs.SORT_CARD,""String_Node_Str"").split(""String_Node_Str"");
  String sort=""String_Node_Str"";
  for (  String s : sort_pref) {
    int i=Integer.parseInt(s);
    if (i == 1)     break;
    sort+=sort_col[i] + ""String_Node_Str"";
  }
  c.setSortOrder(sort + sort_col[1]);
  String curSel=pref.getString(""String_Node_Str"",""String_Node_Str"");
  if (0 < curSel.length())   sel+=""String_Node_Str"" + TableCard._SET_ID + ""String_Node_Str""+ curSel+ ""String_Node_Str"";
  boolean filt_curse=pref.getBoolean(""String_Node_Str"",true);
  if (!filt_curse) {
    sel+=""String_Node_Str"" + TableCard._META_CURSER + ""String_Node_Str"";
    sel_args.add(""String_Node_Str"");
  }
  sel=(sel + ""String_Node_Str"" + Prefs.filt_lang).substring(5);
  c.setSelection(sel);
  String[] sel_args_final=new String[sel_args.size()];
  for (int i=0; i < sel_args.size(); i++)   sel_args_final[i]=sel_args.get(i).toString();
  c.setSelectionArgs(sel_args_final);
  return c;
}","@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  if (card_list != null) {
    empty.setVisibility(View.GONE);
    loading.setVisibility(View.GONE);
    card_list.setEmptyView(loading);
  }
  adapter.changeCursor(null);
  CursorLoader c=new CursorLoader(getActivity());
  c.setUri(Provider.URI_CARD_ALL);
  c.setProjection(AdapterCardsFilter.COLS_USED);
  SharedPreferences pref=PreferenceManager.getDefaultSharedPreferences(getActivity());
  ArrayList<CharSequence> sel_args=new ArrayList<>();
  String[] sort_col=getResources().getStringArray(R.array.sort_card_col);
  String[] sort_pref=pref.getString(Prefs.SORT_CARD,""String_Node_Str"").split(""String_Node_Str"");
  String sort=""String_Node_Str"";
  for (  String s : sort_pref) {
    int i=Integer.parseInt(s);
    if (i == 1)     break;
    sort+=sort_col[i] + ""String_Node_Str"";
  }
  c.setSortOrder(sort + sort_col[1]);
  String curSel=pref.getString(Prefs.FILT_SET,""String_Node_Str"");
  String sel=(curSel.length() == 0) ? TableCard._SET_ID + ""String_Node_Str"" : TableCard._SET_ID + ""String_Node_Str"" + curSel+ ""String_Node_Str"";
  boolean filt_curse=pref.getBoolean(Prefs.FILT_CURSE,true);
  if (!filt_curse) {
    sel+=""String_Node_Str"" + TableCard._META_CURSER + ""String_Node_Str"";
    sel_args.add(""String_Node_Str"");
  }
  sel=sel + ""String_Node_Str"" + Prefs.filt_lang;
  c.setSelection(sel);
  String[] sel_args_final=new String[sel_args.size()];
  for (int i=0; i < sel_args.size(); i++)   sel_args_final[i]=sel_args.get(i).toString();
  c.setSelectionArgs(sel_args_final);
  return c;
}",0.9001895135818067
25867,"@Override public void onReceive(Context context,Intent intent){
  shuffler=null;
  int res=intent.getIntExtra(SupplyShuffler.MSG_RES,-100);
  String msg;
switch (res) {
case SupplyShuffler.RES_OK:
    Intent showSupply=new Intent(getActivity(),ActivitySupply.class);
  showSupply.putExtra(ActivitySupply.PARAM_HISTORY_ID,intent.getLongExtra(SupplyShuffler.MSG_SUPPLY_ID,-1));
startActivity(showSupply);
return;
case SupplyShuffler.RES_MORE:
msg=String.format(getString(R.string.more),intent.getStringExtra(SupplyShuffler.MSG_SHORT));
Toast.makeText(getActivity(),msg,Toast.LENGTH_LONG).show();
return;
case SupplyShuffler.RES_MORE_K:
msg=String.format(getString(R.string.more_k),intent.getStringExtra(SupplyShuffler.MSG_SHORT));
Toast.makeText(getActivity(),msg,Toast.LENGTH_LONG).show();
return;
case SupplyShuffler.RES_NO_YW:
Toast.makeText(getActivity(),R.string.yw_no_bane,Toast.LENGTH_LONG).show();
return;
default :
}
}","@Override public void onReceive(Context context,Intent intent){
  shuffler=null;
  int res=intent.getIntExtra(SupplyShuffler.MSG_RES,-100);
  String msg;
switch (res) {
case SupplyShuffler.RES_OK:
    Intent showSupply=new Intent(getActivity(),ActivitySupply.class);
  showSupply.putExtra(ActivitySupply.PARAM_HISTORY_ID,intent.getLongExtra(SupplyShuffler.MSG_SUPPLY_ID,-1));
startActivity(showSupply);
return;
case SupplyShuffler.RES_MORE:
msg=String.format(getString(R.string.more_k),intent.getStringExtra(SupplyShuffler.MSG_SHORT));
Toast.makeText(getActivity(),msg,Toast.LENGTH_LONG).show();
return;
case SupplyShuffler.RES_NO_YW:
Toast.makeText(getActivity(),R.string.yw_no_bane,Toast.LENGTH_LONG).show();
return;
default :
}
}",0.831623415811708
25868,"@Override public boolean onOptionsItemSelected(MenuItem item){
  if (navToggle.onOptionsItemSelected(item))   return true;
switch (item.getItemId()) {
case R.id.action_toggle_all:
    ((FragmentPicker)active).toggleAll();
  return true;
case R.id.action_submit:
return true;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  if (navToggle.onOptionsItemSelected(item))   return true;
switch (item.getItemId()) {
case R.id.action_toggle_all:
    ((FragmentPicker)active).toggleAll();
  return true;
case R.id.action_submit:
shuffler.startShuffle();
return true;
}
return super.onOptionsItemSelected(item);
}",0.962406015037594
25869,"/** 
 * Start a shuffle and register this receiver. Also cancels any shuffles in progress. 
 */
public void startShuffle(Long... cards){
  if (cards == null)   cards=new Long[0];
  cancelShuffle();
  SharedPreferences pref=PreferenceManager.getDefaultSharedPreferences(getActivity());
  shuffler=new SupplyShuffler(pref.getInt(Prefs.LIMIT_SUPPLY,10),pref.getInt(Prefs.LIMIT_EVENTS,2));
  shuffler.execute(cards);
}","/** 
 * Start a shuffle and register this receiver. Also cancels any shuffles in progress. 
 */
public void startShuffle(){
  cancelShuffle();
  shuffler=new SupplyShuffler();
  shuffler.execute();
}",0.6492659053833605
25870,"@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (data == null) {
    list.setAdapter(adapter);
    return;
  }
  final int col_set_id=data.getColumnIndex(CardDb._SET_ID);
  final int col_lang=data.getColumnIndex(CardDb._LANG);
  int set_id;
  String[] options;
  ArrayList<String> available=new ArrayList<>(languages.size());
  data.moveToFirst();
  set_id=data.getInt(col_set_id);
  available.add(""String_Node_Str"");
  available.add(data.getString(col_lang));
  while (data.moveToNext()) {
    if (set_id != data.getInt(col_set_id)) {
      options=new String[available.size()];
      available.toArray(options);
      setMap.get(set_id).opt=options;
      set_id=data.getInt(col_set_id);
      available.clear();
      available.add(""String_Node_Str"");
    }
    available.add(data.getString(col_lang));
  }
  options=new String[available.size()];
  available.toArray(options);
  setMap.get(set_id).opt=options;
  list.setAdapter(adapter);
  data.close();
}","@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (data == null) {
    list.setAdapter(adapter);
    return;
  }
  final int col_set_id=data.getColumnIndex(CardDb._SET_ID);
  final int col_lang=data.getColumnIndex(CardDb._LANG);
  int set_id;
  String[] options;
  ArrayList<String> available=new ArrayList<>(languages.size());
  data.moveToFirst();
  set_id=data.getInt(col_set_id);
  available.add(""String_Node_Str"");
  available.add(data.getString(col_lang));
  while (data.moveToNext()) {
    if (set_id != data.getInt(col_set_id)) {
      options=new String[available.size()];
      available.toArray(options);
      setMap.get(set_id).opt=options;
      set_id=data.getInt(col_set_id);
      available.clear();
      available.add(""String_Node_Str"");
    }
    available.add(data.getString(col_lang));
  }
  options=new String[available.size()];
  available.toArray(options);
  setMap.get(set_id).opt=options;
  list.setAdapter(adapter);
}",0.9918450560652396
25871,"@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  CursorLoader c=new CursorLoader(getActivity());
switch (id) {
case LoaderId.MARKET_SHUFFLE:
    c.setUri(Provider.URI_CARD_DATA);
  Bundle fragArgs=getArguments();
HashSet<Long> supply=new HashSet<>();
long[] supply_arr=null;
if (fragArgs != null) supply_arr=fragArgs.getLongArray(PARAM_SUPPLY);
if (supply_arr != null) for (long cardID : supply_arr) supply.add(cardID);
Long[] deck_arr=FragmentPicker.loadSelections(getActivity());
ArrayList<Long> deck=new ArrayList<>();
if (deck_arr != null) {
deck=new ArrayList<>(deck_arr.length);
for (long card : deck_arr) if (card != CardDb.ID_BLACK_MARKET && !supply.contains(card)) deck.add(card);
}
c.setProjection(new String[]{CardDb._ID});
String sel=""String_Node_Str"";
String[] selArgs=new String[deck.size()];
for (int i=0; i < deck.size(); i++) {
sel+=""String_Node_Str"";
selArgs[i]=""String_Node_Str"" + deck.get(i);
}
if (0 < sel.length()) sel=CardDb._ID + ""String_Node_Str"" + sel.substring(1)+ ""String_Node_Str"";
c.setSelection(sel);
c.setSelectionArgs(selArgs);
c.setSortOrder(""String_Node_Str"");
return c;
case LoaderId.MARKET_SHOW:
c.setUri(Provider.URI_CARD_ALL);
c.setProjection(AdapterCards.COLS_USED);
c.setSortOrder(App.sortOrder);
transId=App.transId;
if (choices == null || choices.length == 0) {
c.setSelection(CardDb._ID + ""String_Node_Str"");
c.setSelectionArgs(new String[]{""String_Node_Str""});
return c;
}
String cardSel=""String_Node_Str"";
for (long ignored : choices) cardSel+=""String_Node_Str"";
cardSel=CardDb._ID + ""String_Node_Str"" + cardSel.substring(1)+ ""String_Node_Str"";
c.setSelection(""String_Node_Str"" + cardSel + ""String_Node_Str""+ App.transFilter);
String[] strChoices=new String[choices.length];
for (int i=0; i < choices.length; i++) strChoices[i]=""String_Node_Str"" + choices[i];
c.setSelectionArgs(strChoices);
updateView();
return c;
}
return null;
}","@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  CursorLoader c=new CursorLoader(getActivity());
switch (id) {
case LoaderId.MARKET_SHUFFLE:
    c.setUri(Provider.URI_CARD_DATA);
  Bundle fragArgs=getArguments();
HashSet<Long> supply=new HashSet<>();
long[] supply_arr=null;
if (fragArgs != null) supply_arr=fragArgs.getLongArray(PARAM_SUPPLY);
if (supply_arr != null) for (long cardID : supply_arr) supply.add(cardID);
Long[] deck_arr=FragmentPicker.loadSelections(getActivity());
ArrayList<Long> deck=new ArrayList<>();
if (deck_arr != null) {
deck=new ArrayList<>(deck_arr.length);
for (long card : deck_arr) if (card != CardDb.ID_BLACK_MARKET && !supply.contains(card)) deck.add(card);
}
c.setProjection(new String[]{CardDb._ID});
String sel=""String_Node_Str"";
String[] selArgs=new String[deck.size()];
for (int i=0; i < deck.size(); i++) {
sel+=""String_Node_Str"";
selArgs[i]=""String_Node_Str"" + deck.get(i);
}
if (0 < sel.length()) sel=CardDb._ID + ""String_Node_Str"" + sel.substring(1)+ ""String_Node_Str"";
 else sel=CardDb._ID + ""String_Node_Str"";
c.setSelection(sel);
c.setSelectionArgs(selArgs);
c.setSortOrder(""String_Node_Str"");
return c;
case LoaderId.MARKET_SHOW:
c.setUri(Provider.URI_CARD_ALL);
c.setProjection(AdapterCards.COLS_USED);
c.setSortOrder(App.sortOrder);
transId=App.transId;
if (choices == null || choices.length == 0) {
c.setSelection(CardDb._ID + ""String_Node_Str"");
c.setSelectionArgs(new String[]{""String_Node_Str""});
return c;
}
String cardSel=""String_Node_Str"";
for (long ignored : choices) cardSel+=""String_Node_Str"";
cardSel=CardDb._ID + ""String_Node_Str"" + cardSel.substring(1)+ ""String_Node_Str"";
c.setSelection(""String_Node_Str"" + cardSel + ""String_Node_Str""+ App.transFilter);
String[] strChoices=new String[choices.length];
for (int i=0; i < choices.length; i++) strChoices[i]=""String_Node_Str"" + choices[i];
c.setSelectionArgs(strChoices);
updateView();
return c;
}
return null;
}",0.9890625
25872,"@Override public Fragment getItem(int position){
  activeTab=position;
  FragmentHistoryPanel res=new FragmentHistoryPanel();
switch (position) {
case 0:
    res.loaderId=LoaderId.SAMPLE_SUPPLY;
  res.handler=new HandlerSamples(getActivity());
return res;
case 1:
res.loaderId=LoaderId.FAVORITES;
res.handler=new HandlerHistory(getActivity(),true);
return res;
case 2:
res.loaderId=LoaderId.HISTORY;
res.handler=new HandlerHistory(getActivity(),false);
return res;
default :
return null;
}
}","@Override public Fragment getItem(int position){
  activeTab=position;
  FragmentHistoryPanel res=new FragmentHistoryPanel();
  Bundle args=new Bundle();
  args.putInt(FragmentHistoryPanel.PARAM_TYPE,position);
  res.setArguments(args);
  return res;
}",0.3983849259757739
25873,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (handler == null)   throw new IllegalArgumentException(""String_Node_Str"");
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Bundle args=getArguments();
  int type=-1;
  if (args != null)   type=args.getInt(PARAM_TYPE,-1);
switch (type) {
case 0:
    loaderId=LoaderId.SAMPLE_SUPPLY;
  handler=new HandlerSamples(getActivity());
break;
case 1:
loaderId=LoaderId.FAVORITES;
handler=new HandlerHistory(getActivity(),true);
break;
case 2:
loaderId=LoaderId.HISTORY;
handler=new HandlerHistory(getActivity(),false);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}",0.4330175913396482
25874,"@Override public void onStart(){
  super.onStart();
  LoaderManager lm=getActivity().getSupportLoaderManager();
  lm.initLoader(loaderId,null,this);
}","@Override public void onStart(){
  super.onStart();
  App.updateInfo(getActivity());
  LoaderManager lm=getActivity().getSupportLoaderManager();
  if (!App.transId.equals(trnasId)) {
    trnasId=App.transId;
    lm.restartLoader(loaderId,null,this);
  }
 else   lm.initLoader(loaderId,null,this);
}",0.65625
25875,"private File createLocalFile(CrawlFile file,String extension){
  return new File(getCrawlerDownloadDir().getAbsolutePath() + SystemUtils.FILE_SEPARATOR + PathUtils.urlToPath(file.getURL().toString())+ extension);
}","private File createLocalFile(CrawlFile file,String extension){
  return new File(getCrawlerDownloadDir().getAbsolutePath() + SystemUtils.FILE_SEPARATOR + file.getName().getPath()+ extension);
}",0.9041769041769042
25876,"/** 
 * This is a temporary method to import and commit a file. TODO use a list of steps.
 * @param file
 */
private void importAndCommitFile(CrawlFile file){
  LOG.info(""String_Node_Str"" + file);
  File localFile;
  Properties metadata;
  try {
    localFile=createLocalFile(file,""String_Node_Str"");
    FileUtil.createDirsForFile(localFile);
    FileContent content=file.getContent();
    FileOutputStream fos=new FileOutputStream(localFile);
    IOUtils.copy(content.getInputStream(),fos);
    fos.close();
    metadata=new Properties();
    metadata.addLong(""String_Node_Str"",content.getSize());
    metadata.addLong(""String_Node_Str"",content.getLastModifiedTime());
    okFilesCount++;
  }
 catch (  IOException e) {
    throw new FilesystemCollectorException(""String_Node_Str"" + file,e);
  }
  try {
    FileInputStream is=new FileInputStream(localFile);
    String checksum=DigestUtils.md5Hex(is);
    is.close();
    metadata.addString(""String_Node_Str"",checksum);
  }
 catch (  IOException e) {
    throw new FilesystemCollectorException(""String_Node_Str"" + localFile,e);
  }
  File outputFile=createLocalFile(file,""String_Node_Str"");
  Importer importer=new Importer(crawlerConfig.getImporterConfig());
  try {
    importer.importDocument(localFile,null,outputFile,metadata,file.getURL().toString());
  }
 catch (  IOException e) {
    throw new FilesystemCollectorException(""String_Node_Str"" + file,e);
  }
  ICommitter committer=crawlerConfig.getCommitter();
  if (committer != null) {
    committer.queueAdd(file.toString(),outputFile,metadata);
  }
  if (!crawlerConfig.isKeepDownloads()) {
    LOG.debug(""String_Node_Str"" + localFile);
    FileUtils.deleteQuietly(localFile);
    deleteDownloadDirIfReady();
  }
}","/** 
 * This is a temporary method to import and commit a file. TODO use a list of steps.
 * @param file
 */
private void importAndCommitFile(CrawlFile file){
  LOG.info(""String_Node_Str"" + file);
  File localFile;
  Properties metadata;
  try {
    localFile=createLocalFile(file,""String_Node_Str"");
    FileUtil.createDirsForFile(localFile);
    FileContent content=file.getContent();
    FileOutputStream fos=new FileOutputStream(localFile);
    IOUtils.copy(content.getInputStream(),fos);
    fos.close();
    metadata=new Properties();
    metadata.addLong(""String_Node_Str"",content.getSize());
    metadata.addLong(""String_Node_Str"",content.getLastModifiedTime());
    okFilesCount++;
  }
 catch (  IOException e) {
    throw new FilesystemCollectorException(""String_Node_Str"" + file,e);
  }
  try {
    FileInputStream is=new FileInputStream(localFile);
    String checksum=DigestUtils.md5Hex(is);
    is.close();
    metadata.addString(""String_Node_Str"",checksum);
  }
 catch (  IOException e) {
    throw new FilesystemCollectorException(""String_Node_Str"" + localFile,e);
  }
  File outputFile=createLocalFile(file,""String_Node_Str"");
  Importer importer=new Importer(crawlerConfig.getImporterConfig());
  try {
    importer.importDocument(localFile,null,outputFile,metadata,file.getName().toString());
  }
 catch (  IOException e) {
    throw new FilesystemCollectorException(""String_Node_Str"" + file,e);
  }
  ICommitter committer=crawlerConfig.getCommitter();
  if (committer != null) {
    committer.queueAdd(file.toString(),outputFile,metadata);
  }
  if (!crawlerConfig.isKeepDownloads()) {
    LOG.debug(""String_Node_Str"" + localFile);
    FileUtils.deleteQuietly(localFile);
    deleteDownloadDirIfReady();
  }
}",0.9979751229389644
25877,"public CrawlFile(FileObject fileObject){
  if (fileObject == null) {
    throw new FilesystemCollectorException(""String_Node_Str"");
  }
  this.fileObject=fileObject;
  this.reference=getURL().toString();
}","public CrawlFile(FileObject fileObject){
  if (fileObject == null) {
    throw new FilesystemCollectorException(""String_Node_Str"");
  }
  this.fileObject=fileObject;
  this.reference=fileObject.toString();
}",0.9174757281553398
25878,"private File createLocalFile(CrawlFile file,String extension){
  return new File(getCrawlerDownloadDir().getAbsolutePath() + SystemUtils.FILE_SEPARATOR + PathUtils.urlToPath(file.getURL().toString())+ extension);
}","private File createLocalFile(CrawlFile file,String extension){
  return new File(getCrawlerDownloadDir().getAbsolutePath() + SystemUtils.FILE_SEPARATOR + PathUtils.urlToPath(file.getReference())+ extension);
}",0.950354609929078
25879,"public boolean onShoot(Player p,float force){
  int ticks=(int)((((System.currentTimeMillis() - startBow.get(p.getName())) * 20) / 1000) + 3);
  startBow.remove(p.getName());
  float f=(float)ticks / 20.0F;
  f=(f * f + f * 2.0F) / 3.0F;
  f=f > 1.0F ? 1.0F : f;
  if (Math.abs(force - f) > 0.25) {
    return true;
  }
 else {
    return false;
  }
}","public boolean onShoot(Player p,float force){
  int ticks=(int)((((System.currentTimeMillis() - startBow.get(p.getName())) * 20) / 1000) + 3);
  startBow.remove(p.getName());
  float f=(float)ticks / 20.0F;
  f=(f * f + f * 2.0F) / 3.0F;
  f=f > 1.0F ? 1.0F : f;
  if (Math.abs(force - f) > 0.20) {
    return true;
  }
 else {
    return false;
  }
}",0.9971509971509972
25880,"public boolean onShoot(Player p,float force){
  int ticks=(int)((((System.currentTimeMillis() - startBow.get(p.getName())) * 20) / 1000) + 3);
  startBow.remove(p.getName());
  float f=(float)ticks / 20.0F;
  f=(f * f + f * 2.0F) / 3.0F;
  f=f > 1.0F ? 1.0F : f;
  if (Math.abs(force - f) > 0.25) {
    return true;
  }
 else {
    return false;
  }
}","public boolean onShoot(Player p,float force){
  int ticks=(int)((((System.currentTimeMillis() - startBow.get(p.getName())) * 20) / 1000) + 3);
  startBow.remove(p.getName());
  float f=(float)ticks / 20.0F;
  f=(f * f + f * 2.0F) / 3.0F;
  f=f > 1.0F ? 1.0F : f;
  if (Math.abs(force - f) > 0.20) {
    return true;
  }
 else {
    return false;
  }
}",0.9971509971509972
25881,"@SuppressWarnings(""String_Node_Str"") public int runMovingChecks(Player p,Location to,Location from,double yd,double xs,double zs,MoveData movedata,boolean up,boolean inwater,boolean onladder,XYZ lg){
  if ((p.isSneaking() || p.isBlocking()) && p.isSprinting()) {
    if (p.isBlocking() && p.isSprinting()) {
      if ((System.currentTimeMillis() - movedata.blocktime) > 150) {
        int id=this.vars.raiseViolationLevel(CheckType.IMPOSSIBLE,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.IMPOSSIBLE,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.impossiblemovemes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (yd != 0) {
    if (up && onladder) {
      if (yd > ((p.getAllowFlight() || (to.getY() % 1) <= 0.4) ? 0.424 : 0.118)) {
        int id=this.vars.raiseViolationLevel(CheckType.VERTICAL_SPEED,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VERTICAL_SPEED,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.verticalspeedmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
    if (up) {
      if (yd > this.getMaxVertical(p,inwater,up)) {
        int id=this.vars.raiseViolationLevel(CheckType.VERTICAL_SPEED,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VERTICAL_SPEED,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.verticalspeedmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (p.isOnGround() || p.isInsideVehicle() || inwater|| (p.isFlying())|| onladder) {
    this.vars.lastGround.put(p.getName(),new XYZ(from));
  }
 else {
    if (!p.getAllowFlight() && !inwater && !onladder) {
      if (up) {
        double ydis=Math.abs(lg.y - to.getY());
        if (ydis > this.getMaxHight(p,movedata)) {
          int id=this.vars.raiseViolationLevel(CheckType.FLY,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FLY,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.flymes;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            p.setFlying(false);
            p.setAllowFlight(false);
            return 3;
          }
        }
      }
    }
  }
  if ((System.currentTimeMillis() - movedata.lastmounting) > 200) {
    double ydis=Math.abs(lg.y - to.getY());
    if (xs > 0 || zs > 0) {
      boolean wg=movedata.wasonground;
      double mxs=((p.isOnGround()) ? p.getWalkSpeed() : ((p.getAllowFlight() ? p.getFlySpeed() : p.getWalkSpeed())));
      boolean csneak=p.isSneaking();
      if (csneak) {
        if (!movedata.wassneaking) {
          long diff=(System.currentTimeMillis() - movedata.sneaktime);
          if (diff < 501) {
            csneak=false;
          }
        }
      }
      boolean csprint=p.isSprinting();
      if (!csprint) {
        if ((System.currentTimeMillis() - movedata.sprinttime) < 1001) {
          csprint=true;
        }
      }
      boolean cfly=p.isFlying();
      if (!cfly) {
        if ((System.currentTimeMillis() - movedata.flytime) < 2001) {
          cfly=true;
        }
      }
      if (xs > zs) {
        p.sendMessage(xs + ""String_Node_Str"");
      }
 else {
        p.sendMessage(""String_Node_Str"" + zs);
      }
      if (cfly) {
      }
 else       if (csprint) {
      }
 else       if (csneak) {
        mxs=(mxs - (p.getWalkSpeed() - (p.getWalkSpeed() / 3))) + 0.1;
      }
 else {
        mxs=mxs + 0.1;
      }
      if (p.hasPotionEffect(PotionEffectType.SPEED)) {
        int level=Utils.getPotionEffectLevel(p,PotionEffectType.SPEED);
        if (level > 0) {
          mxs=(0.0812) * ((0.5 * level) + 1);
        }
      }
      if (xs > mxs || zs > mxs) {
        int id=this.vars.raiseViolationLevel(CheckType.HORIZONTAL_SPEED,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.HORIZONTAL_SPEED,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (Setting.debug) {
            p.sendMessage(""String_Node_Str"" + xs + ""String_Node_Str""+ zs+ ""String_Node_Str""+ mxs+ ""String_Node_Str""+ p.isOnGround()+ ""String_Node_Str""+ movedata.wasonground+ ""String_Node_Str""+ (System.currentTimeMillis() - movedata.groundtime));
          }
          if (id != 0) {
            String message=Setting.horizontalspeedmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
    if (!p.isOnGround() && !p.getAllowFlight()) {
      double mdis=this.getXZDistance(to.getX(),lg.x,to.getZ(),lg.z);
      if (mdis > this.getMaxMD(inwater,p.isOnGround(),p,ydis,movedata)) {
        int id=this.vars.raiseViolationLevel(CheckType.GLIDE,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.GLIDE,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.glidemes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (!p.isFlying()) {
    if (!inwater && !p.getAllowFlight() && p.isOnGround()) {
      Material m=null;
      if (to.getBlockX() != from.getBlockX() || to.getBlockZ() != from.getBlockZ()) {
        int by=from.getBlockY() + 1;
        int oy=by;
        boolean con=true;
        while (con) {
          by--;
          m=from.getBlock().getRelative(0,((oy - by) * -1) + 1,0).getType();
          if (m.isSolid()) {
            con=false;
            break;
          }
          if (by < 0) {
            con=false;
            break;
          }
        }
        int dis=(oy - by);
        if (dis > 2) {
          int id=this.vars.raiseViolationLevel(CheckType.FLY,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FLY,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.flymes;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            return 1;
          }
        }
      }
    }
    if (!p.getAllowFlight()) {
      if (to.getBlockY() != from.getBlockY()) {
        if (up && p.isOnGround() && !inwater) {
          if (p.getVelocity().getY() < 0) {
            Material m=from.getBlock().getType();
            if (m != Material.CHEST && m != Material.TRAPPED_CHEST) {
              int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
              ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
              Bukkit.getServer().getPluginManager().callEvent(vte);
              if (!vte.isCancelled()) {
                if (id != 0) {
                  String message=Setting.nofallmessage;
                  message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
                  message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
                  Utils.messageAdmins(message);
                }
                return 4;
              }
            }
          }
        }
      }
    }
    if (!up && yd > 0.25 && p.isOnGround()) {
      int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.nofallmessage;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 4;
      }
    }
  }
  if (to.getX() != from.getX() || to.getY() != from.getY() || to.getZ() != from.getZ()) {
    if ((System.currentTimeMillis() - movedata.getTimeStart()) > 500) {
      int max=0;
      max=Math.round((Utils.getPing(p) / 100));
      if (max < 0) {
        max=0;
      }
      max=max + Setting.maxpacket;
      if (movedata.getAmount() > max) {
        int id=this.vars.raiseViolationLevel(CheckType.TIMER,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.TIMER,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (movedata.getAmount() > 50) {
            p.kickPlayer(""String_Node_Str"");
          }
 else {
            p.teleport(movedata.lastloc.toLocation(to.getPitch(),to.getYaw()),TeleportCause.UNKNOWN);
          }
          if (id != 0) {
            String message=Setting.timermes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            message=message.replaceAll(""String_Node_Str"",movedata.getAmount() + ""String_Node_Str"");
            message=message.replaceAll(""String_Node_Str"",max + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          movedata.reset(movedata.lastloc);
        }
      }
 else {
        movedata.reset(new XYZ(from));
      }
    }
 else {
      movedata.setAmount(movedata.getAmount() + 1);
    }
    this.vars.setMoveData(p.getName(),movedata);
  }
  return 0;
}","@SuppressWarnings(""String_Node_Str"") public int runMovingChecks(Player p,Location to,Location from,double yd,double xs,double zs,MoveData movedata,boolean up,boolean inwater,boolean onladder,XYZ lg){
  boolean jumped=(movedata.wasonground != p.isOnGround());
  if (!jumped) {
    if ((System.currentTimeMillis() - movedata.groundtime) < 600) {
      jumped=true;
    }
  }
  if ((p.isSneaking() || p.isBlocking()) && p.isSprinting()) {
    if (p.isBlocking() && p.isSprinting()) {
      if ((System.currentTimeMillis() - movedata.blocktime) > 150) {
        int id=this.vars.raiseViolationLevel(CheckType.IMPOSSIBLE,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.IMPOSSIBLE,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.impossiblemovemes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (yd != 0) {
    if (up && onladder) {
      if (yd > ((p.getAllowFlight() || (to.getY() % 1) <= 0.4) ? 0.424 : 0.118)) {
        int id=this.vars.raiseViolationLevel(CheckType.VERTICAL_SPEED,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VERTICAL_SPEED,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.verticalspeedmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
    if (up) {
      if (yd > this.getMaxVertical(p,inwater,up)) {
        int id=this.vars.raiseViolationLevel(CheckType.VERTICAL_SPEED,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VERTICAL_SPEED,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.verticalspeedmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (p.isOnGround() || p.isInsideVehicle() || inwater|| (p.isFlying())|| onladder) {
    this.vars.lastGround.put(p.getName(),new XYZ(from));
  }
 else {
    if (!p.getAllowFlight() && !inwater && !onladder) {
      if (up) {
        double ydis=Math.abs(lg.y - to.getY());
        if (ydis > this.getMaxHight(p,movedata)) {
          int id=this.vars.raiseViolationLevel(CheckType.FLY,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FLY,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.flymes;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            p.setFlying(false);
            p.setAllowFlight(false);
            return 3;
          }
        }
      }
    }
  }
  if ((System.currentTimeMillis() - movedata.lastmounting) > 200) {
    double ydis=Math.abs(lg.y - to.getY());
    if (xs > 0 || zs > 0) {
      double mxs=0;
      boolean csneak=p.isSneaking();
      if (csneak) {
        if (!movedata.wassneaking) {
          long diff=(System.currentTimeMillis() - movedata.sneaktime);
          if (diff < 501) {
            csneak=false;
          }
        }
      }
      boolean csprint=p.isSprinting();
      if (!csprint) {
        if ((System.currentTimeMillis() - movedata.sprinttime) < 1001) {
          csprint=true;
        }
      }
      boolean cfly=p.isFlying();
      if (!cfly) {
        if ((System.currentTimeMillis() - movedata.flytime) < 2001) {
          cfly=true;
        }
      }
      if (cfly) {
        mxs=(p.getFlySpeed() * 5.457);
      }
 else       if (csprint) {
        if (jumped) {
          mxs=(p.getWalkSpeed() / 0.3);
        }
 else {
          mxs=(p.getWalkSpeed() / 0.71);
        }
      }
 else       if (csneak) {
        if (jumped) {
          mxs=(p.getWalkSpeed() / 2.1);
        }
 else {
          mxs=(p.getWalkSpeed() / 2.9);
        }
      }
 else {
        if (jumped) {
          mxs=(p.getWalkSpeed() / 0.65);
        }
 else {
          mxs=(p.getWalkSpeed() / 0.9);
        }
      }
      if (p.hasPotionEffect(PotionEffectType.SPEED)) {
        int level=Utils.getPotionEffectLevel(p,PotionEffectType.SPEED);
        if (level > 0) {
          mxs=(mxs * (((level * 20) * 0.011) + 1));
        }
      }
      if (xs > mxs || zs > mxs) {
        int id=this.vars.raiseViolationLevel(CheckType.HORIZONTAL_SPEED,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.HORIZONTAL_SPEED,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (Setting.debug) {
            p.sendMessage(""String_Node_Str"" + xs + ""String_Node_Str""+ zs+ ""String_Node_Str""+ mxs+ ""String_Node_Str""+ p.isOnGround()+ ""String_Node_Str""+ movedata.wasonground+ ""String_Node_Str""+ (System.currentTimeMillis() - movedata.groundtime));
          }
          if (id != 0) {
            String message=Setting.horizontalspeedmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
    if (!p.isOnGround() && !p.getAllowFlight()) {
      double mdis=this.getXZDistance(to.getX(),lg.x,to.getZ(),lg.z);
      if (mdis > this.getMaxMD(inwater,p.isOnGround(),p,ydis,movedata)) {
        int id=this.vars.raiseViolationLevel(CheckType.GLIDE,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.GLIDE,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.glidemes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (!p.isFlying()) {
    if (!inwater && !p.getAllowFlight() && p.isOnGround()) {
      Material m=null;
      if (to.getBlockX() != from.getBlockX() || to.getBlockZ() != from.getBlockZ()) {
        int by=from.getBlockY() + 1;
        int oy=by;
        boolean con=true;
        while (con) {
          by--;
          m=from.getBlock().getRelative(0,((oy - by) * -1) + 1,0).getType();
          if (m.isSolid()) {
            con=false;
            break;
          }
          if (by < 0) {
            con=false;
            break;
          }
        }
        int dis=(oy - by);
        if (dis > 2) {
          int id=this.vars.raiseViolationLevel(CheckType.FLY,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FLY,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.flymes;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            return 1;
          }
        }
      }
    }
    if (!p.getAllowFlight()) {
      if (to.getBlockY() != from.getBlockY()) {
        if (up && p.isOnGround() && !inwater) {
          if (p.getVelocity().getY() < 0) {
            Material m=from.getBlock().getType();
            if (m != Material.CHEST && m != Material.TRAPPED_CHEST) {
              int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
              ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
              Bukkit.getServer().getPluginManager().callEvent(vte);
              if (!vte.isCancelled()) {
                if (id != 0) {
                  String message=Setting.nofallmessage;
                  message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
                  message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
                  Utils.messageAdmins(message);
                }
                return 4;
              }
            }
          }
        }
      }
    }
    if (!up && yd > 0.25 && p.isOnGround()) {
      int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.nofallmessage;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 4;
      }
    }
  }
  if (to.getX() != from.getX() || to.getY() != from.getY() || to.getZ() != from.getZ()) {
    if ((System.currentTimeMillis() - movedata.getTimeStart()) > 500) {
      int max=0;
      max=Math.round((Utils.getPing(p) / 100));
      if (max < 0) {
        max=0;
      }
      max=max + Setting.maxpacket;
      if (movedata.getAmount() > max) {
        int id=this.vars.raiseViolationLevel(CheckType.TIMER,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.TIMER,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (movedata.getAmount() > 50) {
            p.kickPlayer(""String_Node_Str"");
          }
 else {
            p.teleport(movedata.lastloc.toLocation(to.getPitch(),to.getYaw()),TeleportCause.UNKNOWN);
          }
          if (id != 0) {
            String message=Setting.timermes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            message=message.replaceAll(""String_Node_Str"",movedata.getAmount() + ""String_Node_Str"");
            message=message.replaceAll(""String_Node_Str"",max + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          movedata.reset(movedata.lastloc);
        }
      }
 else {
        movedata.reset(new XYZ(from));
      }
    }
 else {
      movedata.setAmount(movedata.getAmount() + 1);
    }
    this.vars.setMoveData(p.getName(),movedata);
  }
  return 0;
}",0.9623563711198764
25882,"@SuppressWarnings(""String_Node_Str"") @Override public int runMoveCheck(Player p,Location to,Location from,double yd,double xs,double zs,MoveData movedata,boolean up,boolean inwater,boolean onladder,XYZ lg){
  if (p.isFlying()) {
    return 0;
  }
  if (!inwater) {
    if (to.getBlockX() != from.getBlockX() || to.getBlockZ() != from.getBlockZ()) {
      int by=to.getBlockY();
      int oy=by;
      while (true) {
        by--;
        if (to.getBlock().getRelative(0,((oy - by) * -1),0).getType().isSolid()) {
          break;
        }
        if (by < 0) {
          break;
        }
      }
      int dis=(oy - by);
      if (dis > 2 && p.isOnGround()) {
        int id=this.vars.raiseViolationLevel(CheckType.FLY,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FLY,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.flymes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
 else       if (dis < 1 && !p.isOnGround()) {
        int id=this.vars.raiseViolationLevel(CheckType.IMPOSSIBLE,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.IMPOSSIBLE,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.impossiblemovemes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (!p.getAllowFlight()) {
    if (to.getBlockY() != from.getBlockY()) {
      if (up && p.isOnGround() && !inwater) {
        if (p.getVelocity().getY() < 0) {
          Material m=from.getBlock().getType();
          if (m == Material.CHEST || m == Material.TRAPPED_CHEST) {
            return 0;
          }
          int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.nofallmessage;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            return 4;
          }
        }
      }
    }
  }
  if (!up && yd > 0.25 && p.isOnGround()) {
    int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    if (!vte.isCancelled()) {
      if (id != 0) {
        String message=Setting.nofallmessage;
        message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
        message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
        Utils.messageAdmins(message);
      }
      return 4;
    }
  }
  return 0;
}","@SuppressWarnings(""String_Node_Str"") @Override public int runMoveCheck(Player p,Location to,Location from,double yd,double xs,double zs,MoveData movedata,boolean up,boolean inwater,boolean onladder,XYZ lg){
  if (p.isFlying()) {
    return 0;
  }
  if (!inwater && !p.getAllowFlight() && p.isOnGround()) {
    Material m=null;
    if (to.getBlockX() != from.getBlockX() || to.getBlockZ() != from.getBlockZ()) {
      int by=from.getBlockY() + 1;
      int oy=by;
      boolean con=true;
      while (con) {
        by--;
        m=from.getBlock().getRelative(0,((oy - by) * -1) + 1,0).getType();
        if (m.isSolid()) {
          con=false;
          break;
        }
        if (by < 0) {
          con=false;
          break;
        }
      }
      int dis=(oy - by);
      if (dis > 2) {
        int id=this.vars.raiseViolationLevel(CheckType.FLY,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FLY,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.flymes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
  if (!p.getAllowFlight()) {
    if (to.getBlockY() != from.getBlockY()) {
      if (up && p.isOnGround() && !inwater) {
        if (p.getVelocity().getY() < 0) {
          Material m=from.getBlock().getType();
          if (m == Material.CHEST || m == Material.TRAPPED_CHEST) {
            return 0;
          }
          int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.nofallmessage;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            return 4;
          }
        }
      }
    }
  }
  if (!up && yd > 0.25 && p.isOnGround()) {
    int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    if (!vte.isCancelled()) {
      if (id != 0) {
        String message=Setting.nofallmessage;
        message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
        message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
        Utils.messageAdmins(message);
      }
      return 4;
    }
  }
  return 0;
}",0.86734845116348
25883,"@EventHandler(ignoreCancelled=true) public void onViolationTriggeredEvent(ViolationTriggeredEvent event){
  if (Setting.ignorenpc) {
    if (event.getPlayer().hasMetadata(""String_Node_Str"")) {
      event.setCancelled(true);
      return;
    }
  }
  if (event.getPlayer().hasPermission(""String_Node_Str"" + event.getCheckType().toString().toLowerCase())) {
  }
  if (event.getCheckType() == CheckType.FAST_INTERACT) {
    long diff=0;
    if (this.lastViolation.containsKey(event.getPlayer().getName())) {
      diff=System.currentTimeMillis() - this.lastViolation.get(event.getPlayer().getName());
    }
    if (diff <= 2000 && event.getNewLevel() > 35) {
      event.getPlayer().kickPlayer(ChatColor.RED + ""String_Node_Str"");
      this.nh.vars.setDeniedLogin(event.getPlayer(),(System.currentTimeMillis() + 10000),""String_Node_Str"");
      event.setNewLevel(0);
    }
    this.lastViolation.put(event.getPlayer().getName(),System.currentTimeMillis());
  }
  if (event.getCheckType() == CheckType.AUTOSOUP) {
    if (Setting.autoban) {
      this.nh.vars.setDeniedLogin(event.getPlayer(),(System.currentTimeMillis() + (Setting.autobantime * 1000)),""String_Node_Str"");
      event.getPlayer().kickPlayer(ChatColor.RED + ""String_Node_Str"" + Setting.autobantime+ ""String_Node_Str"");
      Utils.messageAdmins(event.getPlayer().getName() + ""String_Node_Str"" + Setting.autobantime+ ""String_Node_Str"");
    }
  }
}","@EventHandler(ignoreCancelled=true) public void onViolationTriggeredEvent(ViolationTriggeredEvent event){
  if (Setting.ignorenpc) {
    if (event.getPlayer().hasMetadata(""String_Node_Str"")) {
      event.setCancelled(true);
      return;
    }
  }
  if (event.getPlayer().hasPermission(""String_Node_Str"" + event.getCheckType().toString().toLowerCase())) {
  }
  if (event.getCheckType() == CheckType.FAST_INTERACT || event.getCheckType() == CheckType.SPEED_BREAK) {
    long diff=0;
    if (this.lastViolation.containsKey(event.getPlayer().getName())) {
      diff=System.currentTimeMillis() - this.lastViolation.get(event.getPlayer().getName());
    }
    if (diff <= 2000 && event.getNewLevel() > 35) {
      event.getPlayer().kickPlayer(ChatColor.RED + ""String_Node_Str"");
      this.nh.vars.setDeniedLogin(event.getPlayer(),(System.currentTimeMillis() + 10000),""String_Node_Str"");
      event.setNewLevel(0);
    }
    this.lastViolation.put(event.getPlayer().getName(),System.currentTimeMillis());
  }
  if (event.getCheckType() == CheckType.AUTOSOUP) {
    if (Setting.autoban) {
      this.nh.vars.setDeniedLogin(event.getPlayer(),(System.currentTimeMillis() + (Setting.autobantime * 1000)),""String_Node_Str"");
      event.getPlayer().kickPlayer(ChatColor.RED + ""String_Node_Str"" + Setting.autobantime+ ""String_Node_Str"");
      Utils.messageAdmins(event.getPlayer().getName() + ""String_Node_Str"" + Setting.autobantime+ ""String_Node_Str"");
    }
  }
}",0.9829208783548274
25884,"@Override public int runBlockCheck(Player p,Block b,BlockFace bf,long ls,int aid){
  if (p == null || b == null || aid != 0) {
    return 0;
  }
  long diff=(System.currentTimeMillis() - this.getLastBreak(p.getName()));
  this.lastBreak.put(p.getName(),System.currentTimeMillis());
  if (Utils.instantBreak(b.getType()) || p.getGameMode() == GameMode.CREATIVE) {
    if (p.getGameMode() == GameMode.CREATIVE) {
      if (diff <= 200) {
        int id=this.vars.raiseViolationLevel(CheckType.SPEED_BREAK,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.SPEED_BREAK,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.speedbreakmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
 else {
    if (!Utils.canSeeBlock(p,b)) {
      int id=this.vars.raiseViolationLevel(CheckType.VISIBLE,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VISIBLE,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.blockvisiblebreak;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 4;
      }
    }
  }
  return 0;
}","@Override public int runBlockCheck(Player p,Block b,BlockFace bf,long ls,int aid){
  if (p == null || b == null || aid != 0) {
    return 0;
  }
  long diff=(System.currentTimeMillis() - this.getLastBreak(p.getName()));
  this.lastBreak.put(p.getName(),System.currentTimeMillis());
  if (Utils.instantBreak(b.getType()) || p.getGameMode() == GameMode.CREATIVE) {
    if (p.getGameMode() == GameMode.CREATIVE) {
      if (diff <= 200) {
        if (Setting.debug) {
          Bukkit.broadcastMessage(""String_Node_Str"" + diff);
        }
        int id=this.vars.raiseViolationLevel(CheckType.SPEED_BREAK,p);
        ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.SPEED_BREAK,p);
        Bukkit.getServer().getPluginManager().callEvent(vte);
        if (!vte.isCancelled()) {
          if (id != 0) {
            String message=Setting.speedbreakmes;
            message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
            message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
            Utils.messageAdmins(message);
          }
          return 1;
        }
      }
    }
  }
 else {
    if (!Utils.canSeeBlock(p,b)) {
      int id=this.vars.raiseViolationLevel(CheckType.VISIBLE,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VISIBLE,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.blockvisiblebreak;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 4;
      }
    }
  }
  return 0;
}",0.9727668845315904
25885,"private double getMaxHorizontal(boolean onground,boolean inwater,Player p,MoveData md){
  double d=0;
  boolean csneak=p.isSneaking();
  if (!csneak) {
    if ((System.currentTimeMillis() - md.sneaktime) <= 1000) {
      csneak=true;
    }
  }
  boolean csprint=p.isSprinting();
  if (!csprint) {
    if ((System.currentTimeMillis() - md.sprinttime) <= 1000) {
      csprint=true;
    }
  }
  if (p.isFlying()) {
    d=0.305;
  }
 else {
    if (csprint) {
      d=0.788;
    }
 else     if (csneak) {
      if (p.getAllowFlight()) {
        d=0.305;
      }
 else {
        if (onground && p.isSneaking()) {
          d=0.025;
        }
 else         if (onground) {
          d=0.467;
        }
 else         if (!onground && p.isSneaking()) {
          d=0.467;
        }
      }
    }
 else     if (p.isBlocking()) {
      d=0.0205;
    }
 else {
      d=0.467;
    }
  }
  if (inwater) {
    d=0.0774;
  }
  d=d + Math.abs((p.getVelocity().getX() + p.getVelocity().getZ()) * 7.5);
  return d;
}","private double getMaxHorizontal(boolean onground,boolean inwater,Player p,MoveData md){
  double d=0;
  boolean csneak=p.isSneaking();
  if (!csneak) {
    if ((System.currentTimeMillis() - md.sneaktime) <= 1000) {
      csneak=true;
    }
  }
  boolean csprint=p.isSprinting();
  if (!csprint) {
    if ((System.currentTimeMillis() - md.sprinttime) <= 1000) {
      csprint=true;
    }
  }
  if (p.isFlying()) {
    d=0.305;
  }
 else {
    if (csprint) {
      d=0.788;
    }
 else     if (csneak) {
      if (p.getAllowFlight()) {
        d=0.305;
      }
 else {
        if (onground && p.isSneaking()) {
          d=0.025;
        }
 else         if (onground) {
          d=0.467;
        }
 else         if (!onground && p.isSneaking()) {
          d=0.467;
        }
      }
    }
 else     if (p.isBlocking()) {
      d=0.0205;
    }
 else {
      d=0.467;
    }
  }
  if (inwater && !p.getAllowFlight()) {
    d=0.0774;
  }
  d=d + Math.abs((p.getVelocity().getX() + p.getVelocity().getZ()) * 7.5);
  return d;
}",0.9886194952993568
25886,"private double getMaxVertical(Player p,boolean inwater,boolean up){
  double d=0.5;
  if (p.hasPotionEffect(PotionEffectType.JUMP)) {
    d=d + ((this.getPotionEffectLevel(p,PotionEffectType.JUMP)) * 0.11);
  }
  if (inwater) {
    if (up) {
      d=0.3401;
    }
 else {
      d=Math.abs(p.getVelocity().getY());
    }
  }
  if (p.getVelocity().getY() > 0) {
    d=d + (p.getVelocity().getY());
  }
  return d;
}","private double getMaxVertical(Player p,boolean inwater,boolean up){
  double d=0.5;
  if (p.hasPotionEffect(PotionEffectType.JUMP)) {
    d=d + ((this.getPotionEffectLevel(p,PotionEffectType.JUMP)) * 0.11);
  }
  if (inwater && !p.getAllowFlight()) {
    if (up) {
      d=0.3401;
    }
 else {
      d=Math.abs(p.getVelocity().getY());
    }
  }
  if (p.getVelocity().getY() > 0) {
    d=d + (p.getVelocity().getY());
  }
  return d;
}",0.972909305064782
25887,"@EventHandler(ignoreCancelled=true) public void onClick(InventoryClickEvent event){
  if (event.getWhoClicked().getType() == EntityType.PLAYER) {
    Player p=(Player)event.getWhoClicked();
    for (    Check c : nh.getChecks()) {
      if (c.getDetectType() == DetectionType.INVENTORY) {
        if (c.runInventoryCheck(p) != 0) {
          event.setCancelled(true);
          break;
        }
      }
    }
    p=null;
  }
}","@EventHandler(ignoreCancelled=true) public void onClick(InventoryClickEvent event){
  if (event.getWhoClicked().getType() == EntityType.PLAYER) {
    Player p=(Player)event.getWhoClicked();
    for (    Check c : nh.getChecks()) {
      if (c.getDetectType() == DetectionType.INVENTORY) {
        if (c.runInventoryCheck(p,event.getInventory(),event.getAction()) != 0) {
          event.setCancelled(true);
          break;
        }
      }
    }
    p=null;
  }
}",0.9562289562289562
25888,"public int runInventoryCheck(Player p){
  return 0;
}","public int runInventoryCheck(Player p,Inventory inv,InventoryAction ia){
  return 0;
}",0.762589928057554
25889,"@Override public int runBlockCheck(Player p,Block b,BlockFace bf,long ls,int aid){
  if (p == null || b == null || aid != 0) {
    return 0;
  }
  if (Utils.instantBreak(b.getType())) {
  }
 else {
    if (!Utils.canSeeBlock(p,b)) {
      int id=this.vars.raiseViolationLevel(CheckType.VISIBLE,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VISIBLE,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.blockvisiblebreak;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 4;
      }
    }
  }
  return 0;
}","@Override public int runBlockCheck(Player p,Block b,BlockFace bf,long ls,int aid){
  if (p == null || b == null || aid != 0) {
    return 0;
  }
  if (Utils.instantBreak(b.getType()) || p.getGameMode() == GameMode.CREATIVE) {
  }
 else {
    if (!Utils.canSeeBlock(p,b)) {
      int id=this.vars.raiseViolationLevel(CheckType.VISIBLE,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.VISIBLE,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.blockvisiblebreak;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 4;
      }
    }
  }
  return 0;
}",0.9776536312849162
25890,"@Override public int runInventoryCheck(Player p){
  if (p.isBlocking() || p.isSneaking() || p.isSprinting()|| p.isSleeping()) {
    int id=this.vars.raiseViolationLevel(CheckType.IMPOSSIBLE,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.IMPOSSIBLE,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    if (!vte.isCancelled()) {
      if (id != 0) {
        String message=Setting.impossibleclick;
        message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
        message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
        Utils.messageAdmins(message);
      }
      return 1;
    }
  }
  long diff=(System.currentTimeMillis() - this.getLastClicked(p.getName()));
  if (diff <= Setting.fcs) {
    int id=this.vars.raiseViolationLevel(CheckType.FASTCLICK,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FASTCLICK,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    this.lastclick.put(p.getName(),System.currentTimeMillis());
    if (!vte.isCancelled()) {
      if (id != 0) {
        Utils.messageAdmins(ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN+ ""String_Node_Str""+ id);
      }
      return 1;
    }
  }
  this.lastclick.put(p.getName(),System.currentTimeMillis());
  return 0;
}","@Override public int runInventoryCheck(Player p,Inventory inv,InventoryAction ia){
  if (p.isBlocking() || p.isSneaking() || p.isSprinting()|| p.isSleeping()) {
    int id=this.vars.raiseViolationLevel(CheckType.IMPOSSIBLE,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.IMPOSSIBLE,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    if (!vte.isCancelled()) {
      if (id != 0) {
        String message=Setting.impossibleclick;
        message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
        message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
        Utils.messageAdmins(message);
      }
      return 1;
    }
  }
  if (p.getGameMode() == GameMode.CREATIVE) {
    if (inv.getType() == InventoryType.CREATIVE) {
    }
  }
  if (Setting.debug) {
    Bukkit.broadcastMessage(""String_Node_Str"" + inv.getType() + ""String_Node_Str""+ ia.toString().toLowerCase());
  }
  long diff=(System.currentTimeMillis() - this.getLastClicked(p.getName()));
  if (diff <= Setting.fcs) {
    int id=this.vars.raiseViolationLevel(CheckType.FASTCLICK,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.FASTCLICK,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    this.lastclick.put(p.getName(),System.currentTimeMillis());
    if (!vte.isCancelled()) {
      if (id != 0) {
        Utils.messageAdmins(ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN+ ""String_Node_Str""+ id);
      }
      return 1;
    }
  }
  this.lastclick.put(p.getName(),System.currentTimeMillis());
  return 0;
}",0.7511283043197937
25891,"@SuppressWarnings(""String_Node_Str"") @Override public int runMoveCheck(Player p,Location to,Location from,double yd,double md,MoveData movedata,boolean up,boolean inwater,boolean onladder,XYZ lg){
  if (p.isFlying()) {
    return 0;
  }
  if (!p.getAllowFlight()) {
    if (to.getBlockY() != from.getBlockY()) {
      if (up && p.isOnGround() && !inwater) {
        if (p.getVelocity().getY() < 0) {
          int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.nofallmessage;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            return 4;
          }
        }
      }
    }
  }
  if (!up && yd > 0.25 && p.isOnGround()) {
    int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    if (!vte.isCancelled()) {
      if (id != 0) {
        String message=Setting.nofallmessage;
        message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
        message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
        Utils.messageAdmins(message);
      }
      return 4;
    }
  }
  return 0;
}","@SuppressWarnings(""String_Node_Str"") @Override public int runMoveCheck(Player p,Location to,Location from,double yd,double md,MoveData movedata,boolean up,boolean inwater,boolean onladder,XYZ lg){
  if (p.isFlying()) {
    return 0;
  }
  if (!p.getAllowFlight()) {
    if (to.getBlockY() != from.getBlockY()) {
      if (up && p.isOnGround() && !inwater) {
        if (p.getVelocity().getY() < 0) {
          Material m=from.getBlock().getType();
          if (m != Material.CHEST && m != Material.TRAPPED_CHEST) {
            return 0;
          }
          int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.nofallmessage;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            return 4;
          }
        }
      }
    }
  }
  if (!up && yd > 0.25 && p.isOnGround()) {
    int id=this.vars.raiseViolationLevel(CheckType.NOFALL,p);
    ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.NOFALL,p);
    Bukkit.getServer().getPluginManager().callEvent(vte);
    if (!vte.isCancelled()) {
      if (id != 0) {
        String message=Setting.nofallmessage;
        message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
        message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
        Utils.messageAdmins(message);
      }
      return 4;
    }
  }
  return 0;
}",0.9586549062844544
25892,"@SuppressWarnings(""String_Node_Str"") @Override public int run(Player p,Location from,Location to,long ls,LivingEntity e,double damage,Block clicked,BlockFace bf,String mes,boolean blockmove,boolean onladder,boolean up,boolean inwater,double yd,double md,XYZ lg){
  double ydis=Math.abs(lg.y - to.getY());
  if (md != 0) {
    MoveData moved=this.vars.getMoveData(p.getName());
    if ((System.currentTimeMillis() - moved.lastmounting) <= 200) {
      moved=null;
      return 0;
    }
    if (md > this.getMaxHorizontal(p.isOnGround(),inwater,p,moved)) {
      int id=this.vars.raiseViolationLevel(CheckType.HORIZONTAL_SPEED,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.HORIZONTAL_SPEED,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.horizontalspeedmes;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 1;
      }
    }
 else {
      if (!p.isOnGround() && !p.getAllowFlight()) {
        double mdis=this.getXZDistance(to.getX(),lg.x,to.getZ(),lg.z);
        if (mdis > this.getMaxMD(inwater,p.isOnGround(),p,ydis,moved)) {
        }
      }
    }
  }
  return 0;
}","@SuppressWarnings(""String_Node_Str"") @Override public int run(Player p,Location from,Location to,long ls,LivingEntity e,double damage,Block clicked,BlockFace bf,String mes,boolean blockmove,boolean onladder,boolean up,boolean inwater,double yd,double md,XYZ lg){
  double ydis=Math.abs(lg.y - to.getY());
  if (md != 0) {
    MoveData moved=this.vars.getMoveData(p.getName());
    if ((System.currentTimeMillis() - moved.lastmounting) <= 200) {
      moved=null;
      return 0;
    }
    if (md > this.getMaxHorizontal(p.isOnGround(),inwater,p,moved)) {
      int id=this.vars.raiseViolationLevel(CheckType.HORIZONTAL_SPEED,p);
      ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.HORIZONTAL_SPEED,p);
      Bukkit.getServer().getPluginManager().callEvent(vte);
      if (!vte.isCancelled()) {
        if (id != 0) {
          String message=Setting.horizontalspeedmes;
          message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
          message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
          Utils.messageAdmins(message);
        }
        return 1;
      }
    }
 else {
      if (!p.isOnGround() && !p.getAllowFlight()) {
        double mdis=this.getXZDistance(to.getX(),lg.x,to.getZ(),lg.z);
        if (mdis > this.getMaxMD(inwater,p.isOnGround(),p,ydis,moved)) {
          int id=this.vars.raiseViolationLevel(CheckType.GLIDE,p);
          ViolationTriggeredEvent vte=new ViolationTriggeredEvent(id,CheckType.GLIDE,p);
          Bukkit.getServer().getPluginManager().callEvent(vte);
          if (!vte.isCancelled()) {
            if (id != 0) {
              String message=Setting.flymes;
              message=message.replaceAll(""String_Node_Str"",ChatColor.YELLOW + ""String_Node_Str"" + p.getName()+ ""String_Node_Str""+ ChatColor.GREEN);
              message=message.replaceAll(""String_Node_Str"",id + ""String_Node_Str"");
              Utils.messageAdmins(message);
            }
            return 1;
          }
        }
      }
    }
  }
  return 0;
}",0.8158192090395481
25893,"private StringBuilder createStepTeplate(ArrayList<String> stepTexts){
  StringBuilder step=new StringBuilder();
  if (stepTexts.size() == 1) {
    return step.append(""String_Node_Str"").append(stepTexts.get(0)).append(""String_Node_Str"");
  }
 else {
    StringBuilder commaSeparated=new StringBuilder();
    for (    String stepText : stepTexts) {
      commaSeparated.append(""String_Node_Str"").append(stepText).append(""String_Node_Str"");
    }
    return step.append(""String_Node_Str"").append(commaSeparated).append(""String_Node_Str"");
  }
}","private StringBuilder createStepTeplate(ArrayList<String> stepTexts){
  StringBuilder step=new StringBuilder();
  if (stepTexts.size() == 1) {
    return step.append(""String_Node_Str"").append(stepTexts.get(0)).append(""String_Node_Str"");
  }
 else {
    StringBuilder commaSeparated=new StringBuilder();
    for (    String stepText : stepTexts) {
      commaSeparated.append(""String_Node_Str"").append(stepText).append(""String_Node_Str"");
    }
    StringBuilder res=step.append(""String_Node_Str"").append(commaSeparated.substring(0,commaSeparated.length() - 1)).append(""String_Node_Str"");
    return res;
  }
}",0.928695652173913
25894,"@Override public void implementStep(StepImpl stepImpl) throws Exception {
  List<String> paramTypes=new ArrayList<String>();
  StepValueExtractor.StepValue stepValue=new StepValueExtractor().getFor(stepImpl.getStepText());
  String className=Util.getUniqueName();
  StringBuilder classText=new StringBuilder();
  classText.append(""String_Node_Str"").append(className).append(""String_Node_Str"");
  classText.append(""String_Node_Str"").append(stepValue.value).append(""String_Node_Str"");
  if (stepImpl.isContinueOnFailure()) {
    classText.append(""String_Node_Str"");
  }
  classText.append(""String_Node_Str"").append(""String_Node_Str"");
  for (int i=0; i < stepValue.paramCount; i++) {
    if (i + 1 == stepValue.paramCount) {
      classText.append(""String_Node_Str"").append(i);
    }
 else {
      classText.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
    }
    paramTypes.add(""String_Node_Str"");
  }
  String implementation=stepImpl.getImplementation();
  implementation=getStepImplementation(stepValue,implementation,paramTypes,stepImpl.isValidStatement());
  classText.append(""String_Node_Str"").append(implementation).append(""String_Node_Str"");
  classText.append(""String_Node_Str"");
  Util.appendToFile(Util.combinePath(getStepImplementationsDir(),""String_Node_Str""),classText.toString());
}","@Override public void implementStep(StepImpl stepImpl) throws Exception {
  List<String> paramTypes=new ArrayList<String>();
  StepValueExtractor stepValueExtractor=new StepValueExtractor();
  StepValueExtractor.StepValue stepValue=stepValueExtractor.getFor(stepImpl.getFirstStepText());
  ArrayList<String> stepValues=stepValueExtractor.getValueFor(stepImpl.getAllStepTexts());
  String className=Util.getUniqueName();
  StringBuilder classText=new StringBuilder();
  classText.append(""String_Node_Str"").append(className).append(""String_Node_Str"");
  classText.append(createStepTeplate(stepValueExtractor.getValueFor(stepImpl.getAllStepTexts())));
  if (stepImpl.isContinueOnFailure()) {
    classText.append(""String_Node_Str"");
  }
  classText.append(""String_Node_Str"").append(""String_Node_Str"");
  for (int i=0; i < stepValue.paramCount; i++) {
    if (i + 1 == stepValue.paramCount) {
      classText.append(""String_Node_Str"").append(i);
    }
 else {
      classText.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
    }
    paramTypes.add(""String_Node_Str"");
  }
  String implementation=stepImpl.getImplementation();
  implementation=getStepImplementation(stepValue,implementation,paramTypes,stepImpl.isValidStatement());
  classText.append(""String_Node_Str"").append(implementation).append(""String_Node_Str"");
  classText.append(""String_Node_Str"");
  Util.appendToFile(Util.combinePath(getStepImplementationsDir(),""String_Node_Str""),classText.toString());
}",0.8724014336917563
25895,"/** 
 * Generate a css file that extends bootstrap to have different grid properties
 * @param num Number of columns
 * @param minify True if generated code should be minified, false otherwise
 */
private void generate(int num,boolean minify){
  try {
    if (minify) {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
 else {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
    BufferedWriter out=new BufferedWriter(new FileWriter(readFileName()));
    out.write(""String_Node_Str"" + nl + nl+ nl);
    String name[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    printInitProperties(out,name,num);
    Object[][] tableData=divisionTable.getRowData();
    for (int i=0; i < tableData.length; i++) {
      tb=""String_Node_Str"";
      if (isZeroWidth((String)tableData[i][1]))       printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
 else {
        if (!minify)         tb=""String_Node_Str"";
        out.write(nl + ""String_Node_Str"" + sp+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ sp+ ""String_Node_Str""+ nl);
        printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
        out.write(""String_Node_Str"" + nl);
      }
    }
    out.close();
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
 catch (  IOException e) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","/** 
 * Generate a css file that extends bootstrap to have different grid properties
 * @param num Number of columns
 * @param minify True if generated code should be minified, false otherwise
 */
private void generate(int num,boolean minify){
  try {
    if (minify) {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
 else {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
    BufferedWriter out=new BufferedWriter(new FileWriter(readFileName()));
    out.write(""String_Node_Str"" + nl + nl+ nl);
    Object[][] tableData=divisionTable.getRowData();
    printInitProperties(out,tableData,num);
    for (int i=0; i < tableData.length; i++) {
      tb=""String_Node_Str"";
      if (isZeroWidth((String)tableData[i][1]))       printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
 else {
        if (!minify)         tb=""String_Node_Str"";
        out.write(nl + ""String_Node_Str"" + sp+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ sp+ ""String_Node_Str""+ nl);
        printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
        out.write(""String_Node_Str"" + nl);
      }
    }
    out.close();
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
 catch (  IOException e) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}",0.9430051813471504
25896,"/** 
 * Print the initial properties that all columns share
 * @param out Output stream to file
 * @param name Array of names of different column types
 * @param num Number of columns
 * @throws IOException
 */
private void printInitProperties(BufferedWriter out,String[] name,int num) throws IOException {
  for (int i=1; i < num; i++) {
    for (int j=0; j < name.length; j++) {
      out.write(name[j] + i + ""String_Node_Str""+ nl);
    }
  }
  for (int j=0; j < name.length - 1; j++) {
    out.write(name[j] + num + ""String_Node_Str""+ nl);
  }
  out.write(name[name.length - 1] + num + sp+ ""String_Node_Str""+ nl);
  Object[][] tableData=propertyTable.getRowData();
  for (int i=0; i < tableData.length - 1; i++) {
    out.write(sp + sp + tableData[i][0]+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ nl);
  }
  out.write(sp + sp + tableData[tableData.length - 1][0]+ ""String_Node_Str""+ sp+ tableData[tableData.length - 1][1]+ sc+ nl);
  out.write(""String_Node_Str"" + nl + nl);
}","/** 
 * Print the initial properties that all columns share
 * @param out Output stream to file
 * @param name Array of names of different column types
 * @param num Number of columns
 * @throws IOException
 */
private void printInitProperties(BufferedWriter out,Object[][] name,int num) throws IOException {
  for (int i=1; i < num; i++) {
    for (int j=0; j < name.length; j++) {
      out.write(""String_Node_Str"" + name[j][0] + ""String_Node_Str""+ i+ ""String_Node_Str""+ nl);
    }
  }
  for (int j=0; j < name.length - 1; j++) {
    out.write(""String_Node_Str"" + name[j][0] + ""String_Node_Str""+ num+ ""String_Node_Str""+ nl);
  }
  out.write(""String_Node_Str"" + name[name.length - 1][0] + ""String_Node_Str""+ num+ sp+ ""String_Node_Str""+ nl);
  Object[][] tableData=propertyTable.getRowData();
  for (int i=0; i < tableData.length - 1; i++) {
    out.write(sp + sp + tableData[i][0]+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ nl);
  }
  out.write(sp + sp + tableData[tableData.length - 1][0]+ ""String_Node_Str""+ sp+ tableData[tableData.length - 1][1]+ sc+ nl);
  out.write(""String_Node_Str"" + nl + nl);
}",0.91725768321513
25897,"/** 
 * Constructor
 */
public BootstrapGridGenerator(){
  setSize(200,200);
  setBackground(Color.white);
  setLayout(new BorderLayout());
  setSize(500,500);
  northPanel=new JPanel(new BorderLayout());
  northPanel.setBackground(Color.white);
  JPanel pn1=new JPanel();
  JPanel pn2=new JPanel();
  pn1.setBackground(Color.white);
  pn2.setBackground(Color.white);
  titleLabel=new JLabel(""String_Node_Str"");
  titleLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  pn1.add(titleLabel);
  fileNameLabel=new JLabel(""String_Node_Str"");
  pn2.add(fileNameLabel);
  fileNameField=new JTextField(10);
  fileNameField.setText(""String_Node_Str"");
  pn2.add(fileNameField);
  pn2.add(Box.createRigidArea(new Dimension(20,0)));
  numberColumnsLabel=new JLabel(""String_Node_Str"");
  pn2.add(numberColumnsLabel);
  numberColumnsField=new JTextField(3);
  ((AbstractDocument)numberColumnsField.getDocument()).setDocumentFilter(new NumberDocumentFilter());
  numberColumnsField.setText(""String_Node_Str"");
  pn2.add(numberColumnsField);
  northPanel.add(pn1,BorderLayout.NORTH);
  northPanel.add(pn2,BorderLayout.SOUTH);
  add(northPanel,BorderLayout.NORTH);
  tabPane=new JTabbedPane();
  String colNames[]={""String_Node_Str"",""String_Node_Str""};
  String rowData[][]={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  propertyTable=new TablePanel(rowData,colNames);
  tabPane.addTab(""String_Node_Str"",propertyTable);
  String colNames2[]={""String_Node_Str"",""String_Node_Str""};
  String rowData2[][]={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  divisionTable=new TablePanel(rowData2,colNames2);
  tabPane.addTab(""String_Node_Str"",divisionTable);
  add(tabPane,BorderLayout.CENTER);
  southPanel=new JPanel();
  southPanel.setBackground(Color.white);
  generateButton=new JButton(""String_Node_Str"");
  generateButton.addActionListener(this);
  southPanel.add(generateButton);
  minBox=new JCheckBox();
  southPanel.add(minBox);
  minLabel=new JLabel(""String_Node_Str"");
  southPanel.add(minLabel);
  add(southPanel,BorderLayout.SOUTH);
  add(Box.createRigidArea(new Dimension(10,0)),BorderLayout.WEST);
  add(Box.createRigidArea(new Dimension(10,0)),BorderLayout.EAST);
}","/** 
 * Constructor.
 */
public BootstrapGridGenerator(){
  setBackground(Color.white);
  setLayout(new BorderLayout());
  setSize(500,500);
  northPanel=new JPanel(new BorderLayout());
  northPanel.setBackground(Color.white);
  JPanel pn1=new JPanel();
  JPanel pn2=new JPanel();
  pn1.setBackground(Color.white);
  pn2.setBackground(Color.white);
  titleLabel=new JLabel(""String_Node_Str"");
  titleLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  pn1.add(titleLabel);
  fileNameLabel=new JLabel(""String_Node_Str"");
  pn2.add(fileNameLabel);
  fileNameField=new JTextField(10);
  fileNameField.setText(""String_Node_Str"");
  pn2.add(fileNameField);
  pn2.add(Box.createRigidArea(new Dimension(20,0)));
  numberColumnsLabel=new JLabel(""String_Node_Str"");
  pn2.add(numberColumnsLabel);
  numberColumnsField=new JTextField(3);
  ((AbstractDocument)numberColumnsField.getDocument()).setDocumentFilter(new NumberDocumentFilter());
  numberColumnsField.setText(""String_Node_Str"");
  pn2.add(numberColumnsField);
  northPanel.add(pn1,BorderLayout.NORTH);
  northPanel.add(pn2,BorderLayout.SOUTH);
  add(northPanel,BorderLayout.NORTH);
  tabPane=new JTabbedPane();
  String colNames[]={""String_Node_Str"",""String_Node_Str""};
  String rowData[][]={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  propertyTable=new TablePanel(rowData,colNames);
  tabPane.addTab(""String_Node_Str"",propertyTable);
  String colNames2[]={""String_Node_Str"",""String_Node_Str""};
  String rowData2[][]={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  divisionTable=new TablePanel(rowData2,colNames2);
  tabPane.addTab(""String_Node_Str"",divisionTable);
  add(tabPane,BorderLayout.CENTER);
  southPanel=new JPanel();
  southPanel.setBackground(Color.white);
  generateButton=new JButton(""String_Node_Str"");
  generateButton.addActionListener(this);
  southPanel.add(generateButton);
  minBox=new JCheckBox();
  southPanel.add(minBox);
  minLabel=new JLabel(""String_Node_Str"");
  southPanel.add(minLabel);
  add(southPanel,BorderLayout.SOUTH);
  add(Box.createRigidArea(new Dimension(10,0)),BorderLayout.WEST);
  add(Box.createRigidArea(new Dimension(10,0)),BorderLayout.EAST);
}",0.9799296503207118
25898,"/** 
 * Analyzes a string to determine whether or not it is indicating a viewport width of zero If the first character is 0 and is not followed by another digit or radix point, it is taken as zero 
 * @param str String to be analyzed
 * @return Returns true if the string is determined to mean zero, false otherwise.
 */
private boolean isZeroWidth(String str){
  return (str.charAt(0) == '0' && (str.length() == 1 || (!Character.isDigit(str.charAt(1)) && str.charAt(1) != '.')));
}","/** 
 * Analyzes a string to determine whether or not it is indicating a view-port width of zero. If the string is empty, it is taken as zero. If the first character is 0 and is not followed by another digit or radix point, it is taken as zero.
 * @param str - String to be analyzed.
 * @return Returns true if the string is determined to mean zero, false otherwise.
 */
private boolean isZeroWidth(String str){
  return (str.equals(""String_Node_Str"") || str.charAt(0) == '0' && (str.length() == 1 || (!Character.isDigit(str.charAt(1)) && str.charAt(1) != '.')));
}",0.9188156638013372
25899,"/** 
 * Loads and sets the icons for the frame.
 * @param frame The frame for which icons are being set.
 */
private static void setFrameIcons(JFrame frame){
  ArrayList<BufferedImage> icons=new ArrayList<BufferedImage>();
  try {
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
  }
 catch (  IOException e) {
  }
  frame.setIconImages(icons);
}","/** 
 * Loads and sets the icons for the frame.
 * @param frame - The frame for which icons are being set.
 */
private static void setFrameIcons(JFrame frame){
  ArrayList<BufferedImage> icons=new ArrayList<BufferedImage>();
  try {
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
    icons.add(ImageIO.read(frame.getClass().getResource(""String_Node_Str"")));
  }
 catch (  IOException e) {
  }
  frame.setIconImages(icons);
}",0.9983606557377048
25900,"/** 
 * Print properties of each of each column type
 * @param out Output stream to file
 * @param name Name of the column
 * @param num Number of columns
 * @throws IOException
 */
private void printColProperties(BufferedWriter out,String name,int num) throws IOException {
  for (int i=1; i < num; i++) {
    out.write(tb + name + i+ ""String_Node_Str""+ nl);
  }
  out.write(tb + name + num+ sp+ ""String_Node_Str""+ nl+ tb+ sp+ sp+ ""String_Node_Str""+ sp+ ""String_Node_Str""+ sc+ nl+ tb+ ""String_Node_Str""+ nl);
  printColItem(out,name,""String_Node_Str"",num,1);
  printColItem(out,name + ""String_Node_Str"",""String_Node_Str"",num,0);
  printColItem(out,name + ""String_Node_Str"",""String_Node_Str"",num,0);
  printColItem(out,name + ""String_Node_Str"",""String_Node_Str"",num,0);
}","/** 
 * Print properties of each of each column type.
 * @param out - Output stream to file.
 * @param name - Name of the column.
 * @param num - Number of columns.
 * @throws IOException
 */
private void printColProperties(BufferedWriter out,String name,int num) throws IOException {
  printColItem(out,name,""String_Node_Str"",num,1);
  printColItem(out,name + ""String_Node_Str"",""String_Node_Str"",num,0);
  printColItem(out,name + ""String_Node_Str"",""String_Node_Str"",num,0);
  printColItem(out,name + ""String_Node_Str"",""String_Node_Str"",num,0);
}",0.8139711465451784
25901,"/** 
 * Print properties of sub-types of each column type
 * @param out Output stream to file
 * @param name Name of the column
 * @param property css property that is being defined
 * @param num Number of columns
 * @param start Starting point of classes (either 0 or 1)
 * @throws IOException
 */
private void printColItem(BufferedWriter out,String name,String property,int num,int start) throws IOException {
  double inc=100.0 / num;
  for (int i=start; i < num + 1; i++) {
    out.write(nl + tb + name+ i+ sp+ ""String_Node_Str""+ nl+ tb+ sp+ sp+ property+ ""String_Node_Str""+ sp+ (inc * i)+ ""String_Node_Str""+ sc+ nl+ tb+ ""String_Node_Str""+ nl);
  }
}","/** 
 * Print properties of sub-types of each column type.
 * @param out - Output stream to file.
 * @param name - Name of the column.
 * @param property - Css property that is being defined.
 * @param num - Number of columns.
 * @param start - Starting point of classes (either 0 or 1).
 * @throws IOException
 */
private void printColItem(BufferedWriter out,String name,String property,int num,int start) throws IOException {
  double inc=100.0 / num;
  for (int i=start; i < num + 1; i++) {
    out.write(nl + tb + name+ i+ sp+ ""String_Node_Str""+ nl+ tb+ sp+ sp+ property+ ""String_Node_Str""+ sp+ (inc * i)+ ""String_Node_Str""+ sc+ nl+ tb+ ""String_Node_Str""+ nl);
  }
}",0.986404833836858
25902,"/** 
 * Main method
 * @param args
 */
public static void main(String[] args){
  BootstrapGridGenerator gridGen=new BootstrapGridGenerator();
  JFrame frame=new JFrame();
  frame.setSize(gridGen.getWidth(),gridGen.getHeight());
  frame.setVisible(true);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  setFrameIcons(frame);
  frame.getContentPane().add(gridGen,BorderLayout.CENTER);
  frame.validate();
}","/** 
 * Main method.
 * @param args
 */
public static void main(String[] args){
  BootstrapGridGenerator gridGen=new BootstrapGridGenerator();
  JFrame frame=new JFrame();
  frame.setSize(gridGen.getWidth(),gridGen.getHeight());
  frame.setVisible(true);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  setFrameIcons(frame);
  frame.getContentPane().add(gridGen,BorderLayout.CENTER);
  frame.validate();
}",0.9989373007438896
25903,"/** 
 * Generate a css file that extends bootstrap to have different grid properties
 * @param num Number of columns
 * @param minify True if generated code should be minified, false otherwise
 */
private void generate(int num,boolean minify){
  try {
    if (minify) {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
 else {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
    BufferedWriter out=new BufferedWriter(new FileWriter(readFileName()));
    out.write(""String_Node_Str"" + nl + nl+ nl);
    Object[][] tableData=divisionTable.getRowData();
    printInitProperties(out,tableData,num);
    for (int i=0; i < tableData.length; i++) {
      tb=""String_Node_Str"";
      if (isZeroWidth((String)tableData[i][1]))       printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
 else {
        if (!minify)         tb=""String_Node_Str"";
        out.write(nl + ""String_Node_Str"" + sp+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ sp+ ""String_Node_Str""+ nl);
        printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
        out.write(""String_Node_Str"" + nl);
      }
    }
    out.close();
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
 catch (  IOException e) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","/** 
 * Generate a css file that extends bootstrap to have different grid properties.
 * @param num - Number of columns.
 * @param minify - True if generated code should be minified, false otherwise.
 */
private void generate(int num,boolean minify){
  try {
    if (minify) {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
 else {
      nl=""String_Node_Str"";
      sp=""String_Node_Str"";
      sc=""String_Node_Str"";
    }
    BufferedWriter out=new BufferedWriter(new FileWriter(readFileName()));
    if (minify)     out.write(""String_Node_Str"");
 else     out.write(""String_Node_Str"");
    Object[][] tableData=divisionTable.getRowData();
    printInitProperties(out,tableData,num);
    for (int i=0; i < tableData.length; i++) {
      tb=""String_Node_Str"";
      if (isZeroWidth((String)tableData[i][1]))       printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
 else {
        if (!minify)         tb=""String_Node_Str"";
        out.write(nl + ""String_Node_Str"" + sp+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ sp+ ""String_Node_Str""+ nl);
        printColProperties(out,""String_Node_Str"" + tableData[i][0] + ""String_Node_Str"",num);
        out.write(""String_Node_Str"" + nl);
      }
    }
    out.close();
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
  }
 catch (  IOException e) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}",0.9747458183010824
25904,"/** 
 * Print the initial properties that all columns share
 * @param out Output stream to file
 * @param name Array of names of different column types
 * @param num Number of columns
 * @throws IOException
 */
private void printInitProperties(BufferedWriter out,Object[][] name,int num) throws IOException {
  for (int i=1; i < num; i++) {
    for (int j=0; j < name.length; j++) {
      out.write(""String_Node_Str"" + name[j][0] + ""String_Node_Str""+ i+ ""String_Node_Str""+ nl);
    }
  }
  for (int j=0; j < name.length - 1; j++) {
    out.write(""String_Node_Str"" + name[j][0] + ""String_Node_Str""+ num+ ""String_Node_Str""+ nl);
  }
  out.write(""String_Node_Str"" + name[name.length - 1][0] + ""String_Node_Str""+ num+ sp+ ""String_Node_Str""+ nl);
  Object[][] tableData=propertyTable.getRowData();
  for (int i=0; i < tableData.length - 1; i++) {
    out.write(sp + sp + tableData[i][0]+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ nl);
  }
  out.write(sp + sp + tableData[tableData.length - 1][0]+ ""String_Node_Str""+ sp+ tableData[tableData.length - 1][1]+ sc+ nl);
  out.write(""String_Node_Str"" + nl + nl);
}","/** 
 * Print the initial properties that all columns share.
 * @param out - Output stream to file.
 * @param name - Array of names of different column types.
 * @param num - Number of columns.
 * @throws IOException
 */
private void printInitProperties(BufferedWriter out,Object[][] name,int num) throws IOException {
  for (int i=1; i < num; i++) {
    for (int j=0; j < name.length; j++) {
      out.write(""String_Node_Str"" + name[j][0] + ""String_Node_Str""+ i+ ""String_Node_Str""+ nl);
    }
  }
  for (int j=0; j < name.length - 1; j++) {
    out.write(""String_Node_Str"" + name[j][0] + ""String_Node_Str""+ num+ ""String_Node_Str""+ nl);
  }
  out.write(""String_Node_Str"" + name[name.length - 1][0] + ""String_Node_Str""+ num+ sp+ ""String_Node_Str""+ nl);
  Object[][] tableData=propertyTable.getRowData();
  for (int i=0; i < tableData.length - 1; i++) {
    out.write(sp + sp + tableData[i][0]+ ""String_Node_Str""+ sp+ tableData[i][1]+ ""String_Node_Str""+ nl);
  }
  out.write(sp + sp + tableData[tableData.length - 1][0]+ ""String_Node_Str""+ sp+ tableData[tableData.length - 1][1]+ sc+ nl);
  out.write(""String_Node_Str"" + nl + nl);
}",0.9955555555555556
25905,"public ListTypeFacility(int position){
  capacitySortPosition=position;
  facilityName=capacitySortPosition + ""String_Node_Str"";
  currentCapacity=position + 2;
  requiredCapacity=position + 5;
}","public ListTypeFacility(int position){
  capacitySortPosition=position;
  facilityName=(capacitySortPosition + 1) + ""String_Node_Str"";
  currentCapacity=capacitySortPosition + 2;
  requiredCapacity=capacitySortPosition + 5;
}",0.8238095238095238
25906,"private ListTypeFacilityLab(Context appContext){
  mAppContext=appContext;
  mFacilities=new ArrayList<ListTypeFacility>();
  for (int i=1; i <= 100; i++) {
    ListTypeFacility ltf=new ListTypeFacility(i);
    mFacilities.add(ltf);
  }
}","private ListTypeFacilityLab(Context appContext){
  mAppContext=appContext;
  mFacilities=new ArrayList<ListTypeFacility>();
  for (int i=0; i < 100; i++) {
    ListTypeFacility ltf=new ListTypeFacility(i);
    mFacilities.add(ltf);
  }
}",0.9936842105263158
25907,"public Map<String,Object> getRecurrenceData(){
  if (name == null) {
    return null;
  }
  Map<String,Object> recurrenceData=new HashMap<>();
  Map<String,Object> configData=new HashMap<>();
  recurrenceData.put(NAME,name);
  if (name.equalsIgnoreCase(WEEKLY)) {
    configData.put(DAYS,days);
    recurrenceData.put(CONFIG,configData);
    recurrenceData.put(STEP,step);
  }
 else   if (name.equalsIgnoreCase(MONTHLY)) {
    configData.put(REPEAT_ON,repeat_on);
    recurrenceData.put(CONFIG,configData);
    recurrenceData.put(STEP,step);
  }
  recurrenceData.put(UNTIL,until);
  return recurrenceData;
}","public Map<String,Object> getRecurrenceData(){
  if (name == null) {
    return null;
  }
  Map<String,Object> recurrenceData=new HashMap<>();
  Map<String,Object> configData=new HashMap<>();
  recurrenceData.put(NAME,name);
  if (name.equalsIgnoreCase(WEEKLY)) {
    configData.put(DAYS,days);
    recurrenceData.put(CONFIG,configData);
    recurrenceData.put(STEP,step);
  }
 else   if (name.equalsIgnoreCase(MONTHLY)) {
    configData.put(REPEAT_ON,repeat_on);
    recurrenceData.put(CONFIG,configData);
    recurrenceData.put(STEP,step);
  }
 else {
    recurrenceData.put(CONFIG,configData);
  }
  recurrenceData.put(UNTIL,until);
  return recurrenceData;
}",0.9566587864460204
25908,"private CreateData addReminderRecurrenceInfo(CreateData createData){
  for (  Entry<String,List<Field.Value>> entry : unverifiedFieldValues.entrySet()) {
    String key=entry.getKey();
    if (key.equalsIgnoreCase(ReminderRecurrenceField.NAME)) {
      ReminderRecurrenceField.Value data=(ReminderRecurrenceField.Value)entry.getValue().get(0);
      if (data.getReminderData() != null) {
        createData.setReminder(data.getReminderData());
      }
      if (data.getRecurrenceData() != null) {
        createData.setRecurrence(data.getRecurrenceData());
      }
    }
    break;
  }
  return createData;
}","private CreateData addReminderRecurrenceInfo(CreateData createData){
  for (  Entry<String,List<Field.Value>> entry : unverifiedFieldValues.entrySet()) {
    String key=entry.getKey();
    if (key.equalsIgnoreCase(ReminderRecurrenceField.NAME)) {
      ReminderRecurrenceField.Value data=(ReminderRecurrenceField.Value)entry.getValue().get(0);
      if (data.getReminderData() != null) {
        createData.setReminder(data.getReminderData());
      }
      if (data.getRecurrenceData() != null) {
        createData.setRecurrence(data.getRecurrenceData());
      }
      break;
    }
  }
  return createData;
}",0.9918032786885246
25909,"public Settings(Boolean calendar,String time){
  this.calendar=calendar;
  this.time=time;
}","public Settings(Boolean calendar,String time,Boolean isCreateViewEditHidden){
  this.calendar=calendar;
  this.time=time;
  this.isCreateViewEditHidden=isCreateViewEditHidden;
}",0.6840148698884758
25910,"public DateField(CalculationField calculationField){
  super(calculationField);
  this.config=new Configuration(new Settings(calculationField.getConfiguration().isCalendar(),calculationField.getConfiguration().getTimeState()));
  this.values=new ArrayList<>();
  for (  Field.Value calcValue : calculationField.getValues()) {
    this.values.add((DateField.Value)calcValue);
  }
}","public DateField(CalculationField calculationField){
  super(calculationField);
  final CalculationField.Configuration configuration=calculationField.getConfiguration();
  this.config=new Configuration(new Settings(configuration.isCalendar(),configuration.getTimeState(),configuration.getIsHiddenCreateViewEdit()));
  this.values=new ArrayList<>();
  for (  Field.Value calcValue : calculationField.getValues()) {
    this.values.add((DateField.Value)calcValue);
  }
}",0.7358490566037735
25911,"public NumberField(CalculationField calculationField){
  super(calculationField);
  config=new Configuration(new Settings(calculationField.getConfiguration().getNumberOfDecimals()));
  this.values=new ArrayList<>();
  for (  Field.Value calcValue : calculationField.getValues()) {
    this.values.add((NumberField.Value)calcValue);
  }
}","public NumberField(CalculationField calculationField){
  super(calculationField);
  final CalculationField.Configuration configuration=calculationField.getConfiguration();
  config=new Configuration(new Settings(configuration.getNumberOfDecimals(),configuration.getIsHiddenCreateViewEdit()));
  this.values=new ArrayList<>();
  for (  Field.Value calcValue : calculationField.getValues()) {
    this.values.add((NumberField.Value)calcValue);
  }
}",0.7576530612244898
25912,"public Settings(Integer decimals){
  this.decimals=decimals;
}","public Settings(Integer decimals,boolean isCreateViewEdithidden){
  this.decimals=decimals;
  this.isCreateViewEditHidden=isCreateViewEdithidden;
}",0.5933014354066986
25913,"public Configuration(){
  settings=new Settings();
}","public Configuration(Settings settings){
  this.settings=settings;
}",0.6833333333333333
25914,"public TextField(CalculationField calculationField){
  super(calculationField);
  config=new Configuration();
  this.values=new ArrayList<>();
  for (  Field.Value calcValue : calculationField.getValues()) {
    this.values.add((TextField.Value)calcValue);
  }
}","public TextField(CalculationField calculationField){
  super(calculationField);
  config=new Configuration(new Settings(calculationField.getConfiguration().getIsHiddenCreateViewEdit()));
  this.values=new ArrayList<>();
  for (  Field.Value calcValue : calculationField.getValues()) {
    this.values.add((TextField.Value)calcValue);
  }
}",0.8718801996672213
25915,"@Override public void addValue(Value value){
  if (values != null && !values.contains(value)) {
    values.add(0,value);
  }
}","@Override public void addValue(Value value){
  if (values != null && !values.contains(value)) {
    values.add(value);
  }
}",0.992
25916,"@Override protected VolleyError parseNetworkError(VolleyError volleyError){
  if (volleyError instanceof NoConnectionError && volleyError.getCause() instanceof UnknownHostException) {
    error=new ConnectionError(volleyError);
  }
 else   if (volleyError instanceof TimeoutError) {
    error=new NoResponseError(volleyError);
  }
 else {
    String errorJson=getResponseBody(volleyError.networkResponse);
    int responseCode=getResponseCode(volleyError.networkResponse);
    if (Utils.notEmpty(errorJson) && responseCode > 0) {
      error=new ApiError(errorJson,responseCode,volleyError);
    }
 else {
      try {
        error=new PodioError(volleyError);
      }
 catch (      Exception e) {
        error=new PodioError(""String_Node_Str"");
        error.setStackTrace(e.getStackTrace());
      }
    }
  }
synchronized (this) {
    notifyAll();
  }
  return volleyError;
}","@Override protected VolleyError parseNetworkError(VolleyError volleyError){
  if (volleyError instanceof NoConnectionError && volleyError.getCause() instanceof UnknownHostException) {
    error=new ConnectionError(volleyError);
  }
 else   if (volleyError instanceof TimeoutError) {
    error=new NoResponseError(volleyError);
  }
 else {
    String errorJson=getResponseBody(volleyError.networkResponse);
    int responseCode=getResponseCode(volleyError.networkResponse);
    if (Utils.notEmpty(errorJson) && responseCode > 0) {
      try {
        error=new ApiError(errorJson,responseCode,volleyError);
      }
 catch (      JsonSyntaxException jsonSyntaxException) {
        handleNoneJsonError(volleyError);
      }
    }
 else {
      handleNoneJsonError(volleyError);
    }
  }
synchronized (this) {
    notifyAll();
  }
  return volleyError;
}",0.7653179190751445
25917,"@Override public Map<String,Object> getCreateData(){
  HashMap<String,Object> data=null;
  if (createData != null) {
    data=new HashMap<String,Object>();
    data.put(""String_Node_Str"",createData);
  }
  return data;
}","@Override public Map<String,Object> getCreateData(){
  HashMap<String,Object> data=new HashMap<String,Object>();
  if (createData != null) {
    data.put(""String_Node_Str"",createData);
  }
 else   if (value != null) {
    data.put(""String_Node_Str"",value.getId());
  }
 else {
    data=null;
  }
  return data;
}",0.6127819548872181
25918,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  Value value1=(Value)o;
  if (value != null ? !value.equals(value1.value) : value1.value != null)   return false;
  return !(createData != null ? !createData.equals(value1.createData) : value1.createData != null);
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  Value value1=(Value)o;
  if (value != null ? !value.equals(value1.value) : value1.value != null)   return false;
  if (value.equals(value1.value))   return true;
  return !(createData != null ? !createData.equals(value1.createData) : value1.createData != null);
}",0.9352708058124174
25919,"/** 
 * Create a contact field value based on a space object
 * @param space
 */
public Value(Space space){
  createData=new ContactCreateData(space.getSpaceId(),CreateData.CreateDataTypes.space);
}","/** 
 * Create a contact field value based on a space object
 * @param space
 */
public Value(Space space){
  value=null;
  createData=new ContactCreateData(space.getSpaceId(),CreateData.CreateDataTypes.space);
}",0.9658536585365852
25920,public T waitForResult(long maxSeconds);,"/** 
 * Make sure to catch any thrown PodioError
 * @param maxSeconds
 * @return
 * @throws PodioError
 */
public T waitForResult(long maxSeconds) throws PodioError ;",0.3883495145631068
25921,"public void addErrorListener(ErrorListener listener,boolean deliverErrorNow,Throwable error){
  if (listener != null) {
    if (deliverErrorNow) {
      listener.onErrorOccured(error);
    }
 else {
synchronized (ERROR_LISTENER_LOCK) {
        errorListeners.add(listener);
      }
    }
  }
}","public void addErrorListener(ErrorListener listener,boolean deliverErrorNow,Throwable error){
  if (listener != null) {
    if (deliverErrorNow) {
      listener.onErrorOccurred(error);
    }
 else {
synchronized (ERROR_LISTENER_LOCK) {
        errorListeners.add(listener);
      }
    }
  }
}",0.9982964224872232
25922,"public void deliverError(Throwable error){
synchronized (RESULT_LISTENER_LOCK) {
    resultListeners.clear();
  }
  if (Utils.isEmpty(errorListeners) && Utils.isEmpty(GLOBAL_ERROR_LISTENERS)) {
    throw new PodioError(error);
  }
synchronized (ERROR_LISTENER_LOCK) {
    boolean isConsumed=false;
    for (    ErrorListener listener : errorListeners) {
      if (listener != null) {
        if (listener.onErrorOccured(error)) {
          isConsumed=true;
          break;
        }
      }
    }
    errorListeners.clear();
    if (isConsumed) {
      return;
    }
  }
  for (  ErrorListener listener : GLOBAL_ERROR_LISTENERS) {
    if (listener != null) {
      if (listener.onErrorOccured(error)) {
        return;
      }
    }
  }
}","public void deliverError(Throwable error){
synchronized (RESULT_LISTENER_LOCK) {
    resultListeners.clear();
  }
  if (Utils.isEmpty(errorListeners) && Utils.isEmpty(GLOBAL_ERROR_LISTENERS)) {
    throw new PodioError(error);
  }
synchronized (ERROR_LISTENER_LOCK) {
    boolean isConsumed=false;
    for (    ErrorListener listener : errorListeners) {
      if (listener != null) {
        if (listener.onErrorOccurred(error)) {
          isConsumed=true;
          break;
        }
      }
    }
    errorListeners.clear();
    if (isConsumed) {
      return;
    }
  }
  for (  ErrorListener listener : GLOBAL_ERROR_LISTENERS) {
    if (listener != null) {
      if (listener.onErrorOccurred(error)) {
        return;
      }
    }
  }
}",0.9986486486486488
25923,"@Override public void retry(VolleyError error) throws VolleyError {
  super.retry(error);
  String accessToken=Utils.notEmpty(originalAccessToken) ? originalAccessToken : ""String_Node_Str"";
  if (error instanceof AuthFailureError && accessToken.equals(Session.accessToken())) {
    Uri uri=buildAuthUri();
    if (uri == null) {
      clearRequestQueue();
      throw error;
    }
    String url=parseUrl(uri);
    HashMap<String,String> params=parseParams(uri);
    VolleyRequest<Void> reAuthRequest=VolleyRequest.newAuthRequest(url,params);
    reAuthRequest.setRetryPolicy(new DefaultRetryPolicy(CLIENT_DEFAULT_TIMEOUT_MS,0,0));
    addToRefreshQueue(reAuthRequest);
    reAuthRequest.withErrorListener(new Request.ErrorListener(){
      @Override public boolean onErrorOccured(      Throwable cause){
        clearRequestQueue();
        return true;
      }
    }
).waitForResult(TimeUnit.MILLISECONDS.toSeconds(CLIENT_DEFAULT_TIMEOUT_MS));
  }
}","@Override public void retry(VolleyError error) throws VolleyError {
  super.retry(error);
  String accessToken=Utils.notEmpty(originalAccessToken) ? originalAccessToken : ""String_Node_Str"";
  if (error instanceof AuthFailureError && accessToken.equals(Session.accessToken())) {
    Uri uri=buildAuthUri();
    if (uri == null) {
      clearRequestQueue();
      throw error;
    }
    String url=parseUrl(uri);
    HashMap<String,String> params=parseParams(uri);
    VolleyRequest<Void> reAuthRequest=VolleyRequest.newAuthRequest(url,params);
    reAuthRequest.setRetryPolicy(new DefaultRetryPolicy(CLIENT_DEFAULT_TIMEOUT_MS,0,0));
    addToRefreshQueue(reAuthRequest);
    reAuthRequest.withErrorListener(new Request.ErrorListener(){
      @Override public boolean onErrorOccurred(      Throwable cause){
        clearRequestQueue();
        return true;
      }
    }
).waitForResult(TimeUnit.MILLISECONDS.toSeconds(CLIENT_DEFAULT_TIMEOUT_MS));
  }
}",0.999474513925381
25924,"public void deliverError(Throwable error){
  if (Utils.isEmpty(errorListeners) && Utils.isEmpty(GLOBAL_ERROR_LISTENERS)) {
    throw new PodioError(error);
  }
  for (  ErrorListener listener : errorListeners) {
    if (listener != null) {
      if (listener.onErrorOccured(error)) {
        return;
      }
    }
  }
  for (  ErrorListener listener : GLOBAL_ERROR_LISTENERS) {
    if (listener != null) {
      if (listener.onErrorOccured(error)) {
        return;
      }
    }
  }
}","public void deliverError(Throwable error){
  resultListeners.clear();
  if (Utils.isEmpty(errorListeners) && Utils.isEmpty(GLOBAL_ERROR_LISTENERS)) {
    throw new PodioError(error);
  }
  for (  ErrorListener listener : errorListeners) {
    if (listener != null) {
      if (listener.onErrorOccured(error)) {
        errorListeners.clear();
        return;
      }
      errorListeners.remove(listener);
    }
  }
  for (  ErrorListener listener : GLOBAL_ERROR_LISTENERS) {
    if (listener != null) {
      if (listener.onErrorOccured(error)) {
        return;
      }
    }
  }
}",0.8951310861423221
25925,"public void deliverResult(T result){
  for (  ResultListener<T> listener : resultListeners) {
    if (listener != null) {
      if (listener.onRequestPerformed(result)) {
        break;
      }
    }
  }
}","public void deliverResult(T result){
  errorListeners.clear();
  for (  ResultListener<T> listener : resultListeners) {
    if (listener != null) {
      if (listener.onRequestPerformed(result)) {
        resultListeners.clear();
        break;
      }
      resultListeners.remove(listener);
    }
  }
}",0.8055009823182712
25926,"void deliverSession(){
  String accessToken=Session.accessToken();
  String refreshToken=Session.refreshToken();
  long expires=Session.expires();
  for (  SessionListener listener : sessionListeners) {
    if (listener != null) {
      if (listener.onSessionChanged(accessToken,refreshToken,expires)) {
        return;
      }
    }
  }
  for (  SessionListener listener : GLOBAL_SESSION_LISTENERS) {
    if (listener != null) {
      if (listener.onSessionChanged(accessToken,refreshToken,expires)) {
        return;
      }
    }
  }
}","void deliverSession(){
  String accessToken=Session.accessToken();
  String refreshToken=Session.refreshToken();
  long expires=Session.expires();
  for (  SessionListener listener : sessionListeners) {
    if (listener != null) {
      if (listener.onSessionChanged(accessToken,refreshToken,expires)) {
        sessionListeners.clear();
        return;
      }
      sessionListeners.remove(listener);
    }
  }
  for (  SessionListener listener : GLOBAL_SESSION_LISTENERS) {
    if (listener != null) {
      if (listener.onSessionChanged(accessToken,refreshToken,expires)) {
        return;
      }
    }
  }
}",0.9348392701998264
25927,"public void addErrorListener(ErrorListener listener,boolean deliverErrorNow,Throwable error){
  if (listener != null) {
    errorListeners.add(listener);
    if (deliverErrorNow) {
      listener.onErrorOccured(error);
    }
  }
}","public void addErrorListener(ErrorListener listener,boolean deliverErrorNow,Throwable error){
  if (listener != null) {
    if (deliverErrorNow) {
      listener.onErrorOccured(error);
    }
 else {
      errorListeners.add(listener);
    }
  }
}",0.8067226890756303
25928,"public void addResultListener(ResultListener<T> listener,boolean deliverResultNow,T result){
  if (listener != null) {
    resultListeners.add(listener);
    if (deliverResultNow) {
      listener.onRequestPerformed(result);
    }
  }
}","public void addResultListener(ResultListener<T> listener,boolean deliverResultNow,T result){
  if (listener != null) {
    if (deliverResultNow) {
      listener.onRequestPerformed(result);
    }
 else {
      resultListeners.add(listener);
    }
  }
}",0.6475409836065574
25929,"void addSessionListener(SessionListener listener,boolean deliverSessionNow){
  if (listener != null) {
    sessionListeners.add(listener);
    if (deliverSessionNow) {
      listener.onSessionChanged(Session.accessToken(),Session.refreshToken(),Session.expires());
    }
  }
}","void addSessionListener(SessionListener listener,boolean deliverSessionNow){
  if (listener != null) {
    if (deliverSessionNow) {
      listener.onSessionChanged(Session.accessToken(),Session.refreshToken(),Session.expires());
    }
 else {
      sessionListeners.add(listener);
    }
  }
}",0.8309859154929577
25930,"private HashMap<String,ArrayList<Event>> parseEventData(String json){
  HashMap<String,ArrayList<Event>> result=new HashMap<String,ArrayList<Event>>();
  if (Utils.isEmpty(json)) {
    return result;
  }
  JsonParser jsonParser=new JsonParser();
  JsonElement root=jsonParser.parse(json);
  JsonArray jsonElements;
  if (root.isJsonArray()) {
    jsonElements=root.getAsJsonArray();
  }
 else   if (root.isJsonObject()) {
    jsonElements=new JsonArray();
    jsonElements.add(root.getAsJsonObject());
  }
 else {
    return result;
  }
  JsonObject jsonObject;
  Gson gson=new Gson();
  for (  JsonElement jsonElement : jsonElements) {
    if (jsonElement.isJsonObject()) {
      jsonObject=jsonElement.getAsJsonObject();
      JsonObject fayeData=getJsonObject(jsonObject,""String_Node_Str"");
      JsonObject podioData=getJsonObject(fayeData,""String_Node_Str"");
      String key=getString(jsonObject,""String_Node_Str"");
      String type=getString(podioData,""String_Node_Str"");
      try {
        Event.Type eventType=Event.Type.valueOf(type);
        Event event=gson.fromJson(fayeData,eventType.getClassObject());
        addEventToMap(key,event,result);
      }
 catch (      NullPointerException e) {
      }
catch (      IllegalArgumentException e) {
      }
    }
  }
  return null;
}","private HashMap<String,ArrayList<Event>> parseEventData(String json){
  HashMap<String,ArrayList<Event>> result=new HashMap<String,ArrayList<Event>>();
  if (Utils.isEmpty(json)) {
    return result;
  }
  JsonParser jsonParser=new JsonParser();
  JsonElement root=jsonParser.parse(json);
  JsonArray jsonElements;
  if (root.isJsonArray()) {
    jsonElements=root.getAsJsonArray();
  }
 else   if (root.isJsonObject()) {
    jsonElements=new JsonArray();
    jsonElements.add(root.getAsJsonObject());
  }
 else {
    return result;
  }
  JsonObject jsonObject;
  Gson gson=new Gson();
  for (  JsonElement jsonElement : jsonElements) {
    if (jsonElement.isJsonObject()) {
      jsonObject=jsonElement.getAsJsonObject();
      JsonObject fayeData=getJsonObject(jsonObject,""String_Node_Str"");
      JsonObject podioData=getJsonObject(fayeData,""String_Node_Str"");
      String key=getString(jsonObject,""String_Node_Str"");
      String type=getString(podioData,""String_Node_Str"");
      try {
        Event.Type eventType=Event.Type.valueOf(type);
        Event event=gson.fromJson(podioData,eventType.getClassObject());
        addEventToMap(key,event,result);
      }
 catch (      NullPointerException e) {
      }
catch (      IllegalArgumentException e) {
      }
    }
  }
  return null;
}",0.9965210668728256
25931,"/** 
 * Removes the given listener from the stated push channel. If   {@code null}is provided as listener, then all listeners will be removed. If there are no more listeners listening for events at the stated channel, a termination request will be sent to the Podio API.
 */
@Override public void unsubscribe(String channel,ResultListener<Event[]> listener){
  if (listener == null) {
    if (subscriptions.containsKey(channel)) {
      subscriptions.remove(channel);
      execute(new UnsubscribeRequest(channel,transport));
    }
  }
 else {
    if (subscriptions.containsKey(channel)) {
      ArrayList<EventListener> listeners=subscriptions.get(channel);
      listeners.remove(listener);
      if (listeners.size() == 0) {
        subscriptions.remove(channel);
        execute(new UnsubscribeRequest(channel,transport));
      }
    }
  }
  if (subscriptions.isEmpty()) {
    execute(new DisconnectRequest(transport));
  }
}","/** 
 * Removes the given listener from the stated push channel. If   {@code null}is provided as listener, then all listeners will be removed. If there are no more listeners listening for events at the stated channel, a termination request will be sent to the Podio API.
 */
@Override public void unsubscribe(String channel,EventListener listener){
  if (listener == null) {
    if (subscriptions.containsKey(channel)) {
      subscriptions.remove(channel);
      execute(new UnsubscribeRequest(channel,transport));
    }
  }
 else {
    if (subscriptions.containsKey(channel)) {
      ArrayList<EventListener> listeners=subscriptions.get(channel);
      listeners.remove(listener);
      if (listeners.size() == 0) {
        subscriptions.remove(channel);
        execute(new UnsubscribeRequest(channel,transport));
      }
    }
  }
  if (subscriptions.isEmpty()) {
    execute(new DisconnectRequest(transport));
  }
}",0.6172972972972973
25932,"public void unsubscribe(String channel,ResultListener<Event[]> listener);","public void unsubscribe(String channel,EventListener listener);",0.8823529411764706
25933,"/** 
 * Fetches the events for the conversation with the given id.
 * @param id The id of the conversation.
 * @param limit The number of events to fetch.
 * @param offset The number of events to skip before start fetching.
 * @return A ticket which the caller can use to identify this request with.
 */
public Request<Conversation.Event> getConversationMessages(long id,int limit,int offset){
  Path filter=new Path().withEvents(id,limit,offset);
  return get(filter,Conversation.Event.class);
}","/** 
 * Fetches the events for the conversation with the given id.
 * @param id The id of the conversation.
 * @param limit The number of events to fetch.
 * @param offset The number of events to skip before start fetching.
 * @return A ticket which the caller can use to identify this request with.
 */
public Request<Conversation.Event[]> getConversationMessages(long id,int limit,int offset){
  Path filter=new Path().withEvents(id,limit,offset);
  return get(filter,Conversation.Event[].class);
}",0.9959839357429718
25934,"/** 
 * Removes the given listener from the stated push channel. If   {@code null}is provided as listener, then all listeners will be removed. If there are no more listeners listening for events at the stated channel, a termination request will be sent to the Podio API.
 */
@Override public Request<Void> unsubscribe(String channel,ResultListener<?> listener){
  if (listener != null) {
    if (subscriptions.containsKey(channel)) {
      subscriptions.get(channel).listeners.remove(listener);
    }
    return null;
  }
 else {
    if (subscriptions.containsKey(channel)) {
      subscriptions.remove(channel);
    }
    UnsubscribeRequest request=new UnsubscribeRequest(channel,transport);
    execute(request);
    return request;
  }
}","/** 
 * Removes the given listener from the stated push channel. If   {@code null}is provided as listener, then all listeners will be removed. If there are no more listeners listening for events at the stated channel, a termination request will be sent to the Podio API.
 */
@Override public Request<Void> unsubscribe(String channel,ResultListener<?> listener){
  if (listener == null) {
    if (subscriptions.containsKey(channel)) {
      subscriptions.remove(channel);
      UnsubscribeRequest request=new UnsubscribeRequest(channel,transport);
      execute(request);
      return request;
    }
  }
 else {
    if (subscriptions.containsKey(channel)) {
      Subscription subscription=subscriptions.get(channel);
      subscription.listeners.remove(listener);
      if (subscription.listeners.size() == 0) {
        subscription=null;
        subscriptions.remove(channel);
        UnsubscribeRequest request=new UnsubscribeRequest(channel,transport);
        execute(request);
        return request;
      }
    }
  }
  return null;
}",0.5764044943820225
25935,"protected static Status send(Transport transport,Object data){
  String json=transport.send(data);
  Status status=buildStatusObject(json);
  if (!status.isSuccess()) {
switch (status.advicedReconnectApproach()) {
case unknown:
      break;
case handshake:
    open(transport).validate();
case retry:
  connect(transport).validate();
default :
json=transport.send(data);
status=buildStatusObject(json);
}
}
status.validate();
return status;
}","protected static Status send(Transport transport,Object data){
  if (state == Machine.created || state == Machine.error) {
    state=open(transport).isSuccess() ? Machine.handshaken : Machine.error;
  }
  if (state == Machine.handshaken) {
    state=connect(transport).isSuccess() ? Machine.connected : Machine.error;
  }
  String json=transport.send(data);
  Status status=buildStatusObject(json);
  if (!status.isSuccess()) {
    state=Machine.error;
switch (status.advicedReconnectApproach()) {
case unknown:
      break;
case handshake:
    open(transport).validate();
  state=Machine.handshaken;
case retry:
connect(transport).validate();
state=Machine.connected;
default :
json=transport.send(data);
status=buildStatusObject(json);
}
}
status.validate();
state=Machine.success;
return status;
}",0.7085346215780999
25936,"@Override public void run(){
  listener.onRequestPerformed(result);
}","@Override public void run(){
  for (  final ResultListener<T> listener : resultListeners) {
    if (listener != null) {
      if (listener.onRequestPerformed(result)) {
        return;
      }
    }
  }
}",0.4981684981684982
25937,"/** 
 * Reports a delivered error to all error listeners. The callback implementations will be called on the Main thread.
 */
private void notifyErrorListeners(){
  Handler handler=new Handler(Looper.getMainLooper());
  for (  final ErrorListener listener : errorListeners) {
    if (listener != null) {
      handler.post(new Runnable(){
        @Override public void run(){
          listener.onErrorOccured(error);
        }
      }
);
    }
  }
}","/** 
 * Reports a delivered error to all error listeners. The callback implementations will be called on the Main thread.
 */
private void notifyErrorListeners(){
  Handler handler=new Handler(Looper.getMainLooper());
  handler.post(new Runnable(){
    @Override public void run(){
      for (      final ErrorListener listener : errorListeners) {
        if (listener != null) {
          if (listener.onErrorOccured(error)) {
            return;
          }
        }
      }
    }
  }
);
}",0.7112526539278131
25938,"/** 
 * Reports a delivered result to all result listeners. The callback implementations will be called on the Main thread.
 */
private void notifyResultListeners(){
  Handler handler=new Handler(Looper.getMainLooper());
  for (  final ResultListener<T> listener : resultListeners) {
    if (listener != null) {
      handler.post(new Runnable(){
        @Override public void run(){
          listener.onRequestPerformed(result);
        }
      }
);
    }
  }
}","/** 
 * Reports a delivered result to all result listeners. The callback implementations will be called on the Main thread.
 */
private void notifyResultListeners(){
  Handler handler=new Handler(Looper.getMainLooper());
  handler.post(new Runnable(){
    @Override public void run(){
      for (      final ResultListener<T> listener : resultListeners) {
        if (listener != null) {
          if (listener.onRequestPerformed(result)) {
            return;
          }
        }
      }
    }
  }
);
}",0.7355371900826446
25939,"/** 
 * Initializes the Podio SDK with the given client credentials. This method MUST be called before any other request is made.
 * @param context The context to initialize the cache database and network clients in.
 * @param authority The host the SDK will target with its requests.
 * @param clientId The pre-shared Podio client id.
 * @param clientSecret The corresponding Podio client secret.
 * @param sslSocketFactory Optional custom SSL socket factory to use in the HTTP requests.
 */
public static void setup(Context context,String scheme,String authority,String clientId,String clientSecret,SSLSocketFactory sslSocketFactory){
  restClient.setup(context,scheme,authority,clientId,clientSecret,sslSocketFactory);
  application.setClient(restClient);
  calendar.setClient(restClient);
  client.setClient(restClient);
  item.setClient(restClient);
  organization.setClient(restClient);
  user.setClient(restClient);
  view.setClient(restClient);
}","/** 
 * Initializes the Podio SDK with the given client credentials. This method MUST be called before any other request is made.
 * @param context The context to initialize the cache database and network clients in.
 * @param authority The host the SDK will target with its requests.
 * @param clientId The pre-shared Podio client id.
 * @param clientSecret The corresponding Podio client secret.
 * @param sslSocketFactory Optional custom SSL socket factory to use in the HTTP requests.
 */
public static void setup(Context context,String scheme,String authority,String clientId,String clientSecret,SSLSocketFactory sslSocketFactory){
  restClient.setup(context,scheme,authority,clientId,clientSecret,sslSocketFactory);
  application.setClient(restClient);
  calendar.setClient(restClient);
  client.setClient(restClient);
  item.setClient(restClient);
  organization.setClient(restClient);
  user.setClient(restClient);
  view.setClient(restClient);
  task.setClient(restClient);
}",0.9845201238390092
25940,"public GetTaskFilter(){
  this.fullView();
}","public GetTaskFilter(){
  addPathSegment(""String_Node_Str"");
  this.fullView();
}",0.704
25941,"public Request<Task[]> getTasks(TaskFilter filter){
  return get(filter,Task[].class);
}","public Request<Task[]> getTasks(GetTaskFilter filter){
  return get(filter,Task[].class);
}",0.9832402234636872
25942,"Path withWorkspaceId(int spaceId){
  addPathSegment(""String_Node_Str"");
  addPathSegment(Long.toString(spaceId,10));
  return this;
}","Path withWorkspaceId(long spaceId){
  addPathSegment(""String_Node_Str"");
  addPathSegment(Long.toString(spaceId,10));
  return this;
}",0.9812734082397004
25943,"/** 
 * Fetches all space calendar events.
 * @param spaceId The id of the workspace from which to fetch the calendar events.
 * @param from The Date from which the result should start from.
 * @param to The Date from which the result should end at.
 * @param priority The priority level of the results.
 * @param includeTasks Boolean true to include tasks in the calendar. Boolean false otherwise.
 * @return
 */
public Request<CalendarEvent[]> getSpaceCalendar(int spaceId,Date from,Date to,int priority,boolean includeTasks){
  Path filter=new Path().withWorkspaceId(spaceId).withDate(from,to).withPriority(priority).withTasks(includeTasks).withWorkspaceNameField();
  return get(filter,CalendarEvent[].class);
}","/** 
 * Fetches all space calendar events.
 * @param spaceId The id of the workspace from which to fetch the calendar events.
 * @param from The Date from which the result should start from.
 * @param to The Date from which the result should end at.
 * @param priority The priority level of the results.
 * @param includeTasks Boolean true to include tasks in the calendar. Boolean false otherwise.
 * @return
 */
public Request<CalendarEvent[]> getSpaceCalendar(long spaceId,Date from,Date to,int priority,boolean includeTasks){
  Path filter=new Path().withWorkspaceId(spaceId).withDate(from,to).withPriority(priority).withTasks(includeTasks).withWorkspaceNameField();
  return get(filter,CalendarEvent[].class);
}",0.9951083158630328
25944,"@Override public Field deserialize(JsonElement element,Type type,JsonDeserializationContext gsonContext) throws JsonParseException {
  if (element == null || element.isJsonNull()) {
    return null;
  }
  JsonObject jsonObject=element.getAsJsonObject();
  if (!jsonObject.has(""String_Node_Str"")) {
    jsonObject.add(""String_Node_Str"",new JsonArray());
  }
  Field.Type typeEnum=Field.Type.undefined;
  JsonElement fieldType=jsonObject.get(""String_Node_Str"");
  if (fieldType != null && !fieldType.isJsonNull()) {
    try {
      typeEnum=Enum.valueOf(Field.Type.class,fieldType.getAsString());
    }
 catch (    IllegalArgumentException e) {
    }
  }
  if (typeEnum == Field.Type.undefined) {
    jsonObject.addProperty(""String_Node_Str"",Field.Type.undefined.name());
  }
  return gsonContext.deserialize(jsonObject,typeEnum.getFieldClass());
}","@Override public Field deserialize(JsonElement element,Type type,JsonDeserializationContext gsonContext) throws JsonParseException {
  if (element == null || element.isJsonNull()) {
    return null;
  }
  JsonObject jsonObject=element.getAsJsonObject();
  if (!jsonObject.has(""String_Node_Str"")) {
    jsonObject.add(""String_Node_Str"",new JsonArray());
  }
  Field.Type typeEnum=Field.Type.undefined;
  JsonElement fieldType=jsonObject.get(""String_Node_Str"");
  if (fieldType != null && !fieldType.isJsonNull()) {
    try {
      typeEnum=Field.Type.valueOf(fieldType.getAsString());
    }
 catch (    IllegalArgumentException e) {
    }
  }
  if (typeEnum == Field.Type.undefined) {
    jsonObject.addProperty(""String_Node_Str"",Field.Type.undefined.name());
  }
  return gsonContext.deserialize(jsonObject,typeEnum.getFieldClass());
}",0.9815585960737656
25945,"/** 
 * Determines whether the given object can be used as value for this field or not.
 * @param value The object to use as value.
 * @return A type specific value representation of the given object.
 * @throws FieldTypeMismatchException If the given object can't be used as value for this field.
 */
private MapValue validateValue(Object value) throws FieldTypeMismatchException {
  if (value instanceof MapValue) {
    return (MapValue)value;
  }
 else   if (value instanceof MapValue.Data) {
    return new MapValue((MapValue.Data)value);
  }
 else   if (value instanceof String) {
    return new MapValue(value.toString());
  }
 else {
    throw new FieldTypeMismatchException();
  }
}","/** 
 * Determines whether the given object can be used as value for this field or not.
 * @param value The object to use as value.
 * @return A type specific value representation of the given object.
 * @throws FieldTypeMismatchException If the given object can't be used as value for this field.
 */
private MapValue validateValue(Object value) throws FieldTypeMismatchException {
  if (value instanceof MapValue) {
    return (MapValue)value;
  }
 else   if (value instanceof String) {
    return new MapValue(value.toString());
  }
 else {
    throw new FieldTypeMismatchException();
  }
}",0.9243959469992206
25946,"/** 
 * Determines whether the given object can be used as value for this field or not.
 * @param value The object to use as value.
 * @return A type specific value representation of the given object.
 * @throws FieldTypeMismatchException If the given object can't be used as value for this field.
 */
private MoneyValue validateValue(Object value) throws FieldTypeMismatchException {
  if (value instanceof MoneyValue) {
    return (MoneyValue)value;
  }
 else   if (value instanceof MoneyValue.Data) {
    return new MoneyValue((MoneyValue.Data)value);
  }
 else   if (value instanceof String[]) {
    String[] v=(String[])value;
    if (v.length == 2) {
      return new MoneyValue(v[0],v[1]);
    }
 else {
      throw new FieldTypeMismatchException();
    }
  }
 else {
    throw new FieldTypeMismatchException();
  }
}","/** 
 * Determines whether the given object can be used as value for this field or not.
 * @param value The object to use as value.
 * @return A type specific value representation of the given object.
 * @throws FieldTypeMismatchException If the given object can't be used as value for this field.
 */
private MoneyValue validateValue(Object value) throws FieldTypeMismatchException {
  if (value instanceof MoneyValue) {
    return (MoneyValue)value;
  }
 else   if (value instanceof String[]) {
    String[] v=(String[])value;
    if (v.length == 2) {
      return new MoneyValue(v[0],v[1]);
    }
 else {
      throw new FieldTypeMismatchException();
    }
  }
 else {
    throw new FieldTypeMismatchException();
  }
}",0.9333333333333332
25947,"public double getLongitude(){
  return value != null ? value.getLongitude() : 0.0D;
}","public double getLongitude(){
  return Utils.getNative(lng,0.0D);
}",0.6973684210526315
25948,"public String getCountry(){
  return value != null ? value.getCountry() : null;
}","public String getCountry(){
  return country;
}",0.71875
25949,"public double getLatitude(){
  return value != null ? value.getLatitude() : 0.0D;
}","public double getLatitude(){
  return Utils.getNative(lat,0.0D);
}",0.738255033557047
25950,"public MapValue(String value){
  this.value=new Data(value);
}","public MapValue(String value){
  this.value=value;
}",0.912280701754386
25951,"public String getPostalCode(){
  return value != null ? value.getPostalCode() : null;
}","public String getPostalCode(){
  return postal_code;
}",0.723404255319149
25952,"public String getFormattedLocation(){
  return value != null ? value.getFormattedLocation() : null;
}","public String getFormattedLocation(){
  return formatted;
}",0.725
25953,"public String getValue(){
  return value != null ? value.getValue() : null;
}","public String getValue(){
  return value;
}",0.7166666666666667
25954,"public String getState(){
  return value != null ? value.getState() : null;
}","public String getState(){
  return state;
}",0.7
25955,"@Override public Object getPushData(){
  HashMap<String,String> data=null;
  if (value != null && value.value != null) {
    data=new HashMap<String,String>();
    data.put(""String_Node_Str"",value.value);
  }
  return data;
}","@Override public Object getPushData(){
  HashMap<String,String> data=null;
  if (value != null && value != null) {
    data=new HashMap<String,String>();
    data.put(""String_Node_Str"",value);
  }
  return data;
}",0.9726027397260274
25956,"@Override public int hashCode(){
  return this.value != null && this.value.value != null ? this.value.value.hashCode() : 0;
}","@Override public int hashCode(){
  return this.value != null && this.value != null ? this.value.hashCode() : 0;
}",0.9495798319327732
25957,"@Override public boolean equals(Object o){
  if (o instanceof MapValue) {
    MapValue other=(MapValue)o;
    if (other.value != null && other.value.value != null && this.value != null) {
      return other.value.equals(this.value.value);
    }
  }
  return false;
}","@Override public boolean equals(Object o){
  if (o instanceof MapValue) {
    MapValue other=(MapValue)o;
    if (other.value != null && other.value != null && this.value != null) {
      return other.value.equals(this.value);
    }
  }
  return false;
}",0.9769230769230768
25958,"public String getStreetName(){
  return value != null ? value.getStreetName() : null;
}","public String getStreetName(){
  return street_name;
}",0.723404255319149
25959,"public String getStreetNumber(){
  return value != null ? value.getStreetNumber() : null;
}","public String getStreetNumber(){
  return street_number;
}",0.738255033557047
25960,"public String getCity(){
  return value != null ? value.getCity() : null;
}","public String getCity(){
  return city;
}",0.6896551724137931
25961,"public String getCurrency(){
  return value != null ? value.getCurrency() : null;
}","public String getCurrency(){
  return currency;
}",0.7272727272727273
25962,"public String getValue(){
  return value != null ? value.getValue() : null;
}","public String getValue(){
  return value;
}",0.7166666666666667
25963,"@Override public Object getPushData(){
  HashMap<String,String> data=null;
  if (value != null && value.currency != null && value.value != null) {
    data=new HashMap<String,String>();
    data.put(""String_Node_Str"",value.currency);
    data.put(""String_Node_Str"",value.value);
  }
  return data;
}","@Override public Object getPushData(){
  HashMap<String,String> data=null;
  if (value != null && currency != null && value != null) {
    data=new HashMap<String,String>();
    data.put(""String_Node_Str"",currency);
    data.put(""String_Node_Str"",value);
  }
  return data;
}",0.9581881533101044
25964,"@Override public int hashCode(){
  String c=this.value.currency;
  String v=this.value.value;
  return c != null && v != null ? (c + v).hashCode() : 0;
}","@Override public int hashCode(){
  String c=currency;
  String v=value;
  return c != null && v != null ? (c + v).hashCode() : 0;
}",0.9225352112676056
25965,"@Override public boolean equals(Object o){
  if (o instanceof MoneyValue) {
    MoneyValue other=(MoneyValue)o;
    if (other.value != null && other.value.currency != null && other.value.value != null && this.value != null) {
      return other.value.currency.equals(this.value.currency) && other.value.value.equals(this.value.value);
    }
  }
  return false;
}","@Override public boolean equals(Object o){
  if (o instanceof MoneyValue) {
    MoneyValue other=(MoneyValue)o;
    if (other.value != null && other.currency != null && other.value != null && this.value != null) {
      return other.currency.equals(this.currency) && other.value.equals(this.value);
    }
  }
  return false;
}",0.8953488372093024
25966,"public MoneyValue(String currency,String value){
  this.value=new MoneyValue.Data(currency,value);
}","public MoneyValue(String currency,String value){
  this.currency=currency;
  this.value=value;
}",0.7346938775510204
25967,"void reportToListeners(final Handler handler,final WeakReference<T> customListener,final List<WeakReference<T>> globalListeners){
  if (handler != null) {
    handler.post(new Runnable(){
      @Override public void run(){
        boolean didConsumeEvent=false;
        if (customListener != null) {
          didConsumeEvent=executeReport(customListener);
        }
        if (!didConsumeEvent && globalListeners != null && !globalListeners.isEmpty()) {
          for (          WeakReference<T> reference : globalListeners) {
            if (reference.get() != null) {
              if (executeReport(reference)) {
                break;
              }
            }
 else {
              reference.clear();
              globalListeners.remove(reference);
            }
          }
        }
      }
    }
);
  }
}","void reportToListeners(final Handler handler,final WeakReference<T> customListener,final List<WeakReference<T>> globalListeners){
  if (handler != null) {
    handler.post(new Runnable(){
      @Override public void run(){
        boolean didConsumeEvent=false;
        if (customListener != null && customListener.get() != null) {
          didConsumeEvent=executeReport(customListener);
        }
        if (!didConsumeEvent && globalListeners != null && !globalListeners.isEmpty()) {
          for (          WeakReference<T> reference : globalListeners) {
            if (reference.get() != null) {
              if (executeReport(reference)) {
                break;
              }
            }
 else {
              reference.clear();
              globalListeners.remove(reference);
            }
          }
        }
      }
    }
);
  }
}",0.9808383233532936
25968,"@Override public void run(){
  boolean didConsumeEvent=false;
  if (customListener != null) {
    didConsumeEvent=executeReport(customListener);
  }
  if (!didConsumeEvent && globalListeners != null && !globalListeners.isEmpty()) {
    for (    WeakReference<T> reference : globalListeners) {
      if (reference.get() != null) {
        if (executeReport(reference)) {
          break;
        }
      }
 else {
        reference.clear();
        globalListeners.remove(reference);
      }
    }
  }
}","@Override public void run(){
  boolean didConsumeEvent=false;
  if (customListener != null && customListener.get() != null) {
    didConsumeEvent=executeReport(customListener);
  }
  if (!didConsumeEvent && globalListeners != null && !globalListeners.isEmpty()) {
    for (    WeakReference<T> reference : globalListeners) {
      if (reference.get() != null) {
        if (executeReport(reference)) {
          break;
        }
      }
 else {
        reference.clear();
        globalListeners.remove(reference);
      }
    }
  }
}",0.9691119691119692
25969,"private RestResult<T> getResultNow(){
  try {
    return get();
  }
 catch (  InterruptedException e) {
    throw PodioException.fromThrowable(e);
  }
catch (  ExecutionException e) {
    if (e.getCause() instanceof PodioException) {
      throw (PodioException)e.getCause();
    }
 else {
      throw PodioException.fromThrowable(e);
    }
  }
}","private RestResult<T> getResultNow(){
  try {
    return get();
  }
 catch (  InterruptedException e) {
    return null;
  }
catch (  ExecutionException e) {
    return null;
  }
}",0.6425855513307985
25970,"public static VolleyRequest newRefreshRequest(Uri uri){
  RequestFuture<String> future=RequestFuture.newFuture();
  String refreshToken=uri.getQueryParameter(""String_Node_Str"");
  String url=stripQueryParameters(uri);
  VolleyRequest request=new VolleyRequest(Method.POST,url,future);
  request.contentType=""String_Node_Str"";
  request.params.put(""String_Node_Str"",""String_Node_Str"");
  request.params.put(""String_Node_Str"",refreshToken);
  return request;
}","public static VolleyRequest newRefreshRequest(Uri uri){
  return newAuthRequest(uri);
}",0.3082568807339449
25971,"/** 
 * Tries to set the given value to the field with the given name on this item.
 * @param field The external id of the field.
 * @param value The field type specific domain object describing the new value.
 * @return Boolean true. Always.
 * @throws FieldTypeMismatchException If the passed value doesn't match the field with the given name.
 */
public boolean addValue(String field,Object value) throws FieldTypeMismatchException {
  if (field != null && value != null && fields != null) {
    Field f=findField(field,fields);
    if (f != null) {
      f.addValue(value);
    }
 else {
      HashMap<String,Object> newValue=new HashMap<String,Object>();
      newValue.put(""String_Node_Str"",value);
      List<Object> values=data.get(field);
      if (values == null) {
        values=new ArrayList<Object>();
        data.put(field,values);
      }
      values.add(data);
    }
  }
  return true;
}","/** 
 * Tries to set the given value to the field with the given name on this item.
 * @param field The external id of the field.
 * @param value The field type specific domain object describing the new value.
 * @return Boolean true. Always.
 * @throws FieldTypeMismatchException If the passed value doesn't match the field with the given name.
 */
public boolean addValue(String field,Object value) throws FieldTypeMismatchException {
  if (field != null && value != null && fields != null) {
    Field f=findField(field,fields);
    if (f != null) {
      f.addValue(value);
    }
 else {
      HashMap<String,Object> newValue=new HashMap<String,Object>();
      newValue.put(""String_Node_Str"",value);
      List<Object> values=data.get(field);
      if (values == null) {
        values=new ArrayList<Object>();
        data.put(field,values);
      }
      values.add(newValue);
    }
  }
  return true;
}",0.9933920704845814
25972,"/** 
 * Constructor.
 */
public ItemProvider(){
  filter=new ItemFilterProvider();
}","/** 
 * Constructor.
 */
public ItemProvider(){
}",0.7368421052631579
25973,"/** 
 * Initializes the Podio SDK with the given client credentials. This method MUST be called before any other request is made. The caller can then either choose to revoke a previously stored session (the SDK doesn't store or cache the session), or authenticate with user or app credentials. These operations are done in the   {@link ClientAPI} area.
 * @param context The context to initialize the cache database and network clients in.
 * @param clientId The pre-shared Podio client id.
 * @param clientSecret The corresponding Podio client secret.
 * @param behavior The behavior to expect from the  {@link RestClient} implementation.
 */
public static void setup(Context context,String clientId,String clientSecret,RestBehavior behavior){
  RestClientDelegate networkDelegate=new HttpClientDelegate(context);
  client.setup(clientId,clientSecret);
switch (behavior) {
case HTTP_ONLY:
    restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
  break;
case CACHED_HTTP:
CacheClient cacheClient=new SQLiteCacheClient(context,DATABASE_NAME,DATABASE_VERSION);
restClient=new CachedRestClient(context,AUTHORITY,networkDelegate,cacheClient);
break;
default :
restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
break;
}
application.setRestClient(restClient);
calendar.setRestClient(restClient);
item.setRestClient(restClient);
organization.setRestClient(restClient);
client.setRestClient(restClient);
user.setRestClient(restClient);
}","/** 
 * Initializes the Podio SDK with the given client credentials. This method MUST be called before any other request is made. The caller can then either choose to revoke a previously stored session (the SDK doesn't store or cache the session), or authenticate with user or app credentials. These operations are done in the   {@link ClientAPI} area.
 * @param context The context to initialize the cache database and network clients in.
 * @param clientId The pre-shared Podio client id.
 * @param clientSecret The corresponding Podio client secret.
 * @param behavior The behavior to expect from the  {@link RestClient} implementation.
 */
public static void setup(Context context,String clientId,String clientSecret,RestBehavior behavior){
  networkDelegate=new HttpClientDelegate(context);
  client.setup(clientId,clientSecret);
switch (behavior) {
case HTTP_ONLY:
    restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
  break;
case CACHED_HTTP:
CacheClient cacheClient=new SQLiteCacheClient(context,DATABASE_NAME,DATABASE_VERSION);
restClient=new CachedRestClient(context,AUTHORITY,networkDelegate,cacheClient);
break;
default :
restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
break;
}
application.setRestClient(restClient);
calendar.setRestClient(restClient);
item.setRestClient(restClient);
organization.setRestClient(restClient);
client.setRestClient(restClient);
user.setRestClient(restClient);
}",0.9934505342985176
25974,"/** 
 * Initializes the Podio SDK with the given client credentials. This method MUST be called before any other request is made. The caller can then either choose to revoke a previously stored session (the SDK doesn't store or cache the session), or authenticate with user or app credentials. These operations are done in the   {@link ClientAPI} area.
 * @param context The context to initialize the cache database and network clients in.
 * @param clientId The pre-shared Podio client id.
 * @param clientSecret The corresponding Podio client secret.
 * @param behavior The behavior to expect from the  {@link RestClient} implementation.
 */
public static void setup(Context context,String clientId,String clientSecret,RestBehavior behavior){
  RestClientDelegate networkDelegate=new HttpClientDelegate(context);
  client.setup(clientId,clientSecret);
switch (behavior) {
case HTTP_ONLY:
    Podio.restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
  break;
case CACHED_HTTP:
CacheClient cacheClient=new SQLiteCacheClient(context,DATABASE_NAME,DATABASE_VERSION);
Podio.restClient=new CachedRestClient(context,AUTHORITY,networkDelegate,cacheClient);
break;
default :
Podio.restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
break;
}
}","/** 
 * Initializes the Podio SDK with the given client credentials. This method MUST be called before any other request is made. The caller can then either choose to revoke a previously stored session (the SDK doesn't store or cache the session), or authenticate with user or app credentials. These operations are done in the   {@link ClientAPI} area.
 * @param context The context to initialize the cache database and network clients in.
 * @param clientId The pre-shared Podio client id.
 * @param clientSecret The corresponding Podio client secret.
 * @param behavior The behavior to expect from the  {@link RestClient} implementation.
 */
public static void setup(Context context,String clientId,String clientSecret,RestBehavior behavior){
  RestClientDelegate networkDelegate=new HttpClientDelegate(context);
  client.setup(clientId,clientSecret);
switch (behavior) {
case HTTP_ONLY:
    restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
  break;
case CACHED_HTTP:
CacheClient cacheClient=new SQLiteCacheClient(context,DATABASE_NAME,DATABASE_VERSION);
restClient=new CachedRestClient(context,AUTHORITY,networkDelegate,cacheClient);
break;
default :
restClient=new HttpRestClient(context,AUTHORITY,networkDelegate);
break;
}
application.setRestClient(restClient);
calendar.setRestClient(restClient);
item.setRestClient(restClient);
organization.setRestClient(restClient);
client.setRestClient(restClient);
}",0.9261047159301894
25975,"/** 
 * Reports a result back to any listeners implementation.
 * @param request The request that we are reporting the result of.
 * @param result The result of the request.
 */
protected <T>void callListener(final RestRequest<T> request,final RestResult<T> result){
  SessionListener sessionListener=request.getSessionListener();
  if (sessionListener != null) {
    Session session=result.getSession();
    sessionListener.onSessionChanged(session);
  }
  ResultListener<? super T> resultListener=request.getResultListener();
  if (resultListener != null) {
    T item=result.getItem();
    resultListener.onRequestPerformed(item);
  }
  if (result.hasException()) {
    ErrorListener errorListener=request.getErrorListener();
    if (errorListener != null) {
      PodioException error=result.getException();
      errorListener.onExceptionOccurred(error);
    }
  }
}","/** 
 * Reports a result back to any listeners implementation.
 * @param request The request that we are reporting the result of.
 * @param result The result of the request.
 */
protected <T>void callListener(final RestRequest<T> request,final RestResult<T> result){
  if (result != null) {
    SessionListener sessionListener=request.getSessionListener();
    if (sessionListener != null) {
      Session session=result.getSession();
      sessionListener.onSessionChanged(session);
    }
    ResultListener<? super T> resultListener=request.getResultListener();
    if (resultListener != null) {
      T item=result.getItem();
      resultListener.onRequestPerformed(item);
    }
    if (result.hasException()) {
      ErrorListener errorListener=request.getErrorListener();
      if (errorListener != null) {
        PodioException error=result.getException();
        errorListener.onExceptionOccurred(error);
      }
    }
  }
}",0.8658536585365854
25976,"private void authorizeRequest(String url,Map<String,String> params) throws PodioException {
  RequestFuture<String> future=RequestFuture.newFuture();
  StringRequest request=new RefreshRequest(refreshUrl,params,future);
  requestQueue.add(request);
  String resultJson=getBlockingResponse(future);
  session=new Session(resultJson);
}","private void authorizeRequest(String url,Map<String,String> params) throws PodioException {
  RequestFuture<String> future=RequestFuture.newFuture();
  StringRequest request=new RefreshRequest(url,params,future);
  requestQueue.add(request);
  String resultJson=getBlockingResponse(future);
  session=new Session(resultJson);
}",0.9863842662632376
25977,"/** 
 * Constructor.
 * @param client The rest client that will access the data.
 */
public BasicPodioProvider(RestClient client){
  if (client == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  this.client=client;
}","/** 
 * Constructor.
 * @param client The rest client that will access the data.
 */
public BasicPodioProvider(){
}",0.6534090909090909
25978,"public SessionProvider(RestClient client){
  super(client);
  clientId=clientSecret=null;
}","public SessionProvider(){
  clientId=clientSecret=null;
}",0.7702702702702703
25979,"/** 
 * Verifies that the   {@link ItemProvider} calls through to the (mock) restclient with expected uri parameters when trying to fetch all items for a given application. <pre> 1. Create a new ItemProvider. 2. Try to fetch all items for a known application. 3. Verify that the designated rest client is called with a uri that contains the expected parameters. </pre>
 */
public void testFetchItemsForApplication(){
  DummyRestClient mockClient=new DummyRestClient(RestResult.success());
  ItemProvider provider=new ItemProvider(mockClient);
  @SuppressWarnings(""String_Node_Str"") ResultListener<Item.FilterResult> mockListener=Mockito.mock(ResultListener.class);
  provider.getFiltered(4L,mockListener,null,null);
  Mockito.verify(mockListener).onRequestPerformed(null);
  Mockito.verifyNoMoreInteractions(mockListener);
  Uri uri=mockClient.getMockUri();
  assertEquals(Uri.parse(""String_Node_Str""),uri);
}","/** 
 * Verifies that the   {@link ItemProvider} calls through to the (mock) restclient with expected uri parameters when trying to fetch all items for a given application. <pre> 1. Create a new ItemProvider. 2. Try to fetch all items for a known application. 3. Verify that the designated rest client is called with a uri that contains the expected parameters. </pre>
 */
public void testFetchItemsForApplication(){
  DummyRestClient mockClient=new DummyRestClient(RestResult.success());
  ItemProvider provider=new ItemProvider(mockClient);
  @SuppressWarnings(""String_Node_Str"") ResultListener<Item.FilterResult> mockListener=Mockito.mock(ResultListener.class);
  provider.getAll(4L,mockListener,null,null);
  Mockito.verify(mockListener).onRequestPerformed(null);
  Mockito.verifyNoMoreInteractions(mockListener);
  Uri uri=mockClient.getMockUri();
  assertEquals(Uri.parse(""String_Node_Str""),uri);
}",0.9939327082184224
25980,"@Override public Object getPushData(){
  HashMap<String,String> data=null;
  if (value != null) {
    data=new HashMap<String,String>();
    data.put(""String_Node_Str"",value);
  }
  return data;
}","@Override public Object getPushData(){
  HashMap<String,String> data=new HashMap<String,String>();
  data.put(""String_Node_Str"",value);
  return data;
}",0.8735632183908046
25981,"/** 
 * Reports a result back to any listeners implementation.
 * @param request The request that we are reporting the result of.
 * @param result The result of the request.
 */
protected <T>void callListener(final RestRequest<T> request,final RestResult<T> result){
  if (result != null) {
    SessionListener sessionListener=request.getSessionListener();
    if (sessionListener != null) {
      Session session=result.getSession();
      sessionListener.onSessionChanged(session);
    }
    ResultListener<? super T> resultListener=request.getResultListener();
    if (resultListener != null) {
      T item=result.getItem();
      resultListener.onRequestPerformed(item);
    }
    if (result.hasException()) {
      ErrorListener errorListener=request.getErrorListener();
      if (errorListener != null) {
        PodioException error=result.getException();
        errorListener.onExceptionOccurred(error);
      }
    }
  }
}","/** 
 * Reports a result back to any listeners implementation.
 * @param request The request that we are reporting the result of.
 * @param result The result of the request.
 */
protected <T>void callListener(final RestRequest<T> request,final RestResult<T> result){
  if (result != null) {
    if (result.hasSession()) {
      SessionListener sessionListener=request.getSessionListener();
      if (sessionListener != null) {
        Session session=result.getSession();
        sessionListener.onSessionChanged(session);
      }
    }
    if (result.hasException()) {
      ErrorListener errorListener=request.getErrorListener();
      if (errorListener != null) {
        PodioException error=result.getException();
        errorListener.onExceptionOccurred(error);
      }
    }
 else {
      ResultListener<? super T> resultListener=request.getResultListener();
      if (resultListener != null) {
        T item=result.getItem();
        resultListener.onRequestPerformed(item);
      }
    }
  }
}",0.771295818275684
25982,"@Override public boolean equals(Object o){
  boolean isEqual=o instanceof Session;
  if (isEqual) {
    Session other=(Session)o;
    isEqual=accessToken.equals(other.accessToken) && refreshToken.equals(other.refreshToken) && expiresMillis == other.expiresMillis;
  }
  return isEqual;
}","@Override public boolean equals(Object o){
  boolean isEqual=o instanceof Session;
  if (isEqual) {
    Session other=(Session)o;
    boolean accessTokensEquals=accessToken == null && other.accessToken == null || accessToken.equals(other.accessToken);
    boolean refreshTokensEquals=refreshToken == null && other.refreshToken == null || refreshToken.equals(other.refreshToken);
    boolean timeStampsEquals=expiresMillis == other.expiresMillis;
    isEqual=accessTokensEquals && refreshTokensEquals && timeStampsEquals;
  }
  return isEqual;
}",0.6546329723225031
25983,"@Override public Object getPushData(){
  ArrayList<Object> pushData=new ArrayList<Object>();
  for (  Option option : config.settings.options) {
    if (option.isPicked) {
      pushData.add(option.getPushData());
    }
  }
  return pushData;
}","@Override public Object getPushData(){
  ArrayList<Object> pushData=new ArrayList<Object>();
  if (config != null && config.settings != null && config.settings.options != null) {
    for (    Option option : config.settings.options) {
      if (option.isPicked) {
        pushData.add(option.getPushData());
      }
    }
  }
  return pushData;
}",0.8101694915254237
25984,"@Override public boolean set(Object value) throws FieldTypeMismatchException {
  Data data=tryCast(value);
  clear(data);
  try {
    values.add(new Value(data));
  }
 catch (  UnsupportedOperationException e) {
    throw new FieldTypeMismatchException(e);
  }
catch (  ClassCastException e) {
    throw new FieldTypeMismatchException(e);
  }
catch (  IllegalArgumentException e) {
    throw new FieldTypeMismatchException(e);
  }
  return true;
}","@Override public boolean set(Object value) throws FieldTypeMismatchException {
  boolean isSuccess=false;
  Data data=tryCast(value);
  clear(data);
  if (values != null) {
    isSuccess=values.add(new Value(data));
  }
  return isSuccess;
}",0.4825581395348837
25985,"@Override public boolean clear(Object value) throws FieldTypeMismatchException {
  Data data=tryCast(value);
  Value v=new Value(data);
  try {
    values.remove(v);
  }
 catch (  UnsupportedOperationException e) {
    throw new FieldTypeMismatchException(e);
  }
  return true;
}","@Override public boolean clear(Object value) throws FieldTypeMismatchException {
  boolean isSuccess=false;
  Data data=tryCast(value);
  Value v=new Value(data);
  if (values != null) {
    values.remove(v);
    isSuccess=true;
  }
  return isSuccess;
}",0.6329588014981273
25986,"@Override public boolean set(Object value) throws FieldTypeMismatchException {
  Option option=tryCast(value);
  clear(option);
  try {
    values.add(new Value(option));
  }
 catch (  UnsupportedOperationException e) {
    throw new FieldTypeMismatchException(e);
  }
catch (  ClassCastException e) {
    throw new FieldTypeMismatchException(e);
  }
catch (  IllegalArgumentException e) {
    throw new FieldTypeMismatchException(e);
  }
  return true;
}","@Override public boolean set(Object value) throws FieldTypeMismatchException {
  boolean isSuccess=false;
  Option option=tryCast(value);
  clear(option);
  if (values != null) {
    isSuccess=values.add(new Value(option));
  }
  return isSuccess;
}",0.4943181818181818
25987,"@Override public boolean clear(Object value) throws FieldTypeMismatchException {
  Option option=tryCast(value);
  Value v=new Value(option);
  try {
    values.remove(v);
  }
 catch (  UnsupportedOperationException e) {
    throw new FieldTypeMismatchException(e);
  }
  return true;
}","@Override public boolean clear(Object value) throws FieldTypeMismatchException {
  boolean isSuccess=false;
  Option option=tryCast(value);
  Value v=new Value(option);
  if (values != null) {
    values.remove(v);
    isSuccess=true;
  }
  return isSuccess;
}",0.6410256410256411
25988,"/** 
 * Tries to locally set the given value to the current field. The changes are NOT updated on the servers by this method call.
 * @param value The value domain object to set.
 * @return Always boolean true.
 * @throws FieldTypeMismatchException If the value can't be applied to this field type.
 */
public abstract boolean set(Object value) throws FieldTypeMismatchException ;","/** 
 * Tries to locally set the given value to the current field. The changes are NOT updated on the servers by this method call.
 * @param value The value domain object to set.
 * @return Boolean true if the new value could be set, boolean falseotherwise.
 * @throws FieldTypeMismatchException If the value can't be applied to this field type.
 */
public abstract boolean set(Object value) throws FieldTypeMismatchException ;",0.8996282527881041
25989,"/** 
 * Tries to locally clear the given value from the current field. The changes are NOT updated on the servers by this method call.
 * @param value The value domain object to clear.
 * @return Always boolean true.
 * @throws FieldTypeMismatchException If the value can't be applied to this field type.
 */
public abstract boolean clear(Object value) throws FieldTypeMismatchException ;","/** 
 * Tries to locally clear the given value from the current field. The changes are NOT updated on the servers by this method call.
 * @param value The value domain object to clear.
 * @return Boolean true if the value could be cleared, boolean falseotherwise.
 * @throws FieldTypeMismatchException If the value can't be applied to this field type.
 */
public abstract boolean clear(Object value) throws FieldTypeMismatchException ;",0.9015795868772782
25990,"@Override public boolean set(Object value) throws FieldTypeMismatchException {
  String text=tryCast(value);
  values.clear();
  values.add(new Value(text));
  return true;
}","@Override public boolean set(Object value) throws FieldTypeMismatchException {
  boolean isSuccess=false;
  String text=tryCast(value);
  clear(value);
  if (values != null) {
    isSuccess=values.add(new Value(text));
  }
  return isSuccess;
}",0.6842105263157895
25991,"@Override public Object getPushData(){
  ArrayList<Object> pushData=new ArrayList<Object>();
  for (  Value value : values) {
    pushData.add(value.getPushData());
  }
  return pushData;
}","@Override public Object getPushData(){
  ArrayList<Object> pushData=new ArrayList<Object>();
  if (values != null) {
    for (    Value value : values) {
      pushData.add(value.getPushData());
    }
  }
  return pushData;
}",0.9130434782608696
25992,"/** 
 * @see com.podio.sdk.domain.field.Field#clear(java.lang.Object)
 */
@Override public boolean clear(Object value) throws FieldTypeMismatchException {
  values.clear();
  return true;
}","@Override public boolean clear(Object value) throws FieldTypeMismatchException {
  boolean isSuccess=false;
  if (values != null) {
    values.clear();
    isSuccess=true;
  }
  return isSuccess;
}",0.5854922279792746
25993,"/** 
 * Performs the parsing of the given domain model object to a json string.
 * @param item The item to parse.
 * @return A json string representation of the given item.
 */
public String parseToJson(Object item){
  String result=""String_Node_Str"";
  if (item != null) {
    GsonBuilder builder=new GsonBuilder();
    builder.disableHtmlEscaping();
    Gson gson=builder.create();
    result=gson.toJson(item);
  }
  return result;
}","/** 
 * Performs the parsing of the given domain model object to a json string.
 * @param item The item to parse.
 * @return A json string representation of the given item.
 */
public String parseToJson(Object item){
  String result=null;
  if (item != null) {
    GsonBuilder builder=new GsonBuilder();
    builder.disableHtmlEscaping();
    Gson gson=builder.create();
    result=gson.toJson(item);
  }
  return result;
}",0.9755529685681024
25994,"@Override public Field deserialize(JsonElement element,Type type,JsonDeserializationContext gsonContext) throws JsonParseException {
  JsonObject jsonObject=element != null ? element.getAsJsonObject() : null;
  JsonElement fieldType=jsonObject != null ? jsonObject.get(""String_Node_Str"") : null;
  String fieldTypeName=fieldType != null ? fieldType.getAsString() : null;
  Field.Type typeEnum=Field.Type.valueOf(fieldTypeName);
switch (typeEnum) {
case app:
    return gsonContext.deserialize(element,ApplicationReference.class);
case calculation:
  return gsonContext.deserialize(element,CalculationField.class);
case category:
return gsonContext.deserialize(element,Category.class);
case contact:
return gsonContext.deserialize(element,ContactField.class);
case date:
return gsonContext.deserialize(element,DateField.class);
case duration:
return gsonContext.deserialize(element,DurationField.class);
case embed:
return gsonContext.deserialize(element,EmbedField.class);
case image:
return gsonContext.deserialize(element,ImageField.class);
case location:
return gsonContext.deserialize(element,LocationField.class);
case money:
return gsonContext.deserialize(element,MoneyField.class);
case number:
return gsonContext.deserialize(element,NumberField.class);
case progress:
return gsonContext.deserialize(element,ProgressField.class);
case text:
return gsonContext.deserialize(element,Text.class);
case title:
return gsonContext.deserialize(element,TitleField.class);
default :
return gsonContext.deserialize(element,Text.class);
}
}","@Override public Field deserialize(JsonElement element,Type type,JsonDeserializationContext gsonContext) throws JsonParseException {
  JsonObject jsonObject=element != null && !element.isJsonNull() ? element.getAsJsonObject() : null;
  JsonElement fieldType=jsonObject != null && !jsonObject.isJsonNull() ? jsonObject.get(""String_Node_Str"") : null;
  String fieldTypeName=fieldType != null && !fieldType.isJsonNull() ? fieldType.getAsString() : Field.Type.undefined.name();
  Field.Type typeEnum;
  try {
    typeEnum=Field.Type.valueOf(fieldTypeName);
  }
 catch (  IllegalArgumentException e) {
    typeEnum=Field.Type.undefined;
  }
switch (typeEnum) {
case app:
    return gsonContext.deserialize(element,ApplicationReference.class);
case calculation:
  return gsonContext.deserialize(element,CalculationField.class);
case category:
return gsonContext.deserialize(element,Category.class);
case contact:
return gsonContext.deserialize(element,ContactField.class);
case date:
return gsonContext.deserialize(element,DateField.class);
case duration:
return gsonContext.deserialize(element,DurationField.class);
case embed:
return gsonContext.deserialize(element,EmbedField.class);
case image:
return gsonContext.deserialize(element,ImageField.class);
case location:
return gsonContext.deserialize(element,LocationField.class);
case money:
return gsonContext.deserialize(element,MoneyField.class);
case number:
return gsonContext.deserialize(element,NumberField.class);
case progress:
return gsonContext.deserialize(element,ProgressField.class);
case text:
return gsonContext.deserialize(element,TextField.class);
case title:
return gsonContext.deserialize(element,TitleField.class);
default :
JsonObject empty=new JsonObject();
empty.addProperty(""String_Node_Str"",Field.Type.undefined.name());
return gsonContext.deserialize(empty,EmptyField.class);
}
}",0.8943329397874853
25995,"/** 
 * Performs the parsing of the given json string to domain model representation.
 * @param json The json string to parse.
 * @return A domain model representation of the given json string.
 */
public T parseToItem(String source){
  T result=null;
  if (Utils.notEmpty(source)) {
    result=new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).registerTypeAdapter(Field.class,new FieldDeserializer()).create().fromJson(source,classOfItem);
  }
  return result;
}","/** 
 * Performs the parsing of the given json string to domain model representation.
 * @param json The json string to parse.
 * @return A domain model representation of the given json string.
 */
public T parseToItem(String source){
  T result=null;
  if (source != null && Utils.notEmpty(source.trim())) {
    result=new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).registerTypeAdapter(Field.class,new FieldDeserializer()).create().fromJson(source,classOfItem);
  }
  return result;
}",0.975562072336266
25996,"/** 
 * Fetches all Organizations (including a minimal set of information on the contained workspaces) that are available to the user.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getAll(PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Organization[]> parser=new ItemParser<com.podio.sdk.domain.Organization[]>(com.podio.sdk.domain.Organization[].class);
  client.setItemParser(parser);
  OrganizationProvider provider=new OrganizationProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.getAll();
}","/** 
 * Fetches all Organizations (including a minimal set of information on the contained workspaces) that are available to the user.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getAll(PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Organization[]> parser=new ItemParser<com.podio.sdk.domain.Organization[]>(com.podio.sdk.domain.Organization[].class);
  OrganizationProvider provider=new OrganizationProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  provider.setItemParser(parser);
  return provider.getAll();
}",0.9577464788732394
25997,"/** 
 * Fetches all App items, including the inactive ones, in the workspace with the given id.
 * @param spaceId The id of the parent workspace.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getForSpaceIncludingInactive(long spaceId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Application[]> parser=new ItemParser<com.podio.sdk.domain.Application[]>(com.podio.sdk.domain.Application[].class);
  client.setItemParser(parser);
  ApplicationProvider provider=new ApplicationProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.fetchApplicationsForSpaceWithInactivesIncluded(spaceId);
}","/** 
 * Fetches all App items, including the inactive ones, in the workspace with the given id.
 * @param spaceId The id of the parent workspace.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getForSpaceIncludingInactive(long spaceId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Application[]> parser=new ItemParser<com.podio.sdk.domain.Application[]>(com.podio.sdk.domain.Application[].class);
  ApplicationProvider provider=new ApplicationProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  provider.setItemParser(parser);
  return provider.fetchApplicationsForSpaceWithInactivesIncluded(spaceId);
}",0.8826237054085155
25998,"/** 
 * Fetches all App items in the workspace with the given id.
 * @param spaceId The id of the parent workspace.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getForSpace(long spaceId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Application[]> parser=new ItemParser<com.podio.sdk.domain.Application[]>(com.podio.sdk.domain.Application[].class);
  client.setItemParser(parser);
  ApplicationProvider provider=new ApplicationProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.fetchApplicationsForSpace(spaceId);
}","/** 
 * Fetches all App items in the workspace with the given id.
 * @param spaceId The id of the parent workspace.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getForSpace(long spaceId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Application[]> parser=new ItemParser<com.podio.sdk.domain.Application[]>(com.podio.sdk.domain.Application[].class);
  ApplicationProvider provider=new ApplicationProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  provider.setItemParser(parser);
  return provider.fetchApplicationsForSpace(spaceId);
}",0.898876404494382
25999,"/** 
 * Authenticates the caller with the given app credentials. On success a new session object with the access and refresh tokens will be delivered through the given   {@link PodioProviderListener}.
 * @param appId The id of the app to authenticate with.
 * @param appToken The token that has been generated for a particular app.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object authenticateAsApp(String appId,String appToken,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Session> parser=new ItemParser<com.podio.sdk.domain.Session>(com.podio.sdk.domain.Session.class);
  client.setItemParser(parser);
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.authenticateWithAppCredentials(clientId,clientSecret,appId,appToken);
}","/** 
 * Authenticates the caller with the given app credentials. On success a new session object with the access and refresh tokens will be delivered through the given   {@link PodioProviderListener}.
 * @param appId The id of the app to authenticate with.
 * @param appToken The token that has been generated for a particular app.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object authenticateAsApp(String appId,String appToken,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Session> parser=new ItemParser<com.podio.sdk.domain.Session>(com.podio.sdk.domain.Session.class);
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  provider.setItemParser(parser);
  return provider.authenticateWithAppCredentials(clientId,clientSecret,appId,appToken);
}",0.8901623686723973
26000,"/** 
 * Authenticates the caller with the given user credentials. On success a new session object with the access and refresh tokens will be delivered through the given   {@link PodioProviderListener}.
 * @param username The user name of the Podio account to authenticate with.
 * @param password The corresponding password of the Podio account.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object authenticateAsUser(String username,String password,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Session> parser=new ItemParser<com.podio.sdk.domain.Session>(com.podio.sdk.domain.Session.class);
  client.setItemParser(parser);
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.authenticateWithUserCredentials(clientId,clientSecret,username,password);
}","/** 
 * Authenticates the caller with the given user credentials. On success a new session object with the access and refresh tokens will be delivered through the given   {@link PodioProviderListener}.
 * @param username The user name of the Podio account to authenticate with.
 * @param password The corresponding password of the Podio account.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object authenticateAsUser(String username,String password,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Session> parser=new ItemParser<com.podio.sdk.domain.Session>(com.podio.sdk.domain.Session.class);
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  provider.setItemParser(parser);
  return provider.authenticateWithUserCredentials(clientId,clientSecret,username,password);
}",0.8886810102899907
