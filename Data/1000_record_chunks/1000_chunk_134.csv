record_number,buggy_code,fixed_code,code_similarity
133001,"/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  boolean canReorder=true;
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    if (SUPER_DEBUG) {
      pipe.setValidator(Validate.standardValidator());
    }
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if ((iteration % 3) == 2) {
      pipe.addPass(new LoopUnroller());
      pipe.addPass(Validate.standardValidator());
    }
    boolean lastHalf=iteration > nIterations * 2;
    if (canReorder) {
      pipe.addPass(new HoistLoops(lastHalf));
    }
    if (canReorder && (iteration % 2 == 1)) {
      pipe.addPass(new ReorderInstructions(lastHalf));
    }
    if (iteration == nIterations - 2) {
      canReorder=false;
    }
    pipe.addPass(new ForwardDataflow(!canReorder));
    pipe.addPass(new DeadCodeEliminator());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 1) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges,canReorder));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}","/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  boolean canReorder=true;
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    if (SUPER_DEBUG) {
      pipe.setValidator(Validate.standardValidator());
    }
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if ((iteration % 3) == 2) {
      pipe.addPass(new LoopUnroller());
      pipe.addPass(Validate.standardValidator());
    }
    boolean lastHalf=iteration > nIterations * 2;
    if (canReorder) {
      pipe.addPass(new HoistLoops(lastHalf));
    }
    if (canReorder && (iteration % 2 == 1)) {
      pipe.addPass(new ReorderInstructions(lastHalf));
    }
    if (iteration == nIterations - 2) {
      canReorder=false;
    }
    pipe.addPass(new ForwardDataflow(canReorder));
    pipe.addPass(new DeadCodeEliminator());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 1) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges,canReorder));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}",0.9996988858777476
133002,"/** 
 * @param logger
 * @param ancestorBlock the block the instructions are moved from
 * @param ancestors 
 * @param currBlock the block they are moved too (a descendant of the priorblock)
 * @param currContext 
 * @param currBlockInstructions  all changes to instructions in curr blockare made through this iterator, and it is rewound to the previous position before the function exits
 * @param waitMap map of variable names to instructions/continuations they blockon
 * @param writtenV
 * @return true if change made, list of moved continuations
 */
private static Pair<Boolean,Set<Continuation>> relocateDependentInstructions(Logger logger,Block ancestorBlock,ExecContext ancestorContext,Deque<Continuation> ancestors,Block currBlock,ExecContext currContext,ListIterator<Instruction> currBlockInstructions,MultiMap<Var,InstOrCont> waitMap,Var writtenV){
  boolean changed=false;
  List<InstOrCont> waits=waitMap.get(writtenV);
  Set<Instruction> movedI=new HashSet<Instruction>();
  Set<Continuation> movedC=new HashSet<Continuation>();
  for (  InstOrCont ic : waits) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + ic.toString());
    boolean relocated;
switch (ic.type()) {
case CONTINUATION:
{
        relocated=relocateContinuation(ancestors,currBlock,currContext,movedC,ic.continuation());
        break;
      }
case INSTRUCTION:
    relocated=relocateInstruction(ancestors,currContext,currBlockInstructions,movedI,ic.instruction());
  break;
default :
throw new STCRuntimeError(""String_Node_Str"");
}
changed=changed || relocated;
}
ancestorBlock.removeContinuations(movedC);
ancestorBlock.removeInstructions(movedI);
ICUtil.rewindIterator(currBlockInstructions,movedI.size());
updateWaiterMap(waitMap,movedC,movedI);
return Pair.create(changed,movedC);
}","/** 
 * @param logger
 * @param ancestorBlock the block the instructions are moved from
 * @param ancestors 
 * @param currBlock the block they are moved too (a descendant of the priorblock)
 * @param currContext 
 * @param currBlockInstructions  all changes to instructions in curr blockare made through this iterator, and it is rewound to the previous position before the function exits
 * @param waitMap map of variable names to instructions/continuations they blockon
 * @param writtenV
 * @return true if change made, list of moved continuations
 */
private Pair<Boolean,Set<Continuation>> relocateDependentInstructions(Logger logger,Block ancestorBlock,ExecContext ancestorContext,Deque<Continuation> ancestors,Block currBlock,ExecContext currContext,ListIterator<Instruction> currBlockInstructions,MultiMap<Var,InstOrCont> waitMap,Var writtenV){
  boolean changed=false;
  List<InstOrCont> waits=waitMap.get(writtenV);
  Set<Instruction> movedI=new HashSet<Instruction>();
  Set<Continuation> movedC=new HashSet<Continuation>();
  for (  InstOrCont ic : waits) {
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + ic.toString());
    boolean relocated;
switch (ic.type()) {
case CONTINUATION:
{
        relocated=relocateContinuation(ancestors,currBlock,currContext,movedC,ic.continuation());
        break;
      }
case INSTRUCTION:
    relocated=relocateInstruction(ancestors,currContext,currBlockInstructions,movedI,ic.instruction());
  break;
default :
throw new STCRuntimeError(""String_Node_Str"");
}
changed=changed || relocated;
}
ancestorBlock.removeContinuations(movedC);
ancestorBlock.removeInstructions(movedI);
ICUtil.rewindIterator(currBlockInstructions,movedI.size());
updateWaiterMap(waitMap,movedC,movedI);
return Pair.create(changed,movedC);
}",0.9980430528375732
133003,"private static PushDownResult pushDownWaitsRec(Logger logger,Function fn,Block top,ExecContext topContext,Deque<Continuation> ancestors,Block curr,ExecContext currContext,MultiMap<Var,InstOrCont> waitMap){
  boolean changed=false;
  ArrayList<Continuation> pushedDown=new ArrayList<Continuation>();
  ListIterator<Instruction> it=curr.instructionIterator();
  while (it.hasNext()) {
    Instruction i=it.next();
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + i.toString());
    }
    List<Var> writtenFutures=new ArrayList<Var>();
    for (    Var outv : i.getOutputs()) {
      if (Types.isFuture(outv.type())) {
        writtenFutures.add(outv);
      }
    }
    for (    Var v : writtenFutures) {
      if (waitMap.containsKey(v)) {
        Pair<Boolean,Set<Continuation>> pdRes=relocateDependentInstructions(logger,top,topContext,ancestors,curr,currContext,it,waitMap,v);
        changed=changed || pdRes.val1;
        pushedDown.addAll(pdRes.val2);
      }
    }
  }
  for (  Continuation c : curr.getContinuations()) {
    ExecContext newContext=canPushDownInto(c,currContext);
    if (newContext != null) {
      for (      Block innerBlock : c.getBlocks()) {
        ancestors.push(c);
        PushDownResult pdRes=pushDownWaitsRec(logger,fn,top,topContext,ancestors,innerBlock,newContext,waitMap);
        pushedDown.addAll(pdRes.relocated);
        changed=changed || pdRes.anyChanges;
        ancestors.pop();
      }
    }
  }
  return new PushDownResult(changed,pushedDown);
}","private PushDownResult pushDownWaitsRec(Logger logger,Function fn,Block top,ExecContext topContext,Deque<Continuation> ancestors,Block curr,ExecContext currContext,MultiMap<Var,InstOrCont> waitMap){
  boolean changed=false;
  ArrayList<Continuation> pushedDown=new ArrayList<Continuation>();
  ListIterator<Instruction> it=curr.instructionIterator();
  while (it.hasNext()) {
    Instruction i=it.next();
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + i.toString());
    }
    List<Var> writtenFutures=new ArrayList<Var>();
    for (    Var outv : i.getOutputs()) {
      if (Types.isFuture(outv.type())) {
        writtenFutures.add(outv);
      }
    }
    for (    Var v : writtenFutures) {
      if (waitMap.containsKey(v)) {
        Pair<Boolean,Set<Continuation>> pdRes=relocateDependentInstructions(logger,top,topContext,ancestors,curr,currContext,it,waitMap,v);
        changed=changed || pdRes.val1;
        pushedDown.addAll(pdRes.val2);
      }
    }
  }
  for (  Continuation c : curr.getContinuations()) {
    ExecContext newContext=canPushDownInto(c,currContext);
    if (newContext != null) {
      for (      Block innerBlock : c.getBlocks()) {
        ancestors.push(c);
        PushDownResult pdRes=pushDownWaitsRec(logger,fn,top,topContext,ancestors,innerBlock,newContext,waitMap);
        pushedDown.addAll(pdRes.relocated);
        changed=changed || pdRes.anyChanges;
        ancestors.pop();
      }
    }
  }
  return new PushDownResult(changed,pushedDown);
}",0.9976874793524942
133004,"private static boolean relocateContinuation(Deque<Continuation> ancestors,Block currBlock,ExecContext currContext,Set<Continuation> movedC,Continuation cont){
  boolean canRelocate=true;
  for (  Continuation ancestor : ancestors) {
    if (cont == ancestor) {
      canRelocate=false;
      break;
    }
  }
  if (currContext == ExecContext.WORKER) {
    if (cont.getType() != ContinuationType.WAIT_STATEMENT) {
      canRelocate=false;
    }
 else {
      WaitStatement w=(WaitStatement)cont;
      if (w.getTarget() == TaskMode.CONTROL || w.getTarget() == TaskMode.WORKER || w.getTarget() == TaskMode.LOCAL) {
        canRelocate=true;
      }
 else       if (w.getTarget() == TaskMode.LOCAL_CONTROL) {
        w.setMode(WaitMode.TASK_DISPATCH);
        w.setTarget(TaskMode.CONTROL);
      }
 else {
        canRelocate=false;
      }
    }
  }
  if (canRelocate) {
    currBlock.addContinuation(cont);
    movedC.add(cont);
    assert(cont.isAsync());
  }
  return canRelocate;
}","private boolean relocateContinuation(Deque<Continuation> ancestors,Block currBlock,ExecContext currContext,Set<Continuation> movedC,Continuation cont){
  boolean canRelocate=true;
  for (  Continuation ancestor : ancestors) {
    if (cont == ancestor) {
      canRelocate=false;
      break;
    }
  }
  if (currContext == ExecContext.WORKER) {
    if (cont.getType() != ContinuationType.WAIT_STATEMENT) {
      canRelocate=false;
    }
 else {
      WaitStatement w=(WaitStatement)cont;
      if (w.getTarget() == TaskMode.CONTROL || w.getTarget() == TaskMode.WORKER || w.getTarget() == TaskMode.LOCAL) {
        canRelocate=true;
      }
 else       if (w.getTarget() == TaskMode.LOCAL_CONTROL) {
        if (w.getMode() == WaitMode.EXPLICIT && retainExplicit) {
          canRelocate=false;
        }
 else {
          w.setMode(WaitMode.TASK_DISPATCH);
          w.setTarget(TaskMode.CONTROL);
        }
      }
 else {
        canRelocate=false;
      }
    }
  }
  if (canRelocate) {
    currBlock.addContinuation(cont);
    movedC.add(cont);
    assert(cont.isAsync());
  }
  return canRelocate;
}",0.935823754789272
133005,"private static boolean pushDownWaits(Logger logger,Function fn,Block block,ExecContext currContext){
  MultiMap<Var,InstOrCont> waitMap=buildWaiterMap(block);
  if (waitMap.isDefinitelyEmpty()) {
    return false;
  }
  boolean changed=false;
  HashSet<Continuation> allPushedDown=new HashSet<Continuation>();
  ArrayList<Continuation> contCopy=new ArrayList<Continuation>(block.getContinuations());
  for (  Continuation c : contCopy) {
    if (allPushedDown.contains(c)) {
      continue;
    }
    ExecContext newContext=canPushDownInto(c,currContext);
    if (newContext != null) {
      for (      Block innerBlock : c.getBlocks()) {
        ArrayDeque<Continuation> ancestors=new ArrayDeque<Continuation>();
        ancestors.push(c);
        PushDownResult pdRes=pushDownWaitsRec(logger,fn,block,currContext,ancestors,innerBlock,newContext,waitMap);
        changed=changed || pdRes.anyChanges;
        allPushedDown.addAll(pdRes.relocated);
      }
    }
  }
  return changed;
}","private boolean pushDownWaits(Logger logger,Function fn,Block block,ExecContext currContext){
  MultiMap<Var,InstOrCont> waitMap=buildWaiterMap(block);
  if (waitMap.isDefinitelyEmpty()) {
    return false;
  }
  boolean changed=false;
  HashSet<Continuation> allPushedDown=new HashSet<Continuation>();
  ArrayList<Continuation> contCopy=new ArrayList<Continuation>(block.getContinuations());
  for (  Continuation c : contCopy) {
    if (allPushedDown.contains(c)) {
      continue;
    }
    ExecContext newContext=canPushDownInto(c,currContext);
    if (newContext != null) {
      for (      Block innerBlock : c.getBlocks()) {
        ArrayDeque<Continuation> ancestors=new ArrayDeque<Continuation>();
        ancestors.push(c);
        PushDownResult pdRes=pushDownWaitsRec(logger,fn,block,currContext,ancestors,innerBlock,newContext,waitMap);
        changed=changed || pdRes.anyChanges;
        allPushedDown.addAll(pdRes.relocated);
      }
    }
  }
  return changed;
}",0.9964376590330788
133006,"/** 
 * Try to hoist this instruction
 * @param logger
 * @param inst
 * @param state
 * @return true if hoisted
 */
private boolean tryHoist(Logger logger,Instruction inst,HoistTracking state){
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ state.maxHoist+ ""String_Node_Str""+ state.maxLoopHoist);
  }
  if (inst.hasSideEffects()) {
    logger.trace(""String_Node_Str"");
    return false;
  }
  int maxHoist=state.maxHoist;
  for (  Arg in : inst.getInputs()) {
    if (maxHoist <= 0)     return false;
    if (in.isVar()) {
      Var inVar=in.getVar();
      maxHoist=Math.min(maxHoist,maxInputHoist(logger,state,inVar));
    }
  }
  for (  Var readOutput : inst.getReadOutputs()) {
    maxHoist=Math.min(maxHoist,maxInputHoist(logger,state,readOutput));
  }
  for (  Var out : inst.getOutputs()) {
    if (trackDeclares(out)) {
      int declareDepth=state.declareMap.getDepth(out);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + out + ""String_Node_Str""+ declareDepth);
      assert(declareDepth >= 0);
      if (declareDepth > state.maxLoopHoist && !inst.isIdempotent()) {
        maxHoist=Math.min(maxHoist,state.maxLoopHoist);
        if (logger.isTraceEnabled())         logger.trace(""String_Node_Str"" + state.maxLoopHoist);
      }
    }
  }
  for (  Var out : inst.getOutputs()) {
    if (out.storage() == VarStorage.ALIAS) {
      if (!inst.getInitializedAliases().contains(out) && !state.initializedMap.containsKey(out)) {
        logger.trace(""String_Node_Str"");
        return false;
      }
    }
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + maxHoist);
  if (maxHoist > 0) {
    doHoist(logger,inst,maxHoist,state);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Try to hoist this instruction
 * @param logger
 * @param inst
 * @param state
 * @return true if hoisted
 */
private boolean tryHoist(Logger logger,Instruction inst,HoistTracking state){
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ state.maxHoist+ ""String_Node_Str""+ state.maxLoopHoist);
  }
  if (inst.hasSideEffects()) {
    logger.trace(""String_Node_Str"");
    return false;
  }
  int maxHoist=state.maxHoist;
  for (  Arg in : inst.getInputs()) {
    if (maxHoist <= 0)     return false;
    if (in.isVar()) {
      Var inVar=in.getVar();
      maxHoist=Math.min(maxHoist,maxInputHoist(logger,state,inVar));
    }
  }
  for (  Var readOutput : inst.getReadOutputs()) {
    maxHoist=Math.min(maxHoist,maxInputHoist(logger,state,readOutput));
  }
  for (  Var out : inst.getOutputs()) {
    if (trackDeclares(out)) {
      int declareDepth=state.declareMap.getDepth(out);
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + out + ""String_Node_Str""+ declareDepth);
      assert(declareDepth >= 0);
      if (declareDepth > state.maxLoopHoist && !inst.isIdempotent()) {
        maxHoist=Math.min(maxHoist,state.maxLoopHoist);
        if (logger.isTraceEnabled())         logger.trace(""String_Node_Str"" + state.maxLoopHoist);
      }
    }
  }
  for (  Var out : inst.getOutputs()) {
    if (out.storage() == VarStorage.ALIAS) {
      if (!inst.getInitializedAliases().contains(out)) {
        int initDepth=state.initializedMap.getDepth(out);
        if (logger.isTraceEnabled())         logger.trace(""String_Node_Str"" + initDepth + ""String_Node_Str""+ ""String_Node_Str""+ out);
        maxHoist=Math.min(maxHoist,initDepth);
        return false;
      }
    }
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + maxHoist);
  if (maxHoist > 0) {
    doHoist(logger,inst,maxHoist,state);
    return true;
  }
 else {
    return false;
  }
}",0.8074233458848843
133007,"private static String printDepGraph(MultiMap<Var,Var> dependencyGraph){
  List<Var> keys=new ArrayList<Var>(dependencyGraph.keySet());
  Collections.sort(keys);
  StringBuilder sb=new StringBuilder();
  for (  Var key : keys) {
    sb.append(key.name() + ""String_Node_Str"");
    ICUtil.prettyPrintVarList(sb,dependencyGraph.get(key));
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","private static String printDepGraph(MultiMap<Var,Var> dependencyGraph,int indent){
  List<Var> keys=new ArrayList<Var>(dependencyGraph.keySet());
  Collections.sort(keys);
  StringBuilder sb=new StringBuilder();
  for (  Var key : keys) {
    for (int i=0; i < indent; i++) {
      sb.append(' ');
    }
    sb.append(key.name() + ""String_Node_Str"");
    ICUtil.prettyPrintVarList(sb,dependencyGraph.get(key));
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}",0.9128440366972476
133008,"/** 
 * @param logger
 * @param f
 * @return true if changes made
 */
private static boolean eliminateIter(Logger logger,Function f){
  HashSet<Var> removeCandidates=new HashSet<Var>();
  HashSet<Var> needed=new HashSet<Var>();
  MultiMap<Var,Var> dependencyGraph=new MultiMap<Var,Var>();
  walkFunction(logger,f,removeCandidates,needed,dependencyGraph);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + f.getName() + ""String_Node_Str""+ ""String_Node_Str""+ removeCandidates+ ""String_Node_Str""+ ""String_Node_Str""+ needed+ ""String_Node_Str""+ ""String_Node_Str""+ printDepGraph(dependencyGraph));
  }
  ArrayDeque<Var> workStack=new ArrayDeque<Var>();
  workStack.addAll(needed);
  while (!workStack.isEmpty()) {
    Var neededVar=workStack.pop();
    List<Var> deps=dependencyGraph.remove(neededVar);
    if (deps != null) {
      needed.addAll(deps);
      workStack.addAll(deps);
    }
  }
  removeCandidates.removeAll(needed);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + removeCandidates);
  }
  if (removeCandidates.isEmpty()) {
    return false;
  }
 else {
    f.getMainblock().removeVars(removeCandidates);
    return true;
  }
}","/** 
 * @param logger
 * @param f
 * @return true if changes made
 */
private static boolean eliminateIter(Logger logger,Function f){
  HashSet<Var> removeCandidates=new HashSet<Var>();
  HashSet<Var> needed=new HashSet<Var>();
  MultiMap<Var,Var> dependencyGraph=new MultiMap<Var,Var>();
  Map<Var,Var> componentOf=new HashMap<Var,Var>();
  walkFunction(logger,f,removeCandidates,needed,dependencyGraph,componentOf);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + f.getName() + ""String_Node_Str""+ ""String_Node_Str""+ removeCandidates+ ""String_Node_Str""+ ""String_Node_Str""+ needed+ ""String_Node_Str""+ ""String_Node_Str""+ printDepGraph(dependencyGraph,4)+ ""String_Node_Str""+ ICUtil.prettyPrintMap(componentOf,4));
  }
  ArrayDeque<Var> workStack=new ArrayDeque<Var>();
  workStack.addAll(needed);
  while (!workStack.isEmpty()) {
    Var neededVar=workStack.pop();
    List<Var> deps=dependencyGraph.remove(neededVar);
    if (deps != null) {
      needed.addAll(deps);
      workStack.addAll(deps);
    }
  }
  removeCandidates.removeAll(needed);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + removeCandidates);
  }
  if (removeCandidates.isEmpty()) {
    return false;
  }
 else {
    f.getMainblock().removeVars(removeCandidates);
    return true;
  }
}",0.9507667473769168
133009,"/** 
 * Collect information for dead code elimination
 * @param logger
 * @param f
 * @param removeCandidates list of vars declared in function thatcould be removed
 * @param needed
 * @param dependencyGraph
 */
private static void walkFunction(Logger logger,Function f,HashSet<Var> removeCandidates,HashSet<Var> needed,MultiMap<Var,Var> dependencyGraph){
  Map<Var,Var> componentOf=new HashMap<Var,Var>();
  ArrayDeque<Block> workStack=new ArrayDeque<Block>();
  workStack.push(f.getMainblock());
  needed.addAll(f.getOutputList());
  while (!workStack.isEmpty()) {
    Block block=workStack.pop();
    walkBlockVars(block,removeCandidates,dependencyGraph);
    walkInstructions(logger,block,needed,dependencyGraph,componentOf);
    ListIterator<Continuation> it=block.continuationIterator();
    while (it.hasNext()) {
      Continuation c=it.next();
      if (c.isNoop()) {
        it.remove();
      }
 else {
        needed.addAll(c.requiredVars(true));
        for (        Block inner : c.getBlocks()) {
          workStack.push(inner);
        }
      }
    }
  }
}","/** 
 * Collect information for dead code elimination
 * @param logger
 * @param f
 * @param removeCandidates list of vars declared in function thatcould be removed
 * @param needed
 * @param dependencyGraph
 * @param componentOf
 */
private static void walkFunction(Logger logger,Function f,HashSet<Var> removeCandidates,HashSet<Var> needed,MultiMap<Var,Var> dependencyGraph,Map<Var,Var> componentOf){
  ArrayDeque<Block> workStack=new ArrayDeque<Block>();
  workStack.push(f.getMainblock());
  needed.addAll(f.getOutputList());
  while (!workStack.isEmpty()) {
    Block block=workStack.pop();
    walkBlockVars(block,removeCandidates,dependencyGraph);
    walkInstructions(logger,block,needed,dependencyGraph,componentOf);
    ListIterator<Continuation> it=block.continuationIterator();
    while (it.hasNext()) {
      Continuation c=it.next();
      if (c.isNoop()) {
        it.remove();
      }
 else {
        needed.addAll(c.requiredVars(true));
        for (        Block inner : c.getBlocks()) {
          workStack.push(inner);
        }
      }
    }
  }
}",0.9747899159663864
133010,"public Pair<Var,Var> getComponentAlias(){
switch (op) {
case ARRAY_CREATE_NESTED_IMM:
case ARRAY_CREATE_NESTED_FUTURE:
    return Pair.create(getOutput(0),getOutput(1));
case ARRAYREF_CREATE_NESTED_IMM:
case ARRAYREF_CREATE_NESTED_FUTURE:
  return Pair.create(getOutput(0),getOutput(2));
case LOAD_REF:
return Pair.create(getOutput(0),getInput(0).getVar());
case STRUCT_LOOKUP:
case STRUCTREF_LOOKUP:
return Pair.create(getOutput(0),getInput(0).getVar());
default :
return null;
}
}","public Pair<Var,Var> getComponentAlias(){
switch (op) {
case ARRAY_CREATE_NESTED_IMM:
case ARRAY_CREATE_NESTED_FUTURE:
    return Pair.create(getOutput(0),getOutput(1));
case ARRAYREF_CREATE_NESTED_IMM:
case ARRAYREF_CREATE_NESTED_FUTURE:
  return Pair.create(getOutput(0),getOutput(2));
case LOAD_REF:
return Pair.create(getOutput(0),getInput(0).getVar());
case ADDRESS_OF:
return Pair.create(getOutput(0),getInput(0).getVar());
case STRUCT_LOOKUP:
case STRUCTREF_LOOKUP:
return Pair.create(getOutput(0),getInput(0).getVar());
default :
return null;
}
}",0.9305019305019304
133011,"/** 
 * Check function argument type Returns which formal argument type is selected. Only handles case where formalArgT has a type variable
 * @param context
 * @param func
 * @param arg
 * @param formalArgT
 * @param argExprT
 * @param tvConstraints fill in constraints for type variables
 * @return
 * @throws TypeMismatchException
 */
private static Type checkFunArgTV(Context context,String func,int arg,Type formalArgT,Type argExprT,MultiMap<String,Type> tvConstraints) throws TypeMismatchException {
  if (Types.isUnion(formalArgT)) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
  if (Types.isRef(formalArgT)) {
    argExprT=argExprT.memberType();
  }
  if (Types.isUnion(argExprT)) {
    List<Map<String,Type>> possible=new ArrayList<Map<String,Type>>();
    for (    Type alt : UnionType.getAlternatives(argExprT)) {
      possible.add(formalArgT.matchTypeVars(alt));
    }
    for (    Map<String,Type> m : possible) {
      assert(m.keySet().equals(possible.get(0).keySet()));
    }
    for (    String boundVar : possible.get(0).keySet()) {
      List<Type> choices=new ArrayList<Type>();
      for (      Map<String,Type> m : possible) {
        Type t=m.get(boundVar);
        assert(!Types.isUnion(t));
        choices.add(t);
      }
      tvConstraints.put(boundVar,UnionType.makeUnion(choices));
    }
  }
 else {
    tvConstraints.putAll(formalArgT.matchTypeVars(argExprT));
  }
  return formalArgT;
}","/** 
 * Check function argument type Returns which formal argument type is selected. Only handles case where formalArgT has a type variable
 * @param context
 * @param func
 * @param arg
 * @param formalArgT
 * @param argExprT
 * @param tvConstraints fill in constraints for type variables
 * @return
 * @throws TypeMismatchException
 */
private static Type checkFunArgTV(Context context,String func,int arg,Type formalArgT,Type argExprT,MultiMap<String,Type> tvConstraints) throws TypeMismatchException {
  if (Types.isUnion(formalArgT)) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
  if (Types.isRef(formalArgT)) {
    argExprT=argExprT.memberType();
  }
  if (Types.isUnion(argExprT)) {
    List<Map<String,Type>> possible=new ArrayList<Map<String,Type>>();
    for (    Type alt : UnionType.getAlternatives(argExprT)) {
      possible.add(formalArgT.matchTypeVars(alt));
    }
    for (    Map<String,Type> m : possible) {
      assert(m.keySet().equals(possible.get(0).keySet()));
    }
    for (    String boundVar : possible.get(0).keySet()) {
      List<Type> choices=new ArrayList<Type>();
      for (      Map<String,Type> m : possible) {
        Type t=m.get(boundVar);
        assert(!Types.isUnion(t));
        choices.add(t);
      }
      tvConstraints.put(boundVar,UnionType.makeUnion(choices));
    }
  }
 else {
    Map<String,Type> matchedTypeVars=formalArgT.matchTypeVars(argExprT);
    if (matchedTypeVars == null) {
      throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + formalArgT + ""String_Node_Str""+ ""String_Node_Str""+ argExprT);
    }
    tvConstraints.putAll(matchedTypeVars);
  }
  return formalArgT;
}",0.8893905191873589
133012,"/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    if (SUPER_DEBUG) {
      pipe.setValidator(Validate.standardValidator());
    }
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if ((iteration % 3) == 2) {
      pipe.addPass(new LoopUnroller());
      pipe.addPass(Validate.standardValidator());
    }
    boolean aggressive=iteration > (nIterations * 2 / 3);
    pipe.addPass(new HoistLoops(aggressive));
    boolean lastThird=iteration > nIterations * 2 / 3;
    if (iteration % 2 == 1 || lastThird) {
      pipe.addPass(new ReorderInstructions(lastThird));
    }
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 1) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}","/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  boolean canReorder=true;
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    if (SUPER_DEBUG) {
      pipe.setValidator(Validate.standardValidator());
    }
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if ((iteration % 3) == 2) {
      pipe.addPass(new LoopUnroller());
      pipe.addPass(Validate.standardValidator());
    }
    boolean lastHalf=iteration > nIterations * 2;
    if (canReorder) {
      pipe.addPass(new HoistLoops(lastHalf));
    }
    if (canReorder && (iteration % 2 == 1)) {
      pipe.addPass(new ReorderInstructions(lastHalf));
    }
    if (iteration == nIterations - 2) {
      canReorder=false;
    }
    pipe.addPass(new ForwardDataflow(!canReorder));
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 1) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges,canReorder));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}",0.9027954256670904
133013,"/** 
 * Try to squash together waits, e.g. wait (x) { < do some minor work that doesn't help with progress > wait (y) { < do some real work > } } gets changed to wait (x, y) { ... }
 * @param logger
 * @param fn
 * @param block
 */
private boolean squashWaits(Logger logger,Function fn,WaitStatement wait,ExecContext waitContext){
  Block block=wait.getBlock();
  WaitStatement innerWait=null;
  for (  Continuation c : block.getContinuations()) {
    if (c.isAsync()) {
      if (c.getType() == ContinuationType.WAIT_STATEMENT) {
        if (innerWait != null) {
          return false;
        }
 else {
          innerWait=(WaitStatement)c;
        }
      }
 else {
        return false;
      }
    }
  }
  if (innerWait == null)   return false;
  ExecContext innerContext=innerWait.childContext(waitContext);
  if (innerContext != waitContext)   return false;
  for (  Var waitVar : innerWait.getWaitVars()) {
    if (block.getVariables().contains(waitVar)) {
      return false;
    }
  }
  if (!ProgressOpcodes.isNonProgress(block)) {
    return false;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + innerWait.getWaitVars() + ""String_Node_Str""+ ""String_Node_Str""+ wait.getWaitVars()+ ""String_Node_Str"");
  wait.addWaitVars(innerWait.getWaitVars());
  innerWait.inlineInto(block);
  return true;
}","/** 
 * Try to squash together waits, e.g. wait (x) { < do some minor work that doesn't help with progress > wait (y) { < do some real work > } } gets changed to wait (x, y) { ... }
 * @param logger
 * @param fn
 * @param block
 */
private boolean squashWaits(Logger logger,Function fn,WaitStatement wait,ExecContext waitContext){
  Block block=wait.getBlock();
  WaitStatement innerWait=null;
  for (  Continuation c : block.getContinuations()) {
    if (c.isAsync()) {
      if (c.getType() == ContinuationType.WAIT_STATEMENT) {
        if (innerWait != null) {
          return false;
        }
 else {
          innerWait=(WaitStatement)c;
        }
      }
 else {
        return false;
      }
    }
  }
  if (innerWait == null)   return false;
  ExecContext innerContext=innerWait.childContext(waitContext);
  if (innerContext != waitContext)   return false;
  if (retainExplicit && innerWait.getMode() == WaitMode.EXPLICIT && wait.getMode() != WaitMode.EXPLICIT)   return false;
  for (  Var waitVar : innerWait.getWaitVars()) {
    if (block.getVariables().contains(waitVar)) {
      return false;
    }
  }
  if (!ProgressOpcodes.isNonProgress(block)) {
    return false;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + innerWait.getWaitVars() + ""String_Node_Str""+ ""String_Node_Str""+ wait.getWaitVars()+ ""String_Node_Str"");
  wait.addWaitVars(innerWait.getWaitVars());
  innerWait.inlineInto(block);
  return true;
}",0.9563963963963964
133014,"public WaitCoalescer(boolean doMerges){
  this.doMerges=doMerges;
}","public WaitCoalescer(boolean doMerges,boolean retainExplicit){
  this.doMerges=doMerges;
  this.retainExplicit=retainExplicit;
}",0.6871794871794872
133015,"private static boolean mergeWaits(Logger logger,Function fn,Block block){
  boolean changed=false;
  boolean fin;
  do {
    fin=true;
    MultiMap<Var,WaitStatement> waitMap=buildWaitMap(block);
    Var winner=mostSharedVar(waitMap);
    if (winner != null) {
      fin=false;
      changed=true;
      List<WaitStatement> waits=waitMap.get(winner);
      assert(waits != null && waits.size() >= 2);
      boolean explicit=false;
      boolean allRecursive=true;
      Set<Var> intersection=null;
      for (      WaitStatement wait : waits) {
        Set<Var> waitVars=new HashSet<Var>(wait.getWaitVars());
        if (intersection == null) {
          intersection=waitVars;
        }
 else {
          intersection.retainAll(waitVars);
        }
        explicit=explicit || wait.getMode() != WaitMode.DATA_ONLY;
        allRecursive=allRecursive && wait.isRecursive();
      }
      assert(intersection != null && !intersection.isEmpty());
      WaitStatement newWait=new WaitStatement(fn.getName() + ""String_Node_Str"",new ArrayList<Var>(intersection),PassedVar.NONE,Var.NONE,null,explicit ? WaitMode.EXPLICIT : WaitMode.DATA_ONLY,allRecursive,TaskMode.LOCAL);
      for (      WaitStatement wait : waits) {
        if (allRecursive) {
          wait.tryInline(Collections.<Var>emptySet(),intersection);
        }
 else {
          wait.tryInline(intersection,Collections.<Var>emptySet());
        }
        if (wait.getWaitVars().isEmpty() && wait.getMode() != WaitMode.TASK_DISPATCH) {
          newWait.getBlock().insertInline(wait.getBlock());
        }
 else {
          wait.setParent(newWait.getBlock());
          newWait.getBlock().addContinuation(wait);
        }
      }
      block.addContinuation(newWait);
      block.removeContinuations(waits);
    }
    changed=changed || !fin;
  }
 while (!fin);
  return changed;
}","private static boolean mergeWaits(Logger logger,Function fn,Block block){
  boolean changed=false;
  boolean fin;
  do {
    fin=true;
    MultiMap<Var,WaitStatement> waitMap=buildWaitMap(block);
    Var winner=mostSharedVar(waitMap);
    if (winner != null) {
      fin=false;
      changed=true;
      List<WaitStatement> waits=waitMap.get(winner);
      assert(waits != null && waits.size() >= 2);
      boolean explicit=false;
      boolean allRecursive=true;
      Set<Var> intersection=null;
      for (      WaitStatement wait : waits) {
        Set<Var> waitVars=new HashSet<Var>(wait.getWaitVars());
        if (intersection == null) {
          intersection=waitVars;
        }
 else {
          intersection.retainAll(waitVars);
        }
        explicit=explicit || wait.getMode() != WaitMode.DATA_ONLY;
        allRecursive=allRecursive && wait.isRecursive();
      }
      assert(intersection != null && !intersection.isEmpty());
      WaitStatement newWait=new WaitStatement(fn.getName() + ""String_Node_Str"",new ArrayList<Var>(intersection),PassedVar.NONE,Var.NONE,null,explicit ? WaitMode.EXPLICIT : WaitMode.DATA_ONLY,allRecursive,TaskMode.LOCAL);
      for (      WaitStatement wait : waits) {
        if (allRecursive) {
          wait.tryInline(Collections.<Var>emptySet(),intersection,false);
        }
 else {
          wait.tryInline(intersection,Collections.<Var>emptySet(),false);
        }
        if (wait.getWaitVars().isEmpty() && wait.getMode() != WaitMode.TASK_DISPATCH) {
          newWait.getBlock().insertInline(wait.getBlock());
        }
 else {
          wait.setParent(newWait.getBlock());
          newWait.getBlock().addContinuation(wait);
        }
      }
      block.addContinuation(newWait);
      block.removeContinuations(waits);
    }
    changed=changed || !fin;
  }
 while (!fin);
  return changed;
}",0.9967462039045552
133016,"@Override public Block tryInline(Set<Var> closedVars,Set<Var> recClosedVars){
  boolean varsLeft=false;
  ListIterator<Var> it=waitVars.listIterator();
  while (it.hasNext()) {
    Var wv=it.next();
    if ((closedVars.contains(wv) && !recursionRequired(wv)) || recClosedVars.contains(wv)) {
      it.remove();
    }
 else {
      varsLeft=true;
    }
  }
  if (varsLeft || mode == WaitMode.TASK_DISPATCH) {
    return null;
  }
 else {
    return block;
  }
}","@Override public Block tryInline(Set<Var> closedVars,Set<Var> recClosedVars,boolean keepExplicitDependencies){
  if (keepExplicitDependencies && mode == WaitMode.EXPLICIT)   return null;
  boolean varsLeft=false;
  ListIterator<Var> it=waitVars.listIterator();
  while (it.hasNext()) {
    Var wv=it.next();
    if ((closedVars.contains(wv) && !recursionRequired(wv)) || recClosedVars.contains(wv)) {
      it.remove();
    }
 else {
      varsLeft=true;
    }
  }
  if (varsLeft || mode == WaitMode.TASK_DISPATCH) {
    return null;
  }
 else {
    return block;
  }
}",0.8940719144800777
133017,"@Override public Block branchPredict(Map<Var,Arg> knownConstants){
  return tryInline(Collections.<Var>emptySet(),knownConstants.keySet());
}","@Override public Block branchPredict(Map<Var,Arg> knownConstants){
  return null;
}",0.7321428571428571
133018,"/** 
 * @param logger
 * @param block 
 * @param visible allvariables logically visible in this block. will be modified in fn
 * @param referencedGlobals updated with names of any globals used
 * @param updateLists 
 * @return
 */
private static Pair<Set<Var>,Set<Var>> fixupBlockRec(Logger logger,Function function,Block block,HierarchicalSet<Var> visible,Set<Var> referencedGlobals,boolean updateLists){
  if (updateLists)   removeGlobalImports(block);
  Set<Var> blockVars=new HashSet<Var>();
  for (  Var v : block.getVariables()) {
    blockVars.add(v);
    visible.add(v);
  }
  Set<Var> read=new HashSet<Var>();
  Set<Var> written=new HashSet<Var>();
  findBlockNeeded(block,read,written);
  for (  Continuation c : block.getContinuations()) {
    fixupContinuationRec(logger,function,c,visible,referencedGlobals,blockVars,read,written,updateLists);
  }
  read.removeAll(blockVars);
  written.removeAll(blockVars);
  Set<Var> globals=addGlobalImports(block,visible,updateLists,Arrays.asList(read,written));
  referencedGlobals.addAll(globals);
  read.removeAll(globals);
  written.removeAll(globals);
  return Pair.create(read,written);
}","/** 
 * @param logger
 * @param block 
 * @param visible allvariables logically visible in this block. will be modified in fn
 * @param referencedGlobals updated with names of any globals used
 * @param updateLists 
 * @return
 */
private static Pair<Set<Var>,Set<Var>> fixupBlockRec(Logger logger,Function function,Block block,ExecContext execCx,HierarchicalSet<Var> visible,Set<Var> referencedGlobals,boolean updateLists){
  if (updateLists)   removeGlobalImports(block);
  Set<Var> blockVars=new HashSet<Var>();
  for (  Var v : block.getVariables()) {
    blockVars.add(v);
    visible.add(v);
  }
  Set<Var> read=new HashSet<Var>();
  Set<Var> written=new HashSet<Var>();
  findBlockNeeded(block,read,written);
  for (  Continuation c : block.getContinuations()) {
    fixupContinuationRec(logger,function,execCx,c,visible,referencedGlobals,blockVars,read,written,updateLists);
  }
  read.removeAll(blockVars);
  written.removeAll(blockVars);
  if (execCx == ExecContext.CONTROL) {
    Set<Var> globals=addGlobalImports(block,visible,updateLists,Arrays.asList(read,written));
    referencedGlobals.addAll(globals);
    read.removeAll(globals);
    written.removeAll(globals);
  }
  return Pair.create(read,written);
}",0.9674693705111956
133019,"/** 
 * Update variable passing for nested continuation
 * @param logger
 * @param function
 * @param continuation
 * @param visible
 * @param referencedGlobals
 * @param outerBlockVars
 * @param neededVars
 * @param updateLists 
 */
private static void fixupContinuationRec(Logger logger,Function function,Continuation continuation,HierarchicalSet<Var> visible,Set<Var> referencedGlobals,Set<Var> outerBlockVars,Set<Var> read,Set<Var> written,boolean updateLists){
  List<Var> constructVars=continuation.constructDefinedVars();
  for (  Block innerBlock : continuation.getBlocks()) {
    HierarchicalSet<Var> childVisible=visible.makeChild();
    for (    Var v : constructVars) {
      childVisible.add(v);
    }
    Pair<Set<Var>,Set<Var>> inner=fixupBlockRec(logger,function,innerBlock,childVisible,referencedGlobals,updateLists);
    Set<Var> innerRead=inner.val1;
    Set<Var> innerWritten=inner.val2;
    if (!constructVars.isEmpty()) {
      innerRead.removeAll(constructVars);
      innerWritten.removeAll(constructVars);
    }
    if (continuation.inheritsParentVars()) {
      innerRead.removeAll(outerBlockVars);
      read.addAll(innerRead);
      innerWritten.removeAll(outerBlockVars);
      written.addAll(innerWritten);
    }
 else     if (updateLists) {
      rebuildContinuationPassedVars(function,continuation,visible,outerBlockVars,read,innerRead,written,innerWritten);
      rebuildContinuationKeepOpenVars(function,continuation,visible,outerBlockVars,written,innerWritten);
    }
  }
}","/** 
 * Update variable passing for nested continuation
 * @param logger
 * @param function
 * @param outerCx exec context outside of continuation
 * @param continuation
 * @param visible
 * @param referencedGlobals
 * @param outerBlockVars
 * @param neededVars
 * @param updateLists 
 */
private static void fixupContinuationRec(Logger logger,Function function,ExecContext outerCx,Continuation continuation,HierarchicalSet<Var> visible,Set<Var> referencedGlobals,Set<Var> outerBlockVars,Set<Var> read,Set<Var> written,boolean updateLists){
  List<Var> constructVars=continuation.constructDefinedVars();
  ExecContext innerCx=continuation.childContext(outerCx);
  for (  Block innerBlock : continuation.getBlocks()) {
    HierarchicalSet<Var> childVisible=visible.makeChild();
    for (    Var v : constructVars) {
      childVisible.add(v);
    }
    Pair<Set<Var>,Set<Var>> inner=fixupBlockRec(logger,function,innerBlock,innerCx,childVisible,referencedGlobals,updateLists);
    Set<Var> innerRead=inner.val1;
    Set<Var> innerWritten=inner.val2;
    if (!constructVars.isEmpty()) {
      innerRead.removeAll(constructVars);
      innerWritten.removeAll(constructVars);
    }
    if (continuation.inheritsParentVars()) {
      innerRead.removeAll(outerBlockVars);
      read.addAll(innerRead);
      innerWritten.removeAll(outerBlockVars);
      written.addAll(innerWritten);
    }
 else     if (updateLists) {
      rebuildContinuationPassedVars(function,continuation,visible,outerBlockVars,read,innerRead,written,innerWritten);
      rebuildContinuationKeepOpenVars(function,continuation,visible,outerBlockVars,written,innerWritten);
    }
  }
}",0.955337345581248
133020,"/** 
 * Find all referenced vars in scope
 * @param block
 * @param written accumulate output vars
 * @param read accumulate all input vars from this block
 */
private static void findBlockNeeded(Block block,Set<Var> read,Set<Var> written){
  for (  Var v : block.getVariables()) {
    if (v.isMapped()) {
      read.add(v.mapping());
    }
  }
  for (  Instruction i : block.getInstructions()) {
    for (    Arg in : i.getInputs()) {
      if (in.isVar()) {
        read.add(in.getVar());
      }
    }
    written.addAll(i.getOutputs());
  }
  for (  Continuation cont : block.getContinuations()) {
    read.addAll(cont.requiredVars());
  }
  for (  CleanupAction cleanup : block.getCleanups()) {
    for (    Arg in : cleanup.action().getInputs()) {
      if (in.isVar()) {
        read.add(in.getVar());
      }
    }
  }
}","/** 
 * Find all referenced vars in scope
 * @param block
 * @param written accumulate output vars
 * @param read accumulate all input vars from this block
 */
private static void findBlockNeeded(Block block,Set<Var> read,Set<Var> written){
  for (  Var v : block.getVariables()) {
    if (v.isMapped()) {
      read.add(v.mapping());
    }
  }
  for (  Instruction i : block.getInstructions()) {
    for (    Arg in : i.getInputs()) {
      if (in.isVar()) {
        read.add(in.getVar());
      }
    }
    written.addAll(i.getOutputs());
  }
  for (  Continuation cont : block.getContinuations()) {
    read.addAll(cont.requiredVars(false));
  }
  for (  CleanupAction cleanup : block.getCleanups()) {
    for (    Arg in : cleanup.action().getInputs()) {
      if (in.isVar()) {
        read.add(in.getVar());
      }
    }
  }
}",0.9969897652016856
133021,"public static void fixupFunction(Logger logger,Program prog,Function fn,Set<Var> referencedGlobals,boolean updateLists){
  HierarchicalSet<Var> fnargs=new HierarchicalSet<Var>();
  for (  Var v : fn.getInputList()) {
    fnargs.add(v);
  }
  for (  Var v : fn.getOutputList()) {
    fnargs.add(v);
  }
  for (  Entry<String,Arg> e : prog.getGlobalConsts().entrySet()) {
    Arg a=e.getValue();
    Var v=new Var(a.getType(),e.getKey(),VarStorage.GLOBAL_CONST,DefType.GLOBAL_CONST,null);
    fnargs.add(v);
  }
  Pair<Set<Var>,Set<Var>> res=fixupBlockRec(logger,fn,fn.getMainblock(),fnargs,referencedGlobals,updateLists);
  Set<Var> read=res.val1;
  Set<Var> written=res.val2;
  if (updateLists) {
    for (int i=0; i < fn.getOutputList().size(); i++) {
      Var output=fn.getOutput(i);
      if (!read.contains(output)) {
        fn.makeOutputWriteOnly(i);
      }
    }
  }
  read.removeAll(fn.getInputList());
  read.removeAll(fn.getOutputList());
  if (read.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ read.toString());
  }
  written.removeAll(fn.getOutputList());
  if (written.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ written.toString());
  }
}","public static void fixupFunction(Logger logger,Program prog,Function fn,Set<Var> referencedGlobals,boolean updateLists){
  HierarchicalSet<Var> fnargs=new HierarchicalSet<Var>();
  for (  Var v : fn.getInputList()) {
    fnargs.add(v);
  }
  for (  Var v : fn.getOutputList()) {
    fnargs.add(v);
  }
  for (  Entry<String,Arg> e : prog.getGlobalConsts().entrySet()) {
    Arg a=e.getValue();
    Var v=new Var(a.getType(),e.getKey(),VarStorage.GLOBAL_CONST,DefType.GLOBAL_CONST,null);
    fnargs.add(v);
  }
  Pair<Set<Var>,Set<Var>> res=fixupBlockRec(logger,fn,fn.getMainblock(),ExecContext.CONTROL,fnargs,referencedGlobals,updateLists);
  Set<Var> read=res.val1;
  Set<Var> written=res.val2;
  if (updateLists) {
    for (int i=0; i < fn.getOutputList().size(); i++) {
      Var output=fn.getOutput(i);
      if (!read.contains(output)) {
        fn.makeOutputWriteOnly(i);
      }
    }
  }
  read.removeAll(fn.getInputList());
  read.removeAll(fn.getOutputList());
  if (read.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ read.toString());
  }
  written.removeAll(fn.getOutputList());
  if (written.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ written.toString());
  }
}",0.99213217938631
133022,"private static void rebuildContinuationPassedVars(Function function,Continuation continuation,HierarchicalSet<Var> visibleVars,Set<Var> outerBlockVars,Set<Var> outerRead,Set<Var> innerRead,Set<Var> outerWritten,Set<Var> innerWritten){
  Set<Var> innerAllNeeded=new HashSet<Var>();
  innerAllNeeded.addAll(innerRead);
  innerAllNeeded.addAll(innerWritten);
  List<PassedVar> passedIn=new ArrayList<PassedVar>();
  for (  Var needed : innerAllNeeded) {
    assert(needed.storage() != VarStorage.GLOBAL_CONST);
    boolean read=innerRead.contains(needed);
    boolean written=innerWritten.contains(needed);
    if (!outerBlockVars.contains(needed)) {
      if (read)       outerRead.add(needed);
      if (written)       outerWritten.add(needed);
    }
    if (!visibleVars.contains(needed)) {
      throw new STCRuntimeError(""String_Node_Str"" + needed + ""String_Node_Str""+ ""String_Node_Str""+ function.getName());
    }
    assert(read || written);
    boolean writeOnly=!read;
    passedIn.add(new PassedVar(needed,writeOnly));
  }
  continuation.setPassedVars(passedIn);
}","private static void rebuildContinuationPassedVars(Function function,Continuation continuation,HierarchicalSet<Var> visibleVars,Set<Var> outerBlockVars,Set<Var> outerRead,Set<Var> innerRead,Set<Var> outerWritten,Set<Var> innerWritten){
  Set<Var> innerAllNeeded=new HashSet<Var>();
  innerAllNeeded.addAll(innerRead);
  innerAllNeeded.addAll(innerWritten);
  List<PassedVar> passedIn=new ArrayList<PassedVar>();
  for (  Var needed : innerAllNeeded) {
    boolean read=innerRead.contains(needed);
    boolean written=innerWritten.contains(needed);
    if (!outerBlockVars.contains(needed)) {
      if (read)       outerRead.add(needed);
      if (written)       outerWritten.add(needed);
    }
    if (!visibleVars.contains(needed)) {
      throw new STCRuntimeError(""String_Node_Str"" + needed + ""String_Node_Str""+ ""String_Node_Str""+ function.getName());
    }
    assert(read || written);
    boolean writeOnly=!read;
    passedIn.add(new PassedVar(needed,writeOnly));
  }
  continuation.setPassedVars(passedIn);
}",0.9726618705035972
133023,"private boolean rearrangeWaitsRec(Logger logger,Function fn,Block block,ExecContext currContext){
  List<WaitStatement> toInline=new ArrayList<WaitStatement>();
  boolean changed=false;
  for (  Continuation c : block.getContinuations()) {
    ExecContext newContext=c.childContext(currContext);
    for (    Block childB : c.getBlocks()) {
      if (rearrangeWaits(logger,fn,childB,newContext)) {
        changed=true;
      }
    }
    if (c.getType() == ContinuationType.WAIT_STATEMENT) {
      WaitStatement wait=(WaitStatement)c;
      if (tryReduce(logger,fn,currContext,newContext,wait)) {
        toInline.add(wait);
      }
      if (squashWaits(logger,fn,wait,newContext)) {
        changed=true;
      }
    }
  }
  for (  WaitStatement w : toInline) {
    w.inlineInto(block);
    changed=true;
  }
  return changed;
}","private boolean rearrangeWaitsRec(Logger logger,Function fn,Block block,ExecContext currContext){
  List<WaitStatement> toInline=new ArrayList<WaitStatement>();
  boolean changed=false;
  for (  Continuation c : block.getContinuations()) {
    ExecContext newContext=c.childContext(currContext);
    for (    Block childB : c.getBlocks()) {
      if (rearrangeWaits(logger,fn,childB,newContext)) {
        changed=true;
      }
    }
    if (c.getType() == ContinuationType.WAIT_STATEMENT) {
      WaitStatement wait=(WaitStatement)c;
      if (tryReduce(logger,fn,currContext,newContext,wait)) {
        toInline.add(wait);
      }
 else       if (squashWaits(logger,fn,wait,newContext)) {
        changed=true;
      }
    }
  }
  for (  WaitStatement w : toInline) {
    w.inlineInto(block);
    changed=true;
  }
  return changed;
}",0.9963985594237696
133024,"/** 
 * Remove from candidates any variables that can't have the refcount decremented before this continuation starts execution
 * @param inst
 * @param type
 * @param candidates
 */
private void removeDecrCandidates(Continuation cont,RefCountType type,Set<Var> candidates){
  if (type == RefCountType.READERS) {
    for (    Var v : cont.requiredVars()) {
      candidates.remove(v);
    }
  }
  if (isForeachLoop(cont)) {
    AbstractForeachLoop loop=(AbstractForeachLoop)cont;
    for (    RefCount rc : loop.getStartIncrements()) {
      if (rc.type == type) {
        candidates.remove(rc.var);
      }
    }
  }
}","/** 
 * Remove from candidates any variables that can't have the refcount decremented before this continuation starts execution
 * @param inst
 * @param type
 * @param candidates
 */
private void removeDecrCandidates(Continuation cont,RefCountType type,Set<Var> candidates){
  if (type == RefCountType.READERS) {
    for (    Var v : cont.requiredVars(false)) {
      candidates.remove(v);
    }
  }
  if (isForeachLoop(cont)) {
    AbstractForeachLoop loop=(AbstractForeachLoop)cont;
    for (    RefCount rc : loop.getStartIncrements()) {
      if (rc.type == type) {
        candidates.remove(rc.var);
      }
    }
  }
}",0.99597747385358
133025,"/** 
 * try to reduce to a simpler form of wait
 * @param currContext
 * @param toInline
 * @param newContext
 * @param wait
 */
private boolean tryReduce(ExecContext currContext,ExecContext newContext,WaitStatement wait){
  if ((currContext == newContext && ProgressOpcodes.isCheap(wait.getBlock())) || (currContext == ExecContext.WORKER && newContext == ExecContext.CONTROL && ProgressOpcodes.isCheapWorker(wait.getBlock()))) {
    if (wait.getWaitVars().isEmpty()) {
      return true;
    }
 else {
      if (wait.getTarget() == TaskMode.CONTROL) {
        if (currContext == ExecContext.CONTROL) {
          wait.setTarget(TaskMode.LOCAL_CONTROL);
        }
 else {
          wait.setTarget(TaskMode.LOCAL);
        }
      }
      if (wait.getMode() == WaitMode.TASK_DISPATCH) {
        wait.setMode(WaitMode.DATA_ONLY);
      }
    }
  }
  return false;
}","/** 
 * try to reduce to a simpler form of wait
 * @param currContext
 * @param toInline
 * @param newContext
 * @param wait
 */
private boolean tryReduce(Logger logger,Function fn,ExecContext currContext,ExecContext newContext,WaitStatement wait){
  if ((currContext == newContext && ProgressOpcodes.isCheap(wait.getBlock())) || (currContext == ExecContext.WORKER && newContext == ExecContext.CONTROL && canSwitchControlToWorker(logger,fn,wait))) {
    if (wait.getWaitVars().isEmpty()) {
      return true;
    }
 else {
      if (wait.getTarget() == TaskMode.CONTROL) {
        if (currContext == ExecContext.CONTROL) {
          wait.setTarget(TaskMode.LOCAL_CONTROL);
        }
 else {
          wait.setTarget(TaskMode.LOCAL);
        }
      }
      if (wait.getMode() == WaitMode.TASK_DISPATCH) {
        wait.setMode(WaitMode.DATA_ONLY);
      }
    }
  }
  return false;
}",0.9461009174311926
133026,"private boolean rearrangeWaitsRec(Logger logger,Function fn,Block block,ExecContext currContext){
  List<WaitStatement> toInline=new ArrayList<WaitStatement>();
  boolean changed=false;
  for (  Continuation c : block.getContinuations()) {
    ExecContext newContext=c.childContext(currContext);
    for (    Block childB : c.getBlocks()) {
      if (rearrangeWaits(logger,fn,childB,newContext)) {
        changed=true;
      }
    }
    if (c.getType() == ContinuationType.WAIT_STATEMENT) {
      WaitStatement wait=(WaitStatement)c;
      if (tryReduce(currContext,newContext,wait)) {
        toInline.add(wait);
      }
      if (squashWaits(logger,fn,wait,newContext)) {
        changed=true;
      }
    }
  }
  for (  WaitStatement w : toInline) {
    w.inlineInto(block);
    changed=true;
  }
  return changed;
}","private boolean rearrangeWaitsRec(Logger logger,Function fn,Block block,ExecContext currContext){
  List<WaitStatement> toInline=new ArrayList<WaitStatement>();
  boolean changed=false;
  for (  Continuation c : block.getContinuations()) {
    ExecContext newContext=c.childContext(currContext);
    for (    Block childB : c.getBlocks()) {
      if (rearrangeWaits(logger,fn,childB,newContext)) {
        changed=true;
      }
    }
    if (c.getType() == ContinuationType.WAIT_STATEMENT) {
      WaitStatement wait=(WaitStatement)c;
      if (tryReduce(logger,fn,currContext,newContext,wait)) {
        toInline.add(wait);
      }
      if (squashWaits(logger,fn,wait,newContext)) {
        changed=true;
      }
    }
  }
  for (  WaitStatement w : toInline) {
    w.inlineInto(block);
    changed=true;
  }
  return changed;
}",0.993939393939394
133027,"@Override public Collection<Var> requiredVars(){
  ArrayList<Var> res=new ArrayList<Var>();
  if (mode == WaitMode.EXPLICIT || mode == WaitMode.TASK_DISPATCH) {
    for (    Var v : waitVars) {
      res.add(v);
    }
  }
  if (priority != null && priority.isVar()) {
    res.add(priority.getVar());
  }
  return res;
}","@Override public Collection<Var> requiredVars(boolean forDeadCodeElim){
  ArrayList<Var> res=new ArrayList<Var>();
  if (!forDeadCodeElim || mode == WaitMode.EXPLICIT || mode == WaitMode.TASK_DISPATCH) {
    for (    Var v : waitVars) {
      res.add(v);
    }
  }
  if (priority != null && priority.isVar()) {
    res.add(priority.getVar());
  }
  return res;
}",0.9368575624082232
133028,"@Override public void startForeachLoop(String loopName,Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,int leafDegree,boolean arrayClosed,List<PassedVar> passedVars,List<RefCount> perIterIncrs){
  assert(Types.isArray(arrayVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  if (!arrayClosed) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
  boolean haveKeys=loopCountVar != null;
  String contentsVar=TCLTMP_ARRAY_CONTENTS;
  if (splitDegree <= 0) {
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys));
    if (!perIterIncrs.isEmpty()) {
      pointStack.peek().add(new SetVariable(TCLTMP_ITERS,Square.fnCall(""String_Node_Str"",new Token(""String_Node_Str""),new Value(contentsVar))));
      handleRefcounts(perIterIncrs,new Value(TCLTMP_ITERS),false);
    }
  }
 else {
    startForeachSplit(loopName,arrayVar,contentsVar,splitDegree,leafDegree,haveKeys,passedVars,perIterIncrs);
  }
  startForeachInner(new Value(contentsVar),memberVar,loopCountVar);
}","@Override public void startForeachLoop(String loopName,Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,int leafDegree,boolean arrayClosed,List<PassedVar> passedVars,List<RefCount> perIterIncrs){
  assert(Types.isArray(arrayVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  if (!arrayClosed) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
  boolean haveKeys=loopCountVar != null;
  String contentsVar=TCLTMP_ARRAY_CONTENTS;
  if (splitDegree <= 0) {
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys));
    Value tclDict=new Value(contentsVar);
    Expression containerSize=Turbine.dictSize(tclDict);
    handleForeachContainerRefcounts(perIterIncrs,containerSize);
  }
 else {
    startForeachSplit(loopName,arrayVar,contentsVar,splitDegree,leafDegree,haveKeys,passedVars,perIterIncrs);
  }
  startForeachInner(new Value(contentsVar),memberVar,loopCountVar);
}",0.8118811881188119
133029,"private void startForeachSplit(String procName,Var arrayVar,String contentsVar,int splitDegree,int leafDegree,boolean haveKeys,List<PassedVar> usedVars,List<RefCount> perIterIncrs){
  pointStack.peek().add(Turbine.containerSize(TCLTMP_CONTAINER_SIZE,varToExpr(arrayVar)));
  Expression lastIndex=Square.arithExpr(new Value(TCLTMP_CONTAINER_SIZE),new Token(""String_Node_Str""),new LiteralInt(1));
  ArrayList<PassedVar> splitUsedVars=new ArrayList<PassedVar>(usedVars);
  splitUsedVars.add(new PassedVar(arrayVar,false));
  startRangeSplit(procName,splitUsedVars,perIterIncrs,splitDegree,leafDegree,LiteralInt.ZERO,lastIndex,LiteralInt.ONE);
  pointStack.peek().add(new SetVariable(TCLTMP_SPLITLEN,Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,TCLTMP_RANGE_LO)))));
  pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys,new Value(TCLTMP_SPLITLEN),TCLTMP_RANGE_LO_V));
}","private void startForeachSplit(String procName,Var arrayVar,String contentsVar,int splitDegree,int leafDegree,boolean haveKeys,List<PassedVar> usedVars,List<RefCount> perIterIncrs){
  pointStack.peek().add(Turbine.containerSize(TCLTMP_CONTAINER_SIZE,varToExpr(arrayVar)));
  Value containerSize=new Value(TCLTMP_CONTAINER_SIZE);
  Expression lastIndex=Square.arithExpr(containerSize,new Token(""String_Node_Str""),new LiteralInt(1));
  handleForeachContainerRefcounts(perIterIncrs,containerSize);
  ArrayList<PassedVar> splitUsedVars=new ArrayList<PassedVar>(usedVars);
  splitUsedVars.add(new PassedVar(arrayVar,false));
  startRangeSplit(procName,splitUsedVars,perIterIncrs,splitDegree,leafDegree,LiteralInt.ZERO,lastIndex,LiteralInt.ONE);
  pointStack.peek().add(new SetVariable(TCLTMP_SPLITLEN,Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,TCLTMP_RANGE_LO)))));
  pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys,new Value(TCLTMP_SPLITLEN),TCLTMP_RANGE_LO_V));
}",0.873855544252289
133030,"/** 
 * Do the manipulation necessary to allow an old instruction output variable to be replaced with a new one. Assume that newOut is a value type of oldOut
 * @param instBuffer append any fixup instructions here
 * @param newOut
 * @param oldOut
 */
public static void replaceInstructionOutputVar(Block block,List<Instruction> instBuffer,Var newOut,Var oldOut){
  block.declareVariable(newOut);
  if (Types.isRefTo(oldOut.type(),newOut.type())) {
    Var refVar;
    if (oldOut.storage() == VarStorage.ALIAS) {
      refVar=new Var(oldOut.type(),oldOut.name(),VarStorage.TEMP,oldOut.defType(),oldOut.mapping());
      block.replaceVarDeclaration(oldOut,refVar);
      Map<Var,Arg> renames=Collections.singletonMap(oldOut,Arg.createVar(refVar));
      for (      Instruction inst : instBuffer) {
        inst.renameVars(renames);
      }
    }
 else {
      refVar=oldOut;
    }
    instBuffer.add(TurbineOp.addressOf(refVar,newOut));
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + oldOut + ""String_Node_Str""+ newOut+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}","/** 
 * Do the manipulation necessary to allow an old instruction output variable to be replaced with a new one. Assume that newOut is a value type of oldOut
 * @param targetBlock 
 * @param instBuffer append any fixup instructions here
 * @param newOut
 * @param oldOut
 */
public static void replaceInstructionOutputVar(Block block,Block targetBlock,List<Instruction> instBuffer,Var newOut,Var oldOut){
  replaceInstOutput(block,targetBlock,instBuffer,newOut,oldOut);
}",0.4818355640535373
133031,"public static void fixupImmChange(Block srcBlock,Block targetBlock,MakeImmChange change,List<Instruction> instBuffer,List<Var> newOutVars,List<Var> oldOutVars){
  for (  Instruction newInst : change.newInsts) {
    instBuffer.add(newInst);
  }
  if (!change.isOutVarSame()) {
    Var newOut=change.newOut;
    Var oldOut=change.oldOut;
    OptUtil.replaceInstructionOutputVar(srcBlock,instBuffer,newOut,oldOut);
  }
  if (newOutVars != null && change.storeOutputVals) {
    for (int i=0; i < newOutVars.size(); i++) {
      Var oldOut=oldOutVars.get(i);
      Var newOut=newOutVars.get(i);
      if (oldOut != newOut)       instBuffer.add(ICInstructions.futureSet(oldOut,Arg.createVar(newOut)));
    }
  }
}","public static void fixupImmChange(Block srcBlock,Block targetBlock,MakeImmChange change,List<Instruction> instBuffer,List<Var> newOutVars,List<Var> oldOutVars){
  for (  Instruction newInst : change.newInsts) {
    instBuffer.add(newInst);
  }
  if (!change.isOutVarSame()) {
    Var newOut=change.newOut;
    Var oldOut=change.oldOut;
    replaceInstOutput(srcBlock,targetBlock,instBuffer,newOut,oldOut);
  }
  if (newOutVars != null && change.storeOutputVals) {
    for (int i=0; i < newOutVars.size(); i++) {
      Var oldOut=oldOutVars.get(i);
      Var newOut=newOutVars.get(i);
      if (oldOut != newOut)       instBuffer.add(ICInstructions.futureSet(oldOut,Arg.createVar(newOut)));
    }
  }
}",0.9517045454545454
133032,"public void replaceVarDeclaration(Var oldV,Var newV){
  if (!this.variables.contains(oldV)) {
    throw new STCRuntimeError(""String_Node_Str"" + oldV.toString() + ""String_Node_Str"");
  }
  Map<Var,Arg> replacement=Collections.singletonMap(oldV,Arg.createVar(newV));
  this.renameVars(replacement,false,true);
}","public boolean replaceVarDeclaration(Var oldV,Var newV){
  if (!this.variables.contains(oldV)) {
    return false;
  }
  Map<Var,Arg> replacement=Collections.singletonMap(oldV,Arg.createVar(newV));
  this.renameVars(replacement,false,true);
  return true;
}",0.5053003533568905
133033,"/** 
 * Handle foreach loop as special case where we want to increment <# of iterations> * <needed increments inside loop> before loop
 */
private void addIncrementsToForeachLoop(Continuation c){
  AbstractForeachLoop loop=(AbstractForeachLoop)c;
  Counters<Var> readIncrs=new Counters<Var>();
  Counters<Var> writeIncrs=new Counters<Var>();
  if (loop.isAsync()) {
    for (    PassedVar v : loop.getPassedVars()) {
      if (!v.writeOnly && RefCounting.hasReadRefCount(v.var)) {
        readIncrs.increment(v.var);
      }
    }
    for (    Var v : loop.getKeepOpenVars()) {
      if (RefCounting.hasWriteRefCount(v)) {
        writeIncrs.increment(v);
      }
    }
  }
  Block loopBody=loop.getLoopBody();
  ListIterator<Instruction> it=loopBody.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (inst.op == Opcode.INCR_REF || inst.op == Opcode.INCR_WRITERS) {
      Var var=inst.getOutput(0);
      Arg amount=inst.getInput(0);
      if (amount.isIntVal() && definedOutsideCont(loop,loopBody,var)) {
        if (inst.op == Opcode.INCR_REF) {
          readIncrs.increment(var);
        }
 else {
          assert(inst.op == Opcode.INCR_WRITERS);
          writeIncrs.increment(var);
        }
        it.remove();
      }
    }
 else {
      break;
    }
  }
  for (  Entry<Var,Long> read : readIncrs.entries()) {
    loop.addStartIncrement(new RefCount(read.getKey(),RefCountType.READERS,Arg.createIntLit(read.getValue())));
  }
  for (  Entry<Var,Long> write : writeIncrs.entries()) {
    loop.addStartIncrement(new RefCount(write.getKey(),RefCountType.WRITERS,Arg.createIntLit(write.getValue())));
  }
}","/** 
 * Handle foreach loop as special case where we want to increment <# of iterations> * <needed increments inside loop> before loop
 */
private void addIncrementsToForeachLoop(Continuation c){
  AbstractForeachLoop loop=(AbstractForeachLoop)c;
  Counters<Var> readIncrs=new Counters<Var>();
  Counters<Var> writeIncrs=new Counters<Var>();
  if (loop.isAsync()) {
    for (    PassedVar v : loop.getPassedVars()) {
      if (!v.writeOnly && RefCounting.hasReadRefCount(v.var)) {
        readIncrs.increment(v.var);
      }
    }
    for (    Var v : loop.getKeepOpenVars()) {
      if (RefCounting.hasWriteRefCount(v)) {
        writeIncrs.increment(v);
      }
    }
  }
  Block loopBody=loop.getLoopBody();
  ListIterator<Instruction> it=loopBody.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (inst.op == Opcode.INCR_REF || inst.op == Opcode.INCR_WRITERS) {
      Var var=inst.getOutput(0);
      Arg amount=inst.getInput(0);
      if (amount.isIntVal() && definedOutsideCont(loop,loopBody,var)) {
        if (inst.op == Opcode.INCR_REF) {
          readIncrs.add(var,amount.getIntLit());
        }
 else {
          assert(inst.op == Opcode.INCR_WRITERS);
          writeIncrs.add(var,amount.getIntLit());
        }
        it.remove();
      }
    }
 else {
      break;
    }
  }
  for (  Entry<Var,Long> read : readIncrs.entries()) {
    loop.addStartIncrement(new RefCount(read.getKey(),RefCountType.READERS,Arg.createIntLit(read.getValue())));
  }
  for (  Entry<Var,Long> write : writeIncrs.entries()) {
    loop.addStartIncrement(new RefCount(write.getKey(),RefCountType.WRITERS,Arg.createIntLit(write.getValue())));
  }
}",0.9777376654632972
133034,"/** 
 * Fuse the other loop into this loop
 */
public void fuseInto(RangeLoop o,boolean insertAtTop){
  Map<Var,Arg> renames=new HashMap<Var,Arg>();
  renames.put(o.loopVar,Arg.createVar(this.loopVar));
  if (countVar != null)   renames.put(o.countVar,Arg.createVar(this.countVar));
  o.replaceVars(renames,false,true);
  this.fuseIntoAbstract(o,insertAtTop);
}","/** 
 * Fuse the other loop into this loop
 */
public void fuseInto(RangeLoop o,boolean insertAtTop){
  Map<Var,Arg> renames=new HashMap<Var,Arg>();
  renames.put(o.loopVar,Arg.createVar(this.loopVar));
  if (loopCounterVar != null)   renames.put(o.loopCounterVar,Arg.createVar(this.loopCounterVar));
  o.replaceVars(renames,false,true);
  this.fuseIntoAbstract(o,insertAtTop);
}",0.8729729729729729
133035,"private RangeLoop(String loopName,Block block,Var loopVar,Var countVar,Arg start,Arg end,Arg increment,List<PassedVar> passedVars,List<Var> keepOpenVars,int desiredUnroll,boolean unrolled,int splitDegree,int leafDegree,List<RefCount> startIncrements,List<RefCount> endDecrements){
  super(block,passedVars,keepOpenVars,startIncrements,endDecrements);
  assert(start.isImmediateInt());
  assert(end.isImmediateInt());
  assert(increment.isImmediateInt());
  assert(loopVar.type().equals(Types.V_INT));
  this.loopName=loopName;
  this.loopVar=loopVar;
  this.countVar=countVar;
  this.start=start;
  this.end=end;
  this.increment=increment;
  this.desiredUnroll=desiredUnroll;
  this.unrolled=unrolled;
  this.splitDegree=splitDegree;
  this.leafDegree=leafDegree;
}","private RangeLoop(Block block,String loopName,Var loopVar,Var loopCounterVar,Arg start,Arg end,Arg increment,List<PassedVar> passedVars,List<Var> keepOpenVars,int desiredUnroll,boolean unrolled,int splitDegree,int leafDegree,List<RefCount> startIncrements,List<RefCount> endDecrements){
  super(block,loopName,loopVar,loopCounterVar,splitDegree,leafDegree,desiredUnroll,unrolled,passedVars,keepOpenVars,startIncrements,endDecrements);
  assert(loopVar.type().equals(Types.V_INT));
  assert(start.isImmediateInt());
  assert(end.isImmediateInt());
  assert(increment.isImmediateInt());
  this.start=start;
  this.end=end;
  this.increment=increment;
}",0.557909604519774
133036,"public AbstractForeachLoop(Block loopBody,List<PassedVar> passedVars,List<Var> keepOpenVars,List<RefCount> startIncrements,List<RefCount> endDecrements){
  super(loopBody,passedVars,keepOpenVars);
  this.startIncrements=new ArrayList<RefCount>(startIncrements);
  this.endDecrements=new ArrayList<RefCount>(endDecrements);
}","public AbstractForeachLoop(Block loopBody,String loopName,Var loopVar,Var loopCounterVar,int splitDegree,int leafDegree,int desiredUnroll,boolean unrolled,List<PassedVar> passedVars,List<Var> keepOpenVars,List<RefCount> startIncrements,List<RefCount> endDecrements){
  super(loopBody,passedVars,keepOpenVars);
  assert(loopCounterVar == null || loopCounterVar.type().equals(Types.V_INT));
  this.loopName=loopName;
  this.loopVar=loopVar;
  this.loopCounterVar=loopCounterVar;
  this.splitDegree=splitDegree;
  this.leafDegree=leafDegree;
  this.desiredUnroll=desiredUnroll;
  this.unrolled=unrolled;
  this.startIncrements=new ArrayList<RefCount>(startIncrements);
  this.endDecrements=new ArrayList<RefCount>(endDecrements);
}",0.6159695817490495
133037,"public boolean fuseable(RangeLoop o){
  return this.start.equals(o.start) && this.increment.equals(o.increment) && this.end.equals(o.end)&& this.desiredUnroll == o.desiredUnroll && this.splitDegree == o.splitDegree && (this.countVar == null) == (o.countVar == null);
}","public boolean fuseable(RangeLoop o){
  return this.start.equals(o.start) && this.increment.equals(o.increment) && this.end.equals(o.end)&& this.desiredUnroll == o.desiredUnroll && this.splitDegree == o.splitDegree && (this.loopCounterVar == null) == (o.loopCounterVar == null);
}",0.9416058394160584
133038,"public ForeachLoop(String loopName,Var arrayVar,Var loopVar,Var loopCounterVar,int splitDegree,int leafDegree,boolean arrayClosed,List<PassedVar> passedVars,List<Var> keepOpenVars,List<RefCount> startIncrements,List<RefCount> endDecrements){
  this(loopName,new Block(BlockType.FOREACH_BODY,null),arrayVar,loopVar,loopCounterVar,splitDegree,leafDegree,arrayClosed,passedVars,keepOpenVars,startIncrements,endDecrements);
}","public ForeachLoop(String loopName,Var arrayVar,Var loopVar,Var loopCounterVar,int splitDegree,int leafDegree,boolean arrayClosed,List<PassedVar> passedVars,List<Var> keepOpenVars,List<RefCount> startIncrements,List<RefCount> endDecrements){
  this(new Block(BlockType.FOREACH_BODY,null),loopName,arrayVar,loopVar,loopCounterVar,splitDegree,leafDegree,arrayClosed,passedVars,keepOpenVars,startIncrements,endDecrements);
}",0.978622327790974
133039,"@Override public boolean tryUnroll(Logger logger,Block outerBlock){
  logger.trace(""String_Node_Str"" + loopName + ""String_Node_Str""+ desiredUnroll);
  if (this.unrolled) {
    return false;
  }
 else   if (this.desiredUnroll > 1) {
    if (this.countVar != null) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    doUnroll(logger,outerBlock,desiredUnroll);
    return true;
  }
 else   if (start.isIntVal() && end.isIntVal() && increment.isIntVal()) {
    long iters=calcIterations(start.getIntLit(),end.getIntLit(),increment.getIntLit());
    try {
      if (iters <= Settings.getLong(Settings.OPT_UNROLL_LOOP_THRESHOLD_ITERS)) {
        long instCount=loopBody.getInstructionCount();
        long extraInstructions=instCount * (iters - 1);
        long extraInstructionThreshold=Settings.getLong(Settings.OPT_UNROLL_LOOP_THRESHOLD_INSTS);
        if (extraInstructions <= extraInstructionThreshold) {
          doUnroll(logger,outerBlock,iters);
          return true;
        }
      }
    }
 catch (    InvalidOptionException e) {
      throw new STCRuntimeError(e.getMessage());
    }
  }
  return false;
}","@Override public boolean tryUnroll(Logger logger,Block outerBlock){
  logger.trace(""String_Node_Str"" + loopName + ""String_Node_Str""+ desiredUnroll);
  if (this.unrolled) {
    return false;
  }
 else   if (this.desiredUnroll > 1) {
    if (this.loopCounterVar != null) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    doUnroll(logger,outerBlock,desiredUnroll);
    return true;
  }
 else   if (start.isIntVal() && end.isIntVal() && increment.isIntVal()) {
    long iters=calcIterations(start.getIntLit(),end.getIntLit(),increment.getIntLit());
    try {
      if (iters <= Settings.getLong(Settings.OPT_UNROLL_LOOP_THRESHOLD_ITERS)) {
        long instCount=loopBody.getInstructionCount();
        long extraInstructions=instCount * (iters - 1);
        long extraInstructionThreshold=Settings.getLong(Settings.OPT_UNROLL_LOOP_THRESHOLD_INSTS);
        if (extraInstructions <= extraInstructionThreshold) {
          doUnroll(logger,outerBlock,iters);
          return true;
        }
      }
    }
 catch (    InvalidOptionException e) {
      throw new STCRuntimeError(e.getMessage());
    }
  }
  return false;
}",0.9930615784908932
133040,"public static TclTree allocateUpdateable(String tclName,String typePrefix,Expression initReaders,Expression initWriters){
  return new Command(ALLOCATE_CUSTOM,new Token(tclName),new Token(typePrefix),initReaders,initWriters);
}","public static TclTree allocateUpdateable(String tclName,String typePrefix,Expression initReaders){
  return new Command(ALLOCATE_CUSTOM,new Token(tclName),new Token(typePrefix),initReaders);
}",0.9164677804295944
133041,"private void allocateUpdateable(Var var,Arg initReaders,Arg initWriters) throws UndefinedTypeException {
  String tprefix=typeToString(var.type().primType());
  pointStack.peek().add(Turbine.allocateUpdateable(prefixVar(var),tprefix,argToExpr(initReaders),argToExpr(initWriters)));
}","private void allocateUpdateable(Var var,Arg initReaders,Arg initWriters) throws UndefinedTypeException {
  String tprefix=typeToString(var.type().primType());
  pointStack.peek().add(Turbine.allocateUpdateable(prefixVar(var),tprefix,argToExpr(initReaders)));
}",0.9576427255985268
133042,"/** 
 * Return true if inst2 writes some of inst1's required vars
 * @param logger
 * @param inst1
 * @param inst1Inputs
 * @param inst2
 * @param inst2Inputs
 * @return
 */
private boolean writesInputs(Logger logger,Instruction inst1,List<Var> inst1Inputs,Instruction inst2,List<Var> inst2Inputs){
  if (inst2.op == Opcode.ADDRESS_OF && !inst1.getPiecewiseAssignedOutputs().isEmpty() && inst1.getPiecewiseAssignedOutputs().contains(inst2.getOutput(0))) {
    if (logger.isTraceEnabled())     logger.trace(inst2 + ""String_Node_Str"" + inst1);
    return true;
  }
  if (!inst2.getInitializedAliases().isEmpty()) {
    List<Var> initAliases=inst2.getInitializedAliases();
    for (    Var input : inst1.getOutputs()) {
      if (input.storage() == VarStorage.ALIAS && initAliases.contains(input)) {
        if (logger.isTraceEnabled())         logger.trace(inst2 + ""String_Node_Str"" + inst1);
        return true;
      }
    }
  }
  for (  Var inst2Output : inst2.getModifiedOutputs()) {
    if (inst1Inputs.contains(inst2Output)) {
      if (logger.isTraceEnabled())       logger.trace(inst2 + ""String_Node_Str"" + inst1);
      return true;
    }
  }
  return false;
}","/** 
 * Return true if inst2 writes some of inst1's required vars
 * @param logger
 * @param inst1
 * @param inst1Inputs
 * @param inst2
 * @param inst2Inputs
 * @return
 */
private boolean writesInputs(Logger logger,Instruction inst1,List<Var> inst1Inputs,Instruction inst2,List<Var> inst2Inputs){
  if (inst2.op == Opcode.ADDRESS_OF && !inst1.getPiecewiseAssignedOutputs().isEmpty() && inst1.getPiecewiseAssignedOutputs().contains(inst2.getOutput(0))) {
    if (logger.isTraceEnabled())     logger.trace(inst2 + ""String_Node_Str"" + inst1);
    return true;
  }
  if (initializesOutputs(inst1,inst2)) {
    if (logger.isTraceEnabled())     logger.trace(inst2 + ""String_Node_Str"" + inst1);
    return true;
  }
  for (  Var inst2Output : inst2.getModifiedOutputs()) {
    if (inst1Inputs.contains(inst2Output)) {
      if (logger.isTraceEnabled())       logger.trace(inst2 + ""String_Node_Str"" + inst1);
      return true;
    }
  }
  return false;
}",0.8512045347189419
133043,"private boolean varMustBeInitialized(Var v){
  return v.storage() == VarStorage.ALIAS || v.storage() == VarStorage.LOCAL;
}","private boolean varMustBeInitialized(Var v){
  return v.storage() == VarStorage.ALIAS || v.storage() == VarStorage.LOCAL || Types.isScalarUpdateable(v.type());
}",0.8661971830985915
133044,"@Override public List<Var> tryPiggyback(Counters<Var> increments,RefCountType type){
switch (op) {
case LOAD_BLOB:
case LOAD_BOOL:
case LOAD_FILE:
case LOAD_FLOAT:
case LOAD_INT:
case LOAD_REF:
case LOAD_STRING:
case LOAD_VOID:
{
      Var inVar=getInput(0).getVar();
      if (type == RefCountType.READERS) {
        long amt=increments.getCount(inVar);
        if (amt < 0) {
          assert(getInputs().size() == 1);
          this.args=Arrays.asList(args.get(0),args.get(1),Arg.createIntLit(amt * -1));
          return Collections.singletonList(inVar);
        }
      }
    }
case ARRAY_INSERT_IMM:
case ARRAY_INSERT_FUTURE:
{
    Var arr=getOutput(0);
    if (type == RefCountType.WRITERS) {
      long amt=increments.getCount(arr);
      if (amt < 0) {
        assert(getInputs().size() == 2);
        this.args=Arrays.asList(args.get(0),args.get(1),args.get(2),Arg.createIntLit(amt * -1));
        return Collections.singletonList(arr);
      }
    }
  }
}
return Var.NONE;
}","@Override public List<Var> tryPiggyback(Counters<Var> increments,RefCountType type){
switch (op) {
case LOAD_BLOB:
case LOAD_BOOL:
case LOAD_FILE:
case LOAD_FLOAT:
case LOAD_INT:
case LOAD_REF:
case LOAD_STRING:
case LOAD_VOID:
{
      Var inVar=getInput(0).getVar();
      if (type == RefCountType.READERS) {
        long amt=increments.getCount(inVar);
        if (amt < 0) {
          assert(getInputs().size() == 1);
          this.args=Arrays.asList(args.get(0),args.get(1),Arg.createIntLit(amt * -1));
          return Collections.singletonList(inVar);
        }
      }
      break;
    }
case ARRAY_INSERT_IMM:
case ARRAY_INSERT_FUTURE:
{
    Var arr=getOutput(0);
    if (type == RefCountType.WRITERS) {
      long amt=increments.getCount(arr);
      if (amt < 0) {
        assert(getInputs().size() == 2);
        this.args=Arrays.asList(args.get(0),args.get(1),args.get(2),Arg.createIntLit(amt * -1));
        return Collections.singletonList(arr);
      }
    }
    break;
  }
}
return Var.NONE;
}",0.9879638916750252
133045,"/** 
 * Try reordering instructions
 * @param logger
 * @param block
 */
private void reorderInBlock(Logger logger,Block block){
  logger.trace(""String_Node_Str"");
  ArrayList<Instruction> instructionsCopy=new ArrayList<Instruction>(block.getInstructions());
  ArrayList<Instruction> newInstructions=new ArrayList<Instruction>();
  MultiMap<Instruction,Instruction> after=new MultiMap<Instruction,Instruction>();
  boolean moved=false;
  for (int i=0; i < instructionsCopy.size(); i++) {
    Instruction inst1=instructionsCopy.get(i);
    boolean move=searchForInputWriter(logger,instructionsCopy,i,inst1,after);
    if (move) {
      moved=true;
    }
 else {
      newInstructions.add(inst1);
    }
  }
  if (moved) {
    rebuildInstructions(block,newInstructions,after);
    block.replaceInstructions(newInstructions);
    move++;
  }
 else {
    noMove++;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + move + ""String_Node_Str""+ (move + noMove));
}","/** 
 * Try reordering instructions
 * @param logger
 * @param block
 */
private void reorderInBlock(Logger logger,Block block){
  logger.trace(""String_Node_Str"");
  ArrayList<Instruction> instructionsCopy=new ArrayList<Instruction>(block.getInstructions());
  ArrayList<Instruction> newInstructions=new ArrayList<Instruction>();
  MultiMap<Instruction,Instruction> after=new MultiMap<Instruction,Instruction>();
  HashSet<Instruction> mustMove=new HashSet<Instruction>();
  boolean moved=false;
  for (int i=0; i < instructionsCopy.size(); i++) {
    Instruction inst1=instructionsCopy.get(i);
    boolean move=searchForInputWriter(logger,instructionsCopy,i,inst1,after,mustMove);
    if (logger.isTraceEnabled())     logger.trace(""String_Node_Str"" + inst1 + ""String_Node_Str""+ move);
    if (move) {
      moved=true;
      if (logger.isTraceEnabled())       logger.trace(""String_Node_Str"" + inst1 + ""String_Node_Str""+ after.get(inst1));
    }
 else {
      newInstructions.add(inst1);
    }
  }
  if (moved) {
    rebuildInstructions(block,newInstructions,after);
    block.replaceInstructions(newInstructions);
    move++;
  }
 else {
    noMove++;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + move + ""String_Node_Str""+ (move + noMove));
}",0.8693713776192599
133046,"private boolean searchForInputWriter(Logger logger,ArrayList<Instruction> instructionsCopy,int i,Instruction inst1,MultiMap<Instruction,Instruction> after){
  List<Var> inst1Inputs=getInputs(inst1);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + inst1 + ""String_Node_Str""+ inst1Inputs);
  boolean move=false;
  boolean canMoveFurther=true;
  for (int j=i + 1; j < instructionsCopy.size(); j++) {
    Instruction inst2=instructionsCopy.get(j);
    if (writesInputs(logger,inst2,getInputs(inst2),inst1)) {
      after.put(inst1,inst2);
      canMoveFurther=false;
    }
    if (canMoveFurther && writesInputs(logger,inst1,inst1Inputs,inst2)) {
      if (pathExists(after,inst1,inst2)) {
        canMoveFurther=false;
      }
 else {
        after.put(inst2,inst1);
        move=true;
      }
    }
  }
  return move;
}","private boolean searchForInputWriter(Logger logger,ArrayList<Instruction> instructionsCopy,int i,Instruction inst1,MultiMap<Instruction,Instruction> after,HashSet<Instruction> mustMove){
  List<Var> inst1Inputs=getInputs(inst1);
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + inst1 + ""String_Node_Str""+ inst1Inputs);
  boolean move=mustMove.contains(inst1);
  boolean canMoveFurther=true;
  for (int j=i + 1; j < instructionsCopy.size(); j++) {
    Instruction inst2=instructionsCopy.get(j);
    List<Var> inst2Inputs=getInputs(inst2);
    if (writesInputs(logger,inst2,inst2Inputs,inst1,inst1Inputs,false)) {
      after.put(inst1,inst2);
      mustMove.add(inst2);
      canMoveFurther=false;
      if (!move) {
        break;
      }
    }
    if (canMoveFurther && writesInputs(logger,inst1,inst1Inputs,inst2,inst2Inputs,true)) {
      if (pathExists(after,inst1,inst2)) {
        canMoveFurther=false;
      }
 else {
        after.put(inst2,inst1);
        move=true;
      }
    }
  }
  return move;
}",0.8700322234156821
133047,"private boolean writesInputs(Logger logger,Instruction inst1,List<Var> inst1Inputs,Instruction inst2){
  if (inst2.op == Opcode.ADDRESS_OF && !inst1.getPiecewiseAssignedOutputs().isEmpty() && inst1.getPiecewiseAssignedOutputs().contains(inst2.getOutput(0))) {
    return true;
  }
  for (  Var inst2Output : inst2.getModifiedOutputs()) {
    if (inst1Inputs.contains(inst2Output)) {
      if (logger.isTraceEnabled())       logger.trace(inst2 + ""String_Node_Str"" + inst1);
      if (Collections.disjoint(inst1.getModifiedOutputs(),inst2.getModifiedOutputs())) {
        logger.trace(""String_Node_Str"");
        return true;
      }
      break;
    }
  }
  return false;
}","/** 
 * Return true if inst2 writes some of inst1's required vars
 * @param logger
 * @param inst1
 * @param inst1Inputs
 * @param inst2
 * @param inst2Inputs
 * @return
 */
private boolean writesInputs(Logger logger,Instruction inst1,List<Var> inst1Inputs,Instruction inst2,List<Var> inst2Inputs){
  if (inst2.op == Opcode.ADDRESS_OF && !inst1.getPiecewiseAssignedOutputs().isEmpty() && inst1.getPiecewiseAssignedOutputs().contains(inst2.getOutput(0))) {
    if (logger.isTraceEnabled())     logger.trace(inst2 + ""String_Node_Str"" + inst1);
    return true;
  }
  if (!inst2.getInitializedAliases().isEmpty()) {
    List<Var> initAliases=inst2.getInitializedAliases();
    for (    Var input : inst1.getOutputs()) {
      if (input.storage() == VarStorage.ALIAS && initAliases.contains(input)) {
        if (logger.isTraceEnabled())         logger.trace(inst2 + ""String_Node_Str"" + inst1);
        return true;
      }
    }
  }
  for (  Var inst2Output : inst2.getModifiedOutputs()) {
    if (inst1Inputs.contains(inst2Output)) {
      if (logger.isTraceEnabled())       logger.trace(inst2 + ""String_Node_Str"" + inst1);
      return true;
    }
  }
  return false;
}",0.5195652173913043
133048,"/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param leafDegree 
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,int leafDegree,Expression startE,Expression endE,Expression incrE){
  List<Var> allUsedVars=Var.varListUnion(usedVariables,keepOpenVars);
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : allUsedVars) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : allUsedVars) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  incrementAllRefs(usedVariables,keepOpenVars,new Value(TCLTMP_ITERSTOTAL));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(leafDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",splitDegree,new Value(TCLTMP_ITERSLEFT),leafDegree,new Value(TCLTMP_RANGE_INC))))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL,Target.rankAny(),true));
  pointStack.push(inner);
}","/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param leafDegree 
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,int leafDegree,Expression startE,Expression endE,Expression incrE){
  List<Var> allUsedVars=Var.varListUnion(usedVariables,keepOpenVars);
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : allUsedVars) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : allUsedVars) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  incrementAllRefs(usedVariables,keepOpenVars,new Value(TCLTMP_ITERSTOTAL));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(leafDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",leafDegree,new Value(TCLTMP_ITERSLEFT),splitDegree,new Value(TCLTMP_RANGE_INC))))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL,Target.rankAny(),true));
  pointStack.push(inner);
}",0.9975669099756692
133049,"/** 
 * Try to squash together waits, e.g. wait (x) { < do some minor work that doesn't help with progress > wait (y) { < do some real work > } } gets changed to wait (x, y) { ... }
 * @param logger
 * @param fn
 * @param block
 */
private void squashWaits(Logger logger,Function fn,WaitStatement wait,ExecContext waitContext){
  Block block=wait.getBlock();
  WaitStatement innerWait=null;
  for (  Continuation c : block.getContinuations()) {
    if (c.isAsync()) {
      if (c.getType() == ContinuationType.WAIT_STATEMENT) {
        if (innerWait != null) {
          return;
        }
 else {
          innerWait=(WaitStatement)c;
        }
      }
 else {
        return;
      }
    }
  }
  ExecContext innerContext=innerWait.childContext(waitContext);
  if (innerContext != waitContext)   return;
  for (  Var waitVar : innerWait.getWaitVars()) {
    if (block.getVariables().contains(waitVar)) {
      return;
    }
  }
  if (!ProgressOpcodes.isNonProgress(block)) {
    return;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + innerWait.getWaitVars() + ""String_Node_Str""+ ""String_Node_Str""+ wait.getWaitVars()+ ""String_Node_Str"");
  wait.addWaitVars(innerWait.getWaitVars());
  innerWait.inlineInto(block);
}","/** 
 * Try to squash together waits, e.g. wait (x) { < do some minor work that doesn't help with progress > wait (y) { < do some real work > } } gets changed to wait (x, y) { ... }
 * @param logger
 * @param fn
 * @param block
 */
private void squashWaits(Logger logger,Function fn,WaitStatement wait,ExecContext waitContext){
  Block block=wait.getBlock();
  WaitStatement innerWait=null;
  for (  Continuation c : block.getContinuations()) {
    if (c.isAsync()) {
      if (c.getType() == ContinuationType.WAIT_STATEMENT) {
        if (innerWait != null) {
          return;
        }
 else {
          innerWait=(WaitStatement)c;
        }
      }
 else {
        return;
      }
    }
  }
  if (innerWait == null)   return;
  ExecContext innerContext=innerWait.childContext(waitContext);
  if (innerContext != waitContext)   return;
  for (  Var waitVar : innerWait.getWaitVars()) {
    if (block.getVariables().contains(waitVar)) {
      return;
    }
  }
  if (!ProgressOpcodes.isNonProgress(block)) {
    return;
  }
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + innerWait.getWaitVars() + ""String_Node_Str""+ ""String_Node_Str""+ wait.getWaitVars()+ ""String_Node_Str"");
  wait.addWaitVars(innerWait.getWaitVars());
  innerWait.inlineInto(block);
}",0.9860613301473516
133050,"/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    pipe.addPass(inliner);
    pipe.addPass(new FixupVariables());
    pipe.addPass(new ConstantFold());
    if (iteration == 0) {
      pipe.addPass(new LoopUnroller());
    }
    pipe.addPass(new HoistLoops());
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 3) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}","/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if (iteration == 0) {
      pipe.addPass(new LoopUnroller());
    }
    pipe.addPass(new HoistLoops());
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 3) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}",0.9830938292476754
133051,"private void elimRefCountsCont(Logger logger,Function f,Continuation cont,HierarchicalSet<Var> parentAssignedAliasVars){
  for (  Block block : cont.getBlocks()) {
    Counters<Var> readIncrements=new Counters<Var>();
    Counters<Var> writeIncrements=new Counters<Var>();
    if (isSingleSpawnCont(cont)) {
      for (      Var keepOpen : cont.getKeepOpenVars()) {
        if (RefCounting.hasWriteRefCount(keepOpen)) {
          writeIncrements.decrement(keepOpen);
        }
      }
      for (      Var passedIn : cont.getPassedInVars()) {
        if (RefCounting.hasReadRefCount(passedIn)) {
          readIncrements.decrement(passedIn);
        }
      }
    }
    HierarchicalSet<Var> contAssignedAliasVars=parentAssignedAliasVars.makeChild();
    for (    Var v : cont.constructDefinedVars()) {
      if (v.storage() == VarStorage.ALIAS) {
        contAssignedAliasVars.add(v);
      }
    }
    elimRefCountsRec(logger,f,block,readIncrements,writeIncrements,contAssignedAliasVars);
  }
}","private void elimRefCountsCont(Logger logger,Function f,Continuation cont,HierarchicalSet<Var> parentAssignedAliasVars){
  for (  Block block : cont.getBlocks()) {
    Counters<Var> readIncrements=new Counters<Var>();
    Counters<Var> writeIncrements=new Counters<Var>();
    if (isSingleSpawnCont(cont) && cont.getType() != ContinuationType.LOOP) {
      for (      Var keepOpen : cont.getKeepOpenVars()) {
        if (RefCounting.hasWriteRefCount(keepOpen)) {
          writeIncrements.decrement(keepOpen);
        }
      }
      for (      Var passedIn : cont.getPassedInVars()) {
        if (RefCounting.hasReadRefCount(passedIn)) {
          readIncrements.decrement(passedIn);
        }
      }
    }
    HierarchicalSet<Var> contAssignedAliasVars=parentAssignedAliasVars.makeChild();
    for (    Var v : cont.constructDefinedVars()) {
      if (v.storage() == VarStorage.ALIAS) {
        contAssignedAliasVars.add(v);
      }
    }
    elimRefCountsRec(logger,f,block,readIncrements,writeIncrements,contAssignedAliasVars);
  }
}",0.9788489916379736
133052,"private void updateInstructionRefCount(Instruction inst,Counters<Var> readIncrements,Counters<Var> writeIncrements){
  Pair<List<Var>,List<Var>> refIncrs=inst.getIncrVars();
  List<Var> readIncrVars=refIncrs.val1;
  List<Var> writeIncrVars=refIncrs.val2;
  for (  Var v : readIncrVars) {
    if (RefCounting.hasReadRefCount(v)) {
      readIncrements.increment(v);
    }
  }
  for (  Var v : writeIncrVars) {
    if (RefCounting.hasWriteRefCount(v)) {
      writeIncrements.increment(v);
    }
  }
}","private void updateInstructionRefCount(Instruction inst,Counters<Var> readIncrements,Counters<Var> writeIncrements){
  Pair<List<Var>,List<Var>> refIncrs=inst.getIncrVars();
  List<Var> readIncrVars=refIncrs.val1;
  List<Var> writeIncrVars=refIncrs.val2;
  for (  Var v : readIncrVars) {
    if (RefCounting.hasReadRefCount(v)) {
      readIncrements.increment(v);
    }
  }
  for (  Var v : writeIncrVars) {
    if (RefCounting.hasWriteRefCount(v)) {
      writeIncrements.increment(v);
    }
  }
  if (inst.op == Opcode.LOOP_BREAK) {
    LoopBreak loopBreak=(LoopBreak)inst;
    for (    Var ko : loopBreak.getKeepOpenVars()) {
      assert(RefCounting.hasWriteRefCount(ko));
      writeIncrements.decrement(ko);
    }
    for (    Var pass : loopBreak.getUsedVars()) {
      if (RefCounting.hasReadRefCount(pass)) {
        readIncrements.decrement(pass);
      }
    }
  }
}",0.7247639796659404
133053,"private void updateContinuationRefCount(Continuation cont,Counters<Var> readIncrements,Counters<Var> writeIncrements){
  if (cont.isAsync() && cont.getType() == ContinuationType.WAIT_STATEMENT) {
    long incr=1;
    for (    Var passedIn : cont.getPassedInVars()) {
      if (RefCounting.hasReadRefCount(passedIn)) {
        readIncrements.add(passedIn,incr);
      }
    }
    for (    Var keepOpen : cont.getKeepOpenVars()) {
      if (RefCounting.hasWriteRefCount(keepOpen)) {
        writeIncrements.add(keepOpen,incr);
      }
    }
  }
}","private void updateContinuationRefCount(Continuation cont,Counters<Var> readIncrements,Counters<Var> writeIncrements){
  if (cont.isAsync() && isSingleSpawnCont(cont)) {
    long incr=1;
    for (    Var passedIn : cont.getPassedInVars()) {
      if (RefCounting.hasReadRefCount(passedIn)) {
        readIncrements.add(passedIn,incr);
      }
    }
    for (    Var keepOpen : cont.getKeepOpenVars()) {
      if (RefCounting.hasWriteRefCount(keepOpen)) {
        writeIncrements.add(keepOpen,incr);
      }
    }
  }
}",0.935969868173258
133054,"@Override public void clearKeepOpenVars(){
  this.keepOpenVars.clear();
}","@Override public void clearKeepOpenVars(){
  super.clearKeepOpenVars();
  this.loopContinue.clearKeepOpenVars();
  this.loopBreak.clearKeepOpenVars();
}",0.6133333333333333
133055,"@Override public void addKeepOpenVars(Collection<Var> v){
  super.addKeepOpenVars(v);
  this.loopContinue.removeKeepOpenVars(v);
  this.loopBreak.removeKeepOpenVars(v);
}","@Override public void addKeepOpenVars(Collection<Var> v){
  this.keepOpenVars.addAll(v);
}",0.6307692307692307
133056,"@Override public void startLoop(String loopName,List<Var> loopVars,List<Boolean> definedHere,List<Var> initVals,List<Var> usedVariables,List<Var> keepOpenVars,List<Boolean> blockingVars){
  ArrayList<String> loopFnArgs=new ArrayList<String>();
  ArrayList<Value> firstIterArgs=new ArrayList<Value>();
  loopFnArgs.add(Turbine.LOCAL_STACK_NAME);
  firstIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var arg : loopVars) {
    loopFnArgs.add(prefixVar(arg.name()));
  }
  for (  Var init : initVals) {
    firstIterArgs.add(varToExpr(init));
  }
  for (  Var uv : usedVariables) {
    loopFnArgs.add(prefixVar(uv.name()));
    firstIterArgs.add(varToExpr(uv));
  }
  ArrayList<Value> blockingVals=new ArrayList<Value>();
  assert(blockingVars.size() == initVals.size());
  for (int i=0; i < blockingVars.size(); i++) {
    Var iv=initVals.get(i);
    if (blockingVars.get(i)) {
      blockingVals.add(varToExpr(iv));
    }
  }
  incrementAllRefs(usedVariables,keepOpenVars);
  incrementReaders(initVals,null);
  String uniqueLoopName=uniqueTCLFunctionName(loopName);
  pointStack.peek().add(Turbine.loopRule(uniqueLoopName,firstIterArgs,blockingVals));
  Sequence loopBody=new Sequence();
  Proc loopProc=new Proc(uniqueLoopName,usedTclFunctionNames,loopFnArgs,loopBody);
  tree.add(loopProc);
  pointStack.push(loopBody);
  loopNameStack.push(uniqueLoopName);
}","@Override public void startLoop(String loopName,List<Var> loopVars,List<Boolean> definedHere,List<Var> initVals,List<Var> usedVariables,List<Var> keepOpenVars,List<Boolean> blockingVars){
  ArrayList<String> loopFnArgs=new ArrayList<String>();
  ArrayList<Value> firstIterArgs=new ArrayList<Value>();
  loopFnArgs.add(Turbine.LOCAL_STACK_NAME);
  firstIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var arg : loopVars) {
    loopFnArgs.add(prefixVar(arg.name()));
  }
  for (  Var init : initVals) {
    firstIterArgs.add(varToExpr(init));
  }
  for (  Var uv : usedVariables) {
    loopFnArgs.add(prefixVar(uv.name()));
    firstIterArgs.add(varToExpr(uv));
  }
  ArrayList<Value> blockingVals=new ArrayList<Value>();
  assert(blockingVars.size() == initVals.size());
  for (int i=0; i < blockingVars.size(); i++) {
    Var iv=initVals.get(i);
    if (blockingVars.get(i)) {
      blockingVals.add(varToExpr(iv));
    }
  }
  String uniqueLoopName=uniqueTCLFunctionName(loopName);
  pointStack.peek().add(Turbine.loopRule(uniqueLoopName,firstIterArgs,blockingVals));
  Sequence loopBody=new Sequence();
  Proc loopProc=new Proc(uniqueLoopName,usedTclFunctionNames,loopFnArgs,loopBody);
  tree.add(loopProc);
  pointStack.push(loopBody);
  loopNameStack.push(uniqueLoopName);
}",0.9688321441982726
133057,"@Override public void loopBreak(List<Var> loopUsedVars,List<Var> keepOpenVars){
  decrementAllRefs(loopUsedVars,keepOpenVars);
}","@Override public void loopBreak(List<Var> loopUsedVars,List<Var> keepOpenVars){
}",0.7751196172248804
133058,"/** 
 * Find unneeded vars declared in local block
 * @param block
 * @param stillNeeded
 * @param dependentSets
 * @return
 */
private static Set<Var> unneededVars(Block block,Set<Var> stillNeeded,List<List<Var>> dependentSets){
  HashSet<Var> toRemove=new HashSet<Var>();
  for (  List<Var> dependentSet : dependentSets) {
{
      boolean needed=false;
      for (      Var v : dependentSet) {
        if (stillNeeded.contains(v)) {
          needed=true;
          break;
        }
      }
      if (needed) {
        for (        Var v : dependentSet) {
          stillNeeded.add(v);
        }
      }
    }
  }
  for (  Var v : block.getVariables()) {
    if (!stillNeeded.contains(v)) {
      toRemove.add(v);
    }
  }
  return toRemove;
}","/** 
 * Find unneeded vars declared in local block
 * @param block
 * @param stillNeeded
 * @param dependentSets
 * @return
 */
private static Set<Var> unneededVars(Block block,Set<Var> stillNeeded,List<List<Var>> dependentSets){
  HashSet<Var> removeCandidates=new HashSet<Var>();
  for (  Var v : block.getVariables()) {
    if (!stillNeeded.contains(v)) {
      removeCandidates.add(v);
    }
  }
  Logger logger=Logging.getSTCLogger();
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + removeCandidates + ""String_Node_Str""+ ""String_Node_Str""+ dependentSets);
  }
  boolean converged=false;
  while (!converged && !dependentSets.isEmpty()) {
    Iterator<List<Var>> it=dependentSets.iterator();
    while (it.hasNext()) {
      List<Var> dependentSet=it.next();
      converged=true;
      boolean hasRemoveCandidate=false;
      boolean allRemoveCandidates=true;
      for (      Var v : dependentSet) {
        if (removeCandidates.contains(v)) {
          hasRemoveCandidate=true;
        }
 else {
          allRemoveCandidates=false;
        }
      }
      if (!hasRemoveCandidate) {
        it.remove();
      }
 else       if (!allRemoveCandidates) {
        for (        Var v : dependentSet) {
          removeCandidates.remove(v);
        }
        converged=false;
      }
    }
  }
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + removeCandidates + ""String_Node_Str""+ ""String_Node_Str""+ dependentSets);
  }
  return removeCandidates;
}",0.3465832961143367
133059,"private static List<ComputedValue> updateReplacements(Logger logger,Function function,Instruction inst,State av,HierarchicalMap<Var,Arg> replaceInputs,HierarchicalMap<Var,Arg> replaceAll){
}","private static void updateReplacements(Logger logger,Function function,Instruction inst,State av,List<ComputedValue> icvs,HierarchicalMap<Var,Arg> replaceInputs,HierarchicalMap<Var,Arg> replaceAll){
}",0.5846153846153846
133060,"private static boolean forwardDataflow(Logger logger,Function f,ExecContext execCx,Block block,ListIterator<Instruction> insts,State cv,HierarchicalMap<Var,Arg> replaceInputs,HierarchicalMap<Var,Arg> replaceAll) throws InvalidWriteException {
  boolean anotherPassNeeded=false;
  while (insts.hasNext()) {
    Instruction inst=insts.next();
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + replaceInputs);
      logger.trace(""String_Node_Str"" + replaceAll);
      logger.trace(""String_Node_Str"" + cv.availableVals);
      logger.trace(""String_Node_Str"" + cv.closed);
      logger.trace(""String_Node_Str"");
      logger.trace(""String_Node_Str"" + inst);
    }
    inst.renameInputs(replaceInputs);
    inst.renameVars(replaceAll);
    updateReplacements(logger,f,inst,cv,replaceInputs,replaceAll);
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + inst);
    }
    if (switchToImmediate(logger,f,execCx,block,cv,inst,insts)) {
      continue;
    }
    List<Var> in=inst.getBlockingInputs();
    if (in != null) {
      for (      Var ov : inst.getOutputs()) {
        if (!Types.isScalarValue(ov.type())) {
          cv.setDependencies(ov,in);
        }
      }
    }
    for (    Var out : inst.getClosedOutputs()) {
      cv.close(out,false);
    }
  }
  return anotherPassNeeded;
}","private static boolean forwardDataflow(Logger logger,Function f,ExecContext execCx,Block block,ListIterator<Instruction> insts,State cv,HierarchicalMap<Var,Arg> replaceInputs,HierarchicalMap<Var,Arg> replaceAll) throws InvalidWriteException {
  boolean anotherPassNeeded=false;
  while (insts.hasNext()) {
    Instruction inst=insts.next();
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + replaceInputs);
      logger.trace(""String_Node_Str"" + replaceAll);
      logger.trace(""String_Node_Str"" + cv.availableVals);
      logger.trace(""String_Node_Str"" + cv.closed);
      logger.trace(""String_Node_Str"");
      logger.trace(""String_Node_Str"" + inst);
    }
    inst.renameInputs(replaceInputs);
    inst.renameVars(replaceAll);
    List<ComputedValue> icvs=inst.getComputedValues(cv);
    List<Var> oldAliasOutputs=new ArrayList<Var>(inst.getInitializedAliases());
    updateReplacements(logger,f,inst,cv,icvs,replaceInputs,replaceAll);
    if (!oldAliasOutputs.isEmpty()) {
      assert(oldAliasOutputs.size() == 1);
      if (replaceAll.containsKey(oldAliasOutputs.get(0))) {
        logger.trace(""String_Node_Str"");
        insts.remove();
        continue;
      }
    }
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + inst);
    }
    if (switchToImmediate(logger,f,execCx,block,cv,inst,insts)) {
      continue;
    }
    List<Var> in=inst.getBlockingInputs();
    if (in != null) {
      for (      Var ov : inst.getOutputs()) {
        if (!Types.isScalarValue(ov.type())) {
          cv.setDependencies(ov,in);
        }
      }
    }
    for (    Var out : inst.getClosedOutputs()) {
      cv.close(out,false);
    }
  }
  return anotherPassNeeded;
}",0.8751642575558476
133061,"public static Instruction structLookup(Var oVar,Var structVar,String fieldName){
  return new TurbineOp(Opcode.STRUCT_LOOKUP,Arg.createVar(oVar),Arg.createVar(structVar),Arg.createStringLit(fieldName));
}","public static Instruction structLookup(Var oVar,Var structVar,String fieldName){
}",0.5734265734265734
133062,"/** 
 * Handle a prefix of array lookups for the assign target
 * @param afterActions 
 * @throws UserException
 * @throws UndefinedTypeException
 * @throws TypeMismatchException 
 */
private LValue reduceArrayLVal(Context context,LValue origLval,LValue lval,SwiftAST rValExpr,Type rValType,Deque<Runnable> afterActions) throws TypeMismatchException, UndefinedTypeException, UserException {
  SwiftAST indexExpr=lval.indices.get(0);
  assert(indexExpr.getType() == ExMParser.ARRAY_PATH);
  assert(indexExpr.getChildCount() == 1);
  Type indexType=TypeChecker.findSingleExprType(context,indexExpr.child(0));
  if (!indexType.assignableTo(Types.F_INT)) {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + indexType.typeName());
  }
  if (lval.indices.size() == 1) {
    Var lookedup=assignTo1DArray(context,origLval,lval,rValExpr,rValType,afterActions);
    return new LValue(lval.tree,lookedup,new ArrayList<SwiftAST>());
  }
 else {
    Var lvalArr=context.getDeclaredVariable(lval.varName);
    Type memberType=lval.getType(context,1);
    Var mVar;
    if (Types.isArray(memberType)) {
      String literal=Literals.extractIntLit(context,indexExpr.child(0));
      if (literal != null) {
        long arrIx=Long.parseLong(literal);
        if (Types.isArray(lvalArr.type())) {
          mVar=varCreator.createTmpAlias(context,memberType);
          backend.arrayCreateNestedImm(mVar,lvalArr,Arg.createIntLit(arrIx));
        }
 else {
          assert(Types.isArrayRef(lvalArr.type()));
          mVar=varCreator.createTmpAlias(context,new RefType(memberType));
          backend.arrayRefCreateNestedImm(mVar,origLval.var,lvalArr,Arg.createIntLit(arrIx));
        }
      }
 else {
        mVar=varCreator.createTmpAlias(context,new RefType(memberType));
        Var indexVar=exprWalker.eval(context,indexExpr.child(0),Types.F_INT,false,null);
        if (Types.isArray(lvalArr.type())) {
          backend.arrayCreateNestedFuture(mVar,lvalArr,indexVar);
        }
 else {
          assert(Types.isArrayRef(lvalArr.type()));
          backend.arrayRefCreateNestedFuture(mVar,lvalArr,indexVar,origLval.var);
        }
      }
    }
 else {
      mVar=varCreator.createTmp(context,new RefType(memberType));
    }
    return new LValue(lval.tree,mVar,lval.indices.subList(1,lval.indices.size()));
  }
}","/** 
 * Handle a prefix of array lookups for the assign target
 * @param afterActions 
 * @throws UserException
 * @throws UndefinedTypeException
 * @throws TypeMismatchException 
 */
private LValue reduceArrayLVal(Context context,LValue origLval,LValue lval,SwiftAST rValExpr,Type rValType,Deque<Runnable> afterActions) throws TypeMismatchException, UndefinedTypeException, UserException {
  SwiftAST indexExpr=lval.indices.get(0);
  assert(indexExpr.getType() == ExMParser.ARRAY_PATH);
  assert(indexExpr.getChildCount() == 1);
  Type indexType=TypeChecker.findSingleExprType(context,indexExpr.child(0));
  if (!indexType.assignableTo(Types.F_INT)) {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + indexType.typeName());
  }
  if (lval.indices.size() == 1) {
    Var lookedup=assignTo1DArray(context,origLval,lval,rValExpr,rValType,afterActions);
    return new LValue(lval.tree,lookedup,new ArrayList<SwiftAST>());
  }
 else {
    Var lvalArr=context.getDeclaredVariable(lval.varName);
    Type memberType=lval.getType(context,1);
    Var mVar;
    if (Types.isArray(memberType)) {
      String literal=Literals.extractIntLit(context,indexExpr.child(0));
      if (literal != null) {
        long arrIx=Long.parseLong(literal);
        if (Types.isArray(lvalArr.type())) {
          mVar=varCreator.createTmpAlias(context,memberType);
          backend.arrayCreateNestedImm(mVar,lvalArr,Arg.createIntLit(arrIx));
        }
 else {
          assert(Types.isArrayRef(lvalArr.type()));
          mVar=varCreator.createTmpAlias(context,new RefType(memberType));
          backend.arrayRefCreateNestedImm(mVar,origLval.var,lvalArr,Arg.createIntLit(arrIx));
        }
      }
 else {
        mVar=varCreator.createTmpAlias(context,new RefType(memberType));
        Var indexVar=exprWalker.eval(context,indexExpr.child(0),Types.F_INT,false,null);
        if (Types.isArray(lvalArr.type())) {
          backend.arrayCreateNestedFuture(mVar,lvalArr,indexVar);
        }
 else {
          assert(Types.isArrayRef(lvalArr.type()));
          backend.arrayRefCreateNestedFuture(mVar,origLval.var,lvalArr,indexVar);
        }
      }
    }
 else {
      mVar=varCreator.createTmp(context,new RefType(memberType));
    }
    return new LValue(lval.tree,mVar,lval.indices.subList(1,lval.indices.size()));
  }
}",0.9927194860813704
133063,"public void arrayRefCreateNestedFuture(Var arrayResult,Var arrayVar,Var indexVar,Var outerArr){
  assert(Types.isArrayRef(arrayResult.type()));
  assert(Types.isArrayRef(arrayVar.type()));
  assert(Types.isInt(indexVar.type()));
  assert(Types.isArray(outerArr.type()));
  currBlock().addInstruction(TurbineOp.arrayRefCreateNestedComputed(arrayResult,arrayVar,indexVar,outerArr));
}","public void arrayRefCreateNestedFuture(Var arrayResult,Var outerArr,Var array,Var ix){
  assert(Types.isArrayRef(arrayResult.type()));
  assert(Types.isArrayRef(array.type()));
  assert(Types.isInt(ix.type()));
  assert(Types.isArray(outerArr.type()));
  currBlock().addInstruction(TurbineOp.arrayRefCreateNestedComputed(arrayResult,outerArr,array,ix));
}",0.8792401628222524
133064,"public static Instruction arrayRefCreateNestedComputed(Var arrayResult,Var arrayVar,Var indexVar,Var outerArr){
  return new TurbineOp(Opcode.ARRAYREF_CREATE_NESTED_FUTURE,Arg.createVar(arrayResult),Arg.createVar(arrayVar),Arg.createVar(indexVar),Arg.createVar(outerArr));
}","public static Instruction arrayRefCreateNestedComputed(Var arrayResult,Var outerArr,Var array,Var ix){
}",0.5238095238095238
133065,"public static Instruction arrayRefCreateNestedImmIx(Var arrayResult,Var outerArray,Var array,Arg ix){
  return new TurbineOp(Opcode.ARRAYREF_CREATE_NESTED_IMM,Arg.createVar(arrayResult),Arg.createVar(array),ix,Arg.createVar(outerArray));
}","public static Instruction arrayRefCreateNestedImmIx(Var arrayResult,Var outerArray,Var array,Arg ix){
}",0.6023391812865497
133066,"/** 
 * Do the manipulation necessary to allow an old instruction output variable to be replaced with a new one. Assume that newOut is a value type of oldOut
 * @param instBuffer append any fixup instructions here
 * @param newOut
 * @param oldOut
 */
public static void replaceInstructionOutputVar(Block block,List<Instruction> instBuffer,Var newOut,Var oldOut){
  block.declareVariable(newOut);
  if (Types.isRefTo(oldOut.type(),newOut.type())) {
    if (oldOut.storage() == VarStorage.ALIAS) {
      Var replacement=new Var(oldOut.type(),oldOut.name(),VarStorage.TEMP,oldOut.defType(),oldOut.mapping());
      block.replaceVarDeclaration(oldOut,replacement);
    }
    instBuffer.add(TurbineOp.addressOf(oldOut,newOut));
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + oldOut + ""String_Node_Str""+ newOut+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}","/** 
 * Do the manipulation necessary to allow an old instruction output variable to be replaced with a new one. Assume that newOut is a value type of oldOut
 * @param instBuffer append any fixup instructions here
 * @param newOut
 * @param oldOut
 */
public static void replaceInstructionOutputVar(Block block,List<Instruction> instBuffer,Var newOut,Var oldOut){
  block.declareVariable(newOut);
  if (Types.isRefTo(oldOut.type(),newOut.type())) {
    Var refVar;
    if (oldOut.storage() == VarStorage.ALIAS) {
      refVar=new Var(oldOut.type(),oldOut.name(),VarStorage.TEMP,oldOut.defType(),oldOut.mapping());
      block.replaceVarDeclaration(oldOut,refVar);
      Map<Var,Arg> renames=Collections.singletonMap(oldOut,Arg.createVar(refVar));
      for (      Instruction inst : instBuffer) {
        inst.renameVars(renames);
      }
    }
 else {
      refVar=oldOut;
    }
    instBuffer.add(TurbineOp.addressOf(refVar,newOut));
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + oldOut + ""String_Node_Str""+ newOut+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}",0.8649193548387096
133067,"private void checkVarReferences(Map<String,Var> declared,Instruction inst){
  for (  Arg i : inst.getInputs()) {
    if (i.isVar()) {
      checkVarReference(declared,i.getVar());
    }
  }
  for (  Var o : inst.getOutputs()) {
    checkVarReference(declared,o);
  }
}","private void checkVarReferences(Map<String,Var> declared,Instruction inst){
  for (  Arg i : inst.getInputs()) {
    if (i.isVar()) {
      checkVarReference(declared,i.getVar(),inst.toString());
    }
  }
  for (  Var o : inst.getOutputs()) {
    checkVarReference(declared,o,inst.toString());
  }
}",0.943661971830986
133068,"private void checkVarReference(Map<String,Var> declared,Var referencedVar){
}","private void checkVarReference(Map<String,Var> declared,Var referencedVar,String context){
}",0.9112426035502958
133069,"public void replaceVarDeclaration(Var oldV,Var newV){
  ListIterator<Var> it=variables.listIterator();
  while (it.hasNext()) {
    Var curr=it.next();
    if (curr.name().equals(oldV.name())) {
      it.set(newV);
      return;
    }
  }
  throw new STCRuntimeError(""String_Node_Str"" + oldV.toString() + ""String_Node_Str""+ ""String_Node_Str"");
}","public void replaceVarDeclaration(Var oldV,Var newV){
  if (!this.variables.contains(oldV)) {
    throw new STCRuntimeError(""String_Node_Str"" + oldV.toString() + ""String_Node_Str"");
  }
  Map<Var,Arg> replacement=Collections.singletonMap(oldV,Arg.createVar(newV));
  this.renameVars(replacement,false);
}",0.4930662557781202
133070,"/** 
 * Replace variable declarations
 * @param renames
 */
private void replaceVariableDeclarations(Map<Var,Arg> renames){
  ListIterator<Var> it=variables.listIterator();
  while (it.hasNext()) {
    Var v=it.next();
    if (v.isMapped()) {
      if (renames.containsKey(v)) {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 else {
      if (renames.containsKey(v)) {
        Arg replacement=renames.get(v);
        if (replacement.isVar()) {
          it.set(replacement.getVar());
        }
 else {
          it.remove();
        }
      }
    }
  }
}","/** 
 * Replace variable declarations
 * @param renames
 */
private void replaceVariableDeclarations(Map<Var,Arg> renames){
  ListIterator<Var> it=variables.listIterator();
  while (it.hasNext()) {
    Var v=it.next();
    if (renames.containsKey(v)) {
      Arg replacement=renames.get(v);
      if (replacement.isVar()) {
        it.set(replacement.getVar());
      }
 else {
        it.remove();
      }
    }
  }
}",0.5531914893617021
133071,"/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if ((iteration % 3) == 2) {
      pipe.addPass(new LoopUnroller());
    }
    boolean aggressive=iteration > (nIterations * 2 / 3);
    pipe.addPass(new HoistLoops(aggressive));
    pipe.addPass(new ReorderInstructions());
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 3) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}","/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param debug 
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,boolean debug,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if ((iteration % 3) == 2) {
      pipe.addPass(new LoopUnroller());
      pipe.addPass(Validate.standardValidator());
    }
    boolean aggressive=iteration > (nIterations * 2 / 3);
    pipe.addPass(new HoistLoops(aggressive));
    pipe.addPass(new ReorderInstructions());
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - (nIterations / 4) - 3) {
      pipe.addPass(new Pipeline());
      if (debug)       pipe.addPass(Validate.standardValidator());
    }
    boolean doWaitMerges=iteration == nIterations - (nIterations / 4) - 2;
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    if (debug)     pipe.addPass(Validate.standardValidator());
    pipe.runPipeline(logger,prog,iteration);
  }
}",0.9808722264728386
133072,"private void renameInDefs(Map<Var,Arg> renames,boolean inputsOnly){
  renameMappingInputs(renames);
  if (!inputsOnly) {
    replaceVariableDeclarations(renames);
  }
}","private void renameInDefs(Map<Var,Arg> renames,boolean inputsOnly){
  List<Pair<Var,Var>> changedMappedVars=new ArrayList<Pair<Var,Var>>();
  ListIterator<Var> it=variables.listIterator();
  while (it.hasNext()) {
    Var original, var;
    var=original=it.next();
    boolean removed=false;
    if (!inputsOnly) {
      if (renames.containsKey(var)) {
        Arg replacement=renames.get(var);
        if (replacement.isVar()) {
          var=replacement.getVar();
          it.set(var);
        }
 else {
          it.remove();
          removed=true;
        }
      }
    }
    if (!removed && var.isMapped()) {
      assert(!var.mapping().isMapped());
      if (renames.containsKey(var.mapping())) {
        Arg newMapping=renames.get(var.mapping());
        if (newMapping.isVar() && !newMapping.getVar().equals(var.mapping())) {
          it.remove();
          var=new Var(var.type(),var.name(),var.storage(),var.defType(),newMapping.getVar());
          changedMappedVars.add(Pair.create(original,var));
        }
      }
    }
  }
  if (!changedMappedVars.isEmpty()) {
    for (    Pair<Var,Var> change : changedMappedVars) {
      Var oldV=change.val1;
      Var newV=change.val2;
      this.variables.add(newV);
      renames.put(oldV,Arg.createVar(newV));
    }
  }
}",0.1505524861878453
133073,"/** 
 * @return list of vars that need write refcount increment
 */
public List<Var> getWriteIncrVars(){
  return Var.NONE;
}","@Override public List<Var> getWriteIncrVars(){
  if (functionName.equals(Builtins.RANGE) || functionName.equals(Builtins.RANGE_STEP)) {
    return Arrays.asList(getOutput(0));
  }
  return Var.NONE;
}",0.3692307692307692
133074,"public static Instruction arrayCreateNestedComputed(Var arrayResult,Var array,Var ix){
  return new TurbineOp(Opcode.ARRAY_CREATE_NESTED_FUTURE,Arg.createVar(arrayResult),Arg.createVar(array),Arg.createVar(ix));
}","public static Instruction arrayCreateNestedComputed(Var arrayResult,Var array,Var ix){
  assert(Types.isArrayRef(arrayResult.type()));
  assert(Types.isArray(array.type()));
  assert(Types.isInt(ix.type()));
  return new TurbineOp(Opcode.ARRAY_CREATE_NESTED_FUTURE,Arg.createVar(arrayResult),Arg.createVar(array),Arg.createVar(ix));
}",0.7787934186471663
133075,"private void elimRefCountsRec(Logger logger,Function f,Block block,Counters<Var> readIncrements,Counters<Var> writeIncrements,Set<Var> parentAssignedAliasVars){
  fixBlockRefCounting(logger,block,readIncrements,writeIncrements,parentAssignedAliasVars);
  Set<Var> assignedAliasVars=new HashSet<Var>();
  findAssignedAliasVars(block,assignedAliasVars);
  assignedAliasVars.addAll(parentAssignedAliasVars);
  for (  Continuation cont : block.getContinuations()) {
    elimRefCountsCont(logger,f,cont,assignedAliasVars);
  }
}","private void elimRefCountsRec(Logger logger,Function f,Block block,Counters<Var> readIncrements,Counters<Var> writeIncrements,HierarchicalSet<Var> parentAssignedAliasVars){
  fixBlockRefCounting(logger,block,readIncrements,writeIncrements,parentAssignedAliasVars);
  HierarchicalSet<Var> assignedAliasVars=parentAssignedAliasVars.makeChild();
  findAssignedAliasVars(block,assignedAliasVars);
  for (  Continuation cont : block.getContinuations()) {
    elimRefCountsCont(logger,f,cont,assignedAliasVars);
  }
}",0.7040618955512572
133076,"@Override public void optimize(Logger logger,Function f) throws UserException {
  elimRefCountsRec(logger,f,f.getMainblock(),new Counters<Var>(),new Counters<Var>(),Collections.<Var>emptySet());
}","@Override public void optimize(Logger logger,Function f) throws UserException {
  elimRefCountsRec(logger,f,f.getMainblock(),new Counters<Var>(),new Counters<Var>(),new HierarchicalSet<Var>());
}",0.9156010230179028
133077,"private void elimRefCountsCont(Logger logger,Function f,Continuation cont,Set<Var> parentAssignedAliasVars){
  for (  Block block : cont.getBlocks()) {
    Counters<Var> readIncrements=new Counters<Var>();
    Counters<Var> writeIncrements=new Counters<Var>();
    if (cont.isAsync() && cont.getType() == ContinuationType.WAIT_STATEMENT) {
      for (      Var keepOpen : cont.getKeepOpenVars()) {
        if (RefCounting.hasWriteRefCount(keepOpen)) {
          writeIncrements.decrement(keepOpen);
        }
      }
      for (      Var passedIn : cont.getPassedInVars()) {
        if (RefCounting.hasReadRefCount(passedIn)) {
          readIncrements.decrement(passedIn);
        }
      }
    }
    elimRefCountsRec(logger,f,block,readIncrements,writeIncrements,parentAssignedAliasVars);
  }
}","private void elimRefCountsCont(Logger logger,Function f,Continuation cont,HierarchicalSet<Var> parentAssignedAliasVars){
  for (  Block block : cont.getBlocks()) {
    Counters<Var> readIncrements=new Counters<Var>();
    Counters<Var> writeIncrements=new Counters<Var>();
    if (isSingleSpawnCont(cont)) {
      for (      Var keepOpen : cont.getKeepOpenVars()) {
        if (RefCounting.hasWriteRefCount(keepOpen)) {
          writeIncrements.decrement(keepOpen);
        }
      }
      for (      Var passedIn : cont.getPassedInVars()) {
        if (RefCounting.hasReadRefCount(passedIn)) {
          readIncrements.decrement(passedIn);
        }
      }
    }
    HierarchicalSet<Var> contAssignedAliasVars=parentAssignedAliasVars.makeChild();
    for (    Var v : cont.constructDefinedVars()) {
      contAssignedAliasVars.add(v);
    }
    elimRefCountsRec(logger,f,block,readIncrements,writeIncrements,contAssignedAliasVars);
  }
}",0.836405529953917
133078,"/** 
 * Update variable passing for nested continuation
 * @param logger
 * @param function
 * @param continuation
 * @param visible
 * @param referencedGlobals
 * @param outerBlockVars
 * @param neededVars
 */
private static void fixupContinuationRec(Logger logger,Function function,Continuation continuation,HierarchicalMap<String,Var> visible,Set<String> referencedGlobals,Set<String> outerBlockVars,Set<String> neededVars){
  List<Var> constructVars=continuation.constructDefinedVars();
  List<String> constructVarNames=null;
  if (constructVars != null) {
    constructVarNames=Var.nameList(constructVars);
  }
  for (  Block innerBlock : continuation.getBlocks()) {
    HierarchicalMap<String,Var> childVisible=visible.makeChildMap();
    if (constructVars != null) {
      for (      Var v : constructVars) {
        childVisible.put(v.name(),v);
      }
    }
    HashSet<String> innerNeededVars=fixupBlockRec(logger,function,innerBlock,childVisible,referencedGlobals);
    if (constructVarNames != null) {
      innerNeededVars.removeAll(constructVarNames);
    }
    if (continuation.inheritsParentVars()) {
      innerNeededVars.removeAll(outerBlockVars);
      neededVars.addAll(innerNeededVars);
    }
 else {
      rebuildContinuationPassedVars(function,continuation,visible,outerBlockVars,neededVars,innerNeededVars);
    }
  }
}","/** 
 * Update variable passing for nested continuation
 * @param logger
 * @param function
 * @param continuation
 * @param visible
 * @param referencedGlobals
 * @param outerBlockVars
 * @param neededVars
 */
private static void fixupContinuationRec(Logger logger,Function function,Continuation continuation,HierarchicalMap<String,Var> visible,Set<String> referencedGlobals,Set<String> outerBlockVars,Set<String> neededVars){
  List<Var> constructVars=continuation.constructDefinedVars();
  List<String> constructVarNames=Var.nameList(constructVars);
  for (  Block innerBlock : continuation.getBlocks()) {
    HierarchicalMap<String,Var> childVisible=visible.makeChildMap();
    for (    Var v : constructVars) {
      childVisible.put(v.name(),v);
    }
    HashSet<String> innerNeededVars=fixupBlockRec(logger,function,innerBlock,childVisible,referencedGlobals);
    if (!constructVarNames.isEmpty()) {
      innerNeededVars.removeAll(constructVarNames);
    }
    if (continuation.inheritsParentVars()) {
      innerNeededVars.removeAll(outerBlockVars);
      neededVars.addAll(innerNeededVars);
    }
 else {
      rebuildContinuationPassedVars(function,continuation,visible,outerBlockVars,neededVars,innerNeededVars);
    }
  }
}",0.905850445563735
133079,"/** 
 * Set up renames for local variables in inline block
 * @param prog program
 * @param targetFunction function block being inlined into
 * @param inlineBlock block to be inlined
 * @param replacements updated with new renames
 */
private void chooseUniqueNames(Logger logger,Program prog,Function targetFunction,Block inlineBlock,Map<String,Arg> replacements){
  Set<String> excludedNames=new HashSet<String>();
  excludedNames.addAll(prog.getGlobalConsts().keySet());
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(inlineBlock);
  while (!blocks.isEmpty()) {
    Block block=blocks.pop();
    for (    Var v : block.getVariables()) {
      if (v.defType() != DefType.GLOBAL_CONST) {
        updateName(logger,block,targetFunction,replacements,excludedNames,v);
      }
    }
    for (    Continuation c : block.getContinuations()) {
      List<Var> constructVars=c.constructDefinedVars();
      if (constructVars != null) {
        for (        Var cv : constructVars) {
          updateName(logger,block,targetFunction,replacements,excludedNames,cv);
        }
      }
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
}","/** 
 * Set up renames for local variables in inline block
 * @param prog program
 * @param targetFunction function block being inlined into
 * @param inlineBlock block to be inlined
 * @param replacements updated with new renames
 */
private void chooseUniqueNames(Logger logger,Program prog,Function targetFunction,Block inlineBlock,Map<String,Arg> replacements){
  Set<String> excludedNames=new HashSet<String>();
  excludedNames.addAll(prog.getGlobalConsts().keySet());
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(inlineBlock);
  while (!blocks.isEmpty()) {
    Block block=blocks.pop();
    for (    Var v : block.getVariables()) {
      if (v.defType() != DefType.GLOBAL_CONST) {
        updateName(logger,block,targetFunction,replacements,excludedNames,v);
      }
    }
    for (    Continuation c : block.getContinuations()) {
      for (      Var cv : c.constructDefinedVars()) {
        updateName(logger,block,targetFunction,replacements,excludedNames,cv);
      }
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
}",0.7816901408450704
133080,"/** 
 * @param logger
 * @param curr current block
 * @param ancestors ancestors of current block
 * @param maxHoist maximum number of blocks can lift out
 * @param maxLoopHoist max number of block can lift out withoutgoing through loop
 * @param writeMap map for current block filled in with anything defined by construct or outer blocks
 * @return true if change made
 */
private static boolean hoistRec(Logger logger,Block curr,List<Block> ancestors,int maxHoist,int maxLoopHoist,HierarchicalMap<String,Block> writeMap){
  boolean changed=false;
  updateMapWithWrites(curr,writeMap);
  if (maxHoist > 0) {
    changed=tryHoist(logger,curr,ancestors,maxHoist,maxLoopHoist,writeMap);
  }
  ancestors.add(curr);
  for (  Continuation c : curr.getContinuations()) {
    int childHoist=canHoistThrough(c) ? maxHoist + 1 : 0;
    int childLoopHoist=c.isLoop() ? 0 : maxLoopHoist + 1;
    for (    Block b : c.getBlocks()) {
      HierarchicalMap<String,Block> childWriteMap=writeMap.makeChildMap();
      List<Var> constructVars=c.constructDefinedVars();
      if (constructVars != null) {
        for (        Var v : constructVars) {
          if (trackWrites(v)) {
            childWriteMap.put(v.name(),b);
          }
        }
      }
      if (c.getType() == ContinuationType.WAIT_STATEMENT) {
        for (        Var waitVar : ((WaitStatement)c).getWaitVars()) {
          if (trackWrites(waitVar)) {
            childWriteMap.put(waitVar.name(),b);
          }
        }
      }
      if (hoistRec(logger,b,ancestors,childHoist,childLoopHoist,childWriteMap)) {
        changed=true;
      }
    }
  }
  ancestors.remove(ancestors.size() - 1);
  return changed;
}","/** 
 * @param logger
 * @param curr current block
 * @param ancestors ancestors of current block
 * @param maxHoist maximum number of blocks can lift out
 * @param maxLoopHoist max number of block can lift out withoutgoing through loop
 * @param writeMap map for current block filled in with anything defined by construct or outer blocks
 * @return true if change made
 */
private static boolean hoistRec(Logger logger,Block curr,List<Block> ancestors,int maxHoist,int maxLoopHoist,HierarchicalMap<String,Block> writeMap){
  boolean changed=false;
  updateMapWithWrites(curr,writeMap);
  if (maxHoist > 0) {
    changed=tryHoist(logger,curr,ancestors,maxHoist,maxLoopHoist,writeMap);
  }
  ancestors.add(curr);
  for (  Continuation c : curr.getContinuations()) {
    int childHoist=canHoistThrough(c) ? maxHoist + 1 : 0;
    int childLoopHoist=c.isLoop() ? 0 : maxLoopHoist + 1;
    for (    Block b : c.getBlocks()) {
      HierarchicalMap<String,Block> childWriteMap=writeMap.makeChildMap();
      for (      Var v : c.constructDefinedVars()) {
        if (trackWrites(v)) {
          childWriteMap.put(v.name(),b);
        }
      }
      if (c.getType() == ContinuationType.WAIT_STATEMENT) {
        for (        Var waitVar : ((WaitStatement)c).getWaitVars()) {
          if (trackWrites(waitVar)) {
            childWriteMap.put(waitVar.name(),b);
          }
        }
      }
      if (hoistRec(logger,b,ancestors,childHoist,childLoopHoist,childWriteMap)) {
        changed=true;
      }
    }
  }
  ancestors.remove(ancestors.size() - 1);
  return changed;
}",0.9468807906114886
133081,"private void checkCleanups(Function fn,Block block){
  Set<String> blockVarNames=Var.nameSet(block.getVariables());
  if (block.getType() == BlockType.MAIN_BLOCK) {
    blockVarNames.addAll(Var.nameList(fn.getInputList()));
    blockVarNames.addAll(Var.nameList(fn.getOutputList()));
  }
 else {
    List<Var> constructVars=block.getParentCont().constructDefinedVars();
    if (constructVars != null) {
      blockVarNames.addAll(Var.nameList(constructVars));
    }
  }
  for (  CleanupAction ca : block.getCleanups()) {
    if (!blockVarNames.contains(ca.var().name())) {
      if (ca.action().op != Opcode.DECR_WRITERS) {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + ca.var() + ""String_Node_Str""+ fn.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ blockVarNames);
      }
    }
  }
}","private void checkCleanups(Function fn,Block block){
  Set<String> blockVarNames=Var.nameSet(block.getVariables());
  if (block.getType() == BlockType.MAIN_BLOCK) {
    blockVarNames.addAll(Var.nameList(fn.getInputList()));
    blockVarNames.addAll(Var.nameList(fn.getOutputList()));
  }
 else {
    List<Var> constructVars=block.getParentCont().constructDefinedVars();
    blockVarNames.addAll(Var.nameList(constructVars));
  }
  for (  CleanupAction ca : block.getCleanups()) {
    if (!blockVarNames.contains(ca.var().name())) {
      if (ca.action().op != Opcode.DECR_WRITERS) {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + ca.var() + ""String_Node_Str""+ fn.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ blockVarNames);
      }
    }
  }
}",0.974197608558842
133082,"private void checkUniqueVarNames(Logger logger,Program program,Function fn,Block block,Set<String> usedNames){
  for (  Var v : block.getVariables()) {
    checkVarUnique(logger,program,fn,usedNames,v);
  }
  if (checkCleanups)   checkCleanups(fn,block);
  for (  Continuation c : block.getContinuations()) {
    List<Var> constructDefined=c.constructDefinedVars();
    if (constructDefined != null) {
      for (      Var v : constructDefined) {
        checkVarUnique(logger,program,fn,usedNames,v);
      }
    }
    for (    Block inner : c.getBlocks()) {
      checkUniqueVarNames(logger,program,fn,inner,usedNames);
    }
  }
}","private void checkUniqueVarNames(Logger logger,Program program,Function fn,Block block,Set<String> usedNames){
  for (  Var v : block.getVariables()) {
    checkVarUnique(logger,program,fn,usedNames,v);
  }
  if (checkCleanups)   checkCleanups(fn,block);
  for (  Continuation c : block.getContinuations()) {
    for (    Var v : c.constructDefinedVars()) {
      checkVarUnique(logger,program,fn,usedNames,v);
    }
    for (    Block inner : c.getBlocks()) {
      checkUniqueVarNames(logger,program,fn,inner,usedNames);
    }
  }
}",0.8723221936589546
133083,"@Override public List<Var> constructDefinedVars(){
  return null;
}","@Override public List<Var> constructDefinedVars(){
  return Collections.emptyList();
}",0.8496732026143791
133084,"public boolean varNameUsed(String name){
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(this.mainBlock);
  while (!blocks.isEmpty()) {
    Block curr=blocks.pop();
    for (    Var v : curr.variables) {
      if (v.name().equals(name))       return true;
    }
    for (    Continuation c : curr.getContinuations()) {
      List<Var> constructVars=c.constructDefinedVars();
      if (constructVars != null)       for (      Var cv : constructVars)       if (cv.name().equals(name))       return true;
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
  return false;
}","public boolean varNameUsed(String name){
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(this.mainBlock);
  while (!blocks.isEmpty()) {
    Block curr=blocks.pop();
    for (    Var v : curr.variables) {
      if (v.name().equals(name))       return true;
    }
    for (    Continuation c : curr.getContinuations()) {
      for (      Var cv : c.constructDefinedVars())       if (cv.name().equals(name))       return true;
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
  return false;
}",0.7593856655290102
133085,"private void elimRefCountsCont(Logger logger,Function f,Continuation cont){
  Counters<Var> readIncrements=new Counters<Var>();
  Counters<Var> writeIncrements=new Counters<Var>();
  if (cont.isAsync() && cont.getType() == ContinuationType.WAIT_STATEMENT) {
    for (    Var keepOpen : cont.getKeepOpenVars()) {
      if (RefCounting.hasWriteRefCount(keepOpen)) {
        writeIncrements.decrement(keepOpen);
      }
    }
    for (    Var passedIn : cont.getPassedInVars()) {
      if (RefCounting.hasReadRefCount(passedIn)) {
        readIncrements.decrement(passedIn);
      }
    }
  }
  for (  Block block : cont.getBlocks()) {
    elimRefCountsRec(logger,f,block,readIncrements,writeIncrements);
  }
}","private void elimRefCountsCont(Logger logger,Function f,Continuation cont){
  for (  Block block : cont.getBlocks()) {
    Counters<Var> readIncrements=new Counters<Var>();
    Counters<Var> writeIncrements=new Counters<Var>();
    if (cont.isAsync() && cont.getType() == ContinuationType.WAIT_STATEMENT) {
      for (      Var keepOpen : cont.getKeepOpenVars()) {
        if (RefCounting.hasWriteRefCount(keepOpen)) {
          writeIncrements.decrement(keepOpen);
        }
      }
      for (      Var passedIn : cont.getPassedInVars()) {
        if (RefCounting.hasReadRefCount(passedIn)) {
          readIncrements.decrement(passedIn);
        }
      }
    }
    elimRefCountsRec(logger,f,block,readIncrements,writeIncrements);
  }
}",0.9045643153526972
133086,"private void checkVarReference(Map<String,Var> declared,Var referencedVar){
  assert(declared.containsKey(referencedVar.name()));
  assert(referencedVar.identical(declared.get(referencedVar.name())));
}","private void checkVarReference(Map<String,Var> declared,Var referencedVar){
}",0.5519713261648745
133087,"/** 
 * Rename variables in block (and nested blocks) according to map. If the map doesn't have an entry, we don't rename anything
 * @param inputsOnly  if true, only change references which are readingthe var.  if false, completely remove the old variable and replace  with new
 * @param renames OldName -> NewName
 */
public void renameVars(Map<Var,Arg> renames,boolean inputsOnly){
  if (!inputsOnly) {
    renameVarsInBlockVarsList(renames);
  }
  for (  Instruction i : instructions) {
    if (inputsOnly) {
      i.renameInputs(renames);
    }
 else {
      i.renameVars(renames);
    }
  }
  for (  Continuation c : continuations) {
    c.replaceVars(renames,inputsOnly,true);
  }
  renameCleanupActions(renames,inputsOnly);
}","/** 
 * Rename variables in block (and nested blocks) according to map. If the map doesn't have an entry, we don't rename anything
 * @param inputsOnly  if true, only change references which are readingthe var.  if false, completely remove the old variable and replace  with new
 * @param renames OldName -> NewName
 */
public void renameVars(Map<Var,Arg> renames,boolean inputsOnly){
  renameInDefs(renames,inputsOnly);
  renameInCode(renames,inputsOnly);
}",0.7019311502938707
133088,"public static Var declareLocalOutputVar(Block block,Var var,String valName){
  Var valOut=block.declareVariable(Types.derefResultType(var.type()),valName,VarStorage.LOCAL,DefType.LOCAL_COMPILER,null);
  if (valOut.type().equals(Types.V_BLOB)) {
    block.addCleanup(valOut,TurbineOp.freeBlob(valOut));
  }
  return valOut;
}","public static Var declareLocalOutputVar(Block block,Var var,String valName){
  Var valOut=block.declareVariable(Types.derefResultType(var.type()),valName,VarStorage.LOCAL,DefType.LOCAL_COMPILER,null);
  if (valOut.type().equals(Types.V_BLOB)) {
    block.addCleanup(valOut,TurbineOp.freeBlob(valOut));
  }
 else   if (valOut.type().equals(Types.V_FILE)) {
    block.addCleanup(valOut,TurbineOp.decrLocalFileRef(valOut));
  }
  return valOut;
}",0.8083441981747066
133089,"/** 
 * @param logger
 * @param fn
 * @param block
 * @param cv
 * @param inst
 * @param insts if instructions inserted, leaves iterator pointing at previous instruction
 * @return
 */
private static boolean switchToImmediate(Logger logger,Function fn,ExecContext execCx,Block block,State cv,Instruction inst,ListIterator<Instruction> insts){
  MakeImmRequest req=inst.canMakeImmediate(cv.getClosed(),cv.getUnmapped(),false);
  if (req == null) {
    return false;
  }
  Block insertContext;
  ListIterator<Instruction> insertPoint;
  if (req.mode == TaskMode.LOCAL || req.mode == TaskMode.SYNC || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
    insertContext=block;
    insertPoint=insts;
  }
 else {
    List<Var> used=Var.varListUnion(req.in,req.out);
    WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + inst.shortOpName(),Collections.<Var>emptyList(),used,Collections.<Var>emptyList(),inst.getPriority(),WaitMode.TASK_DISPATCH,false,req.mode);
    insertContext=wait.getBlock();
    block.addContinuation(wait);
    insertPoint=insertContext.instructionIterator();
  }
  List<Instruction> alt=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>(req.in.size());
  HashMap<String,Arg> alreadyFetched=new HashMap<String,Arg>();
  for (  Var v : req.in) {
    Arg maybeVal;
    if (alreadyFetched.containsKey(v.name())) {
      maybeVal=alreadyFetched.get(v.name());
    }
 else {
      maybeVal=cv.findRetrieveResult(v);
    }
    if (maybeVal != null) {
      inVals.add(maybeVal);
      alreadyFetched.put(v.name(),maybeVal);
    }
 else {
      Var fetchedV=OptUtil.fetchValueOf(insertContext,alt,v);
      Arg fetched=Arg.createVar(fetchedV);
      inVals.add(fetched);
      alreadyFetched.put(v.name(),fetched);
    }
  }
  List<Var> outValVars=OptUtil.declareLocalOpOutputVars(insertContext,req.out);
  MakeImmChange change=inst.makeImmediate(outValVars,inVals);
  OptUtil.fixupImmChange(block,insertContext,change,alt,outValVars,req.out);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
  }
  insts.remove();
  for (  Instruction newInst : alt) {
    insertPoint.add(newInst);
  }
  if (inst == insertPoint) {
    ICUtil.rewindIterator(insts,alt.size());
  }
 else {
    insts.previous();
  }
  return true;
}","/** 
 * @param logger
 * @param fn
 * @param block
 * @param cv
 * @param inst
 * @param insts if instructions inserted, leaves iterator pointing at previous instruction
 * @return
 */
private static boolean switchToImmediate(Logger logger,Function fn,ExecContext execCx,Block block,State cv,Instruction inst,ListIterator<Instruction> insts){
  MakeImmRequest req=inst.canMakeImmediate(cv.getClosed(),cv.getUnmapped(),false);
  if (req == null) {
    return false;
  }
  Block insertContext;
  ListIterator<Instruction> insertPoint;
  boolean noWaitRequired=req.mode == TaskMode.LOCAL || req.mode == TaskMode.SYNC || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL);
  if (noWaitRequired) {
    insertContext=block;
    insertPoint=insts;
  }
 else {
    List<Var> used=Var.varListUnion(req.in,req.out);
    WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + inst.shortOpName(),Collections.<Var>emptyList(),used,Collections.<Var>emptyList(),inst.getPriority(),WaitMode.TASK_DISPATCH,false,req.mode);
    insertContext=wait.getBlock();
    block.addContinuation(wait);
    insertPoint=insertContext.instructionIterator();
  }
  List<Instruction> alt=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>(req.in.size());
  HashMap<String,Arg> alreadyFetched=new HashMap<String,Arg>();
  for (  Var v : req.in) {
    Arg maybeVal;
    if (alreadyFetched.containsKey(v.name())) {
      maybeVal=alreadyFetched.get(v.name());
    }
 else {
      maybeVal=cv.findRetrieveResult(v);
    }
    if (maybeVal != null && (noWaitRequired || !cantPass(maybeVal.getType()))) {
      inVals.add(maybeVal);
      alreadyFetched.put(v.name(),maybeVal);
    }
 else {
      Var fetchedV=OptUtil.fetchValueOf(insertContext,alt,v);
      Arg fetched=Arg.createVar(fetchedV);
      inVals.add(fetched);
      alreadyFetched.put(v.name(),fetched);
    }
  }
  List<Var> outValVars=OptUtil.declareLocalOpOutputVars(insertContext,req.out);
  MakeImmChange change=inst.makeImmediate(outValVars,inVals);
  OptUtil.fixupImmChange(block,insertContext,change,alt,outValVars,req.out);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
  }
  insts.remove();
  for (  Instruction newInst : alt) {
    insertPoint.add(newInst);
  }
  if (inst == insertPoint) {
    ICUtil.rewindIterator(insts,alt.size());
  }
 else {
    insts.previous();
  }
  return true;
}",0.9787411421425594
133090,"public static Instruction futureSet(Var dst,Arg src){
  assert(Types.isScalarFuture(dst.type()));
switch (dst.type().primType()) {
case BOOL:
    assert(src.isImmediateBool());
  return TurbineOp.assignBool(dst,src);
case INT:
assert(src.isImmediateInt());
return TurbineOp.assignInt(dst,src);
case FLOAT:
assert(src.isImmediateFloat());
return TurbineOp.assignFloat(dst,src);
case STRING:
assert(src.isImmediateString());
return TurbineOp.assignString(dst,src);
case BLOB:
assert(src.isImmediateBlob());
return TurbineOp.assignBlob(dst,src);
case VOID:
assert(src.isVar() && src.getVar().type().equals(Types.V_VOID));
return TurbineOp.assignVoid(dst,src);
default :
throw new STCRuntimeError(""String_Node_Str"" + dst.type().typeName() + ""String_Node_Str"");
}
}","public static Instruction futureSet(Var dst,Arg src){
  assert(Types.isScalarFuture(dst.type()));
switch (dst.type().primType()) {
case BOOL:
    assert(src.isImmediateBool());
  return TurbineOp.assignBool(dst,src);
case INT:
assert(src.isImmediateInt());
return TurbineOp.assignInt(dst,src);
case FLOAT:
assert(src.isImmediateFloat());
return TurbineOp.assignFloat(dst,src);
case STRING:
assert(src.isImmediateString());
return TurbineOp.assignString(dst,src);
case BLOB:
assert(src.isImmediateBlob());
return TurbineOp.assignBlob(dst,src);
case VOID:
assert(src.isVar() && src.getVar().type().equals(Types.V_VOID));
return TurbineOp.assignVoid(dst,src);
case FILE:
assert(src.isVar() && src.getVar().type().equals(Types.V_FILE));
return TurbineOp.assignFile(dst,src);
default :
throw new STCRuntimeError(""String_Node_Str"" + dst.type().typeName() + ""String_Node_Str"");
}
}",0.9302325581395348
133091,"public static Instruction arrayCreateNestedImm(Var arrayResult,Var arrayVar,Arg arrIx){
  return new TurbineOp(Opcode.ARRAY_CREATE_NESTED_IMM,Arg.createVar(arrayResult),Arg.createVar(arrayVar),arrIx);
}","public static Instruction arrayCreateNestedImm(Var arrayResult,Var arrayVar,Arg arrIx){
  assert(arrIx.isImmediateInt());
  return new TurbineOp(Opcode.ARRAY_CREATE_NESTED_IMM,Arg.createVar(arrayResult),Arg.createVar(arrayVar),arrIx);
}",0.9223744292237442
133092,"public static Instruction arrayRefCreateNestedImmIx(Var arrayResult,Var arrayVar,Arg arrIx){
  return new TurbineOp(Opcode.ARRAY_REF_CREATE_NESTED_IMM,Arg.createVar(arrayResult),Arg.createVar(arrayVar),arrIx);
}","public static Instruction arrayRefCreateNestedImmIx(Var arrayResult,Var arrayVar,Arg arrIx){
  assert(arrIx.isImmediateInt());
  return new TurbineOp(Opcode.ARRAY_REF_CREATE_NESTED_IMM,Arg.createVar(arrayResult),Arg.createVar(arrayVar),arrIx);
}",0.925438596491228
133093,"/** 
 * Try and merge if1 into one of statements in mergeCands If successful, call it.remove()
 * @param it
 * @param mergeCands
 * @param loop1
 */
private static void fuseForeachLoop(ListIterator<Continuation> it,LinkedList<Continuation> mergeCands,ForeachLoop loop1){
  for (  Continuation c2 : mergeCands) {
    if (c2.getType() == ContinuationType.FOREACH_LOOP) {
      ForeachLoop loop2=(ForeachLoop)c2;
      if (loop2.fuseable(loop1)) {
        loop2.fuseInto(loop1,true);
        it.remove();
      }
    }
  }
}","/** 
 * Try and merge if1 into one of statements in mergeCands If successful, call it.remove()
 * @param it
 * @param mergeCands
 * @param loop1
 */
private static void fuseForeachLoop(ListIterator<Continuation> it,LinkedList<Continuation> mergeCands,ForeachLoop loop1){
  for (  Continuation c2 : mergeCands) {
    if (c2.getType() == ContinuationType.FOREACH_LOOP) {
      ForeachLoop loop2=(ForeachLoop)c2;
      if (loop2.fuseable(loop1)) {
        loop2.fuseInto(loop1,true);
        it.remove();
        return;
      }
    }
  }
}",0.9848771266540642
133094,"/** 
 * Try and merge if1 into one of statements in mergeCands If successful, call it.remove()
 * @param it
 * @param mergeCands
 * @param loop1
 */
private static void fuseRangeLoop(ListIterator<Continuation> it,LinkedList<Continuation> mergeCands,RangeLoop loop1){
  for (  Continuation c2 : mergeCands) {
    if (c2.getType() == ContinuationType.RANGE_LOOP) {
      RangeLoop loop2=(RangeLoop)c2;
      if (loop2.fuseable(loop1)) {
        loop2.fuseInto(loop1,true);
        it.remove();
      }
    }
  }
}","/** 
 * Try and merge if1 into one of statements in mergeCands If successful, call it.remove()
 * @param it
 * @param mergeCands
 * @param loop1
 */
private static void fuseRangeLoop(ListIterator<Continuation> it,LinkedList<Continuation> mergeCands,RangeLoop loop1){
  for (  Continuation c2 : mergeCands) {
    if (c2.getType() == ContinuationType.RANGE_LOOP) {
      RangeLoop loop2=(RangeLoop)c2;
      if (loop2.fuseable(loop1)) {
        assert(loop2 != loop1);
        loop2.fuseInto(loop1,true);
        it.remove();
        return;
      }
    }
  }
}",0.955140186915888
133095,"/** 
 * Try and merge if1 into one of statements in mergeCands If successful, call it.remove()
 * @param it
 * @param mergeCands
 * @param if1
 */
private static void fuseIfStatement(ListIterator<Continuation> it,LinkedList<Continuation> mergeCands,IfStatement if1){
  for (  Continuation c2 : mergeCands) {
    if (c2.getType() == ContinuationType.IF_STATEMENT) {
      IfStatement if2=(IfStatement)c2;
      if (if1.fuseable(if2)) {
        if2.fuse(if1,true);
        it.remove();
      }
    }
  }
}","/** 
 * Try and merge if1 into one of statements in mergeCands If successful, call it.remove()
 * @param it
 * @param mergeCands
 * @param if1
 */
private static void fuseIfStatement(ListIterator<Continuation> it,LinkedList<Continuation> mergeCands,IfStatement if1){
  for (  Continuation c2 : mergeCands) {
    if (c2.getType() == ContinuationType.IF_STATEMENT) {
      IfStatement if2=(IfStatement)c2;
      if (if1.fuseable(if2)) {
        if2.fuse(if1,true);
        it.remove();
        return;
      }
    }
  }
}",0.9843444227005872
133096,"private static void pushdownDeclarations(Block block,Map<String,Pair<Continuation,Block>> candidates){
  if (candidates.size() > 0) {
    ListIterator<Var> varIt=block.variableIterator();
    while (varIt.hasNext()) {
      Var var=varIt.next();
      Pair<Continuation,Block> newHome=candidates.get(var.name());
      if (newHome != null) {
        varIt.remove();
        newHome.val1.removePassedInVar(var);
        newHome.val2.addVariable(var);
        block.moveCleanups(var,newHome.val2);
      }
    }
  }
}","private static void pushdownDeclarations(Block block,Map<String,Pair<Continuation,Block>> candidates){
  if (candidates.size() > 0) {
    ListIterator<Var> varIt=block.variableIterator();
    while (varIt.hasNext()) {
      Var var=varIt.next();
      Pair<Continuation,Block> newHome=candidates.get(var.name());
      if (newHome != null) {
        varIt.remove();
        Continuation cont=newHome.val1;
        if (cont.isAsync()) {
          cont.removePassedInVar(var);
        }
        newHome.val2.addVariable(var);
        block.moveCleanups(var,newHome.val2);
      }
    }
  }
}",0.9329710144927535
133097,"/** 
 * @param newCV
 * @param replace for debugging purposes, set to true if we intend to replace
 */
public void addComputedValue(ComputedValue newCV,boolean replace){
  boolean outClosed=newCV.isOutClosed();
  if (isAvailable(newCV)) {
    if (!replace) {
      throw new STCRuntimeError(""String_Node_Str"" + getLocation(newCV) + ""String_Node_Str""+ newCV);
    }
  }
 else   if (replace) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + newCV + ""String_Node_Str"");
  }
  Arg valLoc=newCV.getValLocation();
  Opcode op=newCV.getOp();
  availableVals.put(newCV,valLoc);
  if (valLoc.isVar() && outClosed) {
    System.err.println(valLoc + ""String_Node_Str"");
    this.closed.add(valLoc.getVar().name());
  }
  if (op == Opcode.LOAD_BOOL || op == Opcode.LOAD_FLOAT || op == Opcode.LOAD_INT || op == Opcode.LOAD_STRING || op == Opcode.LOAD_VOID || op == Opcode.LOAD_FILE) {
    System.err.println(valLoc + ""String_Node_Str"");
    this.closed.add(newCV.getInput(0).getVar().name());
  }
}","/** 
 * @param newCV
 * @param replace for debugging purposes, set to true if we intend to replace
 */
public void addComputedValue(ComputedValue newCV,boolean replace){
  boolean outClosed=newCV.isOutClosed();
  if (isAvailable(newCV)) {
    if (!replace) {
      throw new STCRuntimeError(""String_Node_Str"" + getLocation(newCV) + ""String_Node_Str""+ newCV);
    }
  }
 else   if (replace) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + newCV + ""String_Node_Str"");
  }
  Arg valLoc=newCV.getValLocation();
  Opcode op=newCV.getOp();
  availableVals.put(newCV,valLoc);
  if (valLoc.isVar() && outClosed) {
    this.closed.add(valLoc.getVar().name());
  }
  if (op == Opcode.LOAD_BOOL || op == Opcode.LOAD_FLOAT || op == Opcode.LOAD_INT || op == Opcode.LOAD_STRING || op == Opcode.LOAD_VOID || op == Opcode.LOAD_FILE) {
    this.closed.add(newCV.getInput(0).getVar().name());
  }
}",0.895397489539749
133098,"/** 
 * @param context local context for app function
 * @param cmd AST for app function command
 * @param outArgs output arguments for app
 * @param hasSideEffects
 * @param deterministic
 * @throws UserException
 */
private void genAppFunctionBody(Context context,SwiftAST appBody,List<Var> inArgs,List<Var> outArgs,boolean hasSideEffects,boolean deterministic) throws UserException {
  assert(appBody.getType() == ExMParser.APP_BODY);
  assert(appBody.getChildCount() >= 1);
  SwiftAST cmd=appBody.child(0);
  assert(cmd.getType() == ExMParser.COMMAND);
  assert(cmd.getChildCount() >= 1);
  SwiftAST appNameT=cmd.child(0);
  assert(appNameT.getType() == ExMParser.STRING);
  String appName=Literals.extractLiteralString(context,appNameT);
  List<Var> args=evalAppCmdArgs(context,cmd);
  Redirects<Var> redirFutures=processAppRedirects(context,appBody.children(1));
  checkAppOutputs(context,appName,outArgs,args,redirFutures);
  Pair<Map<String,Var>,List<Var>> wait=selectAppWaitVars(context,args,redirFutures);
  Map<String,Var> fileNames=wait.val1;
  List<Var> waitVars=wait.val2;
  List<Var> passIn=new ArrayList<Var>();
  passIn.addAll(fileNames.values());
  passIn.addAll(args);
  String waitName=context.getFunctionContext().constructName(""String_Node_Str"");
  backend.startWaitStatement(waitName,waitVars,passIn,Collections.<Var>emptyList(),null,WaitMode.TASK_DISPATCH,true,TaskMode.LEAF);
  Pair<List<Arg>,Redirects<Arg>> retrieved=retrieveAppArgs(context,args,redirFutures,fileNames);
  List<Arg> localArgs=retrieved.val1;
  Redirects<Arg> localRedirects=retrieved.val2;
  List<Arg> localInFiles=new ArrayList<Arg>();
  for (  Var inArg : inArgs) {
    if (Types.isFile(inArg.type())) {
      Var localInputFile=varCreator.fetchValueOf(context,inArg);
      localInFiles.add(Arg.createVar(localInputFile));
    }
  }
  List<Var> localOutputs=new ArrayList<Var>(outArgs.size());
  List<Arg> localOutputFileNames=new ArrayList<Arg>(outArgs.size());
  for (  Var output : outArgs) {
    Var localOutput=varCreator.createValueOfVar(context,output);
    localOutputs.add(localOutput);
    Arg localOutputFileName=null;
    if (Types.isFile(output.type())) {
      localOutputFileName=Arg.createVar(varCreator.fetchValueOf(context,fileNames.get(output.name())));
    }
    localOutputFileNames.add(localOutputFileName);
  }
  backend.runExternal(appName,localArgs,localInFiles,localOutputs,localOutputFileNames,localRedirects,hasSideEffects,deterministic);
  for (int i=0; i < outArgs.size(); i++) {
    Var output=outArgs.get(i);
    Var localOutput=localOutputs.get(i);
    if (Types.isFile(output.type())) {
      backend.assignFile(output,Arg.createVar(localOutput));
      backend.decrLocalFileRef(localOutput);
    }
 else {
      assert(Types.isVoid(output.type()));
      backend.assignVoid(output,Arg.createVar(localOutput));
    }
  }
  backend.endWaitStatement(waitVars,passIn,Arrays.<Var>asList());
}","/** 
 * @param context local context for app function
 * @param cmd AST for app function command
 * @param outArgs output arguments for app
 * @param hasSideEffects
 * @param deterministic
 * @throws UserException
 */
private void genAppFunctionBody(Context context,SwiftAST appBody,List<Var> inArgs,List<Var> outArgs,boolean hasSideEffects,boolean deterministic) throws UserException {
  assert(appBody.getType() == ExMParser.APP_BODY);
  assert(appBody.getChildCount() >= 1);
  SwiftAST cmd=appBody.child(0);
  assert(cmd.getType() == ExMParser.COMMAND);
  assert(cmd.getChildCount() >= 1);
  SwiftAST appNameT=cmd.child(0);
  assert(appNameT.getType() == ExMParser.STRING);
  String appName=Literals.extractLiteralString(context,appNameT);
  List<Var> args=evalAppCmdArgs(context,cmd);
  Redirects<Var> redirFutures=processAppRedirects(context,appBody.children(1));
  checkAppOutputs(context,appName,outArgs,args,redirFutures);
  Pair<Map<String,Var>,List<Var>> wait=selectAppWaitVars(context,args,outArgs,redirFutures);
  Map<String,Var> fileNames=wait.val1;
  List<Var> waitVars=wait.val2;
  List<Var> passIn=new ArrayList<Var>();
  passIn.addAll(fileNames.values());
  passIn.addAll(args);
  String waitName=context.getFunctionContext().constructName(""String_Node_Str"");
  backend.startWaitStatement(waitName,waitVars,passIn,Collections.<Var>emptyList(),null,WaitMode.TASK_DISPATCH,true,TaskMode.LEAF);
  Pair<List<Arg>,Redirects<Arg>> retrieved=retrieveAppArgs(context,args,redirFutures,fileNames);
  List<Arg> localArgs=retrieved.val1;
  Redirects<Arg> localRedirects=retrieved.val2;
  List<Arg> localInFiles=new ArrayList<Arg>();
  for (  Var inArg : inArgs) {
    if (Types.isFile(inArg.type())) {
      Var localInputFile=varCreator.fetchValueOf(context,inArg);
      localInFiles.add(Arg.createVar(localInputFile));
    }
  }
  List<Var> localOutputs=new ArrayList<Var>(outArgs.size());
  List<Arg> localOutputFileNames=new ArrayList<Arg>(outArgs.size());
  for (  Var output : outArgs) {
    Var localOutput=varCreator.createValueOfVar(context,output);
    localOutputs.add(localOutput);
    Arg localOutputFileName=null;
    if (Types.isFile(output.type())) {
      localOutputFileName=Arg.createVar(varCreator.fetchValueOf(context,fileNames.get(output.name())));
    }
    localOutputFileNames.add(localOutputFileName);
  }
  backend.runExternal(appName,localArgs,localInFiles,localOutputs,localOutputFileNames,localRedirects,hasSideEffects,deterministic);
  for (int i=0; i < outArgs.size(); i++) {
    Var output=outArgs.get(i);
    Var localOutput=localOutputs.get(i);
    if (Types.isFile(output.type())) {
      backend.assignFile(output,Arg.createVar(localOutput));
      backend.decrLocalFileRef(localOutput);
    }
 else {
      assert(Types.isVoid(output.type()));
      backend.assignVoid(output,Arg.createVar(localOutput));
    }
  }
  backend.endWaitStatement(waitVars,passIn,Arrays.<Var>asList());
}",0.9986315429353404
133099,"/** 
 * Choose which inputs/outputs to an app invocation should be blocked upon.  This is somewhat complex since we sometimes need to block on filenames/file statuses/etc  
 * @param context
 * @param redirFutures 
 * @param inputs
 * @param outputs
 * @return
 * @throws UserException
 * @throws UndefinedTypeException
 */
private Pair<Map<String,Var>,List<Var>> selectAppWaitVars(Context context,List<Var> args,Redirects<Var> redirFutures) throws UserException, UndefinedTypeException {
  List<Var> allArgs=new ArrayList<Var>();
  allArgs.addAll(args);
  allArgs.addAll(redirFutures.redirections(true,true));
  Map<String,Var> fileNames=new HashMap<String,Var>();
  List<Var> waitVars=new ArrayList<Var>();
  for (  Var arg : allArgs) {
    if (Types.isFile(arg.type())) {
      if (fileNames.containsKey(arg.name())) {
        continue;
      }
      Var filenameFuture=varCreator.createFilenameAlias(context,arg);
      if (arg.defType() == DefType.OUTARG) {
        backend.getFileName(filenameFuture,arg,true);
      }
 else {
        backend.getFileName(filenameFuture,arg,false);
      }
      waitVars.add(filenameFuture);
      fileNames.put(arg.name(),filenameFuture);
      if (arg.defType() != DefType.OUTARG) {
        waitVars.add(arg);
      }
    }
 else {
      waitVars.add(arg);
    }
  }
  return Pair.create(fileNames,waitVars);
}","/** 
 * Choose which inputs/outputs to an app invocation should be blocked upon.  This is somewhat complex since we sometimes need to block on filenames/file statuses/etc  
 * @param context
 * @param redirFutures 
 * @param inputs
 * @param outputs
 * @return
 * @throws UserException
 * @throws UndefinedTypeException
 */
private Pair<Map<String,Var>,List<Var>> selectAppWaitVars(Context context,List<Var> args,List<Var> outArgs,Redirects<Var> redirFutures) throws UserException, UndefinedTypeException {
  List<Var> allArgs=new ArrayList<Var>();
  allArgs.addAll(args);
  allArgs.addAll(redirFutures.redirections(true,true));
  Map<String,Var> fileNames=new HashMap<String,Var>();
  List<Var> waitVars=new ArrayList<Var>();
  for (  Var arg : allArgs) {
    if (Types.isFile(arg.type())) {
      if (fileNames.containsKey(arg.name())) {
        continue;
      }
      loadAppFilename(context,fileNames,waitVars,arg);
    }
 else {
      waitVars.add(arg);
    }
  }
  for (  Var outArg : outArgs) {
    if (Types.isFile(outArg.type()) && !fileNames.containsKey(outArg.name())) {
      loadAppFilename(context,fileNames,waitVars,outArg);
    }
  }
  return Pair.create(fileNames,waitVars);
}",0.7227022780832679
133100,"/** 
 * @param newCV
 * @param replace for debugging purposes, set to true if we intend to replace
 */
public void addComputedValue(ComputedValue newCV,boolean replace){
  boolean outClosed=newCV.isOutClosed();
  if (isAvailable(newCV)) {
    if (!replace) {
      throw new STCRuntimeError(""String_Node_Str"" + getLocation(newCV) + ""String_Node_Str""+ newCV);
    }
  }
 else   if (replace) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + newCV + ""String_Node_Str"");
  }
  Arg valLoc=newCV.getValLocation();
  Opcode op=newCV.getOp();
  availableVals.put(newCV,valLoc);
  if (valLoc.isVar() && outClosed) {
    this.closed.add(valLoc.getVar().name());
  }
  if (op == Opcode.LOAD_BOOL || op == Opcode.LOAD_FLOAT || op == Opcode.LOAD_INT || op == Opcode.LOAD_REF || op == Opcode.LOAD_STRING || op == Opcode.LOAD_VOID || op == Opcode.LOAD_FILE) {
    this.closed.add(newCV.getInput(0).getVar().name());
  }
}","/** 
 * @param newCV
 * @param replace for debugging purposes, set to true if we intend to replace
 */
public void addComputedValue(ComputedValue newCV,boolean replace){
  boolean outClosed=newCV.isOutClosed();
  if (isAvailable(newCV)) {
    if (!replace) {
      throw new STCRuntimeError(""String_Node_Str"" + getLocation(newCV) + ""String_Node_Str""+ newCV);
    }
  }
 else   if (replace) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + newCV + ""String_Node_Str"");
  }
  Arg valLoc=newCV.getValLocation();
  Opcode op=newCV.getOp();
  availableVals.put(newCV,valLoc);
  if (valLoc.isVar() && outClosed) {
    System.err.println(valLoc + ""String_Node_Str"");
    this.closed.add(valLoc.getVar().name());
  }
  if (op == Opcode.LOAD_BOOL || op == Opcode.LOAD_FLOAT || op == Opcode.LOAD_INT || op == Opcode.LOAD_STRING || op == Opcode.LOAD_VOID || op == Opcode.LOAD_FILE) {
    System.err.println(valLoc + ""String_Node_Str"");
    this.closed.add(newCV.getInput(0).getVar().name());
  }
}",0.9334021683014972
133101,"private static void updateMapWithWrites(Block curr,HierarchicalMap<String,Block> writeMap){
  for (  Instruction inst : curr.getInstructions()) {
    for (    Var out : inst.getOutputs()) {
      if (trackWrites(out)) {
        writeMap.put(out.name(),curr);
      }
    }
  }
  for (  Var declared : curr.getVariables()) {
    if (Types.isArray(declared.type())) {
      writeMap.put(declared.name(),curr);
    }
  }
}","private static void updateMapWithWrites(Block curr,HierarchicalMap<String,Block> writeMap){
  for (  Instruction inst : curr.getInstructions()) {
    for (    Var out : inst.getOutputs()) {
      if (trackWrites(out)) {
        Logging.getSTCLogger().trace(""String_Node_Str"" + inst + ""String_Node_Str""+ out);
        writeMap.put(out.name(),curr);
      }
 else {
        Logging.getSTCLogger().trace(""String_Node_Str"" + inst + ""String_Node_Str""+ out);
      }
    }
  }
  for (  Var declared : curr.getVariables()) {
    if (Types.isArray(declared.type()) && declared.storage() != VarStorage.ALIAS) {
      writeMap.put(declared.name(),curr);
    }
  }
}",0.7802607076350093
133102,"public static List<String> varNameList(List<Arg> inputs){
  ArrayList<String> result=new ArrayList<String>();
  collectVarNames(result,inputs);
  return result;
}","public static List<String> varNameList(List<Arg> inputs,boolean nullsOk){
  ArrayList<String> result=new ArrayList<String>();
  collectVarNames(result,inputs,false);
  return result;
}",0.9364161849710982
133103,"/** 
 * Put all variable names in a collection of opargs into addTo
 */
public static void collectVarNames(Collection<String> addTo,Collection<Arg> args){
  for (  Arg o : args) {
    if (o.kind == ArgKind.VAR) {
      addTo.add(o.getVar().name());
    }
  }
}","public static void collectVarNames(Collection<String> addTo,Collection<Arg> args){
  collectVarNames(addTo,args,false);
}",0.5406824146981627
133104,"/** 
 * print a comma separated list of var names to sb
 * @param sb
 * @param args
 */
public static void prettyPrintArgList(StringBuilder sb,Collection<Arg> args){
  boolean first=true;
  for (  Arg a : args) {
    if (first) {
      first=false;
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(a.toString());
  }
}","/** 
 * print a comma separated list of var names to sb
 * @param sb
 * @param args
 */
public static void prettyPrintArgList(StringBuilder sb,Collection<Arg> args){
  boolean first=true;
  for (  Arg a : args) {
    if (first) {
      first=false;
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(a);
  }
}",0.9835082458770614
133105,"public static void replaceOpargsInList(Map<String,Arg> renames,List<Arg> args){
  if (renames.isEmpty()) {
    return;
  }
  for (int i=0; i < args.size(); i++) {
    Arg oa=args.get(i);
    if (oa.isVar()) {
      String oldName=oa.getVar().name();
      Arg val=renames.get(oldName);
      if (val != null) {
        args.set(i,val);
      }
    }
  }
}","public static void replaceOpargsInList(Map<String,Arg> renames,List<Arg> args,boolean nullsOk){
  if (renames.isEmpty()) {
    return;
  }
  for (int i=0; i < args.size(); i++) {
    Arg oa=args.get(i);
    if (oa == null) {
      if (nullsOk) {
        continue;
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + args);
      }
    }
    if (oa.isVar()) {
      String oldName=oa.getVar().name();
      Arg val=renames.get(oldName);
      if (val != null) {
        args.set(i,val);
      }
    }
  }
}",0.8086560364464692
133106,"private static boolean eliminateIter(Logger logger,Block block){
  boolean converged=true;
  ListIterator<Continuation> it=block.continuationIterator();
  while (it.hasNext()) {
    Continuation c=it.next();
    if (c.isNoop()) {
      it.remove();
      converged=false;
    }
  }
  List<List<Var>> dependentSets=new ArrayList<List<Var>>();
  Set<String> thisBlockNeeded=new HashSet<String>();
  Set<String> thisBlockWritten=new HashSet<String>();
  block.findThisBlockNeededVars(thisBlockNeeded,thisBlockWritten,dependentSets);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + thisBlockNeeded + ""String_Node_Str""+ thisBlockWritten);
  }
  Map<String,Block> candidates=new HashMap<String,Block>();
  for (  Var v : block.getVariables()) {
    if (!thisBlockNeeded.contains(v.name()) && !thisBlockWritten.contains(v.name()))     candidates.put(v.name(),null);
  }
  List<Set<String>> subblockNeededVars=new ArrayList<Set<String>>();
  for (  Continuation cont : block.getContinuations()) {
    Set<String> contAllUsed=new HashSet<String>();
    for (    Block subBlock : cont.getBlocks()) {
      Set<String> subblockNeeded=new HashSet<String>();
      Set<String> subblockWritten=new HashSet<String>();
      subBlock.findNeededVars(subblockNeeded,subblockWritten,dependentSets);
      subblockNeededVars.add(subblockNeeded);
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + subBlock.getType() + ""String_Node_Str""+ subblockNeeded+ ""String_Node_Str""+ subblockWritten);
      }
      Set<String> subblockAll=new HashSet<String>();
      subblockAll.addAll(subblockNeeded);
      subblockAll.addAll(subblockWritten);
      for (      String var : subblockAll) {
        if (candidates.containsKey(var)) {
          if (candidates.get(var) == null) {
            candidates.put(var,subBlock);
          }
 else {
            candidates.remove(var);
          }
        }
      }
      contAllUsed.addAll(subblockAll);
    }
    cont.removeUnused(contAllUsed);
  }
  pushdownDeclarations(block,candidates);
  Set<String> allNeeded=new HashSet<String>();
  allNeeded.addAll(thisBlockNeeded);
  for (  Set<String> needed : subblockNeededVars) {
    allNeeded.addAll(needed);
  }
  Set<String> unneeded=unneededVars(block,allNeeded,dependentSets);
  for (  String v : unneeded) {
    logger.debug(""String_Node_Str"" + v + ""String_Node_Str"");
    converged=false;
  }
  block.removeVars(unneeded);
  return converged;
}","private static boolean eliminateIter(Logger logger,Block block){
  boolean converged=true;
  ListIterator<Continuation> it=block.continuationIterator();
  while (it.hasNext()) {
    Continuation c=it.next();
    if (c.isNoop()) {
      it.remove();
      converged=false;
    }
  }
  List<List<Var>> dependentSets=new ArrayList<List<Var>>();
  Set<String> thisBlockNeeded=new HashSet<String>();
  Set<String> thisBlockWritten=new HashSet<String>();
  block.findThisBlockNeededVars(thisBlockNeeded,thisBlockWritten,dependentSets);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + thisBlockNeeded + ""String_Node_Str""+ thisBlockWritten);
  }
  Map<String,Pair<Continuation,Block>> candidates=new HashMap<String,Pair<Continuation,Block>>();
  for (  Var v : block.getVariables()) {
    if (!thisBlockNeeded.contains(v.name()) && !thisBlockWritten.contains(v.name()))     candidates.put(v.name(),null);
  }
  List<Set<String>> subblockNeededVars=new ArrayList<Set<String>>();
  for (  Continuation cont : block.getContinuations()) {
    Set<String> contAllUsed=new HashSet<String>();
    for (    Block subBlock : cont.getBlocks()) {
      Set<String> subblockNeeded=new HashSet<String>();
      Set<String> subblockWritten=new HashSet<String>();
      subBlock.findNeededVars(subblockNeeded,subblockWritten,dependentSets);
      subblockNeededVars.add(subblockNeeded);
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + subBlock.getType() + ""String_Node_Str""+ subblockNeeded+ ""String_Node_Str""+ subblockWritten);
      }
      Set<String> subblockAll=new HashSet<String>();
      subblockAll.addAll(subblockNeeded);
      subblockAll.addAll(subblockWritten);
      for (      String var : subblockAll) {
        if (candidates.containsKey(var)) {
          if (candidates.get(var) == null) {
            candidates.put(var,Pair.create(cont,subBlock));
          }
 else {
            candidates.remove(var);
          }
        }
      }
      contAllUsed.addAll(subblockAll);
    }
    cont.removeUnused(contAllUsed);
  }
  pushdownDeclarations(block,candidates);
  Set<String> allNeeded=new HashSet<String>();
  allNeeded.addAll(thisBlockNeeded);
  for (  Set<String> needed : subblockNeededVars) {
    allNeeded.addAll(needed);
  }
  Set<String> unneeded=unneededVars(block,allNeeded,dependentSets);
  for (  String v : unneeded) {
    logger.debug(""String_Node_Str"" + v + ""String_Node_Str"");
    converged=false;
  }
  block.removeVars(unneeded);
  return converged;
}",0.9887459807073956
133107,"private static void pushdownDeclarations(Block block,Map<String,Block> candidates){
  if (candidates.size() > 0) {
    ListIterator<Var> varIt=block.variableIterator();
    while (varIt.hasNext()) {
      Var var=varIt.next();
      Block newHome=candidates.get(var.name());
      if (newHome != null) {
        varIt.remove();
        newHome.addVariable(var);
        block.moveCleanups(var,newHome);
      }
    }
  }
}","private static void pushdownDeclarations(Block block,Map<String,Pair<Continuation,Block>> candidates){
  if (candidates.size() > 0) {
    ListIterator<Var> varIt=block.variableIterator();
    while (varIt.hasNext()) {
      Var var=varIt.next();
      Pair<Continuation,Block> newHome=candidates.get(var.name());
      if (newHome != null) {
        varIt.remove();
        newHome.val1.removePassedInVar(var);
        newHome.val2.addVariable(var);
        block.moveCleanups(var,newHome.val2);
      }
    }
  }
}",0.9007470651013874
133108,"/** 
 * @param logger
 * @param fn
 * @param block
 * @param cv
 * @param inst
 * @param insts if instructions inserted, leaves iterator pointing at previous instruction
 * @return
 */
private static boolean switchToImmediate(Logger logger,Function fn,ExecContext execCx,Block block,State cv,Instruction inst,ListIterator<Instruction> insts){
  MakeImmRequest req=inst.canMakeImmediate(cv.getClosed(),cv.getUnmapped(),false);
  if (req == null) {
    return false;
  }
  Block insertContext;
  ListIterator<Instruction> insertPoint;
  if (req.mode == TaskMode.LOCAL || req.mode == TaskMode.SYNC || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
    insertContext=block;
    insertPoint=insts;
  }
 else {
    List<Var> used=Var.varListUnion(req.in,req.out);
    WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + inst.shortOpName(),Collections.<Var>emptyList(),used,Collections.<Var>emptyList(),inst.getPriority(),WaitMode.TASK_DISPATCH,false,req.mode);
    insertContext=wait.getBlock();
    block.addContinuation(wait);
    insertPoint=insertContext.instructionIterator();
  }
  List<Instruction> alt=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>(req.in.size());
  HashMap<String,Arg> alreadyFetched=new HashMap<String,Arg>();
  for (  Var v : req.in) {
    Arg maybeVal;
    if (alreadyFetched.containsKey(v.name())) {
      maybeVal=alreadyFetched.get(v.name());
    }
 else {
      maybeVal=cv.findRetrieveResult(v);
    }
    if (maybeVal != null) {
      inVals.add(maybeVal);
      alreadyFetched.put(v.name(),maybeVal);
    }
 else {
      Var fetchedV=OptUtil.fetchValueOf(insertContext,alt,v);
      Arg fetched=Arg.createVar(fetchedV);
      inVals.add(fetched);
      alreadyFetched.put(v.name(),fetched);
    }
  }
  List<Var> outValVars=OptUtil.declareLocalOpOutputVars(insertContext,req.out);
  MakeImmChange change=inst.makeImmediate(outValVars,inVals);
  OptUtil.fixupImmChange(insertContext,change,alt,outValVars,req.out);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
  }
  insts.remove();
  for (  Instruction newInst : alt) {
    insertPoint.add(newInst);
  }
  if (inst == insertPoint) {
    ICUtil.rewindIterator(insts,alt.size());
  }
 else {
    insts.previous();
  }
  return true;
}","/** 
 * @param logger
 * @param fn
 * @param block
 * @param cv
 * @param inst
 * @param insts if instructions inserted, leaves iterator pointing at previous instruction
 * @return
 */
private static boolean switchToImmediate(Logger logger,Function fn,ExecContext execCx,Block block,State cv,Instruction inst,ListIterator<Instruction> insts){
  MakeImmRequest req=inst.canMakeImmediate(cv.getClosed(),cv.getUnmapped(),false);
  if (req == null) {
    return false;
  }
  Block insertContext;
  ListIterator<Instruction> insertPoint;
  if (req.mode == TaskMode.LOCAL || req.mode == TaskMode.SYNC || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
    insertContext=block;
    insertPoint=insts;
  }
 else {
    List<Var> used=Var.varListUnion(req.in,req.out);
    WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + inst.shortOpName(),Collections.<Var>emptyList(),used,Collections.<Var>emptyList(),inst.getPriority(),WaitMode.TASK_DISPATCH,false,req.mode);
    insertContext=wait.getBlock();
    block.addContinuation(wait);
    insertPoint=insertContext.instructionIterator();
  }
  List<Instruction> alt=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>(req.in.size());
  HashMap<String,Arg> alreadyFetched=new HashMap<String,Arg>();
  for (  Var v : req.in) {
    Arg maybeVal;
    if (alreadyFetched.containsKey(v.name())) {
      maybeVal=alreadyFetched.get(v.name());
    }
 else {
      maybeVal=cv.findRetrieveResult(v);
    }
    if (maybeVal != null) {
      inVals.add(maybeVal);
      alreadyFetched.put(v.name(),maybeVal);
    }
 else {
      Var fetchedV=OptUtil.fetchValueOf(insertContext,alt,v);
      Arg fetched=Arg.createVar(fetchedV);
      inVals.add(fetched);
      alreadyFetched.put(v.name(),fetched);
    }
  }
  List<Var> outValVars=OptUtil.declareLocalOpOutputVars(insertContext,req.out);
  MakeImmChange change=inst.makeImmediate(outValVars,inVals);
  OptUtil.fixupImmChange(block,insertContext,change,alt,outValVars,req.out);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
  }
  insts.remove();
  for (  Instruction newInst : alt) {
    insertPoint.add(newInst);
  }
  if (inst == insertPoint) {
    ICUtil.rewindIterator(insts,alt.size());
  }
 else {
    insts.previous();
  }
  return true;
}",0.9987228607918264
133109,"public static void fixupImmChange(Block block,MakeImmChange change,List<Instruction> instBuffer,List<Var> newOutVars,List<Var> oldOutVars){
  for (  Instruction newInst : change.newInsts) {
    instBuffer.add(newInst);
  }
  if (!change.isOutVarSame()) {
    Var newOut=change.newOut;
    Var oldOut=change.oldOut;
    OptUtil.replaceInstructionOutputVar(block,instBuffer,newOut,oldOut);
  }
  if (newOutVars != null) {
    for (int i=0; i < newOutVars.size(); i++) {
      Var oldOut=oldOutVars.get(i);
      Var newOut=newOutVars.get(i);
      instBuffer.add(ICInstructions.futureSet(oldOut,Arg.createVar(newOut)));
    }
  }
}","public static void fixupImmChange(Block srcBlock,Block targetBlock,MakeImmChange change,List<Instruction> instBuffer,List<Var> newOutVars,List<Var> oldOutVars){
  for (  Instruction newInst : change.newInsts) {
    instBuffer.add(newInst);
  }
  if (!change.isOutVarSame()) {
    Var newOut=change.newOut;
    Var oldOut=change.oldOut;
    OptUtil.replaceInstructionOutputVar(srcBlock,instBuffer,newOut,oldOut);
  }
  if (newOutVars != null) {
    for (int i=0; i < newOutVars.size(); i++) {
      Var oldOut=oldOutVars.get(i);
      Var newOut=newOutVars.get(i);
      instBuffer.add(ICInstructions.futureSet(oldOut,Arg.createVar(newOut)));
    }
  }
}",0.9781591263650546
133110,"/** 
 * Convert dataflow f() to local f_l() with wait around it
 * @param logger
 * @param block
 * @return
 */
private static boolean explodeFuncCalls(Logger logger,Function fn,ExecContext execCx,Block block){
  boolean changed=false;
  Set<String> empty=Collections.emptySet();
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction i=it.next();
    MakeImmRequest req=i.canMakeImmediate(empty,Collections.<String>emptySet(),true);
    if (req != null && req.in.size() > 0) {
      List<Var> waitVars=ICUtil.filterBlockingOnly(req.in);
      WaitMode waitMode;
      if (req.mode == TaskMode.SYNC || req.mode == TaskMode.LOCAL || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
        waitMode=WaitMode.DATA_ONLY;
      }
 else {
        waitMode=WaitMode.TASK_DISPATCH;
      }
      List<Var> outWriteRefcounted=RefCounting.filterWriteRefcount(req.out == null ? Collections.<Var>emptyList() : req.out);
      WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + i.shortOpName(),waitVars,req.in,outWriteRefcounted,i.getPriority(),waitMode,true,req.mode);
      block.addContinuation(wait);
      List<Instruction> instBuffer=new ArrayList<Instruction>();
      List<Arg> inVals=OptUtil.fetchValuesOf(wait.getBlock(),instBuffer,req.in);
      List<Var> localOutputs=OptUtil.declareLocalOpOutputVars(wait.getBlock(),req.out);
      MakeImmChange change=i.makeImmediate(localOutputs,inVals);
      OptUtil.fixupImmChange(wait.getBlock(),change,instBuffer,localOutputs,req.out);
      it.remove();
      wait.getBlock().addInstructions(instBuffer);
      changed=true;
    }
  }
  return changed;
}","/** 
 * Convert dataflow f() to local f_l() with wait around it
 * @param logger
 * @param block
 * @return
 */
private static boolean explodeFuncCalls(Logger logger,Function fn,ExecContext execCx,Block block){
  boolean changed=false;
  Set<String> empty=Collections.emptySet();
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction i=it.next();
    MakeImmRequest req=i.canMakeImmediate(empty,Collections.<String>emptySet(),true);
    if (req != null && req.in.size() > 0) {
      if (logger.isTraceEnabled()) {
        logger.trace(""String_Node_Str"" + i + ""String_Node_Str""+ fn.getName());
      }
      List<Var> waitVars=ICUtil.filterBlockingOnly(req.in);
      WaitMode waitMode;
      if (req.mode == TaskMode.SYNC || req.mode == TaskMode.LOCAL || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
        waitMode=WaitMode.DATA_ONLY;
      }
 else {
        waitMode=WaitMode.TASK_DISPATCH;
      }
      List<Var> outWriteRefcounted=RefCounting.filterWriteRefcount(req.out == null ? Collections.<Var>emptyList() : req.out);
      WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + i.shortOpName(),waitVars,req.in,outWriteRefcounted,i.getPriority(),waitMode,true,req.mode);
      block.addContinuation(wait);
      List<Instruction> instBuffer=new ArrayList<Instruction>();
      List<Arg> inVals=OptUtil.fetchValuesOf(wait.getBlock(),instBuffer,req.in);
      List<Var> localOutputs=OptUtil.declareLocalOpOutputVars(wait.getBlock(),req.out);
      MakeImmChange change=i.makeImmediate(localOutputs,inVals);
      OptUtil.fixupImmChange(block,wait.getBlock(),change,instBuffer,localOutputs,req.out);
      it.remove();
      wait.getBlock().addInstructions(instBuffer);
      changed=true;
    }
  }
  return changed;
}",0.9629207073588134
133111,"public static void fixupVariablePassing(Logger logger,Program prog,Function fn,Set<String> referencedGlobals){
  HierarchicalMap<String,Var> fnargs=new HierarchicalMap<String,Var>();
  for (  Var v : fn.getInputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Var v : fn.getOutputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Entry<String,Arg> e : prog.getGlobalConsts().entrySet()) {
    Arg a=e.getValue();
    Var v=new Var(a.getType(),e.getKey(),VarStorage.GLOBAL_CONST,DefType.GLOBAL_CONST,null);
    fnargs.put(e.getKey(),v);
  }
  HashSet<String> neededVars=fixupVariablePassing(logger,fn.getMainblock(),fnargs,referencedGlobals);
  neededVars.removeAll(Var.nameList(fn.getInputList()));
  neededVars.removeAll(Var.nameList(fn.getOutputList()));
  if (neededVars.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ neededVars.toString());
  }
}","public static void fixupVariablePassing(Logger logger,Program prog,Function fn,Set<String> referencedGlobals){
  HierarchicalMap<String,Var> fnargs=new HierarchicalMap<String,Var>();
  for (  Var v : fn.getInputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Var v : fn.getOutputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Entry<String,Arg> e : prog.getGlobalConsts().entrySet()) {
    Arg a=e.getValue();
    Var v=new Var(a.getType(),e.getKey(),VarStorage.GLOBAL_CONST,DefType.GLOBAL_CONST,null);
    fnargs.put(e.getKey(),v);
  }
  HashSet<String> neededVars=fixupVariablePassing(logger,fn,fn.getMainblock(),fnargs,referencedGlobals);
  neededVars.removeAll(Var.nameList(fn.getInputList()));
  neededVars.removeAll(Var.nameList(fn.getOutputList()));
  if (neededVars.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ neededVars.toString());
  }
}",0.9983434566537824
133112,"private void updateName(Logger logger,Block block,Function targetFunction,Map<String,Arg> replacements,Set<String> excludedNames,Var var){
  String newName=targetFunction.getMainblock().uniqueVarName(var.name(),excludedNames);
  Var newVar=new Var(var.type(),newName,var.storage(),var.defType(),var.mapping());
  replacements.put(var.name(),Arg.createVar(newVar));
  excludedNames.add(newName);
  UniqueVarNames.replaceCleanup(block,var,newVar);
  logger.trace(""String_Node_Str"" + var + ""String_Node_Str""+ newVar+ ""String_Node_Str""+ targetFunction.getName());
}","private void updateName(Logger logger,Block block,Function targetFunction,Map<String,Arg> replacements,Set<String> excludedNames,Var var){
  String newName=targetFunction.getMainblock().uniqueVarName(var.name(),excludedNames);
  Var newVar=new Var(var.type(),newName,var.storage(),var.defType(),var.mapping());
  assert(!replacements.containsKey(newName));
  replacements.put(var.name(),Arg.createVar(newVar));
  excludedNames.add(newName);
  UniqueVarNames.replaceCleanup(block,var,newVar);
  logger.trace(""String_Node_Str"" + var + ""String_Node_Str""+ newVar+ ""String_Node_Str""+ targetFunction.getName());
}",0.9606164383561644
133113,"public static void fixupVariablePassing(Logger logger,Program prog,Function fn,Set<String> referencedGlobals){
  HierarchicalMap<String,Var> fnargs=new HierarchicalMap<String,Var>();
  for (  Var v : fn.getInputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Var v : fn.getOutputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Entry<String,Arg> e : prog.getGlobalConsts().entrySet()) {
    Arg a=e.getValue();
    Var v=new Var(a.getType(),e.getKey(),VarStorage.GLOBAL_CONST,DefType.GLOBAL_CONST,null);
    fnargs.put(e.getKey(),v);
  }
  HashSet<String> neededVars=fixupVariablePassing(logger,fn.getMainblock(),fnargs);
  neededVars.removeAll(Var.nameList(fn.getInputList()));
  neededVars.removeAll(Var.nameList(fn.getOutputList()));
  if (neededVars.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ neededVars.toString());
  }
}","public static void fixupVariablePassing(Logger logger,Program prog,Function fn,Set<String> referencedGlobals){
  HierarchicalMap<String,Var> fnargs=new HierarchicalMap<String,Var>();
  for (  Var v : fn.getInputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Var v : fn.getOutputList()) {
    fnargs.put(v.name(),v);
  }
  for (  Entry<String,Arg> e : prog.getGlobalConsts().entrySet()) {
    Arg a=e.getValue();
    Var v=new Var(a.getType(),e.getKey(),VarStorage.GLOBAL_CONST,DefType.GLOBAL_CONST,null);
    fnargs.put(e.getKey(),v);
  }
  HashSet<String> neededVars=fixupVariablePassing(logger,fn.getMainblock(),fnargs,referencedGlobals);
  neededVars.removeAll(Var.nameList(fn.getInputList()));
  neededVars.removeAll(Var.nameList(fn.getOutputList()));
  if (neededVars.size() > 0) {
    throw new STCRuntimeError(""String_Node_Str"" + fn.getName() + ""String_Node_Str""+ neededVars.toString());
  }
}",0.9899441340782122
133114,"protected void fuseIntoAbstract(AbstractLoop o,boolean insertAtTop){
  this.loopBody.insertInline(o.loopBody,insertAtTop);
  this.addKeepOpenVars(o.keepOpenVars);
  ICUtil.removeDuplicates(this.keepOpenVars);
  this.addPassedInVars(o.passedInVars);
  ICUtil.removeDuplicates(this.passedInVars);
}","protected void fuseIntoAbstract(AbstractLoop o,boolean insertAtTop){
  this.loopBody.insertInline(o.loopBody,insertAtTop);
  this.addKeepOpenVars(o.keepOpenVars);
  ICUtil.removeDuplicates(this.keepOpenVars);
  this.addPassedInVars(o.passedInVars);
}",0.9157509157509156
133115,"public AbstractLoop(Block block,List<Var> usedVars,List<Var> keepOpenVars){
  super(usedVars,keepOpenVars);
  this.loopBody=block;
  this.loopBody.setParent(this);
}","public AbstractLoop(Block loopBody,List<Var> usedVars,List<Var> keepOpenVars){
  super(usedVars,keepOpenVars);
  this.loopBody=loopBody;
  this.loopBody.setParent(this);
}",0.9464285714285714
133116,"@Override public void addPassedInVars(Collection<Var> vars){
  super.addPassedInVars(vars);
  this.loopContinue.removeUsedVars(vars);
  this.loopBreak.removeUsedVars(vars);
}","@Override public void addPassedInVars(Collection<Var> vars){
  super.addPassedInVars(vars);
  this.loopContinue.addUsedVars(vars);
  this.loopBreak.addUsedVars(vars);
}",0.9473684210526316
133117,"private Pair<LoopBreak,LoopContinue> findInstructions(Block body){
}","private Pair<LoopBreak,LoopContinue> findInstructions(){
}",0.9206349206349206
133118,"public void addUsedVar(Var variable){
  this.loopUsedVars.add(variable);
}","public void addUsedVar(Var variable){
  this.loopUsedVars.add(variable);
  ICUtil.removeDuplicates(this.loopUsedVars);
}",0.7628865979381443
133119,"private void decrementAllRefs(List<Var> usedVars,List<Var> keepOpenVars,Expression refDecrAmount){
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVars,keepOpenVars);
  pointStack.peek().append(decrementReaders(readOnlyUsedVars,refDecrAmount));
  pointStack.peek().append(decrementWriters(keepOpenVars,refDecrAmount));
}","private void decrementAllRefs(List<Var> usedVars,List<Var> keepOpenVars,Expression refDecrAmount){
  keepOpenVars=RefCounting.filterWriteRefcount(keepOpenVars);
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVars,keepOpenVars);
  pointStack.peek().append(decrementReaders(readOnlyUsedVars,refDecrAmount));
  pointStack.peek().append(decrementWriters(keepOpenVars,refDecrAmount));
}",0.9119318181818182
133120,"private void incrementAllRefs(List<Var> usedVars,List<Var> keepOpenVars,Expression refIncrAmount){
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVars,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,refIncrAmount));
  pointStack.peek().append(incrementWriters(keepOpenVars,refIncrAmount));
}","/** 
 * Increment reference counts upon calling something asynchronously. It is valid to call this function with usedVars = <all variables from outer scope that are used in new scope> keepOpenVars = <all variables written in new scope>
 * @param usedVars any variables used in the new scope.  If thereis overlap with keepOpenVars, only the write refcount is used
 * @param keepOpenVars any written variables for which write refcount mayneed to be maintained.  Any variables without write refcount are filtered out, so it is valid to just pass a list of all variables written in new scope. 
 */
private void incrementAllRefs(List<Var> usedVars,List<Var> keepOpenVars,Expression refIncrAmount){
  keepOpenVars=RefCounting.filterWriteRefcount(keepOpenVars);
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVars,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,refIncrAmount));
  pointStack.peek().append(incrementWriters(keepOpenVars,refIncrAmount));
}",0.4946070878274268
133121,"private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType.getImplType())) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  List<Var> usedVars=null;
  List<Var> keepOpen=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    keepOpen=RefCounting.filterWriteRefcount(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,keepOpen,Arg.createVar(priorityVal),WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(usedVars,keepOpen);
  }
}","private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType.getImplType())) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  List<Var> usedVars=null;
  List<Var> keepOpen=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    keepOpen=RefCounting.filterWriteRefcount(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,keepOpen,priorityVal == null ? null : Arg.createVar(priorityVal),WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(usedVars,keepOpen);
  }
}",0.993672267073969
133122,"public void addVariable(Var variable){
  this.variables.add(variable);
}","public void addVariable(Var variable,boolean atTop){
  if (atTop) {
    this.variables.add(0,variable);
  }
 else {
    this.variables.add(variable);
  }
}",0.6343612334801763
133123,"private void findEssentialVars(Set<String> stillNeeded,List<List<Var>> interdependencies){
  for (  Var v : variables) {
    if (v.isMapped()) {
      stillNeeded.add(v.name());
      stillNeeded.add(v.mapping().name());
    }
  }
  for (  Instruction i : instructions) {
    for (    Arg oa : i.getInputs()) {
      if (oa.isVar()) {
        stillNeeded.add(oa.getVar().name());
      }
    }
    if (i.hasSideEffects()) {
      for (      Var out : i.getOutputs()) {
        stillNeeded.add(out.name());
      }
    }
 else {
      interdependencies.add(i.getOutputs());
    }
  }
  for (  Continuation c : continuations) {
    for (    Var v : c.requiredVars()) {
      stillNeeded.add(v.name());
    }
    for (    Block b : c.getBlocks()) {
      b.findEssentialVars(stillNeeded,interdependencies);
    }
  }
  for (  CleanupAction a : cleanupActions) {
    if (a.action.writesAliasVar()) {
      stillNeeded.add(a.var.name());
    }
    for (    Arg out : a.action.getInputs()) {
      if (out.isVar()) {
        stillNeeded.add(out.getVar().name());
      }
    }
  }
}","private void findEssentialVars(Set<String> stillNeeded,List<List<Var>> interdependencies){
  for (  Var v : variables) {
    if (v.isMapped()) {
      stillNeeded.add(v.name());
      stillNeeded.add(v.mapping().name());
    }
  }
  for (  Instruction i : instructions) {
    updateEssentialVars(i,stillNeeded,interdependencies,i.hasSideEffects());
  }
  for (  Continuation c : continuations) {
    for (    Var v : c.requiredVars()) {
      stillNeeded.add(v.name());
    }
    for (    Block b : c.getBlocks()) {
      b.findEssentialVars(stillNeeded,interdependencies);
    }
  }
  for (  CleanupAction a : cleanupActions) {
    boolean actionHasSideEffects=a.hasSideEffect();
    updateEssentialVars(a.action(),stillNeeded,interdependencies,actionHasSideEffects);
    if (actionHasSideEffects) {
      stillNeeded.add(a.var().name());
    }
  }
}",0.6590555267254801
133124,"public void renameCleanupActions(Map<String,Arg> renames,boolean inputsOnly){
  ListIterator<CleanupAction> it=cleanupActions.listIterator();
  while (it.hasNext()) {
    CleanupAction a=it.next();
    if (inputsOnly) {
      a.action.renameInputs(renames);
    }
 else {
      a.action.renameVars(renames);
    }
    if (!inputsOnly && renames.containsKey(a.var.name())) {
      Arg replacement=renames.get(a.var.name());
      if (replacement.isVar()) {
      }
 else {
      }
    }
  }
}","public void renameCleanupActions(Map<String,Arg> renames,boolean inputsOnly){
  for (  CleanupAction a : cleanupActions) {
    a.renameVars(renames,inputsOnly);
  }
}",0.45662100456621
133125,"/** 
 * List of variables needed by async
 * @param usedVars
 * @param waitVars
 * @return
 */
private List<Var> asyncUsedVars(List<Var> usedVars,List<Var> waitVars){
  List<Var> neededVars=new ArrayList<Var>(usedVars);
  Set<String> existingNames=Var.nameSet(usedVars);
  for (  Var wv : waitVars) {
    if (existingNames.contains(wv)) {
      neededVars.add(wv);
    }
  }
  return neededVars;
}","/** 
 * List of variables needed by async
 * @param usedVars
 * @param waitVars
 * @return
 */
private List<Var> asyncUsedVars(List<Var> usedVars,List<Var> waitVars){
  List<Var> neededVars=new ArrayList<Var>(usedVars);
  Set<String> existingNames=Var.nameSet(usedVars);
  for (  Var wv : waitVars) {
    if (!existingNames.contains(wv.name())) {
      neededVars.add(wv);
    }
  }
  return neededVars;
}",0.9900249376558604
133126,"/** 
 * Start code that will execute asynchronously
 * @param procName the name of the wait block (useful so generatedtcl code can have a nice name for the block)
 * @param waitVars
 * @param usedVars any variables which are read or written inside block
 * @param keepOpenVars any vars that need to be kept open for wait
 * @param mode what guarantees wait statement should provide
 * @param recursive if true, wait until all contents of arrays/structs(recursively) are closed
 * @param target controls where asynchronous execution occurs
 */
public abstract void startWaitStatement(String procName,List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars,WaitMode mode,boolean recursive,TaskMode target);","/** 
 * Start code that will execute asynchronously
 * @param procName the name of the wait block (useful so generatedtcl code can have a nice name for the block)
 * @param waitVars
 * @param usedVars any variables which are read or written inside block
 * @param keepOpenVars any vars that need to be kept open for wait
 * @param mode what guarantees wait statement should provide
 * @param recursive if true, wait until all contents of arrays/structs(recursively) are closed
 * @param target controls where asynchronous execution occurs
 */
public abstract void startWaitStatement(String procName,List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars,Arg priority,WaitMode mode,boolean recursive,TaskMode target);",0.9909154437456325
133127,"/** 
 * Handle the special case of a foreach loop where we are looping over range specified by two or three integer parameters
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachRange(Context context,ForeachLoop loop) throws UserException {
  ArrayRange range=ArrayRange.fromAST(context,loop.getArrayVarTree());
  range.typeCheck(context);
  Var start=exprWalker.eval(context,range.getStart(),Types.F_INT,false,null);
  Var end=exprWalker.eval(context,range.getEnd(),Types.F_INT,false,null);
  Var step;
  if (range.getStep() != null) {
    step=exprWalker.eval(context,range.getStep(),Types.F_INT,false,null);
  }
 else {
    step=varCreator.createTmp(context,Types.F_INT);
    backend.assignInt(step,Arg.createIntLit(1));
  }
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  ArrayList<Var> waitUsedVariables=new ArrayList<Var>(usedVariables);
  waitUsedVariables.addAll(Arrays.asList(start,end,step));
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(start,end,step),waitUsedVariables,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var startVal=varCreator.fetchValueOf(waitContext,start);
  Var endVal=varCreator.fetchValueOf(waitContext,end);
  Var stepVal=varCreator.fetchValueOf(waitContext,step);
  Context bodyContext=loop.setupLoopBodyContext(waitContext);
  Var memberVal=varCreator.createValueOfVar(bodyContext,loop.getMemberVar(),false);
  Var counterVal=loop.getLoopCountVal();
  backend.startRangeLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,memberVal,counterVal,Arg.createVar(startVal),Arg.createVar(endVal),Arg.createVar(stepVal),usedVariables,keepOpenVars,loop.getDesiredUnroll(),loop.getSplitDegree());
  List<Var> waitUsedVars=null;
  if (!loop.isSyncLoop()) {
    waitUsedVars=new ArrayList<Var>(usedVariables);
    waitUsedVars.add(memberVal);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),waitUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  varCreator.initialiseVariable(bodyContext,loop.getMemberVar());
  backend.assignInt(loop.getMemberVar(),Arg.createVar(memberVal));
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(bodyContext,Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(counterVal));
  }
  block(bodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(waitUsedVars,keepOpenVars);
  }
  backend.endRangeLoop(usedVariables,keepOpenVars,loop.getSplitDegree());
  backend.endWaitStatement(usedVariables,keepOpenVars);
}","/** 
 * Handle the special case of a foreach loop where we are looping over range specified by two or three integer parameters
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachRange(Context context,ForeachLoop loop) throws UserException {
  ArrayRange range=ArrayRange.fromAST(context,loop.getArrayVarTree());
  range.typeCheck(context);
  Var start=exprWalker.eval(context,range.getStart(),Types.F_INT,false,null);
  Var end=exprWalker.eval(context,range.getEnd(),Types.F_INT,false,null);
  Var step;
  if (range.getStep() != null) {
    step=exprWalker.eval(context,range.getStep(),Types.F_INT,false,null);
  }
 else {
    step=varCreator.createTmp(context,Types.F_INT);
    backend.assignInt(step,Arg.createIntLit(1));
  }
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  ArrayList<Var> waitUsedVariables=new ArrayList<Var>(usedVariables);
  waitUsedVariables.addAll(Arrays.asList(start,end,step));
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(start,end,step),waitUsedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var startVal=varCreator.fetchValueOf(waitContext,start);
  Var endVal=varCreator.fetchValueOf(waitContext,end);
  Var stepVal=varCreator.fetchValueOf(waitContext,step);
  Context bodyContext=loop.setupLoopBodyContext(waitContext);
  Var memberVal=varCreator.createValueOfVar(bodyContext,loop.getMemberVar(),false);
  Var counterVal=loop.getLoopCountVal();
  backend.startRangeLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,memberVal,counterVal,Arg.createVar(startVal),Arg.createVar(endVal),Arg.createVar(stepVal),usedVariables,keepOpenVars,loop.getDesiredUnroll(),loop.getSplitDegree());
  List<Var> waitUsedVars=null;
  if (!loop.isSyncLoop()) {
    waitUsedVars=new ArrayList<Var>(usedVariables);
    waitUsedVars.add(memberVal);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),waitUsedVars,keepOpenVars,null,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  varCreator.initialiseVariable(bodyContext,loop.getMemberVar());
  backend.assignInt(loop.getMemberVar(),Arg.createVar(memberVal));
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(bodyContext,Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(counterVal));
  }
  block(bodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(waitUsedVars,keepOpenVars);
  }
  backend.endRangeLoop(usedVariables,keepOpenVars,loop.getSplitDegree());
  backend.endWaitStatement(usedVariables,keepOpenVars);
}",0.9983865763149404
133128,"private void waitStmt(Context context,SwiftAST tree) throws UserException {
  Wait wait=Wait.fromAST(context,tree);
  ArrayList<Var> waitEvaled=new ArrayList<Var>();
  for (  SwiftAST expr : wait.getWaitExprs()) {
    Var res=exprWalker.eval(context,expr,TypeChecker.findSingleExprType(context,expr),false,null);
    waitEvaled.add(res);
  }
  ArrayList<Var> usedVars=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  summariseBranchVariableUsage(context,Arrays.asList(wait.getBlock().getVariableUsage()),usedVars,keepOpenVars);
  HashSet<String> waitVarSet=new HashSet<String>(Var.nameList(waitEvaled));
  waitVarSet.retainAll(Var.nameList(keepOpenVars));
  if (waitVarSet.size() > 0) {
    throw new UserException(context,""String_Node_Str"" + ""String_Node_Str"" + waitVarSet.toString());
  }
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),waitEvaled,usedVars,keepOpenVars,WaitMode.EXPLICIT,false,TaskMode.LOCAL_CONTROL);
  block(new LocalContext(context),wait.getBlock());
  backend.endWaitStatement(usedVars,keepOpenVars);
}","private void waitStmt(Context context,SwiftAST tree) throws UserException {
  Wait wait=Wait.fromAST(context,tree);
  ArrayList<Var> waitEvaled=new ArrayList<Var>();
  for (  SwiftAST expr : wait.getWaitExprs()) {
    Var res=exprWalker.eval(context,expr,TypeChecker.findSingleExprType(context,expr),false,null);
    waitEvaled.add(res);
  }
  ArrayList<Var> usedVars=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  summariseBranchVariableUsage(context,Arrays.asList(wait.getBlock().getVariableUsage()),usedVars,keepOpenVars);
  HashSet<String> waitVarSet=new HashSet<String>(Var.nameList(waitEvaled));
  waitVarSet.retainAll(Var.nameList(keepOpenVars));
  if (waitVarSet.size() > 0) {
    throw new UserException(context,""String_Node_Str"" + ""String_Node_Str"" + waitVarSet.toString());
  }
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),waitEvaled,usedVars,keepOpenVars,null,WaitMode.EXPLICIT,false,TaskMode.LOCAL_CONTROL);
  block(new LocalContext(context),wait.getBlock());
  backend.endWaitStatement(usedVars,keepOpenVars);
}",0.9977220956719818
133129,"/** 
 * @param context local context for app function
 * @param cmd AST for app function command
 * @param outputs output arguments for app
 * @param hasSideEffects
 * @param deterministic
 * @throws UserException
 */
private void genAppFunctionBody(Context context,SwiftAST appBody,List<Var> outputs,boolean hasSideEffects,boolean deterministic) throws UserException {
  assert(appBody.getType() == ExMParser.APP_BODY);
  assert(appBody.getChildCount() >= 1);
  SwiftAST cmd=appBody.child(0);
  assert(cmd.getType() == ExMParser.COMMAND);
  assert(cmd.getChildCount() >= 1);
  SwiftAST appNameT=cmd.child(0);
  assert(appNameT.getType() == ExMParser.STRING);
  String appName=Literals.extractLiteralString(context,appNameT);
  List<Var> args=evalAppCmdArgs(context,cmd);
  Redirects<Var> redirFutures=processAppRedirects(context,appBody.children(1));
  checkAppOutputs(context,appName,outputs,args,redirFutures);
  Pair<Map<String,Var>,List<Var>> wait=selectAppWaitVars(context,args,redirFutures);
  Map<String,Var> fileNames=wait.val1;
  List<Var> waitVars=wait.val2;
  List<Var> passIn=new ArrayList<Var>();
  passIn.addAll(fileNames.values());
  passIn.addAll(args);
  String waitName=context.getFunctionContext().constructName(""String_Node_Str"");
  backend.startWaitStatement(waitName,waitVars,passIn,Collections.<Var>emptyList(),WaitMode.TASK_DISPATCH,true,TaskMode.LEAF);
  Pair<List<Arg>,Redirects<Arg>> retrieved=retrieveAppArgs(context,args,redirFutures,fileNames);
  List<Arg> localArgs=retrieved.val1;
  Redirects<Arg> localRedirects=retrieved.val2;
  backend.runExternal(appName,localArgs,outputs,localRedirects,hasSideEffects,deterministic);
  backend.endWaitStatement(passIn,Arrays.<Var>asList());
}","/** 
 * @param context local context for app function
 * @param cmd AST for app function command
 * @param outputs output arguments for app
 * @param hasSideEffects
 * @param deterministic
 * @throws UserException
 */
private void genAppFunctionBody(Context context,SwiftAST appBody,List<Var> outputs,boolean hasSideEffects,boolean deterministic) throws UserException {
  assert(appBody.getType() == ExMParser.APP_BODY);
  assert(appBody.getChildCount() >= 1);
  SwiftAST cmd=appBody.child(0);
  assert(cmd.getType() == ExMParser.COMMAND);
  assert(cmd.getChildCount() >= 1);
  SwiftAST appNameT=cmd.child(0);
  assert(appNameT.getType() == ExMParser.STRING);
  String appName=Literals.extractLiteralString(context,appNameT);
  List<Var> args=evalAppCmdArgs(context,cmd);
  Redirects<Var> redirFutures=processAppRedirects(context,appBody.children(1));
  checkAppOutputs(context,appName,outputs,args,redirFutures);
  Pair<Map<String,Var>,List<Var>> wait=selectAppWaitVars(context,args,redirFutures);
  Map<String,Var> fileNames=wait.val1;
  List<Var> waitVars=wait.val2;
  List<Var> passIn=new ArrayList<Var>();
  passIn.addAll(fileNames.values());
  passIn.addAll(args);
  String waitName=context.getFunctionContext().constructName(""String_Node_Str"");
  backend.startWaitStatement(waitName,waitVars,passIn,Collections.<Var>emptyList(),null,WaitMode.TASK_DISPATCH,true,TaskMode.LEAF);
  Pair<List<Arg>,Redirects<Arg>> retrieved=retrieveAppArgs(context,args,redirFutures,fileNames);
  List<Arg> localArgs=retrieved.val1;
  Redirects<Arg> localRedirects=retrieved.val2;
  backend.runExternal(appName,localArgs,outputs,localRedirects,hasSideEffects,deterministic);
  backend.endWaitStatement(passIn,Arrays.<Var>asList());
}",0.9985435479172736
133130,"private void switchStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  Switch sw=Switch.fromAST(context,tree);
  sw.typeCheck(context);
  Var switchVar=exprWalker.eval(context,sw.getSwitchExpr(),Types.F_INT,true,null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  List<VariableUsageInfo> branchVUs=new ArrayList<VariableUsageInfo>();
  for (  SwiftAST b : sw.getCaseBodies()) {
    branchVUs.add(b.checkedGetVariableUsage());
  }
  checkConditionalDeadlock(context,switchVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(switchVar))   usedVariables.add(switchVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(switchVar),usedVariables,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var switchVal=varCreator.createValueOfVar(waitContext,switchVar);
  backend.retrieveInt(switchVal,switchVar);
  LogHelper.trace(context,""String_Node_Str"" + sw.getCaseBodies().size() + ""String_Node_Str"");
  backend.startSwitch(Arg.createVar(switchVal),sw.getCaseLabels(),sw.hasDefault());
  for (  SwiftAST caseBody : sw.getCaseBodies()) {
    block(new LocalContext(waitContext),caseBody);
    backend.endCase();
  }
  backend.endSwitch();
  backend.endWaitStatement(usedVariables,keepOpenVars);
}","private void switchStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  Switch sw=Switch.fromAST(context,tree);
  sw.typeCheck(context);
  Var switchVar=exprWalker.eval(context,sw.getSwitchExpr(),Types.F_INT,true,null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  List<VariableUsageInfo> branchVUs=new ArrayList<VariableUsageInfo>();
  for (  SwiftAST b : sw.getCaseBodies()) {
    branchVUs.add(b.checkedGetVariableUsage());
  }
  checkConditionalDeadlock(context,switchVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(switchVar))   usedVariables.add(switchVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(switchVar),usedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var switchVal=varCreator.createValueOfVar(waitContext,switchVar);
  backend.retrieveInt(switchVal,switchVar);
  LogHelper.trace(context,""String_Node_Str"" + sw.getCaseBodies().size() + ""String_Node_Str"");
  backend.startSwitch(Arg.createVar(switchVal),sw.getCaseLabels(),sw.hasDefault());
  for (  SwiftAST caseBody : sw.getCaseBodies()) {
    block(new LocalContext(waitContext),caseBody);
    backend.endCase();
  }
  backend.endSwitch();
  backend.endWaitStatement(usedVariables,keepOpenVars);
}",0.9983547219480092
133131,"private void ifStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  If ifStmt=If.fromAST(context,tree);
  Var conditionVar=exprWalker.eval(context,ifStmt.getCondition(),ifStmt.getCondType(context),false,null);
  assert(conditionVar != null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo thenVU=ifStmt.getThenBlock().checkedGetVariableUsage();
  List<VariableUsageInfo> branchVUs;
  if (ifStmt.hasElse()) {
    VariableUsageInfo elseVU=ifStmt.getElseBlock().checkedGetVariableUsage();
    branchVUs=Arrays.asList(thenVU,elseVU);
  }
 else {
    branchVUs=Arrays.asList(thenVU);
  }
  checkConditionalDeadlock(context,conditionVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(conditionVar))   usedVariables.add(conditionVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(conditionVar),usedVariables,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var condVal=varCreator.fetchValueOf(waitContext,conditionVar);
  backend.startIfStatement(Arg.createVar(condVal),ifStmt.hasElse());
  block(new LocalContext(waitContext),ifStmt.getThenBlock());
  if (ifStmt.hasElse()) {
    backend.startElseBlock();
    block(new LocalContext(waitContext),ifStmt.getElseBlock());
  }
  backend.endIfStatement();
  backend.endWaitStatement(usedVariables,keepOpenVars);
}","private void ifStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  If ifStmt=If.fromAST(context,tree);
  Var conditionVar=exprWalker.eval(context,ifStmt.getCondition(),ifStmt.getCondType(context),false,null);
  assert(conditionVar != null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo thenVU=ifStmt.getThenBlock().checkedGetVariableUsage();
  List<VariableUsageInfo> branchVUs;
  if (ifStmt.hasElse()) {
    VariableUsageInfo elseVU=ifStmt.getElseBlock().checkedGetVariableUsage();
    branchVUs=Arrays.asList(thenVU,elseVU);
  }
 else {
    branchVUs=Arrays.asList(thenVU);
  }
  checkConditionalDeadlock(context,conditionVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(conditionVar))   usedVariables.add(conditionVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(conditionVar),usedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var condVal=varCreator.fetchValueOf(waitContext,conditionVar);
  backend.startIfStatement(Arg.createVar(condVal),ifStmt.hasElse());
  block(new LocalContext(waitContext),ifStmt.getThenBlock());
  if (ifStmt.hasElse()) {
    backend.startElseBlock();
    block(new LocalContext(waitContext),ifStmt.getElseBlock());
  }
  backend.endIfStatement();
  backend.endWaitStatement(usedVariables,keepOpenVars);
}",0.9984428526938648
133132,"/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(realArray),waitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),iterUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  Set<Var> noRefcount=Collections.singleton(loop.getMemberVar());
  block(loopBodyContext,loop.getBody(),noRefcount);
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(arrRefWaitUsedVars,keepOpenVars);
  }
}","/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(realArray),waitUsedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),iterUsedVars,keepOpenVars,null,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  Set<Var> noRefcount=Collections.singleton(loop.getMemberVar());
  block(loopBodyContext,loop.getBody(),noRefcount);
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(arrRefWaitUsedVars,keepOpenVars);
  }
}",0.997734481196194
133133,"/** 
 * Dereference src into dst ie. dst = *src
 * @param dst
 * @param src
 * @throws UserException 
 * @throws UndefinedTypeException 
 */
public void dereference(Context context,Var dst,Var src) throws UndefinedTypeException, UserException {
  assert(Types.isRef(src.type()));
  assert(Types.isRefTo(src.type(),dst.type()));
  if (Types.isScalarFuture(dst.type())) {
    Type dstType=dst.type();
    if (dstType.equals(Types.F_INT)) {
      backend.dereferenceInt(dst,src);
    }
 else     if (dstType.equals(Types.F_STRING)) {
      backend.dereferenceString(dst,src);
    }
 else     if (dstType.equals(Types.F_FLOAT)) {
      backend.dereferenceFloat(dst,src);
    }
 else     if (dstType.equals(Types.F_BOOL)) {
      backend.dereferenceBool(dst,src);
    }
 else     if (dstType.equals(Types.F_FILE)) {
      backend.dereferenceFile(dst,src);
    }
 else {
      throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + src.type().toString());
    }
  }
 else   if (Types.isArray(dst.type())) {
    String wName=context.getFunctionContext().constructName(""String_Node_Str"");
    List<Var> keepOpenVars=Arrays.asList(dst);
    List<Var> usedVars=Arrays.asList(src,dst);
    backend.startWaitStatement(wName,Arrays.asList(src),usedVars,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
    Var derefed=varCreator.createTmpAlias(context,dst.type());
    backend.retrieveRef(derefed,src);
    copyArrayByValue(context,dst,derefed);
    backend.endWaitStatement(usedVars,keepOpenVars);
  }
 else   if (Types.isStruct(dst.type())) {
    dereferenceStruct(context,dst,src);
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + src.type());
  }
}","/** 
 * Dereference src into dst ie. dst = *src
 * @param dst
 * @param src
 * @throws UserException 
 * @throws UndefinedTypeException 
 */
public void dereference(Context context,Var dst,Var src) throws UndefinedTypeException, UserException {
  assert(Types.isRef(src.type()));
  assert(Types.isRefTo(src.type(),dst.type()));
  if (Types.isScalarFuture(dst.type())) {
    Type dstType=dst.type();
    if (dstType.equals(Types.F_INT)) {
      backend.dereferenceInt(dst,src);
    }
 else     if (dstType.equals(Types.F_STRING)) {
      backend.dereferenceString(dst,src);
    }
 else     if (dstType.equals(Types.F_FLOAT)) {
      backend.dereferenceFloat(dst,src);
    }
 else     if (dstType.equals(Types.F_BOOL)) {
      backend.dereferenceBool(dst,src);
    }
 else     if (dstType.equals(Types.F_FILE)) {
      backend.dereferenceFile(dst,src);
    }
 else {
      throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + src.type().toString());
    }
  }
 else   if (Types.isArray(dst.type())) {
    String wName=context.getFunctionContext().constructName(""String_Node_Str"");
    List<Var> keepOpenVars=Arrays.asList(dst);
    List<Var> usedVars=Arrays.asList(src,dst);
    backend.startWaitStatement(wName,Arrays.asList(src),usedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
    Var derefed=varCreator.createTmpAlias(context,dst.type());
    backend.retrieveRef(derefed,src);
    copyArrayByValue(context,dst,derefed);
    backend.endWaitStatement(usedVars,keepOpenVars);
  }
 else   if (Types.isStruct(dst.type())) {
    dereferenceStruct(context,dst,src);
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + src.type());
  }
}",0.9985043374214776
133134,"private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType.getImplType())) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  List<Var> usedVars=null;
  List<Var> keepOpen=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    keepOpen=RefCounting.filterWriteRefcount(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,keepOpen,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(usedVars,keepOpen);
  }
}","private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType.getImplType())) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  List<Var> usedVars=null;
  List<Var> keepOpen=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    keepOpen=RefCounting.filterWriteRefcount(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,keepOpen,Arg.createVar(priorityVal),WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(usedVars,keepOpen);
  }
}",0.9940357852882704
133135,"private void copyArrayByValue(Context context,Var dst,Var src) throws UserException {
  assert(dst.type().equals(src.type()));
  assert(Types.isArray(src.type()));
  LocalContext copyContext=new LocalContext(context);
  Type t=src.type();
  Type memType=Types.getArrayMemberType(t);
  Var member=copyContext.createAliasVariable(memType);
  Var ix=copyContext.createLocalValueVariable(Types.V_INT);
  List<Var> keepOpen=Arrays.asList(dst);
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,keepOpen,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  backend.startForeachLoop(context.getFunctionContext().constructName(""String_Node_Str""),src,member,ix,-1,true,usedVars,keepOpen);
  backend.arrayInsertImm(member,dst,Arg.createVar(ix));
  backend.endForeachLoop(-1,true,usedVars,keepOpen);
  backend.endWaitStatement(usedVars,keepOpen);
}","private void copyArrayByValue(Context context,Var dst,Var src) throws UserException {
  assert(dst.type().equals(src.type()));
  assert(Types.isArray(src.type()));
  LocalContext copyContext=new LocalContext(context);
  Type t=src.type();
  Type memType=Types.getArrayMemberType(t);
  Var member=copyContext.createAliasVariable(memType);
  Var ix=copyContext.createLocalValueVariable(Types.V_INT);
  List<Var> keepOpen=Arrays.asList(dst);
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,keepOpen,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  backend.startForeachLoop(context.getFunctionContext().constructName(""String_Node_Str""),src,member,ix,-1,true,usedVars,keepOpen);
  backend.arrayInsertImm(member,dst,Arg.createVar(ix));
  backend.endForeachLoop(-1,true,usedVars,keepOpen);
  backend.endWaitStatement(usedVars,keepOpen);
}",0.9973530968766544
133136,"/** 
 * Copy a struct reference to a struct.  We need to do this in the compiler front-end because we want to generate specialized code to walk the structure and copy all struct members
 * @param context
 * @param dst
 * @param src
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void dereferenceStruct(Context context,Var dst,Var src) throws UserException, UndefinedTypeException {
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,new ArrayList<Var>(),WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  Var rValDerefed=varCreator.createTmp(context,src.type().memberType(),false,true);
  backend.retrieveRef(rValDerefed,src);
  copyByValue(context,rValDerefed,dst,dst.type());
  backend.endWaitStatement(usedVars,new ArrayList<Var>());
}","/** 
 * Copy a struct reference to a struct.  We need to do this in the compiler front-end because we want to generate specialized code to walk the structure and copy all struct members
 * @param context
 * @param dst
 * @param src
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void dereferenceStruct(Context context,Var dst,Var src) throws UserException, UndefinedTypeException {
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,new ArrayList<Var>(),null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  Var rValDerefed=varCreator.createTmp(context,src.type().memberType(),false,true);
  backend.retrieveRef(rValDerefed,src);
  copyByValue(context,rValDerefed,dst,dst.type());
  backend.endWaitStatement(usedVars,new ArrayList<Var>());
}",0.997128087306146
133137,"/** 
 * Generate code for a call to a function, where the arguments might be expressions
 * @param context
 * @param tree
 * @param oList
 * @throws UserException
 * @throws UndefinedVariableException
 * @throws UndefinedFunctionException
 */
private void callFunctionExpression(Context context,SwiftAST tree,List<Var> oList,Map<String,String> renames) throws UserException {
  FunctionCall f=FunctionCall.fromAST(context,tree,true);
  FunctionType concrete=TypeChecker.concretiseFunctionCall(context,f.function(),f.type(),f.args(),oList,false);
  try {
    if (Builtins.isAssertVariant(f.function()) && Settings.getBoolean(Settings.OPT_DISABLE_ASSERTS)) {
      return;
    }
  }
 catch (  InvalidOptionException e) {
    throw new STCRuntimeError(""String_Node_Str"" + e.toString());
  }
  ArrayList<Var> argVars=new ArrayList<Var>(f.args().size());
  for (int i=0; i < f.args().size(); i++) {
    SwiftAST argtree=f.args().get(i);
    Type expType=concrete.getInputs().get(i);
    Type exprType=TypeChecker.findSingleExprType(context,argtree);
    Type argtype=TypeChecker.checkFunArg(context,f.function(),i,expType,exprType).val2;
    argVars.add(eval(context,argtree,argtype,false,renames));
  }
  Var priorityVal=null;
  boolean openedWait=false;
  ArrayList<Var> usedVariables=null;
  List<Var> keepOpen=RefCounting.filterWriteRefcount(oList);
  Context callContext=context;
  if (tree.getChildCount() == 3) {
    SwiftAST priorityT=tree.child(2);
    Var priorityFuture=eval(context,priorityT,Types.F_INT,false,renames);
    usedVariables=new ArrayList<Var>();
    usedVariables.addAll(argVars);
    usedVariables.addAll(oList);
    backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(priorityFuture),usedVariables,keepOpen,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    openedWait=true;
    callContext=new LocalContext(context);
    priorityVal=varCreator.fetchValueOf(callContext,priorityFuture);
  }
  callFunction(context,f.function(),concrete,oList,argVars,priorityVal);
  if (openedWait) {
    backend.endWaitStatement(usedVariables,keepOpen);
  }
}","/** 
 * Generate code for a call to a function, where the arguments might be expressions
 * @param context
 * @param tree
 * @param oList
 * @throws UserException
 * @throws UndefinedVariableException
 * @throws UndefinedFunctionException
 */
private void callFunctionExpression(Context context,SwiftAST tree,List<Var> oList,Map<String,String> renames) throws UserException {
  FunctionCall f=FunctionCall.fromAST(context,tree,true);
  FunctionType concrete=TypeChecker.concretiseFunctionCall(context,f.function(),f.type(),f.args(),oList,false);
  try {
    if (Builtins.isAssertVariant(f.function()) && Settings.getBoolean(Settings.OPT_DISABLE_ASSERTS)) {
      return;
    }
  }
 catch (  InvalidOptionException e) {
    throw new STCRuntimeError(""String_Node_Str"" + e.toString());
  }
  ArrayList<Var> argVars=new ArrayList<Var>(f.args().size());
  for (int i=0; i < f.args().size(); i++) {
    SwiftAST argtree=f.args().get(i);
    Type expType=concrete.getInputs().get(i);
    Type exprType=TypeChecker.findSingleExprType(context,argtree);
    Type argtype=TypeChecker.checkFunArg(context,f.function(),i,expType,exprType).val2;
    argVars.add(eval(context,argtree,argtype,false,renames));
  }
  Var priorityVal=null;
  boolean openedWait=false;
  ArrayList<Var> usedVariables=null;
  List<Var> keepOpen=RefCounting.filterWriteRefcount(oList);
  Context callContext=context;
  if (tree.getChildCount() == 3) {
    SwiftAST priorityT=tree.child(2);
    Var priorityFuture=eval(context,priorityT,Types.F_INT,false,renames);
    usedVariables=new ArrayList<Var>();
    usedVariables.addAll(argVars);
    usedVariables.addAll(oList);
    backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(priorityFuture),usedVariables,keepOpen,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    openedWait=true;
    callContext=new LocalContext(context);
    priorityVal=varCreator.fetchValueOf(callContext,priorityFuture);
  }
  callFunction(context,f.function(),concrete,oList,argVars,priorityVal);
  if (openedWait) {
    backend.endWaitStatement(usedVariables,keepOpen);
  }
}",0.9988221436984688
133138,"@Override public void generateWrappedBuiltin(String function,FunctionType ft,List<Var> outArgs,List<Var> inArgs,TaskMode mode) throws UserException {
  Function fn=new Function(function,inArgs,outArgs,TaskMode.SYNC);
  this.program.addFunction(fn);
  List<Var> used=new ArrayList<Var>();
  used.addAll(inArgs);
  used.addAll(outArgs);
  WaitMode waitMode;
  if (mode == TaskMode.LOCAL || mode == TaskMode.SYNC) {
    waitMode=WaitMode.DATA_ONLY;
  }
 else {
    waitMode=WaitMode.TASK_DISPATCH;
  }
  WaitStatement wait=new WaitStatement(function + ""String_Node_Str"",inArgs,used,Collections.<Var>emptyList(),waitMode,true,mode);
  fn.getMainblock().addContinuation(wait);
  Block block=wait.getBlock();
  List<Instruction> instBuffer=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>();
  for (  Var inArg : inArgs) {
    inVals.add(Arg.createVar(WrapUtil.fetchValueOf(block,instBuffer,inArg,Var.LOCAL_VALUE_VAR_PREFIX + inArg.name())));
  }
  List<Var> outVals=new ArrayList<Var>();
  for (  Var outArg : outArgs) {
    outVals.add(WrapUtil.declareLocalOutputVar(block,outArg,Var.LOCAL_VALUE_VAR_PREFIX + outArg.name()));
  }
  instBuffer.add(new LocalFunctionCall(function,inVals,outVals));
  for (int i=0; i < outVals.size(); i++) {
    Var outArg=outArgs.get(i);
    Var outVal=outVals.get(i);
    instBuffer.add(ICInstructions.futureSet(outArg,Arg.createVar(outVal)));
  }
  block.addInstructions(instBuffer);
}","@Override public void generateWrappedBuiltin(String function,FunctionType ft,List<Var> outArgs,List<Var> inArgs,TaskMode mode) throws UserException {
  Function fn=new Function(function,inArgs,outArgs,TaskMode.SYNC);
  this.program.addFunction(fn);
  List<Var> used=new ArrayList<Var>();
  used.addAll(inArgs);
  used.addAll(outArgs);
  WaitMode waitMode;
  if (mode == TaskMode.LOCAL || mode == TaskMode.SYNC) {
    waitMode=WaitMode.DATA_ONLY;
  }
 else {
    waitMode=WaitMode.TASK_DISPATCH;
  }
  WaitStatement wait=new WaitStatement(function + ""String_Node_Str"",inArgs,used,Collections.<Var>emptyList(),null,waitMode,true,mode);
  fn.getMainblock().addContinuation(wait);
  Block block=wait.getBlock();
  List<Instruction> instBuffer=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>();
  for (  Var inArg : inArgs) {
    inVals.add(Arg.createVar(WrapUtil.fetchValueOf(block,instBuffer,inArg,Var.LOCAL_VALUE_VAR_PREFIX + inArg.name())));
  }
  List<Var> outVals=new ArrayList<Var>();
  for (  Var outArg : outArgs) {
    outVals.add(WrapUtil.declareLocalOutputVar(block,outArg,Var.LOCAL_VALUE_VAR_PREFIX + outArg.name()));
  }
  instBuffer.add(new LocalFunctionCall(function,inVals,outVals));
  for (int i=0; i < outVals.size(); i++) {
    Var outArg=outArgs.get(i);
    Var outVal=outVals.get(i);
    instBuffer.add(ICInstructions.futureSet(outArg,Arg.createVar(outVal)));
  }
  block.addInstructions(instBuffer);
}",0.998259658893143
133139,"@Override public void startWaitStatement(String procName,List<Var> waitVars,List<Var> usedVariables,List<Var> keepOpenVars,WaitMode mode,boolean recursive,TaskMode target){
  assert(currFunction != null);
  WaitStatement wait=new WaitStatement(procName,waitVars,usedVariables,keepOpenVars,mode,recursive,target);
  currBlock().addContinuation(wait);
  blockStack.push(wait.getBlock());
}","@Override public void startWaitStatement(String procName,List<Var> waitVars,List<Var> usedVariables,List<Var> keepOpenVars,Arg priority,WaitMode mode,boolean recursive,TaskMode target){
  assert(currFunction != null);
  assert(priority == null || priority.isImmediateInt());
  WaitStatement wait=new WaitStatement(procName,waitVars,usedVariables,keepOpenVars,priority,mode,recursive,target);
  currBlock().addContinuation(wait);
  blockStack.push(wait.getBlock());
}",0.9073856975381008
133140,"/** 
 * @param logger
 * @param fn
 * @param block
 * @param cv
 * @param inst
 * @param insts if instructions inserted, leaves iterator pointing at previous instruction
 * @return
 */
private static boolean switchToImmediate(Logger logger,Function fn,ExecContext execCx,Block block,State cv,Instruction inst,ListIterator<Instruction> insts){
  MakeImmRequest req=inst.canMakeImmediate(cv.getClosed(),false);
  if (req == null) {
    return false;
  }
  Block insertContext;
  ListIterator<Instruction> insertPoint;
  if (req.mode == TaskMode.LOCAL || req.mode == TaskMode.SYNC || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
    insertContext=block;
    insertPoint=insts;
  }
 else {
    List<Var> used=Var.varListUnion(req.in,req.out);
    WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + inst.shortOpName(),Collections.<Var>emptyList(),used,Collections.<Var>emptyList(),WaitMode.TASK_DISPATCH,false,req.mode);
    insertContext=wait.getBlock();
    block.addContinuation(wait);
    insertPoint=insertContext.instructionIterator();
  }
  List<Instruction> alt=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>(req.in.size());
  HashMap<String,Arg> alreadyFetched=new HashMap<String,Arg>();
  for (  Var v : req.in) {
    Arg maybeVal;
    if (alreadyFetched.containsKey(v.name())) {
      maybeVal=alreadyFetched.get(v.name());
    }
 else {
      maybeVal=cv.findRetrieveResult(v);
    }
    if (maybeVal != null) {
      inVals.add(maybeVal);
      alreadyFetched.put(v.name(),maybeVal);
    }
 else {
      Var fetchedV=OptUtil.fetchValueOf(insertContext,alt,v);
      Arg fetched=Arg.createVar(fetchedV);
      inVals.add(fetched);
      alreadyFetched.put(v.name(),fetched);
    }
  }
  List<Var> outValVars=OptUtil.declareLocalOpOutputVars(insertContext,req.out);
  MakeImmChange change=inst.makeImmediate(outValVars,inVals);
  OptUtil.fixupImmChange(insertContext,change,alt,outValVars,req.out);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
  }
  insts.remove();
  for (  Instruction newInst : alt) {
    insertPoint.add(newInst);
  }
  if (inst == insertPoint) {
    ICUtil.rewindIterator(insts,alt.size());
  }
 else {
    insts.previous();
  }
  return true;
}","/** 
 * @param logger
 * @param fn
 * @param block
 * @param cv
 * @param inst
 * @param insts if instructions inserted, leaves iterator pointing at previous instruction
 * @return
 */
private static boolean switchToImmediate(Logger logger,Function fn,ExecContext execCx,Block block,State cv,Instruction inst,ListIterator<Instruction> insts){
  MakeImmRequest req=inst.canMakeImmediate(cv.getClosed(),false);
  if (req == null) {
    return false;
  }
  Block insertContext;
  ListIterator<Instruction> insertPoint;
  if (req.mode == TaskMode.LOCAL || req.mode == TaskMode.SYNC || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
    insertContext=block;
    insertPoint=insts;
  }
 else {
    List<Var> used=Var.varListUnion(req.in,req.out);
    WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + inst.shortOpName(),Collections.<Var>emptyList(),used,Collections.<Var>emptyList(),inst.getPriority(),WaitMode.TASK_DISPATCH,false,req.mode);
    insertContext=wait.getBlock();
    block.addContinuation(wait);
    insertPoint=insertContext.instructionIterator();
  }
  List<Instruction> alt=new ArrayList<Instruction>();
  List<Arg> inVals=new ArrayList<Arg>(req.in.size());
  HashMap<String,Arg> alreadyFetched=new HashMap<String,Arg>();
  for (  Var v : req.in) {
    Arg maybeVal;
    if (alreadyFetched.containsKey(v.name())) {
      maybeVal=alreadyFetched.get(v.name());
    }
 else {
      maybeVal=cv.findRetrieveResult(v);
    }
    if (maybeVal != null) {
      inVals.add(maybeVal);
      alreadyFetched.put(v.name(),maybeVal);
    }
 else {
      Var fetchedV=OptUtil.fetchValueOf(insertContext,alt,v);
      Arg fetched=Arg.createVar(fetchedV);
      inVals.add(fetched);
      alreadyFetched.put(v.name(),fetched);
    }
  }
  List<Var> outValVars=OptUtil.declareLocalOpOutputVars(insertContext,req.out);
  MakeImmChange change=inst.makeImmediate(outValVars,inVals);
  OptUtil.fixupImmChange(insertContext,change,alt,outValVars,req.out);
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
  }
  insts.remove();
  for (  Instruction newInst : alt) {
    insertPoint.add(newInst);
  }
  if (inst == insertPoint) {
    ICUtil.rewindIterator(insts,alt.size());
  }
 else {
    insts.previous();
  }
  return true;
}",0.9959042897176116
133141,"private void doInlining(Logger logger,Program prog,Function contextFunction,Block block,MultiMap<String,String> inlineLocations,Map<String,Function> toInline){
  for (  Continuation c : block.getContinuations()) {
    for (    Block cb : c.getBlocks()) {
      doInlining(logger,prog,contextFunction,cb,inlineLocations,toInline);
    }
  }
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (isFunctionCall(inst)) {
      FunctionCall fcall=(FunctionCall)inst;
      if (toInline.containsKey(fcall.getFunctionName())) {
        if (fcall.getPriority() != null)         continue;
        List<String> inlineCallers=inlineLocations.get(fcall.getFunctionName());
        if (inlineCallers.contains(contextFunction.getName())) {
          inlineCall(logger,prog,contextFunction,block,it,fcall,toInline.get(fcall.getFunctionName()));
        }
      }
    }
  }
}","private void doInlining(Logger logger,Program prog,Function contextFunction,Block block,MultiMap<String,String> inlineLocations,Map<String,Function> toInline){
  for (  Continuation c : block.getContinuations()) {
    for (    Block cb : c.getBlocks()) {
      doInlining(logger,prog,contextFunction,cb,inlineLocations,toInline);
    }
  }
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (isFunctionCall(inst)) {
      FunctionCall fcall=(FunctionCall)inst;
      if (toInline.containsKey(fcall.getFunctionName())) {
        List<String> inlineCallers=inlineLocations.get(fcall.getFunctionName());
        if (inlineCallers.contains(contextFunction.getName())) {
          inlineCall(logger,prog,contextFunction,block,it,fcall,toInline.get(fcall.getFunctionName()));
        }
      }
    }
  }
}",0.9672767609539656
133142,"/** 
 * Convert dataflow f() to local f_l() with wait around it
 * @param logger
 * @param block
 * @return
 */
private static boolean explodeFuncCalls(Logger logger,Function fn,ExecContext execCx,Block block){
  boolean changed=false;
  Set<String> empty=Collections.emptySet();
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction i=it.next();
    MakeImmRequest req=i.canMakeImmediate(empty,true);
    if (req != null && req.in.size() > 0) {
      List<Var> waitVars=ICUtil.filterBlockingOnly(req.in);
      WaitMode waitMode;
      if (req.mode == TaskMode.SYNC || req.mode == TaskMode.LOCAL || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
        waitMode=WaitMode.DATA_ONLY;
      }
 else {
        waitMode=WaitMode.TASK_DISPATCH;
      }
      List<Var> outWriteRefcounted=RefCounting.filterWriteRefcount(req.out == null ? Collections.<Var>emptyList() : req.out);
      WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + i.shortOpName(),waitVars,req.in,outWriteRefcounted,waitMode,true,req.mode);
      block.addContinuation(wait);
      List<Instruction> instBuffer=new ArrayList<Instruction>();
      List<Arg> inVals=OptUtil.fetchValuesOf(wait.getBlock(),instBuffer,req.in);
      List<Var> localOutputs=OptUtil.declareLocalOpOutputVars(wait.getBlock(),req.out);
      MakeImmChange change=i.makeImmediate(localOutputs,inVals);
      OptUtil.fixupImmChange(wait.getBlock(),change,instBuffer,localOutputs,req.out);
      it.remove();
      wait.getBlock().addInstructions(instBuffer);
      changed=true;
    }
  }
  return changed;
}","/** 
 * Convert dataflow f() to local f_l() with wait around it
 * @param logger
 * @param block
 * @return
 */
private static boolean explodeFuncCalls(Logger logger,Function fn,ExecContext execCx,Block block){
  boolean changed=false;
  Set<String> empty=Collections.emptySet();
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction i=it.next();
    MakeImmRequest req=i.canMakeImmediate(empty,true);
    if (req != null && req.in.size() > 0) {
      List<Var> waitVars=ICUtil.filterBlockingOnly(req.in);
      WaitMode waitMode;
      if (req.mode == TaskMode.SYNC || req.mode == TaskMode.LOCAL || (req.mode == TaskMode.LOCAL_CONTROL && execCx == ExecContext.CONTROL)) {
        waitMode=WaitMode.DATA_ONLY;
      }
 else {
        waitMode=WaitMode.TASK_DISPATCH;
      }
      List<Var> outWriteRefcounted=RefCounting.filterWriteRefcount(req.out == null ? Collections.<Var>emptyList() : req.out);
      WaitStatement wait=new WaitStatement(fn.getName() + ""String_Node_Str"" + i.shortOpName(),waitVars,req.in,outWriteRefcounted,i.getPriority(),waitMode,true,req.mode);
      block.addContinuation(wait);
      List<Instruction> instBuffer=new ArrayList<Instruction>();
      List<Arg> inVals=OptUtil.fetchValuesOf(wait.getBlock(),instBuffer,req.in);
      List<Var> localOutputs=OptUtil.declareLocalOpOutputVars(wait.getBlock(),req.out);
      MakeImmChange change=i.makeImmediate(localOutputs,inVals);
      OptUtil.fixupImmChange(wait.getBlock(),change,instBuffer,localOutputs,req.out);
      it.remove();
      wait.getBlock().addInstructions(instBuffer);
      changed=true;
    }
  }
  return changed;
}",0.9951485748938752
133143,"private static boolean mergeWaits(Logger logger,Function fn,Block block){
  boolean changed=false;
  boolean fin;
  do {
    fin=true;
    MultiMap<String,WaitStatement> waitMap=buildWaitMap(block);
    String winner=mostSharedVar(waitMap);
    if (winner != null) {
      fin=false;
      changed=true;
      List<WaitStatement> waits=waitMap.get(winner);
      assert(waits != null && waits.size() >= 2);
      boolean explicit=false;
      boolean allRecursive=true;
      Set<String> intersection=null;
      for (      WaitStatement wait : waits) {
        Set<String> nameSet=Var.nameSet(wait.getWaitVars());
        if (intersection == null) {
          intersection=nameSet;
        }
 else {
          intersection.retainAll(nameSet);
        }
        explicit=explicit || wait.getMode() != WaitMode.DATA_ONLY;
        allRecursive=allRecursive && wait.isRecursive();
      }
      assert(intersection != null && !intersection.isEmpty());
      List<Var> intersectionVs=ICUtil.getVarsByName(intersection,waits.get(0).getWaitVars());
      WaitStatement newWait=new WaitStatement(fn.getName() + ""String_Node_Str"",intersectionVs,new ArrayList<Var>(0),new ArrayList<Var>(0),explicit ? WaitMode.EXPLICIT : WaitMode.DATA_ONLY,allRecursive,TaskMode.LOCAL);
      ArrayList<Var> usedVars=new ArrayList<Var>();
      ArrayList<Var> keepOpen=new ArrayList<Var>();
      for (      WaitStatement wait : waits) {
        if (allRecursive) {
          wait.tryInline(Collections.<String>emptySet(),intersection);
        }
 else {
          wait.tryInline(intersection,Collections.<String>emptySet());
        }
        if (wait.getWaitVars().isEmpty() && wait.getMode() != WaitMode.TASK_DISPATCH) {
          newWait.getBlock().insertInline(wait.getBlock());
        }
 else {
          wait.setParent(newWait.getBlock());
          newWait.getBlock().addContinuation(wait);
        }
        keepOpen.addAll(wait.getKeepOpenVars());
        usedVars.addAll(wait.getPassedInVars());
      }
      ICUtil.removeDuplicates(keepOpen);
      for (      Var v : keepOpen) {
        newWait.addKeepOpenVar(v);
      }
      ICUtil.removeDuplicates(usedVars);
      newWait.addPassedInVars(usedVars);
      block.addContinuation(newWait);
      block.removeContinuations(waits);
    }
    changed=changed || !fin;
  }
 while (!fin);
  return changed;
}","private static boolean mergeWaits(Logger logger,Function fn,Block block){
  boolean changed=false;
  boolean fin;
  do {
    fin=true;
    MultiMap<String,WaitStatement> waitMap=buildWaitMap(block);
    String winner=mostSharedVar(waitMap);
    if (winner != null) {
      fin=false;
      changed=true;
      List<WaitStatement> waits=waitMap.get(winner);
      assert(waits != null && waits.size() >= 2);
      boolean explicit=false;
      boolean allRecursive=true;
      Set<String> intersection=null;
      for (      WaitStatement wait : waits) {
        Set<String> nameSet=Var.nameSet(wait.getWaitVars());
        if (intersection == null) {
          intersection=nameSet;
        }
 else {
          intersection.retainAll(nameSet);
        }
        explicit=explicit || wait.getMode() != WaitMode.DATA_ONLY;
        allRecursive=allRecursive && wait.isRecursive();
      }
      assert(intersection != null && !intersection.isEmpty());
      List<Var> intersectionVs=ICUtil.getVarsByName(intersection,waits.get(0).getWaitVars());
      WaitStatement newWait=new WaitStatement(fn.getName() + ""String_Node_Str"",intersectionVs,new ArrayList<Var>(0),new ArrayList<Var>(0),null,explicit ? WaitMode.EXPLICIT : WaitMode.DATA_ONLY,allRecursive,TaskMode.LOCAL);
      ArrayList<Var> usedVars=new ArrayList<Var>();
      ArrayList<Var> keepOpen=new ArrayList<Var>();
      for (      WaitStatement wait : waits) {
        if (allRecursive) {
          wait.tryInline(Collections.<String>emptySet(),intersection);
        }
 else {
          wait.tryInline(intersection,Collections.<String>emptySet());
        }
        if (wait.getWaitVars().isEmpty() && wait.getMode() != WaitMode.TASK_DISPATCH) {
          newWait.getBlock().insertInline(wait.getBlock());
        }
 else {
          wait.setParent(newWait.getBlock());
          newWait.getBlock().addContinuation(wait);
        }
        keepOpen.addAll(wait.getKeepOpenVars());
        usedVars.addAll(wait.getPassedInVars());
      }
      ICUtil.removeDuplicates(keepOpen);
      for (      Var v : keepOpen) {
        newWait.addKeepOpenVar(v);
      }
      ICUtil.removeDuplicates(usedVars);
      newWait.addPassedInVars(usedVars);
      block.addContinuation(newWait);
      block.removeContinuations(waits);
    }
    changed=changed || !fin;
  }
 while (!fin);
  return changed;
}",0.998934583422118
133144,"@Override public Collection<Var> requiredVars(){
  ArrayList<Var> res=new ArrayList<Var>();
  if (mode == WaitMode.EXPLICIT || mode == WaitMode.TASK_DISPATCH) {
    for (    Var v : waitVars) {
      res.add(v);
    }
  }
  return res;
}","@Override public Collection<Var> requiredVars(){
  ArrayList<Var> res=new ArrayList<Var>();
  if (mode == WaitMode.EXPLICIT || mode == WaitMode.TASK_DISPATCH) {
    for (    Var v : waitVars) {
      res.add(v);
    }
  }
  if (priority != null && priority.isVar()) {
    res.add(priority.getVar());
  }
  return res;
}",0.841726618705036
133145,"@Override public void generate(Logger logger,CompilerBackend gen,GenInfo info) throws UndefinedTypeException {
  gen.startWaitStatement(procName,waitVars,passedInVars,keepOpenVars,mode,recursive,target);
  this.block.generate(logger,gen,info);
  gen.endWaitStatement(passedInVars,keepOpenVars);
}","@Override public void generate(Logger logger,CompilerBackend gen,GenInfo info) throws UndefinedTypeException {
  gen.startWaitStatement(procName,waitVars,passedInVars,keepOpenVars,priority,mode,recursive,target);
  this.block.generate(logger,gen,info);
  gen.endWaitStatement(passedInVars,keepOpenVars);
}",0.9850249584026622
133146,"@Override public void replaceConstructVars_(Map<String,Arg> renames,boolean inputsOnly){
  ICUtil.replaceVarsInList(renames,waitVars,true);
}","@Override public void replaceConstructVars_(Map<String,Arg> renames,boolean inputsOnly){
  ICUtil.replaceVarsInList(renames,waitVars,true);
  priority=ICUtil.replaceOparg(renames,priority,true);
}",0.8367952522255193
133147,"private WaitStatement(String procName,Block block,List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars,WaitMode mode,boolean recursive,TaskMode target){
  super(usedVars,keepOpenVars);
  assert(waitVars != null);
  assert(usedVars != null);
  assert(keepOpenVars != null);
  assert(target != null);
  assert(mode != null);
  this.procName=procName;
  this.block=block;
  this.block.setParent(this);
  this.waitVars=new ArrayList<Var>(waitVars);
  ICUtil.removeDuplicates(this.waitVars);
  this.mode=mode;
  this.recursive=recursive;
  this.target=target;
}","private WaitStatement(String procName,Block block,List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars,Arg priority,WaitMode mode,boolean recursive,TaskMode target){
  super(usedVars,keepOpenVars);
  assert(waitVars != null);
  assert(usedVars != null);
  assert(keepOpenVars != null);
  assert(target != null);
  assert(mode != null);
  this.procName=procName;
  this.block=block;
  this.block.setParent(this);
  this.waitVars=new ArrayList<Var>(waitVars);
  ICUtil.removeDuplicates(this.waitVars);
  this.priority=priority;
  this.mode=mode;
  this.recursive=recursive;
  this.target=target;
}",0.9665809768637532
133148,"@Override public void prettyPrint(StringBuilder sb,String currentIndent){
  String newIndent=currentIndent + indent;
  sb.append(currentIndent + ""String_Node_Str"");
  ICUtil.prettyPrintVarList(sb,waitVars);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + procName + ""String_Node_Str"");
  ICUtil.prettyPrintVarInfo(sb,passedInVars,keepOpenVars);
  sb.append(""String_Node_Str"" + mode + ""String_Node_Str""+ target+ ""String_Node_Str""+ (recursive ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  block.prettyPrint(sb,newIndent);
  sb.append(currentIndent + ""String_Node_Str"");
}","@Override public void prettyPrint(StringBuilder sb,String currentIndent){
  String newIndent=currentIndent + indent;
  sb.append(currentIndent + ""String_Node_Str"");
  ICUtil.prettyPrintVarList(sb,waitVars);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + procName + ""String_Node_Str"");
  ICUtil.prettyPrintVarInfo(sb,passedInVars,keepOpenVars);
  sb.append(""String_Node_Str"" + mode + ""String_Node_Str""+ target+ ""String_Node_Str""+ (recursive ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  if (priority != null) {
    sb.append(""String_Node_Str"" + priority);
  }
  sb.append(""String_Node_Str"");
  block.prettyPrint(sb,newIndent);
  sb.append(currentIndent + ""String_Node_Str"");
}",0.9442379182156134
133149,"@Override public WaitStatement clone(){
  return new WaitStatement(procName,this.block.clone(),waitVars,passedInVars,keepOpenVars,mode,recursive,target);
}","@Override public WaitStatement clone(){
  return new WaitStatement(procName,this.block.clone(),waitVars,passedInVars,keepOpenVars,priority,mode,recursive,target);
}",0.9717868338557992
133150,"public Arg getPriority(){
  return priority;
}","@Override public Arg getPriority(){
  return priority;
}",0.9019607843137256
133151,"@Override public void startWaitStatement(String procName,List<Var> waitVars,List<Var> usedVariables,List<Var> keepOpenVars,WaitMode mode,boolean recursive,TaskMode target){
  logger.trace(""String_Node_Str"");
  startAsync(procName,waitVars,usedVariables,keepOpenVars,false);
}","@Override public void startWaitStatement(String procName,List<Var> waitVars,List<Var> usedVariables,List<Var> keepOpenVars,Arg priority,WaitMode mode,boolean recursive,TaskMode target){
  logger.trace(""String_Node_Str"");
  startAsync(procName,waitVars,usedVariables,keepOpenVars,false);
}",0.9769094138543516
133152,"public abstract void endWaitStatement(List<Var> usedVars,List<Var> keepOpenVars);","public abstract void endWaitStatement(List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars);",0.8950276243093923
133153,"/** 
 * Handle the special case of a foreach loop where we are looping over range specified by two or three integer parameters
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachRange(Context context,ForeachLoop loop) throws UserException {
  ArrayRange range=ArrayRange.fromAST(context,loop.getArrayVarTree());
  range.typeCheck(context);
  Var start=exprWalker.eval(context,range.getStart(),Types.F_INT,false,null);
  Var end=exprWalker.eval(context,range.getEnd(),Types.F_INT,false,null);
  Var step;
  if (range.getStep() != null) {
    step=exprWalker.eval(context,range.getStep(),Types.F_INT,false,null);
  }
 else {
    step=varCreator.createTmp(context,Types.F_INT);
    backend.assignInt(step,Arg.createIntLit(1));
  }
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  ArrayList<Var> waitUsedVariables=new ArrayList<Var>(usedVariables);
  waitUsedVariables.addAll(Arrays.asList(start,end,step));
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(start,end,step),waitUsedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var startVal=varCreator.fetchValueOf(waitContext,start);
  Var endVal=varCreator.fetchValueOf(waitContext,end);
  Var stepVal=varCreator.fetchValueOf(waitContext,step);
  Context bodyContext=loop.setupLoopBodyContext(waitContext);
  Var memberVal=varCreator.createValueOfVar(bodyContext,loop.getMemberVar(),false);
  Var counterVal=loop.getLoopCountVal();
  backend.startRangeLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,memberVal,counterVal,Arg.createVar(startVal),Arg.createVar(endVal),Arg.createVar(stepVal),usedVariables,keepOpenVars,loop.getDesiredUnroll(),loop.getSplitDegree());
  List<Var> waitUsedVars=null;
  if (!loop.isSyncLoop()) {
    waitUsedVars=new ArrayList<Var>(usedVariables);
    waitUsedVars.add(memberVal);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),waitUsedVars,keepOpenVars,null,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  varCreator.initialiseVariable(bodyContext,loop.getMemberVar());
  backend.assignInt(loop.getMemberVar(),Arg.createVar(memberVal));
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(bodyContext,Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(counterVal));
  }
  block(bodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(waitUsedVars,keepOpenVars);
  }
  backend.endRangeLoop(usedVariables,keepOpenVars,loop.getSplitDegree());
  backend.endWaitStatement(usedVariables,keepOpenVars);
}","/** 
 * Handle the special case of a foreach loop where we are looping over range specified by two or three integer parameters
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachRange(Context context,ForeachLoop loop) throws UserException {
  ArrayRange range=ArrayRange.fromAST(context,loop.getArrayVarTree());
  range.typeCheck(context);
  Var start=exprWalker.eval(context,range.getStart(),Types.F_INT,false,null);
  Var end=exprWalker.eval(context,range.getEnd(),Types.F_INT,false,null);
  Var step;
  if (range.getStep() != null) {
    step=exprWalker.eval(context,range.getStep(),Types.F_INT,false,null);
  }
 else {
    step=varCreator.createTmp(context,Types.F_INT);
    backend.assignInt(step,Arg.createIntLit(1));
  }
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  ArrayList<Var> waitUsedVariables=new ArrayList<Var>(usedVariables);
  List<Var> rangeBounds=Arrays.asList(start,end,step);
  waitUsedVariables.addAll(rangeBounds);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,rangeBounds,waitUsedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var startVal=varCreator.fetchValueOf(waitContext,start);
  Var endVal=varCreator.fetchValueOf(waitContext,end);
  Var stepVal=varCreator.fetchValueOf(waitContext,step);
  Context bodyContext=loop.setupLoopBodyContext(waitContext);
  Var memberVal=varCreator.createValueOfVar(bodyContext,loop.getMemberVar(),false);
  Var counterVal=loop.getLoopCountVal();
  backend.startRangeLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,memberVal,counterVal,Arg.createVar(startVal),Arg.createVar(endVal),Arg.createVar(stepVal),usedVariables,keepOpenVars,loop.getDesiredUnroll(),loop.getSplitDegree());
  List<Var> waitUsedVars=null;
  if (!loop.isSyncLoop()) {
    waitUsedVars=new ArrayList<Var>(usedVariables);
    waitUsedVars.add(memberVal);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.<Var>asList(),waitUsedVars,keepOpenVars,null,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  varCreator.initialiseVariable(bodyContext,loop.getMemberVar());
  backend.assignInt(loop.getMemberVar(),Arg.createVar(memberVal));
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(bodyContext,Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(counterVal));
  }
  block(bodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(Arrays.<Var>asList(),waitUsedVars,keepOpenVars);
  }
  backend.endRangeLoop(usedVariables,keepOpenVars,loop.getSplitDegree());
  backend.endWaitStatement(rangeBounds,usedVariables,keepOpenVars);
}",0.969609724888036
133154,"private void waitStmt(Context context,SwiftAST tree) throws UserException {
  Wait wait=Wait.fromAST(context,tree);
  ArrayList<Var> waitEvaled=new ArrayList<Var>();
  for (  SwiftAST expr : wait.getWaitExprs()) {
    Var res=exprWalker.eval(context,expr,TypeChecker.findSingleExprType(context,expr),false,null);
    waitEvaled.add(res);
  }
  ArrayList<Var> usedVars=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  summariseBranchVariableUsage(context,Arrays.asList(wait.getBlock().getVariableUsage()),usedVars,keepOpenVars);
  HashSet<String> waitVarSet=new HashSet<String>(Var.nameList(waitEvaled));
  waitVarSet.retainAll(Var.nameList(keepOpenVars));
  if (waitVarSet.size() > 0) {
    throw new UserException(context,""String_Node_Str"" + ""String_Node_Str"" + waitVarSet.toString());
  }
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),waitEvaled,usedVars,keepOpenVars,null,WaitMode.EXPLICIT,false,TaskMode.LOCAL_CONTROL);
  block(new LocalContext(context),wait.getBlock());
  backend.endWaitStatement(usedVars,keepOpenVars);
}","private void waitStmt(Context context,SwiftAST tree) throws UserException {
  Wait wait=Wait.fromAST(context,tree);
  ArrayList<Var> waitEvaled=new ArrayList<Var>();
  for (  SwiftAST expr : wait.getWaitExprs()) {
    Var res=exprWalker.eval(context,expr,TypeChecker.findSingleExprType(context,expr),false,null);
    waitEvaled.add(res);
  }
  ArrayList<Var> usedVars=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  summariseBranchVariableUsage(context,Arrays.asList(wait.getBlock().getVariableUsage()),usedVars,keepOpenVars);
  HashSet<String> waitVarSet=new HashSet<String>(Var.nameList(waitEvaled));
  waitVarSet.retainAll(Var.nameList(keepOpenVars));
  if (waitVarSet.size() > 0) {
    throw new UserException(context,""String_Node_Str"" + ""String_Node_Str"" + waitVarSet.toString());
  }
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),waitEvaled,usedVars,keepOpenVars,null,WaitMode.EXPLICIT,false,TaskMode.LOCAL_CONTROL);
  block(new LocalContext(context),wait.getBlock());
  backend.endWaitStatement(waitEvaled,usedVars,keepOpenVars);
}",0.9950248756218906
133155,"/** 
 * @param context local context for app function
 * @param cmd AST for app function command
 * @param outputs output arguments for app
 * @param hasSideEffects
 * @param deterministic
 * @throws UserException
 */
private void genAppFunctionBody(Context context,SwiftAST appBody,List<Var> outputs,boolean hasSideEffects,boolean deterministic) throws UserException {
  assert(appBody.getType() == ExMParser.APP_BODY);
  assert(appBody.getChildCount() >= 1);
  SwiftAST cmd=appBody.child(0);
  assert(cmd.getType() == ExMParser.COMMAND);
  assert(cmd.getChildCount() >= 1);
  SwiftAST appNameT=cmd.child(0);
  assert(appNameT.getType() == ExMParser.STRING);
  String appName=Literals.extractLiteralString(context,appNameT);
  List<Var> args=evalAppCmdArgs(context,cmd);
  Redirects<Var> redirFutures=processAppRedirects(context,appBody.children(1));
  checkAppOutputs(context,appName,outputs,args,redirFutures);
  Pair<Map<String,Var>,List<Var>> wait=selectAppWaitVars(context,args,redirFutures);
  Map<String,Var> fileNames=wait.val1;
  List<Var> waitVars=wait.val2;
  List<Var> passIn=new ArrayList<Var>();
  passIn.addAll(fileNames.values());
  passIn.addAll(args);
  String waitName=context.getFunctionContext().constructName(""String_Node_Str"");
  backend.startWaitStatement(waitName,waitVars,passIn,Collections.<Var>emptyList(),null,WaitMode.TASK_DISPATCH,true,TaskMode.LEAF);
  Pair<List<Arg>,Redirects<Arg>> retrieved=retrieveAppArgs(context,args,redirFutures,fileNames);
  List<Arg> localArgs=retrieved.val1;
  Redirects<Arg> localRedirects=retrieved.val2;
  backend.runExternal(appName,localArgs,outputs,localRedirects,hasSideEffects,deterministic);
  backend.endWaitStatement(passIn,Arrays.<Var>asList());
}","/** 
 * @param context local context for app function
 * @param cmd AST for app function command
 * @param outputs output arguments for app
 * @param hasSideEffects
 * @param deterministic
 * @throws UserException
 */
private void genAppFunctionBody(Context context,SwiftAST appBody,List<Var> outputs,boolean hasSideEffects,boolean deterministic) throws UserException {
  assert(appBody.getType() == ExMParser.APP_BODY);
  assert(appBody.getChildCount() >= 1);
  SwiftAST cmd=appBody.child(0);
  assert(cmd.getType() == ExMParser.COMMAND);
  assert(cmd.getChildCount() >= 1);
  SwiftAST appNameT=cmd.child(0);
  assert(appNameT.getType() == ExMParser.STRING);
  String appName=Literals.extractLiteralString(context,appNameT);
  List<Var> args=evalAppCmdArgs(context,cmd);
  Redirects<Var> redirFutures=processAppRedirects(context,appBody.children(1));
  checkAppOutputs(context,appName,outputs,args,redirFutures);
  Pair<Map<String,Var>,List<Var>> wait=selectAppWaitVars(context,args,redirFutures);
  Map<String,Var> fileNames=wait.val1;
  List<Var> waitVars=wait.val2;
  List<Var> passIn=new ArrayList<Var>();
  passIn.addAll(fileNames.values());
  passIn.addAll(args);
  String waitName=context.getFunctionContext().constructName(""String_Node_Str"");
  backend.startWaitStatement(waitName,waitVars,passIn,Collections.<Var>emptyList(),null,WaitMode.TASK_DISPATCH,true,TaskMode.LEAF);
  Pair<List<Arg>,Redirects<Arg>> retrieved=retrieveAppArgs(context,args,redirFutures,fileNames);
  List<Arg> localArgs=retrieved.val1;
  Redirects<Arg> localRedirects=retrieved.val2;
  backend.runExternal(appName,localArgs,outputs,localRedirects,hasSideEffects,deterministic);
  backend.endWaitStatement(waitVars,passIn,Arrays.<Var>asList());
}",0.9973890339425588
133156,"private void switchStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  Switch sw=Switch.fromAST(context,tree);
  sw.typeCheck(context);
  Var switchVar=exprWalker.eval(context,sw.getSwitchExpr(),Types.F_INT,true,null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  List<VariableUsageInfo> branchVUs=new ArrayList<VariableUsageInfo>();
  for (  SwiftAST b : sw.getCaseBodies()) {
    branchVUs.add(b.checkedGetVariableUsage());
  }
  checkConditionalDeadlock(context,switchVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(switchVar))   usedVariables.add(switchVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(switchVar),usedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var switchVal=varCreator.createValueOfVar(waitContext,switchVar);
  backend.retrieveInt(switchVal,switchVar);
  LogHelper.trace(context,""String_Node_Str"" + sw.getCaseBodies().size() + ""String_Node_Str"");
  backend.startSwitch(Arg.createVar(switchVal),sw.getCaseLabels(),sw.hasDefault());
  for (  SwiftAST caseBody : sw.getCaseBodies()) {
    block(new LocalContext(waitContext),caseBody);
    backend.endCase();
  }
  backend.endSwitch();
  backend.endWaitStatement(usedVariables,keepOpenVars);
}","private void switchStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  Switch sw=Switch.fromAST(context,tree);
  sw.typeCheck(context);
  Var switchVar=exprWalker.eval(context,sw.getSwitchExpr(),Types.F_INT,true,null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  List<VariableUsageInfo> branchVUs=new ArrayList<VariableUsageInfo>();
  for (  SwiftAST b : sw.getCaseBodies()) {
    branchVUs.add(b.checkedGetVariableUsage());
  }
  checkConditionalDeadlock(context,switchVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(switchVar))   usedVariables.add(switchVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(switchVar),usedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var switchVal=varCreator.createValueOfVar(waitContext,switchVar);
  backend.retrieveInt(switchVal,switchVar);
  LogHelper.trace(context,""String_Node_Str"" + sw.getCaseBodies().size() + ""String_Node_Str"");
  backend.startSwitch(Arg.createVar(switchVal),sw.getCaseLabels(),sw.hasDefault());
  for (  SwiftAST caseBody : sw.getCaseBodies()) {
    block(new LocalContext(waitContext),caseBody);
    backend.endCase();
  }
  backend.endSwitch();
  backend.endWaitStatement(Arrays.asList(switchVar),usedVariables,keepOpenVars);
}",0.9918540241120888
133157,"private void ifStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  If ifStmt=If.fromAST(context,tree);
  Var conditionVar=exprWalker.eval(context,ifStmt.getCondition(),ifStmt.getCondType(context),false,null);
  assert(conditionVar != null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo thenVU=ifStmt.getThenBlock().checkedGetVariableUsage();
  List<VariableUsageInfo> branchVUs;
  if (ifStmt.hasElse()) {
    VariableUsageInfo elseVU=ifStmt.getElseBlock().checkedGetVariableUsage();
    branchVUs=Arrays.asList(thenVU,elseVU);
  }
 else {
    branchVUs=Arrays.asList(thenVU);
  }
  checkConditionalDeadlock(context,conditionVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(conditionVar))   usedVariables.add(conditionVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(conditionVar),usedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var condVal=varCreator.fetchValueOf(waitContext,conditionVar);
  backend.startIfStatement(Arg.createVar(condVal),ifStmt.hasElse());
  block(new LocalContext(waitContext),ifStmt.getThenBlock());
  if (ifStmt.hasElse()) {
    backend.startElseBlock();
    block(new LocalContext(waitContext),ifStmt.getElseBlock());
  }
  backend.endIfStatement();
  backend.endWaitStatement(usedVariables,keepOpenVars);
}","private void ifStatement(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  If ifStmt=If.fromAST(context,tree);
  Var conditionVar=exprWalker.eval(context,ifStmt.getCondition(),ifStmt.getCondType(context),false,null);
  assert(conditionVar != null);
  List<Var> usedVariables=new ArrayList<Var>();
  List<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo thenVU=ifStmt.getThenBlock().checkedGetVariableUsage();
  List<VariableUsageInfo> branchVUs;
  if (ifStmt.hasElse()) {
    VariableUsageInfo elseVU=ifStmt.getElseBlock().checkedGetVariableUsage();
    branchVUs=Arrays.asList(thenVU,elseVU);
  }
 else {
    branchVUs=Arrays.asList(thenVU);
  }
  checkConditionalDeadlock(context,conditionVar,branchVUs);
  summariseBranchVariableUsage(context,branchVUs,usedVariables,keepOpenVars);
  if (!usedVariables.contains(conditionVar))   usedVariables.add(conditionVar);
  FunctionContext fc=context.getFunctionContext();
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(conditionVar),usedVariables,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  Context waitContext=new LocalContext(context);
  Var condVal=varCreator.fetchValueOf(waitContext,conditionVar);
  backend.startIfStatement(Arg.createVar(condVal),ifStmt.hasElse());
  block(new LocalContext(waitContext),ifStmt.getThenBlock());
  if (ifStmt.hasElse()) {
    backend.startElseBlock();
    block(new LocalContext(waitContext),ifStmt.getElseBlock());
  }
  backend.endIfStatement();
  backend.endWaitStatement(Arrays.asList(conditionVar),usedVariables,keepOpenVars);
}",0.9913686806411838
133158,"/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(realArray),waitUsedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),iterUsedVars,keepOpenVars,null,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  Set<Var> noRefcount=Collections.singleton(loop.getMemberVar());
  block(loopBodyContext,loop.getBody(),noRefcount);
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(arrRefWaitUsedVars,keepOpenVars);
  }
}","/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(realArray),waitUsedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.<Var>asList(),iterUsedVars,keepOpenVars,null,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  Set<Var> noRefcount=Collections.singleton(loop.getMemberVar());
  block(loopBodyContext,loop.getBody(),noRefcount);
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(Arrays.<Var>asList(),iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(Arrays.asList(realArray),waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars);
  }
}",0.986264556584055
133159,"/** 
 * Dereference src into dst ie. dst = *src
 * @param dst
 * @param src
 * @throws UserException 
 * @throws UndefinedTypeException 
 */
public void dereference(Context context,Var dst,Var src) throws UndefinedTypeException, UserException {
  assert(Types.isRef(src.type()));
  assert(Types.isRefTo(src.type(),dst.type()));
  if (Types.isScalarFuture(dst.type())) {
    Type dstType=dst.type();
    if (dstType.equals(Types.F_INT)) {
      backend.dereferenceInt(dst,src);
    }
 else     if (dstType.equals(Types.F_STRING)) {
      backend.dereferenceString(dst,src);
    }
 else     if (dstType.equals(Types.F_FLOAT)) {
      backend.dereferenceFloat(dst,src);
    }
 else     if (dstType.equals(Types.F_BOOL)) {
      backend.dereferenceBool(dst,src);
    }
 else     if (dstType.equals(Types.F_FILE)) {
      backend.dereferenceFile(dst,src);
    }
 else {
      throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + src.type().toString());
    }
  }
 else   if (Types.isArray(dst.type())) {
    String wName=context.getFunctionContext().constructName(""String_Node_Str"");
    List<Var> keepOpenVars=Arrays.asList(dst);
    List<Var> usedVars=Arrays.asList(src,dst);
    backend.startWaitStatement(wName,Arrays.asList(src),usedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
    Var derefed=varCreator.createTmpAlias(context,dst.type());
    backend.retrieveRef(derefed,src);
    copyArrayByValue(context,dst,derefed);
    backend.endWaitStatement(usedVars,keepOpenVars);
  }
 else   if (Types.isStruct(dst.type())) {
    dereferenceStruct(context,dst,src);
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + src.type());
  }
}","/** 
 * Dereference src into dst ie. dst = *src
 * @param dst
 * @param src
 * @throws UserException 
 * @throws UndefinedTypeException 
 */
public void dereference(Context context,Var dst,Var src) throws UndefinedTypeException, UserException {
  assert(Types.isRef(src.type()));
  assert(Types.isRefTo(src.type(),dst.type()));
  if (Types.isScalarFuture(dst.type())) {
    Type dstType=dst.type();
    if (dstType.equals(Types.F_INT)) {
      backend.dereferenceInt(dst,src);
    }
 else     if (dstType.equals(Types.F_STRING)) {
      backend.dereferenceString(dst,src);
    }
 else     if (dstType.equals(Types.F_FLOAT)) {
      backend.dereferenceFloat(dst,src);
    }
 else     if (dstType.equals(Types.F_BOOL)) {
      backend.dereferenceBool(dst,src);
    }
 else     if (dstType.equals(Types.F_FILE)) {
      backend.dereferenceFile(dst,src);
    }
 else {
      throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + src.type().toString());
    }
  }
 else   if (Types.isArray(dst.type())) {
    String wName=context.getFunctionContext().constructName(""String_Node_Str"");
    List<Var> keepOpenVars=Arrays.asList(dst);
    List<Var> usedVars=Arrays.asList(src,dst);
    List<Var> waitVars=Arrays.asList(src);
    backend.startWaitStatement(wName,waitVars,usedVars,keepOpenVars,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
    Var derefed=varCreator.createTmpAlias(context,dst.type());
    backend.retrieveRef(derefed,src);
    copyArrayByValue(context,dst,derefed);
    backend.endWaitStatement(waitVars,usedVars,keepOpenVars);
  }
 else   if (Types.isStruct(dst.type())) {
    dereferenceStruct(context,dst,src);
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + src.type());
  }
}",0.976991150442478
133160,"private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType.getImplType())) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  List<Var> usedVars=null;
  List<Var> keepOpen=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    keepOpen=RefCounting.filterWriteRefcount(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,keepOpen,priorityVal == null ? null : Arg.createVar(priorityVal),WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(usedVars,keepOpen);
  }
}","private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType.getImplType())) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  List<Var> usedVars=null;
  List<Var> keepOpen=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    keepOpen=RefCounting.filterWriteRefcount(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,keepOpen,priorityVal == null ? null : Arg.createVar(priorityVal),WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(waitVars,usedVars,keepOpen);
  }
}",0.998052369616966
133161,"private void copyArrayByValue(Context context,Var dst,Var src) throws UserException {
  assert(dst.type().equals(src.type()));
  assert(Types.isArray(src.type()));
  LocalContext copyContext=new LocalContext(context);
  Type t=src.type();
  Type memType=Types.getArrayMemberType(t);
  Var member=copyContext.createAliasVariable(memType);
  Var ix=copyContext.createLocalValueVariable(Types.V_INT);
  List<Var> keepOpen=Arrays.asList(dst);
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,keepOpen,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  backend.startForeachLoop(context.getFunctionContext().constructName(""String_Node_Str""),src,member,ix,-1,true,usedVars,keepOpen);
  backend.arrayInsertImm(member,dst,Arg.createVar(ix));
  backend.endForeachLoop(-1,true,usedVars,keepOpen);
  backend.endWaitStatement(usedVars,keepOpen);
}","private void copyArrayByValue(Context context,Var dst,Var src) throws UserException {
  assert(dst.type().equals(src.type()));
  assert(Types.isArray(src.type()));
  LocalContext copyContext=new LocalContext(context);
  Type t=src.type();
  Type memType=Types.getArrayMemberType(t);
  Var member=copyContext.createAliasVariable(memType);
  Var ix=copyContext.createLocalValueVariable(Types.V_INT);
  List<Var> keepOpen=Arrays.asList(dst);
  List<Var> usedVars=Arrays.asList(src,dst);
  List<Var> waitVars=Arrays.asList(src);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),waitVars,usedVars,keepOpen,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  backend.startForeachLoop(context.getFunctionContext().constructName(""String_Node_Str""),src,member,ix,-1,true,usedVars,keepOpen);
  backend.arrayInsertImm(member,dst,Arg.createVar(ix));
  backend.endForeachLoop(-1,true,usedVars,keepOpen);
  backend.endWaitStatement(waitVars,usedVars,keepOpen);
}",0.9607032057911064
133162,"/** 
 * Copy a struct reference to a struct.  We need to do this in the compiler front-end because we want to generate specialized code to walk the structure and copy all struct members
 * @param context
 * @param dst
 * @param src
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void dereferenceStruct(Context context,Var dst,Var src) throws UserException, UndefinedTypeException {
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,new ArrayList<Var>(),null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  Var rValDerefed=varCreator.createTmp(context,src.type().memberType(),false,true);
  backend.retrieveRef(rValDerefed,src);
  copyByValue(context,rValDerefed,dst,dst.type());
  backend.endWaitStatement(usedVars,new ArrayList<Var>());
}","/** 
 * Copy a struct reference to a struct.  We need to do this in the compiler front-end because we want to generate specialized code to walk the structure and copy all struct members
 * @param context
 * @param dst
 * @param src
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void dereferenceStruct(Context context,Var dst,Var src) throws UserException, UndefinedTypeException {
  List<Var> usedVars=Arrays.asList(src,dst);
  List<Var> waitVars=Arrays.asList(src);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),waitVars,usedVars,new ArrayList<Var>(),null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
  Var rValDerefed=varCreator.createTmp(context,src.type().memberType(),false,true);
  backend.retrieveRef(rValDerefed,src);
  copyByValue(context,rValDerefed,dst,dst.type());
  backend.endWaitStatement(waitVars,usedVars,new ArrayList<Var>());
}",0.9574468085106383
133163,"/** 
 * Generate code for a call to a function, where the arguments might be expressions
 * @param context
 * @param tree
 * @param oList
 * @throws UserException
 * @throws UndefinedVariableException
 * @throws UndefinedFunctionException
 */
private void callFunctionExpression(Context context,SwiftAST tree,List<Var> oList,Map<String,String> renames) throws UserException {
  FunctionCall f=FunctionCall.fromAST(context,tree,true);
  FunctionType concrete=TypeChecker.concretiseFunctionCall(context,f.function(),f.type(),f.args(),oList,false);
  try {
    if (Builtins.isAssertVariant(f.function()) && Settings.getBoolean(Settings.OPT_DISABLE_ASSERTS)) {
      return;
    }
  }
 catch (  InvalidOptionException e) {
    throw new STCRuntimeError(""String_Node_Str"" + e.toString());
  }
  ArrayList<Var> argVars=new ArrayList<Var>(f.args().size());
  for (int i=0; i < f.args().size(); i++) {
    SwiftAST argtree=f.args().get(i);
    Type expType=concrete.getInputs().get(i);
    Type exprType=TypeChecker.findSingleExprType(context,argtree);
    Type argtype=TypeChecker.checkFunArg(context,f.function(),i,expType,exprType).val2;
    argVars.add(eval(context,argtree,argtype,false,renames));
  }
  Var priorityVal=null;
  boolean openedWait=false;
  ArrayList<Var> usedVariables=null;
  List<Var> keepOpen=RefCounting.filterWriteRefcount(oList);
  Context callContext=context;
  if (tree.getChildCount() == 3) {
    SwiftAST priorityT=tree.child(2);
    Var priorityFuture=eval(context,priorityT,Types.F_INT,false,renames);
    usedVariables=new ArrayList<Var>();
    usedVariables.addAll(argVars);
    usedVariables.addAll(oList);
    backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(priorityFuture),usedVariables,keepOpen,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    openedWait=true;
    callContext=new LocalContext(context);
    priorityVal=varCreator.fetchValueOf(callContext,priorityFuture);
  }
  callFunction(context,f.function(),concrete,oList,argVars,priorityVal);
  if (openedWait) {
    backend.endWaitStatement(usedVariables,keepOpen);
  }
}","/** 
 * Generate code for a call to a function, where the arguments might be expressions
 * @param context
 * @param tree
 * @param oList
 * @throws UserException
 * @throws UndefinedVariableException
 * @throws UndefinedFunctionException
 */
private void callFunctionExpression(Context context,SwiftAST tree,List<Var> oList,Map<String,String> renames) throws UserException {
  FunctionCall f=FunctionCall.fromAST(context,tree,true);
  FunctionType concrete=TypeChecker.concretiseFunctionCall(context,f.function(),f.type(),f.args(),oList,false);
  try {
    if (Builtins.isAssertVariant(f.function()) && Settings.getBoolean(Settings.OPT_DISABLE_ASSERTS)) {
      return;
    }
  }
 catch (  InvalidOptionException e) {
    throw new STCRuntimeError(""String_Node_Str"" + e.toString());
  }
  ArrayList<Var> argVars=new ArrayList<Var>(f.args().size());
  for (int i=0; i < f.args().size(); i++) {
    SwiftAST argtree=f.args().get(i);
    Type expType=concrete.getInputs().get(i);
    Type exprType=TypeChecker.findSingleExprType(context,argtree);
    Type argtype=TypeChecker.checkFunArg(context,f.function(),i,expType,exprType).val2;
    argVars.add(eval(context,argtree,argtype,false,renames));
  }
  Var priorityVal=null;
  boolean openedWait=false;
  List<Var> waitVars=null;
  List<Var> usedVariables=null;
  List<Var> keepOpen=RefCounting.filterWriteRefcount(oList);
  Context callContext=context;
  if (tree.getChildCount() == 3) {
    SwiftAST priorityT=tree.child(2);
    Var priorityFuture=eval(context,priorityT,Types.F_INT,false,renames);
    usedVariables=new ArrayList<Var>();
    usedVariables.addAll(argVars);
    usedVariables.addAll(oList);
    waitVars=Arrays.asList(priorityFuture);
    backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),waitVars,usedVariables,keepOpen,null,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    openedWait=true;
    callContext=new LocalContext(context);
    priorityVal=varCreator.fetchValueOf(callContext,priorityFuture);
  }
  callFunction(context,f.function(),concrete,oList,argVars,priorityVal);
  if (openedWait) {
    backend.endWaitStatement(waitVars,usedVariables,keepOpen);
  }
}",0.9716542750929368
133164,"@Override public void endWaitStatement(List<Var> usedVars,List<Var> keepOpenVars){
  assert(currBlock().getType() == BlockType.WAIT_BLOCK);
  blockStack.pop();
}","@Override public void endWaitStatement(List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars){
  assert(currBlock().getType() == BlockType.WAIT_BLOCK);
  blockStack.pop();
}",0.9442815249266864
133165,"@Override public void generate(Logger logger,CompilerBackend gen,GenInfo info) throws UndefinedTypeException {
  gen.startWaitStatement(procName,waitVars,passedInVars,keepOpenVars,priority,mode,recursive,target);
  this.block.generate(logger,gen,info);
  gen.endWaitStatement(passedInVars,keepOpenVars);
}","@Override public void generate(Logger logger,CompilerBackend gen,GenInfo info) throws UndefinedTypeException {
  gen.startWaitStatement(procName,waitVars,passedInVars,keepOpenVars,priority,mode,recursive,target);
  this.block.generate(logger,gen,info);
  gen.endWaitStatement(waitVars,passedInVars,keepOpenVars);
}",0.9854604200323102
133166,"@Override public void endWaitStatement(List<Var> usedVars,List<Var> keepOpenVars){
  logger.trace(""String_Node_Str"");
  endAsync(keepOpenVars);
}","@Override public void endWaitStatement(List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars){
  logger.trace(""String_Node_Str"");
  endAsync(keepOpenVars);
}",0.9385113268608414
133167,"private void endAsync(List<Var> usedVars,List<Var> keepOpenVars){
  decrementAllRefs(usedVars,keepOpenVars);
  execContextStack.pop();
  pointStack.pop();
}","private void endAsync(List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars){
  List<Var> allUsedVars=asyncUsedVars(usedVars,waitVars);
  decrementAllRefs(allUsedVars,keepOpenVars);
  execContextStack.pop();
  pointStack.pop();
}",0.7908163265306123
133168,"/** 
 * Internal helper to implement constructs that need to wait for a number of variables, and then run some code
 * @param procName
 * @param waitVars
 * @param usedVariables
 * @param keepOpenVars
 * @param priority 
 * @param recursive 
 * @param shareWork if true, work will be shared with other rule enginesat the cost of higher overhead
 */
private void startAsync(String procName,List<Var> waitVars,List<Var> usedVariables,List<Var> keepOpenVars,Arg priority,boolean recursive,TaskMode mode){
  assert(priority == null || priority.isImmediateInt());
  mode.checkSpawn(execContextStack.peek());
  ArrayList<Var> toPassIn=new ArrayList<Var>();
  HashSet<String> alreadyInSet=new HashSet<String>();
  for (  Var v : usedVariables) {
    toPassIn.add(v);
    alreadyInSet.add(v.name());
    if (v.type().equals(Types.V_BLOB)) {
      throw new STCRuntimeError(""String_Node_Str"");
    }
  }
  for (  Var v : keepOpenVars) {
    if (!alreadyInSet.contains(v.name())) {
      toPassIn.add(v);
    }
  }
  List<String> args=new ArrayList<String>();
  args.add(Turbine.LOCAL_STACK_NAME);
  for (  Var v : toPassIn) {
    args.add(prefixVar(v.name()));
  }
  Sequence constructProc=new Sequence();
  String uniqueName=uniqueTCLFunctionName(procName);
  Proc proc=new Proc(uniqueName,usedTclFunctionNames,args,constructProc);
  tree.add(proc);
  boolean useDeepWait=false;
  List<Expression> waitFor=new ArrayList<Expression>();
  for (  Var w : waitVars) {
    if (recursive) {
      Type baseType=w.type();
      if (Types.isArray(w.type())) {
        baseType=new ArrayInfo(w.type()).baseType;
        useDeepWait=true;
      }
      if (Types.isScalarFuture(baseType)) {
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + w.type().typeName());
      }
    }
    Expression waitExpr=getTurbineWaitId(w);
    waitFor.add(waitExpr);
  }
  incrementAllRefs(usedVariables,keepOpenVars);
  setPriority(priority);
  TclList action=buildAction(uniqueName,toPassIn);
  boolean local=execContextStack.peek() == ExecContext.CONTROL;
  if (useDeepWait) {
    int depths[]=new int[waitVars.size()];
    boolean isFile[]=new boolean[waitVars.size()];
    for (int i=0; i < waitVars.size(); i++) {
      Type waitVarType=waitVars.get(i).type();
      Type baseType;
      if (Types.isArray(waitVarType)) {
        ArrayInfo ai=new ArrayInfo(waitVarType);
        depths[i]=ai.nesting;
        baseType=ai.baseType;
      }
 else {
        depths[i]=0;
        baseType=waitVarType;
      }
      isFile[i]=Types.isFile(baseType);
    }
    pointStack.peek().add(Turbine.deepRule(uniqueName,waitFor,depths,isFile,action,mode,local));
  }
 else {
    pointStack.peek().add(Turbine.rule(uniqueName,waitFor,action,mode,local));
  }
  clearPriority(priority);
  pointStack.push(constructProc);
  ExecContext newExecContext;
  if (mode == TaskMode.LEAF) {
    newExecContext=ExecContext.LEAF;
  }
 else   if (mode == TaskMode.CONTROL) {
    newExecContext=ExecContext.CONTROL;
  }
 else {
    newExecContext=execContextStack.peek();
  }
  execContextStack.push(newExecContext);
}","/** 
 * Internal helper to implement constructs that need to wait for a number of variables, and then run some code
 * @param procName
 * @param waitVars
 * @param usedVars
 * @param keepOpenVars
 * @param priority 
 * @param recursive 
 * @param shareWork if true, work will be shared with other rule enginesat the cost of higher overhead
 */
private void startAsync(String procName,List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars,Arg priority,boolean recursive,TaskMode mode){
  assert(priority == null || priority.isImmediateInt());
  mode.checkSpawn(execContextStack.peek());
  List<Var> allUsedVars=asyncUsedVars(usedVars,waitVars);
  ArrayList<Var> toPassIn=new ArrayList<Var>();
  HashSet<String> alreadyInSet=new HashSet<String>();
  for (  Var v : allUsedVars) {
    toPassIn.add(v);
    alreadyInSet.add(v.name());
    if (v.type().equals(Types.V_BLOB)) {
      throw new STCRuntimeError(""String_Node_Str"");
    }
  }
  for (  Var v : keepOpenVars) {
    if (!alreadyInSet.contains(v.name())) {
      toPassIn.add(v);
    }
  }
  List<String> args=new ArrayList<String>();
  args.add(Turbine.LOCAL_STACK_NAME);
  for (  Var v : toPassIn) {
    args.add(prefixVar(v.name()));
  }
  Sequence constructProc=new Sequence();
  String uniqueName=uniqueTCLFunctionName(procName);
  Proc proc=new Proc(uniqueName,usedTclFunctionNames,args,constructProc);
  tree.add(proc);
  boolean useDeepWait=false;
  List<Expression> waitFor=new ArrayList<Expression>();
  for (  Var w : waitVars) {
    if (recursive) {
      Type baseType=w.type();
      if (Types.isArray(w.type())) {
        baseType=new ArrayInfo(w.type()).baseType;
        useDeepWait=true;
      }
      if (Types.isScalarFuture(baseType)) {
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + w.type().typeName());
      }
    }
    Expression waitExpr=getTurbineWaitId(w);
    waitFor.add(waitExpr);
  }
  incrementAllRefs(allUsedVars,keepOpenVars);
  setPriority(priority);
  TclList action=buildAction(uniqueName,toPassIn);
  boolean local=execContextStack.peek() == ExecContext.CONTROL;
  if (useDeepWait) {
    int depths[]=new int[waitVars.size()];
    boolean isFile[]=new boolean[waitVars.size()];
    for (int i=0; i < waitVars.size(); i++) {
      Type waitVarType=waitVars.get(i).type();
      Type baseType;
      if (Types.isArray(waitVarType)) {
        ArrayInfo ai=new ArrayInfo(waitVarType);
        depths[i]=ai.nesting;
        baseType=ai.baseType;
      }
 else {
        depths[i]=0;
        baseType=waitVarType;
      }
      isFile[i]=Types.isFile(baseType);
    }
    pointStack.peek().add(Turbine.deepRule(uniqueName,waitFor,depths,isFile,action,mode,local));
  }
 else {
    pointStack.peek().add(Turbine.rule(uniqueName,waitFor,action,mode,local));
  }
  clearPriority(priority);
  pointStack.push(constructProc);
  ExecContext newExecContext;
  if (mode == TaskMode.LEAF) {
    newExecContext=ExecContext.LEAF;
  }
 else   if (mode == TaskMode.CONTROL) {
    newExecContext=ExecContext.CONTROL;
  }
 else {
    newExecContext=execContextStack.peek();
  }
  execContextStack.push(newExecContext);
}",0.9820570330022428
133169,"@Override public void endWaitStatement(List<Var> usedVars,List<Var> keepOpenVars){
  logger.trace(""String_Node_Str"");
  endAsync(usedVars,keepOpenVars);
}","@Override public void endWaitStatement(List<Var> waitVars,List<Var> usedVars,List<Var> keepOpenVars){
  logger.trace(""String_Node_Str"");
  endAsync(waitVars,usedVars,keepOpenVars);
}",0.9166666666666666
133170,"private static void doHoist(Logger logger,List<Block> ancestors,Block curr,Instruction inst,ListIterator<Instruction> currInstIt,int hoistDepth,HierarchicalMap<String,Block> writeMap){
  assert(hoistDepth > 0);
  assert(hoistDepth <= ancestors.size());
  Block target=ancestors.get(ancestors.size() - hoistDepth);
  logger.trace(""String_Node_Str"" + hoistDepth + ""String_Node_Str""+ inst.toString());
  assert(target != null);
  currInstIt.remove();
  target.addInstruction(inst);
  relocateVarDefs(curr,target,ancestors,inst,hoistDepth);
  for (  Var out : inst.getOutputs()) {
    writeMap.remove(out.name(),false);
    writeMap.put(out.name(),target,hoistDepth);
  }
}","private static void doHoist(Logger logger,List<Block> ancestors,Block curr,Instruction inst,ListIterator<Instruction> currInstIt,int hoistDepth,HierarchicalMap<String,Block> writeMap){
  assert(hoistDepth > 0);
  assert(hoistDepth <= ancestors.size());
  Block target=ancestors.get(ancestors.size() - hoistDepth);
  logger.trace(""String_Node_Str"" + hoistDepth + ""String_Node_Str""+ inst.toString());
  assert(target != null);
  currInstIt.remove();
  target.addInstruction(inst);
  relocateVarDefs(curr,target,ancestors,inst,hoistDepth);
  for (  Var out : inst.getOutputs()) {
    writeMap.remove(out.name(),false);
    if (trackWrites(out)) {
      writeMap.put(out.name(),target,hoistDepth);
    }
  }
}",0.9737991266375546
133171,"/** 
 * True if the variable is one we should track
 * @param in
 * @return
 */
private static boolean trackWrites(Var in){
  Type t=in.type();
  if (Types.isScalarFuture(t) || Types.isScalarValue(t)) {
    return true;
  }
 else   if (Types.isRef(t) && Types.isScalarFuture(t.memberType())) {
    return true;
  }
  return false;
}","/** 
 * True if the variable is one we should track
 * @param in
 * @return
 */
private static boolean trackWrites(Var in){
  Type t=in.type();
  if (Types.isScalarFuture(t) || Types.isScalarValue(t)) {
    return true;
  }
 else   if (Types.isRef(t)) {
    return true;
  }
  return false;
}",0.935897435897436
133172,"private static void updateName(Set<String> usedNames,HashMap<String,Arg> renames,Var var){
  if (usedNames.contains(var.name())) {
    System.err.println(var.name() + ""String_Node_Str"");
    String newName=chooseNewName(usedNames,var);
    renames.put(var.name(),Arg.createVar(new Var(var.type(),newName,var.storage(),var.defType(),var.mapping())));
    usedNames.add(newName);
  }
 else {
    usedNames.add(var.name());
  }
}","private static void updateName(Set<String> usedNames,HashMap<String,Arg> renames,Var var){
  if (usedNames.contains(var.name())) {
    String newName=chooseNewName(usedNames,var);
    renames.put(var.name(),Arg.createVar(new Var(var.type(),newName,var.storage(),var.defType(),var.mapping())));
    usedNames.add(newName);
  }
 else {
    usedNames.add(var.name());
  }
}",0.9296482412060302
133173,"private void updateName(Block block,Function f,Map<String,Arg> replacements,Set<String> excludedNames,Var var){
  String newName=f.getMainblock().uniqueVarName(var.name(),excludedNames);
  Var newVar=new Var(var.type(),newName,var.storage(),var.defType(),var.mapping());
  replacements.put(var.name(),Arg.createVar(newVar));
  excludedNames.add(newName);
  UniqueVarNames.replaceCleanup(block,var,newVar);
}","private void updateName(Logger logger,Block block,Function targetFunction,Map<String,Arg> replacements,Set<String> excludedNames,Var var){
  String newName=targetFunction.getMainblock().uniqueVarName(var.name(),excludedNames);
  Var newVar=new Var(var.type(),newName,var.storage(),var.defType(),var.mapping());
  replacements.put(var.name(),Arg.createVar(newVar));
  excludedNames.add(newName);
  UniqueVarNames.replaceCleanup(block,var,newVar);
  logger.trace(""String_Node_Str"" + var + ""String_Node_Str""+ newVar+ ""String_Node_Str""+ targetFunction.getName());
}",0.8367768595041323
133174,"/** 
 * Set up renames for local variables in inline block
 * @param prog program
 * @param targetFunction function block being inlined into
 * @param inlineBlock block to be inlined
 * @param replacements updated with new renames
 */
private void chooseUniqueNames(Program prog,Function targetFunction,Block inlineBlock,Map<String,Arg> replacements){
  Set<String> excludedNames=new HashSet<String>();
  excludedNames.addAll(prog.getGlobalConsts().keySet());
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(inlineBlock);
  while (!blocks.isEmpty()) {
    Block block=blocks.pop();
    for (    Var v : block.getVariables()) {
      if (v.defType() != DefType.GLOBAL_CONST) {
        updateName(block,targetFunction,replacements,excludedNames,v);
      }
    }
    for (    Continuation c : block.getContinuations()) {
      List<Var> constructVars=c.constructDefinedVars();
      if (constructVars != null) {
        for (        Var cv : constructVars) {
          updateName(block,targetFunction,replacements,excludedNames,cv);
        }
      }
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
}","/** 
 * Set up renames for local variables in inline block
 * @param prog program
 * @param targetFunction function block being inlined into
 * @param inlineBlock block to be inlined
 * @param replacements updated with new renames
 */
private void chooseUniqueNames(Logger logger,Program prog,Function targetFunction,Block inlineBlock,Map<String,Arg> replacements){
  Set<String> excludedNames=new HashSet<String>();
  excludedNames.addAll(prog.getGlobalConsts().keySet());
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(inlineBlock);
  while (!blocks.isEmpty()) {
    Block block=blocks.pop();
    for (    Var v : block.getVariables()) {
      if (v.defType() != DefType.GLOBAL_CONST) {
        updateName(logger,block,targetFunction,replacements,excludedNames,v);
      }
    }
    for (    Continuation c : block.getContinuations()) {
      List<Var> constructVars=c.constructDefinedVars();
      if (constructVars != null) {
        for (        Var cv : constructVars) {
          updateName(logger,block,targetFunction,replacements,excludedNames,cv);
        }
      }
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
}",0.988034188034188
133175,"/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    pipe.addPass(inliner);
    pipe.addPass(new Validate());
    pipe.addPass(new ConstantFold());
    if (iteration == 0) {
      pipe.addPass(new LoopUnroller());
    }
    pipe.addPass(new HoistLoops());
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - 2) {
      pipe.addPass(new Pipeline());
      pipe.addPass(new Validate());
    }
    boolean doWaitMerges=(iteration == nIterations - 1);
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    pipe.addPass(new Validate());
    pipe.runPipeline(logger,prog,iteration);
  }
}","/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    pipe.addPass(inliner);
    pipe.addPass(new FixupVariables());
    pipe.addPass(new Validate());
    pipe.addPass(new ConstantFold());
    if (iteration == 0) {
      pipe.addPass(new LoopUnroller());
    }
    pipe.addPass(new HoistLoops());
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - 2) {
      pipe.addPass(new Pipeline());
      pipe.addPass(new Validate());
    }
    boolean doWaitMerges=(iteration == nIterations - 1);
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    pipe.addPass(new Validate());
    pipe.runPipeline(logger,prog,iteration);
  }
}",0.9816176470588236
133176,"public void prettyPrint(StringBuilder sb,String indent){
  for (  Var v : variables) {
    sb.append(indent);
    sb.append(""String_Node_Str"" + v.type().typeName() + ""String_Node_Str""+ v.name()+ ""String_Node_Str""+ v.storage().toString().toLowerCase()+ ""String_Node_Str"");
    if (v.isMapped()) {
      sb.append(""String_Node_Str"" + v.mapping().name());
    }
    sb.append(""String_Node_Str"");
  }
  for (  Instruction i : instructions) {
    sb.append(indent);
    sb.append(i.toString());
    sb.append(""String_Node_Str"");
  }
  for (  boolean runLast : new boolean[]{false,true}) {
    for (    Continuation c : continuations) {
      if (c.runLast() == runLast) {
        c.prettyPrint(sb,indent);
      }
    }
  }
  for (  CleanupAction a : cleanupActions) {
    sb.append(indent);
    sb.append(a.action().toString());
    sb.append(""String_Node_Str"" + a.var.name());
    sb.append(""String_Node_Str"");
  }
}","public void prettyPrint(StringBuilder sb,String indent){
  for (  Var v : variables) {
    sb.append(indent);
    sb.append(""String_Node_Str"" + v.type().typeName() + ""String_Node_Str""+ v.name()+ ""String_Node_Str""+ v.storage().toString().toLowerCase()+ ""String_Node_Str"");
    if (v.isMapped()) {
      sb.append(""String_Node_Str"" + v.mapping().name());
    }
    sb.append(""String_Node_Str"");
  }
  for (  Instruction i : instructions) {
    sb.append(indent);
    sb.append(i.toString());
    sb.append(""String_Node_Str"");
  }
  for (  boolean runLast : new boolean[]{false,true}) {
    for (    Continuation c : continuations) {
      if (c.runLast() == runLast) {
        c.prettyPrint(sb,indent);
      }
    }
  }
  for (  CleanupAction a : cleanupActions) {
    sb.append(indent);
    sb.append(a.toString());
    sb.append(""String_Node_Str"");
  }
}",0.9671945701357466
133177,"public Block clone(BlockType newType,Continuation parentCont,Function parentFunction){
  Block cloned=new Block(newType,parentCont,parentFunction,ICUtil.cloneInstructions(this.instructions),new ArrayList<Var>(this.variables),new ArrayList<Continuation>(),new ArrayList<CleanupAction>(this.cleanupActions));
  for (  Continuation c : this.continuations) {
    cloned.addContinuation(c.clone());
  }
  return cloned;
}","public Block clone(BlockType newType,Continuation parentCont,Function parentFunction){
  Block cloned=new Block(newType,parentCont,parentFunction,ICUtil.cloneInstructions(this.instructions),new ArrayList<Var>(this.variables),new ArrayList<Continuation>(),ICUtil.cloneCleanups(this.cleanupActions));
  for (  Continuation c : this.continuations) {
    cloned.addContinuation(c.clone());
  }
  return cloned;
}",0.941747572815534
133178,"private void doInlining(Logger logger,Program prog,Function contextFunction,Block block,MultiMap<String,String> inlineLocations,Map<String,Function> toInline){
  for (  Continuation c : block.getContinuations()) {
    for (    Block cb : c.getBlocks()) {
      doInlining(logger,prog,contextFunction,cb,inlineLocations,toInline);
    }
  }
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (isFunctionCall(inst)) {
      FunctionCall fcall=(FunctionCall)inst;
      if (toInline.containsKey(fcall.getFunctionName())) {
        List<String> inlineCallers=inlineLocations.get(fcall.getFunctionName());
        if (inlineCallers.contains(contextFunction.getName())) {
          inlineCall(logger,prog,contextFunction,block,it,fcall,toInline.get(fcall.getFunctionName()));
        }
      }
    }
  }
}","private void doInlining(Logger logger,Program prog,Function contextFunction,Block block,MultiMap<String,String> inlineLocations,Map<String,Function> toInline){
  for (  Continuation c : block.getContinuations()) {
    for (    Block cb : c.getBlocks()) {
      doInlining(logger,prog,contextFunction,cb,inlineLocations,toInline);
    }
  }
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (isFunctionCall(inst)) {
      FunctionCall fcall=(FunctionCall)inst;
      if (toInline.containsKey(fcall.getFunctionName())) {
        if (fcall.getPriority() != null)         continue;
        List<String> inlineCallers=inlineLocations.get(fcall.getFunctionName());
        if (inlineCallers.contains(contextFunction.getName())) {
          inlineCall(logger,prog,contextFunction,block,it,fcall,toInline.get(fcall.getFunctionName()));
        }
      }
    }
  }
}",0.9672767609539656
133179,"/** 
 * Do the inlining
 * @param logger
 * @param block
 * @param it iterator positioned at function call instruction
 * @param fnCall
 * @param toInline
 */
private void inlineCall(Logger logger,Program prog,Function contextFunction,Block block,ListIterator<Instruction> it,FunctionCall fnCall,Function toInline){
  it.remove();
  Block inlineBlock=toInline.getMainblock().clone(BlockType.NESTED_BLOCK,null,null);
  Map<String,Arg> renames=new HashMap<String,Arg>();
  List<Var> passIn=new ArrayList<Var>();
  List<Var> outArrays=new ArrayList<Var>();
  assert(fnCall.getOutputs().size() == toInline.getOutputList().size());
  assert(fnCall.getInputs().size() == toInline.getInputList().size());
  for (int i=0; i < fnCall.getInputs().size(); i++) {
    Arg inputVal=fnCall.getInput(i);
    Var inArg=toInline.getInputList().get(i);
    renames.put(inArg.name(),inputVal);
    if (inputVal.isVar()) {
      passIn.add(inputVal.getVar());
    }
    inlineBlock.removeCleanups(inArg);
  }
  for (int i=0; i < fnCall.getOutputs().size(); i++) {
    Var outVar=fnCall.getOutput(i);
    Var outArg=toInline.getOutputList().get(i);
    renames.put(outArg.name(),Arg.createVar(outVar));
    passIn.add(outVar);
    if (Types.isArray(outVar.type())) {
      outArrays.add(outVar);
    }
    inlineBlock.removeCleanups(outArg);
  }
  Block insertBlock;
  ListIterator<Instruction> insertPos;
  chooseUniqueNames(prog,contextFunction,inlineBlock,renames);
  inlineBlock.renameVars(renames,false);
  if (fnCall.getMode() == TaskMode.SYNC) {
    insertBlock=block;
    insertPos=it;
  }
 else {
    WaitMode waitMode=WaitMode.TASK_DISPATCH;
    WaitStatement wait=new WaitStatement(contextFunction.getName() + ""String_Node_Str"" + toInline.getName()+ ""String_Node_Str"",toInline.getBlockingInputs(),passIn,outArrays,waitMode,false,fnCall.getMode());
    block.addContinuation(wait);
    insertBlock=wait.getBlock();
    insertPos=insertBlock.instructionIterator();
  }
  insertBlock.insertInline(inlineBlock,insertPos);
  logger.debug(""String_Node_Str"" + fnCall.getFunctionName() + ""String_Node_Str""+ contextFunction.getName());
  blacklist.add(Pair.create(contextFunction.getName(),fnCall.getFunctionName()));
}","/** 
 * Do the inlining
 * @param logger
 * @param block
 * @param it iterator positioned at function call instruction
 * @param fnCall
 * @param toInline
 */
private void inlineCall(Logger logger,Program prog,Function contextFunction,Block block,ListIterator<Instruction> it,FunctionCall fnCall,Function toInline){
}",0.2518871672626142
133180,"@Override public void optimize(Logger logger,Program program) throws UserException {
  boolean changed;
  do {
    FuncCallFinder finder=new FuncCallFinder();
    TreeWalk.walk(logger,program,finder);
    pruneBuiltins(logger,program,finder);
    Pair<MultiMap<String,String>,Set<String>> actions=selectInlineFunctions(program,finder);
    MultiMap<String,String> inlineLocations=actions.val1;
    Set<String> toRemove=actions.val2;
    logger.debug(""String_Node_Str"" + inlineLocations.toString());
    logger.debug(""String_Node_Str"" + toRemove.toString());
    changed=doInlining(logger,program,inlineLocations,toRemove);
    logger.debug(""String_Node_Str"" + changed);
  }
 while (changed);
}","@Override public void optimize(Logger logger,Program program) throws UserException {
  boolean changed;
  int i=0;
  do {
    FuncCallFinder finder=new FuncCallFinder();
    TreeWalk.walk(logger,program,finder);
    pruneBuiltins(logger,program,finder);
    Pair<MultiMap<String,String>,Set<String>> actions=selectInlineFunctions(program,finder);
    MultiMap<String,String> inlineLocations=actions.val1;
    Set<String> toRemove=actions.val2;
    logger.debug(""String_Node_Str"" + inlineLocations.toString());
    logger.debug(""String_Node_Str"" + toRemove.toString());
    changed=doInlining(logger,program,inlineLocations,toRemove);
    logger.debug(""String_Node_Str"" + changed);
    i++;
  }
 while (changed && i < MAX_ITERS_PER_PASS);
}",0.9678770949720672
133181,"/** 
 * Set up renames for local variables in inline block
 * @param inlineBlock
 * @param replacements updated with new renames
 */
private void chooseUniqueNames(Program prog,Function f,Block inlineBlock,Map<String,Arg> replacements){
  Set<String> excludedNames=new HashSet<String>();
  excludedNames.addAll(prog.getGlobalConsts().keySet());
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(inlineBlock);
  while (!blocks.isEmpty()) {
    Block block=blocks.pop();
    for (    Var v : block.getVariables()) {
      if (v.defType() != DefType.GLOBAL_CONST) {
        updateName(f,replacements,excludedNames,v);
      }
    }
    for (    Continuation c : block.getContinuations()) {
      List<Var> constructVars=c.constructDefinedVars();
      if (constructVars != null) {
        for (        Var cv : constructVars) {
          updateName(f,replacements,excludedNames,cv);
        }
      }
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
}","/** 
 * Set up renames for local variables in inline block
 * @param prog program
 * @param targetFunction function block being inlined into
 * @param inlineBlock block to be inlined
 * @param replacements updated with new renames
 */
private void chooseUniqueNames(Program prog,Function targetFunction,Block inlineBlock,Map<String,Arg> replacements){
  Set<String> excludedNames=new HashSet<String>();
  excludedNames.addAll(prog.getGlobalConsts().keySet());
  Deque<Block> blocks=new ArrayDeque<Block>();
  blocks.add(inlineBlock);
  while (!blocks.isEmpty()) {
    Block block=blocks.pop();
    for (    Var v : block.getVariables()) {
      if (v.defType() != DefType.GLOBAL_CONST) {
        updateName(targetFunction,replacements,excludedNames,v);
      }
    }
    for (    Continuation c : block.getContinuations()) {
      List<Var> constructVars=c.constructDefinedVars();
      if (constructVars != null) {
        for (        Var cv : constructVars) {
          updateName(targetFunction,replacements,excludedNames,cv);
        }
      }
      for (      Block inner : c.getBlocks()) {
        blocks.push(inner);
      }
    }
  }
}",0.8169538891476479
133182,"private void doInlining(Logger logger,Program prog,String contextFunction,Block block,Map<String,Function> toInline){
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (isFunctionCall(inst)) {
      FunctionCall fcall=(FunctionCall)inst;
      if (toInline.containsKey(fcall.getFunctionName())) {
        inlineCall(logger,prog,contextFunction,block,it,fcall,toInline.get(fcall.getFunctionName()));
      }
    }
  }
  for (  Continuation c : block.getContinuations()) {
    for (    Block cb : c.getBlocks()) {
      doInlining(logger,prog,contextFunction,cb,toInline);
    }
  }
}","private void doInlining(Logger logger,Program prog,Function contextFunction,Block block,Map<String,Function> toInline){
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (isFunctionCall(inst)) {
      FunctionCall fcall=(FunctionCall)inst;
      if (toInline.containsKey(fcall.getFunctionName())) {
        inlineCall(logger,prog,contextFunction,block,it,fcall,toInline.get(fcall.getFunctionName()));
      }
    }
  }
  for (  Continuation c : block.getContinuations()) {
    for (    Block cb : c.getBlocks()) {
      doInlining(logger,prog,contextFunction,cb,toInline);
    }
  }
}",0.989345509893455
133183,"/** 
 * Do the inlining
 * @param logger
 * @param block
 * @param it iterator positioned at function call instruction
 * @param inst
 * @param function
 */
private void inlineCall(Logger logger,Program prog,String contextFunction,Block block,ListIterator<Instruction> it,FunctionCall inst,Function function){
  it.remove();
  Map<String,Arg> renames=new HashMap<String,Arg>();
  List<Var> passIn=new ArrayList<Var>();
  List<Var> outArrays=new ArrayList<Var>();
  assert(inst.getOutputs().size() == function.getOutputList().size());
  assert(inst.getInputs().size() == function.getInputList().size());
  for (int i=0; i < inst.getInputs().size(); i++) {
    Arg inputVal=inst.getInput(i);
    renames.put(function.getInputList().get(i).name(),inputVal);
    if (inputVal.isVar()) {
      passIn.add(inputVal.getVar());
    }
  }
  for (int i=0; i < inst.getOutputs().size(); i++) {
    Var outVar=inst.getOutput(i);
    renames.put(function.getOutputList().get(i).name(),Arg.createVar(outVar));
    passIn.add(outVar);
    if (Types.isArray(outVar.type())) {
      outArrays.add(outVar);
    }
  }
  Block insertBlock;
  ListIterator<Instruction> insertPos;
  Block inlineBlock=function.getMainblock().clone(BlockType.NESTED_BLOCK,null,null);
  chooseUniqueNames(prog,function,inlineBlock,renames);
  inlineBlock.renameVars(renames,false);
  if (inst.getMode() == TaskMode.SYNC) {
    insertBlock=block;
    insertPos=it;
  }
 else {
    WaitMode waitMode=WaitMode.TASK_DISPATCH;
    WaitStatement wait=new WaitStatement(contextFunction + ""String_Node_Str"" + function.getName()+ ""String_Node_Str"",function.getBlockingInputs(),passIn,outArrays,waitMode,false,inst.getMode());
    block.addContinuation(wait);
    insertBlock=wait.getBlock();
    insertPos=insertBlock.instructionIterator();
  }
  insertBlock.insertInline(inlineBlock,insertPos);
}","/** 
 * Do the inlining
 * @param logger
 * @param block
 * @param it iterator positioned at function call instruction
 * @param fnCall
 * @param toInline
 */
private void inlineCall(Logger logger,Program prog,Function contextFunction,Block block,ListIterator<Instruction> it,FunctionCall fnCall,Function toInline){
  it.remove();
  Map<String,Arg> renames=new HashMap<String,Arg>();
  List<Var> passIn=new ArrayList<Var>();
  List<Var> outArrays=new ArrayList<Var>();
  assert(fnCall.getOutputs().size() == toInline.getOutputList().size());
  assert(fnCall.getInputs().size() == toInline.getInputList().size());
  for (int i=0; i < fnCall.getInputs().size(); i++) {
    Arg inputVal=fnCall.getInput(i);
    renames.put(toInline.getInputList().get(i).name(),inputVal);
    if (inputVal.isVar()) {
      passIn.add(inputVal.getVar());
    }
  }
  for (int i=0; i < fnCall.getOutputs().size(); i++) {
    Var outVar=fnCall.getOutput(i);
    renames.put(toInline.getOutputList().get(i).name(),Arg.createVar(outVar));
    passIn.add(outVar);
    if (Types.isArray(outVar.type())) {
      outArrays.add(outVar);
    }
  }
  Block insertBlock;
  ListIterator<Instruction> insertPos;
  Block inlineBlock=toInline.getMainblock().clone(BlockType.NESTED_BLOCK,null,null);
  chooseUniqueNames(prog,contextFunction,inlineBlock,renames);
  inlineBlock.renameVars(renames,false);
  if (fnCall.getMode() == TaskMode.SYNC) {
    insertBlock=block;
    insertPos=it;
  }
 else {
    WaitMode waitMode=WaitMode.TASK_DISPATCH;
    WaitStatement wait=new WaitStatement(contextFunction + ""String_Node_Str"" + toInline.getName()+ ""String_Node_Str"",toInline.getBlockingInputs(),passIn,outArrays,waitMode,false,fnCall.getMode());
    block.addContinuation(wait);
    insertBlock=wait.getBlock();
    insertPos=insertBlock.instructionIterator();
  }
  insertBlock.insertInline(inlineBlock,insertPos);
  logger.debug(""String_Node_Str"" + fnCall.getFunctionName() + ""String_Node_Str""+ toInline.getName());
}",0.8062745098039216
133184,"private void checkUniqueVarNames(Logger logger,Program program,Function fn,Block block,Set<String> usedNames){
  for (  Var v : block.getVariables()) {
    checkVarUnique(logger,program,fn,usedNames,v);
  }
  for (  Continuation c : block.getContinuations()) {
    List<Var> constructDefined=c.constructDefinedVars();
    if (constructDefined != null) {
      for (      Var v : constructDefined) {
        checkVarUnique(logger,program,fn,usedNames,v);
      }
    }
    for (    Block inner : c.getBlocks()) {
      checkUniqueVarNames(logger,program,fn,inner,usedNames);
    }
  }
}","private void checkUniqueVarNames(Logger logger,Program program,Function fn,Block block,Set<String> usedNames){
  for (  Var v : block.getVariables()) {
    checkVarUnique(logger,program,fn,usedNames,v);
  }
  checkCleanups(fn,block);
  for (  Continuation c : block.getContinuations()) {
    List<Var> constructDefined=c.constructDefinedVars();
    if (constructDefined != null) {
      for (      Var v : constructDefined) {
        checkVarUnique(logger,program,fn,usedNames,v);
      }
    }
    for (    Block inner : c.getBlocks()) {
      checkUniqueVarNames(logger,program,fn,inner,usedNames);
    }
  }
}",0.9774436090225564
133185,"public static ArrayList<Continuation> cloneContinuations(List<Continuation> conts){
  ArrayList<Continuation> newContinuations=new ArrayList<Continuation>(conts.size());
  for (  Continuation old : conts) {
    newContinuations.add(old.clone());
  }
  return newContinuations;
}","public static ArrayList<Continuation> cloneContinuations(List<Continuation> conts,Block parent){
  ArrayList<Continuation> newContinuations=new ArrayList<Continuation>(conts.size());
  for (  Continuation old : conts) {
    Continuation newC=old.clone();
    newC.setParent(parent);
    newContinuations.add(newC);
  }
  return newContinuations;
}",0.8544
133186,"/** 
 * Do the inlining
 * @param logger
 * @param block
 * @param it iterator positioned at function call instruction
 * @param fnCall
 * @param toInline
 */
private void inlineCall(Logger logger,Program prog,Function contextFunction,Block block,ListIterator<Instruction> it,FunctionCall fnCall,Function toInline){
  it.remove();
  Block inlineBlock=toInline.getMainblock().clone(BlockType.NESTED_BLOCK,null,null);
  Map<String,Arg> renames=new HashMap<String,Arg>();
  List<Var> passIn=new ArrayList<Var>();
  List<Var> outArrays=new ArrayList<Var>();
  assert(fnCall.getOutputs().size() == toInline.getOutputList().size());
  assert(fnCall.getInputs().size() == toInline.getInputList().size());
  for (int i=0; i < fnCall.getInputs().size(); i++) {
    Arg inputVal=fnCall.getInput(i);
    Var inArg=toInline.getInputList().get(i);
    renames.put(inArg.name(),inputVal);
    if (inputVal.isVar()) {
      passIn.add(inputVal.getVar());
    }
    inlineBlock.removeCleanups(inArg);
  }
  for (int i=0; i < fnCall.getOutputs().size(); i++) {
    Var outVar=fnCall.getOutput(i);
    Var outArg=toInline.getOutputList().get(i);
    renames.put(outArg.name(),Arg.createVar(outVar));
    passIn.add(outVar);
    if (Types.isArray(outVar.type())) {
      outArrays.add(outVar);
    }
    inlineBlock.removeCleanups(outArg);
  }
  Block insertBlock;
  ListIterator<Instruction> insertPos;
  chooseUniqueNames(prog,contextFunction,inlineBlock,renames);
  inlineBlock.renameVars(renames,false);
  if (fnCall.getMode() == TaskMode.SYNC) {
    insertBlock=block;
    insertPos=it;
  }
 else {
    WaitMode waitMode=WaitMode.TASK_DISPATCH;
    WaitStatement wait=new WaitStatement(contextFunction.getName() + ""String_Node_Str"" + toInline.getName()+ ""String_Node_Str"",toInline.getBlockingInputs(),passIn,outArrays,waitMode,false,fnCall.getMode());
    block.addContinuation(wait);
    insertBlock=wait.getBlock();
    insertPos=insertBlock.instructionIterator();
  }
  insertBlock.insertInline(inlineBlock,insertPos);
  logger.debug(""String_Node_Str"" + fnCall.getFunctionName() + ""String_Node_Str""+ contextFunction.getName());
  new Exception().printStackTrace();
}","/** 
 * Do the inlining
 * @param logger
 * @param block
 * @param it iterator positioned at function call instruction
 * @param fnCall
 * @param toInline
 */
private void inlineCall(Logger logger,Program prog,Function contextFunction,Block block,ListIterator<Instruction> it,FunctionCall fnCall,Function toInline){
  it.remove();
  Block inlineBlock=toInline.getMainblock().clone(BlockType.NESTED_BLOCK,null,null);
  Map<String,Arg> renames=new HashMap<String,Arg>();
  List<Var> passIn=new ArrayList<Var>();
  List<Var> outArrays=new ArrayList<Var>();
  assert(fnCall.getOutputs().size() == toInline.getOutputList().size());
  assert(fnCall.getInputs().size() == toInline.getInputList().size());
  for (int i=0; i < fnCall.getInputs().size(); i++) {
    Arg inputVal=fnCall.getInput(i);
    Var inArg=toInline.getInputList().get(i);
    renames.put(inArg.name(),inputVal);
    if (inputVal.isVar()) {
      passIn.add(inputVal.getVar());
    }
    inlineBlock.removeCleanups(inArg);
  }
  for (int i=0; i < fnCall.getOutputs().size(); i++) {
    Var outVar=fnCall.getOutput(i);
    Var outArg=toInline.getOutputList().get(i);
    renames.put(outArg.name(),Arg.createVar(outVar));
    passIn.add(outVar);
    if (Types.isArray(outVar.type())) {
      outArrays.add(outVar);
    }
    inlineBlock.removeCleanups(outArg);
  }
  Block insertBlock;
  ListIterator<Instruction> insertPos;
  chooseUniqueNames(prog,contextFunction,inlineBlock,renames);
  inlineBlock.renameVars(renames,false);
  if (fnCall.getMode() == TaskMode.SYNC) {
    insertBlock=block;
    insertPos=it;
  }
 else {
    WaitMode waitMode=WaitMode.TASK_DISPATCH;
    WaitStatement wait=new WaitStatement(contextFunction.getName() + ""String_Node_Str"" + toInline.getName()+ ""String_Node_Str"",toInline.getBlockingInputs(),passIn,outArrays,waitMode,false,fnCall.getMode());
    block.addContinuation(wait);
    insertBlock=wait.getBlock();
    insertPos=insertBlock.instructionIterator();
  }
  insertBlock.insertInline(inlineBlock,insertPos);
  logger.debug(""String_Node_Str"" + fnCall.getFunctionName() + ""String_Node_Str""+ contextFunction.getName());
  blacklist.add(Pair.create(contextFunction.getName(),fnCall.getFunctionName()));
}",0.975430539609644
133187,"/** 
 */
private void findCycleFree(MultiMap<String,String> candidates,Set<String> visited,Set<String> toRemove,MultiMap<String,String> newCandidates,Deque<String> callStack,String curr){
  List<String> callers=candidates.get(curr);
  if (callers == null || callers.size() == 0) {
    return;
  }
  if (visited.contains(curr)) {
    return;
  }
  visited.add(curr);
  for (  String caller : callers) {
    if (callStack.contains(caller) || caller.equals(curr)) {
    }
 else {
      newCandidates.put(curr,caller);
      callStack.push(curr);
      findCycleFree(candidates,visited,toRemove,newCandidates,callStack,caller);
      callStack.pop();
    }
  }
}","/** 
 */
private void findCycleFree(MultiMap<String,String> candidates,Set<String> visited,Set<String> toRemove,MultiMap<String,String> newCandidates,Deque<String> callStack,String curr){
  if (blacklist.contains(curr))   return;
  List<String> callers=candidates.get(curr);
  if (callers == null || callers.size() == 0) {
    return;
  }
  if (visited.contains(curr))   return;
  visited.add(curr);
  for (  String caller : callers) {
    if (callStack.contains(caller) || caller.equals(curr)) {
    }
 else     if (blacklist.contains(Pair.create(caller,curr))) {
    }
 else {
      newCandidates.put(curr,caller);
      callStack.push(curr);
      findCycleFree(candidates,visited,toRemove,newCandidates,callStack,caller);
      callStack.pop();
    }
  }
}",0.9040902679830748
133188,"/** 
 * Optimize the program and return a new one NOTE: the input might be modified in-place
 * @param icOutput where to log IC between optimiation steps.  Null for no output 
 * @return
 * @throws InvalidWriteException 
 */
public static Program optimize(Logger logger,PrintStream icOutput,Program prog) throws UserException {
  boolean logIC=icOutput != null;
  if (logIC) {
    prog.log(icOutput,""String_Node_Str"");
  }
  long nIterations;
  try {
    nIterations=Settings.getLong(Settings.OPT_MAX_ITERATIONS);
  }
 catch (  InvalidOptionException ex) {
    throw new STCRuntimeError(ex.getMessage());
  }
  preprocess(icOutput,logger,prog);
  for (long iteration=0; iteration < nIterations; iteration++) {
    iterate(icOutput,logger,prog,iteration,nIterations);
  }
  postprocess(icOutput,logger,prog,nIterations);
  if (logIC) {
    prog.log(icOutput,""String_Node_Str"");
  }
  return prog;
}","/** 
 * Optimize the program and return a new one NOTE: the input might be modified in-place
 * @param icOutput where to log IC between optimiation steps.  Null for no output 
 * @return
 * @throws InvalidWriteException 
 */
public static Program optimize(Logger logger,PrintStream icOutput,Program prog) throws UserException {
  boolean logIC=icOutput != null;
  if (logIC) {
    prog.log(icOutput,""String_Node_Str"");
  }
  long nIterations;
  try {
    nIterations=Settings.getLong(Settings.OPT_MAX_ITERATIONS);
  }
 catch (  InvalidOptionException ex) {
    throw new STCRuntimeError(ex.getMessage());
  }
  preprocess(icOutput,logger,prog);
  iterate(icOutput,logger,prog,nIterations);
  postprocess(icOutput,logger,prog,nIterations);
  if (logIC) {
    prog.log(icOutput,""String_Node_Str"");
  }
  return prog;
}",0.9036777583187392
133189,"/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,long iteration,long nIterations) throws UserException {
  OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
  pipe.addPass(new FunctionInline());
  pipe.addPass(new ConstantFold());
  if (iteration == 0) {
    pipe.addPass(new LoopUnroller());
  }
  pipe.addPass(new HoistLoops());
  pipe.addPass(new ForwardDataflow());
  pipe.addPass(new ContinuationFusion());
  if (iteration == nIterations - 2) {
    pipe.addPass(new Pipeline());
    pipe.addPass(new Validate());
  }
  boolean doWaitMerges=(iteration == nIterations - 1);
  pipe.addPass(new WaitCoalescer(doWaitMerges));
  pipe.addPass(new Validate());
  pipe.runPipeline(logger,prog,iteration);
}","/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,long nIterations) throws UserException {
  FunctionInline inliner=new FunctionInline();
  for (long iteration=0; iteration < nIterations; iteration++) {
    OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
    pipe.addPass(inliner);
    pipe.addPass(new ConstantFold());
    if (iteration == 0) {
      pipe.addPass(new LoopUnroller());
    }
    pipe.addPass(new HoistLoops());
    pipe.addPass(new ForwardDataflow());
    pipe.addPass(new ContinuationFusion());
    if (iteration == nIterations - 2) {
      pipe.addPass(new Pipeline());
      pipe.addPass(new Validate());
    }
    boolean doWaitMerges=(iteration == nIterations - 1);
    pipe.addPass(new WaitCoalescer(doWaitMerges));
    pipe.addPass(new Validate());
    pipe.runPipeline(logger,prog,iteration);
  }
}",0.526207605344296
133190,"public Block clone(BlockType newType,Continuation parentCont,Function parentFunction){
  return new Block(newType,parentCont,parentFunction,ICUtil.cloneInstructions(this.instructions),new ArrayList<Var>(this.variables),ICUtil.cloneContinuations(this.continuations),new ArrayList<CleanupAction>(this.cleanupActions));
}","public Block clone(BlockType newType,Continuation parentCont,Function parentFunction){
  Block cloned=new Block(newType,parentCont,parentFunction,ICUtil.cloneInstructions(this.instructions),new ArrayList<Var>(this.variables),new ArrayList<Continuation>(),new ArrayList<CleanupAction>(this.cleanupActions));
  for (  Continuation c : this.continuations) {
    cloned.addContinuation(c.clone());
  }
  return cloned;
}",0.6294277929155313
133191,"/** 
 * block operates on a BLOCK node of the AST. This should be called for every logical code block (e.g. function bodies, condition bodies, etc) in the program
 * @param context a new context for this block
 * @param closeArgs whether to close input or output argumentsdeclared in block
 */
private void block(Context context,SwiftAST tree,boolean closeArgs) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  if (tree.getType() != ExMParser.BLOCK) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + tree.getLine() + ""String_Node_Str""+ tree.getCharPositionInLine());
  }
  VariableUsageInfo blockVu=tree.checkedGetVariableUsage();
  for (  SwiftAST stmt : tree.children()) {
    walkStatement(context,stmt,blockVu);
  }
  closeBlockVariables(context,closeArgs);
  LogHelper.trace(context,""String_Node_Str"");
}","/** 
 * block operates on a BLOCK node of the AST. This should be called for every logical code block (e.g. function bodies, condition bodies, etc) in the program
 * @param context a new context for this block
 * @param noRefCount vars that shouldn't have refcoutn decremented onblock exit
 */
private void block(Context context,SwiftAST tree,Collection<Var> noRefcount) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  if (tree.getType() != ExMParser.BLOCK) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + tree.getLine() + ""String_Node_Str""+ tree.getCharPositionInLine());
  }
  VariableUsageInfo blockVu=tree.checkedGetVariableUsage();
  for (  SwiftAST stmt : tree.children()) {
    walkStatement(context,stmt,blockVu);
  }
  cleanupBlockVars(context,noRefcount);
  LogHelper.trace(context,""String_Node_Str"");
}",0.8803269118505546
133192,"/** 
 * Compile the function, assuming it is already defined in context 
 */
private void compileFunction(Context context,SwiftAST tree) throws UserException {
  String function=tree.child(0).getText();
  LogHelper.debug(context,""String_Node_Str"" + function);
  assert(context.isFunction(function));
  assert(context.hasFunctionProp(function,FnProp.COMPOSITE));
  SwiftAST outputs=tree.child(1);
  SwiftAST inputs=tree.child(2);
  SwiftAST block=tree.child(3);
  FunctionDecl fdecl=FunctionDecl.fromAST(context,function,inputs,outputs,Collections.<String>emptySet());
  List<Var> iList=fdecl.getInVars();
  List<Var> oList=fdecl.getOutVars();
  context.syncFilePos(tree,lineMapping);
  varAnalyzer.analyzeVariableUsage(context,function,iList,oList,block);
  LocalContext functionContext=new LocalContext(context,function);
  functionContext.setNested(false);
  functionContext.addDeclaredVariables(iList);
  functionContext.addDeclaredVariables(oList);
  TaskMode mode=context.hasFunctionProp(function,FnProp.SYNC) ? TaskMode.SYNC : TaskMode.CONTROL;
  backend.startFunction(function,oList,iList,mode);
  if (mode != TaskMode.SYNC) {
    VariableUsageInfo vu=block.getVariableUsage();
    for (    Var o : oList) {
      flagDeclaredVarForClosing(functionContext,o,vu);
    }
  }
  block(functionContext,block,false);
  backend.endFunction();
  LogHelper.debug(context,""String_Node_Str"" + function);
}","/** 
 * Compile the function, assuming it is already defined in context 
 */
private void compileFunction(Context context,SwiftAST tree) throws UserException {
  String function=tree.child(0).getText();
  LogHelper.debug(context,""String_Node_Str"" + function);
  assert(context.isFunction(function));
  assert(context.hasFunctionProp(function,FnProp.COMPOSITE));
  SwiftAST outputs=tree.child(1);
  SwiftAST inputs=tree.child(2);
  SwiftAST block=tree.child(3);
  FunctionDecl fdecl=FunctionDecl.fromAST(context,function,inputs,outputs,Collections.<String>emptySet());
  List<Var> iList=fdecl.getInVars();
  List<Var> oList=fdecl.getOutVars();
  context.syncFilePos(tree,lineMapping);
  varAnalyzer.analyzeVariableUsage(context,function,iList,oList,block);
  LocalContext functionContext=new LocalContext(context,function);
  functionContext.setNested(false);
  functionContext.addDeclaredVariables(iList);
  functionContext.addDeclaredVariables(oList);
  TaskMode mode=context.hasFunctionProp(function,FnProp.SYNC) ? TaskMode.SYNC : TaskMode.CONTROL;
  backend.startFunction(function,oList,iList,mode);
  if (mode != TaskMode.SYNC) {
    VariableUsageInfo vu=block.getVariableUsage();
    for (    Var o : oList) {
      flagDeclaredVarForClosing(functionContext,o,vu);
    }
  }
  Set<Var> allArgs=new HashSet<Var>();
  allArgs.addAll(iList);
  allArgs.addAll(oList);
  block(functionContext,block,allArgs);
  backend.endFunction();
  LogHelper.debug(context,""String_Node_Str"" + function);
}",0.965088143795368
133193,"/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(realArray),waitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),iterUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  block(loopBodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(arrRefWaitUsedVars,keepOpenVars);
  }
}","/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(realArray),waitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,false,TaskMode.LOCAL_CONTROL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),iterUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,false,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  Set<Var> noRefcount=Collections.singleton(loop.getMemberVar());
  block(loopBodyContext,loop.getBody(),noRefcount);
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(arrRefWaitUsedVars,keepOpenVars);
  }
}",0.9882064634706692
133194,"/** 
 * block operates on a BLOCK node of the AST. This should be called for every logical code block (e.g. function bodies, condition bodies, etc) in the program
 * @param context a new context for this block
 */
private void block(Context context,SwiftAST tree) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  if (tree.getType() != ExMParser.BLOCK) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + tree.getLine() + ""String_Node_Str""+ tree.getCharPositionInLine());
  }
  VariableUsageInfo blockVu=tree.checkedGetVariableUsage();
  for (  SwiftAST stmt : tree.children()) {
    walkStatement(context,stmt,blockVu);
  }
  closeBlockVariables(context);
  LogHelper.trace(context,""String_Node_Str"");
}","/** 
 * block operates on a BLOCK node of the AST. This should be called for every logical code block (e.g. function bodies, condition bodies, etc) in the program
 * @param context a new context for this block
 * @param closeArgs whether to close input or output argumentsdeclared in block
 */
private void block(Context context,SwiftAST tree,boolean closeArgs) throws UserException {
  LogHelper.trace(context,""String_Node_Str"");
  if (tree.getType() != ExMParser.BLOCK) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + tree.getLine() + ""String_Node_Str""+ tree.getCharPositionInLine());
  }
  VariableUsageInfo blockVu=tree.checkedGetVariableUsage();
  for (  SwiftAST stmt : tree.children()) {
    walkStatement(context,stmt,blockVu);
  }
  closeBlockVariables(context,closeArgs);
  LogHelper.trace(context,""String_Node_Str"");
}",0.932415519399249
133195,"/** 
 * Compile the function, assuming it is already defined in context 
 */
private void compileFunction(Context context,SwiftAST tree) throws UserException {
  String function=tree.child(0).getText();
  LogHelper.debug(context,""String_Node_Str"" + function);
  assert(context.isFunction(function));
  assert(context.hasFunctionProp(function,FnProp.COMPOSITE));
  SwiftAST outputs=tree.child(1);
  SwiftAST inputs=tree.child(2);
  SwiftAST block=tree.child(3);
  FunctionDecl fdecl=FunctionDecl.fromAST(context,function,inputs,outputs,Collections.<String>emptySet());
  List<Var> iList=fdecl.getInVars();
  List<Var> oList=fdecl.getOutVars();
  context.syncFilePos(tree,lineMapping);
  varAnalyzer.analyzeVariableUsage(context,function,iList,oList,block);
  LocalContext functionContext=new LocalContext(context,function);
  functionContext.setNested(false);
  functionContext.addDeclaredVariables(iList);
  functionContext.addDeclaredVariables(oList);
  TaskMode mode=context.hasFunctionProp(function,FnProp.SYNC) ? TaskMode.SYNC : TaskMode.CONTROL;
  backend.startFunction(function,oList,iList,mode);
  VariableUsageInfo vu=block.getVariableUsage();
  for (  Var o : oList) {
    flagDeclaredVarForClosing(functionContext,o,vu);
  }
  block(functionContext,block);
  backend.endFunction();
  LogHelper.debug(context,""String_Node_Str"" + function);
}","/** 
 * Compile the function, assuming it is already defined in context 
 */
private void compileFunction(Context context,SwiftAST tree) throws UserException {
  String function=tree.child(0).getText();
  LogHelper.debug(context,""String_Node_Str"" + function);
  assert(context.isFunction(function));
  assert(context.hasFunctionProp(function,FnProp.COMPOSITE));
  SwiftAST outputs=tree.child(1);
  SwiftAST inputs=tree.child(2);
  SwiftAST block=tree.child(3);
  FunctionDecl fdecl=FunctionDecl.fromAST(context,function,inputs,outputs,Collections.<String>emptySet());
  List<Var> iList=fdecl.getInVars();
  List<Var> oList=fdecl.getOutVars();
  context.syncFilePos(tree,lineMapping);
  varAnalyzer.analyzeVariableUsage(context,function,iList,oList,block);
  LocalContext functionContext=new LocalContext(context,function);
  functionContext.setNested(false);
  functionContext.addDeclaredVariables(iList);
  functionContext.addDeclaredVariables(oList);
  TaskMode mode=context.hasFunctionProp(function,FnProp.SYNC) ? TaskMode.SYNC : TaskMode.CONTROL;
  backend.startFunction(function,oList,iList,mode);
  if (mode != TaskMode.SYNC) {
    VariableUsageInfo vu=block.getVariableUsage();
    for (    Var o : oList) {
      flagDeclaredVarForClosing(functionContext,o,vu);
    }
  }
  block(functionContext,block,false);
  backend.endFunction();
  LogHelper.debug(context,""String_Node_Str"" + function);
}",0.9778262450018176
133196,"/** 
 * Make sure all arrays in block are closed upon exiting
 * @param context
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void closeBlockVariables(Context context) throws UndefinedTypeException, UserException {
  for (  Var v : context.getArraysToClose()) {
    assert(v.defType() != DefType.INARG);
    assert(Types.isArray(v.type()));
    backend.decrWriters(v);
  }
  for (  Var v : context.getScopeVariables()) {
    if (v.storage() == VarStorage.STACK || v.storage() == VarStorage.TEMP) {
      backend.decrRef(v);
    }
  }
}","/** 
 * Make sure all arrays in block are closed upon exiting
 * @param context
 * @param closeArgs 
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void closeBlockVariables(Context context,boolean closeArgs) throws UndefinedTypeException, UserException {
  for (  Var v : context.getArraysToClose()) {
    assert(v.defType() != DefType.INARG);
    assert(Types.isArray(v.type()));
    backend.decrWriters(v);
  }
  for (  Var v : context.getScopeVariables()) {
    if (v.storage() == VarStorage.STACK || v.storage() == VarStorage.TEMP) {
      if (closeArgs && !(v.defType() == DefType.INARG || v.defType() == DefType.OUTARG)) {
        backend.decrRef(v);
      }
    }
  }
}",0.8888888888888888
133197,"/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,long iteration,long nIterations) throws UserException {
  OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
  pipe.addPass(new FunctionInline());
  pipe.addPass(new ConstantFold());
  if (iteration == 0) {
    pipe.addPass(new LoopUnroller());
  }
  pipe.addPass(new HoistLoops());
  pipe.addPass(new ForwardDataflow());
  pipe.addPass(new ContinuationFusion());
  if (iteration == nIterations - 2) {
    pipe.addPass(new Pipeline());
  }
  boolean doWaitMerges=(iteration == nIterations - 1);
  pipe.addPass(new WaitCoalescer(doWaitMerges));
  pipe.addPass(new Validate());
  pipe.runPipeline(logger,prog,iteration);
}","/** 
 * Do one iteration of the iterative optimizer passes
 * @param icOutput
 * @param logger
 * @param prog
 * @param iteration
 * @param nIterations
 * @throws Exception
 */
private static void iterate(PrintStream icOutput,Logger logger,Program prog,long iteration,long nIterations) throws UserException {
  OptimizerPipeline pipe=new OptimizerPipeline(icOutput);
  pipe.addPass(new FunctionInline());
  pipe.addPass(new ConstantFold());
  if (iteration == 0) {
    pipe.addPass(new LoopUnroller());
  }
  pipe.addPass(new HoistLoops());
  pipe.addPass(new ForwardDataflow());
  pipe.addPass(new ContinuationFusion());
  if (iteration == nIterations - 2) {
    pipe.addPass(new Pipeline());
    pipe.addPass(new Validate());
  }
  boolean doWaitMerges=(iteration == nIterations - 1);
  pipe.addPass(new WaitCoalescer(doWaitMerges));
  pipe.addPass(new Validate());
  pipe.runPipeline(logger,prog,iteration);
}",0.9810055865921788
133198,"@Override public void functionCall(String function,List<Var> inputs,List<Var> outputs,List<Boolean> blocking,TaskMode mode,Arg priority){
  assert(priority == null || priority.isImmediateInt());
  logger.debug(""String_Node_Str"" + function);
  TclList iList=TclUtil.tclListOfVariables(inputs);
  TclList oList=TclUtil.tclListOfVariables(outputs);
  ArrayList<Var> blockOn=new ArrayList<Var>();
  HashSet<String> alreadyBlocking=new HashSet<String>();
  for (int i=0; i < inputs.size(); i++) {
    Var v=inputs.get(i);
    if (blocking.get(i) && !alreadyBlocking.contains(v.name())) {
      blockOn.add(v);
      alreadyBlocking.add(v.name());
    }
  }
  setPriority(priority);
  if (mode == TaskMode.CONTROL || mode == TaskMode.LOCAL) {
    pointStack.peek().append(incrementReaders(outputs,null));
    pointStack.peek().append(incrementReaders(inputs,null));
    pointStack.peek().add(Turbine.callFunction(TclNamer.swiftFuncName(function),oList,iList,TclUtil.tclListOfVariables(blockOn)));
  }
 else   if (mode == TaskMode.SYNC) {
    assert(blocking.size() == 0);
    pointStack.peek().add(Turbine.callFunctionSync(TclNamer.swiftFuncName(function),oList,iList));
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + mode);
  }
  clearPriority(priority);
}","@Override public void functionCall(String function,List<Var> inputs,List<Var> outputs,List<Boolean> blocking,TaskMode mode,Arg priority){
}",0.197864768683274
133199,"public Type findArrayType(Context context) throws UserException {
  Type arrayType=TypeChecker.findSingleExprType(context,arrayVarTree);
  if (!Types.isArray(arrayType) && !Types.isArrayRef(arrayType)) {
    throw new TypeMismatchException(context,""String_Node_Str"");
  }
  return arrayType;
}","public Type findArrayType(Context context) throws UserException {
  Type arrayType=TypeChecker.findSingleExprType(context,arrayVarTree);
  for (  Type alt : UnionType.getAlternatives(arrayType)) {
    if (Types.isArray(alt) || Types.isArrayRef(alt)) {
      return alt;
    }
  }
  throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + arrayType.typeName());
}",0.6715758468335787
133200,"private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType)) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  ArrayList<Var> usedVars=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,new ArrayList<Var>(),WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(usedVars,new ArrayList<Var>());
  }
}","private void callFunction(Context context,String function,FunctionType concrete,List<Var> oList,List<Var> iList,Var priorityVal) throws UndefinedTypeException, UserException {
  ArrayList<Var> realIList=new ArrayList<Var>(iList.size());
  ArrayList<Var> derefVars=new ArrayList<Var>();
  ArrayList<Var> waitVars=new ArrayList<Var>();
  Context waitContext=null;
  assert(concrete.getInputs().size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Var input=iList.get(i);
    Type inputType=input.type();
    Type expType=concrete.getInputs().get(i);
    if (inputType.getImplType().equals(expType.getImplType())) {
      realIList.add(input);
    }
 else     if (Types.isRefTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Var derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      realIList.add(snapshotUpdateable(context,input));
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  ArrayList<Var> usedVars=null;
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    usedVars=new ArrayList<Var>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,new ArrayList<Var>(),WaitMode.DATA_ONLY,false,TaskMode.LOCAL);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Var derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).type())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  backendFunctionCall(context,function,oList,realIList,priorityVal);
  if (waitContext != null) {
    backend.endWaitStatement(usedVars,new ArrayList<Var>());
  }
}",0.9967948717948718
133201,"/** 
 * Check if an expression type can be used for function argument
 * @param argType non-polymorphic function argument type
 * @param exprType type of argument expression
 * @return true if compatible
 */
public static boolean compatibleArgTypes(Type argType,Type exprType){
  if (argType.assignableTo(exprType)) {
    return true;
  }
 else   if (Types.isRefTo(exprType,argType)) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Check if an expression type can be used for function argument
 * @param argType non-polymorphic function argument type
 * @param exprType type of argument expression
 * @return true if compatible
 */
public static boolean compatibleArgTypes(Type argType,Type exprType){
  if (exprType.assignableTo(argType)) {
    return true;
  }
 else   if (Types.isRefTo(exprType,argType)) {
    return true;
  }
 else {
    return false;
  }
}",0.9840182648401826
133202,"@Override public void addKeepOpenVars(Collection<Var> v){
  this.keepOpenVars.addAll(v);
}","@Override public void addKeepOpenVars(Collection<Var> v){
  super.addKeepOpenVars(v);
  this.loopContinue.removeKeepOpenVars(v);
  this.loopBreak.removeKeepOpenVars(v);
}",0.6307692307692307
133203,"protected void fuseIntoAbstract(AbstractLoop o,boolean insertAtTop){
  this.loopBody.insertInline(o.loopBody,insertAtTop);
  this.keepOpenVars.addAll(o.keepOpenVars);
  ICUtil.removeDuplicates(this.keepOpenVars);
  this.passedInVars.addAll(o.passedInVars);
  ICUtil.removeDuplicates(this.passedInVars);
}","protected void fuseIntoAbstract(AbstractLoop o,boolean insertAtTop){
  this.loopBody.insertInline(o.loopBody,insertAtTop);
  this.addKeepOpenVars(o.keepOpenVars);
  ICUtil.removeDuplicates(this.keepOpenVars);
  this.addPassedInVars(o.passedInVars);
  ICUtil.removeDuplicates(this.passedInVars);
}",0.9233333333333332
133204,"@Override public void addPassedInVars(Collection<Var> vars){
  assert(vars != null);
  this.passedInVars.addAll(vars);
}","@Override public void addPassedInVars(Collection<Var> vars){
  super.addPassedInVars(vars);
  this.loopContinue.removeUsedVars(vars);
  this.loopBreak.removeUsedVars(vars);
}",0.6122448979591837
133205,"@Override public void addKeepOpenVar(Var v){
  this.keepOpenVars.add(v);
}","@Override public void addKeepOpenVar(Var v){
  super.addKeepOpenVar(v);
  this.loopContinue.addKeepOpenVar(v);
  this.loopBreak.addKeepOpenVar(v);
}",0.6306306306306306
133206,"public void setLoopBreak(LoopBreak loopBreak){
}","public void setLoopBreak(LoopBreak loopBreak){
  this.loopBreak=loopBreak;
}",0.7741935483870968
133207,"public LoopBreak(List<Var> loopUsedVars,List<Var> varsToClose){
  super(Opcode.LOOP_BREAK);
  this.loopUsedVars=new ArrayList<Var>(loopUsedVars);
  this.varsToClose=new ArrayList<Var>(varsToClose);
}","public LoopBreak(List<Var> loopUsedVars,List<Var> varsToClose){
  super(Opcode.LOOP_BREAK);
  this.loopUsedVars=new ArrayList<Var>(loopUsedVars);
  this.keepOpenVars=new ArrayList<Var>(varsToClose);
}",0.9423558897243108
133208,"public LoopContinue(List<Var> newLoopVars,List<Var> usedVariables,List<Var> keepOpenVars,List<Boolean> blockingVars){
  super(Opcode.LOOP_CONTINUE);
  this.newLoopVars=new ArrayList<Var>(newLoopVars);
  this.usedVariables=new ArrayList<Var>(usedVariables);
  this.keepOpenVars=new ArrayList<Var>(keepOpenVars);
  this.blockingVars=new ArrayList<Boolean>(blockingVars);
}","public LoopContinue(List<Var> newLoopVars,List<Var> loopUsedVars,List<Var> keepOpenVars,List<Boolean> blockingVars){
  super(Opcode.LOOP_CONTINUE);
  this.newLoopVars=new ArrayList<Var>(newLoopVars);
  this.loopUsedVars=new ArrayList<Var>(loopUsedVars);
  this.keepOpenVars=new ArrayList<Var>(keepOpenVars);
  this.blockingVars=new ArrayList<Boolean>(blockingVars);
}",0.6567164179104478
133209,"public void removeUsedVar(Var variable){
  ICUtil.removeVarInList(usedVariables,variable.name());
}","public void removeUsedVar(Var variable){
  ICUtil.removeVarInList(loopUsedVars,variable.name());
}",0.9441624365482234
133210,"@Override public void removeVars(Set<String> removeVars){
  assert(!removeVars.contains(newLoopVars.get(0).name()));
  ICUtil.removeVarsInList(usedVariables,removeVars);
  ICUtil.removeVarsInList(keepOpenVars,removeVars);
  ICUtil.removeVarsInList(newLoopVars,removeVars);
}","@Override public void removeVars(Set<String> removeVars){
  assert(!removeVars.contains(newLoopVars.get(0).name()));
  ICUtil.removeVarsInList(loopUsedVars,removeVars);
  ICUtil.removeVarsInList(keepOpenVars,removeVars);
  ICUtil.removeVarsInList(newLoopVars,removeVars);
}",0.979890310786106
133211,"public void addUsedVar(Var variable){
  this.usedVariables.add(variable);
}","public void addUsedVar(Var variable){
  this.loopUsedVars.add(variable);
}",0.9261744966442952
133212,"@Override public void startLoop(String loopName,List<Var> loopVars,List<Var> initVals,List<Var> usedVariables,List<Var> keepOpenVars,List<Boolean> blockingVars){
  ArrayList<String> loopFnArgs=new ArrayList<String>();
  ArrayList<Value> firstIterArgs=new ArrayList<Value>();
  loopFnArgs.add(Turbine.LOCAL_STACK_NAME);
  firstIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var arg : loopVars) {
    loopFnArgs.add(prefixVar(arg.name()));
  }
  for (  Var init : initVals) {
    firstIterArgs.add(varToExpr(init));
  }
  for (  Var uv : usedVariables) {
    loopFnArgs.add(prefixVar(uv.name()));
    firstIterArgs.add(varToExpr(uv));
  }
  ArrayList<Value> blockingVals=new ArrayList<Value>();
  assert(blockingVars.size() == initVals.size());
  for (int i=0; i < blockingVars.size(); i++) {
    Var iv=initVals.get(i);
    if (blockingVars.get(i)) {
      blockingVals.add(varToExpr(iv));
    }
  }
  incrementAllRefs(usedVariables,keepOpenVars);
  String uniqueLoopName=uniqueTCLFunctionName(loopName);
  pointStack.peek().add(Turbine.loopRule(uniqueLoopName,firstIterArgs,blockingVals));
  Sequence loopBody=new Sequence();
  Proc loopProc=new Proc(uniqueLoopName,usedTclFunctionNames,loopFnArgs,loopBody);
  tree.add(loopProc);
  pointStack.push(loopBody);
  loopNameStack.push(uniqueLoopName);
}","@Override public void startLoop(String loopName,List<Var> loopVars,List<Var> initVals,List<Var> usedVariables,List<Var> keepOpenVars,List<Boolean> blockingVars){
  ArrayList<String> loopFnArgs=new ArrayList<String>();
  ArrayList<Value> firstIterArgs=new ArrayList<Value>();
  loopFnArgs.add(Turbine.LOCAL_STACK_NAME);
  firstIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var arg : loopVars) {
    loopFnArgs.add(prefixVar(arg.name()));
  }
  for (  Var init : initVals) {
    firstIterArgs.add(varToExpr(init));
  }
  for (  Var uv : usedVariables) {
    loopFnArgs.add(prefixVar(uv.name()));
    firstIterArgs.add(varToExpr(uv));
  }
  ArrayList<Value> blockingVals=new ArrayList<Value>();
  assert(blockingVars.size() == initVals.size());
  for (int i=0; i < blockingVars.size(); i++) {
    Var iv=initVals.get(i);
    if (blockingVars.get(i)) {
      blockingVals.add(varToExpr(iv));
    }
  }
  incrementAllRefs(usedVariables,keepOpenVars);
  pointStack.peek().append(incrementReaders(initVals,null));
  String uniqueLoopName=uniqueTCLFunctionName(loopName);
  pointStack.peek().add(Turbine.loopRule(uniqueLoopName,firstIterArgs,blockingVals));
  Sequence loopBody=new Sequence();
  Proc loopProc=new Proc(uniqueLoopName,usedTclFunctionNames,loopFnArgs,loopBody);
  tree.add(loopProc);
  pointStack.push(loopBody);
  loopNameStack.push(uniqueLoopName);
}",0.9772811918063314
133213,"@Override public void loopContinue(List<Var> newVals,List<Var> usedVariables,List<Var> registeredContainers,List<Boolean> blockingVars){
  ArrayList<Value> nextIterArgs=new ArrayList<Value>();
  String loopName=loopNameStack.peek();
  nextIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var v : newVals) {
    nextIterArgs.add(varToExpr(v));
  }
  for (  Var v : usedVariables) {
    nextIterArgs.add(varToExpr(v));
  }
  ArrayList<Value> blockingVals=new ArrayList<Value>();
  assert(newVals.size() == blockingVars.size());
  for (int i=0; i < newVals.size(); i++) {
    if (blockingVars.get(i)) {
      blockingVals.add(varToExpr(newVals.get(i)));
    }
  }
  pointStack.peek().add(Turbine.loopRule(loopName,nextIterArgs,blockingVals));
}","@Override public void loopContinue(List<Var> newVals,List<Var> usedVariables,List<Var> registeredContainers,List<Boolean> blockingVars){
  ArrayList<Value> nextIterArgs=new ArrayList<Value>();
  String loopName=loopNameStack.peek();
  nextIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var v : newVals) {
    nextIterArgs.add(varToExpr(v));
  }
  for (  Var v : usedVariables) {
    nextIterArgs.add(varToExpr(v));
  }
  ArrayList<Value> blockingVals=new ArrayList<Value>();
  assert(newVals.size() == blockingVars.size());
  for (int i=0; i < newVals.size(); i++) {
    if (blockingVars.get(i)) {
      blockingVals.add(varToExpr(newVals.get(i)));
    }
  }
  pointStack.peek().append(incrementReaders(newVals,null));
  pointStack.peek().add(Turbine.loopRule(loopName,nextIterArgs,blockingVals));
}",0.9616368286445012
133214,"/** 
 * Union of lists with one instance of each variable by name included in result
 * @param lists
 * @return
 */
public static List<Var> varListUnion(List<Var> list1,List<Var> list2){
  ArrayList<Var> res=new ArrayList<Var>();
  Set<String> present=new HashSet<String>();
  for (  Var v : list1) {
    if (!present.contains(v.name())) {
      res.add(v);
    }
  }
  for (  Var v : list2) {
    if (!present.contains(v.name())) {
      res.add(v);
    }
  }
  return res;
}","/** 
 * Union of lists with one instance of each variable by name included in result
 * @param list1
 * @param list2
 * @return
 */
public static List<Var> varListUnion(List<Var> list1,List<Var> list2){
  ArrayList<Var> res=new ArrayList<Var>();
  Set<String> present=new HashSet<String>();
  for (  Var v : list1) {
    if (!present.contains(v.name())) {
      res.add(v);
    }
  }
  for (  Var v : list2) {
    if (!present.contains(v.name())) {
      res.add(v);
    }
  }
  return res;
}",0.981404958677686
133215,"/** 
 * Increment readers by a TODO: handle struct and file vars
 * @param vars
 * @param incr expression for the amount of increment/decrement.  If null, assume 1
 * @param if true, then negate incr
 * @return
 */
private static Sequence incrementReaders(List<Var> vars,Expression incr,boolean negate){
  Sequence seq=new Sequence();
  for (  VarCount vc : Var.countVars(vars)) {
    Var var=vc.var;
    if (!hasRefcount(var)) {
      continue;
    }
    Expression amount;
    if (vc.count == 1 && incr == null) {
      amount=null;
    }
 else     if (incr == null) {
      amount=new LiteralInt(vc.count);
    }
 else     if (vc.count == 1 && incr != null) {
      amount=incr;
    }
 else {
      amount=Square.arithExpr(new LiteralInt(vc.count),new Token(""String_Node_Str""),incr);
    }
    if (Types.isFile(var.type())) {
      if (negate) {
        seq.add(Turbine.decrFileRef(varToExpr(var),amount));
      }
 else {
        seq.add(Turbine.incrFileRef(varToExpr(var),amount));
      }
    }
 else     if (Types.isStruct(var.type())) {
    }
 else {
      if (negate) {
        seq.add(Turbine.decrRef(varToExpr(var),amount));
      }
 else {
        seq.add(Turbine.incrRef(varToExpr(var),amount));
      }
    }
  }
  return seq;
}","/** 
 * Increment readers by a TODO: handle struct and file vars
 * @param vars
 * @param incr expression for the amount of increment/decrement.  If null, assume 1
 * @param negate if true, then negate incr
 * @return
 */
private static Sequence incrementReaders(List<Var> vars,Expression incr,boolean negate){
  Sequence seq=new Sequence();
  for (  VarCount vc : Var.countVars(vars)) {
    Var var=vc.var;
    if (!hasRefcount(var)) {
      continue;
    }
    Expression amount;
    if (vc.count == 1 && incr == null) {
      amount=null;
    }
 else     if (incr == null) {
      amount=new LiteralInt(vc.count);
    }
 else     if (vc.count == 1 && incr != null) {
      amount=incr;
    }
 else {
      amount=Square.arithExpr(new LiteralInt(vc.count),new Token(""String_Node_Str""),incr);
    }
    if (Types.isFile(var.type())) {
      if (negate) {
        seq.add(Turbine.decrFileRef(varToExpr(var),amount));
      }
 else {
        seq.add(Turbine.incrFileRef(varToExpr(var),amount));
      }
    }
 else     if (Types.isStruct(var.type())) {
    }
 else {
      if (negate) {
        seq.add(Turbine.decrRef(varToExpr(var),amount));
      }
 else {
        seq.add(Turbine.incrRef(varToExpr(var),amount));
      }
    }
  }
  return seq;
}",0.9971898835808912
133216,"/** 
 * Evaluates expression, creating temporary output variable if needed
 * @param type expected result type of expression
 * @return return the name of a newly created tmp variable
 * @throws UserException
 */
public Var eval(Context context,SwiftAST tree,Type type,boolean storeInStack,Map<String,String> renames) throws UserException {
  assert(type != null);
  context.syncFilePos(tree,lineMapping);
  if (tree.getType() == ExMParser.VARIABLE) {
    String varName=tree.child(0).getText();
    if (renames != null && renames.containsKey(varName)) {
      varName=renames.get(varName);
    }
    Var var=context.getDeclaredVariable(varName);
    if (var == null) {
      throw new UndefinedVariableException(context,""String_Node_Str"" + varName + ""String_Node_Str"");
    }
    if (var.storage() == VarStorage.STACK || (!storeInStack) && var.type().equals(type)) {
      return var;
    }
  }
  if (tree.getType() == ExMParser.STRUCT_LOAD && Types.isStruct(TypeChecker.findSingleExprType(context,tree.child(0)))) {
    return lookupStructField(context,tree,type,storeInStack,null,renames);
  }
 else {
    Var tmp=varCreator.createTmp(context,type,storeInStack,false);
    ArrayList<Var> childOList=new ArrayList<Var>(1);
    childOList.add(tmp);
    evalToVars(context,tree,childOList,renames);
    return tmp;
  }
}","/** 
 * Evaluates expression, creating temporary output variable if needed
 * @param type expected result type of expression
 * @return return the name of a newly created tmp variable
 * @throws UserException
 */
public Var eval(Context context,SwiftAST tree,Type type,boolean storeInStack,Map<String,String> renames) throws UserException {
  assert(type != null);
  context.syncFilePos(tree,lineMapping);
  if (tree.getType() == ExMParser.VARIABLE) {
    String varName=tree.child(0).getText();
    if (renames != null && renames.containsKey(varName)) {
      varName=renames.get(varName);
    }
    Var var=context.getDeclaredVariable(varName);
    if (var == null) {
      throw new UndefinedVariableException(context,""String_Node_Str"" + varName + ""String_Node_Str"");
    }
    if ((var.storage() == VarStorage.STACK || (!storeInStack)) && var.type().equals(type)) {
      return var;
    }
  }
  if (tree.getType() == ExMParser.STRUCT_LOAD && Types.isStruct(TypeChecker.findSingleExprType(context,tree.child(0)))) {
    return lookupStructField(context,tree,type,storeInStack,null,renames);
  }
 else {
    Var tmp=varCreator.createTmp(context,type,storeInStack,false);
    ArrayList<Var> childOList=new ArrayList<Var>(1);
    childOList.add(tmp);
    evalToVars(context,tree,childOList,renames);
    return tmp;
  }
}",0.9992429977289932
133217,"public static Command stringSet(String turbineDstVar,Expression src){
  return new Command(STORE_STRING,new Value(turbineDstVar),src);
}","public static Command stringSet(Value turbineDstVar,Expression src){
  return new Command(STORE_STRING,turbineDstVar,src);
}",0.9153846153846154
133218,"public static Command integerSet(String turbineDstVar,Expression src){
  return new Command(STORE_INTEGER,new Value(turbineDstVar),src);
}","public static Command integerSet(Value turbineDstVar,Expression src){
  return new Command(STORE_INTEGER,turbineDstVar,src);
}",0.9166666666666666
133219,"public static Command floatSet(String turbineDstVar,Expression src){
  Value t=new Value(turbineDstVar);
  Command c=new Command(STORE_FLOAT,t,src);
  return c;
}","public static Command floatSet(Value turbineDstVar,Expression src){
  return new Command(STORE_FLOAT,turbineDstVar,src);
}",0.7323943661971831
133220,"@Override public void assignInt(Var target,Arg src){
  assert(src.isImmediateInt());
  if (!Types.isInt(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.integerSet(prefixVar(target.name()),opargToExpr(src)));
}","@Override public void assignInt(Var target,Arg src){
  assert(src.isImmediateInt());
  if (!Types.isInt(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.integerSet(varToExpr(target),opargToExpr(src)));
}",0.9141004862236628
133221,"@Override public void initUpdateable(Var updateable,Arg val){
  assert(Types.isScalarUpdateable(updateable.type()));
  if (!updateable.type().equals(Types.UP_FLOAT)) {
    throw new STCRuntimeError(updateable.type() + ""String_Node_Str"");
  }
  assert(val.isImmediateFloat());
  pointStack.peek().add(Turbine.floatSet(prefixVar(updateable.name()),opargToExpr(val)));
}","@Override public void initUpdateable(Var updateable,Arg val){
  assert(Types.isScalarUpdateable(updateable.type()));
  if (!updateable.type().equals(Types.UP_FLOAT)) {
    throw new STCRuntimeError(updateable.type() + ""String_Node_Str"");
  }
  assert(val.isImmediateFloat());
  pointStack.peek().add(Turbine.updateableFloatInit(varToExpr(updateable),opargToExpr(val)));
}",0.8780487804878049
133222,"@Override public void assignString(Var target,Arg src){
  assert(src.isImmediateString());
  if (!Types.isString(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.stringSet(prefixVar(target.name()),opargToExpr(src)));
}","@Override public void assignString(Var target,Arg src){
  assert(src.isImmediateString());
  if (!Types.isString(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.stringSet(varToExpr(target),opargToExpr(src)));
}",0.9162717219589256
133223,"/** 
 * Set target=addressof(src)
 */
@Override public void assignReference(Var target,Var src){
  assert(Types.isRef(target.type()));
  assert(target.type().memberType().equals(src.type()));
  if (refIsString(target.type())) {
    pointStack.peek().add(Turbine.stringSet(prefixVar(target.name()),varToExpr(src)));
  }
 else {
    pointStack.peek().add(Turbine.integerSet(prefixVar(target.name()),varToExpr(src)));
  }
}","/** 
 * Set target=addressof(src)
 */
@Override public void assignReference(Var target,Var src){
  assert(Types.isRef(target.type()));
  assert(target.type().memberType().equals(src.type()));
  if (refIsString(target.type())) {
    pointStack.peek().add(Turbine.stringSet(varToExpr(target),varToExpr(src)));
  }
 else {
    pointStack.peek().add(Turbine.integerSet(varToExpr(target),varToExpr(src)));
  }
}",0.7433414043583535
133224,"@Override public void assignBool(Var target,Arg src){
  assert(src.isImmediateBool());
  if (!Types.isBool(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.integerSet(prefixVar(target.name()),opargToExpr(src)));
}","@Override public void assignBool(Var target,Arg src){
  assert(src.isImmediateBool());
  if (!Types.isBool(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.integerSet(varToExpr(target),opargToExpr(src)));
}",0.9149277688603532
133225,"@Override public void addGlobal(String name,Arg val){
  String tclName=prefixVar(name);
  globInit.add(Turbine.makeTCLGlobal(tclName));
  String typePrefix;
  Expression expr;
  Command setCmd;
switch (val.getKind()) {
case INTVAL:
    typePrefix=Turbine.INTEGER_TYPENAME;
  expr=new LiteralInt(val.getIntLit());
setCmd=Turbine.integerSet(tclName,expr);
break;
case FLOATVAL:
typePrefix=Turbine.FLOAT_TYPENAME;
expr=new LiteralFloat(val.getFloatLit());
setCmd=Turbine.floatSet(tclName,expr);
break;
case STRINGVAL:
typePrefix=Turbine.STRING_TYPENAME;
expr=new TclString(val.getStringLit(),true);
setCmd=Turbine.stringSet(tclName,expr);
break;
case BOOLVAL:
typePrefix=Turbine.INTEGER_TYPENAME;
expr=new LiteralInt(val.getBoolLit() ? 1 : 0);
setCmd=Turbine.integerSet(tclName,expr);
break;
default :
throw new STCRuntimeError(""String_Node_Str"" + val.getKind());
}
globInit.add(Turbine.allocate(tclName,typePrefix,false));
globInit.add(setCmd);
}","@Override public void addGlobal(String name,Arg val){
  String tclName=prefixVar(name);
  Value tclVal=new Value(tclName);
  globInit.add(Turbine.makeTCLGlobal(tclName));
  String typePrefix;
  Expression expr;
  Command setCmd;
switch (val.getKind()) {
case INTVAL:
    typePrefix=Turbine.INTEGER_TYPENAME;
  expr=new LiteralInt(val.getIntLit());
setCmd=Turbine.integerSet(tclVal,expr);
break;
case FLOATVAL:
typePrefix=Turbine.FLOAT_TYPENAME;
expr=new LiteralFloat(val.getFloatLit());
setCmd=Turbine.floatSet(tclVal,expr);
break;
case STRINGVAL:
typePrefix=Turbine.STRING_TYPENAME;
expr=new TclString(val.getStringLit(),true);
setCmd=Turbine.stringSet(tclVal,expr);
break;
case BOOLVAL:
typePrefix=Turbine.INTEGER_TYPENAME;
expr=new LiteralInt(val.getBoolLit() ? 1 : 0);
setCmd=Turbine.integerSet(tclVal,expr);
break;
default :
throw new STCRuntimeError(""String_Node_Str"" + val.getKind());
}
globInit.add(Turbine.allocate(tclName,typePrefix,false));
globInit.add(setCmd);
}",0.9671704012506512
133226,"@Override public void assignFloat(Var target,Arg src){
  assert(src.isImmediateFloat());
  if (!Types.isFloat(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.floatSet(prefixVar(target.name()),opargToExpr(src)));
}","@Override public void assignFloat(Var target,Arg src){
  assert(src.isImmediateFloat());
  if (!Types.isFloat(target.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + target.type().toString());
  }
  pointStack.peek().add(Turbine.floatSet(varToExpr(target),opargToExpr(src)));
}",0.9152
133227,"/** 
 * Generate and return Tcl from our internal TclTree
 */
@Override public String code(){
  StringBuilder sb=new StringBuilder(10 * 1024);
  try {
    tree.appendTo(sb);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    System.out.println(e.getMessage());
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
    System.out.println(sb);
    System.out.println(""String_Node_Str"");
    System.exit(ExitCode.ERROR_INTERNAL.code());
  }
  return sb.toString();
}","/** 
 * Generate and return Tcl from  our internal TclTree
 */
@Override public String code(){
  StringBuilder sb=new StringBuilder(10 * 1024);
  try {
    tree.appendTo(sb);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    System.out.println(e.getMessage());
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
    System.out.println(sb);
    System.out.println(""String_Node_Str"");
    System.exit(ExitCode.ERROR_INTERNAL.code());
  }
  return sb.toString();
}",0.9990069513406156
133228,"/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,Expression startE,Expression endE,Expression incrE){
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : usedVariables) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : usedVariables) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVariables,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().append(incrementWriters(keepOpenVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(splitDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",splitDegree,TCLTMP_ITERSLEFT,splitDegree)))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL));
  pointStack.push(inner);
}","/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,Expression startE,Expression endE,Expression incrE){
  List<Var> allUsedVars=Var.varListUnion(usedVariables,keepOpenVars);
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : allUsedVars) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : allUsedVars) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVariables,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().append(incrementWriters(keepOpenVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(splitDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",splitDegree,TCLTMP_ITERSLEFT,splitDegree)))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL));
  pointStack.push(inner);
}",0.9831955188050148
133229,"/** 
 * @param arrayVar
 * @param memberVar
 * @param loopCountVar counter variable, can be null
 * @param splitDegree
 * @param arrayClosed if true, assume array is already closed
 * @param usedVariables
 * @param keepOpenVars
 */
public abstract void startForeachLoop(Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars);","/** 
 * @param loopName unique name for loop
 * @param arrayVar
 * @param memberVar
 * @param loopCountVar counter variable, can be null
 * @param splitDegree
 * @param arrayClosed if true, assume array is already closed
 * @param usedVariables
 * @param keepOpenVars
 */
public abstract void startForeachLoop(String loopName,Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars);",0.9342723004694836
133230,"/** 
 * Handle the special case of a foreach loop where we are looping over range specified by two or three integer parameters
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachRange(Context context,ForeachLoop loop) throws UserException {
  ArrayRange range=ArrayRange.fromAST(context,loop.getArrayVarTree());
  range.typeCheck(context);
  Var start=exprWalker.eval(context,range.getStart(),Types.F_INT,false,null);
  Var end=exprWalker.eval(context,range.getEnd(),Types.F_INT,false,null);
  Var step;
  if (range.getStep() != null) {
    step=exprWalker.eval(context,range.getStep(),Types.F_INT,false,null);
  }
 else {
    step=varCreator.createTmp(context,Types.F_INT);
    backend.assignInt(step,Arg.createIntLit(1));
  }
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  ArrayList<Var> waitUsedVariables=new ArrayList<Var>(usedVariables);
  waitUsedVariables.addAll(Arrays.asList(start,end,step));
  backend.startWaitStatement(""String_Node_Str"" + loopNum,Arrays.asList(start,end,step),waitUsedVariables,keepOpenVars,WaitMode.DATA_ONLY,TaskMode.LOCAL);
  Context waitContext=new LocalContext(context);
  Var startVal=varCreator.fetchValueOf(waitContext,start);
  Var endVal=varCreator.fetchValueOf(waitContext,end);
  Var stepVal=varCreator.fetchValueOf(waitContext,step);
  Context bodyContext=loop.setupLoopBodyContext(waitContext);
  Var memberVal=varCreator.createValueOfVar(bodyContext,loop.getMemberVar(),false);
  Var counterVal=loop.getLoopCountVal();
  backend.startRangeLoop(""String_Node_Str"" + loopNum,memberVal,counterVal,Arg.createVar(startVal),Arg.createVar(endVal),Arg.createVar(stepVal),usedVariables,keepOpenVars,loop.getDesiredUnroll(),loop.getSplitDegree());
  List<Var> waitUsedVars=null;
  if (!loop.isSyncLoop()) {
    waitUsedVars=new ArrayList<Var>(usedVariables);
    waitUsedVars.add(memberVal);
    backend.startWaitStatement(""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),waitUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,TaskMode.CONTROL);
  }
  varCreator.initialiseVariable(bodyContext,loop.getMemberVar());
  backend.assignInt(loop.getMemberVar(),Arg.createVar(memberVal));
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(bodyContext,Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(counterVal));
  }
  block(bodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(waitUsedVars,keepOpenVars);
  }
  backend.endRangeLoop(usedVariables,keepOpenVars,loop.getSplitDegree());
  backend.endWaitStatement(usedVariables,keepOpenVars);
}","/** 
 * Handle the special case of a foreach loop where we are looping over range specified by two or three integer parameters
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachRange(Context context,ForeachLoop loop) throws UserException {
  ArrayRange range=ArrayRange.fromAST(context,loop.getArrayVarTree());
  range.typeCheck(context);
  Var start=exprWalker.eval(context,range.getStart(),Types.F_INT,false,null);
  Var end=exprWalker.eval(context,range.getEnd(),Types.F_INT,false,null);
  Var step;
  if (range.getStep() != null) {
    step=exprWalker.eval(context,range.getStep(),Types.F_INT,false,null);
  }
 else {
    step=varCreator.createTmp(context,Types.F_INT);
    backend.assignInt(step,Arg.createIntLit(1));
  }
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  ArrayList<Var> waitUsedVariables=new ArrayList<Var>(usedVariables);
  waitUsedVariables.addAll(Arrays.asList(start,end,step));
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(start,end,step),waitUsedVariables,keepOpenVars,WaitMode.DATA_ONLY,TaskMode.LOCAL);
  Context waitContext=new LocalContext(context);
  Var startVal=varCreator.fetchValueOf(waitContext,start);
  Var endVal=varCreator.fetchValueOf(waitContext,end);
  Var stepVal=varCreator.fetchValueOf(waitContext,step);
  Context bodyContext=loop.setupLoopBodyContext(waitContext);
  Var memberVal=varCreator.createValueOfVar(bodyContext,loop.getMemberVar(),false);
  Var counterVal=loop.getLoopCountVal();
  backend.startRangeLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,memberVal,counterVal,Arg.createVar(startVal),Arg.createVar(endVal),Arg.createVar(stepVal),usedVariables,keepOpenVars,loop.getDesiredUnroll(),loop.getSplitDegree());
  List<Var> waitUsedVars=null;
  if (!loop.isSyncLoop()) {
    waitUsedVars=new ArrayList<Var>(usedVariables);
    waitUsedVars.add(memberVal);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),waitUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,TaskMode.CONTROL);
  }
  varCreator.initialiseVariable(bodyContext,loop.getMemberVar());
  backend.assignInt(loop.getMemberVar(),Arg.createVar(memberVal));
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(bodyContext,Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(counterVal));
  }
  block(bodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(waitUsedVars,keepOpenVars);
  }
  backend.endRangeLoop(usedVariables,keepOpenVars,loop.getSplitDegree());
  backend.endWaitStatement(usedVariables,keepOpenVars);
}",0.9886494489225202
133231,"/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,TaskMode.LOCAL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.constructName(""String_Node_Str""),Arrays.asList(realArray),waitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,TaskMode.LOCAL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.constructName(""String_Node_Str""),Collections.<Var>emptyList(),iterUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  block(loopBodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(arrRefWaitUsedVars,keepOpenVars);
  }
}","/** 
 * Handle the general foreach loop where we are looping over array
 * @param context
 * @param loop
 * @throws UserException
 * @throws UndefinedTypeException
 */
private void foreachArray(Context context,ForeachLoop loop) throws UserException, UndefinedTypeException {
  Var arrayVar=exprWalker.eval(context,loop.getArrayVarTree(),loop.findArrayType(context),true,null);
  ArrayList<Var> usedVariables=new ArrayList<Var>();
  ArrayList<Var> keepOpenVars=new ArrayList<Var>();
  VariableUsageInfo bodyVU=loop.getBody().checkedGetVariableUsage();
  summariseBranchVariableUsage(context,Arrays.asList(bodyVU),usedVariables,keepOpenVars);
  for (  Var v : keepOpenVars) {
    if (v.name().equals(arrayVar.name())) {
      throw new STCRuntimeError(""String_Node_Str"" + v.name() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  FunctionContext fc=context.getFunctionContext();
  int loopNum=fc.getCounterVal(""String_Node_Str"");
  Var realArray;
  Context outsideLoopContext;
  ArrayList<Var> arrRefWaitUsedVars=null;
  if (Types.isArrayRef(arrayVar.type())) {
    arrRefWaitUsedVars=new ArrayList<Var>(usedVariables);
    arrRefWaitUsedVars.add(arrayVar);
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(arrayVar),arrRefWaitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,TaskMode.LOCAL);
    outsideLoopContext=new LocalContext(context);
    realArray=varCreator.createTmp(outsideLoopContext,arrayVar.type().memberType(),false,true);
    backend.retrieveRef(realArray,arrayVar);
  }
 else {
    realArray=arrayVar;
    outsideLoopContext=context;
  }
  ArrayList<Var> waitUsedVars=new ArrayList<Var>(usedVariables);
  waitUsedVars.add(realArray);
  backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Arrays.asList(realArray),waitUsedVars,keepOpenVars,WaitMode.DATA_ONLY,TaskMode.LOCAL);
  loop.setupLoopBodyContext(outsideLoopContext);
  Context loopBodyContext=loop.getBodyContext();
  backend.startForeachLoop(fc.getFunctionName() + ""String_Node_Str"" + loopNum,realArray,loop.getMemberVar(),loop.getLoopCountVal(),loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  ArrayList<Var> iterUsedVars=null;
  if (!loop.isSyncLoop()) {
    iterUsedVars=new ArrayList<Var>(usedVariables);
    if (loop.getLoopCountVal() != null)     iterUsedVars.add(loop.getLoopCountVal());
    backend.startWaitStatement(fc.getFunctionName() + ""String_Node_Str"" + loopNum,Collections.<Var>emptyList(),iterUsedVars,keepOpenVars,WaitMode.TASK_DISPATCH,TaskMode.CONTROL);
  }
  if (loop.getCountVarName() != null) {
    Var loopCountVar=varCreator.createVariable(loop.getBodyContext(),Types.F_INT,loop.getCountVarName(),VarStorage.STACK,DefType.LOCAL_USER,null);
    backend.assignInt(loopCountVar,Arg.createVar(loop.getLoopCountVal()));
  }
  block(loopBodyContext,loop.getBody());
  if (!loop.isSyncLoop()) {
    backend.endWaitStatement(iterUsedVars,keepOpenVars);
  }
  backend.endForeachLoop(loop.getSplitDegree(),true,usedVariables,keepOpenVars);
  backend.endWaitStatement(waitUsedVars,keepOpenVars);
  if (Types.isArrayRef(arrayVar.type())) {
    backend.endWaitStatement(arrRefWaitUsedVars,keepOpenVars);
  }
}",0.9668109668109668
133232,"private void copyArrayByValue(Context context,Var dst,Var src) throws UserException {
  assert(dst.type().equals(src.type()));
  assert(Types.isArray(src.type()));
  LocalContext copyContext=new LocalContext(context);
  Type t=src.type();
  Type memType=Types.getArrayMemberType(t);
  Var member=copyContext.createAliasVariable(memType);
  Var ix=copyContext.createLocalValueVariable(Types.V_INT);
  List<Var> keepOpen=Arrays.asList(dst);
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,keepOpen,WaitMode.DATA_ONLY,TaskMode.LOCAL);
  backend.startForeachLoop(src,member,ix,-1,true,usedVars,keepOpen);
  backend.arrayInsertImm(member,dst,Arg.createVar(ix));
  backend.endForeachLoop(-1,true,usedVars,keepOpen);
  backend.decrWriters(dst);
  backend.endWaitStatement(usedVars,keepOpen);
}","private void copyArrayByValue(Context context,Var dst,Var src) throws UserException {
  assert(dst.type().equals(src.type()));
  assert(Types.isArray(src.type()));
  LocalContext copyContext=new LocalContext(context);
  Type t=src.type();
  Type memType=Types.getArrayMemberType(t);
  Var member=copyContext.createAliasVariable(memType);
  Var ix=copyContext.createLocalValueVariable(Types.V_INT);
  List<Var> keepOpen=Arrays.asList(dst);
  List<Var> usedVars=Arrays.asList(src,dst);
  backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(src),usedVars,keepOpen,WaitMode.DATA_ONLY,TaskMode.LOCAL);
  backend.startForeachLoop(context.getFunctionContext().constructName(""String_Node_Str""),src,member,ix,-1,true,usedVars,keepOpen);
  backend.arrayInsertImm(member,dst,Arg.createVar(ix));
  backend.endForeachLoop(-1,true,usedVars,keepOpen);
  backend.decrWriters(dst);
  backend.endWaitStatement(usedVars,keepOpen);
}",0.9667738478027867
133233,"@Override public void startForeachLoop(Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  if (!Types.isArray(arrayVar.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + arrayVar.toString());
  }
  assert(arrayVar.type().memberType().equals(memberVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  ForeachLoop loop=new ForeachLoop(arrayVar,memberVar,loopCountVar,splitDegree,arrayClosed,usedVariables,keepOpenVars);
  currBlock().addContinuation(loop);
  blockStack.push(loop.getLoopBody());
}","@Override public void startForeachLoop(String loopName,Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  if (!Types.isArray(arrayVar.type())) {
    throw new STCRuntimeError(""String_Node_Str"" + arrayVar.toString());
  }
  assert(arrayVar.type().memberType().equals(memberVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  ForeachLoop loop=new ForeachLoop(loopName,arrayVar,memberVar,loopCountVar,splitDegree,arrayClosed,usedVariables,keepOpenVars);
  currBlock().addContinuation(loop);
  blockStack.push(loop.getLoopBody());
}",0.9802994483845549
133234,"public ForeachLoop(Var arrayVar,Var loopVar,Var loopCounterVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  this(new Block(BlockType.FOREACH_BODY),arrayVar,loopVar,loopCounterVar,splitDegree,arrayClosed,usedVariables,keepOpenVars);
}","public ForeachLoop(String loopName,Var arrayVar,Var loopVar,Var loopCounterVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  this(loopName,new Block(BlockType.FOREACH_BODY),arrayVar,loopVar,loopCounterVar,splitDegree,arrayClosed,usedVariables,keepOpenVars);
}",0.9565217391304348
133235,"@Override public void startForeachLoop(Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  assert(Types.isArray(arrayVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  int foreach_num=foreach_counter++;
  String procName=""String_Node_Str"" + foreach_num;
  if (!arrayClosed) {
    ArrayList<Var> passIn=new ArrayList<Var>(usedVariables);
    if (!passIn.contains(arrayVar)) {
      passIn.add(arrayVar);
    }
    startAsync(procName,Arrays.asList(arrayVar),passIn,keepOpenVars,false);
  }
  boolean haveKeys=loopCountVar != null;
  String contentsVar=TCLTMP_ARRAY_CONTENTS;
  if (splitDegree <= 0) {
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys));
  }
 else {
    pointStack.peek().add(Turbine.containerSize(TCLTMP_CONTAINER_SIZE,varToExpr(arrayVar)));
    Expression lastIndex=Square.arithExpr(new Value(TCLTMP_CONTAINER_SIZE),new Token(""String_Node_Str""),new LiteralInt(1));
    ArrayList<Var> splitUsedVars=new ArrayList<Var>(usedVariables);
    splitUsedVars.add(arrayVar);
    startRangeSplit(procName,splitUsedVars,keepOpenVars,splitDegree,new LiteralInt(0),lastIndex,new LiteralInt(1));
    pointStack.peek().add(new SetVariable(TCLTMP_SPLITLEN,Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,TCLTMP_RANGE_LO)))));
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys,new Value(TCLTMP_SPLITLEN),TCLTMP_RANGE_LO_V));
  }
  startForeachInner(new Value(contentsVar),memberVar,loopCountVar,true,usedVariables,keepOpenVars,foreach_num);
}","@Override public void startForeachLoop(String loopName,Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  assert(Types.isArray(arrayVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  int foreach_num=foreach_counter++;
  String procName=""String_Node_Str"" + foreach_num;
  if (!arrayClosed) {
    ArrayList<Var> passIn=new ArrayList<Var>(usedVariables);
    if (!passIn.contains(arrayVar)) {
      passIn.add(arrayVar);
    }
    startAsync(procName,Arrays.asList(arrayVar),passIn,keepOpenVars,false);
  }
  boolean haveKeys=loopCountVar != null;
  String contentsVar=TCLTMP_ARRAY_CONTENTS;
  if (splitDegree <= 0) {
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys));
  }
 else {
    pointStack.peek().add(Turbine.containerSize(TCLTMP_CONTAINER_SIZE,varToExpr(arrayVar)));
    Expression lastIndex=Square.arithExpr(new Value(TCLTMP_CONTAINER_SIZE),new Token(""String_Node_Str""),new LiteralInt(1));
    ArrayList<Var> splitUsedVars=new ArrayList<Var>(usedVariables);
    splitUsedVars.add(arrayVar);
    startRangeSplit(procName,splitUsedVars,keepOpenVars,splitDegree,new LiteralInt(0),lastIndex,new LiteralInt(1));
    pointStack.peek().add(new SetVariable(TCLTMP_SPLITLEN,Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,TCLTMP_RANGE_LO)))));
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys,new Value(TCLTMP_SPLITLEN),TCLTMP_RANGE_LO_V));
  }
  startForeachInner(new Value(contentsVar),memberVar,loopCountVar,true,usedVariables,keepOpenVars,foreach_num);
}",0.995243757431629
133236,"private void startForeachInner(Value arrayContents,Var memberVar,Var loopCountVar,List<Var> usedVariables,List<Var> keepOpenVars,int foreach_num){
  Sequence curr=pointStack.peek();
  boolean haveKeys=loopCountVar != null;
  Sequence loopBody=new Sequence();
  String tclMemberVar=prefixVar(memberVar.name());
  String tclCountVar=haveKeys ? prefixVar(loopCountVar.name()) : null;
  Sequence tclLoop;
  if (haveKeys) {
    tclLoop=new DictFor(new Token(tclCountVar),new Token(tclMemberVar),arrayContents,loopBody);
  }
 else {
    tclLoop=new ForEach(new Token(tclMemberVar),arrayContents,loopBody);
  }
  curr.add(tclLoop);
  pointStack.push(loopBody);
}","private void startForeachInner(Value arrayContents,Var memberVar,Var loopCountVar,List<Var> usedVariables,List<Var> keepOpenVars){
  Sequence curr=pointStack.peek();
  boolean haveKeys=loopCountVar != null;
  Sequence loopBody=new Sequence();
  String tclMemberVar=prefixVar(memberVar.name());
  String tclCountVar=haveKeys ? prefixVar(loopCountVar.name()) : null;
  Sequence tclLoop;
  if (haveKeys) {
    tclLoop=new DictFor(new Token(tclCountVar),new Token(tclMemberVar),arrayContents,loopBody);
  }
 else {
    tclLoop=new ForEach(new Token(tclMemberVar),arrayContents,loopBody);
  }
  curr.add(tclLoop);
  pointStack.push(loopBody);
}",0.9876352395672334
133237,"/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,Expression startE,Expression endE,Expression incrE){
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : usedVariables) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : usedVariables) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=loopName + ""String_Node_Str"";
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=loopName + ""String_Node_Str"";
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVariables,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().append(incrementWriters(keepOpenVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(splitDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",splitDegree,TCLTMP_ITERSLEFT,splitDegree)))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL));
  pointStack.push(inner);
}","/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,Expression startE,Expression endE,Expression incrE){
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : usedVariables) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : usedVariables) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVariables,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().append(incrementWriters(keepOpenVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(splitDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",splitDegree,TCLTMP_ITERSLEFT,splitDegree)))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL));
  pointStack.push(inner);
}",0.9937720010831302
133238,"@Override public void startForeachLoop(Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  assert(Types.isArray(arrayVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  if (!arrayClosed) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
  int foreach_num=foreach_counter++;
  String procName=""String_Node_Str"" + foreach_num;
  if (!arrayClosed) {
    ArrayList<Var> passIn=new ArrayList<Var>(usedVariables);
    if (!passIn.contains(arrayVar)) {
      passIn.add(arrayVar);
    }
    startAsync(procName,Arrays.asList(arrayVar),passIn,keepOpenVars,TaskMode.LOCAL);
  }
  boolean haveKeys=loopCountVar != null;
  String contentsVar=TCLTMP_ARRAY_CONTENTS;
  if (splitDegree <= 0) {
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys));
  }
 else {
    startForeachSplit(procName,arrayVar,contentsVar,splitDegree,haveKeys,usedVariables,keepOpenVars);
  }
  startForeachInner(new Value(contentsVar),memberVar,loopCountVar,usedVariables,keepOpenVars,foreach_num);
}","@Override public void startForeachLoop(String loopName,Var arrayVar,Var memberVar,Var loopCountVar,int splitDegree,boolean arrayClosed,List<Var> usedVariables,List<Var> keepOpenVars){
  assert(Types.isArray(arrayVar.type()));
  assert(loopCountVar == null || loopCountVar.type().equals(Types.V_INT));
  if (!arrayClosed) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
  if (!arrayClosed) {
    ArrayList<Var> passIn=new ArrayList<Var>(usedVariables);
    if (!passIn.contains(arrayVar)) {
      passIn.add(arrayVar);
    }
    startAsync(loopName + ""String_Node_Str"",Arrays.asList(arrayVar),passIn,keepOpenVars,TaskMode.LOCAL);
  }
  boolean haveKeys=loopCountVar != null;
  String contentsVar=TCLTMP_ARRAY_CONTENTS;
  if (splitDegree <= 0) {
    pointStack.peek().add(Turbine.containerContents(contentsVar,varToExpr(arrayVar),haveKeys));
  }
 else {
    startForeachSplit(loopName,arrayVar,contentsVar,splitDegree,haveKeys,usedVariables,keepOpenVars);
  }
  startForeachInner(new Value(contentsVar),memberVar,loopCountVar,usedVariables,keepOpenVars);
}",0.7925045703839122
133239,"/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,Expression startE,Expression endE,Expression incrE){
  List<Var> allUsedVars=Var.varListUnion(usedVariables,keepOpenVars);
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : allUsedVars) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : allUsedVars) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVariables,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().append(incrementWriters(keepOpenVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(splitDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",splitDegree,TCLTMP_ITERSLEFT,splitDegree)))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL));
  pointStack.push(inner);
}","/** 
 * After this function is called, in the TCL context at the top of the stack will be available the bottom, top (inclusive) and increment of the split in tcl values: TCLTMP_RANGE_LO TCLTMP_RANGE_HI and TCLTMP_RANGE_INC
 * @param loopName
 * @param usedVariables
 * @param keepOpenVars
 * @param splitDegree
 * @param startE start of range (inclusive)
 * @param endE end of range (inclusive)
 * @param incrE
 */
private void startRangeSplit(String loopName,List<Var> usedVariables,List<Var> keepOpenVars,int splitDegree,Expression startE,Expression endE,Expression incrE){
  List<Var> allUsedVars=Var.varListUnion(usedVariables,keepOpenVars);
  List<String> commonFormalArgs=new ArrayList<String>();
  commonFormalArgs.add(Turbine.LOCAL_STACK_NAME);
  for (  Var uv : allUsedVars) {
    commonFormalArgs.add(prefixVar(uv.name()));
  }
  commonFormalArgs.add(TCLTMP_RANGE_LO);
  commonFormalArgs.add(TCLTMP_RANGE_HI);
  commonFormalArgs.add(TCLTMP_RANGE_INC);
  List<String> outerFormalArgs=new ArrayList<String>(commonFormalArgs);
  Value loVal=new Value(TCLTMP_RANGE_LO);
  Value hiVal=new Value(TCLTMP_RANGE_HI);
  Value incVal=new Value(TCLTMP_RANGE_INC);
  List<Expression> commonArgs=new ArrayList<Expression>();
  commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
  for (  Var uv : allUsedVars) {
    commonArgs.add(varToExpr(uv));
  }
  List<Expression> outerCallArgs=new ArrayList<Expression>(commonArgs);
  outerCallArgs.add(startE);
  outerCallArgs.add(endE);
  outerCallArgs.add(incrE);
  List<Expression> innerCallArgs=new ArrayList<Expression>(commonArgs);
  innerCallArgs.add(loVal);
  innerCallArgs.add(hiVal);
  innerCallArgs.add(incVal);
  Sequence outer=new Sequence();
  String outerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(outerProcName,usedTclFunctionNames,outerFormalArgs,outer));
  Sequence inner=new Sequence();
  String innerProcName=uniqueTCLFunctionName(loopName + ""String_Node_Str"");
  tree.add(new Proc(innerProcName,usedTclFunctionNames,commonFormalArgs,inner));
  pointStack.peek().add(new SetVariable(TCLTMP_ITERSTOTAL,rangeItersLeft(startE,endE,incrE)));
  List<Var> readOnlyUsedVars=Var.varListDiff(usedVariables,keepOpenVars);
  pointStack.peek().append(incrementReaders(readOnlyUsedVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().append(incrementWriters(keepOpenVars,new Value(TCLTMP_ITERSTOTAL)));
  pointStack.peek().add(new Command(outerProcName,outerCallArgs));
  outer.add(new SetVariable(TCLTMP_ITERSLEFT,rangeItersLeft(new Value(TCLTMP_RANGE_LO),new Value(TCLTMP_RANGE_HI),new Value(TCLTMP_RANGE_INC))));
  Expression doneSplitting=Square.arithExpr(new Value(TCLTMP_ITERSLEFT),new Token(""String_Node_Str""),new LiteralInt(splitDegree));
  Sequence thenB=new Sequence();
  Sequence elseB=new Sequence();
  If splitIf=new If(doneSplitting,thenB,elseB);
  outer.add(splitIf);
  thenB.add(new Command(innerProcName,innerCallArgs));
  Sequence splitBody=new Sequence();
  String splitStart=""String_Node_Str"";
  String skip=""String_Node_Str"";
  elseB.add(new SetVariable(skip,Square.arithExpr(new Token(String.format(""String_Node_Str"",splitDegree,new Value(TCLTMP_ITERSLEFT),splitDegree,new Value(TCLTMP_RANGE_INC))))));
  ForLoop splitLoop=new ForLoop(splitStart,loVal,hiVal,new Value(skip),splitBody);
  elseB.add(splitLoop);
  ArrayList<Expression> outerRecCall=new ArrayList<Expression>();
  outerRecCall.add(new Token(outerProcName));
  outerRecCall.addAll(commonArgs);
  outerRecCall.add(new Value(splitStart));
  Square splitEnd=Square.arithExpr(new Token(String.format(""String_Node_Str"",TCLTMP_RANGE_HI,splitStart,skip)));
  outerRecCall.add(splitEnd);
  outerRecCall.add(incVal);
  splitBody.add(Turbine.rule(outerProcName,new ArrayList<Value>(0),new TclList(outerRecCall),TaskMode.CONTROL));
  pointStack.push(inner);
}",0.8946468499276601
133240,"/** 
 * @param logger
 * @param ancestorBlock the block the instructions are moved from
 * @param ancestors 
 * @param currBlock the block they are moved too (a descendant of the priorblock)
 * @param currBlockInstructions  all changes to instructions in curr blockare made through this iterator, and it is rewound to the previous position before the function exits
 * @param waitMap map of variable names to instructions/continuations they blockon
 * @param writtenV
 * @return list of moved continuations
 */
private static Set<Continuation> relocateDependentInstructions(Logger logger,Block ancestorBlock,Deque<AncestorContinuation> ancestors,Block currBlock,ListIterator<Instruction> currBlockInstructions,MultiMap<String,InstOrCont> waitMap,Var writtenV){
  List<InstOrCont> waits=waitMap.get(writtenV.name());
  Set<Instruction> movedI=new HashSet<Instruction>();
  Set<Continuation> movedC=new HashSet<Continuation>();
  for (  InstOrCont ic : waits) {
    logger.trace(""String_Node_Str"" + ic.toString());
switch (ic.type()) {
case CONTINUATION:
      Continuation c=ic.continuation();
    currBlock.addContinuation(c);
  movedC.add(c);
assert(c.isAsync());
updateAncestorKeepOpen(ancestors,c.getKeepOpenVars());
break;
case INSTRUCTION:
boolean canRelocate=true;
Instruction inst=ic.instruction();
ArrayList<Var> keepOpenVars=new ArrayList<Var>();
for (Var out : inst.getOutputs()) {
if (Types.isArray(out.type())) {
keepOpenVars.add(out);
}
 else if (Types.isArrayRef(out.type())) {
canRelocate=false;
}
}
if (canRelocate) {
currBlockInstructions.add(inst);
movedI.add(ic.instruction());
if (!keepOpenVars.isEmpty()) {
updateAncestorKeepOpen(ancestors,keepOpenVars);
}
}
break;
default :
throw new STCRuntimeError(""String_Node_Str"");
}
}
ancestorBlock.removeContinuations(movedC);
ancestorBlock.removeInstructions(movedI);
ICUtil.rewindIterator(currBlockInstructions,movedI.size());
updateWaiterMap(waitMap,movedC,movedI);
return movedC;
}","/** 
 * @param logger
 * @param ancestorBlock the block the instructions are moved from
 * @param ancestors 
 * @param currBlock the block they are moved too (a descendant of the priorblock)
 * @param currBlockInstructions  all changes to instructions in curr blockare made through this iterator, and it is rewound to the previous position before the function exits
 * @param waitMap map of variable names to instructions/continuations they blockon
 * @param writtenV
 * @return list of moved continuations
 */
private static Set<Continuation> relocateDependentInstructions(Logger logger,Block ancestorBlock,Deque<AncestorContinuation> ancestors,Block currBlock,ListIterator<Instruction> currBlockInstructions,MultiMap<String,InstOrCont> waitMap,Var writtenV){
  List<InstOrCont> waits=waitMap.get(writtenV.name());
  Set<Instruction> movedI=new HashSet<Instruction>();
  Set<Continuation> movedC=new HashSet<Continuation>();
  for (  InstOrCont ic : waits) {
    logger.trace(""String_Node_Str"" + ic.toString());
switch (ic.type()) {
case CONTINUATION:
{
        Continuation c=ic.continuation();
        boolean canRelocate=true;
        for (        AncestorContinuation ancestor : ancestors) {
          if (c == ancestor.continuation) {
            canRelocate=false;
            break;
          }
        }
        if (canRelocate) {
          currBlock.addContinuation(c);
          movedC.add(c);
          assert(c.isAsync());
          updateAncestorKeepOpen(ancestors,c.getKeepOpenVars());
        }
        break;
      }
case INSTRUCTION:
{
      boolean canRelocate=true;
      Instruction inst=ic.instruction();
      ArrayList<Var> keepOpenVars=new ArrayList<Var>();
      for (      Var out : inst.getOutputs()) {
        if (Types.isArray(out.type())) {
          keepOpenVars.add(out);
        }
 else         if (Types.isArrayRef(out.type())) {
          canRelocate=false;
        }
      }
      if (canRelocate) {
        currBlockInstructions.add(inst);
        movedI.add(ic.instruction());
        if (!keepOpenVars.isEmpty()) {
          updateAncestorKeepOpen(ancestors,keepOpenVars);
        }
      }
      break;
    }
default :
  throw new STCRuntimeError(""String_Node_Str"");
}
}
ancestorBlock.removeContinuations(movedC);
ancestorBlock.removeInstructions(movedI);
ICUtil.rewindIterator(currBlockInstructions,movedI.size());
updateWaiterMap(waitMap,movedC,movedI);
return movedC;
}",0.8933730795689062
133241,"public Set<String> unneededVars(){
  HashSet<String> toRemove=new HashSet<String>();
  Set<String> stillNeeded=findEssentialVars();
  for (  Var v : getVariables()) {
    if (!stillNeeded.contains(v.name())) {
      toRemove.add(v.name());
    }
  }
  return toRemove;
}","public Set<String> unneededVars(){
  HashSet<String> toRemove=new HashSet<String>();
  Pair<Set<String>,List<List<Var>>> res=findEssentialVars();
  Set<String> stillNeeded=res.val1;
  for (  List<Var> dependentSet : res.val2) {
{
      boolean needed=false;
      for (      Var v : dependentSet) {
        if (stillNeeded.contains(v.name())) {
          needed=true;
          break;
        }
      }
      if (needed) {
        for (        Var v : dependentSet) {
          stillNeeded.add(v.name());
        }
      }
    }
  }
  for (  Var v : getVariables()) {
    if (!stillNeeded.contains(v.name())) {
      toRemove.add(v.name());
    }
  }
  return toRemove;
}",0.4994686503719447
133242,"private void findEssentialVars(HashSet<String> stillNeeded){
  for (  Var v : this.getVariables()) {
    if (v.isMapped()) {
      stillNeeded.add(v.name());
      stillNeeded.add(v.mapping().name());
    }
  }
  for (  Instruction i : this.getInstructions()) {
    for (    Arg oa : i.getInputs()) {
      if (oa.isVar()) {
        stillNeeded.add(oa.getVar().name());
      }
    }
    if (i.hasSideEffects()) {
      for (      Var out : i.getOutputs()) {
        stillNeeded.add(out.name());
      }
    }
  }
  for (  Continuation c : this.getContinuations()) {
    for (    Var v : c.requiredVars()) {
      stillNeeded.add(v.name());
    }
    for (    Block b : c.getBlocks()) {
      b.findEssentialVars(stillNeeded);
    }
  }
  for (  CleanupAction a : cleanupActions) {
    if (a.action.writesAliasVar()) {
      stillNeeded.add(a.var.name());
    }
    for (    Arg out : a.action.getInputs()) {
      if (out.isVar()) {
        stillNeeded.add(out.getVar().name());
      }
    }
  }
}","private void findEssentialVars(Set<String> stillNeeded,List<List<Var>> interdependencies){
  for (  Var v : this.getVariables()) {
    if (v.isMapped()) {
      stillNeeded.add(v.name());
      stillNeeded.add(v.mapping().name());
    }
  }
  for (  Instruction i : this.getInstructions()) {
    for (    Arg oa : i.getInputs()) {
      if (oa.isVar()) {
        stillNeeded.add(oa.getVar().name());
      }
    }
    if (i.hasSideEffects()) {
      for (      Var out : i.getOutputs()) {
        stillNeeded.add(out.name());
      }
    }
 else {
      interdependencies.add(i.getOutputs());
    }
  }
  for (  Continuation c : this.getContinuations()) {
    for (    Var v : c.requiredVars()) {
      stillNeeded.add(v.name());
    }
    for (    Block b : c.getBlocks()) {
      b.findEssentialVars(stillNeeded,interdependencies);
    }
  }
  for (  CleanupAction a : cleanupActions) {
    if (a.action.writesAliasVar()) {
      stillNeeded.add(a.var.name());
    }
    for (    Arg out : a.action.getInputs()) {
      if (out.isVar()) {
        stillNeeded.add(out.getVar().name());
      }
    }
  }
}",0.9453681710213776
133243,"@Override public Collection<Var> requiredVars(){
  ArrayList<Var> res=new ArrayList<Var>();
  for (  Var c : keepOpenVars) {
    if (c.storage() == VarStorage.ALIAS) {
      res.add(c);
    }
  }
  if (mode == WaitMode.EXPLICIT) {
    for (    Var v : waitVars) {
      res.add(v);
    }
  }
  return res;
}","@Override public Collection<Var> requiredVars(){
  ArrayList<Var> res=new ArrayList<Var>();
  for (  Var c : keepOpenVars) {
    if (c.storage() == VarStorage.ALIAS) {
      res.add(c);
    }
  }
  if (mode == WaitMode.EXPLICIT || mode == WaitMode.TASK_DISPATCH) {
    for (    Var v : waitVars) {
      res.add(v);
    }
  }
  return res;
}",0.9475308641975309
133244,"private void foreach(Context context,SwiftAST tree) throws UserException {
  ForeachLoop loop=ForeachLoop.fromAST(context,tree);
  if (loop.iteratesOverRange() && loop.getLoopCountVal() != null) {
    foreachRange(context,loop);
  }
 else {
    foreachArray(context,loop);
  }
}","private void foreach(Context context,SwiftAST tree) throws UserException {
  ForeachLoop loop=ForeachLoop.fromAST(context,tree);
  if (loop.iteratesOverRange() && loop.getCountVarName() == null) {
    foreachRange(context,loop);
  }
 else {
    foreachArray(context,loop);
  }
}",0.9676258992805756
133245,"/** 
 * @return the type of the result
 * @throws UserException 
 */
public ExprType getType(Context context) throws UserException {
  List<SwiftAST> members=getMembers();
  if (members.size() == 0) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"");
  }
  List<SwiftType> memberTypes=new ArrayList<SwiftType>(members.size());
  for (  SwiftAST elem : members) {
    memberTypes.add(TypeChecker.findSingleExprType(context,elem));
  }
  List<SwiftType> possibleTypes=TypeChecker.typeIntersection(memberTypes);
  if (possibleTypes.size() == 0) {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + memberTypes.toString());
  }
  List<SwiftType> possibleArrayTypes=new ArrayList<SwiftType>();
  for (  SwiftType alt : possibleTypes) {
    possibleArrayTypes.add(new ArrayType(alt));
  }
  return new ExprType(UnionType.createUnionType(possibleArrayTypes));
}","/** 
 * @return the type of the result
 * @throws UserException 
 */
public ExprType getType(Context context) throws UserException {
  List<SwiftAST> members=getMembers();
  if (members.size() == 0) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"");
  }
  List<SwiftType> memberTypes=new ArrayList<SwiftType>(members.size());
  for (  SwiftAST elem : members) {
    memberTypes.add(TypeChecker.findSingleExprType(context,elem));
  }
  List<SwiftType> possibleTypes=TypeChecker.typeIntersection(memberTypes);
  if (possibleTypes.size() == 0) {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + memberTypes.toString());
  }
  List<SwiftType> possibleArrayTypes=new ArrayList<SwiftType>();
  for (  SwiftType alt : possibleTypes) {
    possibleArrayTypes.add(new ArrayType(alt));
  }
  return new ExprType(UnionType.makeUnion(possibleArrayTypes));
}",0.9933628318584072
133246,"private static ArgDecl extractArgInfo(Context context,SwiftAST arg) throws UndefinedTypeException, InvalidSyntaxException {
  assert(arg.getType() == ExMParser.DECLARATION);
  assert(arg.getChildCount() == 2 || arg.getChildCount() == 3);
  ArgDecl argInfo;
  boolean thisVarArgs=false;
  if (arg.getChildCount() == 3) {
    assert(arg.child(2).getType() == ExMParser.VARARGS);
    thisVarArgs=true;
  }
  SwiftAST baseTypes=arg.child(0);
  SwiftAST restDecl=arg.child(1);
  assert(baseTypes.getType() == ExMParser.MULTI_TYPE);
  assert(baseTypes.getChildCount() >= 1);
  assert(restDecl.getType() == ExMParser.DECLARE_VARIABLE_REST);
  ArrayList<SwiftType> alts=new ArrayList<SwiftType>(baseTypes.getChildCount());
  String varname=null;
  for (int i=0; i < baseTypes.getChildCount(); i++) {
    SwiftAST typeAlt=baseTypes.child(i);
    assert(typeAlt.getType() == ExMParser.ID);
    String typeName=typeAlt.getText();
    SwiftType baseType=context.lookupType(typeName);
    if (baseType == null) {
      throw new UndefinedTypeException(context,typeName);
    }
    Variable v=fromFormalArgTree(context,baseType,restDecl,DefType.INARG);
    varname=v.getName();
    alts.add(v.getType());
  }
  SwiftType argType=UnionType.createUnionType(alts);
  argInfo=new ArgDecl(varname,argType,thisVarArgs);
  return argInfo;
}","private static ArgDecl extractArgInfo(Context context,SwiftAST arg) throws UndefinedTypeException, InvalidSyntaxException {
  assert(arg.getType() == ExMParser.DECLARATION);
  assert(arg.getChildCount() == 2 || arg.getChildCount() == 3);
  ArgDecl argInfo;
  boolean thisVarArgs=false;
  if (arg.getChildCount() == 3) {
    assert(arg.child(2).getType() == ExMParser.VARARGS);
    thisVarArgs=true;
  }
  SwiftAST baseTypes=arg.child(0);
  SwiftAST restDecl=arg.child(1);
  assert(baseTypes.getType() == ExMParser.MULTI_TYPE);
  assert(baseTypes.getChildCount() >= 1);
  assert(restDecl.getType() == ExMParser.DECLARE_VARIABLE_REST);
  ArrayList<SwiftType> alts=new ArrayList<SwiftType>(baseTypes.getChildCount());
  String varname=null;
  for (int i=0; i < baseTypes.getChildCount(); i++) {
    SwiftAST typeAlt=baseTypes.child(i);
    assert(typeAlt.getType() == ExMParser.ID);
    String typeName=typeAlt.getText();
    SwiftType baseType=context.lookupType(typeName);
    if (baseType == null) {
      throw new UndefinedTypeException(context,typeName);
    }
    Variable v=fromFormalArgTree(context,baseType,restDecl,DefType.INARG);
    varname=v.getName();
    alts.add(v.getType());
  }
  SwiftType argType=UnionType.makeUnion(alts);
  argInfo=new ArgDecl(varname,argType,thisVarArgs);
  return argInfo;
}",0.9954407294832828
133247,"/** 
 * Handle an expression which is an array access. Copies a member of an array, specified by index, into another variable. If the other variable is an alias variable, we can avoid the copy.
 * @param context
 * @param tree
 * @param oVar the variable to copy into
 * @throws UserException
 */
private void arrayLoad(Context context,SwiftAST tree,Variable oVar,Map<String,String> renames) throws UserException {
  if (tree.getChildCount() != 2) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + tree.getChildCount());
  }
  SwiftAST arrayTree=tree.child(0);
  SwiftType arrExprType=TypeChecker.findSingleExprType(context,arrayTree);
  Variable arrayVar=evalExprToTmp(context,arrayTree,arrExprType,false,renames);
  boolean isRef;
  SwiftType arrayType=arrayVar.getType();
  SwiftType memberType;
  if (Types.isArray(arrayType)) {
    isRef=false;
    memberType=arrayType.getMemberType();
  }
 else   if (Types.isArrayRef(arrayType)) {
    isRef=true;
    memberType=arrayType.getMemberType().getMemberType();
  }
 else {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (Types.isArray(memberType)) {
    if (!(Types.isArrayRef(oVar.getType()) && oVar.getType().getMemberType().equals(memberType))) {
      SwiftType expType=new Types.ReferenceType(memberType);
      throw new TypeMismatchException(context,""String_Node_Str"" + expType.toString() + ""String_Node_Str""+ arrayVar.getName()+ ""String_Node_Str""+ arrayVar.getType().toString()+ ""String_Node_Str""+ oVar.getType().toString());
    }
  }
 else   if (Types.isStruct(memberType)) {
    if (!(Types.isStructRef(oVar.getType()) && oVar.getType().getMemberType().equals(memberType))) {
      SwiftType expType=new Types.ReferenceType(memberType);
      throw new TypeMismatchException(context,""String_Node_Str"" + expType.toString() + ""String_Node_Str""+ arrayVar.getName()+ ""String_Node_Str""+ arrayVar.getType().toString()+ ""String_Node_Str""+ oVar.getType().toString());
    }
  }
 else   if (Types.isScalarFuture(memberType)) {
    if (!memberType.equals(oVar.getType())) {
      throw new TypeMismatchException(context,""String_Node_Str"" + arrayVar.toString() + ""String_Node_Str""+ oVar.toString());
    }
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + memberType.toString());
  }
  SwiftAST arrayIndexTree=tree.child(1);
  SwiftType indexType=TypeChecker.findSingleExprType(context,arrayIndexTree);
  if (!indexType.assignableTo(Types.FUTURE_INTEGER)) {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + indexType.typeName());
  }
  Variable lookupIntoVar;
  boolean doDereference;
  if (memberType.equals(oVar.getType())) {
    lookupIntoVar=varCreator.createTmp(context,new ReferenceType(memberType));
    doDereference=true;
  }
 else {
    assert(Types.isReference(oVar.getType()));
    assert(memberType.equals(oVar.getType().getMemberType()));
    lookupIntoVar=oVar;
    doDereference=false;
  }
  String arrayIndexStr=Literals.extractIntLit(context,arrayIndexTree);
  if (arrayIndexStr != null) {
    long arrayIndex;
    try {
      arrayIndex=Long.parseLong(arrayIndexStr);
    }
 catch (    NumberFormatException e) {
      throw new STCRuntimeError(""String_Node_Str"" + arrayIndexStr);
    }
    backend.arrayLookupRefImm(lookupIntoVar,arrayVar,Arg.createIntLit(arrayIndex),isRef);
  }
 else {
    Variable indexVar=evalExprToTmp(context,arrayIndexTree,Types.FUTURE_INTEGER,false,renames);
    backend.arrayLookupFuture(lookupIntoVar,arrayVar,indexVar,isRef);
  }
  if (doDereference) {
    dereference(context,oVar,lookupIntoVar);
  }
}","/** 
 * Handle an expression which is an array access. Copies a member of an array, specified by index, into another variable. If the other variable is an alias variable, we can avoid the copy.
 * @param context
 * @param tree
 * @param oVar the variable to copy into
 * @throws UserException
 */
private void arrayLoad(Context context,SwiftAST tree,Variable oVar,Map<String,String> renames) throws UserException {
  if (tree.getChildCount() != 2) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + tree.getChildCount());
  }
  SwiftAST arrayTree=tree.child(0);
  SwiftType arrExprType=TypeChecker.findSingleExprType(context,arrayTree);
  SwiftType arrType=null;
  for (  SwiftType altType : UnionType.getAlternatives(arrExprType)) {
    assert(Types.isArray(altType) || Types.isArrayRef(altType));
    SwiftType lookupRes=TypeChecker.dereferenceResultType(Types.getArrayMemberType(altType));
    if (lookupRes.equals(oVar.getType())) {
      arrType=altType;
      break;
    }
  }
  if (arrType == null) {
    throw new STCRuntimeError(""String_Node_Str"" + arrExprType + ""String_Node_Str""+ oVar);
  }
  Variable arrayVar=evalExprToTmp(context,arrayTree,arrType,false,renames);
  SwiftType memberType=Types.getArrayMemberType(arrType);
  SwiftAST arrayIndexTree=tree.child(1);
  SwiftType indexType=TypeChecker.findSingleExprType(context,arrayIndexTree);
  if (!indexType.assignableTo(Types.FUTURE_INTEGER)) {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + indexType.typeName());
  }
  Variable lookupIntoVar;
  boolean doDereference;
  if (memberType.equals(oVar.getType())) {
    lookupIntoVar=varCreator.createTmp(context,new ReferenceType(memberType));
    doDereference=true;
  }
 else {
    assert(Types.isReferenceTo(oVar.getType(),memberType));
    lookupIntoVar=oVar;
    doDereference=false;
  }
  String arrayIndexStr=Literals.extractIntLit(context,arrayIndexTree);
  if (arrayIndexStr != null) {
    long arrayIndex;
    try {
      arrayIndex=Long.parseLong(arrayIndexStr);
    }
 catch (    NumberFormatException e) {
      throw new STCRuntimeError(""String_Node_Str"" + arrayIndexStr);
    }
    backend.arrayLookupRefImm(lookupIntoVar,arrayVar,Arg.createIntLit(arrayIndex),Types.isArrayRef(arrType));
  }
 else {
    Variable indexVar=evalExprToTmp(context,arrayIndexTree,Types.FUTURE_INTEGER,false,renames);
    backend.arrayLookupFuture(lookupIntoVar,arrayVar,indexVar,Types.isArrayRef(arrType));
  }
  if (doDereference) {
    dereference(context,oVar,lookupIntoVar);
  }
}",0.6374656537902053
133248,"/** 
 * Creates a temporary variable and evaluates expression into it
 * @param codebuf buffer to append code to
 * @param type type of tmp variable
 * @return return the name of a newly created tmp variable
 * @throws UserException
 */
public Variable evalExprToTmp(Context context,SwiftAST tree,SwiftType type,boolean storeInStack,Map<String,String> renames) throws UserException {
  assert(type != null);
  if (tree.getType() == ExMParser.VARIABLE) {
    String varName=tree.child(0).getText();
    if (renames != null && renames.containsKey(varName)) {
      varName=renames.get(varName);
    }
    Variable var=context.getDeclaredVariable(varName);
    if (var == null) {
      throw new UndefinedVariableException(context,""String_Node_Str"" + varName + ""String_Node_Str"");
    }
    if (var.getStorage() == VariableStorage.STACK || (!storeInStack) && var.getType().equals(type)) {
      return var;
    }
  }
  if (tree.getType() == ExMParser.ARRAY_LOAD && immediateArrayLoadPossible(tree)) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
 else   if (tree.getType() == ExMParser.STRUCT_LOAD && Types.isStruct(TypeChecker.findSingleExprType(context,tree.child(0)))) {
    return lookupStructField(context,tree,type,storeInStack,null,renames);
  }
 else {
    Variable tmp=varCreator.createTmp(context,type,storeInStack,false);
    ArrayList<Variable> childOList=new ArrayList<Variable>(1);
    childOList.add(tmp);
    walkExpr(context,tree,childOList,renames);
    return tmp;
  }
}","/** 
 * Creates a temporary variable and evaluates expression into it
 * @param codebuf buffer to append code to
 * @param type type of tmp variable
 * @return return the name of a newly created tmp variable
 * @throws UserException
 */
public Variable evalExprToTmp(Context context,SwiftAST tree,SwiftType type,boolean storeInStack,Map<String,String> renames) throws UserException {
  assert(type != null);
  if (tree.getType() == ExMParser.VARIABLE) {
    String varName=tree.child(0).getText();
    if (renames != null && renames.containsKey(varName)) {
      varName=renames.get(varName);
    }
    Variable var=context.getDeclaredVariable(varName);
    if (var == null) {
      throw new UndefinedVariableException(context,""String_Node_Str"" + varName + ""String_Node_Str"");
    }
    if (var.getStorage() == VariableStorage.STACK || (!storeInStack) && var.getType().equals(type)) {
      return var;
    }
  }
  if (tree.getType() == ExMParser.STRUCT_LOAD && Types.isStruct(TypeChecker.findSingleExprType(context,tree.child(0)))) {
    return lookupStructField(context,tree,type,storeInStack,null,renames);
  }
 else {
    Variable tmp=varCreator.createTmp(context,type,storeInStack,false);
    ArrayList<Variable> childOList=new ArrayList<Variable>(1);
    childOList.add(tmp);
    walkExpr(context,tree,childOList,renames);
    return tmp;
  }
}",0.9458889669711876
133249,"private static ExprType uncachedFindExprType(Context context,SwiftAST tree) throws UserException {
  int token=tree.getType();
switch (token) {
case ExMParser.CALL_FUNCTION:
{
      return callFunction(context,tree,true);
    }
case ExMParser.VARIABLE:
{
    Variable var=context.getDeclaredVariable(tree.child(0).getText());
    if (var == null) {
      throw new UndefinedVariableException(context,""String_Node_Str"" + tree.child(0).getText() + ""String_Node_Str"");
    }
    SwiftType exprType=var.getType();
    if (Types.isScalarUpdateable(exprType)) {
      return new ExprType(UnionType.createUnionType(exprType,ScalarUpdateableType.asScalarFuture(exprType)));
    }
    return new ExprType(exprType);
  }
case ExMParser.INT_LITERAL:
return new ExprType(UnionType.createUnionType(Types.FUTURE_INTEGER,Types.FUTURE_FLOAT));
case ExMParser.FLOAT_LITERAL:
return new ExprType(Types.FUTURE_FLOAT);
case ExMParser.STRING_LITERAL:
return new ExprType(Types.FUTURE_STRING);
case ExMParser.BOOL_LITERAL:
return new ExprType(Types.FUTURE_BOOLEAN);
case ExMParser.OPERATOR:
return findOperatorResultType(context,tree);
case ExMParser.STRUCT_LOAD:
ExprType structTypeL=findExprType(context,tree.child(0));
String fieldName=tree.child(1).getText();
if (structTypeL.elems() != 1) {
throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"");
}
SwiftType structType=structTypeL.get(0);
SwiftType fieldType;
fieldType=findStructFieldType(context,fieldName,structType);
if (fieldType == null) {
throw new TypeMismatchException(context,""String_Node_Str"" + fieldName + ""String_Node_Str""+ ((StructType)structType).getTypeName());
}
if (Types.isStruct(structType)) {
return new ExprType(fieldType);
}
 else {
assert(Types.isStructRef(structType));
return new ExprType(dereferenceResultType(fieldType));
}
case ExMParser.ARRAY_LOAD:
ExprType arrTypeL=findExprType(context,tree.child(0));
if (arrTypeL.elems() != 1) {
throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"");
}
SwiftType arrType=arrTypeL.get(0);
SwiftType memberType;
if (Types.isArray(arrType) || Types.isArrayRef(arrType)) {
memberType=Types.getArrayMemberType(arrType);
}
 else {
throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + arrType.toString());
}
SwiftType resultType;
resultType=dereferenceResultType(memberType);
return new ExprType(resultType);
case ExMParser.ARRAY_RANGE:
{
ArrayRange ar=ArrayRange.fromAST(context,tree);
ar.typeCheck(context);
return new ExprType(new ArrayType(Types.FUTURE_INTEGER));
}
case ExMParser.ARRAY_ELEMS:
{
return ArrayElems.fromAST(context,tree).getType(context);
}
default :
throw new STCRuntimeError(""String_Node_Str"" + LogHelper.tokName(token));
}
}","private static ExprType uncachedFindExprType(Context context,SwiftAST tree) throws UserException {
  int token=tree.getType();
switch (token) {
case ExMParser.CALL_FUNCTION:
{
      return callFunction(context,tree,true);
    }
case ExMParser.VARIABLE:
{
    Variable var=context.getDeclaredVariable(tree.child(0).getText());
    if (var == null) {
      throw new UndefinedVariableException(context,""String_Node_Str"" + tree.child(0).getText() + ""String_Node_Str"");
    }
    SwiftType exprType=var.getType();
    if (Types.isScalarUpdateable(exprType)) {
      return new ExprType(UnionType.createUnionType(exprType,ScalarUpdateableType.asScalarFuture(exprType)));
    }
    return new ExprType(exprType);
  }
case ExMParser.INT_LITERAL:
return new ExprType(UnionType.createUnionType(Types.FUTURE_INTEGER,Types.FUTURE_FLOAT));
case ExMParser.FLOAT_LITERAL:
return new ExprType(Types.FUTURE_FLOAT);
case ExMParser.STRING_LITERAL:
return new ExprType(Types.FUTURE_STRING);
case ExMParser.BOOL_LITERAL:
return new ExprType(Types.FUTURE_BOOLEAN);
case ExMParser.OPERATOR:
return findOperatorResultType(context,tree);
case ExMParser.STRUCT_LOAD:
ExprType structTypeL=findExprType(context,tree.child(0));
String fieldName=tree.child(1).getText();
if (structTypeL.elems() != 1) {
throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"");
}
SwiftType structType=structTypeL.get(0);
SwiftType fieldType;
fieldType=findStructFieldType(context,fieldName,structType);
if (fieldType == null) {
throw new TypeMismatchException(context,""String_Node_Str"" + fieldName + ""String_Node_Str""+ ((StructType)structType).getTypeName());
}
if (Types.isStruct(structType)) {
return new ExprType(fieldType);
}
 else {
assert(Types.isStructRef(structType));
return new ExprType(dereferenceResultType(fieldType));
}
case ExMParser.ARRAY_LOAD:
SwiftType arrType=findSingleExprType(context,tree.child(0));
List<SwiftType> resultAlts=new ArrayList<SwiftType>();
for (SwiftType arrAlt : UnionType.getAlternatives(arrType)) {
if (Types.isArray(arrAlt) || Types.isArrayRef(arrAlt)) {
SwiftType memberType=Types.getArrayMemberType(arrAlt);
resultAlts.add(dereferenceResultType(memberType));
}
 else {
throw new TypeMismatchException(context,""String_Node_Str"" + arrType.toString());
}
}
return new ExprType(UnionType.makeUnion(resultAlts));
case ExMParser.ARRAY_RANGE:
{
ArrayRange ar=ArrayRange.fromAST(context,tree);
ar.typeCheck(context);
return new ExprType(new ArrayType(Types.FUTURE_INTEGER));
}
case ExMParser.ARRAY_ELEMS:
{
return ArrayElems.fromAST(context,tree).getType(context);
}
default :
throw new STCRuntimeError(""String_Node_Str"" + LogHelper.tokName(token));
}
}",0.8390334572490706
133250,"private static ExprType callFunction(Context context,SwiftAST tree,boolean noWarn) throws UndefinedFunctionException, UserException {
  FunctionCall f=FunctionCall.fromAST(context,tree);
  List<FunctionType> alts=concretiseFunctionCall(context,f.function(),f.type(),f.args(),noWarn);
  if (alts.size() == 1) {
    return new ExprType(alts.get(0).getOutputs());
  }
 else {
    assert(alts.size() >= 2);
    int numOutputs=f.type().getOutputs().size();
    if (numOutputs == 0) {
      return new ExprType(Collections.<SwiftType>emptyList());
    }
 else {
      List<SwiftType> altOutputs=new ArrayList<SwiftType>();
      for (int out=0; out < numOutputs; out++) {
        List<SwiftType> altOutput=new ArrayList<SwiftType>();
        for (        FunctionType ft : alts) {
          altOutput.add(ft.getOutputs().get(out));
        }
        altOutputs.add(UnionType.createUnionType(altOutput));
      }
      return new ExprType(altOutputs);
    }
  }
}","private static ExprType callFunction(Context context,SwiftAST tree,boolean noWarn) throws UndefinedFunctionException, UserException {
  FunctionCall f=FunctionCall.fromAST(context,tree);
  List<FunctionType> alts=concretiseFunctionCall(context,f.function(),f.type(),f.args(),noWarn);
  if (alts.size() == 1) {
    return new ExprType(alts.get(0).getOutputs());
  }
 else {
    assert(alts.size() >= 2);
    int numOutputs=f.type().getOutputs().size();
    if (numOutputs == 0) {
      return new ExprType(Collections.<SwiftType>emptyList());
    }
 else {
      List<SwiftType> altOutputs=new ArrayList<SwiftType>();
      for (int out=0; out < numOutputs; out++) {
        List<SwiftType> altOutput=new ArrayList<SwiftType>();
        for (        FunctionType ft : alts) {
          altOutput.add(ft.getOutputs().get(out));
        }
        altOutputs.add(UnionType.makeUnion(altOutput));
      }
      return new ExprType(altOutputs);
    }
  }
}",0.993704092339979
133251,"/** 
 * Check function argument type Returns which formal argument type is selected. Only handles case where formalArgT has a type variable
 * @param context
 * @param func
 * @param arg
 * @param formalArgT
 * @param argExprT
 * @param tvConstraints fill in constraints for type variables
 * @return
 * @throws TypeMismatchException
 */
private static SwiftType checkFunArgTV(Context context,String func,int arg,SwiftType formalArgT,SwiftType argExprT,MultiMap<String,SwiftType> tvConstraints) throws TypeMismatchException {
  if (Types.isUnion(formalArgT)) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
 else   if (Types.isTypeVar(formalArgT)) {
    SwiftType actConv;
    if (Types.isReference(argExprT)) {
      actConv=argExprT.getMemberType();
    }
 else {
      actConv=argExprT;
    }
    tvConstraints.put(formalArgT.getTypeVarName(),actConv);
  }
 else   if ((Types.isArray(formalArgT) || Types.isArray(formalArgT)) && Types.isTypeVar(Types.getArrayMemberType(formalArgT))) {
    if (!Types.isArray(argExprT) && !Types.isArrayRef(argExprT)) {
      throw argumentTypeException(context,arg,formalArgT,argExprT,func);
    }
    tvConstraints.put(Types.getArrayMemberType(formalArgT).getTypeVarName(),Types.getArrayMemberType(argExprT));
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + formalArgT);
  }
  return formalArgT;
}","/** 
 * Check function argument type Returns which formal argument type is selected. Only handles case where formalArgT has a type variable
 * @param context
 * @param func
 * @param arg
 * @param formalArgT
 * @param argExprT
 * @param tvConstraints fill in constraints for type variables
 * @return
 * @throws TypeMismatchException
 */
private static SwiftType checkFunArgTV(Context context,String func,int arg,SwiftType formalArgT,SwiftType argExprT,MultiMap<String,SwiftType> tvConstraints) throws TypeMismatchException {
  if (Types.isUnion(formalArgT)) {
    throw new STCRuntimeError(""String_Node_Str"");
  }
  if (Types.isReference(formalArgT)) {
    argExprT=argExprT.getMemberType();
  }
  if (Types.isUnion(argExprT)) {
    List<Map<String,SwiftType>> possible=new ArrayList<Map<String,SwiftType>>();
    for (    SwiftType alt : UnionType.getAlternatives(argExprT)) {
      possible.add(formalArgT.matchTypeVars(alt));
    }
    for (    Map<String,SwiftType> m : possible) {
      assert(m.keySet().equals(possible.get(0).keySet()));
    }
    for (    String boundVar : possible.get(0).keySet()) {
      List<SwiftType> choices=new ArrayList<SwiftType>();
      for (      Map<String,SwiftType> m : possible) {
        SwiftType t=m.get(boundVar);
        assert(!Types.isUnion(t));
        choices.add(t);
      }
      tvConstraints.put(boundVar,UnionType.makeUnion(choices));
    }
  }
 else {
    tvConstraints.putAll(formalArgT.matchTypeVars(argExprT));
  }
  return formalArgT;
}",0.512695652173913
133252,"private static ExprType findOperatorResultType(Context context,SwiftAST tree) throws TypeMismatchException, UserException {
  String opName=extractOpName(tree);
  ArrayList<SwiftType> argTypes=new ArrayList<SwiftType>();
  List<BuiltinOpcode> opcodes=getBuiltInFromOpTree(context,tree,argTypes);
  assert(opcodes != null);
  assert(opcodes.size() > 0);
  List<SwiftType> alternatives=new ArrayList<SwiftType>(opcodes.size());
  for (  BuiltinOpcode opcode : opcodes) {
    OpType opType=Operators.getBuiltinOpType(opcode);
    assert(opType != null);
    checkOp(context,opName,opType,argTypes);
    alternatives.add(new ScalarFutureType(opType.out));
  }
  return new ExprType(UnionType.createUnionType(alternatives));
}","private static ExprType findOperatorResultType(Context context,SwiftAST tree) throws TypeMismatchException, UserException {
  String opName=extractOpName(tree);
  ArrayList<SwiftType> argTypes=new ArrayList<SwiftType>();
  List<BuiltinOpcode> opcodes=getBuiltInFromOpTree(context,tree,argTypes);
  assert(opcodes != null);
  assert(opcodes.size() > 0);
  List<SwiftType> alternatives=new ArrayList<SwiftType>(opcodes.size());
  for (  BuiltinOpcode opcode : opcodes) {
    OpType opType=Operators.getBuiltinOpType(opcode);
    assert(opType != null);
    checkOp(context,opName,opType,argTypes);
    alternatives.add(new ScalarFutureType(opType.out));
  }
  return new ExprType(UnionType.makeUnion(alternatives));
}",0.9916434540389972
133253,"/** 
 * The type of the internal variable that will be created from an array dereference
 * @param memberType the type of array memebrs for the array being dereferenced
 * @return
 */
private static SwiftType dereferenceResultType(SwiftType memberType){
  SwiftType resultType;
  if (Types.isScalarFuture(memberType)) {
    resultType=memberType;
  }
 else   if (Types.isArray(memberType) || Types.isStruct(memberType)) {
    resultType=new ReferenceType(memberType);
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + memberType.toString());
  }
  return resultType;
}","/** 
 * The type of the internal variable that will be created from an array dereference
 * @param memberType the type of array memebrs for the array being dereferenced
 * @return
 */
public static SwiftType dereferenceResultType(SwiftType memberType){
  SwiftType resultType;
  if (Types.isScalarFuture(memberType)) {
    resultType=memberType;
  }
 else   if (Types.isArray(memberType) || Types.isStruct(memberType)) {
    resultType=new ReferenceType(memberType);
  }
 else {
    throw new STCRuntimeError(""String_Node_Str"" + memberType.toString());
  }
  return resultType;
}",0.9905090595340812
133254,"private void callFunction(Context context,String function,List<Variable> oList,List<Variable> iList,Variable priorityVal) throws UndefinedTypeException, UserException {
  List<SwiftType> expectedTypes=TypeChecker.checkFunctionCall(context,function,oList,iList);
  ArrayList<Variable> realIList=new ArrayList<Variable>(iList.size());
  ArrayList<Variable> derefVars=new ArrayList<Variable>();
  ArrayList<Variable> waitVars=new ArrayList<Variable>();
  Context waitContext=null;
  assert(expectedTypes.size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Variable input=iList.get(i);
    SwiftType inputType=input.getType();
    SwiftType expType=expectedTypes.get(i);
    if (inputType.equals(expType)) {
      realIList.add(input);
    }
 else     if (Types.isReferenceTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Variable derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      Variable copy=varCreator.createTmp(waitContext,ScalarUpdateableType.asScalarFuture(inputType));
      assignVariable(waitContext,copy,input);
      realIList.add(copy);
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    ArrayList<Variable> usedVars=new ArrayList<Variable>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,new ArrayList<Variable>(),false);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Variable derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).getType())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  Arg priority=priorityVal != null ? Arg.createVar(priorityVal) : null;
  if (context.isBuiltinFunction(function)) {
    if (FunctionSemantics.hasLocalEquiv(function)) {
      assert(oList.size() <= 1);
      Variable out=oList.size() == 0 ? null : oList.get(0);
      backend.asyncOp(FunctionSemantics.getLocalEquiv(function),out,Arg.fromVarList(realIList),priority);
    }
 else {
      backend.builtinFunctionCall(function,realIList,oList,priority);
    }
  }
 else   if (context.isCompositeFunction(function))   backend.compositeFunctionCall(function,realIList,oList,null,!context.isSyncComposite(function),priority);
 else   throw UndefinedFunctionException.unknownFunction(context,function);
  if (waitContext != null) {
    backend.endWaitStatement(new ArrayList<Variable>());
  }
}","private void callFunction(Context context,String function,List<Variable> oList,List<Variable> iList,Variable priorityVal) throws UndefinedTypeException, UserException {
  List<SwiftType> expectedTypes=TypeChecker.checkFunctionCall(context,function,oList,iList);
  ArrayList<Variable> realIList=new ArrayList<Variable>(iList.size());
  ArrayList<Variable> derefVars=new ArrayList<Variable>();
  ArrayList<Variable> waitVars=new ArrayList<Variable>();
  Context waitContext=null;
  assert(expectedTypes.size() == iList.size());
  for (int i=0; i < iList.size(); i++) {
    Variable input=iList.get(i);
    SwiftType inputType=input.getType();
    SwiftType expType=expectedTypes.get(i);
    if (inputType.equals(expType)) {
      realIList.add(input);
    }
 else     if (Types.isReferenceTo(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Variable derefed;
      derefed=waitContext.createAliasVariable(expType);
      waitVars.add(input);
      derefVars.add(derefed);
      realIList.add(derefed);
    }
 else     if (Types.isUpdateableEquiv(inputType,expType)) {
      if (waitContext == null) {
        waitContext=new LocalContext(context);
      }
      Variable copy=varCreator.createTmp(waitContext,ScalarUpdateableType.asScalarFuture(inputType));
      assignVariable(waitContext,copy,input);
      realIList.add(copy);
    }
 else {
      throw new STCRuntimeError(context.getFileLine() + ""String_Node_Str"" + ""String_Node_Str""+ inputType.toString()+ ""String_Node_Str""+ expType.toString());
    }
  }
  if (waitContext != null) {
    FunctionContext fc=context.getFunctionContext();
    ArrayList<Variable> usedVars=new ArrayList<Variable>();
    usedVars.addAll(iList);
    usedVars.addAll(oList);
    backend.startWaitStatement(fc.constructName(""String_Node_Str"" + function),waitVars,usedVars,new ArrayList<Variable>(),false);
    assert(waitVars.size() == derefVars.size());
    for (int i=0; i < waitVars.size(); i++) {
      Variable derefVar=derefVars.get(i);
      varCreator.declare(derefVar);
      if (Types.isArrayRef(waitVars.get(i).getType())) {
        backend.retrieveRef(derefVar,waitVars.get(i));
      }
 else {
        throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"" + derefVar);
      }
    }
  }
  Arg priority=priorityVal != null ? Arg.createVar(priorityVal) : null;
  if (context.isBuiltinFunction(function)) {
    if (FunctionSemantics.hasLocalEquiv(function)) {
      assert(oList.size() <= 1);
      Variable out=oList.size() == 0 ? null : oList.get(0);
      backend.asyncOp(FunctionSemantics.getLocalEquiv(function),out,Arg.fromVarList(realIList),priority);
    }
 else {
      backend.builtinFunctionCall(function,realIList,oList,priority);
    }
  }
 else   if (context.isCompositeFunction(function))   backend.compositeFunctionCall(function,realIList,oList,null,!context.isSyncComposite(function),priority);
 else   throw UndefinedFunctionException.unknownFunction(context,function);
  if (waitContext != null) {
    backend.endWaitStatement(new ArrayList<Variable>());
  }
}",0.9855926653569088
133255,"/** 
 * Creates a new tmp value, entering it in the provided context and calling the backend to initialise it 
 * @param context
 * @param type
 * @param storeInStack if the variable should be stored in the stack
 * @param isAlias if the variable is just going to be an alias for anothervariable (i.e. no storage should be declared)
 * @return
 * @throws UserException
 * @throws UndefinedTypeException
 */
public Variable createTmp(Context context,SwiftType type,boolean storeInStack,boolean isAlias) throws UserException, UndefinedTypeException {
  if (storeInStack && isAlias) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"");
  }
  Variable tmp;
  if ((!storeInStack) && isAlias) {
    tmp=context.createAliasVariable(type);
  }
 else {
    tmp=context.createTmpVar(type,storeInStack);
  }
  initialiseVariable(context,tmp);
  return tmp;
}","/** 
 * Creates a new tmp value, entering it in the provided context and calling the backend to initialise it 
 * @param context
 * @param type
 * @param storeInStack if the variable should be stored in the stack
 * @param isAlias if the variable is just going to be an alias for anothervariable (i.e. no storage should be declared)
 * @return
 * @throws UserException
 * @throws UndefinedTypeException
 */
public Variable createTmp(Context context,SwiftType type,boolean storeInStack,boolean isAlias) throws UserException, UndefinedTypeException {
  assert(context != null);
  if (storeInStack && isAlias) {
    throw new STCRuntimeError(""String_Node_Str"" + ""String_Node_Str"");
  }
  Variable tmp;
  if ((!storeInStack) && isAlias) {
    tmp=context.createAliasVariable(type);
  }
 else {
    tmp=context.createTmpVar(type,storeInStack);
  }
  initialiseVariable(context,tmp);
  return tmp;
}",0.984650369528141
133256,"/** 
 * Get asynchronous implementation of builtin op TODO: this is a temporary solution to get this working. Will be better later on to have arith ops, etc in  different namespace entirely
 * @throws UserException 
 */
public static String getBuiltinOpImpl(BuiltinOpcode op){
  String impl=builtinOpImpls.get(op);
  if (impl != null) {
    return impl;
  }
  List<String> impls=FunctionSemantics.findOpImpl(op);
  assert(impls != null);
  assert(impls.size() > 0);
  if (impls.size() > 1) {
    Logger.getLogger(""String_Node_Str"").warn(""String_Node_Str"" + op + ""String_Node_Str""+ impls.toString());
  }
  return impls.get(0);
}","/** 
 * Get asynchronous implementation of builtin op TODO: this is a temporary solution to get this working. Will be better later on to have arith ops, etc in  different namespace entirely
 * @throws UserException 
 */
public static TclFunRef getBuiltinOpImpl(BuiltinOpcode op){
  TclFunRef impl=builtinOpImpls.get(op);
  if (impl != null) {
    return impl;
  }
  return null;
}",0.6964285714285714
133257,"private static void populateBuiltinOpImpls(){
  builtinOpImpls.put(BuiltinOpcode.PLUS_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.MINUS_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.MULT_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.DIV_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.MOD_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.NEGATE_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.EQ_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.NEQ_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.LT_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.LTE_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.GT_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.GTE_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.PLUS_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.MINUS_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.MULT_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.DIV_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.NEGATE_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.EQ_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.NEQ_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.LT_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.LTE_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.GT_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.GTE_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.EQ_STRING,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.NEQ_STRING,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.STRCAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.EQ_BOOL,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.NEQ_BOOL,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.AND,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.OR,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.NOT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.COPY_INT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.COPY_VOID,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.COPY_FLOAT,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.COPY_STRING,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.COPY_BOOL,""String_Node_Str"");
  builtinOpImpls.put(BuiltinOpcode.COPY_BLOB,""String_Node_Str"");
}","private static void populateBuiltinOpImpls(){
  builtinOpImpls.put(BuiltinOpcode.PLUS_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.MINUS_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.MULT_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.DIV_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.MOD_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.NEGATE_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.EQ_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.NEQ_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.LT_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.LTE_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.GT_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.GTE_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.PLUS_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.MINUS_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.MULT_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.DIV_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.NEGATE_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.EQ_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.NEQ_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.LT_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.LTE_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.GT_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.GTE_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.EQ_STRING,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.NEQ_STRING,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.STRCAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.EQ_BOOL,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.NEQ_BOOL,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.AND,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.OR,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.NOT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.COPY_INT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.COPY_VOID,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.COPY_FLOAT,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.COPY_STRING,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.COPY_BOOL,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
  builtinOpImpls.put(BuiltinOpcode.COPY_BLOB,new TclFunRef(OP_TCL_PKG,""String_Node_Str""));
}",0.5568221070811744
133258,"@Override public void asyncOp(BuiltinOpcode op,Variable out,List<Arg> in,Arg priority){
  String fnName=BuiltinOps.getBuiltinOpImpl(op);
  if (fnName == null) {
    throw new STCRuntimeError(""String_Node_Str"" + op + ""String_Node_Str"");
  }
  ArrayList<Variable> inputs=new ArrayList<Variable>();
  for (  Arg a : in) {
    assert(a.getType() == ArgType.VAR);
    inputs.add(a.getVar());
  }
  builtinFunctionCall(fnName,inputs,Arrays.asList(out),priority);
}","@Override public void asyncOp(BuiltinOpcode op,Variable out,List<Arg> in,Arg priority){
  TclFunRef fn=BuiltinOps.getBuiltinOpImpl(op);
  if (fn == null) {
    List<String> impls=FunctionSemantics.findOpImpl(op);
    assert(impls != null);
    assert(impls.size() > 0);
    if (impls.size() > 1) {
      Logger.getLogger(""String_Node_Str"").warn(""String_Node_Str"" + op + ""String_Node_Str""+ impls.toString());
    }
    fn=builtinSymbols.get(impls.get(0));
  }
  ArrayList<Variable> inputs=new ArrayList<Variable>();
  for (  Arg a : in) {
    assert(a.getType() == ArgType.VAR);
    inputs.add(a.getVar());
  }
  List<Variable> outL=(out == null) ? new ArrayList<Variable>(0) : Arrays.asList(out);
  builtinFunctionCall(""String_Node_Str"" + op.toString(),fn,inputs,outL,priority);
}",0.6138933764135702
133259,"@Override public void defineBuiltinFunction(String name,String pkg,String version,String symbol,FunctionType type,TclOpTemplate inlineTclTemplate){
  String pv=pkg + version;
  if (!pkg.equals(""String_Node_Str"")) {
    if (!requiredPackages.contains(pv)) {
      PackageRequire pr=new PackageRequire(pkg,version);
      pointStack.peek().add(pr);
      requiredPackages.add(pv);
      pointStack.peek().add(new Command(""String_Node_Str""));
    }
  }
  builtinSymbols.put(name,new TCLFunRef(pkg,symbol));
  logger.debug(""String_Node_Str"" + name);
}","@Override public void defineBuiltinFunction(String name,String pkg,String version,String symbol,FunctionType type,TclOpTemplate inlineTclTemplate){
  String pv=pkg + version;
  if (!pkg.equals(""String_Node_Str"")) {
    if (!requiredPackages.contains(pv)) {
      PackageRequire pr=new PackageRequire(pkg,version);
      pointStack.peek().add(pr);
      requiredPackages.add(pv);
      pointStack.peek().add(new Command(""String_Node_Str""));
    }
  }
  builtinSymbols.put(name,new TclFunRef(pkg,symbol));
  logger.debug(""String_Node_Str"" + name);
}",0.9963436928702012
133260,"@Override public void builtinFunctionCall(String function,List<Variable> inputs,List<Variable> outputs,Arg priority){
  assert(priority == null || priority.isImmediateInt());
  logger.debug(""String_Node_Str"" + function);
  TclList iList=tclListOfVariables(inputs);
  TclList oList=tclListOfVariables(outputs);
  TCLFunRef tclf=builtinSymbols.get(function);
  if (tclf == null) {
    throw new STCRuntimeError(""String_Node_Str"" + function);
  }
  Token f=new Token(tclf.pkg + ""String_Node_Str"" + tclf.symbol);
  Value s=new Value(Turbine.LOCAL_STACK_NAME);
  Command c=new Command(f,s,oList,iList);
  setPriority(priority);
  pointStack.peek().add(c);
  clearPriority(priority);
}","private void builtinFunctionCall(String function,TclFunRef tclf,List<Variable> inputs,List<Variable> outputs,Arg priority){
  TclList iList=tclListOfVariables(inputs);
  TclList oList=tclListOfVariables(outputs);
  if (tclf == null) {
    throw new STCRuntimeError(""String_Node_Str"" + function);
  }
  Token f=new Token(tclf.pkg + ""String_Node_Str"" + tclf.symbol);
  Value s=new Value(Turbine.LOCAL_STACK_NAME);
  Command c=new Command(f,s,oList,iList);
  setPriority(priority);
  pointStack.peek().add(c);
  clearPriority(priority);
}",0.8467874794069192
133261,"/** 
 * Internal helper to implement constructs that need to wait for a number of variables, and then run some code
 * @param procName
 * @param waitVars
 * @param usedVariables
 * @param containersToRegister
 * @param shareWork if true, work will be shared with other rule enginesat the cost of higher overhead
 */
private void startAsync(String procName,List<Variable> waitVars,List<Variable> usedVariables,List<Variable> containersToRegister,boolean shareWork){
  List<String> args=new ArrayList<String>();
  args.add(Turbine.LOCAL_STACK_NAME);
  for (  Variable v : usedVariables) {
    args.add(prefixVar(v.getName()));
  }
  Sequence constructProc=new Sequence();
  String uniqueName=uniqueTCLFunctionName(procName);
  Proc proc=new Proc(uniqueName,usedTclFunctionNames,args,constructProc);
  tree.add(proc);
  List<Value> inputs=new ArrayList<Value>();
  for (  Variable w : waitVars) {
    inputs.add(varToExpr(w));
  }
  for (  Variable c : containersToRegister) {
    pointStack.peek().add(Turbine.containerSlotCreate(varToExpr(c)));
  }
  TclList action=buildAction(uniqueName,usedVariables);
  pointStack.peek().add(Turbine.rule(uniqueName,inputs,action,shareWork));
  pointStack.push(constructProc);
}","/** 
 * Internal helper to implement constructs that need to wait for a number of variables, and then run some code
 * @param procName
 * @param waitVars
 * @param usedVariables
 * @param containersToRegister
 * @param shareWork if true, work will be shared with other rule enginesat the cost of higher overhead
 */
private void startAsync(String procName,List<Variable> waitVars,List<Variable> usedVariables,List<Variable> containersToRegister,boolean shareWork){
  ArrayList<Variable> toPassIn=new ArrayList<Variable>();
  HashSet<String> alreadyInSet=new HashSet<String>();
  for (  Variable v : usedVariables) {
    toPassIn.add(v);
    alreadyInSet.add(v.getName());
  }
  for (  Variable v : containersToRegister) {
    if (!alreadyInSet.contains(v.getName())) {
      toPassIn.add(v);
    }
  }
  List<String> args=new ArrayList<String>();
  args.add(Turbine.LOCAL_STACK_NAME);
  for (  Variable v : toPassIn) {
    args.add(prefixVar(v.getName()));
  }
  Sequence constructProc=new Sequence();
  String uniqueName=uniqueTCLFunctionName(procName);
  Proc proc=new Proc(uniqueName,usedTclFunctionNames,args,constructProc);
  tree.add(proc);
  List<Value> inputs=new ArrayList<Value>();
  for (  Variable w : waitVars) {
    inputs.add(varToExpr(w));
  }
  for (  Variable c : containersToRegister) {
    pointStack.peek().add(Turbine.containerSlotCreate(varToExpr(c)));
  }
  TclList action=buildAction(uniqueName,toPassIn);
  pointStack.peek().add(Turbine.rule(uniqueName,inputs,action,shareWork));
  pointStack.push(constructProc);
}",0.8624319419237749
133262,"/** 
 * Generate code for a call to a function, where the arguments might be expressions
 * @param context
 * @param tree
 * @param oList
 * @throws UserException
 * @throws UndefinedVariableException
 * @throws UndefinedFunctionException
 */
private void callFunctionExpression(Context context,SwiftAST tree,List<Variable> oList,Map<String,String> renames) throws UserException {
  assert(tree.getChildCount() >= 2 && tree.getChildCount() <= 3);
  String f=tree.child(0).getText();
  try {
    if (Builtins.isAssertVariant(f) && Settings.getBoolean(Settings.OPT_DISABLE_ASSERTS)) {
      return;
    }
  }
 catch (  InvalidOptionException e) {
    throw new STCRuntimeError(""String_Node_Str"" + e.toString());
  }
  SwiftAST arglist=tree.child(1);
  FunctionType ftype=context.lookupFunction(f);
  if (ftype == null) {
    throw UndefinedFunctionException.unknownFunction(context,f);
  }
  ArrayList<Variable> argVars=new ArrayList<Variable>(arglist.getChildCount());
  int argcount=arglist.getChildCount();
  for (int i=0; i < argcount; i++) {
    SwiftAST argtree=arglist.child(i);
    InArgT expType=ftype.getInputs().get(Math.min(i,ftype.getInputs().size() - 1));
    SwiftType argtype;
    if (expType.getAltCount() == 1) {
      argtype=TypeChecker.findSingleExprType(context,argtree,expType.getAlt(0));
    }
 else {
      argtype=TypeChecker.findSingleExprType(context,argtree);
      SwiftType matching=TypeChecker.whichAlternativeType(expType,argtype);
      if (matching != null && Types.isUpdateableEquiv(argtype,matching)) {
        argtree.clearTypeInfo();
        argtype=TypeChecker.findSingleExprType(context,argtree,matching);
      }
    }
    argVars.add(evalExprToTmp(context,argtree,argtype,false,renames));
  }
  Variable priorityVal=null;
  boolean openedWait=false;
  List<Variable> waitContainers=null;
  Context callContext=context;
  if (tree.getChildCount() == 3) {
    SwiftAST priorityT=tree.child(2);
    Variable priorityFuture=evalExprToTmp(context,priorityT,Types.FUTURE_INTEGER,false,renames);
    waitContainers=new ArrayList<Variable>(0);
    ArrayList<Variable> usedVariables=new ArrayList<Variable>();
    usedVariables.addAll(argVars);
    usedVariables.addAll(oList);
    backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(priorityFuture),usedVariables,waitContainers,false);
    openedWait=true;
    callContext=new LocalContext(context);
    priorityVal=varCreator.fetchValueOf(callContext,priorityFuture);
  }
  callFunction(context,f,oList,argVars,priorityVal);
  if (openedWait) {
    backend.endWaitStatement(waitContainers);
  }
}","/** 
 * Generate code for a call to a function, where the arguments might be expressions
 * @param context
 * @param tree
 * @param oList
 * @throws UserException
 * @throws UndefinedVariableException
 * @throws UndefinedFunctionException
 */
private void callFunctionExpression(Context context,SwiftAST tree,List<Variable> oList,Map<String,String> renames) throws UserException {
  assert(tree.getChildCount() >= 2 && tree.getChildCount() <= 3);
  String f=tree.child(0).getText();
  try {
    if (Builtins.isAssertVariant(f) && Settings.getBoolean(Settings.OPT_DISABLE_ASSERTS)) {
      return;
    }
  }
 catch (  InvalidOptionException e) {
    throw new STCRuntimeError(""String_Node_Str"" + e.toString());
  }
  SwiftAST arglist=tree.child(1);
  FunctionType ftype=context.lookupFunction(f);
  if (ftype == null) {
    throw UndefinedFunctionException.unknownFunction(context,f);
  }
  if (arglist.getChildCount() > 0 && ftype.getInputs().size() == 0) {
    throw new TypeMismatchException(context,""String_Node_Str"" + ""String_Node_Str"" + f);
  }
  ArrayList<Variable> argVars=new ArrayList<Variable>(arglist.getChildCount());
  int argcount=arglist.getChildCount();
  for (int i=0; i < argcount; i++) {
    SwiftAST argtree=arglist.child(i);
    InArgT expType=ftype.getInputs().get(Math.min(i,ftype.getInputs().size() - 1));
    SwiftType argtype;
    if (expType.getAltCount() == 1) {
      argtype=TypeChecker.findSingleExprType(context,argtree,expType.getAlt(0));
    }
 else {
      argtype=TypeChecker.findSingleExprType(context,argtree);
      SwiftType matching=TypeChecker.whichAlternativeType(expType,argtype);
      if (matching != null && Types.isUpdateableEquiv(argtype,matching)) {
        argtree.clearTypeInfo();
        argtype=TypeChecker.findSingleExprType(context,argtree,matching);
      }
    }
    argVars.add(evalExprToTmp(context,argtree,argtype,false,renames));
  }
  Variable priorityVal=null;
  boolean openedWait=false;
  List<Variable> waitContainers=null;
  Context callContext=context;
  if (tree.getChildCount() == 3) {
    SwiftAST priorityT=tree.child(2);
    Variable priorityFuture=evalExprToTmp(context,priorityT,Types.FUTURE_INTEGER,false,renames);
    waitContainers=new ArrayList<Variable>(0);
    ArrayList<Variable> usedVariables=new ArrayList<Variable>();
    usedVariables.addAll(argVars);
    usedVariables.addAll(oList);
    backend.startWaitStatement(context.getFunctionContext().constructName(""String_Node_Str""),Arrays.asList(priorityFuture),usedVariables,waitContainers,false);
    openedWait=true;
    callContext=new LocalContext(context);
    priorityVal=varCreator.fetchValueOf(callContext,priorityFuture);
  }
  callFunction(context,f,oList,argVars,priorityVal);
  if (openedWait) {
    backend.endWaitStatement(waitContainers);
  }
}",0.9701327433628318
133263,"/** 
 * Replace variables by name in list Remove variables with duplicate names
 * @param replacements
 * @param vars
 */
public static void replaceVarsInList(Map<String,Oparg> replacements,List<Variable> vars,boolean removeDupes){
  ArrayList<String> alreadySeen=null;
  if (removeDupes) {
    alreadySeen=new ArrayList<String>(vars.size());
  }
  int n=vars.size();
  for (int i=0; i < n; i++) {
    String varName=vars.get(i).getName();
    if (replacements.containsKey(varName)) {
      Oparg oa=replacements.get(varName);
      if (oa.getType() == OpargType.VAR) {
        if (removeDupes && alreadySeen.contains(oa.getVar().getName())) {
          vars.remove(i);
          i--;
          n--;
        }
 else {
          vars.set(i,oa.getVar());
          if (removeDupes) {
            alreadySeen.add(oa.getVar().getName());
          }
        }
      }
    }
 else {
      if (removeDupes) {
        if (alreadySeen.contains(varName)) {
          vars.remove(i);
          i--;
          n--;
        }
 else {
          alreadySeen.add(varName);
        }
      }
    }
  }
}","public static void replaceVarsInList(Map<String,Oparg> replacements,List<Variable> vars,boolean removeDupes,boolean removeMapped){
  ArrayList<String> alreadySeen=null;
  if (removeDupes) {
    alreadySeen=new ArrayList<String>(vars.size());
  }
  ListIterator<Variable> it=vars.listIterator();
  while (it.hasNext()) {
    Variable v=it.next();
    String varName=v.getName();
    if (replacements.containsKey(varName)) {
      Oparg oa=replacements.get(varName);
      if (oa.getType() == OpargType.VAR) {
        if (removeDupes && alreadySeen.contains(oa.getVar().getName())) {
          it.remove();
        }
 else {
          it.set(oa.getVar());
          if (removeDupes) {
            alreadySeen.add(oa.getVar().getName());
          }
        }
      }
    }
 else {
      if (removeDupes) {
        if (alreadySeen.contains(varName)) {
          it.remove();
        }
 else {
          alreadySeen.add(varName);
        }
      }
    }
  }
}",0.7688540646425074
133264,"/** 
 * Find all the directly assigned constants in the block
 * @param logger
 * @param block
 * @param knownConstants
 * @param removeDefs if true, remove the set instructions as we go
 */
private static void findBlockConstants(Logger logger,Block block,Map<String,Oparg> knownConstants,boolean removeLocalConsts,boolean ignoreLocalValConstants){
  Set<String> removalCandidates=null;
  if (removeLocalConsts) {
    removalCandidates=new HashSet<String>();
    for (    Variable v : block.getVariables()) {
      if (v.getStorage() != VariableStorage.ALIAS) {
        removalCandidates.add(v.getName());
      }
    }
  }
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (inst.getInputs().size() == 1) {
      Oparg input=inst.getInput(0);
      if (input.isConstant() && (inst.op == Opcode.STORE_INT || inst.op == Opcode.STORE_BOOL || inst.op == Opcode.STORE_FLOAT || inst.op == Opcode.STORE_STRING || (!ignoreLocalValConstants && inst.op == Opcode.LOCAL_OP && LocalBuiltin.isValueCopy(inst)))) {
        Oparg output=inst.getOutput(0);
        String varName=output.getVar().getName();
        if ((!removeLocalConsts) || removalCandidates.contains(varName)) {
          logger.debug(""String_Node_Str"" + varName);
          knownConstants.put(varName,input);
          if (removeLocalConsts && !inst.writesAliasVar()) {
            logger.trace(""String_Node_Str"" + inst.toString());
            it.remove();
          }
        }
      }
    }
  }
  if (removeLocalConsts) {
    block.removeVarDeclarations(knownConstants.keySet());
  }
}","/** 
 * Find all the directly assigned constants in the block
 * @param logger
 * @param block
 * @param knownConstants
 * @param removeDefs if true, remove the set instructions as we go
 */
private static void findBlockConstants(Logger logger,Block block,Map<String,Oparg> knownConstants,boolean removeLocalConsts,boolean ignoreLocalValConstants){
  Set<String> removalCandidates=null;
  if (removeLocalConsts) {
    removalCandidates=new HashSet<String>();
    for (    Variable v : block.getVariables()) {
      if (v.getStorage() != VariableStorage.ALIAS) {
        removalCandidates.add(v.getName());
      }
    }
  }
  ListIterator<Instruction> it=block.instructionIterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (inst.getInputs().size() == 1) {
      Oparg input=inst.getInput(0);
      if (input.isConstant() && (inst.op == Opcode.STORE_INT || inst.op == Opcode.STORE_BOOL || inst.op == Opcode.STORE_FLOAT || inst.op == Opcode.STORE_STRING || (!ignoreLocalValConstants && inst.op == Opcode.LOCAL_OP && LocalBuiltin.isValueCopy(inst)))) {
        Oparg output=inst.getOutput(0);
        String varName=output.getVar().getName();
        if ((!removeLocalConsts) || removalCandidates.contains(varName)) {
          logger.debug(""String_Node_Str"" + varName);
          knownConstants.put(varName,input);
          if (removeLocalConsts && !inst.hasSideEffects()) {
            logger.trace(""String_Node_Str"" + inst.toString());
            it.remove();
          }
        }
      }
    }
  }
  if (removeLocalConsts) {
    block.removeVarDeclarations(knownConstants.keySet());
  }
}",0.9913419913419912
133265,"private static List<ComputedValue> updateReplacements(Instruction inst,State av,HierarchicalMap<String,Oparg> replaceInputs,HierarchicalMap<String,Oparg> replaceAll){
  List<ComputedValue> icvs=inst.getComputedValues(av.availableVals);
  if (icvs != null) {
    for (    ComputedValue currCV : icvs) {
      if (ComputedValue.isCopy(currCV)) {
        replaceInputs.put(currCV.getValLocation().getVar().getName(),currCV.getInput(0));
        continue;
      }
      Oparg currLoc=currCV.getValLocation();
      if (!av.isAvailable(currCV)) {
        av.addComputedValue(currCV,false);
      }
 else       if (currLoc.isConstant()) {
        Oparg prevLoc=av.getLocation(currCV);
        if (prevLoc.getType() == OpargType.VAR) {
          assert(Types.isScalarValue(prevLoc.getVar().getType()));
          av.addComputedValue(currCV,true);
          replaceInputs.put(prevLoc.getVar().getName(),currLoc);
        }
 else {
          assert(currLoc.equals(prevLoc));
        }
      }
 else {
        final boolean usePrev;
        assert(currLoc.getType() == OpargType.VAR);
        Oparg prevLoc=av.getLocation(currCV);
        if (prevLoc.isConstant()) {
          usePrev=true;
        }
 else {
          assert(prevLoc.getType() == OpargType.VAR);
          boolean currClosed=av.isClosed(currLoc.getVar().getName());
          boolean prevClosed=av.isClosed(prevLoc.getVar().getName());
          if (currCV.equivType == EquivalenceType.REFERENCE) {
            replaceAll.put(currLoc.getVar().getName(),prevLoc);
          }
          if (prevClosed || !currClosed) {
            usePrev=true;
          }
 else {
            usePrev=false;
          }
        }
        if (usePrev) {
          replaceInputs.put(currLoc.getVar().getName(),prevLoc);
        }
 else {
          replaceInputs.put(prevLoc.getVar().getName(),currLoc);
        }
      }
    }
  }
  return icvs;
}","private static List<ComputedValue> updateReplacements(Logger logger,Instruction inst,State av,HierarchicalMap<String,Oparg> replaceInputs,HierarchicalMap<String,Oparg> replaceAll){
  List<ComputedValue> icvs=inst.getComputedValues(av.availableVals);
  logger.trace(""String_Node_Str"");
  if (icvs != null) {
    logger.trace(""String_Node_Str"" + icvs.toString());
    for (    ComputedValue currCV : icvs) {
      if (ComputedValue.isCopy(currCV)) {
        replaceInputs.put(currCV.getValLocation().getVar().getName(),currCV.getInput(0));
        continue;
      }
      Oparg currLoc=currCV.getValLocation();
      if (!av.isAvailable(currCV)) {
        av.addComputedValue(currCV,false);
      }
 else       if (currLoc.isConstant()) {
        Oparg prevLoc=av.getLocation(currCV);
        if (prevLoc.getType() == OpargType.VAR) {
          assert(Types.isScalarValue(prevLoc.getVar().getType()));
          av.addComputedValue(currCV,true);
          replaceInputs.put(prevLoc.getVar().getName(),currLoc);
        }
 else {
          assert(currLoc.equals(prevLoc));
        }
      }
 else {
        final boolean usePrev;
        assert(currLoc.getType() == OpargType.VAR);
        Oparg prevLoc=av.getLocation(currCV);
        if (prevLoc.isConstant()) {
          usePrev=true;
        }
 else {
          assert(prevLoc.getType() == OpargType.VAR);
          boolean currClosed=av.isClosed(currLoc.getVar().getName());
          boolean prevClosed=av.isClosed(prevLoc.getVar().getName());
          if (currCV.equivType == EquivalenceType.REFERENCE) {
            replaceAll.put(currLoc.getVar().getName(),prevLoc);
          }
          if (prevClosed || !currClosed) {
            usePrev=true;
          }
 else {
            usePrev=false;
          }
        }
        if (usePrev) {
          replaceInputs.put(currLoc.getVar().getName(),prevLoc);
        }
 else {
          replaceInputs.put(prevLoc.getVar().getName(),currLoc);
        }
      }
    }
  }
  return icvs;
}",0.9731543624161074
133266,"private static boolean forwardDataflow(Logger logger,CompFunction f,Block block,ListIterator<Instruction> insts,State cv,HierarchicalMap<String,Oparg> replaceInputs,HierarchicalMap<String,Oparg> replaceAll) throws InvalidWriteException {
  boolean anotherPassNeeded=false;
  while (insts.hasNext()) {
    Instruction inst=insts.next();
    logger.trace(""String_Node_Str"" + replaceInputs);
    logger.trace(""String_Node_Str"" + replaceAll);
    logger.trace(""String_Node_Str"" + cv.availableVals);
    logger.trace(""String_Node_Str"" + cv.closed);
    logger.trace(""String_Node_Str"");
    logger.trace(""String_Node_Str"" + inst);
    inst.renameInputs(replaceInputs);
    inst.renameVars(replaceAll);
    List<Instruction> alt=switchToImmediateVersion(logger,block,cv,inst);
    if (alt != null) {
      logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
      ICUtil.replaceInsts(insts,alt);
      ICUtil.rewindIterator(insts,alt.size());
      continue;
    }
    updateReplacements(inst,cv,replaceInputs,replaceAll);
    List<Variable> in=inst.getBlockingInputs();
    if (in != null) {
      for (      Oparg o : inst.getOutputs()) {
        Variable ov=o.getVar();
        if (!Types.isScalarValue(ov.getType())) {
          cv.setDependencies(ov,in);
        }
      }
    }
  }
  return anotherPassNeeded;
}","private static boolean forwardDataflow(Logger logger,CompFunction f,Block block,ListIterator<Instruction> insts,State cv,HierarchicalMap<String,Oparg> replaceInputs,HierarchicalMap<String,Oparg> replaceAll) throws InvalidWriteException {
  boolean anotherPassNeeded=false;
  while (insts.hasNext()) {
    Instruction inst=insts.next();
    logger.trace(""String_Node_Str"" + replaceInputs);
    logger.trace(""String_Node_Str"" + replaceAll);
    logger.trace(""String_Node_Str"" + cv.availableVals);
    logger.trace(""String_Node_Str"" + cv.closed);
    logger.trace(""String_Node_Str"");
    logger.trace(""String_Node_Str"" + inst);
    inst.renameInputs(replaceInputs);
    inst.renameVars(replaceAll);
    List<Instruction> alt=switchToImmediateVersion(logger,block,cv,inst);
    if (alt != null) {
      logger.trace(""String_Node_Str"" + inst + ""String_Node_Str""+ alt.toString());
      ICUtil.replaceInsts(insts,alt);
      ICUtil.rewindIterator(insts,alt.size());
      continue;
    }
    updateReplacements(logger,inst,cv,replaceInputs,replaceAll);
    List<Variable> in=inst.getBlockingInputs();
    if (in != null) {
      for (      Oparg o : inst.getOutputs()) {
        Variable ov=o.getVar();
        if (!Types.isScalarValue(ov.getType())) {
          cv.setDependencies(ov,in);
        }
      }
    }
  }
  return anotherPassNeeded;
}",0.9973831775700934
133267,"private static void mergeWaits(Logger logger,CompFunction fn,Block block){
  boolean converged;
  do {
    converged=true;
    Map<String,List<WaitStatement>> waitMap=buildWaitMap(block);
    String winner=mostSharedVar(waitMap);
    if (winner != null) {
      converged=false;
      List<WaitStatement> waits=waitMap.get(winner);
      assert(waits != null && waits.size() >= 2);
      Set<String> intersection=null;
      for (      WaitStatement wait : waits) {
        Set<String> nameSet=Variable.nameSet(wait.getWaitVars());
        if (intersection == null) {
          intersection=nameSet;
        }
 else {
          intersection.retainAll(nameSet);
        }
      }
      assert(intersection != null && !intersection.isEmpty());
      List<Variable> intersectionVs=ICUtil.getVarsByName(intersection,waits.get(0).getWaitVars());
      WaitStatement newWait=new WaitStatement(fn.getName() + ""String_Node_Str"",intersectionVs,new ArrayList<Variable>(0),new ArrayList<Variable>(0),false);
      for (      WaitStatement wait : waits) {
        wait.removeWaitVars(intersection);
        if (wait.getWaitVars().isEmpty()) {
          newWait.getBlock().insertInline(wait.getBlock());
        }
 else {
          newWait.getBlock().addContinuation(wait);
        }
      }
      block.addContinuation(newWait);
      block.removeContinuations(waits);
    }
  }
 while (!converged);
}","private static void mergeWaits(Logger logger,CompFunction fn,Block block){
  boolean converged;
  do {
    converged=true;
    Map<String,List<WaitStatement>> waitMap=buildWaitMap(block);
    String winner=mostSharedVar(waitMap);
    if (winner != null) {
      converged=false;
      List<WaitStatement> waits=waitMap.get(winner);
      assert(waits != null && waits.size() >= 2);
      boolean explicit=false;
      Set<String> intersection=null;
      for (      WaitStatement wait : waits) {
        Set<String> nameSet=Variable.nameSet(wait.getWaitVars());
        if (intersection == null) {
          intersection=nameSet;
        }
 else {
          intersection.retainAll(nameSet);
        }
        if (wait.isExplicit()) {
          explicit=true;
        }
      }
      assert(intersection != null && !intersection.isEmpty());
      List<Variable> intersectionVs=ICUtil.getVarsByName(intersection,waits.get(0).getWaitVars());
      WaitStatement newWait=new WaitStatement(fn.getName() + ""String_Node_Str"",intersectionVs,new ArrayList<Variable>(0),new ArrayList<Variable>(0),explicit);
      for (      WaitStatement wait : waits) {
        wait.removeWaitVars(intersection);
        if (wait.getWaitVars().isEmpty()) {
          newWait.getBlock().insertInline(wait.getBlock());
        }
 else {
          newWait.getBlock().addContinuation(wait);
        }
      }
      block.addContinuation(newWait);
      block.removeContinuations(waits);
    }
  }
 while (!converged);
}",0.9614449461618616
133268,"private Token arithOpTok(LocalOpcode op){
switch (op) {
case EQ_INT:
case EQ_FLOAT:
case EQ_BOOL:
    return new Token(""String_Node_Str"");
case NEQ_INT:
case NEQ_FLOAT:
case NEQ_BOOL:
  return new Token(""String_Node_Str"");
case PLUS_INT:
case PLUS_FLOAT:
return new Token(""String_Node_Str"");
case MINUS_INT:
case MINUS_FLOAT:
case NEGATE_INT:
case NEGATE_FLOAT:
return new Token(""String_Node_Str"");
case MULT_FLOAT:
case MULT_INT:
return new Token(""String_Node_Str"");
case POW_FLOAT:
return new Token(""String_Node_Str"");
case LT_INT:
case LT_FLOAT:
return new Token(""String_Node_Str"");
case LTE_INT:
case LTE_FLOAT:
return new Token(""String_Node_Str"");
case GT_INT:
case GT_FLOAT:
return new Token(""String_Node_Str"");
case GTE_INT:
case GTE_FLOAT:
return new Token(""String_Node_Str"");
case OR:
return new Token(""String_Node_Str"");
case AND:
return new Token(""String_Node_Str"");
case NOT:
return new Token(""String_Node_Str"");
case CEIL:
return new Token(""String_Node_Str"");
case FLOOR:
return new Token(""String_Node_Str"");
case ROUND:
return new Token(""String_Node_Str"");
case EXP:
return new Token(""String_Node_Str"");
case LOG:
return new Token(""String_Node_Str"");
case SQRT:
return new Token(""String_Node_Str"");
case ABS_FLOAT:
case ABS_INT:
return new Token(""String_Node_Str"");
case RANDOM:
return new Token(""String_Node_Str"");
case DIV_FLOAT:
return new Token(""String_Node_Str"");
default :
throw new ParserRuntimeException(""String_Node_Str"" + op.toString());
}
}","private Token arithOpTok(LocalOpcode op){
switch (op) {
case EQ_INT:
case EQ_FLOAT:
case EQ_BOOL:
    return new Token(""String_Node_Str"");
case NEQ_INT:
case NEQ_FLOAT:
case NEQ_BOOL:
  return new Token(""String_Node_Str"");
case PLUS_INT:
case PLUS_FLOAT:
return new Token(""String_Node_Str"");
case MINUS_INT:
case MINUS_FLOAT:
case NEGATE_INT:
case NEGATE_FLOAT:
return new Token(""String_Node_Str"");
case MULT_FLOAT:
case MULT_INT:
return new Token(""String_Node_Str"");
case POW_FLOAT:
return new Token(""String_Node_Str"");
case LT_INT:
case LT_FLOAT:
return new Token(""String_Node_Str"");
case LTE_INT:
case LTE_FLOAT:
return new Token(""String_Node_Str"");
case GT_INT:
case GT_FLOAT:
return new Token(""String_Node_Str"");
case GTE_INT:
case GTE_FLOAT:
return new Token(""String_Node_Str"");
case OR:
return new Token(""String_Node_Str"");
case AND:
return new Token(""String_Node_Str"");
case NOT:
return new Token(""String_Node_Str"");
case EXP:
return new Token(""String_Node_Str"");
case LOG:
return new Token(""String_Node_Str"");
case SQRT:
return new Token(""String_Node_Str"");
case ABS_FLOAT:
case ABS_INT:
return new Token(""String_Node_Str"");
case RANDOM:
return new Token(""String_Node_Str"");
case DIV_FLOAT:
return new Token(""String_Node_Str"");
default :
throw new ParserRuntimeException(""String_Node_Str"" + op.toString());
}
}",0.9475574712643678
133269,"private Expression[] arithOpExpr(LocalOpcode op,ArrayList<Expression> argExpr){
switch (op) {
case PLUS_INT:
case PLUS_FLOAT:
case MINUS_INT:
case MINUS_FLOAT:
case MULT_INT:
case MULT_FLOAT:
case DIV_FLOAT:
case POW_FLOAT:
case EQ_INT:
case NEQ_INT:
case LT_INT:
case LTE_INT:
case GT_INT:
case GTE_INT:
case LT_FLOAT:
case LTE_FLOAT:
case GT_FLOAT:
case GTE_FLOAT:
case EQ_FLOAT:
case NEQ_FLOAT:
case EQ_BOOL:
case NEQ_BOOL:
case EQ_STRING:
case NEQ_STRING:
case AND:
case OR:
    assert(argExpr.size() == 2);
  return new Expression[]{argExpr.get(0),arithOpTok(op),argExpr.get(1)};
case NOT:
case NEGATE_INT:
case NEGATE_FLOAT:
assert(argExpr.size() == 1);
return new Expression[]{arithOpTok(op),argExpr.get(0)};
case IS_NAN:
assert(argExpr.size() == 1);
return new Expression[]{argExpr.get(0),new Token(""String_Node_Str""),argExpr.get(0)};
case CEIL:
case FLOOR:
case ROUND:
case LOG:
case EXP:
case SQRT:
case ABS_FLOAT:
case ABS_INT:
return new Expression[]{arithOpTok(op),new Token(""String_Node_Str""),argExpr.get(0),new Token(""String_Node_Str"")};
case RANDOM:
return new Expression[]{arithOpTok(op),new Token(""String_Node_Str"")};
case INTTOFLOAT:
assert(argExpr.size() == 1);
return new Expression[]{argExpr.get(0)};
case MAX_FLOAT:
case MAX_INT:
case MIN_FLOAT:
case MIN_INT:
String fnName;
if (op == LocalOpcode.MAX_FLOAT || op == LocalOpcode.MAX_INT) {
fnName=""String_Node_Str"";
}
 else {
fnName=""String_Node_Str"";
}
return new Expression[]{new Token(fnName),new Token(""String_Node_Str""),argExpr.get(0),new Token(""String_Node_Str""),argExpr.get(1),new Token(""String_Node_Str"")};
default :
throw new ParserRuntimeException(""String_Node_Str"" + ""String_Node_Str"" + op.toString());
}
}","private Expression[] arithOpExpr(LocalOpcode op,ArrayList<Expression> argExpr){
switch (op) {
case PLUS_INT:
case PLUS_FLOAT:
case MINUS_INT:
case MINUS_FLOAT:
case MULT_INT:
case MULT_FLOAT:
case DIV_FLOAT:
case POW_FLOAT:
case EQ_INT:
case NEQ_INT:
case LT_INT:
case LTE_INT:
case GT_INT:
case GTE_INT:
case LT_FLOAT:
case LTE_FLOAT:
case GT_FLOAT:
case GTE_FLOAT:
case EQ_FLOAT:
case NEQ_FLOAT:
case EQ_BOOL:
case NEQ_BOOL:
case EQ_STRING:
case NEQ_STRING:
case AND:
case OR:
    assert(argExpr.size() == 2);
  return new Expression[]{argExpr.get(0),arithOpTok(op),argExpr.get(1)};
case NOT:
case NEGATE_INT:
case NEGATE_FLOAT:
assert(argExpr.size() == 1);
return new Expression[]{arithOpTok(op),argExpr.get(0)};
case IS_NAN:
assert(argExpr.size() == 1);
return new Expression[]{argExpr.get(0),new Token(""String_Node_Str""),argExpr.get(0)};
case LOG:
case EXP:
case SQRT:
case ABS_FLOAT:
case ABS_INT:
return new Expression[]{arithOpTok(op),new Token(""String_Node_Str""),argExpr.get(0),new Token(""String_Node_Str"")};
case RANDOM:
return new Expression[]{arithOpTok(op),new Token(""String_Node_Str"")};
case INTTOFLOAT:
assert(argExpr.size() == 1);
return new Expression[]{new Token(""String_Node_Str""),argExpr.get(0),new Token(""String_Node_Str"")};
case CEIL:
case FLOOR:
case ROUND:
{
String fname;
assert(argExpr.size() == 1);
switch (op) {
case CEIL:
fname=""String_Node_Str"";
break;
case FLOOR:
fname=""String_Node_Str"";
break;
case ROUND:
fname=""String_Node_Str"";
break;
default :
throw new STCRuntimeError(""String_Node_Str"");
}
return new Expression[]{new Token(""String_Node_Str"" + fname + ""String_Node_Str""),argExpr.get(0),new Token(""String_Node_Str"")};
}
case MAX_FLOAT:
case MAX_INT:
case MIN_FLOAT:
case MIN_INT:
String fnName;
if (op == LocalOpcode.MAX_FLOAT || op == LocalOpcode.MAX_INT) {
fnName=""String_Node_Str"";
}
 else {
fnName=""String_Node_Str"";
}
return new Expression[]{new Token(fnName),new Token(""String_Node_Str""),argExpr.get(0),new Token(""String_Node_Str""),argExpr.get(1),new Token(""String_Node_Str"")};
default :
throw new ParserRuntimeException(""String_Node_Str"" + ""String_Node_Str"" + op.toString());
}
}",0.7789142407553108
133270,"@Override public void startRangeLoop(String loopName,Variable loopVar,Oparg start,Oparg end,Oparg increment,boolean isSync,List<Variable> usedVariables,List<Variable> containersToRegister,int desiredUnroll,int splitDegree){
  assert(start.getType() == OpargType.INTVAL || (start.getType() == OpargType.VAR && start.getVariable().getType().equals(Types.VALUE_INTEGER)));
  assert(end.getType() == OpargType.INTVAL || (end.getType() == OpargType.VAR && end.getVariable().getType().equals(Types.VALUE_INTEGER)));
  assert(increment.getType() == OpargType.INTVAL || (increment.getType() == OpargType.VAR && increment.getVariable().getType().equals(Types.VALUE_INTEGER)));
  assert(loopVar.getType().equals(Types.VALUE_INTEGER));
  Expression startE=opargToExpr(start);
  Expression endE=opargToExpr(end);
  Expression incrE=opargToExpr(increment);
  if (splitDegree > 0) {
    startRangeSplit(loopName,usedVariables,containersToRegister,splitDegree,startE,endE,incrE);
    startRangeLoopInner(loopName,loopVar,isSync,usedVariables,containersToRegister,TCLTMP_RANGE_LO_V,TCLTMP_RANGE_HI_V,TCLTMP_RANGE_INC_V);
  }
 else {
    startRangeLoopInner(loopName,loopVar,isSync,usedVariables,containersToRegister,startE,endE,incrE);
  }
}","@Override public void startRangeLoop(String loopName,Variable loopVar,Oparg start,Oparg end,Oparg increment,boolean isSync,List<Variable> usedVariables,List<Variable> containersToRegister,int desiredUnroll,int splitDegree){
  assert(start.getType() == OpargType.INTVAL || (start.getType() == OpargType.VAR && start.getVar().getType().equals(Types.VALUE_INTEGER)));
  assert(end.getType() == OpargType.INTVAL || (end.getType() == OpargType.VAR && end.getVar().getType().equals(Types.VALUE_INTEGER)));
  assert(increment.getType() == OpargType.INTVAL || (increment.getType() == OpargType.VAR && increment.getVar().getType().equals(Types.VALUE_INTEGER)));
  assert(loopVar.getType().equals(Types.VALUE_INTEGER));
  Expression startE=opargToExpr(start);
  Expression endE=opargToExpr(end);
  Expression incrE=opargToExpr(increment);
  if (splitDegree > 0) {
    startRangeSplit(loopName,usedVariables,containersToRegister,splitDegree,startE,endE,incrE);
    startRangeLoopInner(loopName,loopVar,isSync,usedVariables,containersToRegister,TCLTMP_RANGE_LO_V,TCLTMP_RANGE_HI_V,TCLTMP_RANGE_INC_V);
  }
 else {
    startRangeLoopInner(loopName,loopVar,isSync,usedVariables,containersToRegister,startE,endE,incrE);
  }
}",0.9938398357289528
133271,"private Expression opargToExpr(Oparg in){
switch (in.getType()) {
case INTVAL:
    return new LiteralInt(in.getIntLit());
case BOOLVAL:
  return new LiteralInt(in.getBoolLit() ? 1 : 0);
case STRINGVAL:
return new TclString(in.getStringLit(),true);
case VAR:
return new Value(prefixVar(in.getVariable().getName()));
case FLOATVAL:
return new LiteralFloat(in.getFloatLit());
default :
throw new ParserRuntimeException(""String_Node_Str"" + in.getType().toString());
}
}","private Expression opargToExpr(Oparg in){
switch (in.getType()) {
case INTVAL:
    return new LiteralInt(in.getIntLit());
case BOOLVAL:
  return new LiteralInt(in.getBoolLit() ? 1 : 0);
case STRINGVAL:
return new TclString(in.getStringLit(),true);
case VAR:
return new Value(prefixVar(in.getVar().getName()));
case FLOATVAL:
return new LiteralFloat(in.getFloatLit());
default :
throw new ParserRuntimeException(""String_Node_Str"" + in.getType().toString());
}
}",0.9945945945945946
133272,"private RangeLoop(String loopName,Block block,Variable loopVar,Oparg start,Oparg end,Oparg increment,boolean isSync,List<Variable> usedVariables,List<Variable> containersToRegister,int desiredUnroll,int splitDegree){
  super(block,usedVariables,containersToRegister);
  assert(start.getType() == OpargType.INTVAL || (start.getType() == OpargType.VAR && start.getVariable().getType().equals(Types.VALUE_INTEGER)));
  assert(end.getType() == OpargType.INTVAL || (end.getType() == OpargType.VAR && end.getVariable().getType().equals(Types.VALUE_INTEGER)));
  assert(increment.getType() == OpargType.INTVAL || (increment.getType() == OpargType.VAR && increment.getVariable().getType().equals(Types.VALUE_INTEGER)));
  assert(loopVar.getType().equals(Types.VALUE_INTEGER));
  this.loopName=loopName;
  this.loopVar=loopVar;
  this.start=start;
  this.end=end;
  this.increment=increment;
  this.isSync=isSync;
  this.desiredUnroll=desiredUnroll;
  this.splitDegree=splitDegree;
}","private RangeLoop(String loopName,Block block,Variable loopVar,Oparg start,Oparg end,Oparg increment,boolean isSync,List<Variable> usedVariables,List<Variable> containersToRegister,int desiredUnroll,int splitDegree){
  super(block,usedVariables,containersToRegister);
  assert(start.getType() == OpargType.INTVAL || (start.getType() == OpargType.VAR && start.getVar().getType().equals(Types.VALUE_INTEGER)));
  assert(end.getType() == OpargType.INTVAL || (end.getType() == OpargType.VAR && end.getVar().getType().equals(Types.VALUE_INTEGER)));
  assert(increment.getType() == OpargType.INTVAL || (increment.getType() == OpargType.VAR && increment.getVar().getType().equals(Types.VALUE_INTEGER)));
  assert(loopVar.getType().equals(Types.VALUE_INTEGER));
  this.loopName=loopName;
  this.loopVar=loopVar;
  this.start=start;
  this.end=end;
  this.increment=increment;
  this.isSync=isSync;
  this.desiredUnroll=desiredUnroll;
  this.splitDegree=splitDegree;
}",0.992240041386446
133273,"@Override public boolean constantReplace(Map<String,Oparg> knownConstants){
  boolean anyChanged=false;
  Oparg oldVals[]=new Oparg[]{start,end,increment};
  Oparg newVals[]=new Oparg[3];
  for (int i=0; i < oldVals.length; i++) {
    Oparg old=oldVals[i];
    if (old.type == OpargType.VAR) {
      Oparg replacement=knownConstants.get(old.getVariable().getName());
      if (replacement != null) {
        assert(replacement.getType() == OpargType.INTVAL);
        anyChanged=true;
        newVals[i]=replacement;
      }
 else {
        newVals[i]=old;
      }
    }
 else {
      newVals[i]=old;
    }
  }
  start=newVals[0];
  end=newVals[1];
  increment=newVals[2];
  assert(start != null);
  assert(end != null);
  assert(increment != null);
  return anyChanged;
}","@Override public boolean constantReplace(Map<String,Oparg> knownConstants){
  boolean anyChanged=false;
  Oparg oldVals[]=new Oparg[]{start,end,increment};
  Oparg newVals[]=new Oparg[3];
  for (int i=0; i < oldVals.length; i++) {
    Oparg old=oldVals[i];
    if (old.type == OpargType.VAR) {
      Oparg replacement=knownConstants.get(old.getVar().getName());
      if (replacement != null) {
        assert(replacement.getType() == OpargType.INTVAL);
        anyChanged=true;
        newVals[i]=replacement;
      }
 else {
        newVals[i]=old;
      }
    }
 else {
      newVals[i]=old;
    }
  }
  start=newVals[0];
  end=newVals[1];
  increment=newVals[2];
  assert(start != null);
  assert(end != null);
  assert(increment != null);
  return anyChanged;
}",0.9967469095640858
133274,"private Oparg renameRangeArg(Oparg val,Map<String,Oparg> renames){
  if (val.type == OpargType.VAR) {
    String vName=val.getVariable().getName();
    if (renames.containsKey(vName)) {
      Oparg o=renames.get(vName);
      assert(o != null);
      return o;
    }
  }
  return val;
}","private Oparg renameRangeArg(Oparg val,Map<String,Oparg> renames){
  if (val.type == OpargType.VAR) {
    String vName=val.getVar().getName();
    if (renames.containsKey(vName)) {
      Oparg o=renames.get(vName);
      assert(o != null);
      return o;
    }
  }
  return val;
}",0.9911816578483243
133275,"@Override public void replaceInputs(Map<String,Oparg> renames){
  replaceVarsInBlocks(renames,true);
  ICUtil.replaceVarsInList2(renames,waitVars,true);
}","@Override public void replaceInputs(Map<String,Oparg> renames){
  replaceVarsInBlocks(renames,true);
  ICUtil.replaceVarsInList(renames,waitVars,true);
}",0.996742671009772
133276,"@Override public boolean tryUnroll(Logger logger,Block outerBlock){
  logger.trace(""String_Node_Str"" + loopName + ""String_Node_Str""+ desiredUnroll);
  if (this.desiredUnroll > 1) {
    logger.debug(""String_Node_Str"" + desiredUnroll + ""String_Node_Str"");
    Oparg oldStep=this.increment;
    long checkIter;
    if (increment.getType() == OpargType.INTVAL && start.getType() == OpargType.INTVAL && end.getType() == OpargType.INTVAL) {
      long startV=start.getIntLit();
      long endV=end.getIntLit();
      long incV=increment.getIntLit();
      long diff=(endV - startV + 1);
      long iters=((diff - 1) / incV) + 1;
      long extra=iters % desiredUnroll;
      if (extra == 0) {
        checkIter=desiredUnroll;
      }
 else {
        checkIter=extra;
      }
    }
 else {
      checkIter=-1;
    }
    if (oldStep.getType() == OpargType.INTVAL) {
      this.increment=Oparg.createIntLit(oldStep.getIntLit() * desiredUnroll);
    }
 else {
      Variable old=oldStep.getVariable();
      Variable newIncrement=new Variable(old.getType(),old.getName() + ""String_Node_Str"" + desiredUnroll,VariableStorage.LOCAL,DefType.LOCAL_COMPILER,null);
      outerBlock.declareVariable(newIncrement);
      outerBlock.addInstruction(new LocalBuiltin(LocalOpcode.MULT_INT,newIncrement,Arrays.asList(oldStep,Oparg.createIntLit(desiredUnroll))));
      this.increment=Oparg.createVar(newIncrement);
    }
    Block orig=loopBody;
    this.loopBody=new Block(BlockType.LOOP_BODY);
    Block curr=loopBody;
    Variable nextIter=loopVar;
    for (int i=0; i < desiredUnroll; i++) {
      NestedBlock nb=new NestedBlock(orig.clone(BlockType.NESTED_BLOCK));
      curr.addContinuation(nb);
      if (i != 0) {
        nb.replaceVars(Collections.singletonMap(this.loopVar.getName(),Oparg.createVar(nextIter)));
      }
      if (i < desiredUnroll - 1) {
        Variable lastIter=nextIter;
        nextIter=new Variable(Types.VALUE_INTEGER,this.loopVar.getName() + ""String_Node_Str"" + (i + 1),VariableStorage.LOCAL,DefType.LOCAL_COMPILER,null);
        curr.addVariable(nextIter);
        curr.addInstruction(new LocalBuiltin(LocalOpcode.PLUS_INT,nextIter,Arrays.asList(Oparg.createVar(lastIter),oldStep)));
        boolean mustCheck=checkIter < 0 || i + 1 == checkIter;
        if (mustCheck) {
          Variable nextIterCheck=new Variable(Types.VALUE_BOOLEAN,this.loopVar.getName() + ""String_Node_Str"" + (i + 1)+ ""String_Node_Str"",VariableStorage.LOCAL,DefType.LOCAL_COMPILER,null);
          curr.addVariable(nextIterCheck);
          curr.addInstruction(new LocalBuiltin(LocalOpcode.LTE_INT,nextIterCheck,Arrays.asList(Oparg.createVar(nextIter),this.end)));
          IfStatement ifSt=new IfStatement(nextIterCheck);
          curr.addContinuation(ifSt);
          curr=ifSt.getThenBlock();
        }
      }
 else {
        curr=null;
      }
    }
    this.desiredUnroll=1;
    return true;
  }
  return false;
}","@Override public boolean tryUnroll(Logger logger,Block outerBlock){
  logger.trace(""String_Node_Str"" + loopName + ""String_Node_Str""+ desiredUnroll);
  if (this.desiredUnroll > 1) {
    logger.debug(""String_Node_Str"" + desiredUnroll + ""String_Node_Str"");
    Oparg oldStep=this.increment;
    long checkIter;
    if (increment.getType() == OpargType.INTVAL && start.getType() == OpargType.INTVAL && end.getType() == OpargType.INTVAL) {
      long startV=start.getIntLit();
      long endV=end.getIntLit();
      long incV=increment.getIntLit();
      long diff=(endV - startV + 1);
      long iters=((diff - 1) / incV) + 1;
      long extra=iters % desiredUnroll;
      if (extra == 0) {
        checkIter=desiredUnroll;
      }
 else {
        checkIter=extra;
      }
    }
 else {
      checkIter=-1;
    }
    if (oldStep.getType() == OpargType.INTVAL) {
      this.increment=Oparg.createIntLit(oldStep.getIntLit() * desiredUnroll);
    }
 else {
      Variable old=oldStep.getVar();
      Variable newIncrement=new Variable(old.getType(),old.getName() + ""String_Node_Str"" + desiredUnroll,VariableStorage.LOCAL,DefType.LOCAL_COMPILER,null);
      outerBlock.declareVariable(newIncrement);
      outerBlock.addInstruction(new LocalBuiltin(LocalOpcode.MULT_INT,newIncrement,Arrays.asList(oldStep,Oparg.createIntLit(desiredUnroll))));
      this.increment=Oparg.createVar(newIncrement);
    }
    Block orig=loopBody;
    this.loopBody=new Block(BlockType.LOOP_BODY);
    Block curr=loopBody;
    Variable nextIter=loopVar;
    for (int i=0; i < desiredUnroll; i++) {
      NestedBlock nb=new NestedBlock(orig.clone(BlockType.NESTED_BLOCK));
      curr.addContinuation(nb);
      if (i != 0) {
        nb.replaceVars(Collections.singletonMap(this.loopVar.getName(),Oparg.createVar(nextIter)));
      }
      if (i < desiredUnroll - 1) {
        Variable lastIter=nextIter;
        nextIter=new Variable(Types.VALUE_INTEGER,this.loopVar.getName() + ""String_Node_Str"" + (i + 1),VariableStorage.LOCAL,DefType.LOCAL_COMPILER,null);
        curr.addVariable(nextIter);
        curr.addInstruction(new LocalBuiltin(LocalOpcode.PLUS_INT,nextIter,Arrays.asList(Oparg.createVar(lastIter),oldStep)));
        boolean mustCheck=checkIter < 0 || i + 1 == checkIter;
        if (mustCheck) {
          Variable nextIterCheck=new Variable(Types.VALUE_BOOLEAN,this.loopVar.getName() + ""String_Node_Str"" + (i + 1)+ ""String_Node_Str"",VariableStorage.LOCAL,DefType.LOCAL_COMPILER,null);
          curr.addVariable(nextIterCheck);
          curr.addInstruction(new LocalBuiltin(LocalOpcode.LTE_INT,nextIterCheck,Arrays.asList(Oparg.createVar(nextIter),this.end)));
          IfStatement ifSt=new IfStatement(nextIterCheck);
          curr.addContinuation(ifSt);
          curr=ifSt.getThenBlock();
        }
      }
 else {
        curr=null;
      }
    }
    this.desiredUnroll=1;
    return true;
  }
  return false;
}",0.9991392666551904
133277,"private void replaceShared(Map<String,Oparg> renames,boolean inputsOnly){
  replaceVarsInBlocks(renames,inputsOnly);
  if (renames.containsKey(condVar.getName())) {
    condVar=renames.get(condVar.getName()).getVariable();
  }
}","private void replaceShared(Map<String,Oparg> renames,boolean inputsOnly){
  replaceVarsInBlocks(renames,inputsOnly);
  if (renames.containsKey(condVar.getName())) {
    condVar=renames.get(condVar.getName()).getVar();
  }
}",0.9889135254988912
133278,"@Override public void replaceVars(Map<String,Oparg> renames){
  replaceVarsInBlocks(renames,false);
  ICUtil.replaceVarsInList2(renames,waitVars,true);
  ICUtil.replaceVarsInList2(renames,usedVariables,true);
  ICUtil.replaceVarsInList2(renames,containersToRegister,true);
}","@Override public void replaceVars(Map<String,Oparg> renames){
  replaceVarsInBlocks(renames,false);
  ICUtil.replaceVarsInList(renames,waitVars,true);
  ICUtil.replaceVarsInList(renames,usedVariables,true);
  ICUtil.replaceVarsInList(renames,containersToRegister,true);
}",0.9944954128440368
133279,"protected void checkNotRemoved(Oparg o,Set<String> removeVars){
  if (o.type == OpargType.VAR) {
    checkNotRemoved(o.getVariable(),removeVars);
  }
}","protected void checkNotRemoved(Oparg o,Set<String> removeVars){
  if (o.type == OpargType.VAR) {
    checkNotRemoved(o.getVar(),removeVars);
  }
}",0.9831649831649832
133280,"/** 
 * Make all of variable names in composite functions completely unique within the function 
 * @param in
 */
public static void makeVarNamesUnique(Program in){
  for (  CompFunction f : in.getComposites()) {
    makeVarNamesUnique(f);
  }
}","/** 
 * Make all of variable names in composite functions completely unique within the function 
 * @param in
 */
public static void makeVarNamesUnique(Program in){
  for (  CompFunction f : in.getComposites()) {
    makeVarNamesUnique(f,in.getGlobalConsts().keySet());
  }
}",0.9423076923076924
133281,"static String encode(BigInteger plain){
  String plain_string=plain.toString();
  int length=plain_string.length();
  int[] plain_string_10=new int[ReedSolomon.base_10_length];
  for (int i=0; i < length; i++) {
    plain_string_10[i]=(int)plain_string.charAt(i) - (int)'0';
  }
  int codeword_length=0;
  int[] codeword=new int[ReedSolomon.initial_codeword.length];
  do {
    int new_length=0;
    int digit_32=0;
    for (int i=0; i < length; i++) {
      digit_32=digit_32 * 10 + plain_string_10[i];
      if (digit_32 >= 32) {
        plain_string_10[new_length]=digit_32 >> 5;
        digit_32&=31;
        new_length+=1;
      }
 else       if (new_length > 0) {
        plain_string_10[new_length]=0;
        new_length+=1;
      }
    }
    length=new_length;
    codeword[codeword_length]=digit_32;
    codeword_length+=1;
  }
 while (length > 0);
  int[] p={0,0,0,0};
  for (int i=ReedSolomon.base_32_length - 1; i >= 0; i--) {
    final int fb=codeword[i] ^ p[3];
    p[3]=p[2] ^ ReedSolomon.gmult(30,fb);
    p[2]=p[1] ^ ReedSolomon.gmult(6,fb);
    p[1]=p[0] ^ ReedSolomon.gmult(9,fb);
    p[0]=ReedSolomon.gmult(17,fb);
  }
  System.arraycopy(p,0,codeword,ReedSolomon.base_32_length,ReedSolomon.initial_codeword.length - ReedSolomon.base_32_length);
  StringBuilder cypher_string_builder=new StringBuilder();
  for (int i=0; i < 17; i++) {
    final int codework_index=ReedSolomon.codeword_map[i];
    final int alphabet_index=codeword[codework_index];
    cypher_string_builder.append(ReedSolomon.alphabet.charAt(alphabet_index));
    if ((i & 3) == 3 && i < 13) {
      cypher_string_builder.append('-');
    }
  }
  return cypher_string_builder.toString();
}","public static String encode(BigInteger plain){
  String plain_string=plain.toString();
  int length=plain_string.length();
  int[] plain_string_10=new int[ReedSolomon.base_10_length];
  for (int i=0; i < length; i++) {
    plain_string_10[i]=(int)plain_string.charAt(i) - (int)'0';
  }
  int codeword_length=0;
  int[] codeword=new int[ReedSolomon.initial_codeword.length];
  do {
    int new_length=0;
    int digit_32=0;
    for (int i=0; i < length; i++) {
      digit_32=digit_32 * 10 + plain_string_10[i];
      if (digit_32 >= 32) {
        plain_string_10[new_length]=digit_32 >> 5;
        digit_32&=31;
        new_length+=1;
      }
 else       if (new_length > 0) {
        plain_string_10[new_length]=0;
        new_length+=1;
      }
    }
    length=new_length;
    codeword[codeword_length]=digit_32;
    codeword_length+=1;
  }
 while (length > 0);
  int[] p={0,0,0,0};
  for (int i=ReedSolomon.base_32_length - 1; i >= 0; i--) {
    final int fb=codeword[i] ^ p[3];
    p[3]=p[2] ^ ReedSolomon.gmult(30,fb);
    p[2]=p[1] ^ ReedSolomon.gmult(6,fb);
    p[1]=p[0] ^ ReedSolomon.gmult(9,fb);
    p[0]=ReedSolomon.gmult(17,fb);
  }
  System.arraycopy(p,0,codeword,ReedSolomon.base_32_length,ReedSolomon.initial_codeword.length - ReedSolomon.base_32_length);
  StringBuilder cypher_string_builder=new StringBuilder();
  for (int i=0; i < 17; i++) {
    final int codework_index=ReedSolomon.codeword_map[i];
    final int alphabet_index=codeword[codework_index];
    cypher_string_builder.append(ReedSolomon.alphabet.charAt(alphabet_index));
    if ((i & 3) == 3 && i < 13) {
      cypher_string_builder.append('-');
    }
  }
  return cypher_string_builder.toString();
}",0.9979160464423936
133282,"static BigInteger decode(String cypher_string) throws DecodeException {
  int[] codeword=new int[ReedSolomon.initial_codeword.length];
  System.arraycopy(ReedSolomon.initial_codeword,0,codeword,0,ReedSolomon.initial_codeword.length);
  int codeword_length=0;
  for (int i=0; i < cypher_string.length(); i++) {
    int position_in_alphabet=ReedSolomon.alphabet.indexOf(cypher_string.charAt(i));
    if (position_in_alphabet <= -1 || position_in_alphabet > ReedSolomon.alphabet.length()) {
      continue;
    }
    if (codeword_length > 16) {
      throw new CodewordTooLongException();
    }
    int codework_index=ReedSolomon.codeword_map[codeword_length];
    codeword[codework_index]=position_in_alphabet;
    codeword_length+=1;
  }
  if (codeword_length == 17 && !ReedSolomon.is_codeword_valid(codeword) || codeword_length != 17) {
    throw new CodewordInvalidException();
  }
  int length=ReedSolomon.base_32_length;
  int[] cypher_string_32=new int[length];
  for (int i=0; i < length; i++) {
    cypher_string_32[i]=codeword[length - i - 1];
  }
  StringBuilder plain_string_builder=new StringBuilder();
  do {
    int new_length=0;
    int digit_10=0;
    for (int i=0; i < length; i++) {
      digit_10=digit_10 * 32 + cypher_string_32[i];
      if (digit_10 >= 10) {
        cypher_string_32[new_length]=digit_10 / 10;
        digit_10%=10;
        new_length+=1;
      }
 else       if (new_length > 0) {
        cypher_string_32[new_length]=0;
        new_length+=1;
      }
    }
    length=new_length;
    plain_string_builder.append((char)(digit_10 + (int)'0'));
  }
 while (length > 0);
  return new BigInteger(plain_string_builder.reverse().toString());
}","public static BigInteger decode(String cypher_string) throws DecodeException {
  int[] codeword=new int[ReedSolomon.initial_codeword.length];
  System.arraycopy(ReedSolomon.initial_codeword,0,codeword,0,ReedSolomon.initial_codeword.length);
  int codeword_length=0;
  for (int i=0; i < cypher_string.length(); i++) {
    int position_in_alphabet=ReedSolomon.alphabet.indexOf(cypher_string.charAt(i));
    if (position_in_alphabet <= -1 || position_in_alphabet > ReedSolomon.alphabet.length()) {
      continue;
    }
    if (codeword_length > 16) {
      throw new CodewordTooLongException();
    }
    int codework_index=ReedSolomon.codeword_map[codeword_length];
    codeword[codework_index]=position_in_alphabet;
    codeword_length+=1;
  }
  if (codeword_length == 17 && !ReedSolomon.is_codeword_valid(codeword) || codeword_length != 17) {
    throw new CodewordInvalidException();
  }
  int length=ReedSolomon.base_32_length;
  int[] cypher_string_32=new int[length];
  for (int i=0; i < length; i++) {
    cypher_string_32[i]=codeword[length - i - 1];
  }
  StringBuilder plain_string_builder=new StringBuilder();
  do {
    int new_length=0;
    int digit_10=0;
    for (int i=0; i < length; i++) {
      digit_10=digit_10 * 32 + cypher_string_32[i];
      if (digit_10 >= 10) {
        cypher_string_32[new_length]=digit_10 / 10;
        digit_10%=10;
        new_length+=1;
      }
 else       if (new_length > 0) {
        cypher_string_32[new_length]=0;
        new_length+=1;
      }
    }
    length=new_length;
    plain_string_builder.append((char)(digit_10 + (int)'0'));
  }
 while (length > 0);
  return new BigInteger(plain_string_builder.reverse().toString());
}",0.997913561847988
133283,"private void getRates(String name,String params){
  for (int i=0; i < extensions.size(); i++) {
    IExtension extension=extensions.get(i);
    final IRateSource rs=extension.createRateSource(name + ""String_Node_Str"" + params);
    if (rs != null) {
      final String preferredFiatCurrency=rs.getPreferredFiatCurrency();
      final Set<String> fiatCurrencies=rs.getFiatCurrencies();
      final Set<String> cryptoCurrencies=rs.getCryptoCurrencies();
      System.out.println(""String_Node_Str"" + preferredFiatCurrency);
      System.out.println(""String_Node_Str"");
      for (      String fiatCurrency : fiatCurrencies) {
        System.out.println(""String_Node_Str"" + fiatCurrency);
      }
      System.out.println(""String_Node_Str"");
      String selectedCryptoCurrency=null;
      for (      String cryptoCurrency : cryptoCurrencies) {
        if (selectedCryptoCurrency == null) {
          selectedCryptoCurrency=cryptoCurrency;
        }
        System.out.println(""String_Node_Str"" + cryptoCurrency);
      }
      final BigDecimal exchangeRateLast=rs.getExchangeRateLast(selectedCryptoCurrency,preferredFiatCurrency);
      if (exchangeRateLast != null) {
        System.out.println(""String_Node_Str"" + selectedCryptoCurrency + ""String_Node_Str""+ exchangeRateLast.stripTrailingZeros().toPlainString()+ ""String_Node_Str""+ preferredFiatCurrency);
      }
 else {
        System.err.println(""String_Node_Str"");
      }
      if (rs instanceof IRateSourceAdvanced) {
        IRateSourceAdvanced rsa=(IRateSourceAdvanced)rs;
        for (        String fiatCurrency : fiatCurrencies) {
          System.out.println(""String_Node_Str"" + fiatCurrency);
          final BigDecimal buyPrice=rsa.getExchangeRateForBuy(selectedCryptoCurrency,fiatCurrency);
          if (buyPrice != null) {
            System.out.println(""String_Node_Str"" + selectedCryptoCurrency + ""String_Node_Str""+ buyPrice.stripTrailingZeros().toPlainString()+ ""String_Node_Str""+ fiatCurrency);
          }
 else {
            System.err.println(""String_Node_Str"");
          }
          final BigDecimal sellPrice=rsa.getExchangeRateForSell(selectedCryptoCurrency,fiatCurrency);
          if (sellPrice != null) {
            System.out.println(""String_Node_Str"" + selectedCryptoCurrency + ""String_Node_Str""+ sellPrice.stripTrailingZeros().toPlainString()+ ""String_Node_Str""+ fiatCurrency);
          }
 else {
            System.err.println(""String_Node_Str"");
          }
        }
      }
      return;
    }
  }
  System.err.println(""String_Node_Str"");
}","private void getRates(String name,String params){
  for (int i=0; i < extensions.size(); i++) {
    IExtension extension=extensions.get(i);
    final IRateSource rs=extension.createRateSource(name + ""String_Node_Str"" + params);
    if (rs != null) {
      final String preferredFiatCurrency=rs.getPreferredFiatCurrency();
      final Set<String> fiatCurrencies=rs.getFiatCurrencies();
      final Set<String> cryptoCurrencies=rs.getCryptoCurrencies();
      System.out.println(""String_Node_Str"" + preferredFiatCurrency);
      System.out.println(""String_Node_Str"");
      for (      String fiatCurrency : fiatCurrencies) {
        System.out.println(""String_Node_Str"" + fiatCurrency);
      }
      System.out.println(""String_Node_Str"");
      String selectedCryptoCurrency=params;
      for (      String cryptoCurrency : cryptoCurrencies) {
        if (selectedCryptoCurrency == null) {
          selectedCryptoCurrency=cryptoCurrency;
        }
        System.out.println(""String_Node_Str"" + cryptoCurrency);
      }
      final BigDecimal exchangeRateLast=rs.getExchangeRateLast(selectedCryptoCurrency,preferredFiatCurrency);
      if (exchangeRateLast != null) {
        System.out.println(""String_Node_Str"" + selectedCryptoCurrency + ""String_Node_Str""+ exchangeRateLast.stripTrailingZeros().toPlainString()+ ""String_Node_Str""+ preferredFiatCurrency);
      }
 else {
        System.err.println(""String_Node_Str"");
      }
      if (rs instanceof IRateSourceAdvanced) {
        IRateSourceAdvanced rsa=(IRateSourceAdvanced)rs;
        for (        String fiatCurrency : fiatCurrencies) {
          System.out.println(""String_Node_Str"" + fiatCurrency);
          final BigDecimal buyPrice=rsa.getExchangeRateForBuy(selectedCryptoCurrency,fiatCurrency);
          if (buyPrice != null) {
            System.out.println(""String_Node_Str"" + selectedCryptoCurrency + ""String_Node_Str""+ buyPrice.stripTrailingZeros().toPlainString()+ ""String_Node_Str""+ fiatCurrency);
          }
 else {
            System.err.println(""String_Node_Str"");
          }
          final BigDecimal sellPrice=rsa.getExchangeRateForSell(selectedCryptoCurrency,fiatCurrency);
          if (sellPrice != null) {
            System.out.println(""String_Node_Str"" + selectedCryptoCurrency + ""String_Node_Str""+ sellPrice.stripTrailingZeros().toPlainString()+ ""String_Node_Str""+ fiatCurrency);
          }
 else {
            System.err.println(""String_Node_Str"");
          }
        }
      }
      return;
    }
  }
  System.err.println(""String_Node_Str"");
}",0.9980237154150198
133284,"@Override public IRateSource createRateSource(String sourceLogin){
  if (sourceLogin != null && !sourceLogin.trim().isEmpty()) {
    StringTokenizer st=new StringTokenizer(sourceLogin,""String_Node_Str"");
    String exchangeType=st.nextToken();
    if (""String_Node_Str"".equalsIgnoreCase(exchangeType)) {
      return new SmartcashTickerRateSource();
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(exchangeType)) {
      BigDecimal rate=BigDecimal.ZERO;
      if (st.hasMoreTokens()) {
        try {
          rate=new BigDecimal(st.nextToken());
        }
 catch (        Throwable e) {
        }
      }
      String preferedFiatCurrency=ICurrencies.USD;
      if (st.hasMoreTokens()) {
        preferedFiatCurrency=st.nextToken().toUpperCase();
      }
      return new FixPriceRateSource(rate,preferedFiatCurrency);
    }
  }
  return null;
}","@Override public IRateSource createRateSource(String sourceLogin){
  if (sourceLogin != null && !sourceLogin.trim().isEmpty()) {
    StringTokenizer st=new StringTokenizer(sourceLogin,""String_Node_Str"");
    String exchangeType=st.nextToken();
    if (""String_Node_Str"".equalsIgnoreCase(exchangeType)) {
      BigDecimal rate=BigDecimal.ZERO;
      if (st.hasMoreTokens()) {
        try {
          rate=new BigDecimal(st.nextToken());
        }
 catch (        Throwable e) {
        }
      }
      String preferedFiatCurrency=ICurrencies.USD;
      if (st.hasMoreTokens()) {
        preferedFiatCurrency=st.nextToken().toUpperCase();
      }
      return new FixPriceRateSource(rate,preferedFiatCurrency);
    }
  }
  return null;
}",0.9256926952141058
133285,"@Override public IWallet createWallet(String walletLogin){
  if (walletLogin != null && !walletLogin.trim().isEmpty()) {
    StringTokenizer st=new StringTokenizer(walletLogin,""String_Node_Str"");
    String walletType=st.nextToken();
    if (""String_Node_Str"".equalsIgnoreCase(walletType)) {
      String protocol=st.nextToken();
      String username=st.nextToken();
      String password=st.nextToken();
      String hostname=st.nextToken();
      String port=st.nextToken();
      String accountName=""String_Node_Str"";
      if (st.hasMoreTokens()) {
        accountName=st.nextToken();
      }
      if (protocol != null && username != null && password != null && hostname != null && port != null && accountName != null) {
        String rpcURL=protocol + ""String_Node_Str"" + username+ ""String_Node_Str""+ password+ ""String_Node_Str""+ hostname+ ""String_Node_Str""+ port;
        return new SmartcashdRPCWallet(rpcURL,accountName);
      }
    }
  }
  return null;
}","@Override public IWallet createWallet(String walletLogin){
  if (walletLogin != null && !walletLogin.trim().isEmpty()) {
    StringTokenizer st=new StringTokenizer(walletLogin,""String_Node_Str"");
    String walletType=st.nextToken();
    if (""String_Node_Str"".equalsIgnoreCase(walletType)) {
      String protocol=st.nextToken();
      String username=st.nextToken();
      String password=st.nextToken();
      String hostname=st.nextToken();
      String port=st.nextToken();
      String accountName=""String_Node_Str"";
      if (st.hasMoreTokens()) {
        accountName=st.nextToken();
      }
      if (protocol != null && username != null && password != null && hostname != null && port != null && accountName != null) {
        String rpcURL=protocol + ""String_Node_Str"" + username+ ""String_Node_Str""+ password+ ""String_Node_Str""+ hostname+ ""String_Node_Str""+ port;
        return new SmartcashRPCWallet(rpcURL,accountName);
      }
    }
  }
  return null;
}",0.999482669425763
133286,"private void loadFiatCurrencies(){
  IBitcoinAverage api=RestProxyFactory.createProxy(IBitcoinAverage.class,""String_Node_Str"");
  HashMap<String,String> currenciesAndURLs=api.getFiatCurrenciesAndURLs();
  if (fiatCurrenciesAndURLs != null) {
    fiatCurrenciesAndURLs=currenciesAndURLs;
  }
}","private void loadFiatCurrencies(){
  IBitcoinAverage api=RestProxyFactory.createProxy(IBitcoinAverage.class,""String_Node_Str"");
  HashMap<String,String> currenciesAndURLs=api.getFiatCurrenciesAndURLs();
  if (currenciesAndURLs != null) {
    for (    Map.Entry<String,String> entry : currenciesAndURLs.entrySet()) {
      entry.setValue(entry.getValue().replace(""String_Node_Str"",""String_Node_Str""));
    }
    fiatCurrenciesAndURLs=currenciesAndURLs;
  }
}",0.7663551401869159
133287,"@Override public void remove(){
  super.removeElementFromNamedIndexes();
  if (!globals.getEdgeWrapper().elementExists(id)) {
    return;
  }
  Set<String> indexedKeys=globals.getIndexedKeysListWrapper().getIndexedKeys(Edge.class);
  Map<String,Object> props=globals.getEdgeWrapper().readProperties(this,indexedKeys.toArray(ArrayUtils.EMPTY_STRING_ARRAY));
  for (  String key : props.keySet()) {
    globals.getEdgeKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  globals.getVertexWrapper().deleteEdgeEndpoints(this);
  globals.getEdgeWrapper().deleteEdge(this);
  globals.getCaches().remove(id,Edge.class);
  globals.checkedFlush();
}","@Override public void remove(){
  super.removeElementFromNamedIndexes();
  if (!globals.getEdgeWrapper().elementExists(id)) {
    return;
  }
  Map<String,Object> props=globals.getEdgeWrapper().readAllProperties(this);
  for (  String key : props.keySet()) {
    globals.getEdgeKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  globals.getVertexWrapper().deleteEdgeEndpoints(this);
  globals.getEdgeWrapper().deleteEdge(this);
  globals.getCaches().remove(id,Edge.class);
  globals.checkedFlush();
}",0.8733108108108109
133288,"@Override public Edge getEdge(Object id){
  if (id == null) {
    throw ExceptionFactory.edgeIdCanNotBeNull();
  }
  String myID=id.toString();
  Edge edge=globals.getCaches().retrieve(myID,Edge.class);
  if (edge != null) {
    return edge;
  }
  edge=new AccumuloEdge(globals,myID);
  if (!globals.getConfig().getSkipExistenceChecks()) {
    String[] preload=globals.getConfig().getPreloadedProperties();
    if (preload == null) {
      preload=new String[]{};
    }
    Map<String,Object> props=globals.getEdgeWrapper().readProperties(edge,preload);
    if (props == null) {
      return null;
    }
    for (    String key : props.keySet()) {
      ((AccumuloElement)edge).setPropertyInMemory(key,props.get(key));
    }
  }
  globals.getCaches().cache(edge,Edge.class);
  return edge;
}","@Override public Edge getEdge(Object id){
  if (id == null) {
    throw ExceptionFactory.edgeIdCanNotBeNull();
  }
  String idStr=id.toString();
  Edge edge=globals.getCaches().retrieve(idStr,Edge.class);
  if (edge != null) {
    return edge;
  }
  edge=new AccumuloEdge(globals,idStr);
  if (!globals.getConfig().getSkipExistenceChecks()) {
    String[] preload=globals.getConfig().getPreloadedProperties();
    if (preload == null) {
      preload=new String[]{};
    }
    Map<String,Object> props=globals.getEdgeWrapper().readProperties(edge,preload);
    if (props == null) {
      return null;
    }
    for (    String key : props.keySet()) {
      ((AccumuloElement)edge).setPropertyInMemory(key,props.get(key));
    }
  }
  globals.getCaches().cache(edge,Edge.class);
  return edge;
}",0.8012618296529969
133289,"/** 
 * @deprecated Move this somewhere appropriate
 * @return
 */
@Deprecated public BatchWriter getWriter(String tablename){
  try {
    return globals.getMtbw().getBatchWriter(tablename);
  }
 catch (  Exception e) {
    throw new AccumuloGraphException(e);
  }
}","/** 
 * @deprecated Move this somewhere appropriate
 * @return
 */
@Deprecated private BatchWriter getWriter(String tablename){
  try {
    return globals.getMtbw().getBatchWriter(tablename);
  }
 catch (  Exception e) {
    throw new AccumuloGraphException(e);
  }
}",0.9793621013133208
133290,"/** 
 * @deprecated Move this somewhere appropriate
 * @param tablename
 * @return
 */
@Deprecated protected Scanner getScanner(String tablename){
  try {
    return globals.getConfig().getConnector().createScanner(tablename,globals.getConfig().getAuthorizations());
  }
 catch (  Exception e) {
    throw new AccumuloGraphException(e);
  }
}","/** 
 * @deprecated Move this somewhere appropriate
 * @param tablename
 * @return
 */
@Deprecated private Scanner getScanner(String tablename){
  try {
    return globals.getConfig().getConnector().createScanner(tablename,globals.getConfig().getAuthorizations());
  }
 catch (  Exception e) {
    throw new AccumuloGraphException(e);
  }
}",0.9824046920821116
133291,"@Override public Vertex addVertex(Object id){
  if (id == null) {
    id=AccumuloGraphUtils.generateId();
  }
  String myID=id.toString();
  Vertex vert=null;
  if (!globals.getConfig().getSkipExistenceChecks()) {
    vert=getVertex(myID);
    if (vert != null) {
      throw ExceptionFactory.vertexWithIdAlreadyExists(myID);
    }
  }
  vert=new AccumuloVertex(globals,myID);
  globals.getVertexWrapper().writeVertex(vert);
  globals.checkedFlush();
  globals.getCaches().cache(vert,Vertex.class);
  return vert;
}","@Override public Vertex addVertex(Object id){
  if (id == null) {
    id=AccumuloGraphUtils.generateId();
  }
  String idStr=id.toString();
  Vertex vert=null;
  if (!globals.getConfig().getSkipExistenceChecks()) {
    vert=getVertex(idStr);
    if (vert != null) {
      throw ExceptionFactory.vertexWithIdAlreadyExists(idStr);
    }
  }
  vert=new AccumuloVertex(globals,idStr);
  globals.getVertexWrapper().writeVertex(vert);
  globals.checkedFlush();
  globals.getCaches().cache(vert,Vertex.class);
  return vert;
}",0.9110251450676984
133292,"@Override public void remove(){
  globals.getCaches().remove(getId(),Vertex.class);
  super.removeElementFromNamedIndexes();
  if (!globals.getVertexWrapper().elementExists(id)) {
    throw ExceptionFactory.vertexWithIdDoesNotExist(getId());
  }
  Set<String> indexedKeys=globals.getIndexedKeysListWrapper().getIndexedKeys(Vertex.class);
  Map<String,Object> props=globals.getVertexWrapper().readProperties(this,indexedKeys.toArray(ArrayUtils.EMPTY_STRING_ARRAY));
  for (  String key : props.keySet()) {
    globals.getVertexKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  for (  Edge edge : getEdges(Direction.BOTH)) {
    edge.remove();
  }
  globals.checkedFlush();
  globals.getVertexWrapper().deleteVertex(this);
  globals.checkedFlush();
}","@Override public void remove(){
  globals.getCaches().remove(getId(),Vertex.class);
  super.removeElementFromNamedIndexes();
  if (!globals.getVertexWrapper().elementExists(id)) {
    throw ExceptionFactory.vertexWithIdDoesNotExist(getId());
  }
  Map<String,Object> props=globals.getVertexWrapper().readAllProperties(this);
  for (  String key : props.keySet()) {
    globals.getVertexKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  for (  Edge edge : getEdges(Direction.BOTH)) {
    edge.remove();
  }
  globals.checkedFlush();
  globals.getVertexWrapper().deleteVertex(this);
  globals.checkedFlush();
}",0.8917378917378918
133293,"/** 
 * Test whether the given Accumulo key represents a metadata key (e.g. existence, edge endpoint, etc), rather than a property.
 * @param key
 * @return
 */
private static boolean isMetaKey(Key key){
  String cf=key.getColumnFamily().toString();
  String cq=key.getColumnQualifier().toString();
  return (Constants.LABEL.equals(cf) && Constants.EXISTS.equals(cq)) || Constants.IN_EDGE.equals(cf) || Constants.OUT_EDGE.equals(cf);
}","/** 
 * Test whether the given Accumulo key represents a metadata key (e.g. existence, edge endpoint, etc), rather than a property.
 * @param key
 * @return
 */
private static boolean isMetaKey(Key key){
  String cf=key.getColumnFamily().toString();
  return Constants.LABEL.equals(cf) || Constants.IN_EDGE.equals(cf) || Constants.OUT_EDGE.equals(cf);
}",0.8781725888324873
133294,"/** 
 * Read the given properties for the given element id. This may return an empty map for elements with no properties. If the element does not exist, return null.
 * @param id
 * @param propertyKeys
 * @return
 */
public Map<String,Object> readProperties(Element element,String... propertyKeys){
  Scanner s=getScanner();
  s.setRange(new Range(element.getId().toString()));
  s.fetchColumnFamily(new Text(Constants.LABEL));
  for (  String key : propertyKeys) {
    s.fetchColumnFamily(new Text(key));
  }
  Map<String,Object> props=new PropertyParser().parse(s);
  s.close();
  return props;
}","/** 
 * Read the given properties for the given element. If propertyKeys is null, read all properties. If the element has no properties, return an empty Map. If the element does not exist, return null.
 * @param id
 * @param propertyKeys
 * @return
 */
public Map<String,Object> readProperties(Element element,String[] propertyKeys){
  Scanner s=getScanner();
  s.setRange(Range.exact((String)element.getId()));
  if (propertyKeys != null) {
    s.fetchColumnFamily(new Text(Constants.LABEL));
    for (    String key : propertyKeys) {
      s.fetchColumnFamily(new Text(key));
    }
  }
  Map<String,Object> props=new PropertyParser().parse(s);
  s.close();
  return props;
}",0.8037676609105181
133295,"public Iterable<Edge> getEdges(Vertex vertex,Direction direction,String... labels){
  Scanner scan=getScanner();
  scan.setRange(new Range(vertex.getId().toString()));
  if (direction.equals(Direction.IN)) {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
  }
 else   if (direction.equals(Direction.OUT)) {
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
 else {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
  if (labels.length > 0) {
    applyEdgeLabelValueFilter(scan,labels);
  }
  return new ScannerIterable<Edge>(scan){
    @Override public Edge next(    PeekingIterator<Entry<Key,Value>> iterator){
      Entry<Key,Value> kv=iterator.next();
      String[] parts=kv.getKey().getColumnQualifier().toString().split(Constants.ID_DELIM);
      String label=(new String(kv.getValue().get())).split(""String_Node_Str"")[1];
      AccumuloEdge edge;
      if (kv.getKey().getColumnFamily().toString().equalsIgnoreCase(Constants.IN_EDGE)) {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,kv.getKey().getRow().toString()),new AccumuloVertex(globals,parts[0]),label);
      }
 else {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,parts[0]),new AccumuloVertex(globals,kv.getKey().getRow().toString()),label);
      }
      globals.getCaches().cache(edge,Edge.class);
      return edge;
    }
  }
;
}","public Iterable<Edge> getEdges(Vertex vertex,Direction direction,String... labels){
  Scanner scan=getScanner();
  scan.setRange(new Range(vertex.getId().toString()));
  if (direction.equals(Direction.IN)) {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
  }
 else   if (direction.equals(Direction.OUT)) {
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
 else {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
  if (labels.length > 0) {
    applyEdgeLabelValueFilter(scan,labels);
  }
  return new ScannerIterable<Edge>(scan){
    @Override public Edge next(    PeekingIterator<Entry<Key,Value>> iterator){
      Entry<Key,Value> kv=iterator.next();
      String[] parts=kv.getKey().getColumnQualifier().toString().split(Constants.ID_DELIM);
      String label=(new String(kv.getValue().get())).split(Constants.ID_DELIM)[1];
      AccumuloEdge edge;
      if (kv.getKey().getColumnFamily().toString().equalsIgnoreCase(Constants.IN_EDGE)) {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,kv.getKey().getRow().toString()),new AccumuloVertex(globals,parts[0]),label);
      }
 else {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,parts[0]),new AccumuloVertex(globals,kv.getKey().getRow().toString()),label);
      }
      globals.getCaches().cache(edge,Edge.class);
      return edge;
    }
  }
;
}",0.988577362409138
133296,"@Override public void remove(){
  super.removeElementFromNamedIndexes();
  Map<String,Object> props=globals.getEdgeWrapper().readProperties(this);
  for (  String key : props.keySet()) {
    globals.getEdgeKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  globals.getVertexWrapper().deleteEdgeEndpoints(this);
  globals.getEdgeWrapper().deleteEdge(this);
  globals.getCaches().remove(id,Edge.class);
  globals.checkedFlush();
}","@Override public void remove(){
  super.removeElementFromNamedIndexes();
  if (!globals.getEdgeWrapper().elementExists(id)) {
    return;
  }
  Set<String> indexedKeys=globals.getIndexedKeysListWrapper().getIndexedKeys(Edge.class);
  Map<String,Object> props=globals.getEdgeWrapper().readProperties(this,indexedKeys.toArray(ArrayUtils.EMPTY_STRING_ARRAY));
  for (  String key : props.keySet()) {
    globals.getEdgeKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  globals.getVertexWrapper().deleteEdgeEndpoints(this);
  globals.getEdgeWrapper().deleteEdge(this);
  globals.getCaches().remove(id,Edge.class);
  globals.checkedFlush();
}",0.8057553956834532
133297,"@Override public void removeVertex(Vertex vertex){
  globals.getCaches().remove(vertex.getId(),Vertex.class);
  if (!globals.getConfig().getIndexableGraphDisabled()) {
    removeElementFromNamedIndexes(vertex);
  }
  Scanner scan=getElementScanner(Vertex.class);
  scan.setRange(new Range(vertex.getId().toString()));
  BatchDeleter edgedeleter=null;
  BatchDeleter vertexdeleter=null;
  BatchWriter indexdeleter=getVertexIndexWriter();
  try {
    edgedeleter=globals.getConfig().getConnector().createBatchDeleter(globals.getConfig().getEdgeTableName(),globals.getConfig().getAuthorizations(),globals.getConfig().getQueryThreads(),globals.getConfig().getBatchWriterConfig());
    vertexdeleter=globals.getConfig().getConnector().createBatchDeleter(globals.getConfig().getVertexTableName(),globals.getConfig().getAuthorizations(),globals.getConfig().getQueryThreads(),globals.getConfig().getBatchWriterConfig());
  }
 catch (  Exception e) {
    throw new AccumuloGraphException(e);
  }
  Iterator<Entry<Key,Value>> iter=scan.iterator();
  List<Range> ranges=new ArrayList<Range>();
  if (!iter.hasNext()) {
    throw ExceptionFactory.vertexWithIdDoesNotExist(vertex.getId());
  }
  try {
    while (iter.hasNext()) {
      Entry<Key,Value> e=iter.next();
      Key k=e.getKey();
      if (k.getColumnFamily().toString().equals(Constants.OUT_EDGE) || k.getColumnFamily().toString().equals(Constants.IN_EDGE)) {
        ranges.add(new Range(k.getColumnQualifier().toString().split(Constants.ID_DELIM)[1]));
        Mutation vm=new Mutation(k.getColumnQualifier().toString().split(Constants.ID_DELIM)[0]);
        vm.putDelete(invert(k.getColumnFamily()),new Text(vertex.getId().toString() + Constants.ID_DELIM + k.getColumnQualifier().toString().split(Constants.ID_DELIM)[1]));
        vertexBW.addMutation(vm);
      }
 else {
        Mutation m=new Mutation(e.getValue().get());
        m.putDelete(k.getColumnFamily(),k.getRow());
        indexdeleter.addMutation(m);
      }
    }
    globals.checkedFlush();
    scan.close();
    if (!ranges.isEmpty()) {
      edgedeleter.setRanges(ranges);
      edgedeleter.delete();
      ranges.clear();
    }
    ranges.add(new Range(vertex.getId().toString()));
    vertexdeleter.setRanges(ranges);
    vertexdeleter.delete();
  }
 catch (  Exception e) {
    throw new AccumuloGraphException(e);
  }
 finally {
    if (edgedeleter != null)     edgedeleter.close();
    if (vertexdeleter != null)     vertexdeleter.close();
  }
}","@Override public void removeVertex(Vertex vertex){
  vertex.remove();
}",0.0534591194968553
133298,"/** 
 * @deprecated Move to appropriate location.
 * @param element
 */
private void removeElementFromNamedIndexes(Element element){
  for (  Index<? extends Element> index : getIndices()) {
    ((AccumuloIndex<? extends Element>)index).getWrapper().removeElementFromIndex(element);
  }
}","/** 
 * @deprecated Move to appropriate location.
 * @param element
 */
@Deprecated private void removeElementFromNamedIndexes(Element element){
  for (  Index<? extends Element> index : getIndices()) {
    ((AccumuloIndex<? extends Element>)index).getWrapper().removeElementFromIndex(element);
  }
}",0.979591836734694
133299,"/** 
 * @deprecated This will go away along with {@link #vertexBW}.
 * @throws Exception
 */
private void setupWriters() throws Exception {
  vertexBW=globals.getMtbw().getBatchWriter(globals.getConfig().getVertexTableName());
}","/** 
 * @deprecated This will go away along with {@link #vertexBW}.
 * @throws Exception
 */
@Deprecated private void setupWriters() throws Exception {
  vertexBW=globals.getMtbw().getBatchWriter(globals.getConfig().getVertexTableName());
}",0.9743589743589745
133300,"@Override public void remove(){
  globals.getCaches().remove(getId(),Vertex.class);
  super.removeElementFromNamedIndexes();
  for (  Edge edge : getEdges(Direction.BOTH)) {
    edge.remove();
  }
  globals.checkedFlush();
  globals.getVertexWrapper().deleteVertex(this);
  globals.checkedFlush();
}","@Override public void remove(){
  globals.getCaches().remove(getId(),Vertex.class);
  super.removeElementFromNamedIndexes();
  if (!globals.getVertexWrapper().elementExists(id)) {
    throw ExceptionFactory.vertexWithIdDoesNotExist(getId());
  }
  Set<String> indexedKeys=globals.getIndexedKeysListWrapper().getIndexedKeys(Vertex.class);
  Map<String,Object> props=globals.getVertexWrapper().readProperties(this,indexedKeys.toArray(ArrayUtils.EMPTY_STRING_ARRAY));
  for (  String key : props.keySet()) {
    globals.getVertexKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  for (  Edge edge : getEdges(Direction.BOTH)) {
    edge.remove();
  }
  globals.checkedFlush();
  globals.getVertexWrapper().deleteVertex(this);
  globals.checkedFlush();
}",0.5583566760037348
133301,"@Override public Map<String,Object> parse(Iterable<Entry<Key,Value>> entries){
  Map<String,Object> props=null;
  for (  Entry<Key,Value> entry : entries) {
    if (props == null) {
      props=new HashMap<String,Object>();
    }
    Key key=entry.getKey();
    if (!isExistenceKey(key)) {
      String attr=key.getColumnFamily().toString();
      Object value=AccumuloByteSerializer.deserialize(entry.getValue().get());
      props.put(attr,value);
    }
  }
  return props;
}","@Override public Map<String,Object> parse(Iterable<Entry<Key,Value>> entries){
  Map<String,Object> props=null;
  for (  Entry<Key,Value> entry : entries) {
    if (props == null) {
      props=new HashMap<String,Object>();
    }
    Key key=entry.getKey();
    if (!isMetaKey(key)) {
      String attr=key.getColumnFamily().toString();
      Object value=AccumuloByteSerializer.deserialize(entry.getValue().get());
      props.put(attr,value);
    }
  }
  return props;
}",0.9863013698630136
133302,"@Override public void remove(){
  super.removeElementFromNamedIndexes();
  if (!globals.getEdgeWrapper().elementExists(id)) {
    return;
  }
  Map<String,Object> props=globals.getEdgeWrapper().readAllProperties(this);
  for (  String key : props.keySet()) {
    globals.getEdgeKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  globals.getVertexWrapper().deleteEdgeEndpoints(this);
  globals.getEdgeWrapper().deleteEdge(this);
  globals.getCaches().remove(id,Edge.class);
  globals.checkedFlush();
}","@Override public void remove(){
  super.removeElementFromNamedIndexes();
  if (!globals.getEdgeWrapper().elementExists(id)) {
    return;
  }
  Map<String,Object> props=globals.getEdgeWrapper().readAllProperties(this);
  for (  Entry<String,Object> ents : props.entrySet()) {
    globals.getEdgeKeyIndexWrapper().removePropertyFromIndex(this,ents.getKey(),ents.getValue());
  }
  globals.getVertexWrapper().deleteEdgeEndpoints(this);
  globals.getEdgeWrapper().deleteEdge(this);
  globals.getCaches().remove(id,Edge.class);
  globals.checkedFlush();
}",0.936685288640596
133303,"@Override public Vertex getVertex(Object id){
  if (id == null) {
    throw ExceptionFactory.vertexIdCanNotBeNull();
  }
  String myID=id.toString();
  Vertex vertex=globals.getCaches().retrieve(myID,Vertex.class);
  if (vertex != null) {
    return vertex;
  }
  vertex=new AccumuloVertex(globals,myID);
  if (!globals.getConfig().getSkipExistenceChecks()) {
    String[] preload=globals.getConfig().getPreloadedProperties();
    if (preload == null) {
      preload=new String[]{};
    }
    Map<String,Object> props=globals.getVertexWrapper().readProperties(vertex,preload);
    if (props == null) {
      return null;
    }
    for (    String key : props.keySet()) {
      ((AccumuloElement)vertex).setPropertyInMemory(key,props.get(key));
    }
  }
  globals.getCaches().cache(vertex,Vertex.class);
  return vertex;
}","@Override public Vertex getVertex(Object id){
  if (id == null) {
    throw ExceptionFactory.vertexIdCanNotBeNull();
  }
  String myID=id.toString();
  Vertex vertex=globals.getCaches().retrieve(myID,Vertex.class);
  if (vertex != null) {
    return vertex;
  }
  vertex=new AccumuloVertex(globals,myID);
  if (!globals.getConfig().getSkipExistenceChecks()) {
    String[] preload=globals.getConfig().getPreloadedProperties();
    if (preload == null) {
      preload=new String[]{};
    }
    Map<String,Object> props=globals.getVertexWrapper().readProperties(vertex,preload);
    if (props == null) {
      return null;
    }
    for (    Entry<String,Object> ents : props.entrySet()) {
      ((AccumuloElement)vertex).setPropertyInMemory(ents.getKey(),ents.getValue());
    }
  }
  globals.getCaches().cache(vertex,Vertex.class);
  return vertex;
}",0.959378733572282
133304,"@Override public Edge getEdge(Object id){
  if (id == null) {
    throw ExceptionFactory.edgeIdCanNotBeNull();
  }
  String idStr=id.toString();
  Edge edge=globals.getCaches().retrieve(idStr,Edge.class);
  if (edge != null) {
    return edge;
  }
  edge=new AccumuloEdge(globals,idStr);
  if (!globals.getConfig().getSkipExistenceChecks()) {
    String[] preload=globals.getConfig().getPreloadedProperties();
    if (preload == null) {
      preload=new String[]{};
    }
    Map<String,Object> props=globals.getEdgeWrapper().readProperties(edge,preload);
    if (props == null) {
      return null;
    }
    for (    String key : props.keySet()) {
      ((AccumuloElement)edge).setPropertyInMemory(key,props.get(key));
    }
  }
  globals.getCaches().cache(edge,Edge.class);
  return edge;
}","@Override public Edge getEdge(Object id){
  if (id == null) {
    throw ExceptionFactory.edgeIdCanNotBeNull();
  }
  String idStr=id.toString();
  Edge edge=globals.getCaches().retrieve(idStr,Edge.class);
  if (edge != null) {
    return edge;
  }
  edge=new AccumuloEdge(globals,idStr);
  if (!globals.getConfig().getSkipExistenceChecks()) {
    String[] preload=globals.getConfig().getPreloadedProperties();
    if (preload == null) {
      preload=new String[]{};
    }
    Map<String,Object> props=globals.getEdgeWrapper().readProperties(edge,preload);
    if (props == null) {
      return null;
    }
    for (    Entry<String,Object> ents : props.entrySet()) {
      ((AccumuloElement)edge).setPropertyInMemory(ents.getKey(),ents.getValue());
    }
  }
  globals.getCaches().cache(edge,Edge.class);
  return edge;
}",0.9517326732673268
133305,"@Override public void remove(){
  globals.getCaches().remove(getId(),Vertex.class);
  super.removeElementFromNamedIndexes();
  if (!globals.getVertexWrapper().elementExists(id)) {
    throw ExceptionFactory.vertexWithIdDoesNotExist(getId());
  }
  Map<String,Object> props=globals.getVertexWrapper().readAllProperties(this);
  for (  String key : props.keySet()) {
    globals.getVertexKeyIndexWrapper().removePropertyFromIndex(this,key,props.get(key));
  }
  for (  Edge edge : getEdges(Direction.BOTH)) {
    edge.remove();
  }
  globals.checkedFlush();
  globals.getVertexWrapper().deleteVertex(this);
  globals.checkedFlush();
}","@Override public void remove(){
  globals.getCaches().remove(getId(),Vertex.class);
  super.removeElementFromNamedIndexes();
  if (!globals.getVertexWrapper().elementExists(id)) {
    throw ExceptionFactory.vertexWithIdDoesNotExist(getId());
  }
  Map<String,Object> props=globals.getVertexWrapper().readAllProperties(this);
  for (  Entry<String,Object> ent : props.entrySet()) {
    globals.getVertexKeyIndexWrapper().removePropertyFromIndex(this,ent.getKey(),ent.getValue());
  }
  CloseableIterable<Edge> iter=(CloseableIterable<Edge>)getEdges(Direction.BOTH);
  for (  Edge edge : iter) {
    edge.remove();
  }
  iter.close();
  globals.checkedFlush();
  globals.getVertexWrapper().deleteVertex(this);
  globals.checkedFlush();
}",0.8675932699341624
133306,"public void put(String key,Object value){
  Integer timeout=getTimeout(key);
  if (timeout == null) {
    return;
  }
  values.put(key,new TimedValue(value,timeout != null ? System.currentTimeMillis() + timeout : null));
}","public void put(String key,Object value){
  Integer timeout=getTimeout(key);
  if (timeout == null) {
    return;
  }
  values.put(key,new TimedValue(value,System.currentTimeMillis() + timeout));
}",0.9403341288782816
133307,"public void putAll(Map<String,Object> entries){
  for (  String key : entries.keySet()) {
    put(key,entries.get(key));
  }
}","public void putAll(Map<String,Object> entries){
  if (entries == null)   return;
  for (  Entry<String,Object> ent : entries.entrySet()) {
    put(ent.getKey(),ent.getValue());
  }
}",0.7467532467532467
133308,"/** 
 * Parse out the property entries and set them for the given element.
 * @param element
 * @param entries
 */
protected void setInMemoryProperties(T element,Iterable<Entry<Key,Value>> entries){
  Map<String,Object> props=new PropertyParser().parse(entries);
  for (  String key : props.keySet()) {
    element.setPropertyInMemory(key,props.get(key));
  }
}","/** 
 * Parse out the property entries and set them for the given element.
 * @param element
 * @param entries
 */
protected void setInMemoryProperties(T element,Iterable<Entry<Key,Value>> entries){
  Map<String,Object> props=new PropertyParser().parse(entries);
  if (props == null)   return;
  for (  Entry<String,Object> ent : props.entrySet()) {
    element.setPropertyInMemory(ent.getKey(),ent.getValue());
  }
}",0.8663239074550129
133309,"public Iterable<Edge> getEdges(Vertex vertex,Direction direction,String... labels){
  Scanner scan=getScanner();
  scan.setRange(new Range(vertex.getId().toString()));
  if (direction.equals(Direction.IN)) {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
  }
 else   if (direction.equals(Direction.OUT)) {
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
 else {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
  if (labels.length > 0) {
    applyEdgeLabelValueFilter(scan,labels);
  }
  return new ScannerIterable<Edge>(scan){
    @Override public Edge next(    PeekingIterator<Entry<Key,Value>> iterator){
      Entry<Key,Value> kv=iterator.next();
      String[] parts=kv.getKey().getColumnQualifier().toString().split(Constants.ID_DELIM);
      String label=(new String(kv.getValue().get())).split(Constants.ID_DELIM)[1];
      AccumuloEdge edge;
      if (kv.getKey().getColumnFamily().toString().equalsIgnoreCase(Constants.IN_EDGE)) {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,kv.getKey().getRow().toString()),new AccumuloVertex(globals,parts[0]),label);
      }
 else {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,parts[0]),new AccumuloVertex(globals,kv.getKey().getRow().toString()),label);
      }
      globals.getCaches().cache(edge,Edge.class);
      return edge;
    }
  }
;
}","public CloseableIterable<Edge> getEdges(Vertex vertex,Direction direction,String... labels){
  Scanner scan=getScanner();
  scan.setRange(new Range(vertex.getId().toString()));
  if (direction.equals(Direction.IN)) {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
  }
 else   if (direction.equals(Direction.OUT)) {
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
 else {
    scan.fetchColumnFamily(new Text(Constants.IN_EDGE));
    scan.fetchColumnFamily(new Text(Constants.OUT_EDGE));
  }
  if (labels.length > 0) {
    applyEdgeLabelValueFilter(scan,labels);
  }
  return new ScannerIterable<Edge>(scan){
    @Override public Edge next(    PeekingIterator<Entry<Key,Value>> iterator){
      Entry<Key,Value> kv=iterator.next();
      String[] parts=kv.getKey().getColumnQualifier().toString().split(Constants.ID_DELIM);
      String label=(new String(kv.getValue().get())).split(Constants.ID_DELIM)[1];
      AccumuloEdge edge;
      if (kv.getKey().getColumnFamily().toString().equalsIgnoreCase(Constants.IN_EDGE)) {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,kv.getKey().getRow().toString()),new AccumuloVertex(globals,parts[0]),label);
      }
 else {
        edge=new AccumuloEdge(globals,parts[1],new AccumuloVertex(globals,parts[0]),new AccumuloVertex(globals,kv.getKey().getRow().toString()),label);
      }
      globals.getCaches().cache(edge,Edge.class);
      return edge;
    }
  }
;
}",0.996895481200414
133310,"/** 
 * Rebuild this index for the given table.
 * @param table
 * @param key
 */
public void rebuildIndex(String key,Class<? extends Element> elementClass){
  ElementTableWrapper wrapper=globals.getElementWrapper(elementClass);
  if (wrapper instanceof VertexTableWrapper) {
    for (    Vertex v : ((VertexTableWrapper)wrapper).getVertices()) {
      rebuild(wrapper,v,key);
    }
  }
 else   if (wrapper instanceof EdgeTableWrapper) {
    for (    Edge e : ((EdgeTableWrapper)wrapper).getEdges()) {
      rebuild(wrapper,e,key);
    }
  }
 else {
    throw new AccumuloGraphException(""String_Node_Str"" + wrapper.getClass());
  }
  globals.checkedFlush();
}","/** 
 * Rebuild this index for the given table.
 * @param table
 * @param key
 */
public void rebuildIndex(String key,Class<? extends Element> elementClass){
  ElementTableWrapper wrapper=globals.getElementWrapper(elementClass);
  if (wrapper instanceof VertexTableWrapper) {
    CloseableIterable<Vertex> iter=((VertexTableWrapper)wrapper).getVertices();
    for (    Vertex v : iter) {
      rebuild(wrapper,v,key);
    }
    iter.close();
  }
 else   if (wrapper instanceof EdgeTableWrapper) {
    CloseableIterable<Edge> iter=((EdgeTableWrapper)wrapper).getEdges();
    for (    Edge e : iter) {
      rebuild(wrapper,e,key);
    }
    iter.close();
  }
 else {
    throw new AccumuloGraphException(""String_Node_Str"" + wrapper.getClass());
  }
  globals.checkedFlush();
}",0.8465829846582985
133311,"@Test public void testVertexInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).setCreate(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addVertex(i + ""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
  }
}","@Test public void testVertexInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_NAME=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_NAME).setInstanceType(InstanceType.Mock).setCreate(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addVertex(i + ""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_NAME,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
    g.shutdown();
  }
}",0.9784172661870504
133312,"@Test public void testEdgeInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).setAutoFlush(true).setCreate(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addEdge(null,g.addVertex(i + ""String_Node_Str""),g.addVertex(i + ""String_Node_Str""),""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
  }
}","@Test public void testEdgeInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_NAME=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_NAME).setInstanceType(InstanceType.Mock).setAutoFlush(true).setCreate(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      Vertex v1=g.addVertex(i + ""String_Node_Str"");
      Vertex v2=g.addVertex(i + ""String_Node_Str"");
      g.addEdge(null,v1,v2,""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_NAME,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
    g.shutdown();
  }
}",0.8799540493968984
133313,"@Override public Vertex getVertex(Object id){
  if (id == null) {
    throw ExceptionFactory.vertexIdCanNotBeNull();
  }
  String myID;
  try {
    myID=(String)id;
  }
 catch (  ClassCastException e) {
    return null;
  }
  if (vertexCache != null) {
    Vertex vertex=vertexCache.retrieve(myID);
    if (vertex != null) {
      return vertex;
    }
  }
  Vertex vertex=new AccumuloVertex(this,myID);
  Scanner scan=null;
  try {
    if (!config.getSkipExistenceChecks()) {
      scan=getElementScanner(Vertex.class);
      scan.setRange(new Range(myID));
      scan.fetchColumn(TLABEL,TEXISTS);
      String[] preload=config.getPreloadedProperties();
      if (preload != null) {
        Text colf=new Text(""String_Node_Str"");
        for (        String key : preload) {
          if (StringFactory.LABEL.equals(key)) {
            colf.set(AccumuloGraph.LABEL);
          }
 else {
            colf.set(key);
          }
          scan.fetchColumnFamily(colf);
        }
      }
      Iterator<Entry<Key,Value>> iter=scan.iterator();
      if (!iter.hasNext()) {
        return null;
      }
      preloadProperties(iter,(AccumuloElement)vertex);
    }
  }
  finally {
    if (scan != null) {
      scan.close();
    }
  }
  if (vertexCache != null) {
    vertexCache.cache(vertex);
  }
  return vertex;
}","@Override public Vertex getVertex(Object id){
  if (id == null) {
    throw ExceptionFactory.vertexIdCanNotBeNull();
  }
  String myID=id.toString();
  if (vertexCache != null) {
    Vertex vertex=vertexCache.retrieve(myID);
    if (vertex != null) {
      return vertex;
    }
  }
  Vertex vertex=new AccumuloVertex(this,myID);
  Scanner scan=null;
  try {
    if (!config.getSkipExistenceChecks()) {
      scan=getElementScanner(Vertex.class);
      scan.setRange(new Range(myID));
      scan.fetchColumn(TLABEL,TEXISTS);
      String[] preload=config.getPreloadedProperties();
      if (preload != null) {
        Text colf=new Text(""String_Node_Str"");
        for (        String key : preload) {
          if (StringFactory.LABEL.equals(key)) {
            colf.set(AccumuloGraph.LABEL);
          }
 else {
            colf.set(key);
          }
          scan.fetchColumnFamily(colf);
        }
      }
      Iterator<Entry<Key,Value>> iter=scan.iterator();
      if (!iter.hasNext()) {
        return null;
      }
      preloadProperties(iter,(AccumuloElement)vertex);
    }
  }
  finally {
    if (scan != null) {
      scan.close();
    }
  }
  if (vertexCache != null) {
    vertexCache.cache(vertex);
  }
  return vertex;
}",0.9638648860958366
133314,"@Override public Edge getEdge(Object id){
  String myID;
  if (id == null) {
    throw ExceptionFactory.edgeIdCanNotBeNull();
  }
 else {
    try {
      myID=(String)id;
    }
 catch (    ClassCastException e) {
      return null;
    }
  }
  Edge edge=null;
  if (edgeCache != null) {
    edge=edgeCache.retrieve(myID);
    if (edge != null) {
      return edge;
    }
  }
  Scanner s;
  if (!config.getSkipExistenceChecks()) {
    s=getElementScanner(Edge.class);
    s.setRange(new Range(myID,myID));
    s.fetchColumnFamily(TLABEL);
    if (config.getPreloadedProperties() != null) {
      for (      String x : config.getPreloadedProperties()) {
        s.fetchColumnFamily(new Text(x));
      }
    }
    boolean found=s.iterator().hasNext();
    s.close();
    if (!found) {
      return null;
    }
  }
 else {
    return new AccumuloEdge(this,myID);
  }
  edge=new AccumuloEdge(this,myID);
  preloadProperties(s.iterator(),(AccumuloElement)edge);
  if (edgeCache != null) {
    edgeCache.cache(edge);
  }
  return edge;
}","@Override public Edge getEdge(Object id){
  if (id == null) {
    throw ExceptionFactory.edgeIdCanNotBeNull();
  }
  String myID=id.toString();
  Edge edge=null;
  if (edgeCache != null) {
    edge=edgeCache.retrieve(myID);
    if (edge != null) {
      return edge;
    }
  }
  Scanner s;
  if (!config.getSkipExistenceChecks()) {
    s=getElementScanner(Edge.class);
    s.setRange(new Range(myID,myID));
    s.fetchColumnFamily(TLABEL);
    if (config.getPreloadedProperties() != null) {
      for (      String x : config.getPreloadedProperties()) {
        s.fetchColumnFamily(new Text(x));
      }
    }
    boolean found=s.iterator().hasNext();
    s.close();
    if (!found) {
      return null;
    }
  }
 else {
    return new AccumuloEdge(this,myID);
  }
  edge=new AccumuloEdge(this,myID);
  preloadProperties(s.iterator(),(AccumuloElement)edge);
  if (edgeCache != null) {
    edgeCache.cache(edge);
  }
  return edge;
}",0.8665987780040734
133315,"@Test public void testVertexInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addVertex(i + ""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
  }
}","@Test public void testVertexInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addVertex(i + ""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
  }
}",0.951646811492642
133316,"@Test public void testEdgeInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).autoFlush(true).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addEdge(null,g.addVertex(i + ""String_Node_Str""),g.addVertex(i + ""String_Node_Str""),""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    System.out.println(e1);
    assertNull(e1);
    assertNull(e2);
  }
}","@Test public void testEdgeInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).autoFlush(true).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addEdge(null,g.addVertex(i + ""String_Node_Str""),g.addVertex(i + ""String_Node_Str""),""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    System.out.println(e1);
    assertNull(e1);
    assertNull(e2);
  }
}",0.9581564584596726
133317,"@Test public void testVertexInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addVertex(i + ""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
  }
}","@Test public void testVertexInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addVertex(i + ""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    assertNull(e1);
    assertNull(e2);
  }
}",0.951646811492642
133318,"@Test public void testEdgeInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setUser(""String_Node_Str"").setPassword(""String_Node_Str"".getBytes()).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).autoFlush(true).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addEdge(null,g.addVertex(i + ""String_Node_Str""),g.addVertex(i + ""String_Node_Str""),""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    System.out.println(e1);
    assertNull(e1);
    assertNull(e2);
  }
}","@Test public void testEdgeInputMap() throws Exception {
  final String INSTANCE_NAME=""String_Node_Str"";
  final String TEST_TABLE_1=""String_Node_Str"";
  if (!System.getProperty(""String_Node_Str"").startsWith(""String_Node_Str"")) {
    Graph g=GraphFactory.open(new AccumuloGraphConfiguration().setInstanceName(INSTANCE_NAME).setGraphName(TEST_TABLE_1).setInstanceType(InstanceType.Mock).autoFlush(true).create(true).getConfiguration());
    for (int i=0; i < 100; i++) {
      g.addEdge(null,g.addVertex(i + ""String_Node_Str""),g.addVertex(i + ""String_Node_Str""),""String_Node_Str"");
    }
    assertEquals(0,MRTester.main(new String[]{""String_Node_Str"",""String_Node_Str"",TEST_TABLE_1,INSTANCE_NAME,""String_Node_Str""}));
    System.out.println(e1);
    assertNull(e1);
    assertNull(e2);
  }
}",0.9581564584596726
133319,"/** 
 * Called to write all properties added to this builder out to Accumulo.
 * @throws MutationsRejectedException
 */
public void finish() throws MutationsRejectedException {
  writer.addMutation(mutation);
}","/** 
 * Called to write all properties added to this builder out to Accumulo.
 * @throws MutationsRejectedException
 */
public void finish() throws MutationsRejectedException {
  if (mutation.size() > 0) {
    writer.addMutation(mutation);
  }
}",0.8967032967032967
133320,"public SortedSet<Text> getSplits(){
  String val=getString(SPLITS);
  if ((val == null) || (val.trim().equals(""String_Node_Str""))) {
    return null;
  }
  SortedSet<Text> splits=new TreeSet<Text>();
  for (  String s : val.split(""String_Node_Str"")) {
    splits.add(new Text(s));
  }
  return splits;
}","public SortedSet<Text> getSplits(){
  String val=getString(SPLITS);
  if ((val == null) || (val.trim().equals(""String_Node_Str""))) {
    return null;
  }
  SortedSet<Text> splits=new TreeSet<Text>();
  for (  String s : val.trim().split(""String_Node_Str"")) {
    splits.add(new Text(s));
  }
  return splits;
}",0.9885807504078304
133321,"@Override public int compareTo(MapReduceVertex other){
  int val=this.id.compareTo(other.id);
  if (val != 0) {
    return val;
  }
  return getClass().getSimpleName().compareTo(other.getClass().getSimpleName());
}","@Override public int compareTo(MapReduceElement other){
  int val=this.id.compareTo(other.id);
  if (val != 0) {
    return val;
  }
  return getClass().getSimpleName().compareTo(other.getClass().getSimpleName());
}",0.9696969696969696
133322,"public void actionPerformed(AnActionEvent e){
  final Project project=e.getProject();
  if (project == null)   return;
  final Editor editor=FileEditorManager.getInstance(project).getSelectedTextEditor();
  if (editor == null)   return;
  String initialValue=""String_Node_Str"";
  final SelectionModel selectionModel=editor.getSelectionModel();
  if (selectionModel.hasSelection()) {
    String selectedText=selectionModel.getSelectedText();
    if (selectedText == null) {
      selectionModel.selectLineAtCaret();
      selectedText=selectionModel.getSelectedText();
      if (selectedText == null)       selectedText=""String_Node_Str"";
    }
    if (!selectedText.isEmpty()) {
      selectedText=selectedText.trim();
      if (selectedText.contains(""String_Node_Str""))       selectedText=selectedText.substring(0,selectedText.indexOf(""String_Node_Str""));
    }
    initialValue=selectedText;
  }
  final String text=Messages.showInputDialog(project,null,""String_Node_Str"",null,initialValue,null);
  final Runnable readRunner=new Runnable(){
    @Override public void run(){
      int offset=editor.getCaretModel().getOffset();
      final Document document=editor.getDocument();
      if (selectionModel.hasSelection()) {
        int selectionStart=selectionModel.getSelectionStart();
        int selectionEnd=selectionModel.getSelectionEnd();
        selectionModel.removeSelection();
        document.deleteString(selectionStart,selectionEnd);
        offset=selectionStart;
      }
      int lineNumber=document.getLineNumber(offset);
      int lineStartOffset=document.getLineStartOffset(lineNumber);
      int indentLength=offset - lineStartOffset;
      document.insertString(offset,Util.convertTextToAscii(text,indentLength));
    }
  }
;
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    @Override public void run(){
      CommandProcessor.getInstance().executeCommand(project,new Runnable(){
        @Override public void run(){
          ApplicationManager.getApplication().runWriteAction(readRunner);
        }
      }
,""String_Node_Str"",null);
    }
  }
);
}","public void actionPerformed(AnActionEvent e){
  final Project project=e.getProject();
  if (project == null)   return;
  final Editor editor=FileEditorManager.getInstance(project).getSelectedTextEditor();
  if (editor == null)   return;
  String initialValue=""String_Node_Str"";
  final SelectionModel selectionModel=editor.getSelectionModel();
  if (selectionModel.hasSelection()) {
    String selectedText=selectionModel.getSelectedText();
    if (selectedText == null) {
      selectionModel.selectLineAtCaret();
      selectedText=selectionModel.getSelectedText();
      if (selectedText == null)       selectedText=""String_Node_Str"";
    }
    if (!selectedText.isEmpty()) {
      selectedText=selectedText.trim();
      if (selectedText.contains(""String_Node_Str""))       selectedText=selectedText.substring(0,selectedText.indexOf(""String_Node_Str""));
    }
    initialValue=selectedText;
  }
  final String text=Messages.showInputDialog(project,null,""String_Node_Str"",null,initialValue,null);
  final Runnable readRunner=new Runnable(){
    @Override public void run(){
      if (text == null)       return;
      int offset=editor.getCaretModel().getOffset();
      final Document document=editor.getDocument();
      if (selectionModel.hasSelection()) {
        int selectionStart=selectionModel.getSelectionStart();
        int selectionEnd=selectionModel.getSelectionEnd();
        selectionModel.removeSelection();
        document.deleteString(selectionStart,selectionEnd);
        offset=selectionStart;
      }
      int lineNumber=document.getLineNumber(offset);
      int lineStartOffset=document.getLineStartOffset(lineNumber);
      int indentLength=offset - lineStartOffset;
      document.insertString(offset,Util.convertTextToAscii(text,indentLength));
    }
  }
;
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    @Override public void run(){
      CommandProcessor.getInstance().executeCommand(project,new Runnable(){
        @Override public void run(){
          ApplicationManager.getApplication().runWriteAction(readRunner);
        }
      }
,""String_Node_Str"",null);
    }
  }
);
}",0.9909995262908574
133323,"/** 
 * Render allure report page in project-reports.html.
 * @param sink  sink
 * @param title title
 */
private void render(Sink sink,String title){
  sink.head();
  sink.title();
  sink.text(title);
  sink.title_();
  sink.head_();
  sink.body();
  sink.lineBreak();
  sink.rawText(""String_Node_Str"");
  sink.link(""String_Node_Str"");
  sink.body_();
  sink.flush();
  sink.close();
}","/** 
 * Render allure report page in project-reports.html.
 * @param sink  sink
 * @param title title
 */
private void render(Sink sink,String title){
  sink.head();
  sink.title();
  sink.text(title);
  sink.title_();
  sink.head_();
  sink.body();
  sink.lineBreak();
  File indexHtmlFile=new File(outputDirectory,""String_Node_Str"");
  String relativePath=reportingDirectory.toURI().relativize(indexHtmlFile.toURI()).getPath();
  sink.rawText(String.format(""String_Node_Str"",relativePath));
  sink.link(relativePath);
  sink.body_();
  sink.flush();
  sink.close();
}",0.7413612565445026
133324,"@Override protected void executeReport(Locale locale) throws MavenReportException {
  getLog().info(""String_Node_Str"" + reportVersion);
  getLog().info(""String_Node_Str"" + resultsPattern);
  File[] reportDirectories=getPathsByGlobs(projectBaseDirectory,resultsPattern);
  getLog().info(String.format(""String_Node_Str"",reportDirectories.length,resultsPattern));
  if (reportDirectories.length == 0) {
    throw new MavenReportException(String.format(""String_Node_Str"",resultsPattern));
  }
  try {
    DependencyResolver resolver=new DependencyResolver(repoSystem,repoSession,projectRepos);
    AllureReportBuilder builder=new AllureReportBuilder(reportVersion,outputDirectory,resolver);
    getLog().info(""String_Node_Str"" + outputDirectory);
    builder.processResults(reportDirectories);
    getLog().info(""String_Node_Str"");
    builder.unpackFace();
    getLog().info(""String_Node_Str"");
    render(getSink(),getName(locale));
  }
 catch (  AllureReportBuilderException e) {
    getLog().error(""String_Node_Str"",e);
    throw new MavenReportException(""String_Node_Str"",e);
  }
}","@Override protected void executeReport(Locale locale) throws MavenReportException {
  getLog().info(""String_Node_Str"" + reportVersion);
  getLog().info(""String_Node_Str"" + resultsPattern);
  File[] reportDirectories=getReportDirectories(projectBaseDirectory,resultsPattern);
  getLog().info(String.format(""String_Node_Str"",reportDirectories.length,resultsPattern));
  if (reportDirectories.length == 0) {
    throw new MavenReportException(String.format(""String_Node_Str"",resultsPattern));
  }
  try {
    DependencyResolver resolver=new DependencyResolver(repoSystem,repoSession,projectRepos);
    AllureReportBuilder builder=new AllureReportBuilder(reportVersion,outputDirectory,resolver);
    getLog().info(""String_Node_Str"" + outputDirectory);
    builder.processResults(reportDirectories);
    getLog().info(""String_Node_Str"");
    builder.unpackFace();
    getLog().info(""String_Node_Str"");
    render(getSink(),getName(locale));
  }
 catch (  AllureReportBuilderException e) {
    getLog().error(""String_Node_Str"",e);
    throw new MavenReportException(""String_Node_Str"",e);
  }
}",0.9875518672199172
133325,"/** 
 * Loads the top section of the IPS framework INI file and returns the contents as a DataComponent of Entries. Each line is set as an Entry.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return A TableComponent of Entries representing the contents at the topof the INI file.
 */
private TableComponent loadGlobalConfiguration(Iterator<String> it){
  TableComponent globalConfiguration=new TableComponent();
  globalConfiguration.setName(""String_Node_Str"");
  globalConfiguration.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  globalConfiguration.setId(currID);
  currID++;
  String[] splitLine=null;
  ArrayList<IEntry> entries=new ArrayList<IEntry>();
  IEntry portNameTemplate=makeIPSEntry();
  IEntry implementationTemplate=makeIPSEntry();
  portNameTemplate.setName(""String_Node_Str"");
  implementationTemplate.setName(""String_Node_Str"");
  entries.add(portNameTemplate);
  entries.add(implementationTemplate);
  globalConfiguration.setRowTemplate(entries);
  line=it.next();
  while (!line.contains(""String_Node_Str"") && it.hasNext()) {
    if (line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
      }
      splitLine=line.split(""String_Node_Str"",2);
      ArrayList<IEntry> row=new ArrayList<IEntry>();
      int rowID=globalConfiguration.addRow();
      row=globalConfiguration.getRow(rowID);
      row.get(0).setValue(splitLine[0]);
      row.get(1).setValue(splitLine[1]);
    }
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  return globalConfiguration;
}","/** 
 * Loads the top section of the IPS framework INI file and returns the contents as a DataComponent of Entries. Each line is set as an Entry.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return A TableComponent of Entries representing the contents at the topof the INI file.
 */
private TableComponent loadGlobalConfiguration(Iterator<String> it){
  TableComponent globalConfiguration=new TableComponent();
  globalConfiguration.setName(""String_Node_Str"");
  globalConfiguration.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  globalConfiguration.setId(currID);
  currID++;
  String[] splitLine=null;
  ArrayList<IEntry> entries=new ArrayList<IEntry>();
  IEntry portNameTemplate=makeIPSEntry();
  IEntry implementationTemplate=makeIPSEntry();
  portNameTemplate.setName(""String_Node_Str"");
  implementationTemplate.setName(""String_Node_Str"");
  entries.add(portNameTemplate);
  entries.add(implementationTemplate);
  globalConfiguration.setRowTemplate(entries);
  line=it.next();
  while (!line.contains(""String_Node_Str"") && it.hasNext()) {
    if (line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
      }
      splitLine=line.split(""String_Node_Str"",2);
      if (splitLine.length < 2 || splitLine[0].trim().length() == 0) {
        continue;
      }
      ArrayList<IEntry> row=new ArrayList<IEntry>();
      int rowID=globalConfiguration.addRow();
      row=globalConfiguration.getRow(rowID);
      row.get(0).setValue(splitLine[0]);
      row.get(1).setValue(splitLine[1]);
    }
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  return globalConfiguration;
}",0.8783744557329463
133326,"/** 
 * <p> Constructs the MasterDetailsComponent that allows the user to add and delete Ports entries. Supplies some limitations on the types of ports that are allowed in the MasterDetailsComponent that aligns with the IPS framework. </p>
 * @param ipsComponents The DataComponents to be put into the MasterDetailsComponent
 * @return the resultant MasterDetailsComponent
 */
private MasterDetailsComponent buildMasterDetailsComponent(ArrayList<DataComponent> ipsComponents){
  MasterDetailsComponent masterDetails=new MasterDetailsComponent();
  masterDetails.setName(""String_Node_Str"");
  masterDetails.setDescription(""String_Node_Str"");
  String portName;
  int masterId;
  String[] allowedPortNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ArrayList<String> allowedPortList=new ArrayList<String>(Arrays.asList(allowedPortNames));
  ArrayList<DataComponent> portTemplates=new ArrayList<DataComponent>();
  Boolean portAdded;
  for (int i=0; i < ipsComponents.size(); i++) {
    DataComponent data=ipsComponents.get(i);
    portTemplates.add(data);
    allowedPortList.remove(data.getName());
  }
  if (allowedPortList.size() > 0 && portMap == null) {
    populatePortMap();
  }
  for (  String port : allowedPortList) {
    portTemplates.add(loadComponent(portMap.get(port).iterator()));
  }
  allowedPortList=new ArrayList<String>(Arrays.asList(allowedPortNames));
  masterDetails.setTemplates(allowedPortList,portTemplates);
  for (  DataComponent data : ipsComponents) {
    masterId=masterDetails.addMaster();
    portName=data.getName();
    masterDetails.setMasterInstanceValue(masterId,portName);
    masterDetails.getDetailsAtIndex(masterId - 1).copy(data);
  }
  return masterDetails;
}","/** 
 * <p> Constructs the MasterDetailsComponent that allows the user to add and delete Ports entries. Supplies some limitations on the types of ports that are allowed in the MasterDetailsComponent that aligns with the IPS framework. </p>
 * @param ipsComponents The DataComponents to be put into the MasterDetailsComponent
 * @return the resultant MasterDetailsComponent
 */
private MasterDetailsComponent buildMasterDetailsComponent(ArrayList<DataComponent> ipsComponents){
  MasterDetailsComponent masterDetails=new MasterDetailsComponent();
  masterDetails.setName(""String_Node_Str"");
  masterDetails.setDescription(""String_Node_Str"");
  String portName;
  int masterId;
  String[] allowedPortNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ArrayList<String> allowedPortList=new ArrayList<String>(Arrays.asList(allowedPortNames));
  ArrayList<DataComponent> portTemplates=new ArrayList<DataComponent>();
  Boolean portAdded;
  for (int i=0; i < ipsComponents.size(); i++) {
    DataComponent data=ipsComponents.get(i);
    portTemplates.add(data);
    allowedPortList.remove(data.getName());
  }
  if (allowedPortList.size() > 0 && portMap == null) {
    populatePortMap();
  }
  for (  String port : allowedPortList) {
    portTemplates.add(loadComponent(portMap.get(port).iterator()));
  }
  allowedPortList=new ArrayList<String>(Arrays.asList(allowedPortNames));
  masterDetails.setTemplates(allowedPortList,portTemplates);
  for (  DataComponent data : ipsComponents) {
    masterId=masterDetails.addMaster();
    portName=data.getName();
    masterDetails.setMasterInstanceValue(masterId,portName);
    masterDetails.getDetailsAtIndex(masterId - 1).copy(data);
  }
  return masterDetails;
}",0.98993851313583
133327,"/** 
 * Fills the portMap in with the correct default information for each port. This method is used when filling in the MasterDetailsComponent, in the event that a configuration file is lacking a definition of a port. Each of the default definition arrays must end with two separate blank or whitespace filled strings in order to satisfy the exit statement of the loadComponent() definition.
 */
private void populatePortMap(){
  String[] allowedPortNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ArrayList<String> portLines;
  portMap=new HashMap<String,ArrayList<String>>();
  String[] initStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(initStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] thermStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(thermStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] elecStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(elecStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] cetdStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(cetdStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] ntgStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(ntgStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] dfoilStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(dfoilStrings));
  portMap.put(""String_Node_Str"",portLines);
}","/** 
 * Fills the portMap in with the correct default information for each port. This method is used when filling in the MasterDetailsComponent, in the event that a configuration file is lacking a definition of a port. Each of the default definition arrays must end with two separate blank or whitespace filled strings in order to satisfy the exit statement of the loadComponent() definition.
 */
private void populatePortMap(){
  String[] allowedPortNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ArrayList<String> portLines;
  portMap=new HashMap<String,ArrayList<String>>();
  String[] initStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(initStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] thermStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(thermStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] elecStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(elecStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] cetdStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(cetdStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] ntgStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(ntgStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] dfoilStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(dfoilStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] ctdStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(ctdStrings));
  portMap.put(""String_Node_Str"",portLines);
  String[] ampereStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  portLines=new ArrayList<String>(Arrays.asList(ampereStrings));
  portMap.put(""String_Node_Str"",portLines);
}",0.8981282602025161
133328,"/** 
 * Read the INI file lines into entries of an ArrayList so that it is easy to parse the sections into ICE.
 * @param iniFile The INI file to be read in.
 * @return An ArrayList of strings of the lines of the INI file.
 * @throws FileNotFoundException Thrown when the INI file cannot be found.
 * @throws IOException Thrown when the INI file cannot be read or closed.
 */
private ArrayList<String> readFileLines(IFile ifile) throws FileNotFoundException, IOException {
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(ifile.getContents()));
  }
 catch (  CoreException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  StringBuffer buffer=new StringBuffer();
  int fileByte;
  while ((fileByte=reader.read()) != -1) {
    buffer.append((char)fileByte);
  }
  reader.close();
  String[] bufferSplit=(buffer.toString()).split(""String_Node_Str"");
  ArrayList<String> fileLines=new ArrayList<String>(Arrays.asList(bufferSplit));
  fileLines.add(""String_Node_Str"");
  return fileLines;
}","/** 
 * Read the INI file lines into entries of an ArrayList so that it is easy to parse the sections into ICE.
 * @param iniFile The INI file to be read in.
 * @return An ArrayList of strings of the lines of the INI file.
 * @throws FileNotFoundException Thrown when the INI file cannot be found.
 * @throws IOException Thrown when the INI file cannot be read or closed.
 */
private ArrayList<String> readFileLines(IFile ifile) throws FileNotFoundException, IOException {
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(ifile.getContents()));
  }
 catch (  CoreException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  StringBuffer buffer=new StringBuffer();
  int fileByte;
  ArrayList<String> fileLines=new ArrayList<String>();
  String line=reader.readLine();
  while (line != null) {
    fileLines.add(line);
    line=reader.readLine();
  }
  reader.close();
  fileLines.add(""String_Node_Str"");
  return fileLines;
}",0.8125613346418057
133329,"/** 
 * Loads the Ports table from the INI file and returns the information as a DataComponent of Entry. Each of the ports specified the table are set as an entry. The number of ports in the table specify the number of Components that need to be loaded by the loadComponent() method.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return A TableComponent of Entries representing the contents in theports table of the INI file.
 */
private TableComponent loadPortsData(Iterator<String> it){
  TableComponent portsTable=new TableComponent();
  portsTable.setName(""String_Node_Str"");
  portsTable.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  portsTable.setId(currID);
  currID++;
  ArrayList<IEntry> entries=new ArrayList<IEntry>();
  IEntry portNameTemplate=makeIPSEntry();
  IEntry implementationTemplate=makeIPSEntry();
  portNameTemplate.setName(""String_Node_Str"");
  implementationTemplate.setName(""String_Node_Str"");
  entries.add(portNameTemplate);
  entries.add(implementationTemplate);
  portsTable.setRowTemplate(entries);
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  line=it.next();
  while (it.hasNext() && !line.contains(""String_Node_Str"")) {
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  ArrayList<String> portNames=new ArrayList<String>(Arrays.asList(line.split(""String_Node_Str"")[1].split(""String_Node_Str"")));
  while (portNames.size() > 0 && it.hasNext()) {
    if (line.contains(""String_Node_Str"") && line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
      }
      int rowID=portsTable.addRow();
      ArrayList<IEntry> row=portsTable.getRow(rowID);
      String portName=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (portNames.contains(portName)) {
        row.get(0).setValue(portName);
        line=it.next();
        if (line.contains(""String_Node_Str"")) {
          line=line.split(""String_Node_Str"",2)[0];
        }
        if (line.contains(""String_Node_Str"")) {
          String implementation=line.split(""String_Node_Str"",2)[1];
          row.get(1).setValue(implementation);
        }
 else {
          System.err.println(""String_Node_Str"" + ""String_Node_Str"");
          System.exit(1);
        }
        portNames.remove(portName);
      }
    }
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  return portsTable;
}","/** 
 * Loads the Ports table from the INI file and returns the information as a DataComponent of Entry. Each of the ports specified the table are set as an entry. The number of ports in the table specify the number of Components that need to be loaded by the loadComponent() method.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return A TableComponent of Entries representing the contents in theports table of the INI file.
 */
private TableComponent loadPortsData(Iterator<String> it){
  TableComponent portsTable=new TableComponent();
  portsTable.setName(""String_Node_Str"");
  portsTable.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  portsTable.setId(currID);
  currID++;
  ArrayList<IEntry> entries=new ArrayList<IEntry>();
  IEntry portNameTemplate=makeIPSEntry();
  IEntry implementationTemplate=makeIPSEntry();
  portNameTemplate.setName(""String_Node_Str"");
  implementationTemplate.setName(""String_Node_Str"");
  entries.add(portNameTemplate);
  entries.add(implementationTemplate);
  portsTable.setRowTemplate(entries);
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  line=it.next();
  while (it.hasNext() && !line.contains(""String_Node_Str"")) {
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  ArrayList<String> portNames=new ArrayList<String>(Arrays.asList(line.split(""String_Node_Str"")[1].split(""String_Node_Str"")));
  while (portNames.size() > 0 && it.hasNext()) {
    if (line.contains(""String_Node_Str"") && line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
        if (line.trim().length() == 0) {
          continue;
        }
      }
      int rowID=portsTable.addRow();
      ArrayList<IEntry> row=portsTable.getRow(rowID);
      String portName=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (portNames.contains(portName)) {
        row.get(0).setValue(portName);
        line=it.next();
        if (line.contains(""String_Node_Str"")) {
          line=line.split(""String_Node_Str"",2)[0];
        }
        if (line.contains(""String_Node_Str"")) {
          String implementation=line.split(""String_Node_Str"",2)[1];
          row.get(1).setValue(implementation);
        }
 else {
          System.err.println(""String_Node_Str"" + ""String_Node_Str"");
          System.exit(1);
        }
        portNames.remove(portName);
      }
    }
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  return portsTable;
}",0.9868054265006504
133330,"/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  if (remoteManager != null) {
    List<IRemoteConnectionType> types=getService(IRemoteServicesManager.class).getRemoteConnectionTypes();
    IRemoteConnectionType connectionType=null;
    for (    IRemoteConnectionType type : types) {
      if (""String_Node_Str"".equals(type.getName())) {
        connectionType=type;
        break;
      }
    }
    if (connectionType != null) {
      try {
        for (        IRemoteConnection c : connectionType.getConnections()) {
          String connectionHost=c.getService(IRemoteConnectionHostService.class).getHostname();
          if (InetAddress.getByName(host).getHostAddress().equals(InetAddress.getByName(connectionHost).getHostAddress())) {
            connection=c;
            return connection;
          }
        }
      }
 catch (      UnknownHostException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
      if (connection == null) {
        final IRemoteConnectionType finalType=connectionType;
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            IRemoteUIConnectionService uiConnService=finalType.getService(IRemoteUIConnectionService.class);
            IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
            if (wizard != null) {
              wizard.setConnectionName(host);
              try {
                connection=wizard.open().save();
                if (connection != null) {
                  connection.open(null);
                }
              }
 catch (              RemoteConnectionException e) {
                logger.error(getClass().getName() + ""String_Node_Str"",e);
              }
            }
          }
        }
);
      }
    }
  }
  return connection;
}","/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  if (remoteManager != null) {
    List<IRemoteConnectionType> types=getService(IRemoteServicesManager.class).getRemoteConnectionTypes();
    IRemoteConnectionType connectionType=null;
    for (    IRemoteConnectionType type : types) {
      if (""String_Node_Str"".equals(type.getName())) {
        connectionType=type;
        break;
      }
    }
    if (connectionType != null) {
      for (      IRemoteConnection c : connectionType.getConnections()) {
        if (host.equals(c.getName())) {
          connection=c;
          return connection;
        }
      }
      if (connection == null) {
        final IRemoteConnectionType finalType=connectionType;
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            IRemoteUIConnectionService uiConnService=finalType.getService(IRemoteUIConnectionService.class);
            IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
            if (wizard != null) {
              wizard.setConnectionName(host);
              try {
                connection=wizard.open().save();
                if (connection != null) {
                  connection.open(null);
                }
              }
 catch (              RemoteConnectionException e) {
                logger.error(getClass().getName() + ""String_Node_Str"",e);
              }
            }
          }
        }
);
      }
    }
  }
  return connection;
}",0.8812260536398467
133331,"/** 
 * <p> The constructor. SerializedItemBuilders must be initialized with an InputStream. The stream can contain either a Painfully Simple Form file or an XML file that was created according to the JAXB-generated schemas for ICE Forms. If it is unable to load the InputStream or determines that the contents of the stream are not consistent with either the XML or the PSF formats, then it will throw an IOException. </p>
 * @param inputStream <p> The InputStream from which the SerializedItemBuilder should build the SerializedItem. </p>
 * @throws IOException
 */
public SerializedItemBuilder(InputStream inputStream) throws IOException {
  int numChars=0;
  ByteArrayInputStream itemReadStream=null;
  char[] buffer=null;
  Writer writer=null;
  Reader reader=null;
  ICEJAXBHandler xmlMarshaller=new ICEJAXBHandler();
  boolean tryAgain=false;
  ArrayList<Class> classList=new ArrayList<Class>();
  if (inputStream != null) {
    originalItem=new Item(null);
    writer=new StringWriter();
    buffer=new char[1024];
    try {
      reader=new BufferedReader(new InputStreamReader(inputStream,""String_Node_Str""));
      while ((numChars=reader.read(buffer)) != -1) {
        writer.write(buffer,0,numChars);
      }
    }
  finally {
      inputStream.close();
    }
    itemReadStream=new ByteArrayInputStream(writer.toString().getBytes());
    try {
      classList.add(JobLauncher.class);
      originalItem=(Item)xmlMarshaller.read(classList,itemReadStream);
    }
 catch (    NullPointerException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      tryAgain=true;
    }
catch (    JAXBException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      tryAgain=true;
    }
    if (tryAgain) {
      itemReadStream.reset();
      tryAgain=false;
      try {
        classList.add(Item.class);
        originalItem=(Item)xmlMarshaller.read(classList,itemReadStream);
      }
 catch (      NullPointerException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        tryAgain=true;
      }
catch (      JAXBException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        tryAgain=true;
      }
    }
    if (tryAgain) {
      itemReadStream.reset();
      try {
        originalItem.loadFromPSF(itemReadStream);
      }
 catch (      IOException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    itemReadStream.close();
    name=originalItem.getName();
    type=originalItem.getItemType();
  }
 else {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return;
}","/** 
 * <p> The constructor. SerializedItemBuilders must be initialized with an InputStream. The stream can contain either a Painfully Simple Form file or an XML file that was created according to the JAXB-generated schemas for ICE Forms. If it is unable to load the InputStream or determines that the contents of the stream are not consistent with either the XML or the PSF formats, then it will throw an IOException. </p>
 * @param inputStream <p> The InputStream from which the SerializedItemBuilder should build the SerializedItem. </p>
 * @throws IOException
 */
public SerializedItemBuilder(InputStream inputStream) throws IOException {
  int numChars=0;
  ByteArrayInputStream itemReadStream=null;
  char[] buffer=null;
  Writer writer=null;
  Reader reader=null;
  ICEJAXBHandler xmlMarshaller=new ICEJAXBHandler();
  boolean tryAgain=false;
  ArrayList<Class> classList=(ArrayList<Class>)new ICEJAXBClassProvider().getClasses();
  if (inputStream != null) {
    originalItem=new Item(null);
    writer=new StringWriter();
    buffer=new char[1024];
    try {
      reader=new BufferedReader(new InputStreamReader(inputStream,""String_Node_Str""));
      while ((numChars=reader.read(buffer)) != -1) {
        writer.write(buffer,0,numChars);
      }
    }
  finally {
      inputStream.close();
    }
    itemReadStream=new ByteArrayInputStream(writer.toString().getBytes());
    try {
      classList.add(JobLauncher.class);
      originalItem=(Item)xmlMarshaller.read(classList,itemReadStream);
    }
 catch (    NullPointerException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      tryAgain=true;
    }
catch (    JAXBException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      tryAgain=true;
    }
    if (tryAgain) {
      itemReadStream.reset();
      tryAgain=false;
      try {
        classList.add(Item.class);
        originalItem=(Item)xmlMarshaller.read(classList,itemReadStream);
      }
 catch (      NullPointerException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        tryAgain=true;
      }
catch (      JAXBException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        tryAgain=true;
      }
    }
    if (tryAgain) {
      itemReadStream.reset();
      try {
        originalItem.loadFromPSF(itemReadStream);
      }
 catch (      IOException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    itemReadStream.close();
    name=originalItem.getName();
    type=originalItem.getItemType();
  }
 else {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return;
}",0.992091226779474
133332,"/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  if (remoteManager != null) {
    List<IRemoteConnectionType> types=getService(IRemoteServicesManager.class).getRemoteConnectionTypes();
    IRemoteConnectionType connectionType=null;
    for (    IRemoteConnectionType type : types) {
      if (""String_Node_Str"".equals(type.getName())) {
        connectionType=type;
        break;
      }
    }
    if (connectionType != null) {
      try {
        for (        IRemoteConnection c : connectionType.getConnections()) {
          String connectionHost=c.getService(IRemoteConnectionHostService.class).getHostname();
          if (InetAddress.getByName(host).getHostAddress().equals(InetAddress.getByName(connectionHost).getHostAddress())) {
            connection=c;
            return connection;
          }
        }
      }
 catch (      UnknownHostException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
      if (connection == null) {
        final IRemoteConnectionType finalType=connectionType;
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            IRemoteUIConnectionService uiConnService=finalType.getService(IRemoteUIConnectionService.class);
            IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
            if (wizard != null) {
              wizard.setConnectionName(host);
              try {
                connection=wizard.open().save();
                if (connection != null) {
                  connection.open(null);
                }
              }
 catch (              RemoteConnectionException e) {
                logger.error(getClass().getName() + ""String_Node_Str"",e);
              }
            }
          }
        }
);
      }
    }
  }
  return connection;
}","/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  if (remoteManager != null) {
    List<IRemoteConnectionType> types=getService(IRemoteServicesManager.class).getRemoteConnectionTypes();
    IRemoteConnectionType connectionType=null;
    for (    IRemoteConnectionType type : types) {
      if (""String_Node_Str"".equals(type.getName())) {
        connectionType=type;
        break;
      }
    }
    if (connectionType != null) {
      for (      IRemoteConnection c : connectionType.getConnections()) {
        if (host.equals(c.getName())) {
          connection=c;
          return connection;
        }
      }
      if (connection == null) {
        final IRemoteConnectionType finalType=connectionType;
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            IRemoteUIConnectionService uiConnService=finalType.getService(IRemoteUIConnectionService.class);
            IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
            if (wizard != null) {
              wizard.setConnectionName(host);
              try {
                connection=wizard.open().save();
                if (connection != null) {
                  connection.open(null);
                }
              }
 catch (              RemoteConnectionException e) {
                logger.error(getClass().getName() + ""String_Node_Str"",e);
              }
            }
          }
        }
);
      }
    }
  }
  return connection;
}",0.8812260536398467
133333,"/** 
 * This operation draws a browser on the page that displays the selected ICEResource.
 * @param formToolkit The FormToolkit that is used to create SWT widgets for this page.
 * @param form The IManagedForm on which the table should be drawn.
 */
protected Browser createBrowser(Composite parent,FormToolkit toolkit){
  Browser browser=null;
  try {
    browser=new Browser(parent,SWT.NONE);
    toolkit.adapt(browser);
    browser.setLayout(new GridLayout());
    browser.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
    browser.layout(true);
    if (!resourceComponent.isEmpty()) {
      browser.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      browser.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  SWTError e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  return browser;
}","/** 
 * This operation draws a browser on the page that displays the selected ICEResource.
 * @param formToolkit The FormToolkit that is used to create SWT widgets for this page.
 * @param form The IManagedForm on which the table should be drawn.
 */
protected Browser createBrowser(Composite parent,FormToolkit toolkit){
  Browser browser=null;
  try {
    browser=new Browser(parent,SWT.NONE);
    toolkit.adapt(browser);
    browser.layout(true);
    if (!resourceComponent.isEmpty()) {
      browser.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      browser.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  SWTError e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  return browser;
}",0.5076660988074957
133334,"@Override public void resourceChanged(IResourceChangeEvent event){
  if (event.getType() == IResourceChangeEvent.POST_CHANGE) {
    try {
      event.getDelta().accept(new IResourceDeltaVisitor(){
        public boolean visit(        IResourceDelta delta) throws CoreException {
          for (          ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
            if (delta.getResource().getName().equals((new File(r.getPath()).getName()))) {
              ICEResourcePage.this.update(r);
            }
          }
          return true;
        }
      }
);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
}","@Override public void resourceChanged(IResourceChangeEvent event){
  if (event.getType() == IResourceChangeEvent.POST_CHANGE) {
    try {
      event.getDelta().accept(new IResourceDeltaVisitor(){
        @Override public boolean visit(        IResourceDelta delta) throws CoreException {
          for (          ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
            if (delta.getResource().getName().equals((new File(r.getPath()).getName()))) {
              ICEResourcePage.this.update(r);
            }
          }
          return true;
        }
      }
);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
}",0.9924698795180724
133335,"/** 
 * The default constructor.
 * @param editor The FormEditor for which the Page should be constructed. This should be an  {@link ICEFormEditor}.
 * @param id The id of the page.
 * @param title The title of the page.
 */
public ICEResourcePage(FormEditor editor,String id,String title){
  super(editor,id,title);
  if (!(editor instanceof ICEFormEditor)) {
    logger.info(""String_Node_Str"");
  }
  String[] extensions={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  textFileExtensions=new ArrayList<String>(Arrays.asList(extensions));
  ResourcesPlugin.getWorkspace().addResourceChangeListener(this,IResourceChangeEvent.POST_CHANGE);
  return;
}","/** 
 * The default constructor.
 * @param editor The FormEditor for which the Page should be constructed. This should be an  {@link ICEFormEditor}.
 * @param id The id of the page.
 * @param title The title of the page.
 */
public ICEResourcePage(FormEditor editor,String id,String title){
  super(editor,id,title);
  if (!(editor instanceof ICEFormEditor)) {
    logger.info(""String_Node_Str"");
  }
  String[] extensions={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  textFileExtensions=new ArrayList<String>(Arrays.asList(extensions));
  ResourcesPlugin.getWorkspace().addResourceChangeListener(this,IResourceChangeEvent.POST_CHANGE);
  return;
}",0.9865671641791044
133336,"/** 
 * This operation overrides the default/abstract implementation of FormPage.createFormContents to create the contents of the ICEResourcePage.
 * @param managedForm The Form widget on which the ICEResourcePage exists.
 */
@Override protected void createFormContent(IManagedForm managedForm){
  final FormToolkit toolkit=managedForm.getToolkit();
  try {
    getSite().getWorkbenchWindow().getActivePage().showView(ICEResourceView.ID);
  }
 catch (  PartInitException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  pageComposite=managedForm.getForm().getBody();
  pageComposite.setLayout(stackLayout);
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(this);
  pageComposite.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent event){
      getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(ICEResourcePage.this);
    }
  }
);
  browser=createBrowser(pageComposite,toolkit);
  stackLayout.topControl=browser;
  pageComposite.layout();
  plotGridComposite=new PlotGridComposite(pageComposite,SWT.NONE);
  toolkit.adapt(plotGridComposite);
  workbenchPage=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
  return;
}","/** 
 * This operation overrides the default/abstract implementation of FormPage.createFormContents to create the contents of the ICEResourcePage.
 * @param managedForm The Form widget on which the ICEResourcePage exists.
 */
@Override protected void createFormContent(IManagedForm managedForm){
  final FormToolkit toolkit=managedForm.getToolkit();
  try {
    getSite().getWorkbenchWindow().getActivePage().showView(ICEResourceView.ID);
  }
 catch (  PartInitException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  pageComposite=managedForm.getForm().getBody();
  pageComposite.setLayout(stackLayout);
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(this);
  pageComposite.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent event){
      getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(ICEResourcePage.this);
    }
  }
);
  browser=createBrowser(pageComposite,toolkit);
  stackLayout.topControl=browser;
  if (browser == null) {
    Label label=new Label(pageComposite,SWT.CENTER);
    label.setText(""String_Node_Str"");
    stackLayout.topControl=label;
  }
  pageComposite.layout();
  plotGridComposite=new PlotGridComposite(pageComposite,SWT.NONE);
  toolkit.adapt(plotGridComposite);
  workbenchPage=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
  return;
}",0.8986587183308494
133337,"/** 
 * Updates the Resource Page's widgets to render the specified Resource. <p> <b>Note:</b> This method assumes it is called from the UI thread. </p>
 * @param resource The resource to render. Assumed not to be  {@code null}.
 * @throws PartInitException
 */
public void showResource(ICEResource resource) throws PartInitException {
  if (resource == null) {
    Control topControl=stackLayout.topControl;
    if (topControl != browser) {
      browser.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      stackLayout.topControl=browser;
      pageComposite.layout();
      if (topControl != null && !topControl.isDisposed()) {
        topControl.dispose();
      }
    }
    return;
  }
  boolean useBrowser=!(resource instanceof VizResource);
  if (!useBrowser) {
    try {
      if (plotGridComposite.addPlot(resource.getPath()) != -1) {
        stackLayout.topControl=plotGridComposite;
        pageComposite.layout();
        activateEditor();
        return;
      }
    }
 catch (    Exception e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
  String path=resource.getPath().toString();
  int extIndex=path.lastIndexOf(""String_Node_Str"");
  String fileExtension=path.substring(extIndex + 1);
  boolean useEditor=textFileExtensions.contains(fileExtension);
  if (useEditor) {
    IFileStore fileOnLocalDisk=EFS.getLocalFileSystem().getStore(resource.getPath());
    FileStoreEditorInput editorInput=new FileStoreEditorInput(fileOnLocalDisk);
    IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    IWorkbenchPage page=window.getActivePage();
    page.openEditor(editorInput,""String_Node_Str"");
  }
  if (useBrowser && !useEditor && browser != null && !browser.isDisposed()) {
    browser.setUrl(path);
    stackLayout.topControl=browser;
    pageComposite.layout();
    activateEditor();
  }
  return;
}","/** 
 * Updates the Resource Page's widgets to render the specified Resource. <p> <b>Note:</b> This method assumes it is called from the UI thread. </p>
 * @param resource The resource to render. Assumed not to be  {@code null}.
 * @throws PartInitException
 */
public void showResource(ICEResource resource) throws PartInitException {
  if (resource == null) {
    Control topControl=stackLayout.topControl;
    if (topControl != browser) {
      if (browser != null && !browser.isDisposed()) {
        browser.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        stackLayout.topControl=browser;
        pageComposite.layout();
      }
 else {
        Label label=new Label(pageComposite,SWT.CENTER);
        label.setText(""String_Node_Str"");
        stackLayout.topControl=label;
      }
      if (topControl != null && !topControl.isDisposed()) {
        topControl.dispose();
      }
    }
    return;
  }
  boolean useBrowser=!(resource instanceof VizResource);
  if (!useBrowser) {
    try {
      if (plotGridComposite.addPlot(resource.getPath()) != -1) {
        stackLayout.topControl=plotGridComposite;
        pageComposite.layout();
        activateEditor();
        return;
      }
    }
 catch (    Exception e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
  String path=resource.getPath().toString();
  int extIndex=path.lastIndexOf(""String_Node_Str"");
  String fileExtension=path.substring(extIndex + 1);
  boolean useEditor=textFileExtensions.contains(fileExtension);
  if (useEditor) {
    IFileStore fileOnLocalDisk=EFS.getLocalFileSystem().getStore(resource.getPath());
    FileStoreEditorInput editorInput=new FileStoreEditorInput(fileOnLocalDisk);
    IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    IWorkbenchPage page=window.getActivePage();
    page.openEditor(editorInput,""String_Node_Str"");
  }
  if (useBrowser && !useEditor && browser != null && !browser.isDisposed()) {
    browser.setUrl(path);
    stackLayout.topControl=browser;
    pageComposite.layout();
    activateEditor();
  }
  return;
}",0.9453916481344206
133338,"public boolean visit(IResourceDelta delta) throws CoreException {
  for (  ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
    if (delta.getResource().getName().equals((new File(r.getPath()).getName()))) {
      ICEResourcePage.this.update(r);
    }
  }
  return true;
}","@Override public boolean visit(IResourceDelta delta) throws CoreException {
  for (  ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
    if (delta.getResource().getName().equals((new File(r.getPath()).getName()))) {
      ICEResourcePage.this.update(r);
    }
  }
  return true;
}",0.9833333333333332
133339,"/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  if (remoteManager != null) {
    IRemoteConnectionType connectionType=remoteManager.getRemoteConnectionTypes().get(0);
    if (connectionType != null) {
      try {
        for (        IRemoteConnection c : connectionType.getConnections()) {
          String connectionHost=c.getService(IRemoteConnectionHostService.class).getHostname();
          if (InetAddress.getByName(host).getHostAddress().equals(InetAddress.getByName(connectionHost).getHostAddress())) {
            connection=c;
            return connection;
          }
        }
      }
 catch (      UnknownHostException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
      if (connection == null) {
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            IRemoteUIConnectionService uiConnService=connectionType.getService(IRemoteUIConnectionService.class);
            IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
            if (wizard != null) {
              wizard.setConnectionName(host);
              try {
                connection=wizard.open().save();
                if (connection != null) {
                  connection.open(null);
                }
              }
 catch (              RemoteConnectionException e) {
                logger.error(getClass().getName() + ""String_Node_Str"",e);
              }
            }
          }
        }
);
      }
    }
  }
  return connection;
}","/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  if (remoteManager != null) {
    List<IRemoteConnectionType> types=getService(IRemoteServicesManager.class).getRemoteConnectionTypes();
    IRemoteConnectionType connectionType=null;
    for (    IRemoteConnectionType type : types) {
      if (""String_Node_Str"".equals(type.getName())) {
        connectionType=type;
        break;
      }
    }
    if (connectionType != null) {
      try {
        for (        IRemoteConnection c : connectionType.getConnections()) {
          String connectionHost=c.getService(IRemoteConnectionHostService.class).getHostname();
          if (InetAddress.getByName(host).getHostAddress().equals(InetAddress.getByName(connectionHost).getHostAddress())) {
            connection=c;
            return connection;
          }
        }
      }
 catch (      UnknownHostException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
      if (connection == null) {
        final IRemoteConnectionType finalType=connectionType;
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            IRemoteUIConnectionService uiConnService=finalType.getService(IRemoteUIConnectionService.class);
            IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
            if (wizard != null) {
              wizard.setConnectionName(host);
              try {
                connection=wizard.open().save();
                if (connection != null) {
                  connection.open(null);
                }
              }
 catch (              RemoteConnectionException e) {
                logger.error(getClass().getName() + ""String_Node_Str"",e);
              }
            }
          }
        }
);
      }
    }
  }
  return connection;
}",0.9085396664982316
133340,"@Override public void run(){
  IRemoteUIConnectionService uiConnService=connectionType.getService(IRemoteUIConnectionService.class);
  IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
  if (wizard != null) {
    wizard.setConnectionName(host);
    try {
      connection=wizard.open().save();
      if (connection != null) {
        connection.open(null);
      }
    }
 catch (    RemoteConnectionException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  IRemoteUIConnectionService uiConnService=finalType.getService(IRemoteUIConnectionService.class);
  IRemoteUIConnectionWizard wizard=uiConnService.getConnectionWizard(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
  if (wizard != null) {
    wizard.setConnectionName(host);
    try {
      connection=wizard.open().save();
      if (connection != null) {
        connection.open(null);
      }
    }
 catch (    RemoteConnectionException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
}",0.9868305531167691
133341,"/** 
 * <p> This operation configures a NekModel. It is used by both test operations. </p>
 * @return <p> A newly instantiated NekModel. </p>
 */
private NekModel setupNekItem(){
  NekModel model=new NekModel(projectSpace,new TestNekControllerFactory());
  return model;
}","/** 
 * <p> This operation configures a NekModel. It is used by both test operations. </p>
 * @return <p> A newly instantiated NekModel. </p>
 */
private NekModel setupNekItem(){
  IVizService service=new FakeVizService();
  IVizServiceFactory factory=new BasicVizServiceFactory();
  factory.register(service);
  VizServiceFactoryHolder.setVizServiceFactory(factory);
  NekModel model=new NekModel(projectSpace,new TestNekControllerFactory());
  return model;
}",0.7421555252387448
133342,"/** 
 * This operation overrides the base class operation to properly account for the Nek5000 file structure.
 * @param installDir The installation directory of Nek5000.
 * @param executable The name of the executable selected by a client.
 * @return The updated executable name reflecting the fact that all Nek5000examples are setup as ${executable}/nek5000.
 */
@Override protected String updateExecutablePath(String installDir,String executable){
  HashMap<String,String> executableMap=new HashMap<String,String>();
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  String exampleCopyStage=""String_Node_Str"" + installDir + ""String_Node_Str""+ executable+ ""String_Node_Str"";
  String rmObjStage=""String_Node_Str"";
  String inputCopyStage=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str"";
  String launchStage=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str"";
  String vizStage=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str"";
  String launchCommand=exampleCopyStage + rmObjStage + inputCopyStage+ launchStage+ vizStage;
  return launchCommand;
}","/** 
 * This operation overrides the base class operation to properly account for the Nek5000 file structure.
 * @param installDir The installation directory of Nek5000.
 * @param executable The name of the executable selected by a client.
 * @return The updated executable name reflecting the fact that all Nek5000examples are setup as ${executable}/nek5000.
 */
@Override protected String updateExecutablePath(String installDir,String executable){
  HashMap<String,String> executableMap=new HashMap<String,String>();
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  String exampleCopyStage=""String_Node_Str"" + installDir + ""String_Node_Str""+ executable+ ""String_Node_Str"";
  String inputCopyStage=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str"";
  String copyNekStep=""String_Node_Str"";
  String launchStage=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str""+ executableMap.get(executable)+ ""String_Node_Str"";
  String vizStage=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str""+ executableMap.get(executable)+ ""String_Node_Str"";
  String rmObjStage=""String_Node_Str"";
  String launchCommand=exampleCopyStage + inputCopyStage + copyNekStep+ launchStage+ vizStage+ rmObjStage;
  return launchCommand;
}",0.87612434906107
133343,"/** 
 * Grabs the MESH DATA MeshComponent from the componentMap and writes the contents to the specified OutputStream. In the process of iterating through each element/quad, this method also constructs 2+ ArrayLists of Strings (thermal, fluid and if any passive scalar BCs) representing lines of boundary conditions in a reafile. These ArrayLists are passed into the writeBoundaryConditions(...) method.
 * @param stream The OutputStream to write to
 * @throws IOException Thrown when writing to OutputStream fails
 */
private void writeMesh(OutputStream stream) throws IOException {
  MeshComponent mesh=(MeshComponent)componentMap.get(""String_Node_Str"");
  NekPolygonController currQuad;
  IController currEdge;
  int currEdgeId;
  ArrayList<VertexController> currVertices=new ArrayList<VertexController>();
  String currValue;
  StringBuffer buffer=new StringBuffer();
  ArrayList<String> bufferArray=new ArrayList<String>();
  ArrayList<Float> xCoords=new ArrayList<Float>();
  ArrayList<Float> yCoords=new ArrayList<Float>();
  BoundaryCondition currBC;
  ArrayList<Float> currBCValues=new ArrayList<Float>();
  ArrayList<String> thermalBCs=new ArrayList<String>();
  ArrayList<String> fluidBCs=new ArrayList<String>();
  ArrayList<ArrayList<String>> passiveScalarBCs=null;
  for (int i=0; i < mesh.getPolygons().size(); i++) {
    currQuad=(NekPolygonController)mesh.getPolygons().get(i);
    currValue=String.format(""String_Node_Str"" + ""String_Node_Str"",(i + 1),currQuad.getPolygonProperties().getMaterialId(),currQuad.getPolygonProperties().getGroupNum());
    buffer.append(currValue);
    for (    IController entity : currQuad.getEntitiesFromCategory(MeshCategory.EDGES)) {
      for (      VertexController v : entity.getEntitiesFromCategory(MeshCategory.VERTICES,VertexController.class)) {
        if (!currVertices.contains(v)) {
          currVertices.add(v);
        }
      }
    }
    for (int k=0; k < 4; k++) {
      xCoords.add((float)currVertices.get(k).getTranslation()[0]);
      yCoords.add((float)currVertices.get(k).getTranslation()[1]);
    }
    for (int j=0; j < 4; j++) {
      currEdge=currQuad.getEntitiesFromCategory(MeshCategory.EDGES).get(j);
      currEdgeId=Integer.valueOf(currEdge.getProperty(MeshProperty.ID));
      currBC=currQuad.getFluidBoundaryCondition(currEdgeId);
      if (currBC.getType() != BoundaryConditionType.None) {
        currBCValues=currBC.getValues();
        currValue=String.format(""String_Node_Str"",currBC.getType().id,(i + 1),(j + 1),currBCValues.get(0),currBCValues.get(1),currBCValues.get(2),currBCValues.get(3),currBCValues.get(4));
        fluidBCs.add(currValue);
      }
      currBC=currQuad.getThermalBoundaryCondition(currEdgeId);
      if (currBC.getType() != BoundaryConditionType.None) {
        currBCValues=currBC.getValues();
        currValue=String.format(""String_Node_Str"",currBC.getType().id,(i + 1),(j + 1),currBCValues.get(0),currBCValues.get(1),currBCValues.get(2),currBCValues.get(3),currBCValues.get(4));
        thermalBCs.add(currValue);
      }
      if (properties.getNumPassiveScalars() > 0) {
        passiveScalarBCs=new ArrayList<ArrayList<String>>(properties.getNumPassiveScalars());
        for (int k=1; k <= properties.getNumPassiveScalars(); k++) {
          currBC=currQuad.getOtherBoundaryCondition(currEdgeId,k);
          if (currBC.getType() != BoundaryConditionType.None) {
            currBCValues=currBC.getValues();
            currValue=String.format(""String_Node_Str"",currBC.getType().id,(i + 1),(j + 1),currBCValues.get(0),currBCValues.get(1),currBCValues.get(2),currBCValues.get(3),currBCValues.get(4));
            passiveScalarBCs.get(k).add(currValue);
          }
        }
      }
    }
    currValue=String.format(""String_Node_Str"" + ""String_Node_Str"",xCoords.get(0),xCoords.get(1),xCoords.get(2),xCoords.get(3),yCoords.get(0),yCoords.get(1),yCoords.get(2),yCoords.get(3));
    buffer.append(currValue);
    xCoords.clear();
    yCoords.clear();
  }
  updateProperties(properties.getNumDimensions(),thermalBCs.isEmpty() ? properties.getNumThermalElements() : thermalBCs.size() / 4,fluidBCs.isEmpty() ? properties.getNumFluidElements() : fluidBCs.size() / 4,passiveScalarBCs == null ? 0 : passiveScalarBCs.size() / 4);
  String meshHeader=String.format(""String_Node_Str"" + ""String_Node_Str"",properties.getNumThermalElements(),properties.getNumDimensions(),properties.getNumFluidElements());
  buffer.insert(0,meshHeader);
  byte[] byteArray=buffer.toString().getBytes();
  stream.write(byteArray);
  writeCurvedSideData(stream);
  writeBoundaryConditions(stream,fluidBCs,thermalBCs,passiveScalarBCs);
  return;
}","/** 
 * Grabs the MESH DATA MeshComponent from the componentMap and writes the contents to the specified OutputStream. In the process of iterating through each element/quad, this method also constructs 2+ ArrayLists of Strings (thermal, fluid and if any passive scalar BCs) representing lines of boundary conditions in a reafile. These ArrayLists are passed into the writeBoundaryConditions(...) method.
 * @param stream The OutputStream to write to
 * @throws IOException Thrown when writing to OutputStream fails
 */
private void writeMesh(OutputStream stream) throws IOException {
  MeshComponent mesh=(MeshComponent)componentMap.get(""String_Node_Str"");
  NekPolygonController currQuad;
  IController currEdge;
  int currEdgeId;
  String currValue;
  StringBuffer buffer=new StringBuffer();
  ArrayList<String> bufferArray=new ArrayList<String>();
  ArrayList<Float> xCoords=new ArrayList<Float>();
  ArrayList<Float> yCoords=new ArrayList<Float>();
  BoundaryCondition currBC;
  ArrayList<Float> currBCValues=new ArrayList<Float>();
  ArrayList<String> thermalBCs=new ArrayList<String>();
  ArrayList<String> fluidBCs=new ArrayList<String>();
  ArrayList<ArrayList<String>> passiveScalarBCs=null;
  for (int i=0; i < mesh.getPolygons().size(); i++) {
    currQuad=(NekPolygonController)mesh.getPolygons().get(i);
    currValue=String.format(""String_Node_Str"" + ""String_Node_Str"",(i + 1),currQuad.getPolygonProperties().getMaterialId(),currQuad.getPolygonProperties().getGroupNum());
    buffer.append(currValue);
    for (    EdgeController entity : currQuad.getEntitiesFromCategory(MeshCategory.EDGES,EdgeController.class)) {
      xCoords.add((float)entity.getStartLocation()[0]);
      yCoords.add((float)entity.getStartLocation()[1]);
    }
    for (int j=0; j < 4; j++) {
      currEdge=currQuad.getEntitiesFromCategory(MeshCategory.EDGES).get(j);
      currEdgeId=Integer.valueOf(currEdge.getProperty(MeshProperty.ID));
      currBC=currQuad.getFluidBoundaryCondition(currEdgeId);
      if (currBC.getType() != BoundaryConditionType.None) {
        currBCValues=currBC.getValues();
        currValue=String.format(""String_Node_Str"",currBC.getType().id,(i + 1),(j + 1),currBCValues.get(0),currBCValues.get(1),currBCValues.get(2),currBCValues.get(3),currBCValues.get(4));
        fluidBCs.add(currValue);
      }
      currBC=currQuad.getThermalBoundaryCondition(currEdgeId);
      if (currBC.getType() != BoundaryConditionType.None) {
        currBCValues=currBC.getValues();
        currValue=String.format(""String_Node_Str"",currBC.getType().id,(i + 1),(j + 1),currBCValues.get(0),currBCValues.get(1),currBCValues.get(2),currBCValues.get(3),currBCValues.get(4));
        thermalBCs.add(currValue);
      }
      if (properties.getNumPassiveScalars() > 0) {
        passiveScalarBCs=new ArrayList<ArrayList<String>>(properties.getNumPassiveScalars());
        for (int k=1; k <= properties.getNumPassiveScalars(); k++) {
          currBC=currQuad.getOtherBoundaryCondition(currEdgeId,k);
          if (currBC.getType() != BoundaryConditionType.None) {
            currBCValues=currBC.getValues();
            currValue=String.format(""String_Node_Str"",currBC.getType().id,(i + 1),(j + 1),currBCValues.get(0),currBCValues.get(1),currBCValues.get(2),currBCValues.get(3),currBCValues.get(4));
            passiveScalarBCs.get(k).add(currValue);
          }
        }
      }
    }
    currValue=String.format(""String_Node_Str"" + ""String_Node_Str"",xCoords.get(0),xCoords.get(1),xCoords.get(2),xCoords.get(3),yCoords.get(0),yCoords.get(1),yCoords.get(2),yCoords.get(3));
    buffer.append(currValue);
    xCoords.clear();
    yCoords.clear();
  }
  updateProperties(properties.getNumDimensions(),thermalBCs.isEmpty() ? properties.getNumThermalElements() : thermalBCs.size() / 4,fluidBCs.isEmpty() ? properties.getNumFluidElements() : fluidBCs.size() / 4,passiveScalarBCs == null ? 0 : passiveScalarBCs.size() / 4);
  String meshHeader=String.format(""String_Node_Str"" + ""String_Node_Str"",properties.getNumThermalElements(),properties.getNumDimensions(),properties.getNumFluidElements());
  buffer.insert(0,meshHeader);
  byte[] byteArray=buffer.toString().getBytes();
  stream.write(byteArray);
  writeCurvedSideData(stream);
  writeBoundaryConditions(stream,fluidBCs,thermalBCs,passiveScalarBCs);
  return;
}",0.9467799642218246
133344,"@Override public FormStatus execute(Dictionary<String,String> dictionary){
  status=FormStatus.Processing;
  String localDir=dictionary.get(""String_Node_Str"");
  String hostName=dictionary.get(""String_Node_Str"");
  ExecutionHelper helper=new ExecutionHelper(dictionary);
  if (localDir == null || hostName == null) {
    return actionError(""String_Node_Str"",null);
  }
  String connectionName=dictionary.get(""String_Node_Str"");
  if (connectionName == null) {
    connection=getRemoteConnection(hostName);
  }
 else {
    IRemoteConnectionType connectionType=getService(IRemoteServicesManager.class).getRemoteConnectionTypes().get(0);
    for (    IRemoteConnection c : connectionType.getConnections()) {
      if (connectionName.equals(c.getName())) {
        connection=c;
      }
    }
  }
  if (connection == null) {
    return actionError(""String_Node_Str"" + hostName,null);
  }
  if (!connection.isOpen()) {
    try {
      connection.open(null);
    }
 catch (    RemoteConnectionException e) {
      return actionError(""String_Node_Str"",e);
    }
  }
  IRemoteFileService fileManager=connection.getService(IRemoteFileService.class);
  IFileStore localDirectory=EFS.getLocalFileSystem().fromLocalFile(helper.getLocalLaunchFolder().getLocation().toFile());
  String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
  String userHome=connection.getProperty(IRemoteConnection.USER_HOME_PROPERTY);
  IFileStore downloadFileStore=fileManager.getResource(userHome + remoteSeparator + ""String_Node_Str""+ remoteSeparator+ localDir);
  try {
    IFileStore[] remoteStores=downloadFileStore.childStores(EFS.NONE,null);
    for (    IFileStore remoteFile : remoteStores) {
      IFileInfo fileInfo=remoteFile.fetchInfo();
      if (fileInfo.getLength() < maxFileSize) {
        String msg=""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getName() + ""String_Node_Str""+ fileInfo.getLength()+ ""String_Node_Str"";
        logger.info(msg);
        postConsoleText(msg);
        IFileStore childStore=localDirectory.getChild(remoteFile.getName());
        remoteFile.copy(childStore,EFS.OVERWRITE,null);
      }
 else {
        long sizeDiff=fileInfo.getLength() - maxFileSize;
        String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getLength() + ""String_Node_Str""+ sizeDiff+ ""String_Node_Str""+ maxFileSize+ ""String_Node_Str"";
        postConsoleText(msg);
        logger.info(msg);
      }
    }
  }
 catch (  CoreException e) {
    return actionError(getClass().getName() + ""String_Node_Str"",e);
  }
  status=FormStatus.Processed;
  return status;
}","@Override public FormStatus execute(Dictionary<String,String> dictionary){
  status=FormStatus.Processing;
  String localDir=dictionary.get(""String_Node_Str"");
  String hostName=dictionary.get(""String_Node_Str"");
  ExecutionHelper helper=new ExecutionHelper(dictionary);
  if (localDir == null || hostName == null) {
    return actionError(""String_Node_Str"",null);
  }
  String connectionName=dictionary.get(""String_Node_Str"");
  if (connectionName == null) {
    connection=getRemoteConnection(hostName);
  }
 else {
    List<IRemoteConnectionType> types=getService(IRemoteServicesManager.class).getRemoteConnectionTypes();
    IRemoteConnectionType connectionType=null;
    for (    IRemoteConnectionType type : types) {
      if (""String_Node_Str"".equals(type.getName())) {
        connectionType=type;
        break;
      }
    }
    if (connectionType == null) {
      return actionError(""String_Node_Str"",null);
    }
    for (    IRemoteConnection c : connectionType.getConnections()) {
      if (connectionName.equals(c.getName())) {
        connection=c;
      }
    }
  }
  if (connection == null) {
    return actionError(""String_Node_Str"" + hostName,null);
  }
  if (!connection.isOpen()) {
    try {
      connection.open(null);
    }
 catch (    RemoteConnectionException e) {
      return actionError(""String_Node_Str"",e);
    }
  }
  IRemoteFileService fileManager=connection.getService(IRemoteFileService.class);
  IFileStore localDirectory=EFS.getLocalFileSystem().fromLocalFile(helper.getLocalLaunchFolder().getLocation().toFile());
  String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
  String userHome=connection.getProperty(IRemoteConnection.USER_HOME_PROPERTY);
  IFileStore downloadFileStore=fileManager.getResource(userHome + remoteSeparator + ""String_Node_Str""+ remoteSeparator+ localDir);
  try {
    IFileStore[] remoteStores=downloadFileStore.childStores(EFS.NONE,null);
    for (    IFileStore remoteFile : remoteStores) {
      IFileInfo fileInfo=remoteFile.fetchInfo();
      if (fileInfo.getLength() < maxFileSize) {
        String msg=""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getName() + ""String_Node_Str""+ fileInfo.getLength()+ ""String_Node_Str"";
        logger.info(msg);
        postConsoleText(msg);
        IFileStore childStore=localDirectory.getChild(remoteFile.getName());
        remoteFile.copy(childStore,EFS.OVERWRITE,null);
      }
 else {
        long sizeDiff=fileInfo.getLength() - maxFileSize;
        String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getLength() + ""String_Node_Str""+ sizeDiff+ ""String_Node_Str""+ maxFileSize+ ""String_Node_Str"";
        postConsoleText(msg);
        logger.info(msg);
      }
    }
  }
 catch (  CoreException e) {
    return actionError(getClass().getName() + ""String_Node_Str"",e);
  }
  status=FormStatus.Processed;
  return status;
}",0.9266521423384168
133345,"@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  ILaunchManager manager=DebugPlugin.getDefault().getLaunchManager();
  if (manager != null) {
    IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
    IProject productProject=root.getProject(""String_Node_Str"");
    if (productProject != null) {
      ArrayList<String> currentPlugins=new ArrayList<String>();
      ArrayList<String> notIncludedProjects=new ArrayList<String>();
      String fileName=""String_Node_Str"", currentPluginsStr=""String_Node_Str"", key=""String_Node_Str"";
      String vmArgs=""String_Node_Str"", vmArgsKey=""String_Node_Str"";
      String[] plugins;
      if (SystemUtils.IS_OS_WINDOWS) {
        fileName=""String_Node_Str"";
      }
 else       if (SystemUtils.IS_OS_MAC_OSX) {
        fileName=""String_Node_Str"";
      }
 else       if (SystemUtils.IS_OS_LINUX) {
        fileName=""String_Node_Str"";
      }
 else {
        throw new ExecutionException(""String_Node_Str"");
      }
      IFile launchICE=productProject.getFile(""String_Node_Str"" + fileName);
      if (!launchICE.exists()) {
        IFile tempCopy=productProject.getFile(fileName);
        try {
          launchICE.create(tempCopy.getContents(),true,null);
        }
 catch (        CoreException e1) {
          e1.printStackTrace();
          logger.error(""String_Node_Str"" + fileName,e1);
        }
      }
      ILaunchConfiguration launchConfig=manager.getLaunchConfiguration(launchICE);
      try {
        currentPluginsStr=launchConfig.getAttribute(key,""String_Node_Str"");
        vmArgs=launchConfig.getAttribute(vmArgsKey,""String_Node_Str"");
        vmArgs=vmArgs.replace(""String_Node_Str"",""String_Node_Str"");
        plugins=currentPluginsStr.split(""String_Node_Str"");
        for (        String s : plugins) {
          currentPlugins.add(s.split(""String_Node_Str"")[0]);
        }
        List<String> pluginsToIgnore=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        for (        IProject p : root.getProjects()) {
          String name=p.getName();
          if (!currentPlugins.contains(p.getName()) && !name.contains(""String_Node_Str"") && !name.contains(""String_Node_Str"")&& !name.contains(""String_Node_Str"")&& !name.contains(""String_Node_Str"")&& !pluginsToIgnore.contains(name)) {
            notIncludedProjects.add(p.getName());
          }
        }
        ListSelectionDialog dialog=new ListSelectionDialog(PlatformUI.getWorkbench().getDisplay().getActiveShell(),notIncludedProjects.toArray(),ArrayContentProvider.getInstance(),new LabelProvider(),""String_Node_Str"");
        dialog.setTitle(""String_Node_Str"");
        int ok=dialog.open();
        if (ok == Window.OK) {
          Object[] results=dialog.getResult();
          for (          Object s : results) {
            currentPluginsStr=s.toString() + ""String_Node_Str"" + currentPluginsStr;
          }
          ILaunchConfigurationWorkingCopy wc=launchConfig.getWorkingCopy();
          wc.setAttribute(key,currentPluginsStr);
          wc.setAttribute(vmArgsKey,vmArgs);
          ILaunchConfiguration config=wc.doSave();
          Job job=new WorkspaceJob(""String_Node_Str""){
            @Override public IStatus runInWorkspace(            IProgressMonitor monitor) throws CoreException {
              config.launch(ILaunchManager.RUN_MODE,monitor);
              return Status.OK_STATUS;
            }
          }
;
          job.schedule();
        }
      }
 catch (      CoreException e) {
        e.printStackTrace();
        logger.error(""String_Node_Str"",e);
      }
    }
  }
  return null;
}","@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  ILaunchManager manager=DebugPlugin.getDefault().getLaunchManager();
  if (manager != null) {
    IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
    IProject productProject=root.getProject(""String_Node_Str"");
    if (productProject != null) {
      ArrayList<String> currentPlugins=new ArrayList<String>();
      ArrayList<String> notIncludedProjects=new ArrayList<String>();
      String fileName=""String_Node_Str"", currentPluginsStr=""String_Node_Str"", key=""String_Node_Str"";
      String vmArgs=""String_Node_Str"", vmArgsKey=""String_Node_Str"";
      String[] plugins;
      if (SystemUtils.IS_OS_WINDOWS) {
        fileName=""String_Node_Str"";
      }
 else       if (SystemUtils.IS_OS_MAC_OSX) {
        fileName=""String_Node_Str"";
      }
 else       if (SystemUtils.IS_OS_LINUX) {
        fileName=""String_Node_Str"";
      }
 else {
        throw new ExecutionException(""String_Node_Str"");
      }
      IFile launchICE=productProject.getFile(""String_Node_Str"" + fileName);
      if (!launchICE.exists()) {
        IFile tempCopy=productProject.getFile(fileName);
        try {
          launchICE.create(tempCopy.getContents(),true,null);
        }
 catch (        CoreException e1) {
          e1.printStackTrace();
          logger.error(""String_Node_Str"" + fileName,e1);
        }
      }
      ILaunchConfiguration launchConfig=manager.getLaunchConfiguration(launchICE);
      try {
        currentPluginsStr=launchConfig.getAttribute(key,""String_Node_Str"");
        vmArgs=launchConfig.getAttribute(vmArgsKey,""String_Node_Str"");
        vmArgs=vmArgs.replace(""String_Node_Str"",""String_Node_Str"");
        plugins=currentPluginsStr.split(""String_Node_Str"");
        for (        String s : plugins) {
          currentPlugins.add(s.split(""String_Node_Str"")[0]);
        }
        List<String> pluginsToIgnore=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        for (        IProject p : root.getProjects()) {
          String name=p.getName();
          if (!currentPlugins.contains(p.getName()) && !name.endsWith(""String_Node_Str"") && !name.contains(""String_Node_Str"")&& !name.contains(""String_Node_Str"")&& !name.contains(""String_Node_Str"")&& !pluginsToIgnore.contains(name)) {
            notIncludedProjects.add(p.getName());
          }
        }
        ListSelectionDialog dialog=new ListSelectionDialog(PlatformUI.getWorkbench().getDisplay().getActiveShell(),notIncludedProjects.toArray(),ArrayContentProvider.getInstance(),new LabelProvider(),""String_Node_Str"");
        dialog.setTitle(""String_Node_Str"");
        int ok=dialog.open();
        if (ok == Window.OK) {
          Object[] results=dialog.getResult();
          for (          Object s : results) {
            currentPluginsStr=s.toString() + ""String_Node_Str"" + currentPluginsStr;
          }
          ILaunchConfigurationWorkingCopy wc=launchConfig.getWorkingCopy();
          wc.setAttribute(key,currentPluginsStr);
          wc.setAttribute(vmArgsKey,vmArgs);
          ILaunchConfiguration config=wc.doSave();
          Job job=new WorkspaceJob(""String_Node_Str""){
            @Override public IStatus runInWorkspace(            IProgressMonitor monitor) throws CoreException {
              config.launch(ILaunchManager.RUN_MODE,monitor);
              return Status.OK_STATUS;
            }
          }
;
          job.schedule();
        }
      }
 catch (      CoreException e) {
        e.printStackTrace();
        logger.error(""String_Node_Str"",e);
      }
    }
  }
  return null;
}",0.9979423868312756
133346,"/** 
 * Update the new project manifest to have required packages imported.
 */
private void updateManifest(){
  String packageBase=fProjectProvider.getProjectName();
  String sep=System.getProperty(""String_Node_Str"");
  String manifestFile=fProjectProvider.getLocationPath().makeAbsolute().toOSString() + sep + fProjectProvider.getProjectName()+ sep+ ""String_Node_Str""+ sep+ ""String_Node_Str"";
  StringBuilder manifestLines=new StringBuilder();
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"" + packageBase + ""String_Node_Str"");
  manifestLines.append(""String_Node_Str"" + packageBase + ""String_Node_Str"");
  try {
    Files.write(Paths.get(manifestFile),manifestLines.toString().getBytes(),StandardOpenOption.APPEND);
  }
 catch (  IOException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
}","/** 
 * Update the new project manifest to have required packages imported.
 */
private void updateManifest(){
  IProject project=fProjectProvider.getProject();
  IFile manifestFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
  String packageBase=fProjectProvider.getProjectName();
  StringBuilder manifestLines=new StringBuilder();
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"" + packageBase + ""String_Node_Str"");
  manifestLines.append(""String_Node_Str"" + packageBase + ""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  manifestLines.append(""String_Node_Str"");
  try {
    manifestFile.appendContents(new ByteArrayInputStream(manifestLines.toString().getBytes()),IResource.FORCE,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}",0.5641484130531963
133347,"/** 
 * This operation ensures that the MOOSEFileHandler can create a MOOSE input file from a set of incoming TreeComposites.
 */
@Test public void checkWritingInputFileFromTree(){
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String filePath=userDir + separator + ""String_Node_Str"";
  String outputFilePath=userDir + separator + ""String_Node_Str"";
  String refFilePath=userDir + separator + ""String_Node_Str"";
  File outputFile=null;
  MOOSEFileHandler handler=new MOOSEFileHandler();
  TreeComposite adaptivity=null, indicators=null;
  TreeComposite analyticalIndicator=null, fluxJumpIndicator=null;
  TreeComposite function=null, powerHistory=null;
  ArrayList<TreeComposite> blocks=null;
  try {
    blocks=handler.loadYAML(filePath);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  adaptivity=getTreeByName(blocks,""String_Node_Str"");
  indicators=(TreeComposite)adaptivity.getChildExemplars().get(0).clone();
  analyticalIndicator=(TreeComposite)indicators.getChildExemplars().get(1).clone();
  fluxJumpIndicator=(TreeComposite)indicators.getChildExemplars().get(2).clone();
  adaptivity.setNextChild(indicators);
  indicators.setNextChild(analyticalIndicator);
  analyticalIndicator.setActive(true);
  indicators.setNextChild(fluxJumpIndicator);
  adaptivity.setActive(true);
  indicators.setActive(true);
  analyticalIndicator.setActive(true);
  fluxJumpIndicator.setActive(true);
  DataComponent adaptivityData=(DataComponent)adaptivity.getDataNodes().get(0);
  adaptivity.setActiveDataNode(adaptivityData);
  adaptivityData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  adaptivityData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  adaptivityData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  DataComponent analyticalIndicatorsComponent=(DataComponent)analyticalIndicator.getDataNodes().get(0);
  analyticalIndicatorsComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  analyticalIndicatorsComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  DataComponent fluxJumpIndicatorComponent=(DataComponent)fluxJumpIndicator.getDataNodes().get(0);
  fluxJumpIndicatorComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  fluxJumpIndicatorComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  fluxJumpIndicatorComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  function=(TreeComposite)getTreeByName(blocks,""String_Node_Str"");
  powerHistory=(TreeComposite)function.getChildExemplars().get(14).clone();
  function.setNextChild(powerHistory);
  powerHistory.setName(""String_Node_Str"");
  function.setActive(true);
  powerHistory.setActive(true);
  DataComponent powerData=(DataComponent)powerHistory.getDataNodes().get(0);
  powerData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  powerData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  Parameter dataFileParam=new Parameter();
  dataFileParam.setName(""String_Node_Str"");
  dataFileParam.setDefault(""String_Node_Str"");
  dataFileParam.setEnabled(true);
  powerData.addEntry(dataFileParam.toEntry());
  handler.dumpInputFile(outputFilePath,blocks);
  outputFile=new File(outputFilePath);
  assertTrue(outputFile.exists());
  int firstHash, lastHash;
  try {
    RandomAccessFile inputFileRAF=new RandomAccessFile(outputFilePath,""String_Node_Str"");
    byte[] inputBytes=new byte[(int)inputFileRAF.length()];
    inputFileRAF.read(inputBytes);
    String inputString=new String(inputBytes);
    String[] inputArray=inputString.split(""String_Node_Str"");
    inputString=""String_Node_Str"";
    boolean hasComment=false;
    for (    String line : inputArray) {
      hasComment=!(line.lastIndexOf(""String_Node_Str"") == -1);
      if (hasComment) {
        firstHash=line.trim().indexOf(""String_Node_Str"");
        lastHash=line.trim().lastIndexOf(""String_Node_Str"");
        if (firstHash == 0 && firstHash == lastHash) {
        }
 else {
          line=line.substring(0,line.lastIndexOf(""String_Node_Str""));
          line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        }
        if (line.endsWith(""String_Node_Str"")) {
          line+=""String_Node_Str"";
        }
      }
      inputString+=line + ""String_Node_Str"";
    }
    RandomAccessFile refFileRAF=new RandomAccessFile(refFilePath,""String_Node_Str"");
    byte[] refBytes=new byte[(int)refFileRAF.length()];
    refFileRAF.read(refBytes);
    String refString=new String(refBytes);
    System.out.println(inputString);
    assertEquals(refString,inputString);
    inputFileRAF.close();
    refFileRAF.close();
    outputFile.deleteOnExit();
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail();
  }
  return;
}","/** 
 * This operation ensures that the MOOSEFileHandler can create a MOOSE input file from a set of incoming TreeComposites.
 */
@Test public void checkWritingInputFileFromTree(){
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String filePath=userDir + separator + ""String_Node_Str"";
  String outputFilePath=userDir + separator + ""String_Node_Str"";
  String refFilePath=userDir + separator + ""String_Node_Str"";
  File outputFile=null;
  MOOSEFileHandler handler=new MOOSEFileHandler();
  TreeComposite adaptivity=null, indicators=null;
  TreeComposite analyticalIndicator=null, fluxJumpIndicator=null;
  TreeComposite function=null, powerHistory=null;
  ArrayList<TreeComposite> blocks=null;
  try {
    blocks=handler.loadYAML(filePath);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  adaptivity=getTreeByName(blocks,""String_Node_Str"");
  indicators=(TreeComposite)adaptivity.getChildExemplars().get(0).clone();
  analyticalIndicator=(TreeComposite)indicators.getChildExemplars().get(1).clone();
  fluxJumpIndicator=(TreeComposite)indicators.getChildExemplars().get(2).clone();
  adaptivity.setNextChild(indicators);
  indicators.setNextChild(analyticalIndicator);
  analyticalIndicator.setActive(true);
  indicators.setNextChild(fluxJumpIndicator);
  adaptivity.setActive(true);
  indicators.setActive(true);
  analyticalIndicator.setActive(true);
  fluxJumpIndicator.setActive(true);
  DataComponent adaptivityData=(DataComponent)adaptivity.getDataNodes().get(0);
  adaptivity.setActiveDataNode(adaptivityData);
  adaptivityData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  adaptivityData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  adaptivityData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  DataComponent analyticalIndicatorsComponent=(DataComponent)analyticalIndicator.getDataNodes().get(0);
  analyticalIndicatorsComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  analyticalIndicatorsComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  DataComponent fluxJumpIndicatorComponent=(DataComponent)fluxJumpIndicator.getDataNodes().get(0);
  fluxJumpIndicatorComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  fluxJumpIndicatorComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  fluxJumpIndicatorComponent.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  function=(TreeComposite)getTreeByName(blocks,""String_Node_Str"");
  powerHistory=(TreeComposite)function.getChildExemplars().get(14).clone();
  function.setNextChild(powerHistory);
  powerHistory.setName(""String_Node_Str"");
  function.setActive(true);
  powerHistory.setActive(true);
  DataComponent powerData=(DataComponent)powerHistory.getDataNodes().get(0);
  powerData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  powerData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  powerData.retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"");
  powerData.retrieveEntry(""String_Node_Str"").setTag(""String_Node_Str"");
  handler.dumpInputFile(outputFilePath,blocks);
  outputFile=new File(outputFilePath);
  assertTrue(outputFile.exists());
  int firstHash, lastHash;
  try {
    RandomAccessFile inputFileRAF=new RandomAccessFile(outputFilePath,""String_Node_Str"");
    byte[] inputBytes=new byte[(int)inputFileRAF.length()];
    inputFileRAF.read(inputBytes);
    String inputString=new String(inputBytes);
    String[] inputArray=inputString.split(""String_Node_Str"");
    inputString=""String_Node_Str"";
    boolean hasComment=false;
    for (    String line : inputArray) {
      hasComment=!(line.lastIndexOf(""String_Node_Str"") == -1);
      if (hasComment) {
        firstHash=line.trim().indexOf(""String_Node_Str"");
        lastHash=line.trim().lastIndexOf(""String_Node_Str"");
        if (firstHash == 0 && firstHash == lastHash) {
        }
 else {
          line=line.substring(0,line.lastIndexOf(""String_Node_Str""));
          line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        }
        if (line.endsWith(""String_Node_Str"")) {
          line+=""String_Node_Str"";
        }
      }
      inputString+=line + ""String_Node_Str"";
    }
    RandomAccessFile refFileRAF=new RandomAccessFile(refFilePath,""String_Node_Str"");
    byte[] refBytes=new byte[(int)refFileRAF.length()];
    refFileRAF.read(refBytes);
    String refString=new String(refBytes);
    System.out.println(inputString);
    assertEquals(refString,inputString);
    inputFileRAF.close();
    refFileRAF.close();
    outputFile.deleteOnExit();
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail();
  }
  return;
}",0.9688373537633296
133348,"@Override public void update(IUpdateable component){
  if (component == meshComp) {
    PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
      @Override public void run(){
        editor.setDirty(true);
      }
    }
);
  }
}","@Override public void update(IUpdateable component){
  PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      editor.setDirty(true);
    }
  }
);
}",0.897025171624714
133349,"/** 
 * Update elementTreeViewer when new elements are added to the mesh.
 * @param component
 * @see IUpdateableListener#update(IUpdateable)
 */
@Override public void update(IUpdateable component){
  logger.info(""String_Node_Str"" + ""String_Node_Str"");
  PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      if (elementTreeViewer != null) {
        logger.info(""String_Node_Str"" + ""String_Node_Str"");
        if (meshComponent != null) {
          elementTreeViewer.setInput(meshComponent.getPolygons());
        }
        elementTreeViewer.refresh();
        elementTreeViewer.getTree().redraw();
      }
    }
  }
);
  return;
}","/** 
 * Update elementTreeViewer when new elements are added to the mesh.
 * @param component
 * @see IUpdateableListener#update(IUpdateable)
 */
@Override public void update(IUpdateable component){
  if (component == meshComponent) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
      @Override public void run(){
        if (elementTreeViewer != null) {
          logger.info(""String_Node_Str"" + ""String_Node_Str"");
          if (meshComponent != null) {
            elementTreeViewer.setInput(meshComponent.getPolygons());
          }
          elementTreeViewer.refresh();
          elementTreeViewer.getTree().redraw();
        }
      }
    }
);
  }
  return;
}",0.953781512605042
133350,"@Override public void update(IManagedUpdateable component,SubscriptionType[] types){
  notifyListeners();
}","@Override public void update(IManagedUpdateable component,SubscriptionType[] types){
  if (types.length != 1 || !SubscriptionType.PROPERTY.equals(types[0])) {
    notifyListeners();
  }
 else {
    notifyListeners(new ICEObject());
  }
}",0.6046511627906976
133351,"@Override public void setAllowedValues(List<String> values){
  allowedValues=values;
}","@Override public void setAllowedValues(List<String> values){
  allowedValues=values;
  if (allowedValues != null && !allowedValues.isEmpty()) {
    setValue(allowedValues.get(0));
  }
}",0.6346863468634686
133352,"/** 
 * This operation clears the Eclipse console. 
 */
public static void clearConsole(){
  if (console != null) {
    console.clearConsole();
  }
}","/** 
 * This operation clears the Eclipse console.
 */
public static void clearConsole(){
  if (console != null) {
    console.clearConsole();
  }
}",0.9966329966329966
133353,"/** 
 * This operation allows subclasses to post errors and return the  appropriate status to the Item executing the Action. 
 * @param errorMessage The descriptive message for the error.
 * @param exception A possible exception to print to the Logger.
 * @return status The error status.
 */
protected FormStatus actionError(String errorMessage,Exception exception){
  if (exception == null) {
    logger.error(errorMessage);
  }
 else {
    logger.error(errorMessage,exception);
  }
  status=FormStatus.InfoError;
  return status;
}","/** 
 * This operation allows subclasses to post errors and return the appropriate status to the Item executing the Action.
 * @param errorMessage The descriptive message for the error.
 * @param exception A possible exception to print to the Logger.
 * @return status The error status.
 */
protected FormStatus actionError(String errorMessage,Exception exception){
  if (exception == null) {
    logger.error(errorMessage);
  }
 else {
    logger.error(errorMessage,exception);
  }
  status=FormStatus.InfoError;
  return status;
}",0.99812382739212
133354,"/** 
 * This static method initializes the data structures necessary  for Eclipse Console output for the Action.execute method. 
 */
protected static void initializeConsoleOutput(){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
      try {
        consoleView=(IConsoleView)page.showView(IConsoleConstants.ID_CONSOLE_VIEW);
        console=new MessageConsole(""String_Node_Str"",null);
        ConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[]{console});
        consoleView.display(console);
        console.activate();
        msgStream=console.newMessageStream();
        msgStream.setActivateOnWrite(true);
        msgStream.println(""String_Node_Str"");
      }
 catch (      PartInitException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"");
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
  }
);
}","/** 
 * This static method initializes the data structures necessary for Eclipse Console output for the Action.execute method.
 */
protected static void initializeConsoleOutput(){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
      try {
        consoleView=(IConsoleView)page.showView(IConsoleConstants.ID_CONSOLE_VIEW);
        if (console == null) {
          console=new MessageConsole(""String_Node_Str"",null);
          ConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[]{console});
          consoleView.display(console);
          console.activate();
          msgStream=console.newMessageStream();
          msgStream.setActivateOnWrite(true);
          msgStream.println(""String_Node_Str"");
        }
      }
 catch (      PartInitException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"");
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
  }
);
}",0.9723703344643724
133355,"/** 
 * This operation can be used by subclasses to post text to  the Eclipse Console. 
 * @param sText The string to print to the Console.
 */
protected void postConsoleText(final String sText){
  if (msgStream == null) {
    initializeConsoleOutput();
  }
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      if (msgStream != null) {
        msgStream.println(sText);
      }
    }
  }
);
  return;
}","/** 
 * This operation can be used by subclasses to post text to the Eclipse Console.
 * @param sText The string to print to the Console.
 */
protected void postConsoleText(final String sText){
  if (msgStream == null) {
    initializeConsoleOutput();
  }
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      if (msgStream != null) {
        msgStream.println(sText);
      }
    }
  }
);
  return;
}",0.9977064220183486
133356,"/** 
 * This method is used in the job launch mechanism to collect all required files for the MooseLauncher
 * @return
 */
private FormStatus populateListOfLauncherFiles(){
  DataComponent launcherFiles=(DataComponent)mooseLauncher.getForm().getComponent(1);
  String fileName=modelFiles.retrieveEntry(""String_Node_Str"").getValue();
  FormStatus retStatus=mooseModel.process(""String_Node_Str"");
  if (!retStatus.equals(FormStatus.Processed)) {
    return retStatus;
  }
  launcherFiles.retrieveEntry(""String_Node_Str"").setValue(fileName);
  mooseLauncher.update(launcherFiles.retrieveEntry(""String_Node_Str""));
  for (  IEntry e : getFileEntries()) {
    IEntry launcherFile=launcherFiles.retrieveEntry(e.getName());
    if (launcherFile != null) {
      launcherFile.setValue(e.getValue());
    }
  }
  return FormStatus.ReadyToProcess;
}","/** 
 * This method is used in the job launch mechanism to collect all required files for the MooseLauncher
 * @return
 */
private FormStatus populateListOfLauncherFiles(){
  DataComponent launcherFiles=(DataComponent)mooseLauncher.getForm().getComponent(1);
  String fileName=modelFiles.retrieveEntry(""String_Node_Str"").getValue();
  FormStatus retStatus=mooseModel.process(""String_Node_Str"");
  if (!retStatus.equals(FormStatus.Processed)) {
    return retStatus;
  }
  FileEntry fileEntry=(FileEntry)launcherFiles.retrieveEntry(""String_Node_Str"");
  ArrayList<String> allowed=new ArrayList<String>();
  allowed.add(fileName);
  fileEntry.setAllowedValues(allowed);
  fileEntry.setValue(fileName);
  mooseLauncher.update(launcherFiles.retrieveEntry(""String_Node_Str""));
  for (  IEntry e : getFileEntries()) {
    IEntry launcherFile=launcherFiles.retrieveEntry(e.getName());
    if (launcherFile != null) {
      launcherFile.setValue(e.getValue());
    }
  }
  return FormStatus.ReadyToProcess;
}",0.912452419793366
133357,"/** 
 * Check that files are populated in the allowed values list. 
 */
@Test public void checkAllowedValues(){
  FileEntry entry=new FileEntry();
  entry.setProject(project);
  assertEquals(13,entry.getAllowedValues().size());
  FileEntry yamlFiles=new FileEntry(""String_Node_Str"");
  yamlFiles.setProject(project);
  assertEquals(3,yamlFiles.getAllowedValues().size());
  IFile file=project.getFile(""String_Node_Str"");
  try {
    file.create(new ByteArrayInputStream(new String(""String_Node_Str"").getBytes()),true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  entry.updateAvailableFiles();
  assertEquals(14,entry.getAllowedValues().size());
  try {
    file.delete(true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
}","/** 
 * Check that files are populated in the allowed values list. 
 */
@Test public void checkAllowedValues(){
  FileEntry entry=new FileEntry();
  entry.setProject(project);
  assertEquals(13,entry.getAllowedValues().size());
  FileEntry yamlFiles=new FileEntry(""String_Node_Str"");
  yamlFiles.setProject(project);
  assertEquals(3,yamlFiles.getAllowedValues().size());
  IFile file=project.getFile(""String_Node_Str"");
  try {
    file.create(new ByteArrayInputStream(new String(""String_Node_Str"").getBytes()),true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  assertEquals(14,entry.getAllowedValues().size());
  try {
    file.delete(true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
}",0.9794079794079794
133358,"/** 
 * This operation lets clients specify the IProject space for the Item containing this FileEntry.
 * @param projectSpace The project this Entry belongs to.
 */
public void setProject(IProject projectSpace){
  project=projectSpace;
  generateAllowedValues();
  isModified=true;
}","/** 
 * This operation lets clients specify the IProject space for the Item containing this FileEntry.
 * @param projectSpace The project this Entry belongs to.
 */
public void setProject(IProject projectSpace){
  if (projectSpace != null) {
    project=projectSpace;
    generateAllowedValues();
    isModified=true;
    ResourcesPlugin.getWorkspace().addResourceChangeListener(this,IResourceChangeEvent.POST_CHANGE);
  }
}",0.7807637906647807
133359,"/** 
 * If the action name is ReflectivityModel.processActionName, then calculates the reflectivity and scattering density profiles for the material layers and input fields.
 * @see {@link org.eclipse.ice.item.Item#process(String)}
 */
@Override public FormStatus process(String actionName){
  FormStatus retVal=FormStatus.InfoError;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    double[] waveVector;
    double[] rData;
    double[] error;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    if (!fileName.isEmpty() && project.getFile(fileName).exists()) {
      IFile userDataFile=project.getFile(fileName);
      Form dataForm=getIOService().getReader(""String_Node_Str"").read(userDataFile);
      ListComponent<String[]> userData=(ListComponent<String[]>)dataForm.getComponent(1);
      waveVector=new double[userData.size()];
      rData=new double[userData.size()];
      error=new double[userData.size()];
      for (int i=0; i < userData.size(); i++) {
        String[] dataLine=userData.get(i);
        double waveDataPoint=Double.parseDouble(dataLine[0]);
        waveVector[i]=waveDataPoint;
        double rDataPoint=Double.parseDouble(dataLine[1]);
        rData[i]=rDataPoint;
        double errorDataPoint=Double.parseDouble(dataLine[2]);
        error[i]=errorDataPoint;
      }
      ReflectivityCalculator calculator=new ReflectivityCalculator();
      ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,false);
      ReflectivityProfile rq4Profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,true);
      double[] reflectivity=profile.reflectivity;
      double[] scatDensity=profile.scatteringDensity;
      double[] depth=profile.depth;
      double[] rq4=rq4Profile.reflectivity;
      double[] rq4Data=new double[rq4.length];
      double rChiSquare=0;
      double rq4ChiSquare=0;
      for (int i=0; i < reflectivity.length; i++) {
        double rPoint=reflectivity[i];
        double rDataPoint=rData[i];
        double rq4Point=rq4[i];
        double rq4DataPoint=rDataPoint * (Math.pow(waveVector[i],4));
        rq4Data[i]=rq4DataPoint;
        rChiSquare+=(rPoint - rDataPoint) * (rPoint - rDataPoint) / rPoint;
        rq4ChiSquare+=(rq4Point - rq4DataPoint) * (rq4Point - rq4DataPoint) / rq4Point;
      }
      ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredEntryName).setValue(Double.toString(rChiSquare));
      ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredRQ4EntryName).setValue(Double.toString(rq4ChiSquare));
      String reflectData=""String_Node_Str"";
      for (int i=0; i < reflectivity.length; i++) {
        reflectData+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(reflectivity[i])+ ""String_Node_Str""+ Double.toString(rData[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
      }
      ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
      String scatData=""String_Node_Str"";
      for (int i=0; i < depth.length; i++) {
        scatData+=Double.toString(depth[i]) + ""String_Node_Str"" + Double.toString(scatDensity[i])+ ""String_Node_Str"";
      }
      ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
      String rq4DataStr=""String_Node_Str"";
      for (int i=0; i < rq4.length; i++) {
        rq4DataStr+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(rq4[i])+ ""String_Node_Str""+ Double.toString(rq4Data[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
      }
      ByteArrayInputStream rq4Stream=new ByteArrayInputStream(rq4DataStr.getBytes());
      ResourceComponent resources=(ResourceComponent)form.getComponent(resourceCompId);
      if (resources.isEmpty()) {
        String basename=""String_Node_Str"" + form.getId() + ""String_Node_Str"";
        IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
        IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
        IFile rq4File=project.getFile(basename + ""String_Node_Str"");
        try {
          if (!reflectivityFile.exists()) {
            reflectivityFile.create(reflectStream,true,null);
          }
          if (!scatteringFile.exists()) {
            scatteringFile.create(scatStream,true,null);
          }
          if (!rq4File.exists()) {
            rq4File.create(rq4Stream,true,null);
          }
          VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
          reflectivitySource.setName(""String_Node_Str"");
          reflectivitySource.setId(1);
          reflectivitySource.setDescription(""String_Node_Str"");
          VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
          scatDensitySource.setName(""String_Node_Str"");
          scatDensitySource.setId(2);
          scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
          VizResource rq4Source=new VizResource(rq4File.getLocation().toFile());
          rq4Source.setName(""String_Node_Str"");
          rq4Source.setId(3);
          rq4Source.setDescription(""String_Node_Str"");
          resources.addResource(reflectivitySource);
          resources.addResource(scatDensitySource);
          resources.addResource(rq4Source);
        }
 catch (        CoreException|IOException e) {
          logger.error(""String_Node_Str"" + ""String_Node_Str"");
          logger.error(getClass().getName() + ""String_Node_Str"",e);
        }
      }
 else {
        try {
          VizResource reflectSource=(VizResource)resources.get(0);
          IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
          reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
          reflectSource.setName(reflectSource.getName());
          VizResource scatSource=(VizResource)resources.get(1);
          IFile scatteringFile=project.getFile(scatSource.getContents().getName());
          scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
          scatSource.setName(scatSource.getName());
          VizResource rq4Source=(VizResource)resources.get(2);
          IFile rq4File=project.getFile(rq4Source.getContents().getName());
          rq4File.setContents(new BufferedInputStream(rq4Stream),true,false,null);
          rq4Source.setName(rq4Source.getName());
        }
 catch (        CoreException|NullPointerException e) {
          logger.error(""String_Node_Str"" + ""String_Node_Str"");
          logger.error(getClass().getName() + ""String_Node_Str"",e);
          retVal=FormStatus.InfoError;
        }
      }
    }
    if (retVal == null) {
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}","/** 
 * If the action name is ReflectivityModel.processActionName, then calculates the reflectivity and scattering density profiles for the material layers and input fields.
 * @see {@link org.eclipse.ice.item.Item#process(String)}
 */
@Override public FormStatus process(String actionName){
  FormStatus retVal=FormStatus.InfoError;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    double[] waveVector;
    double[] rData;
    double[] error;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    if (!fileName.isEmpty() && project.getFile(fileName).exists()) {
      IFile userDataFile=project.getFile(fileName);
      Form dataForm=getIOService().getReader(""String_Node_Str"").read(userDataFile);
      ListComponent<String[]> userData=(ListComponent<String[]>)dataForm.getComponent(1);
      waveVector=new double[userData.size()];
      rData=new double[userData.size()];
      error=new double[userData.size()];
      for (int i=0; i < userData.size(); i++) {
        String[] dataLine=userData.get(i);
        double waveDataPoint=Double.parseDouble(dataLine[0]);
        waveVector[i]=waveDataPoint;
        double rDataPoint=Double.parseDouble(dataLine[1]);
        rData[i]=rDataPoint;
        double errorDataPoint=Double.parseDouble(dataLine[2]);
        error[i]=errorDataPoint;
      }
      ReflectivityCalculator calculator=new ReflectivityCalculator();
      ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,false);
      ReflectivityProfile rq4Profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,true);
      double[] reflectivity=profile.reflectivity;
      double[] scatDensity=profile.scatteringDensity;
      double[] depth=profile.depth;
      double[] rq4=rq4Profile.reflectivity;
      double[] rq4Data=new double[rq4.length];
      double rChiSquare=0;
      double rq4ChiSquare=0;
      for (int i=0; i < reflectivity.length; i++) {
        double rPoint=reflectivity[i];
        double rDataPoint=rData[i];
        double rq4Point=rq4[i];
        double rq4DataPoint=rDataPoint * (Math.pow(waveVector[i],4));
        rq4Data[i]=rq4DataPoint;
        rChiSquare+=(rPoint - rDataPoint) * (rPoint - rDataPoint) / rPoint;
        rq4ChiSquare+=(rq4Point - rq4DataPoint) * (rq4Point - rq4DataPoint) / rq4Point;
      }
      ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredEntryName).setValue(Double.toString(rChiSquare));
      ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredRQ4EntryName).setValue(Double.toString(rq4ChiSquare));
      String reflectData=""String_Node_Str"";
      for (int i=0; i < reflectivity.length; i++) {
        reflectData+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(reflectivity[i])+ ""String_Node_Str""+ Double.toString(rData[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
      }
      ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
      String scatData=""String_Node_Str"";
      for (int i=0; i < depth.length; i++) {
        scatData+=Double.toString(depth[i]) + ""String_Node_Str"" + Double.toString(scatDensity[i])+ ""String_Node_Str"";
      }
      ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
      String rq4DataStr=""String_Node_Str"";
      for (int i=0; i < rq4.length; i++) {
        rq4DataStr+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(rq4[i])+ ""String_Node_Str""+ Double.toString(rq4Data[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
      }
      ByteArrayInputStream rq4Stream=new ByteArrayInputStream(rq4DataStr.getBytes());
      ResourceComponent resources=(ResourceComponent)form.getComponent(resourceCompId);
      if (resources.isEmpty()) {
        String basename=""String_Node_Str"" + form.getId() + ""String_Node_Str"";
        IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
        IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
        IFile rq4File=project.getFile(basename + ""String_Node_Str"");
        try {
          if (!reflectivityFile.exists()) {
            reflectivityFile.create(reflectStream,true,null);
          }
          if (!scatteringFile.exists()) {
            scatteringFile.create(scatStream,true,null);
          }
          if (!rq4File.exists()) {
            rq4File.create(rq4Stream,true,null);
          }
          VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
          reflectivitySource.setName(""String_Node_Str"");
          reflectivitySource.setId(1);
          reflectivitySource.setDescription(""String_Node_Str"");
          VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
          scatDensitySource.setName(""String_Node_Str"");
          scatDensitySource.setId(2);
          scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
          VizResource rq4Source=new VizResource(rq4File.getLocation().toFile());
          rq4Source.setName(""String_Node_Str"");
          rq4Source.setId(3);
          rq4Source.setDescription(""String_Node_Str"");
          resources.addResource(reflectivitySource);
          resources.addResource(scatDensitySource);
          resources.addResource(rq4Source);
        }
 catch (        CoreException|IOException e) {
          logger.error(""String_Node_Str"" + ""String_Node_Str"");
          logger.error(getClass().getName() + ""String_Node_Str"",e);
        }
      }
 else {
        try {
          VizResource reflectSource=(VizResource)resources.get(0);
          IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
          reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
          reflectSource.setName(reflectSource.getName());
          VizResource scatSource=(VizResource)resources.get(1);
          IFile scatteringFile=project.getFile(scatSource.getContents().getName());
          scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
          scatSource.setName(scatSource.getName());
          VizResource rq4Source=(VizResource)resources.get(2);
          IFile rq4File=project.getFile(rq4Source.getContents().getName());
          rq4File.setContents(new BufferedInputStream(rq4Stream),true,false,null);
          rq4Source.setName(rq4Source.getName());
        }
 catch (        CoreException|NullPointerException e) {
          logger.error(""String_Node_Str"" + ""String_Node_Str"");
          logger.error(getClass().getName() + ""String_Node_Str"",e);
          retVal=FormStatus.InfoError;
          return retVal;
        }
      }
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}",0.9964847363552266
133360,"/** 
 * This operation by default returns the Actions necessary to  execute the Job Launch based on the parameters in the action  data map. Subclasses can override this method to return a custom  set of Actions.  By default, for both local and remote launches, this operation  returns an Action list that starts with copying files to the local  working directory. If local, the next Action is the Local Execution Action.  If remote, it returns the Remote File Upload, Remote Execution, and Remote  File Download Actions, in that order. 
 * @return actions List of Actions to execute. 
 */
protected List<Action> getActions(){
  List<Action> actionList=new ArrayList<Action>();
  IActionFactory actionFactory=getActionFactory();
  actionList.add(actionFactory.getAction(""String_Node_Str""));
  if (enableDocker) {
    Action dockerAction=actionFactory.getAction(""String_Node_Str"");
    dockerAction.execute(actionDataMap);
  }
  if (isLocalhost(actionDataMap.get(""String_Node_Str""))) {
    actionList.add(actionFactory.getAction(""String_Node_Str""));
  }
 else {
    System.out.println(""String_Node_Str"");
    actionList.add(actionFactory.getAction(""String_Node_Str""));
    actionList.add(actionFactory.getAction(""String_Node_Str""));
    actionList.add(actionFactory.getAction(""String_Node_Str""));
  }
  return actionList;
}","/** 
 * This operation by default returns the Actions necessary to  execute the Job Launch based on the parameters in the action  data map. Subclasses can override this method to return a custom  set of Actions.  By default, for both local and remote launches, this operation  returns an Action list that starts with copying files to the local  working directory. If local, the next Action is the Local Execution Action.  If remote, it returns the Remote File Upload, Remote Execution, and Remote  File Download Actions, in that order. 
 * @return actions List of Actions to execute. 
 */
protected List<Action> getActions(){
  List<Action> actionList=new ArrayList<Action>();
  IActionFactory actionFactory=getActionFactory();
  actionList.add(actionFactory.getAction(""String_Node_Str""));
  if (enableDocker) {
    Action dockerAction=actionFactory.getAction(""String_Node_Str"");
    dockerAction.execute(actionDataMap);
  }
  if (isLocalhost(actionDataMap.get(""String_Node_Str"")) && !enableDocker) {
    actionList.add(actionFactory.getAction(""String_Node_Str""));
  }
 else {
    System.out.println(""String_Node_Str"");
    actionList.add(actionFactory.getAction(""String_Node_Str""));
    actionList.add(actionFactory.getAction(""String_Node_Str""));
    actionList.add(actionFactory.getAction(""String_Node_Str""));
  }
  return actionList;
}",0.9936066190297104
133361,"/** 
 * Sets the name, description, and custom action name  for the item.
 */
@Override protected void setupItemInfo(){
  setName(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  allowedActions.add(0,exportString);
  writerName=""String_Node_Str"";
  readerName=""String_Node_Str"";
  outputName=""String_Node_Str"";
  exportString=""String_Node_Str"";
}","/** 
 * Sets the name, description, and custom action name  for the item.
 */
@Override protected void setupItemInfo(){
  setName(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  writerName=""String_Node_Str"";
  readerName=""String_Node_Str"";
  outputName=""String_Node_Str"";
  exportString=""String_Node_Str"";
  allowedActions.add(0,exportString);
}",0.6348314606741573
133362,"/** 
 * The function called whenever the user moves the mouse.
 * @param event The event that prompted this function's invocation.
 */
private void handleMouseMoved(MouseEvent event){
  DecimalFormat format=new DecimalFormat(""String_Node_Str"");
}","/** 
 * The function called whenever the user moves the mouse.
 * @param event The event that prompted this function's invocation.
 */
private void handleMouseMoved(MouseEvent event){
  DecimalFormat format=new DecimalFormat(""String_Node_Str"");
  cursorPosition.setText(""String_Node_Str"" + format.format(event.getPickResult().getIntersectedPoint().getX() / 3) + ""String_Node_Str""+ event.getPickResult().getIntersectedPoint().getY() / 3 + ""String_Node_Str"");
  cursorPosition.setTranslateX(scene.getWidth() / -20);
  cursorPosition.setTranslateZ(-5);
}",0.617314930991217
133363,"/** 
 * The function called whenever the mouse is dragged in Edit Mode.
 * @param event The event which prompted the invocation of this function.
 */
private void handleEditModeDrag(MouseEvent event){
  mouseOldX=mousePosX;
  mouseOldY=mousePosY;
  mousePosX=event.getX();
  mousePosY=event.getY();
  PickResult pickResult=event.getPickResult();
  Node intersectedNode=pickResult.getIntersectedNode();
  if (intersectedNode instanceof Shape3D || dragStarted) {
    dragStarted=true;
    Group nodeParent=(Group)intersectedNode.getParent();
    AbstractController modelShape=(AbstractController)nodeParent.getProperties().get(AbstractController.class);
    if (selectedVertices.contains(modelShape) || dragStarted) {
      if (vertexMarkers.isEmpty()) {
        double[] cursorLocation=((VertexController)modelShape).getTranslation();
        for (        AbstractController vertex : selectedVertices) {
          Sphere marker=new Sphere(1);
          double[] position=((VertexController)vertex).getTranslation();
          marker.setTranslateX(position[0]);
          marker.setTranslateY(position[1]);
          vertexMarkers.add(marker);
          relativeXCords.add(position[0] - cursorLocation[0]);
          relativeYCords.add(position[1] - cursorLocation[1]);
          ((FXAttachment)attachmentManager.getAttachments().get(1)).getFxNode().getChildren().add(marker);
        }
      }
      for (int i=0; i < vertexMarkers.size(); i++) {
        Sphere marker=vertexMarkers.get(i);
        marker.setTranslateX(relativeXCords.get(i) + mousePosX);
        marker.setTranslateY(relativeYCords.get(i) + mousePosY);
      }
    }
  }
}","/** 
 * The function called whenever the mouse is dragged in Edit Mode.
 * @param event The event which prompted the invocation of this function.
 */
private void handleEditModeDrag(MouseEvent event){
  mouseOldX=mousePosX;
  mouseOldY=mousePosY;
  mousePosX=event.getX();
  mousePosY=event.getY();
  PickResult pickResult=event.getPickResult();
  Node intersectedNode=pickResult.getIntersectedNode();
  dragStarted=true;
  Group nodeParent=(Group)intersectedNode.getParent();
  AbstractController modelShape=(AbstractController)nodeParent.getProperties().get(AbstractController.class);
  if (selectedVertices.contains(modelShape) || dragStarted) {
    if (vertexMarkers.isEmpty()) {
      double[] cursorLocation=((VertexController)modelShape).getTranslation();
      for (      AbstractController vertex : selectedVertices) {
        Sphere marker=new Sphere(1);
        double[] position=((VertexController)vertex).getTranslation();
        marker.setTranslateX(position[0]);
        marker.setTranslateY(position[1]);
        vertexMarkers.add(marker);
        relativeXCords.add(position[0] - cursorLocation[0]);
        relativeYCords.add(position[1] - cursorLocation[1]);
        ((FXAttachment)attachmentManager.getAttachments().get(1)).getFxNode().getChildren().add(marker);
      }
    }
    for (int i=0; i < vertexMarkers.size(); i++) {
      Sphere marker=vertexMarkers.get(i);
      double xAdjust=0;
      double yAdjust=0;
      for (      Double x : relativeXCords) {
        if (x + mousePosX + xAdjust < -16d * SCALE) {
          xAdjust=-16d * SCALE - x - mousePosX;
        }
 else         if (x + mousePosX + xAdjust > 16d * SCALE) {
          xAdjust=16d * SCALE - x - mousePosX;
        }
      }
      for (      Double y : relativeYCords) {
        if (y + mousePosY + yAdjust < -8d * SCALE) {
          yAdjust=-8d * SCALE - y - mousePosY;
        }
 else         if (y + mousePosY + yAdjust > 8d * SCALE) {
          yAdjust=8d * SCALE - y - mousePosY;
        }
      }
      marker.setTranslateX(relativeXCords.get(i) + mousePosX + xAdjust);
      marker.setTranslateY(relativeYCords.get(i) + mousePosY + yAdjust);
    }
  }
}",0.6034255599472991
133364,"/** 
 * The function called whenever the mouse button is released in Edit Mode.
 * @param event The mouse event which prompted the invocation of this function.
 */
private void handleEditModeMouseUp(MouseEvent event){
  if (dragStarted) {
    dragStarted=false;
    mouseOldX=mousePosX;
    mouseOldY=mousePosY;
    mousePosX=event.getX();
    mousePosY=event.getY();
    for (int i=0; i < selectedVertices.size(); i++) {
      VertexController vertex=(VertexController)selectedVertices.get(i);
      vertex.updateLocation((relativeXCords.get(i) + mousePosX) / SCALE,(relativeYCords.get(i) + mousePosY) / SCALE,0);
      for (      Sphere marker : vertexMarkers) {
        ((FXAttachment)attachmentManager.getAttachments().get(1)).getFxNode().getChildren().remove(marker);
      }
    }
    vertexMarkers.clear();
    relativeXCords.clear();
    relativeYCords.clear();
  }
}","/** 
 * The function called whenever the mouse button is released in Edit Mode.
 * @param event The mouse event which prompted the invocation of this function.
 */
private void handleEditModeMouseUp(MouseEvent event){
  if (dragStarted) {
    dragStarted=false;
    mouseOldX=mousePosX;
    mouseOldY=mousePosY;
    mousePosX=event.getX();
    mousePosY=event.getY();
    for (int i=0; i < selectedVertices.size(); i++) {
      VertexController vertex=(VertexController)selectedVertices.get(i);
      vertex.updateLocation(vertexMarkers.get(i).getTranslateX() / SCALE,vertexMarkers.get(i).getTranslateY() / SCALE,vertexMarkers.get(i).getTranslateZ() / SCALE);
      for (      Sphere marker : vertexMarkers) {
        ((FXAttachment)attachmentManager.getAttachments().get(1)).getFxNode().getChildren().remove(marker);
      }
    }
    vertexMarkers.clear();
    relativeXCords.clear();
    relativeYCords.clear();
  }
}",0.9025069637883008
133365,"@Override protected void updateCamera(ICamera camera){
  if (!(camera instanceof FXCameraAttachment)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  FXCameraAttachment attachment=(FXCameraAttachment)camera;
  Camera fxCamera=attachment.getFxCamera();
  if (fxCamera == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  cameraController=new TopDownCameraController(fxCamera,scene,fxCanvas);
  scene.setCamera(fxCamera);
  defaultCamera=fxCamera;
  cursorPosition=new Text();
  cursorPosition.setTranslateZ(-5);
  internalRoot.getChildren().add(cursorPosition);
}","@Override protected void updateCamera(ICamera camera){
  if (!(camera instanceof FXCameraAttachment)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  FXCameraAttachment attachment=(FXCameraAttachment)camera;
  Camera fxCamera=attachment.getFxCamera();
  if (fxCamera == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  cameraController=new TopDownCameraController(fxCamera,scene,fxCanvas);
  scene.setCamera(fxCamera);
  defaultCamera=fxCamera;
  cursorPosition=new Text();
  cursorPosition.setTranslateZ(-5);
  internalRoot.getChildren().add(cursorPosition);
  BorderPane pane=new BorderPane();
  internalRoot.getChildren().add(pane);
}",0.9404388714733544
133366,"/** 
 * The default constructor.
 * @param camera The camera this controller will manage.
 * @param scene The scene the camera is viewing.
 * @param canvas The FXCanvas containing the scene.
 */
public AbstractCameraController(Camera camera,Scene scene,FXCanvas canvas){
  this.camera=camera;
  this.scene=scene;
  this.canvas=canvas;
  xform=new Group();
  xform.getChildren().add(camera);
  affine=new Affine();
  xform.getTransforms().setAll(affine);
  defaultX=new Rotate();
  defaultY=new Rotate();
  defaultZ=new Rotate();
  defaultX.setAxis(Rotate.X_AXIS);
  defaultY.setAxis(Rotate.Y_AXIS);
  defaultZ.setAxis(Rotate.Z_AXIS);
  reset();
  scene.setOnKeyPressed(new EventHandler<KeyEvent>(){
    @Override public void handle(    KeyEvent event){
      handleKeyPressed(event);
    }
  }
);
  scene.setOnMousePressed(new EventHandler<MouseEvent>(){
    @Override public void handle(    MouseEvent arg0){
      handleMousePressed(arg0);
    }
  }
);
  scene.setOnMouseDragged(new EventHandler<MouseEvent>(){
    @Override public void handle(    MouseEvent arg0){
      handleMouseDragged(arg0);
    }
  }
);
  scene.setOnScroll(new EventHandler<ScrollEvent>(){
    @Override public void handle(    ScrollEvent event){
      handleMouseScroll(event);
    }
  }
);
}","/** 
 * The default constructor.
 * @param camera The camera this controller will manage.
 * @param scene The scene the camera is viewing.
 * @param canvas The FXCanvas containing the scene.
 */
public AbstractCameraController(Camera camera,Scene scene,FXCanvas canvas){
  this.camera=camera;
  this.scene=scene;
  this.canvas=canvas;
  xform=new Group();
  xform.getChildren().add(camera);
  affine=new Affine();
  xform.getTransforms().setAll(affine);
  defaultX=new Rotate();
  defaultY=new Rotate();
  defaultZ=new Rotate();
  defaultX.setAxis(Rotate.X_AXIS);
  defaultY.setAxis(Rotate.Y_AXIS);
  defaultZ.setAxis(Rotate.Z_AXIS);
  reset();
  scene.setOnKeyPressed(new EventHandler<KeyEvent>(){
    @Override public void handle(    KeyEvent event){
      handleKeyPressed(event);
    }
  }
);
  scene.setOnMousePressed(new EventHandler<MouseEvent>(){
    @Override public void handle(    MouseEvent arg0){
      handleMousePressed(arg0);
    }
  }
);
  scene.setOnMouseDragged(new EventHandler<MouseEvent>(){
    @Override public void handle(    MouseEvent arg0){
      handleMouseDragged(arg0);
    }
  }
);
  scene.setOnMouseReleased(new EventHandler<MouseEvent>(){
    @Override public void handle(    MouseEvent arg0){
      handleMouseReleased(arg0);
    }
  }
);
  scene.setOnScroll(new EventHandler<ScrollEvent>(){
    @Override public void handle(    ScrollEvent event){
      handleMouseScroll(event);
    }
  }
);
}",0.9406968124536694
133367,"/** 
 * The default constructor.
 * @param camera The camera this controller will manage.
 * @param scene The scene the camera is viewing.
 * @param canvas The FXCanvas containing the scene.
 */
public CenteredCameraController(Camera camera,Scene scene,FXCanvas canvas){
  super(camera,scene,canvas);
  x=new Rotate();
  x.setAxis(Rotate.X_AXIS);
  xform.getTransforms().add(x);
  y=new Rotate();
  y.setAxis(Rotate.Y_AXIS);
  z=new Rotate();
  z.setAxis(Rotate.Z_AXIS);
  xform.getTransforms().setAll(x,y,z,affine);
}","/** 
 * The default constructor.
 * @param camera The camera this controller will manage.
 * @param scene The scene the camera is viewing.
 * @param canvas The FXCanvas containing the scene.
 */
public CenteredCameraController(Camera camera,Scene scene,FXCanvas canvas){
  super(camera,scene,canvas);
  dragStarted=false;
  x=new Rotate();
  x.setAxis(Rotate.X_AXIS);
  xform.getTransforms().add(x);
  y=new Rotate();
  y.setAxis(Rotate.Y_AXIS);
  z=new Rotate();
  z.setAxis(Rotate.Z_AXIS);
  xform.getTransforms().setAll(x,y,z,affine);
}",0.9801324503311258
133368,"@Override public void handleMouseDragged(MouseEvent event){
  mouseOldX=mousePosX;
  mouseOldY=mousePosY;
  mousePosX=event.getSceneX();
  mousePosY=event.getSceneY();
  mouseDeltaX=(mousePosX - mouseOldX);
  mouseDeltaY=(mousePosY - mouseOldY);
  if (event.isPrimaryButtonDown()) {
    y.setAngle(y.getAngle() - mouseDeltaX);
    x.setAngle(x.getAngle() + mouseDeltaY);
  }
}","@Override public void handleMouseDragged(MouseEvent event){
  mouseOldX=mousePosX;
  mouseOldY=mousePosY;
  mousePosX=event.getSceneX();
  mousePosY=event.getSceneY();
  if (dragStarted) {
    mouseDeltaX=(mousePosX - mouseOldX);
    mouseDeltaY=(mousePosY - mouseOldY);
    if (event.isPrimaryButtonDown()) {
      y.setAngle(y.getAngle() - mouseDeltaX);
      x.setAngle(x.getAngle() + mouseDeltaY);
    }
  }
 else {
    dragStarted=true;
  }
}",0.913730255164034
133369,"/** 
 * Takes all of the information from the wizard pages and uses it to create the plugin and java classes.
 * @return whether the project generation was successful
 */
@Override public boolean performFinish(){
  boolean successful=false;
  try {
    fProjectPage.updateData();
    fContentPage.updateData();
    IDialogSettings settings=getDialogSettings();
    if (settings != null) {
      fProjectPage.saveSettings(settings);
      fContentPage.saveSettings(settings);
    }
    fTemplateWizard.setTemplateExtension(fProjectPage.getProjectName());
    BasicNewProjectResourceWizard.updatePerspective(fConfig);
    if (!PDECore.getDefault().areModelsInitialized()) {
      try {
        getContainer().run(true,true,new IRunnableWithProgress(){
          public void run(          IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
            PDECore.getDefault().getModelManager().targetReloaded(monitor);
            if (monitor.isCanceled()) {
              throw new InterruptedException();
            }
          }
        }
);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    getContainer().run(false,true,new NewProjectCreationOperation(fPluginData,fProjectProvider,fTemplateWizard));
    IWorkingSet[] workingSets=fProjectPage.getSelectedWorkingSets();
    if (workingSets.length > 0)     getWorkbench().getWorkingSetManager().addToWorkingSets(fProjectProvider.getProject(),workingSets);
    setNature(fProjectProvider.getProject());
    setPackageLayout();
    addPackageImports();
    fProjectProvider.getProject().refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
    successful=true;
  }
 catch (  InvocationTargetException e) {
    PDEPlugin.logException(e);
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  CoreException e) {
    e.printStackTrace();
  }
  return successful;
}","/** 
 * Takes all of the information from the wizard pages and uses it to create the plugin and java classes.
 * @return whether the project generation was successful
 */
@Override public boolean performFinish(){
  boolean successful=false;
  try {
    fProjectPage.updateData();
    fContentPage.updateData();
    IDialogSettings settings=getDialogSettings();
    if (settings != null) {
      fProjectPage.saveSettings(settings);
      fContentPage.saveSettings(settings);
    }
    fTemplateWizard.setTemplateExtension(fProjectPage.getProjectName());
    BasicNewProjectResourceWizard.updatePerspective(fConfig);
    if (!PDECore.getDefault().areModelsInitialized()) {
      try {
        getContainer().run(true,true,new IRunnableWithProgress(){
          public void run(          IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
            PDECore.getDefault().getModelManager().targetReloaded(monitor);
            if (monitor.isCanceled()) {
              throw new InterruptedException();
            }
          }
        }
);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    getContainer().run(false,true,new NewProjectCreationOperation(fPluginData,fProjectProvider,fTemplateWizard));
    IWorkingSet[] workingSets=fProjectPage.getSelectedWorkingSets();
    if (workingSets.length > 0)     getWorkbench().getWorkingSetManager().addToWorkingSets(fProjectProvider.getProject(),workingSets);
    setNature(fProjectProvider.getProject());
    setPackageLayout();
    updateManifest();
    fProjectProvider.getProject().refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
    successful=true;
  }
 catch (  InvocationTargetException e) {
    PDEPlugin.logException(e);
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  CoreException e) {
    e.printStackTrace();
  }
  return successful;
}",0.9920246977103164
133370,"/** 
 * Use this method to process the data that has been  specified in the form.  Data being processed should be written usint 
 * @param actionName
 * @return
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.ReadyToProcess;
  if (writerName == ""String_Node_Str"" || outputName == ""String_Node_Str"") {
    return FormStatus.InfoError;
  }
  if (actionName == exportString) {
    IWriter writer=ioService.getWriter(writerName);
    try {
      retStatus=FormStatus.Processing;
      writer.write(form,outputName);
      project.refreshLocal(IResource.DEPTH_ONE,null);
      retStatus=FormStatus.Processed;
    }
 catch (    CoreException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
 else {
    retStatus=super.process(actionName);
  }
  return retStatus;
}","/** 
 * Use this method to process the data that has been  specified in the form.  Data being processed should be written usint 
 * @param actionName
 * @return
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.ReadyToProcess;
  if (writerName == ""String_Node_Str"" || outputName == ""String_Node_Str"") {
    return FormStatus.InfoError;
  }
  if (actionName == exportString) {
    IFile outputFile=project.getFile(outputName);
    writer=ioService.getWriter(writerName);
    try {
      retStatus=FormStatus.Processing;
      writer.write(form,outputFile);
      project.refreshLocal(1,null);
      retStatus=FormStatus.Processed;
    }
 catch (    CoreException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
 else {
    retStatus=super.process(actionName);
  }
  return retStatus;
}",0.8524203069657615
133371,"public $className$Model(IProject project){
  super(project);
  exportString=""String_Node_Str"";
  writerName=""String_Node_Str"";
  readerName=""String_Node_Str"";
  outputName=""String_Node_Str"";
}","public $className$Model(IProject project){
  super(project);
  exportString=""String_Node_Str"";
}",0.6666666666666666
133372,"/** 
 * Check that files are populated in the allowed values list. 
 */
@Test public void checkAllowedValues(){
  FileEntry entry=new FileEntry();
  entry.setProject(project);
  assertEquals(15,entry.getAllowedValues().size());
  FileEntry yamlFiles=new FileEntry(""String_Node_Str"");
  yamlFiles.setProject(project);
  assertEquals(3,yamlFiles.getAllowedValues().size());
  IFile file=project.getFile(""String_Node_Str"");
  try {
    file.create(new ByteArrayInputStream(new String(""String_Node_Str"").getBytes()),true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  entry.updateAvailableFiles();
  assertEquals(16,entry.getAllowedValues().size());
  try {
    file.delete(true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
}","/** 
 * Check that files are populated in the allowed values list. 
 */
@Test public void checkAllowedValues(){
  FileEntry entry=new FileEntry();
  entry.setProject(project);
  assertEquals(13,entry.getAllowedValues().size());
  FileEntry yamlFiles=new FileEntry(""String_Node_Str"");
  yamlFiles.setProject(project);
  assertEquals(3,yamlFiles.getAllowedValues().size());
  IFile file=project.getFile(""String_Node_Str"");
  try {
    file.create(new ByteArrayInputStream(new String(""String_Node_Str"").getBytes()),true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  entry.updateAvailableFiles();
  assertEquals(14,entry.getAllowedValues().size());
  try {
    file.delete(true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
}",0.9974779319041616
133373,"@Override public ITemplateSection[] createTemplateSections(){
  return new ITemplateSection[]{new ICEItemTemplate()};
}","@Override public ITemplateSection[] createTemplateSections(){
  templateSections=new ITemplateSection[]{new ICEItemTemplate()};
  return templateSections;
}",0.8363636363636363
133374,"/** 
 * Sets the package layout to be as specified in the wizard.
 */
private void setPackageLayout(){
  String sep=System.getProperty(""String_Node_Str"");
  String[] packageHierarchy=fProjectProvider.getProjectName().split(""String_Node_Str"");
  String projectSrcPath=fProjectProvider.getLocationPath().makeAbsolute().toOSString() + sep + fProjectProvider.getProjectName()+ sep+ fPluginData.getSourceFolderName();
  File[] projectSrcs=new File(projectSrcPath).listFiles();
  File modelDir=new File(projectSrcPath + sep + String.join(sep,packageHierarchy)+ sep+ ""String_Node_Str"");
  File launcherDir=new File(projectSrcPath + sep + String.join(sep,packageHierarchy)+ sep+ ""String_Node_Str"");
  try {
    modelDir.mkdirs();
    launcherDir.mkdirs();
    for (    File f : projectSrcs) {
      if (f.getName().endsWith(""String_Node_Str"") || f.getName().endsWith(""String_Node_Str"")) {
        Files.move(f.toPath(),(new File(launcherDir.getAbsolutePath() + sep + f.getName())).toPath(),REPLACE_EXISTING);
      }
 else       if (f.getName().endsWith(""String_Node_Str"") || f.getName().endsWith(""String_Node_Str"")) {
        Files.move(f.toPath(),(new File(modelDir.getAbsolutePath() + sep + f.getName())).toPath(),REPLACE_EXISTING);
      }
    }
    fProjectProvider.getProject().refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
  }
catch (  CoreException ce) {
    ce.printStackTrace();
  }
}","/** 
 * Sets the package layout to be as specified in the wizard.
 */
private void setPackageLayout(){
  String sep=System.getProperty(""String_Node_Str"");
  String[] packageHierarchy=fProjectProvider.getProjectName().split(""String_Node_Str"");
  String projectSrcPath=fProjectProvider.getLocationPath().makeAbsolute().toOSString() + sep + fProjectProvider.getProjectName()+ sep+ fPluginData.getSourceFolderName();
  File[] projectSrcs=new File(projectSrcPath).listFiles();
  File modelDir=new File(projectSrcPath + sep + String.join(sep,packageHierarchy)+ sep+ ""String_Node_Str"");
  File launcherDir=new File(projectSrcPath + sep + String.join(sep,packageHierarchy)+ sep+ ""String_Node_Str"");
  try {
    modelDir.mkdirs();
    launcherDir.mkdirs();
    for (    File f : projectSrcs) {
      if (f.getName().endsWith(""String_Node_Str"") || f.getName().endsWith(""String_Node_Str"")) {
        Files.move(f.toPath(),(new File(launcherDir.getAbsolutePath() + sep + f.getName())).toPath(),REPLACE_EXISTING);
      }
 else       if (f.getName().endsWith(""String_Node_Str"") || f.getName().endsWith(""String_Node_Str"")) {
        Files.move(f.toPath(),(new File(modelDir.getAbsolutePath() + sep + f.getName())).toPath(),REPLACE_EXISTING);
      }
    }
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
  }
}",0.9426613775694194
133375,"/** 
 * Creates and adds the pages to the wizard. Three pages are created.
 */
@Override public void addPages(){
  WizardElement templateWizardElement=getTemplateWizard();
  fProjectPage=new NewProjectCreationFromTemplatePage(""String_Node_Str"",fPluginData,getSelection(),templateWizardElement);
  fProjectPage.setTitle(WIZARD_TITLE);
  fProjectPage.setDescription(DESCRIPTION);
  String projectName=getDefaultValue(DEF_PROJECT_NAME);
  if (projectName != null)   fProjectPage.setInitialProjectName(projectName);
  addPage(fProjectPage);
  fProjectProvider=new IProjectProvider(){
    public String getProjectName(){
      return fProjectPage.getProjectName();
    }
    public IProject getProject(){
      return fProjectPage.getProjectHandle();
    }
    public IPath getLocationPath(){
      return fProjectPage.getLocationPath();
    }
  }
;
  fContentPage=new PluginContentPage(""String_Node_Str"",fProjectProvider,fProjectPage,fPluginData);
  addPage(fContentPage);
  try {
    fTemplateWizard=(ICEItemWizard)templateWizardElement.createExecutableExtension();
    fTemplateWizard.init(fPluginData);
    fTemplateWizard.addPages();
    IWizardPage[] pages=fTemplateWizard.getPages();
    for (int i=0; i < pages.length; i++) {
      addPage(pages[i]);
    }
  }
 catch (  CoreException e) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Creates and adds the pages to the wizard. Three pages are created.
 */
@Override public void addPages(){
  WizardElement templateWizardElement=getTemplateWizard();
  fProjectPage=new NewProjectCreationFromTemplatePage(""String_Node_Str"",fPluginData,getSelection(),templateWizardElement);
  fProjectPage.setTitle(WIZARD_TITLE);
  fProjectPage.setDescription(DESCRIPTION);
  String projectName=getDefaultValue(DEF_PROJECT_NAME);
  if (projectName != null)   fProjectPage.setInitialProjectName(projectName);
  addPage(fProjectPage);
  fProjectProvider=new IProjectProvider(){
    public String getProjectName(){
      return fProjectPage.getProjectName();
    }
    public IProject getProject(){
      return fProjectPage.getProjectHandle();
    }
    public IPath getLocationPath(){
      return fProjectPage.getLocationPath();
    }
  }
;
  fContentPage=new PluginContentPage(""String_Node_Str"",fProjectProvider,fProjectPage,fPluginData);
  addPage(fContentPage);
  try {
    fTemplateWizard=(ICEItemWizard)templateWizardElement.createExecutableExtension();
    fTemplateWizard.init(fPluginData);
    fTemplateWizard.addPages();
    IWizardPage[] pages=fTemplateWizard.getPages();
    for (int i=0; i < pages.length; i++) {
      addPage(pages[i]);
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
}",0.990764684152198
133376,"/** 
 * Takes all of the information from the wizard pages and uses it to create the plugin and java classes.
 * @return whether the project generation was successful
 */
@Override public boolean performFinish(){
  boolean successful=false;
  try {
    fProjectPage.updateData();
    fContentPage.updateData();
    IDialogSettings settings=getDialogSettings();
    if (settings != null) {
      fProjectPage.saveSettings(settings);
      fContentPage.saveSettings(settings);
    }
    BasicNewProjectResourceWizard.updatePerspective(fConfig);
    if (!PDECore.getDefault().areModelsInitialized()) {
      try {
        getContainer().run(true,true,new IRunnableWithProgress(){
          public void run(          IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
            PDECore.getDefault().getModelManager().targetReloaded(monitor);
            if (monitor.isCanceled()) {
              throw new InterruptedException();
            }
          }
        }
);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    getContainer().run(false,true,new NewProjectCreationOperation(fPluginData,fProjectProvider,fTemplateWizard));
    IWorkingSet[] workingSets=fProjectPage.getSelectedWorkingSets();
    if (workingSets.length > 0)     getWorkbench().getWorkingSetManager().addToWorkingSets(fProjectProvider.getProject(),workingSets);
    setNature(fProjectProvider.getProject());
    setPackageLayout();
    successful=true;
  }
 catch (  InvocationTargetException e) {
    PDEPlugin.logException(e);
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  CoreException e) {
    e.printStackTrace();
  }
  return successful;
}","/** 
 * Takes all of the information from the wizard pages and uses it to create the plugin and java classes.
 * @return whether the project generation was successful
 */
@Override public boolean performFinish(){
  boolean successful=false;
  try {
    fProjectPage.updateData();
    fContentPage.updateData();
    IDialogSettings settings=getDialogSettings();
    if (settings != null) {
      fProjectPage.saveSettings(settings);
      fContentPage.saveSettings(settings);
    }
    fTemplateWizard.setTemplateExtension(fProjectPage.getProjectName());
    BasicNewProjectResourceWizard.updatePerspective(fConfig);
    if (!PDECore.getDefault().areModelsInitialized()) {
      try {
        getContainer().run(true,true,new IRunnableWithProgress(){
          public void run(          IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
            PDECore.getDefault().getModelManager().targetReloaded(monitor);
            if (monitor.isCanceled()) {
              throw new InterruptedException();
            }
          }
        }
);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    getContainer().run(false,true,new NewProjectCreationOperation(fPluginData,fProjectProvider,fTemplateWizard));
    IWorkingSet[] workingSets=fProjectPage.getSelectedWorkingSets();
    if (workingSets.length > 0)     getWorkbench().getWorkingSetManager().addToWorkingSets(fProjectProvider.getProject(),workingSets);
    setNature(fProjectProvider.getProject());
    setPackageLayout();
    addPackageImports();
    fProjectProvider.getProject().refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
    successful=true;
  }
 catch (  InvocationTargetException e) {
    PDEPlugin.logException(e);
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  CoreException e) {
    e.printStackTrace();
  }
  return successful;
}",0.9463705308775732
133377,"@Override public FormStatus process(String actionName){
}","@Override public FormStatus process(String actionName){
  return null;
}",0.8837209302325582
133378,"@Override public Item getInstance(IProject projectSpace){
  Item item=new $className$(projectSpace);
  item.setItemBuilderName(this.getItemName());
  return item;
}","@Override public Item getInstance(IProject projectSpace){
  Item item=new $className$Launcher(projectSpace);
  item.setItemBuilderName(this.getItemName());
  return item;
}",0.9761904761904762
133379,"@Override public FormStatus process(String actionName){
}","@Override public FormStatus process(String actionName){
  return null;
}",0.8837209302325582
133380,"@Override protected FormStatus reviewEntries(Form preparedForm){
}","@Override protected FormStatus reviewEntries(Form preparedForm){
  return null;
}",0.8979591836734694
133381,"@Override public Item getInstance(IProject projectSpace){
  Item item=new $className$(projectSpace);
  item.setItemBuilderName(this.getItemName());
  return item;
}","@Override public Item getInstance(IProject projectSpace){
  Item item=new $className$Model(projectSpace);
  item.setItemBuilderName(this.getItemName());
  return item;
}",0.984984984984985
133382,"@Override public Object clone(){
  PointMesh clone=new PointMesh();
  clone.copy(this);
  return clone;
}","@Override public Object clone(){
  VertexMesh clone=new VertexMesh();
  clone.copy(this);
  return clone;
}",0.9150943396226416
133383,"/** 
 * A private utility used for deleting a range of lines in a text file.
 * @param filename
 * @param startline
 * @param numlines
 */
private void deleteLines(String filename,int startline,int numlines){
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    StringBuffer sb=new StringBuffer(""String_Node_Str"");
    int linenumber=1;
    String line;
    while ((line=br.readLine()) != null) {
      if (linenumber < startline || linenumber >= startline + numlines) {
        sb.append(line + ""String_Node_Str"");
      }
      linenumber++;
    }
    if (startline + numlines > linenumber) {
      logger.info(""String_Node_Str"");
    }
    br.close();
    FileWriter fw=new FileWriter(new File(filename));
    fw.write(sb.toString());
    fw.close();
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
}","/** 
 * A private utility used for deleting a range of lines in a text file.
 * @param filename
 * @param startline
 * @param numlines
 */
private void deleteLines(IFile file,int startline,int numlines){
  try {
    BufferedReader br=new BufferedReader(new InputStreamReader(file.getContents()));
    StringBuffer sb=new StringBuffer(""String_Node_Str"");
    int linenumber=1;
    String line;
    while ((line=br.readLine()) != null) {
      if (linenumber < startline || linenumber >= startline + numlines) {
        sb.append(line + ""String_Node_Str"");
      }
      linenumber++;
    }
    if (startline + numlines > linenumber) {
      logger.info(""String_Node_Str"");
    }
    br.close();
    FileWriter fw=new FileWriter(file.getLocation().toFile());
    fw.write(sb.toString());
    fw.close();
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
}",0.9498591549295776
133384,"/** 
 * This operation loads the contents of the TreeComposite from the MOOSE data. It is called when a MOOSE-based application has been accepted and the entries are reviewed. It will only load the Form if the project space exists - so that it can find the files - and if the Form has been previously configured. It compares the executable name passed to this function with the files in the project directory and looks for a match with the name ""executuableName.yaml"" that it can load. It throws an IOException if it cannot find a match.
 * @param mooseExecutableName The name of the MOOSE executable whose YAML input specification should be loaded into the Form's TreeComposite.
 * @throws IOException
 * @throws CoreException
 */
protected void loadTreeContents(String mooseExecutableName) throws IOException, CoreException {
  TreeComposite mooseParentTree=(TreeComposite)form.getComponent(mooseTreeCompositeId), tmpParentTree;
  if (project != null && project.isAccessible()) {
    IFolder mooseFolder=project.getFolder(""String_Node_Str"");
    if (!mooseFolder.exists()) {
      mooseFolder.create(true,true,null);
    }
    URI uri=URI.create(mooseExecutableName);
    IFile yamlFile=null, syntaxFile=null;
    if (""String_Node_Str"".equals(uri.getScheme())) {
      IRemoteConnection remoteConnection=getRemoteConnectionReference(uri.getHost());
      if (remoteConnection != null) {
        Action generator=getActionFactory().getAction(""String_Node_Str"");
        Dictionary<String,String> map=new Hashtable<String,String>();
        map.put(""String_Node_Str"",mooseFolder.getLocation().toOSString());
        map.put(""String_Node_Str"",uri.getRawPath());
        map.put(""String_Node_Str"",uri.getHost());
        generator.execute(map);
      }
      String animal=Paths.get(uri.getRawPath()).getFileName().toString();
      refreshProjectSpace();
      yamlFile=mooseFolder.getFile(animal + ""String_Node_Str"");
      syntaxFile=mooseFolder.getFile(animal + ""String_Node_Str"");
    }
 else {
      File execFile=new File(uri);
      yamlFile=mooseFolder.getFile(execFile.getName().toLowerCase() + ""String_Node_Str"");
      syntaxFile=mooseFolder.getFile(execFile.getName().toLowerCase() + ""String_Node_Str"");
      String[] yamlCmd={""String_Node_Str"",""String_Node_Str"",execFile.getAbsolutePath() + ""String_Node_Str"" + yamlFile.getLocation().toOSString()};
      String[] syntaxCmd={""String_Node_Str"",""String_Node_Str"",execFile.getAbsolutePath() + ""String_Node_Str"" + syntaxFile.getLocation().toOSString()};
      Process p1=Runtime.getRuntime().exec(yamlCmd);
      Process p2=Runtime.getRuntime().exec(syntaxCmd);
      try {
        int code1=p1.waitFor();
        int code2=p2.waitFor();
        if (code1 != 0 || code2 != 0) {
          throw new Exception(""String_Node_Str"" + code1 + ""String_Node_Str""+ code2);
        }
      }
 catch (      Exception e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
    createCleanMOOSEFile(yamlFile.getLocation().toOSString());
    createCleanMOOSEFile(syntaxFile.getLocation().toOSString());
    refreshProjectSpace();
    IReader.getIReaders();
    IReader reader=getReader();
    if (yamlFile.exists() && syntaxFile.exists() && reader != null) {
      Form readerForm=reader.read(yamlFile);
      tmpParentTree=(TreeComposite)readerForm.getComponent(mooseTreeCompositeId);
      mooseParentTree.copy(tmpParentTree);
    }
 else {
      throw new IOException(""String_Node_Str"" + yamlFile.getName() + ""String_Node_Str""+ syntaxFile.getName()+ ""String_Node_Str"");
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  return;
}","/** 
 * This operation loads the contents of the TreeComposite from the MOOSE data. It is called when a MOOSE-based application has been accepted and the entries are reviewed. It will only load the Form if the project space exists - so that it can find the files - and if the Form has been previously configured. It compares the executable name passed to this function with the files in the project directory and looks for a match with the name ""executuableName.yaml"" that it can load. It throws an IOException if it cannot find a match.
 * @param mooseExecutableName The name of the MOOSE executable whose YAML input specification should be loaded into the Form's TreeComposite.
 * @throws IOException
 * @throws CoreException
 */
protected void loadTreeContents(String mooseExecutableName) throws IOException, CoreException {
  TreeComposite mooseParentTree=(TreeComposite)form.getComponent(mooseTreeCompositeId), tmpParentTree;
  if (project != null && project.isAccessible()) {
    IFolder mooseFolder=project.getFolder(""String_Node_Str"");
    if (!mooseFolder.exists()) {
      mooseFolder.create(true,true,null);
    }
    URI uri=URI.create(mooseExecutableName);
    IFile yamlFile=null, syntaxFile=null;
    if (""String_Node_Str"".equals(uri.getScheme())) {
      IRemoteConnection remoteConnection=getRemoteConnectionReference(uri.getHost());
      if (remoteConnection != null) {
        Action generator=getActionFactory().getAction(""String_Node_Str"");
        Dictionary<String,String> map=new Hashtable<String,String>();
        map.put(""String_Node_Str"",mooseFolder.getLocation().toOSString());
        map.put(""String_Node_Str"",uri.getRawPath());
        map.put(""String_Node_Str"",uri.getHost());
        generator.execute(map);
      }
      String animal=Paths.get(uri.getRawPath()).getFileName().toString();
      refreshProjectSpace();
      yamlFile=mooseFolder.getFile(animal + ""String_Node_Str"");
      syntaxFile=mooseFolder.getFile(animal + ""String_Node_Str"");
    }
 else {
      File execFile=new File(uri);
      yamlFile=mooseFolder.getFile(execFile.getName().toLowerCase() + ""String_Node_Str"");
      syntaxFile=mooseFolder.getFile(execFile.getName().toLowerCase() + ""String_Node_Str"");
      String[] yamlCmd={""String_Node_Str"",""String_Node_Str"",execFile.getAbsolutePath() + ""String_Node_Str"" + yamlFile.getLocation().toOSString().replaceAll(""String_Node_Str"",""String_Node_Str"")};
      String[] syntaxCmd={""String_Node_Str"",""String_Node_Str"",execFile.getAbsolutePath() + ""String_Node_Str"" + syntaxFile.getLocation().toOSString().replaceAll(""String_Node_Str"",""String_Node_Str"")};
      Process p1=Runtime.getRuntime().exec(yamlCmd);
      Process p2=Runtime.getRuntime().exec(syntaxCmd);
      try {
        int code1=p1.waitFor();
        int code2=p2.waitFor();
        if (code1 != 0 || code2 != 0) {
          throw new Exception(""String_Node_Str"" + code1 + ""String_Node_Str""+ code2);
        }
      }
 catch (      Exception e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
    createCleanMOOSEFile(yamlFile.getName());
    createCleanMOOSEFile(syntaxFile.getName());
    refreshProjectSpace();
    IReader.getIReaders();
    IReader reader=getReader();
    if (yamlFile.exists() && syntaxFile.exists() && reader != null) {
      Form readerForm=reader.read(yamlFile);
      tmpParentTree=(TreeComposite)readerForm.getComponent(mooseTreeCompositeId);
      mooseParentTree.copy(tmpParentTree);
    }
 else {
      throw new IOException(""String_Node_Str"" + yamlFile.getName() + ""String_Node_Str""+ syntaxFile.getName()+ ""String_Node_Str"");
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  return;
}",0.9800382827454196
133385,"/** 
 * This method is intended to take a filePath corresponding to a MOOSE YAML or action syntax file, and remove any extraneous header or footer lines that aren't valid syntax. If any lines from the file were removed, it re-writes the file. If no changes were made (no header/footer to remove), it does nothing.
 * @param filePath The filepath to the YAML or action syntax file.
 * @throws IOException
 * @throws CoreException
 */
private void createCleanMOOSEFile(String filePath) throws IOException, CoreException {
  String fileExt, fileType=null;
  boolean hasHeader=false, hasFooter=false;
  int headerLine=0, footerLine=0;
  String separator=System.getProperty(""String_Node_Str"");
  ArrayList<String> fileLines;
  IFolder mooseFolder=project.getFolder(""String_Node_Str"");
  if (!mooseFolder.exists()) {
    mooseFolder.create(true,true,null);
  }
  fileExt=filePath.substring(filePath.lastIndexOf(""String_Node_Str""));
  if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else {
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + fileExt);
  }
  java.nio.file.Path readPath=Paths.get(filePath);
  fileLines=(ArrayList<String>)Files.readAllLines(readPath,Charset.defaultCharset());
  String header=""String_Node_Str"" + fileType + ""String_Node_Str"";
  String footer=""String_Node_Str"" + fileType + ""String_Node_Str"";
  hasHeader=fileLines.contains(header);
  hasFooter=fileLines.contains(footer);
  if (hasFooter) {
    footerLine=fileLines.indexOf(footer);
    deleteLines(filePath,footerLine,fileLines.size() - footerLine + 1);
  }
  if (hasHeader) {
    headerLine=fileLines.indexOf(header);
    deleteLines(filePath,1,headerLine + 1);
  }
  return;
}","/** 
 * This method is intended to take a filePath corresponding to a MOOSE YAML or action syntax file, and remove any extraneous header or footer lines that aren't valid syntax. If any lines from the file were removed, it re-writes the file. If no changes were made (no header/footer to remove), it does nothing.
 * @param filePath The filepath to the YAML or action syntax file.
 * @throws IOException
 * @throws CoreException
 */
private void createCleanMOOSEFile(String fileName) throws IOException, CoreException {
  String fileExt, fileType=null;
  boolean hasHeader=false, hasFooter=false;
  int headerLine=0, footerLine=0;
  String line=""String_Node_Str"";
  ArrayList<String> fileLines=new ArrayList<String>();
  IFolder mooseFolder=project.getFolder(""String_Node_Str"");
  refreshProjectSpace();
  if (!mooseFolder.exists()) {
    mooseFolder.create(true,true,null);
  }
  fileExt=fileName.substring(fileName.lastIndexOf(""String_Node_Str""));
  if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else {
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + fileExt);
  }
  IFile file=mooseFolder.getFile(fileName);
  BufferedReader reader=new BufferedReader(new InputStreamReader(file.getContents()));
  while ((line=reader.readLine()) != null) {
    fileLines.add(line);
  }
  String header=""String_Node_Str"" + fileType + ""String_Node_Str"";
  String footer=""String_Node_Str"" + fileType + ""String_Node_Str"";
  hasHeader=fileLines.contains(header);
  hasFooter=fileLines.contains(footer);
  if (hasFooter) {
    footerLine=fileLines.indexOf(footer);
    deleteLines(file,footerLine,fileLines.size() - footerLine + 1);
    refreshProjectSpace();
  }
  if (hasHeader) {
    headerLine=fileLines.indexOf(header);
    deleteLines(file,1,headerLine + 1);
    refreshProjectSpace();
  }
  return;
}",0.8241996744438416
133386,"/** 
 * Check that an Extrema is constructed correctly.
 */
@Test public void checkConstruction(){
  Extrema first=new Extrema(-1d,0d,-0.5d,0.5d,0d,1d);
  assertTrue(first.getMinX() == -1d);
  assertTrue(first.getMinY() == -0.5d);
  assertTrue(first.getMaxY() == 0.5d);
  assertTrue(first.getMaxZ() == 1d);
  Extrema second=new Extrema(0d,1d,-1d,0d,-0.5d,0.5d);
  assertTrue(second.getMinY() == -1d);
  assertTrue(second.getMinZ() == -0.5d);
  assertTrue(second.getMaxZ() == 0.5d);
  assertTrue(second.getMaxX() == 1d);
  Extrema third=new Extrema(-0.5d,0.5d,0d,1d,-1d,0d);
  assertTrue(third.getMinZ() == -1d);
  assertTrue(third.getMinX() == -0.5d);
  assertTrue(third.getMaxX() == 0.5d);
  assertTrue(third.getMaxY() == 1d);
  ArrayList<Extrema> extrema=new ArrayList<Extrema>();
  extrema.add(first);
  extrema.add(second);
  extrema.add(third);
  Extrema all=new Extrema(extrema);
  assertTrue(all.getMinX() == -1d);
  assertTrue(all.getMaxX() == 1d);
  assertTrue(all.getMinY() == -1d);
  assertTrue(all.getMaxY() == 1d);
  assertTrue(all.getMinZ() == -1d);
  assertTrue(all.getMaxZ() == 1d);
}","/** 
 * Check that an Extrema is constructed correctly.
 */
@Test public void checkConstruction(){
  Extrema first=new Extrema(-1d,0d,-0.5d,0.5d,0d,1d);
  assertTrue(first.getMinX() == -1d);
  assertTrue(first.getMinY() == -0.5d);
  assertTrue(first.getMaxY() == 0.5d);
  assertTrue(first.getMaxZ() == 1d);
  Extrema second=new Extrema(0d,1d,-1d,0d,-0.5d,0.5d);
  assertTrue(second.getMinY() == -1d);
  assertTrue(second.getMinZ() == -0.5d);
  assertTrue(second.getMaxZ() == 0.5d);
  assertTrue(second.getMaxX() == 1d);
  Extrema third=new Extrema(-0.5d,0.5d,0d,1d,-1d,0d);
  assertTrue(third.getMinZ() == -1d);
  assertTrue(third.getMinX() == -0.5d);
  assertTrue(third.getMaxX() == 0.5d);
  assertTrue(third.getMaxY() == 1d);
  ArrayList<Extrema> extrema=new ArrayList<Extrema>();
  extrema.add(first);
  extrema.add(second);
  extrema.add(third);
  Extrema all=new Extrema(extrema);
  assertTrue(all.getMinX() == -1d);
  assertTrue(all.getMaxX() == 1d);
  assertTrue(all.getMinY() == -1d);
  assertTrue(all.getMaxY() == 1d);
  assertTrue(all.getMinZ() == -1d);
  assertTrue(all.getMaxZ() == 1d);
  Extrema empty=new Extrema(new ArrayList<Extrema>());
  assertTrue(empty.getMinX() == 0d);
  assertTrue(empty.getMaxX() == 0d);
  assertTrue(empty.getMinY() == 0d);
  assertTrue(empty.getMaxY() == 0d);
  assertTrue(empty.getMinZ() == 0d);
  assertTrue(empty.getMaxZ() == 0d);
}",0.8881711748082358
133387,"/** 
 * A constructor which creates an extrema from a list of the extrema of other sub-regions. The new extrema will be the extrema of the smallest region possible which contains all given sub-regions.
 * @param subRegions The list of regions which this extrema will contain.
 */
public Extrema(List<Extrema> subRegions){
  logger=LoggerFactory.getLogger(getClass());
  for (  Extrema region : subRegions) {
    if (region != subRegions.get(0)) {
      if (minX > region.minX) {
        minX=region.minX;
      }
      if (maxX < region.maxX) {
        maxX=region.maxX;
      }
      if (minY > region.minY) {
        minY=region.minY;
      }
      if (maxY < region.maxY) {
        maxY=region.maxY;
      }
      if (minZ > region.minZ) {
        minZ=region.minZ;
      }
      if (maxZ < region.maxZ) {
        maxZ=region.maxZ;
      }
    }
 else {
      this.minX=region.minX;
      this.maxX=region.maxX;
      this.minY=region.minY;
      this.maxY=region.maxY;
      this.minZ=region.minZ;
      this.maxZ=region.maxZ;
    }
  }
}","/** 
 * A constructor which creates an extrema from a list of the extrema of other sub-regions. The new extrema will be the extrema of the smallest region possible which contains all given sub-regions. If subRegions is null, the extrema will have 0 for all minimum and maximum values.
 * @param subRegions The list of regions which this extrema will contain.
 */
public Extrema(List<Extrema> subRegions){
  logger=LoggerFactory.getLogger(getClass());
  if (subRegions.isEmpty()) {
    minX=0;
    maxX=0;
    minY=0;
    maxY=0;
    minZ=0;
    maxZ=0;
  }
  for (  Extrema region : subRegions) {
    if (region != subRegions.get(0)) {
      if (minX > region.minX) {
        minX=region.minX;
      }
      if (maxX < region.maxX) {
        maxX=region.maxX;
      }
      if (minY > region.minY) {
        minY=region.minY;
      }
      if (maxY < region.maxY) {
        maxY=region.maxY;
      }
      if (minZ > region.minZ) {
        minZ=region.minZ;
      }
      if (maxZ < region.maxZ) {
        maxZ=region.maxZ;
      }
    }
 else {
      this.minX=region.minX;
      this.maxX=region.maxX;
      this.minY=region.minY;
      this.maxY=region.maxY;
      this.minZ=region.minZ;
      this.maxZ=region.maxZ;
    }
  }
}",0.884293884733832
133388,"@Override public boolean setValue(String newValue){
  Double newValueDouble, lowerBound, upperBound;
  if (allowedValues.size() == 2) {
    lowerBound=Double.valueOf(allowedValues.get(0));
    upperBound=Double.valueOf(allowedValues.get(1));
    try {
      newValueDouble=Double.valueOf(newValue);
    }
 catch (    NumberFormatException|NullPointerException e) {
      errorMessage=newValue + ""String_Node_Str"";
      return false;
    }
    if (newValueDouble != null && (newValueDouble.compareTo(lowerBound) != -1 && newValueDouble.compareTo(upperBound) != 1)) {
      this.value=newValue;
      errorMessage=null;
      return true;
    }
 else {
      String error=continuousErrMsg;
      error=error.replace(""String_Node_Str"",newValue != null ? newValue : ""String_Node_Str"");
      error=error.replace(""String_Node_Str"",getAllowedValues().get(0));
      error=error.replace(""String_Node_Str"",getAllowedValues().get(1));
      this.errorMessage=error;
      return false;
    }
  }
  logger.info(""String_Node_Str"");
  return false;
}","@Override public boolean setValue(String newValue){
  Double newValueDouble, lowerBound, upperBound;
  if (allowedValues.size() == 2) {
    lowerBound=Double.valueOf(allowedValues.get(0));
    upperBound=Double.valueOf(allowedValues.get(1));
    try {
      newValueDouble=Double.valueOf(newValue);
    }
 catch (    NumberFormatException|NullPointerException e) {
      String error=continuousErrMsg;
      error=error.replace(""String_Node_Str"",newValue != null ? newValue : ""String_Node_Str"");
      error=error.replace(""String_Node_Str"",getAllowedValues().get(0));
      error=error.replace(""String_Node_Str"",getAllowedValues().get(1));
      this.errorMessage=error;
      return false;
    }
    if (newValueDouble != null && (newValueDouble.compareTo(lowerBound) != -1 && newValueDouble.compareTo(upperBound) != 1)) {
      this.value=newValue;
      errorMessage=null;
      return true;
    }
 else {
      String error=continuousErrMsg;
      error=error.replace(""String_Node_Str"",newValue != null ? newValue : ""String_Node_Str"");
      error=error.replace(""String_Node_Str"",getAllowedValues().get(0));
      error=error.replace(""String_Node_Str"",getAllowedValues().get(1));
      this.errorMessage=error;
      return false;
    }
  }
  logger.info(""String_Node_Str"");
  return false;
}",0.8710920770877945
133389,"@Override public void refresh(){
  if (isDisposed()) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  if (widget != null) {
    System.out.println(""String_Node_Str"" + entry.getName());
    widget.dispose();
    widget=null;
  }
  for (  Button button : buttons) {
    if (!button.isDisposed()) {
      button.dispose();
    }
  }
  buttons.clear();
  if (resizeListener != null) {
    removeControlListener(resizeListener);
    resizeListener=null;
  }
  render();
  layout();
  return;
}","@Override public void refresh(){
  logger.info(""String_Node_Str"" + entry.getName());
  if (label != null) {
    label.dispose();
    label=null;
  }
  if (widget != null) {
    logger.info(""String_Node_Str"" + widget.getClass().getCanonicalName());
    widget.dispose();
    widget=null;
  }
  for (  Button button : buttons) {
    if (!button.isDisposed()) {
      button.dispose();
    }
  }
  buttons.clear();
  if (isDisposed()) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  if (resizeListener != null) {
    removeControlListener(resizeListener);
    resizeListener=null;
  }
  render();
  layout();
  return;
}",0.3586206896551724
133390,"@Override public void update(IUpdateable component){
  if (component == entry) {
    PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
      @Override public void run(){
        if (!AbstractEntryComposite.this.isDisposed()) {
          refresh();
          if (!AbstractEntryComposite.this.entry.getValue().equals(currentSelection)) {
            toggleSaveDecoration();
          }
          currentSelection=AbstractEntryComposite.this.entry.getValue();
        }
 else {
          entry.unregister(AbstractEntryComposite.this);
        }
      }
    }
);
  }
}","@Override public void update(IUpdateable component){
  if (component == entry) {
    PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
      @Override public void run(){
        if (!AbstractEntryComposite.this.isDisposed()) {
          logger.info(""String_Node_Str"" + entry.getName() + ""String_Node_Str"");
          refresh();
          if (!AbstractEntryComposite.this.entry.getValue().equals(currentSelection)) {
            toggleSaveDecoration();
          }
          currentSelection=AbstractEntryComposite.this.entry.getValue();
        }
 else {
          entry.unregister(AbstractEntryComposite.this);
        }
      }
    }
);
  }
}",0.9353796445880452
133391,"@Override public void run(){
  if (!AbstractEntryComposite.this.isDisposed()) {
    refresh();
    if (!AbstractEntryComposite.this.entry.getValue().equals(currentSelection)) {
      toggleSaveDecoration();
    }
    currentSelection=AbstractEntryComposite.this.entry.getValue();
  }
 else {
    entry.unregister(AbstractEntryComposite.this);
  }
}","@Override public void run(){
  if (!AbstractEntryComposite.this.isDisposed()) {
    logger.info(""String_Node_Str"" + entry.getName() + ""String_Node_Str"");
    refresh();
    if (!AbstractEntryComposite.this.entry.getValue().equals(currentSelection)) {
      toggleSaveDecoration();
    }
    currentSelection=AbstractEntryComposite.this.entry.getValue();
  }
 else {
    entry.unregister(AbstractEntryComposite.this);
  }
}",0.903896103896104
133392,"/** 
 * This operation creates an AbstractEntryComposite for an Entry and adds that Entry to the EntryMap.
 * @param entry The Entry for which the Control should be created.
 * @param index The index in the entryMap of where the rendered AbstractEntryComposite will be put.
 */
private void renderEntry(IEntry entry,int index){
  for (  IEntryComposite entryTemp : entryMap.values()) {
    if (entryTemp.getEntry().equals(entry)) {
      return;
    }
  }
  IEntryComposite entryComposite=null;
  IEntryCompositeProvider provider=new DefaultEntryCompositeProvider();
  if (!""String_Node_Str"".equals(entry.getContext())) {
    try {
      for (      IEntryCompositeProvider p : IEntryCompositeProvider.getProviders()) {
        if (p.getName().equals(entry.getContext())) {
          provider=p;
          break;
        }
      }
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  entryComposite=provider.getEntryComposite(this,entry,SWT.FLAT,formToolkit);
  entryMap.put(index,entryComposite);
  List<Control> uiEntryComps=Arrays.asList(getChildren());
  HashMap<Integer,AbstractEntryComposite> uiMap=new HashMap<Integer,AbstractEntryComposite>();
  for (int i=0; i < uiEntryComps.size(); i++) {
    AbstractEntryComposite e=(AbstractEntryComposite)uiEntryComps.get(i);
    if (e != null) {
      uiMap.put(i,e);
    }
  }
  for (int i=0; i < entryMap.size(); i++) {
    IEntry mapEntry=null, uiEntry=null;
    if (entryMap.get(i) != null)     mapEntry=entryMap.get(i).getEntry();
    if (uiMap.get(i) != null)     uiEntry=uiMap.get(i).entry;
    if (mapEntry == null || uiEntry == null) {
      continue;
    }
    int uiPosition=0;
    if (!mapEntry.getName().equals(uiEntry.getName())) {
      for (int j=0; j < uiEntryComps.size(); j++) {
        IEntry e=uiMap.get(j).entry;
        if (e.getName().equals(mapEntry.getName())) {
          uiPosition=j;
          break;
        }
      }
      if (i - 1 >= 0) {
        AbstractEntryComposite entryAbove=uiMap.get(i - 1);
        if (entryAbove != null) {
          uiMap.get(uiPosition).moveBelow(entryAbove);
        }
      }
 else       if (i + 1 <= entryMap.size()) {
        AbstractEntryComposite entryBelow=uiMap.get(i + 1);
        if (entryBelow != null) {
          uiMap.get(uiPosition).moveAbove(entryBelow);
        }
      }
    }
  }
  return;
}","/** 
 * This operation creates an AbstractEntryComposite for an Entry and adds that Entry to the EntryMap.
 * @param entry The Entry for which the Control should be created.
 * @param index The index in the entryMap of where the rendered AbstractEntryComposite will be put.
 */
private void renderEntry(IEntry entry,int index){
  for (  IEntryComposite entryTemp : entryMap.values()) {
    if (entryTemp.getEntry().equals(entry)) {
      return;
    }
  }
  IEntryComposite entryComposite=null;
  IEntryCompositeProvider provider=new DefaultEntryCompositeProvider();
  if (!""String_Node_Str"".equals(entry.getContext())) {
    try {
      for (      IEntryCompositeProvider p : IEntryCompositeProvider.getProviders()) {
        if (p.getName().equals(entry.getContext())) {
          provider=p;
          break;
        }
      }
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  entryComposite=provider.getEntryComposite(this,entry,SWT.FLAT,formToolkit);
  entryMap.put(index,entryComposite);
  List<Control> uiEntryComps=Arrays.asList(getChildren());
  HashMap<Integer,IEntryComposite> uiMap=new HashMap<Integer,IEntryComposite>();
  for (int i=0; i < uiEntryComps.size(); i++) {
    IEntryComposite e=(IEntryComposite)uiEntryComps.get(i);
    if (e != null) {
      uiMap.put(i,e);
    }
  }
  for (int i=0; i < entryMap.size(); i++) {
    IEntry mapEntry=null, uiEntry=null;
    if (entryMap.get(i) != null)     mapEntry=entryMap.get(i).getEntry();
    if (uiMap.get(i) != null)     uiEntry=uiMap.get(i).getEntry();
    if (mapEntry == null || uiEntry == null) {
      continue;
    }
    int uiPosition=0;
    if (!mapEntry.getName().equals(uiEntry.getName())) {
      for (int j=0; j < uiEntryComps.size(); j++) {
        IEntry e=uiMap.get(j).getEntry();
        if (e.getName().equals(mapEntry.getName())) {
          uiPosition=j;
          break;
        }
      }
      if (i - 1 >= 0) {
        IEntryComposite entryAbove=uiMap.get(i - 1);
        if (entryAbove != null) {
          uiMap.get(uiPosition).getComposite().moveBelow(entryAbove.getComposite());
        }
      }
 else       if (i + 1 <= entryMap.size()) {
        IEntryComposite entryBelow=uiMap.get(i + 1);
        if (entryBelow != null) {
          uiMap.get(uiPosition).getComposite().moveAbove(entryBelow.getComposite());
        }
      }
    }
  }
  return;
}",0.8544303797468354
133393,"@Override public void widgetSelected(SelectionEvent e){
  entry.setValue(((Combo)e.widget).getText());
  notifyListeners(SWT.Selection,new Event());
}","@Override public void widgetSelected(SelectionEvent e){
  notifyListeners(SWT.Selection,new Event());
  Button button=(Button)e.getSource();
  if (button.getSelection()) {
    entry.setValue(yes);
  }
 else {
    entry.setValue(no);
  }
  logger.info(""String_Node_Str"" + entry.getName() + ""String_Node_Str""+ entry.getValue());
  return;
}",0.3155737704918033
133394,"/** 
 * Creates a checkbox for the EntryComposite.
 */
private void createCheckbox(){
  Button tmpButton=null;
  tmpButton=new Button(this,SWT.CHECK);
  tmpButton.setText(entry.getName());
  tmpButton.setToolTipText(entry.getDescription());
  if (allowedBinaryValues.subList(0,5).contains(entry.getValue().toLowerCase())) {
    tmpButton.setSelection(true);
  }
 else {
    tmpButton.setSelection(false);
  }
  tmpButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      notifyListeners(SWT.Selection,new Event());
      int index=lowercaseAllowedValues.indexOf(entry.getValue().toLowerCase());
      String value=null;
      value=(index == 0) ? entry.getAllowedValues().get(1) : entry.getAllowedValues().get(0);
      entry.setValue(value);
      logger.info(""String_Node_Str"" + entry.getName() + ""String_Node_Str""+ entry.getValue());
      return;
    }
  }
);
  tmpButton.setBackground(getBackground());
  buttons.add(tmpButton);
}","/** 
 * Creates a checkbox for the EntryComposite.
 */
private void createCheckbox(){
  Button tmpButton=null;
  tmpButton=new Button(this,SWT.CHECK);
  tmpButton.setText(entry.getName());
  tmpButton.setToolTipText(entry.getDescription());
  if (allowedBinaryValues.subList(0,5).contains(entry.getValue().toLowerCase())) {
    tmpButton.setSelection(true);
  }
 else {
    tmpButton.setSelection(false);
  }
  String yes=""String_Node_Str"", no=""String_Node_Str"";
  for (  String s : lowercaseAllowedValues) {
    for (int i=0; i < allowedBinaryValues.size(); i++) {
      if (s.equals(allowedBinaryValues.get(i)) && i < 6) {
        yes=s;
        break;
      }
 else       if (s.equals(allowedBinaryValues.get(i)) && i > 5) {
        no=s;
        break;
      }
    }
  }
  PostiveNegativeSelectionAdapter adapter=new PostiveNegativeSelectionAdapter(yes,no);
  tmpButton.addSelectionListener(adapter);
  tmpButton.setBackground(getBackground());
  buttons.add(tmpButton);
}",0.5425101214574899
133395,"/** 
 * This operation checks the Item to make sure that by default it offers two actions, one for writing the Form to XML and another for writing the Entries in the Form as a set of key-value pairs. It also makes sure that the Form is written to these two file types if the Item is so directed. It also makes sure that processing a disabled Item fails. Finally, it pulls the output file handle from the Item and makes sure that the default name of the file is set according to the default in the class documentation.
 * @throws IOException
 * @throws JAXBException
 * @throws NullPointerException
 * @throws CoreException
 */
@Test public void checkProcessing() throws NullPointerException, JAXBException, IOException, CoreException {
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  URI defaultProjectLocation=null;
  IProject project=null;
  String separator=System.getProperty(""String_Node_Str"");
  String filename=null;
  ICEJAXBHandler xmlHandler=new ICEJAXBHandler();
  ArrayList<Class> classList=new ArrayList<Class>();
  classList.add(Item.class);
  classList.addAll(new ICEJAXBClassProvider().getClasses());
  try {
    project=workspaceRoot.getProject(""String_Node_Str"");
    if (!project.exists()) {
      defaultProjectLocation=(new File(System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str"")).toURI();
      IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(""String_Node_Str"");
      desc.setLocationURI(defaultProjectLocation);
      project.create(desc,null);
    }
    if (project.exists() && !project.isOpen()) {
      project.open(null);
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  item=new TestItem(project);
  IIOService ioService=new FakeIOService();
  FakeIWriter xmlWriter=new FakeIWriter(""String_Node_Str"");
  ioService.addWriter(xmlWriter);
  item.setIOService(ioService);
  Form form=item.getForm();
  ArrayList<String> actions=form.getActionList();
  assertNotNull(actions);
  assertEquals(2,actions.size());
  assertTrue(actions.contains(""String_Node_Str""));
  assertTrue(actions.contains(""String_Node_Str""));
  assertEquals(FormStatus.InfoError,item.process(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
  item.disable(true);
  assertEquals(FormStatus.Unacceptable,item.process(""String_Node_Str""));
  item.disable(false);
  assertEquals(FormStatus.Processed,item.process(""String_Node_Str""));
  assertTrue(xmlWriter.written);
  assertEquals(FormStatus.Processed,item.process(""String_Node_Str""));
  filename=(form.getName() + ""String_Node_Str"" + form.getId()+ ""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  IFile formDatFile=project.getFile(filename);
  assertTrue(formDatFile.exists());
  Properties formDatProps=new Properties();
  try {
    formDatProps.load(formDatFile.getContents());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  CoreException e1) {
    e1.printStackTrace();
    fail();
  }
  assertEquals(""String_Node_Str"",formDatProps.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",formDatProps.get(""String_Node_Str""));
  try {
    formDatFile.delete(true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  String outputFilename=item.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + item.getId()+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + outputFilename + ""String_Node_Str"");
  File outputFile=item.getOutputFile();
  assertNotNull(outputFile);
  String retOutputName=outputFile.getAbsolutePath();
  System.out.println(""String_Node_Str"" + retOutputName);
  assertTrue(outputFile.getAbsolutePath().contains(outputFilename));
  project.close(null);
  project.delete(true,null);
  return;
}","/** 
 * This operation checks the Item to make sure that by default it offers two actions, one for writing the Form to XML and another for writing the Entries in the Form as a set of key-value pairs. It also makes sure that the Form is written to these two file types if the Item is so directed. It also makes sure that processing a disabled Item fails. Finally, it pulls the output file handle from the Item and makes sure that the default name of the file is set according to the default in the class documentation.
 * @throws IOException
 * @throws JAXBException
 * @throws NullPointerException
 * @throws CoreException
 */
@Test public void checkProcessing() throws NullPointerException, JAXBException, IOException, CoreException {
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  URI defaultProjectLocation=null;
  IProject project=null;
  String separator=System.getProperty(""String_Node_Str"");
  String filename=null;
  ICEJAXBHandler xmlHandler=new ICEJAXBHandler();
  ArrayList<Class> classList=new ArrayList<Class>();
  classList.add(Item.class);
  classList.addAll(new ICEJAXBClassProvider().getClasses());
  try {
    project=workspaceRoot.getProject(""String_Node_Str"");
    if (!project.exists()) {
      defaultProjectLocation=(new File(System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str"")).toURI();
      IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(""String_Node_Str"");
      desc.setLocationURI(defaultProjectLocation);
      project.create(desc,null);
    }
    if (project.exists() && !project.isOpen()) {
      project.open(null);
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  item=new TestItem(project);
  IIOService ioService=new FakeIOService();
  FakeIWriter xmlWriter=new FakeIWriter(""String_Node_Str"");
  ioService.addWriter(xmlWriter);
  item.setIOService(ioService);
  Form form=item.getForm();
  ArrayList<String> actions=form.getActionList();
  assertNotNull(actions);
  assertEquals(2,actions.size());
  assertTrue(actions.contains(""String_Node_Str""));
  assertTrue(actions.contains(""String_Node_Str""));
  assertEquals(FormStatus.InfoError,item.process(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
  item.disable(true);
  assertEquals(FormStatus.Unacceptable,item.process(""String_Node_Str""));
  item.disable(false);
  assertEquals(FormStatus.Processed,item.process(""String_Node_Str""));
  assertTrue(xmlWriter.written);
  System.out.println(""String_Node_Str"");
  assertEquals(FormStatus.Processed,item.process(""String_Node_Str""));
  filename=(form.getName() + ""String_Node_Str"" + form.getId()+ ""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  IFile formDatFile=project.getFile(filename);
  assertTrue(formDatFile.exists());
  Properties formDatProps=new Properties();
  try {
    formDatProps.load(formDatFile.getContents());
  }
 catch (  IOException|CoreException e) {
    e.printStackTrace();
    fail();
  }
  assertEquals(""String_Node_Str"",formDatProps.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",formDatProps.get(""String_Node_Str""));
  try {
    formDatFile.delete(true,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  String outputFilename=item.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + item.getId()+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + outputFilename + ""String_Node_Str"");
  File outputFile=item.getOutputFile();
  assertNotNull(outputFile);
  String retOutputName=outputFile.getAbsolutePath();
  System.out.println(""String_Node_Str"" + retOutputName);
  assertTrue(outputFile.getAbsolutePath().contains(outputFilename));
  project.close(null);
  project.delete(true,null);
  return;
}",0.9315358181337564
133396,"/** 
 * Sets up the psfItemString.
 */
@BeforeClass public static void beforeClass(){
  ArrayList<String> PSFForm=new ArrayList<String>();
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  psfItemString=""String_Node_Str"";
  for (  String i : PSFForm) {
    psfItemString+=i;
  }
  return;
}","/** 
 * Sets up the psfItemString.
 */
@BeforeClass public static void beforeClass(){
  ArrayList<String> PSFForm=new ArrayList<String>();
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"" + ""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  PSFForm.add(""String_Node_Str"");
  psfItemString=""String_Node_Str"";
  for (  String i : PSFForm) {
    psfItemString+=i;
  }
  return;
}",0.9765957446808512
133397,"/** 
 * <p> This operation overrides setupForm() to setup a Form for the tests. </p>
 */
@Override protected void setupForm(){
  form=new Form();
  FakeDataComponent dc1=new FakeDataComponent();
  dc1.setId(1);
  dc1.setName(""String_Node_Str"");
  IEntry dc1Entry=new StringEntry();
  dc1Entry.setName(""String_Node_Str"");
  dc1Entry.setValue(""String_Node_Str"");
  dc1Entry.setTag(""String_Node_Str"");
  dc1.addEntry(dc1Entry);
  DataComponent dc2=new DataComponent();
  dc2.setId(2);
  dc2.setName(""String_Node_Str"");
  IEntry dc2Entry=new StringEntry();
  dc2Entry.setId(5);
  dc2Entry.setName(""String_Node_Str"");
  dc2Entry.setValue(""String_Node_Str"");
  dc2.addEntry(dc2Entry);
  DataComponent dc3=new DataComponent();
  dc3.setId(3);
  dc3.setName(""String_Node_Str"");
  DataComponent dc4=new DataComponent();
  dc4.setId(4);
  dc4.setName(""String_Node_Str"");
  form.addComponent(dc1);
  form.addComponent(dc2);
  form.addComponent(dc3);
  form.addComponent(dc4);
  setName(""String_Node_Str"");
  setId(15);
  setDescription(""String_Node_Str"");
  return;
}","/** 
 * <p> This operation overrides setupForm() to setup a Form for the tests. </p>
 */
@Override protected void setupForm(){
  form=new Form();
  FakeDataComponent dc1=new FakeDataComponent();
  dc1.setId(1);
  dc1.setName(""String_Node_Str"");
  IEntry dc1Entry=new StringEntry();
  dc1Entry.setName(""String_Node_Str"");
  dc1Entry.setValue(""String_Node_Str"");
  dc1Entry.setTag(""String_Node_Str"");
  dc1.addEntry(dc1Entry);
  DataComponent dc2=new DataComponent();
  dc2.setId(2);
  dc2.setName(""String_Node_Str"");
  IEntry dc2Entry=new StringEntry();
  dc2Entry.setId(5);
  dc2Entry.setName(""String_Node_Str"");
  dc2Entry.setTag(""String_Node_Str"");
  dc2Entry.setValue(""String_Node_Str"");
  dc2.addEntry(dc2Entry);
  DataComponent dc3=new DataComponent();
  dc3.setId(3);
  dc3.setName(""String_Node_Str"");
  DataComponent dc4=new DataComponent();
  dc4.setId(4);
  dc4.setName(""String_Node_Str"");
  form.addComponent(dc1);
  form.addComponent(dc2);
  form.addComponent(dc3);
  form.addComponent(dc4);
  setName(""String_Node_Str"");
  setId(15);
  setDescription(""String_Node_Str"");
  return;
}",0.9823255813953488
133398,"/** 
 * The process operation processes the data in the Form to perform a certain action. The action name must be one of the set of actions from the Form that represents this Item. It is possible that ICE may require information in addition to that which was requested in the original Form, such as for a username and password for a remote machine. If this is the case, process will return FormStatus.NeedsInfo and a new, temporary Form will be available for the Item by calling getItem(). Once this new Form is submitted (by calling Item.submitForm() with the completed Form), the Item will finish processing. This operation must be tailored by subclasses to initiate specific Actions. The only Actions available to the Item by default are actions to write the Item's Form to an XML file or a ""tagged output"" where the tags of Entries are used as keys associated with the values of the Entry. If the Entries do not have tags, then the names of the Entries are used. The Form is persisted to a file in the project associated with the Item with a name equal to Form.getName()+""_""+Form.getId() and either a .xml or .dat extension. If the name of the Form contains spaces or other whitespace, they are converted to a single underscore. The names of the available actions are be ""Export to ICE Native Format"" and ""Export to key-value pair output."" Subclasses may choose to add additional actions or to remove the default actions.
 * @param actionName The name of action that should be performed using the processed Form data.
 * @return The status of the Item after processing the Form and executingthe action. It returns FormStatus.InfoError if it is unable to run for any reason, including being asked to run actions that are not in the list of available actions.
 */
public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  IFile outputFile=null;
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  Hashtable<String,String> propsDictionary=null;
  String filename=(form.getName() + ""String_Node_Str"" + form.getId()).replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (allowedActions.contains(actionName) && enabled) {
    if (actionName.equals(nativeExportActionString)) {
      outputFile=project.getFile(filename + ""String_Node_Str"");
      IWriter xmlWriter=ioService.getWriter(""String_Node_Str"");
      xmlWriter.write(form,outputFile);
      retStatus=FormStatus.Processed;
    }
 else     if (actionName.equals(taggedExportActionString)) {
      action=actionFactory.getAction(""String_Node_Str"");
      if (action == null) {
        logger.error(""String_Node_Str"");
        return FormStatus.InfoError;
      }
      outputFile=project.getFile(filename + ""String_Node_Str"");
      try {
        propsDictionary=new Hashtable<String,String>();
        propsDictionary.put(""String_Node_Str"",outputFile.getLocationURI().getPath());
        for (        IEntry i : entryList) {
          if (i.getTag() != null) {
            propsDictionary.put(i.getTag(),i.getValue());
          }
 else {
            propsDictionary.put(i.getName(),i.getValue());
            logger.info(""String_Node_Str"" + i.getTag() + ""String_Node_Str""+ i.getValue());
          }
        }
        retStatus=action.execute(propsDictionary);
        project.refreshLocal(IResource.DEPTH_ONE,null);
        notifyListenersOfProjectChange();
      }
 catch (      CoreException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
  }
  if (enabled) {
    status=retStatus;
    return retStatus;
  }
 else {
    return FormStatus.Unacceptable;
  }
}","/** 
 * The process operation processes the data in the Form to perform a certain action. The action name must be one of the set of actions from the Form that represents this Item. It is possible that ICE may require information in addition to that which was requested in the original Form, such as for a username and password for a remote machine. If this is the case, process will return FormStatus.NeedsInfo and a new, temporary Form will be available for the Item by calling getItem(). Once this new Form is submitted (by calling Item.submitForm() with the completed Form), the Item will finish processing. This operation must be tailored by subclasses to initiate specific Actions. The only Actions available to the Item by default are actions to write the Item's Form to an XML file or a ""tagged output"" where the tags of Entries are used as keys associated with the values of the Entry. If the Entries do not have tags, then the names of the Entries are used. The Form is persisted to a file in the project associated with the Item with a name equal to Form.getName()+""_""+Form.getId() and either a .xml or .dat extension. If the name of the Form contains spaces or other whitespace, they are converted to a single underscore. The names of the available actions are be ""Export to ICE Native Format"" and ""Export to key-value pair output."" Subclasses may choose to add additional actions or to remove the default actions.
 * @param actionName The name of action that should be performed using the processed Form data.
 * @return The status of the Item after processing the Form and executingthe action. It returns FormStatus.InfoError if it is unable to run for any reason, including being asked to run actions that are not in the list of available actions.
 */
public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  IFile outputFile=null;
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  Hashtable<String,String> propsDictionary=null;
  String filename=(form.getName() + ""String_Node_Str"" + form.getId()).replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (allowedActions.contains(actionName) && enabled) {
    if (actionName.equals(nativeExportActionString)) {
      outputFile=project.getFile(filename + ""String_Node_Str"");
      IWriter xmlWriter=ioService.getWriter(""String_Node_Str"");
      xmlWriter.write(form,outputFile);
      retStatus=FormStatus.Processed;
    }
 else     if (actionName.equals(taggedExportActionString)) {
      System.out.println(""String_Node_Str"");
      action=actionFactory.getAction(""String_Node_Str"");
      if (action == null) {
        logger.error(""String_Node_Str"");
        return FormStatus.InfoError;
      }
      outputFile=project.getFile(filename + ""String_Node_Str"");
      try {
        propsDictionary=new Hashtable<String,String>();
        propsDictionary.put(""String_Node_Str"",outputFile.getLocationURI().getPath());
        for (        IEntry i : entryList) {
          System.out.println(""String_Node_Str"" + i.getName());
          if (i.getTag() != null) {
            System.out.println(""String_Node_Str"" + i.getTag() + ""String_Node_Str""+ i.getValue());
            propsDictionary.put(i.getTag(),i.getValue());
          }
 else {
            propsDictionary.put(i.getName(),i.getValue());
            logger.info(""String_Node_Str"" + i.getTag() + ""String_Node_Str""+ i.getValue());
          }
        }
        retStatus=action.execute(propsDictionary);
        project.refreshLocal(IResource.DEPTH_ONE,null);
        notifyListenersOfProjectChange();
      }
 catch (      CoreException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
  }
  if (enabled) {
    status=retStatus;
    return retStatus;
  }
 else {
    return FormStatus.Unacceptable;
  }
}",0.9722446779843708
133399,"/** 
 * Creates a JavaFX PipeController from a RELAP7 Pipe.
 * @param plantComp The pipe to be converted.
 * @return The converted pipe.
 */
public PipeController createPipe(Pipe plantComp){
  PipeMesh mesh=new PipeMesh();
  mesh.setProperty(""String_Node_Str"",Integer.toString(plantComp.getId()));
  mesh.setLength(plantComp.getLength() * SCALE);
  mesh.setRadius(plantComp.getRadius() * SCALE);
  mesh.setInnerRadius(plantComp.getRadius() * SCALE);
  mesh.setAxialSamples(plantComp.getNumElements());
  PipeController pipe=(PipeController)factory.createController(mesh);
  double[] position=plantComp.getPosition();
  position[0]=position[0] * SCALE;
  position[1]=position[1] * SCALE;
  position[2]=position[2] * SCALE;
  double[] orientation=plantComp.getOrientation();
  double[] normalized=new double[3];
  double length=Math.sqrt(Math.pow(orientation[0],2) + Math.pow(orientation[1],2) + Math.pow(orientation[2],2));
  normalized[0]=orientation[0] / length;
  normalized[1]=orientation[1] / length;
  normalized[2]=orientation[2] / length;
  double pipeLength=plantComp.getLength() * SCALE;
  position[0]+=pipeLength / 2 * normalized[0];
  position[1]+=pipeLength / 2 * normalized[1];
  position[2]+=pipeLength / 2 * normalized[2];
  pipe.setTranslation(position[0],position[1],position[2]);
  double yRotation;
  if (normalized[1] != 0 || normalized[0] != 0) {
    yRotation=normalized[2] / Math.sqrt(Math.pow(normalized[0],2) + Math.pow(normalized[1],2));
  }
 else {
    yRotation=0d;
  }
  double zRotation;
  if (normalized[0] != 0) {
    zRotation=normalized[1] / normalized[0];
  }
 else {
    zRotation=0d;
  }
  if ((yRotation != 0 && zRotation != 0)) {
    pipe.setRotation(0,-Math.atan(yRotation),-Math.atan(zRotation));
  }
 else {
    if (normalized[0] > 0) {
      pipe.setRotation(0,0,-Math.PI / 2);
    }
 else     if (normalized[0] < 0) {
      pipe.setRotation(0,0,Math.PI / 2);
    }
 else     if (normalized[2] > 0) {
      pipe.setRotation(Math.PI / 2,0,0);
    }
 else     if (normalized[2] < 0) {
      pipe.setRotation(-Math.PI / 2,0,0);
    }
 else     if (normalized[1] < 0) {
      pipe.setRotation(-Math.PI,0,0);
    }
  }
  return pipe;
}","/** 
 * Creates a JavaFX PipeController from a RELAP7 Pipe.
 * @param plantComp The pipe to be converted.
 * @return The converted pipe.
 */
public PipeController createPipe(Pipe plantComp){
  PipeMesh mesh=new PipeMesh();
  mesh.setProperty(""String_Node_Str"",Integer.toString(plantComp.getId()));
  mesh.setLength(plantComp.getLength() * SCALE);
  mesh.setRadius(plantComp.getRadius() * SCALE);
  mesh.setInnerRadius(plantComp.getRadius() * SCALE);
  mesh.setAxialSamples(plantComp.getNumElements());
  mesh.setProperty(""String_Node_Str"",plantComp.getName());
  PipeController pipe=(PipeController)factory.createController(mesh);
  double[] position=plantComp.getPosition();
  position[0]=position[0] * SCALE;
  position[1]=position[1] * SCALE;
  position[2]=position[2] * SCALE;
  double[] orientation=plantComp.getOrientation();
  double[] normalized=new double[3];
  double length=Math.sqrt(Math.pow(orientation[0],2) + Math.pow(orientation[1],2) + Math.pow(orientation[2],2));
  normalized[0]=orientation[0] / length;
  normalized[1]=orientation[1] / length;
  normalized[2]=orientation[2] / length;
  double pipeLength=plantComp.getLength() * SCALE;
  position[0]+=pipeLength / 2 * normalized[0];
  position[1]+=pipeLength / 2 * normalized[1];
  position[2]+=pipeLength / 2 * normalized[2];
  pipe.setTranslation(position[0],position[1],position[2]);
  double yRotation;
  if (normalized[1] != 0 || normalized[0] != 0) {
    yRotation=normalized[2] / Math.sqrt(Math.pow(normalized[0],2) + Math.pow(normalized[1],2));
  }
 else {
    yRotation=0d;
  }
  double zRotation;
  if (normalized[0] != 0) {
    zRotation=normalized[1] / normalized[0];
  }
 else {
    zRotation=0d;
  }
  if ((yRotation != 0 && zRotation != 0)) {
    pipe.setRotation(0,-Math.atan(yRotation),-Math.atan(zRotation));
  }
 else {
    if (normalized[0] > 0) {
      pipe.setRotation(0,0,-Math.PI / 2);
    }
 else     if (normalized[0] < 0) {
      pipe.setRotation(0,0,Math.PI / 2);
    }
 else     if (normalized[2] > 0) {
      pipe.setRotation(Math.PI / 2,0,0);
    }
 else     if (normalized[2] < 0) {
      pipe.setRotation(-Math.PI / 2,0,0);
    }
 else     if (normalized[1] < 0) {
      pipe.setRotation(-Math.PI,0,0);
    }
  }
  return pipe;
}",0.9866061293984107
133400,"/** 
 * The default constructor.
 */
public HeatExchangerMesh(){
  super();
}","/** 
 * The default constructor
 * @param primary The heat exchanger's primary pipe.
 */
public HeatExchangerMesh(PipeController primary){
  this();
  setPrimaryPipe(primary);
}",0.5748031496062992
133401,"@Override protected void updateCamera(ICamera camera){
  if (!(camera instanceof FXCameraAttachment)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  FXCameraAttachment attachment=(FXCameraAttachment)camera;
  Camera fxCamera=attachment.getFxCamera();
  if (fxCamera == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  cameraController=new CenteredController(fxCamera,scene,fxCanvas);
  scene.setCamera(fxCamera);
  defaultCamera=fxCamera;
}","@Override protected void updateCamera(ICamera camera){
  if (!(camera instanceof FXCameraAttachment)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  FXCameraAttachment attachment=(FXCameraAttachment)camera;
  Camera fxCamera=attachment.getFxCamera();
  if (fxCamera == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  cameraController=new CenteredCameraController(fxCamera,scene,fxCanvas);
  scene.setCamera(fxCamera);
  defaultCamera=fxCamera;
}",0.9937888198757764
133402,"/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  IRemoteConnection connection=null;
  IRemoteConnectionType connectionType=remoteManager.getRemoteConnectionTypes().get(0);
  if (connectionType != null) {
    try {
      for (      IRemoteConnection c : connectionType.getConnections()) {
        String connectionHost=c.getService(IRemoteConnectionHostService.class).getHostname();
        if (InetAddress.getByName(host).getHostAddress().equals(InetAddress.getByName(connectionHost).getHostAddress())) {
          connection=c;
          break;
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
  return connection;
}","/** 
 * This method returns an IRemoteConnection stored in the Remote Preferences that corresponds to the provided hostname.
 * @param host
 * @return
 */
protected IRemoteConnection getRemoteConnection(String host){
  IRemoteServicesManager remoteManager=getService(IRemoteServicesManager.class);
  IRemoteConnection connection=null;
  if (remoteManager != null) {
    IRemoteConnectionType connectionType=remoteManager.getRemoteConnectionTypes().get(0);
    if (connectionType != null) {
      try {
        for (        IRemoteConnection c : connectionType.getConnections()) {
          String connectionHost=c.getService(IRemoteConnectionHostService.class).getHostname();
          if (InetAddress.getByName(host).getHostAddress().equals(InetAddress.getByName(connectionHost).getHostAddress())) {
            connection=c;
            break;
          }
        }
      }
 catch (      UnknownHostException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
  }
  return connection;
}",0.966110268082954
133403,"/** 
 * Return the OSGi service with the given service interface.
 * @param service service interface
 * @return the specified service or null if it's not registered
 */
private <T>T getService(Class<T> service){
  BundleContext context=FrameworkUtil.getBundle(getClass()).getBundleContext();
  ServiceReference<T> ref=context.getServiceReference(service);
  return ref != null ? context.getService(ref) : null;
}","/** 
 * Return the OSGi service with the given service interface.
 * @param service service interface
 * @return the specified service or null if it's not registered
 */
private <T>T getService(Class<T> service){
  BundleContext context=FrameworkUtil.getBundle(getClass()).getBundleContext();
  if (context != null) {
    ServiceReference<T> ref=context.getServiceReference(service);
    return ref != null ? context.getService(ref) : null;
  }
 else {
    return null;
  }
}",0.9301801801801802
133404,"@Override protected IStatus run(IProgressMonitor monitor){
  final int ticks=100;
  int worked=0;
  monitor.beginTask(""String_Node_Str"",ticks);
  status=FormStatus.Processing;
  Action.clearConsole();
  for (  Action action : actions) {
    currentlyRunningAction=action;
    monitor.subTask(""String_Node_Str"" + currentlyRunningAction.getActionName() + ""String_Node_Str"");
    FormStatus tempStatus=currentlyRunningAction.execute(actionDataMap);
    if (tempStatus.equals(FormStatus.InfoError)) {
      return error(""String_Node_Str"" + action.getActionName() + ""String_Node_Str"",null);
    }
    if (tempStatus.equals(FormStatus.NeedsInfo)) {
      status=tempStatus;
      while (status.equals(FormStatus.Processing) || status.equals(FormStatus.NeedsInfo)) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e1) {
          return error(""String_Node_Str"" + action.getActionName() + ""String_Node_Str"",e1);
        }
      }
      status=FormStatus.Processing;
    }
    if (monitor.isCanceled()) {
      currentlyRunningAction.cancel();
      status=FormStatus.Processed;
      return Status.CANCEL_STATUS;
    }
    while (tempStatus.equals(FormStatus.Processing)) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e1) {
        return error(""String_Node_Str"" + action.getActionName() + ""String_Node_Str"",e1);
      }
      tempStatus=currentlyRunningAction.getStatus();
    }
    worked+=ticks / actions.size();
    monitor.worked(worked);
  }
  status=FormStatus.Processed;
  monitor.worked(ticks);
  monitor.done();
  return Status.OK_STATUS;
}","@Override protected IStatus run(IProgressMonitor monitor){
  final int ticks=100;
  int worked=0;
  monitor.beginTask(""String_Node_Str"",ticks);
  status=FormStatus.Processing;
  Action.clearConsole();
  for (  Action action : actions) {
    currentlyRunningAction=action;
    monitor.subTask(""String_Node_Str"" + currentlyRunningAction.getActionName() + ""String_Node_Str"");
    FormStatus tempStatus=currentlyRunningAction.execute(actionDataMap);
    if (tempStatus.equals(FormStatus.InfoError)) {
      return error(""String_Node_Str"" + action.getActionName() + ""String_Node_Str"",null);
    }
    if (tempStatus.equals(FormStatus.NeedsInfo)) {
      status=FormStatus.NeedsInfo;
      while (tempStatus.equals(FormStatus.NeedsInfo)) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e1) {
          return error(""String_Node_Str"" + action.getActionName() + ""String_Node_Str"",e1);
        }
        tempStatus=currentlyRunningAction.getStatus();
      }
      status=FormStatus.Processing;
    }
    if (monitor.isCanceled()) {
      currentlyRunningAction.cancel();
      status=FormStatus.Processed;
      return Status.CANCEL_STATUS;
    }
    while (tempStatus.equals(FormStatus.Processing)) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e1) {
        return error(""String_Node_Str"" + action.getActionName() + ""String_Node_Str"",e1);
      }
      tempStatus=currentlyRunningAction.getStatus();
    }
    worked+=ticks / actions.size();
    monitor.worked(worked);
  }
  status=FormStatus.Processed;
  monitor.worked(ticks);
  monitor.done();
  return Status.OK_STATUS;
}",0.96
133405,"@Override public void run(){
  File stdout=new File(actionDataMap.get(""String_Node_Str"")), stderr=new File(actionDataMap.get(""String_Node_Str""));
  FileWriter outputFileWriter=null;
  BufferedWriter outputFileBufferedWriter=null;
  FileReader stdoutReader=null, stderrReader=null;
  BufferedReader stdoutBufferredReader=null, stderrBufferredReader=null;
  String line=null;
  try {
    outputFileWriter=new FileWriter(processOutput);
    outputFileBufferedWriter=new BufferedWriter(outputFileWriter);
    stdoutReader=new FileReader(stdout);
    stdoutBufferredReader=new BufferedReader(stdoutReader);
    stderrReader=new FileReader(stderr);
    stderrBufferredReader=new BufferedReader(stderrReader);
    while (status.equals(FormStatus.Processing) || status.equals(FormStatus.NeedsInfo)) {
      while ((line=stdoutBufferredReader.readLine()) != null) {
        outputFileBufferedWriter.write(line);
        outputFileBufferedWriter.write(""String_Node_Str"");
      }
      while ((line=stderrBufferredReader.readLine()) != null) {
        outputFileBufferedWriter.write(line);
        outputFileBufferedWriter.write(""String_Node_Str"");
      }
      outputFileBufferedWriter.flush();
      Thread.currentThread();
      Thread.sleep(100);
    }
    stdoutBufferredReader.close();
    stdoutReader.close();
    stderrBufferredReader.close();
    stderrReader.close();
    outputFileBufferedWriter.close();
    outputFileWriter.close();
    updateResourceComponent();
  }
 catch (  IOException|InterruptedException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    return;
  }
}","@Override public void run(){
  File stdout=new File(actionDataMap.get(""String_Node_Str"")), stderr=new File(actionDataMap.get(""String_Node_Str""));
  FileWriter outputFileWriter=null;
  BufferedWriter outputFileBufferedWriter=null;
  FileReader stdoutReader=null, stderrReader=null;
  BufferedReader stdoutBufferredReader=null, stderrBufferredReader=null;
  String line=null;
  try {
    outputFileWriter=new FileWriter(processOutput);
    outputFileBufferedWriter=new BufferedWriter(outputFileWriter);
    stdoutReader=new FileReader(stdout);
    stdoutBufferredReader=new BufferedReader(stdoutReader);
    stderrReader=new FileReader(stderr);
    stderrBufferredReader=new BufferedReader(stderrReader);
    while (status.equals(FormStatus.Processing) || status.equals(FormStatus.NeedsInfo)) {
      while ((line=stdoutBufferredReader.readLine()) != null) {
        outputFileBufferedWriter.write(line);
        outputFileBufferedWriter.write(""String_Node_Str"");
      }
      while ((line=stderrBufferredReader.readLine()) != null) {
        outputFileBufferedWriter.write(line);
        outputFileBufferedWriter.write(""String_Node_Str"");
      }
      outputFileBufferedWriter.flush();
      Thread.currentThread();
      Thread.sleep(100);
      action=launchJob.getCurrentAction();
    }
    stdoutBufferredReader.close();
    stdoutReader.close();
    stderrBufferredReader.close();
    stderrReader.close();
    outputFileBufferedWriter.close();
    outputFileWriter.close();
    updateResourceComponent();
  }
 catch (  IOException|InterruptedException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    return;
  }
}",0.986740672217083
133406,"/** 
 * This operations grabs the information from the stdout and stderr files and puts it into the output file for JobLauncher that is consumed by clients.
 */
private void writeOutputData(){
  Thread streamingThread=new Thread(new Runnable(){
    @Override public void run(){
      File stdout=new File(actionDataMap.get(""String_Node_Str"")), stderr=new File(actionDataMap.get(""String_Node_Str""));
      FileWriter outputFileWriter=null;
      BufferedWriter outputFileBufferedWriter=null;
      FileReader stdoutReader=null, stderrReader=null;
      BufferedReader stdoutBufferredReader=null, stderrBufferredReader=null;
      String line=null;
      try {
        outputFileWriter=new FileWriter(processOutput);
        outputFileBufferedWriter=new BufferedWriter(outputFileWriter);
        stdoutReader=new FileReader(stdout);
        stdoutBufferredReader=new BufferedReader(stdoutReader);
        stderrReader=new FileReader(stderr);
        stderrBufferredReader=new BufferedReader(stderrReader);
        while (status.equals(FormStatus.Processing) || status.equals(FormStatus.NeedsInfo)) {
          while ((line=stdoutBufferredReader.readLine()) != null) {
            outputFileBufferedWriter.write(line);
            outputFileBufferedWriter.write(""String_Node_Str"");
          }
          while ((line=stderrBufferredReader.readLine()) != null) {
            outputFileBufferedWriter.write(line);
            outputFileBufferedWriter.write(""String_Node_Str"");
          }
          outputFileBufferedWriter.flush();
          Thread.currentThread();
          Thread.sleep(100);
        }
        stdoutBufferredReader.close();
        stdoutReader.close();
        stderrBufferredReader.close();
        stderrReader.close();
        outputFileBufferedWriter.close();
        outputFileWriter.close();
        updateResourceComponent();
      }
 catch (      IOException|InterruptedException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        return;
      }
    }
  }
);
  logger.info(""String_Node_Str"");
  streamingThread.start();
  return;
}","/** 
 * This operations grabs the information from the stdout and stderr files and puts it into the output file for JobLauncher that is consumed by clients.
 */
private void writeOutputData(){
  Thread streamingThread=new Thread(new Runnable(){
    @Override public void run(){
      File stdout=new File(actionDataMap.get(""String_Node_Str"")), stderr=new File(actionDataMap.get(""String_Node_Str""));
      FileWriter outputFileWriter=null;
      BufferedWriter outputFileBufferedWriter=null;
      FileReader stdoutReader=null, stderrReader=null;
      BufferedReader stdoutBufferredReader=null, stderrBufferredReader=null;
      String line=null;
      try {
        outputFileWriter=new FileWriter(processOutput);
        outputFileBufferedWriter=new BufferedWriter(outputFileWriter);
        stdoutReader=new FileReader(stdout);
        stdoutBufferredReader=new BufferedReader(stdoutReader);
        stderrReader=new FileReader(stderr);
        stderrBufferredReader=new BufferedReader(stderrReader);
        while (status.equals(FormStatus.Processing) || status.equals(FormStatus.NeedsInfo)) {
          while ((line=stdoutBufferredReader.readLine()) != null) {
            outputFileBufferedWriter.write(line);
            outputFileBufferedWriter.write(""String_Node_Str"");
          }
          while ((line=stderrBufferredReader.readLine()) != null) {
            outputFileBufferedWriter.write(line);
            outputFileBufferedWriter.write(""String_Node_Str"");
          }
          outputFileBufferedWriter.flush();
          Thread.currentThread();
          Thread.sleep(100);
          action=launchJob.getCurrentAction();
        }
        stdoutBufferredReader.close();
        stdoutReader.close();
        stderrBufferredReader.close();
        stderrReader.close();
        outputFileBufferedWriter.close();
        outputFileWriter.close();
        updateResourceComponent();
      }
 catch (      IOException|InterruptedException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        return;
      }
    }
  }
);
  logger.info(""String_Node_Str"");
  streamingThread.start();
  return;
}",0.9888546359971544
133407,"/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String host=""String_Node_Str"";
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      logger.error(""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      host=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
    }
    String thisHost=""String_Node_Str"";
    try {
      thisHost=InetAddress.getLocalHost().getCanonicalHostName();
    }
 catch (    UnknownHostException e) {
      e.printStackTrace();
      logger.error(this.getClass().getName() + ""String_Node_Str"",e);
    }
    if (!thisHost.isEmpty()) {
      System.out.println(""String_Node_Str"" + thisHost);
      createICEUpdaterBlock(thisHost);
    }
    if (populateListOfLauncherFiles() != FormStatus.ReadyToProcess) {
      logger.error(getClass().getName() + ""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(host);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
    outputFile=mooseLauncher.getOutputFile();
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}","/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String thisHost=""String_Node_Str"", remoteHost=""String_Node_Str"";
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      logger.error(""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      remoteHost=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
      try {
        thisHost=InetAddress.getLocalHost().getHostAddress();
      }
 catch (      UnknownHostException e) {
        e.printStackTrace();
        logger.error(this.getClass().getName() + ""String_Node_Str"",e);
      }
    }
    createICEUpdaterBlock(thisHost);
    if (populateListOfLauncherFiles() != FormStatus.ReadyToProcess) {
      logger.error(getClass().getName() + ""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(remoteHost);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
    outputFile=mooseLauncher.getOutputFile();
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}",0.8997185080928923
133408,"/** 
 * This private method add the necessary components  to the Form. 
 */
private void addComponents(){
  for (  Component c : mooseModel.getForm().getComponents()) {
    if (c.getName().equals(""String_Node_Str"")) {
      c.setName(""String_Node_Str"");
    }
    form.addComponent(c);
  }
  modelFiles=(DataComponent)form.getComponent(1);
  form.addComponent(mooseLauncher.getForm().getComponent(3));
  modelTree=(TreeComposite)form.getComponent(2);
  postProcessorsData=new DataComponent();
  postProcessorsData.setName(""String_Node_Str"");
  postProcessorsData.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  postProcessorsData.setId(MOOSE.ppDataId);
  form.addComponent(postProcessorsData);
  TreeComposite ppTree;
  if ((ppTree=getTopLevelTreeByName(""String_Node_Str"")) != null) {
    setupPostprocessorData(ppTree);
  }
}","/** 
 * This private method add the necessary components to the Form.
 */
private void addComponents(){
  for (  Component c : mooseModel.getForm().getComponents()) {
    if (c.getName().equals(""String_Node_Str"")) {
      c.setName(""String_Node_Str"");
    }
    form.addComponent(c);
  }
  modelFiles=(DataComponent)form.getComponent(1);
  form.addComponent(mooseLauncher.getForm().getComponent(3));
  modelTree=(TreeComposite)form.getComponent(2);
  postProcessorsData=new DataComponent();
  postProcessorsData.setName(""String_Node_Str"");
  postProcessorsData.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  postProcessorsData.setId(MOOSE.ppDataId);
  form.addComponent(postProcessorsData);
  TreeComposite ppTree;
  if ((ppTree=getTopLevelTreeByName(""String_Node_Str"")) != null) {
    setupPostprocessorData(ppTree);
  }
}",0.998800959232614
133409,"/** 
 * Overriding the default behavior here because  the overall process output should be in the  to-be-created local job folder. 
 */
@Override protected void setupOutputFile(){
  return;
}","/** 
 * Overriding the default behavior here because the overall process output should be in the to-be-created local job folder.
 */
@Override protected void setupOutputFile(){
  return;
}",0.992084432717678
133410,"/** 
 * This operation launches the job on a remote machine.
 */
protected void launchRemotely(){
  IRemoteConnectionWorkingCopy workingCopy=null;
  IRemoteProcessService processService=null;
  Date currentDate=new Date();
  SimpleDateFormat shortDate=new SimpleDateFormat(""String_Node_Str"");
  String hostname=execDictionary.get(""String_Node_Str"");
  String launchCMDFileName=""String_Node_Str"", launchCMD=""String_Node_Str"";
  List<IFile> files=new ArrayList<IFile>();
  Dictionary<String,String> uploadDataMap=new Hashtable<String,String>();
  Dictionary<String,String> downloadDataMap=new Hashtable<String,String>();
  IFileStore localDirectory=EFS.getLocalFileSystem().getStore(localLaunchFolder.getLocationURI());
  while (!formSubmitted.get()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e1) {
      logger.error(getClass().getName() + ""String_Node_Str"",e1);
      return;
    }
  }
  try {
    launchCMDFileName=writeRemoteCommandFile();
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    return;
  }
  if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    launchCMD=""String_Node_Str"" + launchCMDFileName;
  }
 else {
    launchCMD=""String_Node_Str"" + launchCMDFileName;
  }
  uploadDataMap.put(""String_Node_Str"",""String_Node_Str"" + workingDirectoryBaseName);
  downloadDataMap.put(""String_Node_Str"",localLaunchFolder.getLocation().toOSString());
  for (  String shortInputName : fileMap.keySet()) {
    files.add(localLaunchFolder.getFile(shortInputName));
  }
  if (connection == null) {
    if (connectionType == null) {
      logger.error(""String_Node_Str"");
      status=FormStatus.InfoError;
      return;
    }
    DataComponent credentials=(DataComponent)formAtomic.get().getComponent(1);
    try {
      workingCopy=connectionType.newConnection(hostname + ""String_Node_Str"" + shortDate.format(currentDate));
    }
 catch (    RemoteConnectionException e3) {
      e3.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    workingCopy.setAttribute(""String_Node_Str"",hostname);
    workingCopy.setAttribute(""String_Node_Str"",credentials.retrieveAllEntries().get(0).getValue());
    workingCopy.setSecureAttribute(""String_Node_Str"",credentials.retrieveAllEntries().get(1).getValue());
    try {
      connection=workingCopy.save();
    }
 catch (    RemoteConnectionException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      status=FormStatus.InfoError;
      return;
    }
  }
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    status=FormStatus.InfoError;
    return;
  }
  if (connection.isOpen() && !cancelled.get()) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    status=FormStatus.Processing;
    String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
    uploadDataMap.put(""String_Node_Str"",""String_Node_Str"" + remoteSeparator + workingDirectoryBaseName);
    uploadDataMap.put(""String_Node_Str"",execDictionary.get(""String_Node_Str""));
    String filesString=""String_Node_Str"";
    for (    IFile f : files) {
      filesString+=f.getLocation().toOSString() + ""String_Node_Str"";
    }
    filesString=filesString.substring(0,filesString.length() - 1);
    uploadDataMap.put(""String_Node_Str"",filesString);
    uploadDataMap.put(""String_Node_Str"",localLaunchFolder.getLocation().toOSString());
    RemoteFileUploadAction uploadAction=new RemoteFileUploadAction();
    status=uploadAction.execute(uploadDataMap);
    if (status == FormStatus.InfoError) {
      logger.error(""String_Node_Str"");
      return;
    }
    processService=connection.getService(IRemoteProcessService.class);
    processService.setWorkingDirectory(uploadAction.getRemoteUploadDirectoryPath());
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + processService.getWorkingDirectory());
    IRemoteProcessBuilder processBuilder=processService.getProcessBuilder(""String_Node_Str"",launchCMD);
    processBuilder.redirectErrorStream(false);
    try {
      logger.info(""String_Node_Str"" + ""String_Node_Str"");
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ launchCMDFileName);
      remoteJob=processBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
    }
 catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      status=FormStatus.InfoError;
      return;
    }
    InputStream stdOutStream=remoteJob.getInputStream();
    InputStream stdErrStream=remoteJob.getErrorStream();
    if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
    monitorJob();
    if (!cancelled.get()) {
      String remoteDir=processService.getWorkingDirectory();
      downloadDataMap.put(""String_Node_Str"",remoteDir);
      downloadDataMap.put(""String_Node_Str"",execDictionary.get(""String_Node_Str""));
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + localDirectory.getName() + ""String_Node_Str""+ remoteDir+ ""String_Node_Str"");
      RemoteFileDownloadAction downloadAction=new RemoteFileDownloadAction();
      status=downloadAction.execute(downloadDataMap);
      if (status == FormStatus.InfoError) {
        logger.error(""String_Node_Str"");
        return;
      }
    }
  }
  status=FormStatus.Processed;
  connection.close();
  return;
}","/** 
 * This operation launches the job on a remote machine.
 */
protected void launchRemotely(){
  IRemoteConnectionWorkingCopy workingCopy=null;
  IRemoteProcessService processService=null;
  Date currentDate=new Date();
  SimpleDateFormat shortDate=new SimpleDateFormat(""String_Node_Str"");
  String hostname=execDictionary.get(""String_Node_Str"");
  String launchCMDFileName=""String_Node_Str"", launchCMD=""String_Node_Str"";
  List<IFile> files=new ArrayList<IFile>();
  Dictionary<String,String> uploadDataMap=new Hashtable<String,String>();
  Dictionary<String,String> downloadDataMap=new Hashtable<String,String>();
  IFileStore localDirectory=EFS.getLocalFileSystem().getStore(localLaunchFolder.getLocationURI());
  while (!formSubmitted.get()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e1) {
      logger.error(getClass().getName() + ""String_Node_Str"",e1);
      return;
    }
  }
  try {
    launchCMDFileName=writeRemoteCommandFile();
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    return;
  }
  if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    launchCMD=""String_Node_Str"" + launchCMDFileName;
  }
 else {
    launchCMD=""String_Node_Str"" + launchCMDFileName;
  }
  uploadDataMap.put(""String_Node_Str"",""String_Node_Str"" + workingDirectoryBaseName);
  downloadDataMap.put(""String_Node_Str"",localLaunchFolder.getLocation().toOSString());
  for (  String shortInputName : fileMap.keySet()) {
    files.add(localLaunchFolder.getFile(shortInputName));
  }
  if (connection == null) {
    if (connectionType == null) {
      logger.error(""String_Node_Str"");
      status=FormStatus.InfoError;
      return;
    }
    DataComponent credentials=(DataComponent)formAtomic.get().getComponent(1);
    try {
      workingCopy=connectionType.newConnection(hostname + ""String_Node_Str"" + shortDate.format(currentDate));
    }
 catch (    RemoteConnectionException e3) {
      e3.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    workingCopy.setAttribute(""String_Node_Str"",hostname);
    workingCopy.setAttribute(""String_Node_Str"",credentials.retrieveAllEntries().get(0).getValue());
    workingCopy.setSecureAttribute(""String_Node_Str"",credentials.retrieveAllEntries().get(1).getValue());
    try {
      connection=workingCopy.save();
    }
 catch (    RemoteConnectionException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      status=FormStatus.InfoError;
      return;
    }
  }
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    status=FormStatus.InfoError;
    return;
  }
  if (connection.isOpen() && !cancelled.get()) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    status=FormStatus.Processing;
    String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
    uploadDataMap.put(""String_Node_Str"",""String_Node_Str"" + remoteSeparator + workingDirectoryBaseName);
    uploadDataMap.put(""String_Node_Str"",execDictionary.get(""String_Node_Str""));
    String filesString=""String_Node_Str"";
    for (    IFile f : files) {
      filesString+=f.getLocation().toOSString() + ""String_Node_Str"";
    }
    filesString=filesString.substring(0,filesString.length() - 1);
    uploadDataMap.put(""String_Node_Str"",filesString);
    uploadDataMap.put(""String_Node_Str"",localLaunchFolder.getLocation().toOSString());
    RemoteFileUploadAction uploadAction=new RemoteFileUploadAction();
    status=uploadAction.execute(uploadDataMap);
    if (status == FormStatus.InfoError) {
      logger.error(""String_Node_Str"");
      return;
    }
    processService=connection.getService(IRemoteProcessService.class);
    processService.setWorkingDirectory(uploadAction.getRemoteUploadDirectoryPath());
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + processService.getWorkingDirectory());
    IRemoteProcessBuilder processBuilder=processService.getProcessBuilder(""String_Node_Str"",launchCMD);
    processBuilder.redirectErrorStream(false);
    try {
      logger.info(""String_Node_Str"" + ""String_Node_Str"");
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ launchCMDFileName);
      remoteJob=processBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
    }
 catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      status=FormStatus.InfoError;
      return;
    }
    InputStream stdOutStream=remoteJob.getInputStream();
    InputStream stdErrStream=remoteJob.getErrorStream();
    if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
    monitorJob();
    if (!cancelled.get()) {
      String remoteDir=processService.getWorkingDirectory();
      downloadDataMap.put(""String_Node_Str"",remoteDir);
      downloadDataMap.put(""String_Node_Str"",execDictionary.get(""String_Node_Str""));
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + localDirectory.getName() + ""String_Node_Str""+ remoteDir+ ""String_Node_Str"");
      RemoteFileDownloadAction downloadAction=new RemoteFileDownloadAction();
      status=downloadAction.execute(downloadDataMap);
      if (status == FormStatus.InfoError) {
        logger.error(""String_Node_Str"");
        return;
      }
    }
  }
  status=FormStatus.Processed;
  fileMap.clear();
  connection.close();
  return;
}",0.9982627777269818
133411,"/** 
 * This operation creates a set of ICEFormPages for ListComponents that are stored in the component map.
 * @return The pages.
 * @throws CoreException 
 */
private ArrayList<IFormPage> createListSectionPages(){
  ArrayList<IFormPage> pages=new ArrayList<IFormPage>();
  try {
    IListPageProvider[] listPageProviders=IListPageProvider.getProviders();
    if (listPageProviders != null && listPageProviders.length > 0) {
      String providerNameToUse=DefaultListPageProvider.PROVIDER_NAME;
      for (      IListPageProvider currentProvider : listPageProviders) {
        if (providerNameToUse.equals(currentProvider.getName())) {
          pages.addAll(currentProvider.getPages(this,componentMap));
          break;
        }
      }
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    logger.error(""String_Node_Str"",e);
  }
  return pages;
}","/** 
 * This operation creates a set of ICEFormPages for ListComponents that are stored in the component map.
 * @return The pages.
 * @throws CoreException
 */
private ArrayList<IFormPage> createListSectionPages(){
  ArrayList<IFormPage> pages=new ArrayList<IFormPage>();
  try {
    IListPageProvider[] listPageProviders=IListPageProvider.getProviders();
    if (listPageProviders != null && listPageProviders.length > 0) {
      String providerNameToUse=DefaultListPageProvider.PROVIDER_NAME;
      for (      IListPageProvider currentProvider : listPageProviders) {
        if (providerNameToUse.equals(currentProvider.getName())) {
          pages.addAll(currentProvider.getPages(this,componentMap));
          break;
        }
      }
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  CoreException e) {
    logger.error(""String_Node_Str"",e);
  }
  return pages;
}",0.9994404029099048
133412,"/** 
 * An operation that tests xml persistence on JobLauncherForm.
 * @throws IOException 
 * @throws JAXBException 
 * @throws NullPointerException 
 */
@Test public void checkXMLPersistence() throws NullPointerException, JAXBException, IOException {
  JobLauncherForm jobForm=new JobLauncherForm();
  JobLauncherForm loadedForm=new JobLauncherForm();
  ArrayList<String> actions=new ArrayList<String>();
  ICEJAXBHandler xmlHandler=new ICEJAXBHandler();
  ArrayList<Class> classList=new ArrayList<Class>();
  classList.add(JobLauncherForm.class);
  classList.addAll(new ICEJAXBClassProvider().getClasses());
  jobForm.setName(""String_Node_Str"");
  jobForm.setDescription(""String_Node_Str"");
  jobForm.setId(3);
  jobForm.enableMPI(2,4,2);
  jobForm.enableOpenMP(2,4,3);
  actions.add(""String_Node_Str"");
  jobForm.setActionList(actions);
  jobForm.setInputFiles(""String_Node_Str"",""String_Node_Str"",new ArrayList<String>());
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  xmlHandler.write(jobForm,classList,outputStream);
  loadedForm=(JobLauncherForm)xmlHandler.read(classList,new ByteArrayInputStream(outputStream.toByteArray()));
  assertTrue(jobForm.equals(loadedForm));
}","/** 
 * An operation that tests xml persistence on JobLauncherForm.
 * @throws IOException 
 * @throws JAXBException 
 * @throws NullPointerException 
 */
@Test public void checkXMLPersistence() throws NullPointerException, JAXBException, IOException {
  JobLauncherForm jobForm=new JobLauncherForm();
  Form loadedForm=new JobLauncherForm();
  ArrayList<String> actions=new ArrayList<String>();
  ICEJAXBHandler xmlHandler=new ICEJAXBHandler();
  ArrayList<Class> classList=new ArrayList<Class>();
  classList.add(JobLauncherForm.class);
  classList.addAll(new ICEJAXBClassProvider().getClasses());
  jobForm.setName(""String_Node_Str"");
  jobForm.setDescription(""String_Node_Str"");
  jobForm.setId(3);
  jobForm.enableMPI(2,4,2);
  jobForm.enableOpenMP(2,4,3);
  actions.add(""String_Node_Str"");
  jobForm.setActionList(actions);
  jobForm.setInputFiles(""String_Node_Str"",""String_Node_Str"",new ArrayList<String>());
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  xmlHandler.write(jobForm,classList,outputStream);
  loadedForm=(Form)xmlHandler.read(classList,new ByteArrayInputStream(outputStream.toByteArray()));
  assertTrue(jobForm.equals(loadedForm));
}",0.9907407407407408
133413,"@Override public void resourceChanged(IResourceChangeEvent event){
  if (event.getType() == IResourceChangeEvent.POST_CHANGE) {
    try {
      event.getDelta().accept(new IResourceDeltaVisitor(){
        public boolean visit(        IResourceDelta delta) throws CoreException {
          for (          ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
            if (delta.getResource().getName().equals(r.getName())) {
              ICEResourcePage.this.update(r);
            }
          }
          return true;
        }
      }
);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
}","@Override public void resourceChanged(IResourceChangeEvent event){
  if (event.getType() == IResourceChangeEvent.POST_CHANGE) {
    try {
      event.getDelta().accept(new IResourceDeltaVisitor(){
        public boolean visit(        IResourceDelta delta) throws CoreException {
          for (          ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
            if (delta.getResource().getName().equals((new File(r.getPath()).getName()))) {
              ICEResourcePage.this.update(r);
            }
          }
          return true;
        }
      }
);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
}",0.9814814814814816
133414,"public boolean visit(IResourceDelta delta) throws CoreException {
  for (  ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
    if (delta.getResource().getName().equals(r.getName())) {
      ICEResourcePage.this.update(r);
    }
  }
  return true;
}","public boolean visit(IResourceDelta delta) throws CoreException {
  for (  ICEResource r : ICEResourcePage.this.resourceComponent.getResources()) {
    if (delta.getResource().getName().equals((new File(r.getPath()).getName()))) {
      ICEResourcePage.this.update(r);
    }
  }
  return true;
}",0.9577464788732394
133415,"/** 
 * Adds the components of the model to the reflectivity page.
 * @see org.eclipse.ice.client.widgets.ICEFormEditor#addPages()
 */
@Override protected void addPages(){
  for (  Component i : iceDataForm.getComponents()) {
    logger.info(""String_Node_Str"" + i.getName() + ""String_Node_Str""+ i.getId());
    i.accept(this);
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty())) {
    DataComponent dataComp=(DataComponent)componentMap.get(""String_Node_Str"").get(0);
    DataComponent outputComp=(DataComponent)componentMap.get(""String_Node_Str"").get(1);
    ListComponent listComp=(ListComponent)componentMap.get(""String_Node_Str"").get(0);
    ResourceComponent resComp=(ResourceComponent)componentMap.get(""String_Node_Str"").get(0);
    ReflectivityPage page=new ReflectivityPage(this,dataComp.getName() + listComp.getName() + resComp.getName()+ outputComp.getName(),""String_Node_Str"");
    super.resourceComponentPage=page;
    page.setResourceComponent(resComp);
    page.setDataComponent(dataComp);
    page.setList(listComp);
    page.setOutputComponent(outputComp);
    try {
      addPage(page);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
    reflectPage=page;
  }
}","/** 
 * Adds the components of the model to the reflectivity page.
 * @see org.eclipse.ice.client.widgets.ICEFormEditor#addPages()
 */
@Override protected void addPages(){
  for (  Component i : iceDataForm.getComponents()) {
    logger.info(""String_Node_Str"" + i.getName() + ""String_Node_Str""+ i.getId());
    i.accept(this);
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty())) {
    DataComponent dataComp=(DataComponent)componentMap.get(""String_Node_Str"").get(0);
    DataComponent outputComp=(DataComponent)componentMap.get(""String_Node_Str"").get(1);
    ListComponent listComp=(ListComponent)componentMap.get(""String_Node_Str"").get(0);
    ResourceComponent resComp=(ResourceComponent)componentMap.get(""String_Node_Str"").get(0);
    ReflectivityPage page=new ReflectivityPage(this,dataComp.getName() + listComp.getName() + resComp.getName()+ outputComp.getName(),""String_Node_Str"");
    page.setResourceComponent(resComp);
    page.setDataComponent(dataComp);
    page.setList(listComp);
    page.setOutputComponent(outputComp);
    resourceComponentPage=page;
    try {
      addPage(page);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
    reflectPage=page;
  }
}",0.9733434881949732
133416,"@Override public void setParent(Shape parent){
  List<AbstractController> parentList=model.getEntitiesByCategory(""String_Node_Str"");
  if (!parentList.isEmpty()) {
    ((Group)parentList.get(0).getRepresentation()).getChildren().remove(view.getRepresentation());
  }
  String operator=parent.getProperty(""String_Node_Str"");
  if (operator != null && OperatorType.valueOf(parent.getProperty(""String_Node_Str"")) == OperatorType.Union) {
    ((Group)parent.getRepresentation()).getChildren().add((Group)view.getRepresentation());
  }
  super.setParent(parent);
}","@Override public void setParent(Shape parent){
  List<AbstractController> parentList=model.getEntitiesByCategory(""String_Node_Str"");
  if (!parentList.isEmpty() && !""String_Node_Str"".equals(parent.getProperty(""String_Node_Str""))) {
    ((Group)parentList.get(0).getRepresentation()).getChildren().remove(view.getRepresentation());
  }
  String operator=parent.getProperty(""String_Node_Str"");
  if (operator != null && OperatorType.valueOf(parent.getProperty(""String_Node_Str"")) == OperatorType.Union) {
    ((Group)parent.getRepresentation()).getChildren().add((Group)view.getRepresentation());
  }
  super.setParent(parent);
}",0.9426644182124788
133417,"@Override public void copy(AbstractController source){
  super.copy(source);
  List<AbstractController> parentList=model.getEntitiesByCategory(""String_Node_Str"");
  if (!parentList.isEmpty()) {
    parentList.get(0).addEntity(this);
  }
}","@Override public void copy(AbstractController source){
  model=new ShapeComponent();
  model.setController(this);
  if (source.getProperty(""String_Node_Str"") == null) {
    model.copy(source.getModel());
    view=new FXShapeView((ShapeComponent)model);
    view.copy(source.getView());
  }
 else {
    view=new FXShapeView();
    model.copy(source.getModel());
    view.copy(source.getView());
  }
  model.register(this);
  view.register(this);
}",0.2865497076023391
133418,"@Override public void refresh(AbstractMeshComponent model){
  if (model.getProperty(""String_Node_Str"") == null) {
    createShape(ShapeType.valueOf(model.getProperty(""String_Node_Str"")));
    Boolean newSelected=""String_Node_Str"".equals(model.getProperty(""String_Node_Str""));
    if (selected != newSelected) {
      selected=newSelected;
      if (selected) {
        shape.setMaterial(selectedMaterial);
        gizmo.setVisible(true);
      }
 else {
        shape.setMaterial(defaultMaterial);
        gizmo.setVisible(false);
      }
    }
  }
}","@Override public void refresh(AbstractMeshComponent model){
  node.getTransforms().setAll(Util.convertTransformation(transformation));
  if (model.getProperty(""String_Node_Str"") == null) {
    createShape(ShapeType.valueOf(model.getProperty(""String_Node_Str"")));
    Boolean newSelected=""String_Node_Str"".equals(model.getProperty(""String_Node_Str""));
    if (selected != newSelected) {
      selected=newSelected;
      if (selected) {
        shape.setMaterial(selectedMaterial);
        gizmo.setVisible(true);
      }
 else {
        shape.setMaterial(defaultMaterial);
        gizmo.setVisible(false);
      }
    }
  }
}",0.9361702127659576
133419,"/** 
 * <p> Opens the replicate dialog box and clones the selected shape to the properties </p>
 */
@Override public void run(){
  AbstractController geometry=(AbstractController)view.treeViewer.getInput();
  ITreeSelection selection=(ITreeSelection)view.treeViewer.getSelection();
  TreePath[] paths=selection.getPaths();
  if (paths.length != 1) {
    return;
  }
  Object selectedObject=paths[0].getLastSegment();
  if (!(selectedObject instanceof Shape)) {
    return;
  }
  Shape selectedShape=(Shape)selectedObject;
  Transformation accumulatedTransformation=(Transformation)selectedShape.getTransformation().clone();
  ReplicateDialog replicateDialog=new ReplicateDialog(view.getSite().getShell());
  if (replicateDialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  int quantity=replicateDialog.getQuantity();
  double[] shift=replicateDialog.getShift();
  if (quantity == 1) {
    return;
  }
  Shape parentShape=(Shape)selectedShape.getEntitiesByCategory(""String_Node_Str"").get(0);
synchronized (geometry) {
    if (parentShape != null) {
      parentShape.removeEntity(selectedShape);
    }
 else {
      geometry.removeEntity(selectedShape);
    }
  }
  ShapeComponent replicateUnionComponent=new ShapeComponent();
  Shape replicateUnion=(Shape)view.getFactory().createController(replicateUnionComponent);
  replicateUnion.setProperty(""String_Node_Str"",""String_Node_Str"");
  replicateUnion.setProperty(""String_Node_Str"",""String_Node_Str"");
  replicateUnion.setProperty(""String_Node_Str"",selectedShape.getProperty(""String_Node_Str""));
  for (int i=1; i <= quantity; i++) {
    Shape clonedShape=(Shape)selectedShape.clone();
    clonedShape.setProperty(""String_Node_Str"",""String_Node_Str"");
    clonedShape.setProperty(""String_Node_Str"",Integer.toString(i));
    clonedShape.setTransformation((Transformation)accumulatedTransformation.clone());
    replicateUnion.addEntity(clonedShape);
    accumulatedTransformation.translate(shift);
  }
  if (parentShape != null) {
synchronized (geometry) {
      parentShape.addEntity(replicateUnion);
    }
    view.treeViewer.refresh(parentShape);
  }
 else {
synchronized (geometry) {
      geometry.addEntity(replicateUnion);
    }
    view.treeViewer.refresh();
  }
  view.treeViewer.expandToLevel(parentShape,1);
}","/** 
 * <p> Opens the replicate dialog box and clones the selected shape to the properties </p>
 */
@Override public void run(){
  AbstractController geometry=(AbstractController)view.treeViewer.getInput();
  ITreeSelection selection=(ITreeSelection)view.treeViewer.getSelection();
  TreePath[] paths=selection.getPaths();
  if (paths.length != 1) {
    return;
  }
  Object selectedObject=paths[0].getLastSegment();
  if (!(selectedObject instanceof Shape)) {
    return;
  }
  Shape selectedShape=(Shape)selectedObject;
  Transformation accumulatedTransformation=(Transformation)selectedShape.getTransformation().clone();
  ReplicateDialog replicateDialog=new ReplicateDialog(view.getSite().getShell());
  if (replicateDialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  int quantity=replicateDialog.getQuantity();
  double[] shift=replicateDialog.getShift();
  if (quantity == 1) {
    return;
  }
  Shape parentShape=(Shape)selectedShape.getEntitiesByCategory(""String_Node_Str"").get(0);
synchronized (geometry) {
    if (parentShape != null) {
      parentShape.removeEntity(selectedShape);
    }
 else {
      geometry.removeEntity(selectedShape);
    }
  }
  ShapeComponent replicateUnionComponent=new ShapeComponent();
  Shape replicateUnion=(Shape)view.getFactory().createController(replicateUnionComponent);
  replicateUnion.setProperty(""String_Node_Str"",""String_Node_Str"");
  replicateUnion.setProperty(""String_Node_Str"",""String_Node_Str"");
  replicateUnion.setProperty(""String_Node_Str"",selectedShape.getProperty(""String_Node_Str""));
  for (int i=1; i <= quantity; i++) {
    Shape clonedShape=(Shape)selectedShape.clone();
    clonedShape.setProperty(""String_Node_Str"",""String_Node_Str"");
    clonedShape.setProperty(""String_Node_Str"",Integer.toString(i));
    clonedShape.setTransformation((Transformation)accumulatedTransformation.clone());
    replicateUnion.addEntity(clonedShape);
    accumulatedTransformation.translate(shift);
  }
  if (parentShape != null) {
synchronized (geometry) {
      parentShape.addEntity(replicateUnion);
      replicateUnion.setParent(parentShape);
    }
    view.treeViewer.refresh(parentShape);
  }
 else {
synchronized (geometry) {
      geometry.addEntity(replicateUnion);
    }
    view.treeViewer.refresh();
  }
  view.treeViewer.expandToLevel(parentShape,1);
}",0.9902152641878668
133420,"@Override public IFormPage[] getPages(Map<String,ArrayList<Component>> componentMap){
  return null;
}","@Override public ArrayList<IFormPage> getPages(FormEditor formEditor,Map<String,ArrayList<Component>> componentMap){
  return null;
}",0.851063829787234
133421,"public void addShapesToNode(Group parentNode,List<AbstractController> shapes){
  for (  AbstractController nativeShape : shapes) {
    if (nativeShape.getProperty(""String_Node_Str"") != null) {
      ShapeType shapeType=ShapeType.None;
      Mesh mesh=null;
      shapeType=ShapeType.valueOf(nativeShape.getProperty(""String_Node_Str""));
      FXShape shape=new FXShape(shapeType);
      shape.getProperties().put(Shape.class,nativeShape);
      shape.getTransforms().setAll(Util.convertTransformation(nativeShape.getTransformation()));
      parentNode.getChildren().add(shape);
    }
 else {
      if (OperatorType.valueOf(nativeShape.getProperty(""String_Node_Str"")) == OperatorType.Union) {
        Group complexShapeNode=new Group();
        complexShapeNode.setId(nativeShape.getProperty(""String_Node_Str""));
        complexShapeNode.getProperties().put(IShape.class,nativeShape);
        complexShapeNode.getTransforms().setAll(Util.convertTransformation(nativeShape.getTransformation()));
        List<AbstractController> childShapes=nativeShape.getEntitiesByCategory(""String_Node_Str"");
        addShapesToNode(complexShapeNode,childShapes);
        parentNode.getChildren().add(complexShapeNode);
      }
    }
  }
}","public void addShapesToNode(Group parentNode,List<AbstractController> shapes){
  for (  AbstractController nativeShape : shapes) {
    if (nativeShape.getProperty(""String_Node_Str"") == null) {
      ShapeType shapeType=ShapeType.None;
      Mesh mesh=null;
      shapeType=ShapeType.valueOf(nativeShape.getProperty(""String_Node_Str""));
      FXShape shape=new FXShape(shapeType);
      shape.getProperties().put(Shape.class,nativeShape);
      shape.getTransforms().setAll(Util.convertTransformation(nativeShape.getTransformation()));
      parentNode.getChildren().add(shape);
    }
 else {
      if (OperatorType.valueOf(nativeShape.getProperty(""String_Node_Str"")) == OperatorType.Union) {
        Group complexShapeNode=new Group();
        complexShapeNode.setId(nativeShape.getProperty(""String_Node_Str""));
        complexShapeNode.getProperties().put(IShape.class,nativeShape);
        complexShapeNode.getTransforms().setAll(Util.convertTransformation(nativeShape.getTransformation()));
        List<AbstractController> childShapes=nativeShape.getEntitiesByCategory(""String_Node_Str"");
        addShapesToNode(complexShapeNode,childShapes);
        parentNode.getChildren().add(complexShapeNode);
      }
    }
  }
}",0.999182338511856
133422,"@Override public void addGeometry(Shape geom){
  super.addGeometry(geom);
  if (fxAttachmentNode == null) {
    fxAttachmentNode=new Group();
  }
  if (knownGeometry == null) {
    knownGeometry=new ArrayList<>();
  }
  if (!knownGeometry.contains(geom)) {
    geom.register(new IVizUpdateableListener(){
      @Override public void update(      IVizUpdateable component){
        ArrayList<Shape> primitiveShapes=new ArrayList<Shape>();
        ArrayList<Shape> complexShapes=new ArrayList<Shape>();
        for (        AbstractController shape : geom.getEntitiesByCategory(""String_Node_Str"")) {
          if (shape.getProperty(""String_Node_Str"") != null) {
            primitiveShapes.add((Shape)shape);
          }
 else {
            complexShapes.add((Shape)shape);
          }
        }
        javafx.application.Platform.runLater(new Runnable(){
          @Override public void run(){
            syncShapes(fxAttachmentNode,primitiveShapes,complexShapes);
          }
        }
);
      }
    }
);
    knownGeometry.add(geom);
  }
}","@Override public void addGeometry(Shape geom){
  super.addGeometry(geom);
  if (fxAttachmentNode == null) {
    fxAttachmentNode=new Group();
  }
  if (knownGeometry == null) {
    knownGeometry=new ArrayList<>();
  }
  if (!knownGeometry.contains(geom)) {
    geom.register(new IVizUpdateableListener(){
      @Override public void update(      IVizUpdateable component){
        ArrayList<Shape> primitiveShapes=new ArrayList<Shape>();
        ArrayList<Shape> complexShapes=new ArrayList<Shape>();
        javafx.application.Platform.runLater(new Runnable(){
          @Override public void run(){
            syncShapes(fxAttachmentNode,geom.getEntitiesByCategory(""String_Node_Str""));
          }
        }
);
      }
    }
);
    knownGeometry.add(geom);
  }
}",0.7969009407858328
133423,"public void syncShapes(Group parentNode,List<Shape> primitiveShapes,List<Shape> complexShapes){
  Shape nodeShape=null;
  int primitiveShapeIndex=-1;
  int complexShapeIndex=-1;
  List<Node> removeNodeIndices=new ArrayList<Node>();
  int numNodeChildren=parentNode.getChildren().size();
  for (int nodeIndex=0; nodeIndex < numNodeChildren; nodeIndex++) {
    Node childSpatial=parentNode.getChildren().get(nodeIndex);
    Group childNode=null;
    try {
      childNode=(Group)childSpatial;
    }
 catch (    ClassCastException e) {
      return;
    }
    if (childSpatial.getProperties().containsKey(Shape.class)) {
      nodeShape=(Shape)childSpatial.getProperties().get(Shape.class);
      primitiveShapeIndex=primitiveShapes.indexOf(nodeShape);
      complexShapeIndex=complexShapes.indexOf(nodeShape);
    }
    if (primitiveShapeIndex >= 0) {
      Shape primitiveShape=primitiveShapes.get(primitiveShapeIndex);
      childSpatial.getTransforms().setAll(Util.convertTransformation(primitiveShape.getTransformation()));
      primitiveShapes.remove(primitiveShapeIndex);
    }
 else     if (complexShapeIndex >= 0) {
      Shape complexShape=complexShapes.get(complexShapeIndex);
      childSpatial.getTransforms().setAll(Util.convertTransformation(complexShape.getTransformation()));
      List<AbstractController> complexShapeChildren=complexShape.getEntitiesByCategory(""String_Node_Str"");
      List<Shape> childPrimitiveShapes=new ArrayList<Shape>();
      List<Shape> childComplexShapes=new ArrayList<Shape>();
      for (      AbstractController complexShapeChild : complexShapeChildren) {
        if (complexShapeChild.getProperty(""String_Node_Str"") != null) {
          childPrimitiveShapes.add((Shape)complexShapeChild);
        }
 else {
          childComplexShapes.add((Shape)complexShapeChild);
        }
      }
      syncShapes(childNode,childPrimitiveShapes,childComplexShapes);
      complexShapes.remove(complexShapeIndex);
    }
 else {
      removeNodeIndices.add(childSpatial);
    }
  }
  for (  Node nodeIndex : removeNodeIndices) {
    nodeIndex.setVisible(false);
    parentNode.getChildren().remove(nodeIndex);
  }
  for (  Shape primitiveShape : primitiveShapes) {
    ShapeType shapeType=ShapeType.None;
    Mesh mesh=null;
    shapeType=ShapeType.valueOf(primitiveShape.getProperty(""String_Node_Str""));
    FXShape shape=new FXShape(shapeType);
    shape.getProperties().put(Shape.class,primitiveShape);
    shape.getTransforms().setAll(Util.convertTransformation(primitiveShape.getTransformation()));
    parentNode.getChildren().add(shape);
  }
  for (  Shape complexShape : complexShapes) {
    if (OperatorType.valueOf(complexShape.getProperty(""String_Node_Str"")) == OperatorType.Union) {
      Group complexShapeNode=new Group();
      complexShapeNode.setId(complexShape.getProperty(""String_Node_Str""));
      complexShapeNode.getProperties().put(IShape.class,complexShape);
      complexShapeNode.getTransforms().setAll(Util.convertTransformation(complexShape.getTransformation()));
      List<AbstractController> shapes=complexShape.getEntitiesByCategory(""String_Node_Str"");
      addShapesToNode(complexShapeNode,shapes);
      parentNode.getChildren().add(complexShapeNode);
    }
  }
}","public void syncShapes(Group parentNode,List<AbstractController> shapeList){
  Shape nodeShape=null;
  int primitiveShapeIndex=-1;
  int complexShapeIndex=-1;
  List<Node> removeNodeIndices=new ArrayList<Node>();
  int numNodeChildren=parentNode.getChildren().size();
  for (int nodeIndex=0; nodeIndex < numNodeChildren; nodeIndex++) {
    Node childSpatial=parentNode.getChildren().get(nodeIndex);
    Group childNode=null;
    try {
      childNode=(Group)childSpatial;
    }
 catch (    ClassCastException e) {
      return;
    }
    if (childSpatial.getProperties().containsKey(Shape.class)) {
      nodeShape=(Shape)childSpatial.getProperties().get(Shape.class);
    }
    childSpatial.getTransforms().setAll(Util.convertTransformation(nodeShape.getTransformation()));
    List<AbstractController> complexShapeChildren=nodeShape.getEntitiesByCategory(""String_Node_Str"");
    if (!complexShapeChildren.isEmpty()) {
      syncShapes(childNode,complexShapeChildren);
    }
  }
  for (  Node nodeIndex : removeNodeIndices) {
    nodeIndex.setVisible(false);
    parentNode.getChildren().remove(nodeIndex);
  }
  for (  AbstractController shape : shapeList) {
    if (shape.getProperty(""String_Node_Str"") == null) {
      ShapeType shapeType=ShapeType.None;
      Mesh mesh=null;
      shapeType=ShapeType.valueOf(shape.getProperty(""String_Node_Str""));
      FXShape fxShape=new FXShape(shapeType);
      fxShape.getProperties().put(Shape.class,shape);
      fxShape.getTransforms().setAll(Util.convertTransformation(shape.getTransformation()));
      parentNode.getChildren().add(fxShape);
    }
 else {
      if (OperatorType.valueOf(shape.getProperty(""String_Node_Str"")) == OperatorType.Union) {
        Group complexShapeNode=new Group();
        complexShapeNode.setId(shape.getProperty(""String_Node_Str""));
        complexShapeNode.getProperties().put(IShape.class,shape);
        complexShapeNode.getTransforms().setAll(Util.convertTransformation(shape.getTransformation()));
        List<AbstractController> shapes=shape.getEntitiesByCategory(""String_Node_Str"");
        addShapesToNode(complexShapeNode,shapes);
        parentNode.getChildren().add(complexShapeNode);
      }
    }
  }
}",0.6245394252026529
133424,"@Override public void update(IVizUpdateable component){
  ArrayList<Shape> primitiveShapes=new ArrayList<Shape>();
  ArrayList<Shape> complexShapes=new ArrayList<Shape>();
  for (  AbstractController shape : geom.getEntitiesByCategory(""String_Node_Str"")) {
    if (shape.getProperty(""String_Node_Str"") != null) {
      primitiveShapes.add((Shape)shape);
    }
 else {
      complexShapes.add((Shape)shape);
    }
  }
  javafx.application.Platform.runLater(new Runnable(){
    @Override public void run(){
      syncShapes(fxAttachmentNode,primitiveShapes,complexShapes);
    }
  }
);
}","@Override public void update(IVizUpdateable component){
  ArrayList<Shape> primitiveShapes=new ArrayList<Shape>();
  ArrayList<Shape> complexShapes=new ArrayList<Shape>();
  javafx.application.Platform.runLater(new Runnable(){
    @Override public void run(){
      syncShapes(fxAttachmentNode,geom.getEntitiesByCategory(""String_Node_Str""));
    }
  }
);
}",0.4994686503719447
133425,"@Override public void run(){
  syncShapes(fxAttachmentNode,primitiveShapes,complexShapes);
}","@Override public void run(){
  syncShapes(fxAttachmentNode,geom.getEntitiesByCategory(""String_Node_Str""));
}",0.72
133426,"/** 
 * A utility operation for processing tasks in the event loop.
 * @param currentTask The current task to be processed.
 */
private void processTask(QueuedTask currentTask){
  String name=null;
  IFile file=null;
  try {
    if (currentTask != null) {
      if (""String_Node_Str"".equals(currentTask.task) || ""String_Node_Str"".equals(currentTask.task)) {
        name=currentTask.item.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        file=currentTask.item.getProject().getFile(name);
      }
      if (""String_Node_Str"".equals(currentTask.task) && !(currentTask.item instanceof ReactorAnalyzer)) {
        writeFile(currentTask.item,file);
        itemIdMap.put(currentTask.item.getId(),file.getName());
      }
 else       if (""String_Node_Str"".equals(currentTask.task)) {
        Thread.currentThread();
        Thread.sleep(1000);
        if (file.exists()) {
          file.delete(true,null);
        }
        itemIdMap.remove(currentTask.item.getId());
      }
 else       if (""String_Node_Str"".equals(currentTask.task)) {
        writeFile(currentTask.form,currentTask.file);
      }
 else       if (""String_Node_Str"".equals(currentTask.task)) {
        String oldFile=itemIdMap.get(currentTask.item.getId());
        if (oldFile != null) {
          itemIdMap.put(currentTask.item.getId(),currentTask.file.getName());
          Thread.currentThread();
          Thread.sleep(1000);
          IProject project=currentTask.item.getProject();
          IFile oldFileHandle=project.getFile(oldFile);
          if (oldFileHandle.exists()) {
            oldFileHandle.move(currentTask.file.getProjectRelativePath(),true,null);
          }
        }
      }
    }
 else {
      Thread.currentThread();
      Thread.sleep(1000);
    }
  }
 catch (  InterruptedException|CoreException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  return;
}","/** 
 * A utility operation for processing tasks in the event loop.
 * @param currentTask The current task to be processed.
 */
private void processTask(QueuedTask currentTask){
  String name=null;
  IFile file=null;
  try {
    if (currentTask != null) {
      if (""String_Node_Str"".equals(currentTask.task) || ""String_Node_Str"".equals(currentTask.task)) {
        name=currentTask.item.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        file=currentTask.item.getProject().getFile(name);
      }
      if (""String_Node_Str"".equals(currentTask.task) && !(currentTask.item instanceof ReactorAnalyzer)) {
        writeFile(currentTask.item,file);
        itemIdMap.put(currentTask.item.getId(),file.getName());
      }
 else       if (""String_Node_Str"".equals(currentTask.task)) {
        Thread.currentThread();
        Thread.sleep(100);
        if (file.exists()) {
          file.delete(true,null);
        }
        itemIdMap.remove(currentTask.item.getId());
      }
 else       if (""String_Node_Str"".equals(currentTask.task)) {
        writeFile(currentTask.form,currentTask.file);
      }
 else       if (""String_Node_Str"".equals(currentTask.task)) {
        String oldFile=itemIdMap.get(currentTask.item.getId());
        if (oldFile != null) {
          itemIdMap.put(currentTask.item.getId(),currentTask.file.getName());
          Thread.currentThread();
          Thread.sleep(1000);
          IProject project=currentTask.item.getProject();
          IFile oldFileHandle=project.getFile(oldFile);
          if (oldFileHandle.exists()) {
            oldFileHandle.move(currentTask.file.getProjectRelativePath(),true,null);
          }
        }
      }
    }
 else {
      Thread.currentThread();
      Thread.sleep(1000);
    }
  }
 catch (  InterruptedException|CoreException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  return;
}",0.5906110674009966
133427,"/** 
 * <p> This is an alternative constructor that allows the ICEFormEditor to be injected. It is primarily used for testing but may have other uses. </p>
 * @param editor <p> The instance of ICEFormEditor that should be used by the Widget. </p>
 */
public EclipseFormWidget(ICEFormEditor editor){
  this();
  ICEFormEditor=editor;
}","/** 
 * <p> This is an alternative constructor that allows the ICEFormEditor to be injected. It is primarily used for testing but may have other uses. </p>
 * @param editor <p> The instance of ICEFormEditor that should be used by the Widget. </p>
 */
public EclipseFormWidget(ICEFormEditor editor){
  this();
  ICEFormEditor=editor;
  IEditorInput input=ICEFormEditor.getEditorInput();
  if (input instanceof ICEFormInput) {
    ICEFormInput formInput=(ICEFormInput)input;
    widgetForm=formInput.getForm();
  }
}",0.7877358490566038
133428,"/** 
 * This operation overrides init so that the ICE Form, passed as an IEditorInput, can be stored.
 * @param site the site on the workbench where the Form is drawn
 * @param input the input for this editor
 */
@Override public void init(IEditorSite site,IEditorInput input) throws RuntimeException {
  IClient client=null;
  try {
    client=IClient.getClient();
  }
 catch (  CoreException e1) {
    e1.printStackTrace();
  }
  setSite(site);
  if (input instanceof ICEFormInput) {
    ICEFormInput=(ICEFormInput)input;
    iceDataForm=ICEFormInput.getForm();
    setPartName(iceDataForm.getName() + ""String_Node_Str"");
    setInput(input);
  }
 else   if (input instanceof FileEditorInput && client != null) {
    IFile formFile=((FileEditorInput)input).getFile();
    iceDataForm=client.loadItem(formFile);
    logger.info(""String_Node_Str"");
    ICEFormInput=new ICEFormInput(iceDataForm);
    setInput(ICEFormInput);
    setPartName(input.getName());
    try {
      registerUpdateListener(IUpdateEventListener.getUpdateEventListener());
      registerProcessListener(IProcessEventListener.getProcessEventListener());
      registerResourceProvider(ISimpleResourceProvider.getSimpleResourceProvider());
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (  Identifiable i : client.getItems()) {
    if (iceDataForm.getItemID() == i.getId()) {
      itemName=i.getClass().getSimpleName() + ""String_Node_Str"" + i.getId();
      break;
    }
  }
  iceDataForm.register(this);
  return;
}","/** 
 * This operation overrides init so that the ICE Form, passed as an IEditorInput, can be stored.
 * @param site the site on the workbench where the Form is drawn
 * @param input the input for this editor
 */
@Override public void init(IEditorSite site,IEditorInput input) throws RuntimeException {
  IClient client=null;
  try {
    client=IClient.getClient();
  }
 catch (  CoreException e1) {
    e1.printStackTrace();
  }
  setSite(site);
  if (input instanceof ICEFormInput) {
    ICEFormInput=(ICEFormInput)input;
    iceDataForm=ICEFormInput.getForm();
    setPartName(iceDataForm.getName() + ""String_Node_Str"");
    setInput(input);
  }
 else   if (input instanceof FileEditorInput && client != null) {
    IFile formFile=((FileEditorInput)input).getFile();
    iceDataForm=client.loadItem(formFile);
    logger.info(""String_Node_Str"");
    ICEFormInput=new ICEFormInput(iceDataForm);
    setInput(ICEFormInput);
    client.addFormWidget(new EclipseFormWidget(this));
    setPartName(input.getName());
    try {
      registerUpdateListener(IUpdateEventListener.getUpdateEventListener());
      registerProcessListener(IProcessEventListener.getProcessEventListener());
      registerResourceProvider(ISimpleResourceProvider.getSimpleResourceProvider());
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (  Identifiable i : client.getItems()) {
    if (iceDataForm.getItemID() == i.getId()) {
      itemName=i.getClass().getSimpleName() + ""String_Node_Str"" + i.getId();
      break;
    }
  }
  iceDataForm.register(this);
  return;
}",0.9836552748885586
133429,"/** 
 * Mutator method for the held geometry
 * @param newGeometry the new Geometry to hold
 */
public void setGeometry(Shape newGeometry){
  geometry=newGeometry;
  geometry.register(this);
  notifyListeners();
}","/** 
 * Mutator method for the held geometry
 * @param newGeometry the new Geometry to hold
 */
public void setGeometry(Shape newGeometry){
  geometry=newGeometry;
  geometry.setProperty(""String_Node_Str"",""String_Node_Str"");
  geometry.register(this);
  notifyListeners();
}",0.8747433264887063
133430,"@Override public void setParent(Shape parent){
  List<AbstractController> parentList=model.getEntitiesByCategory(""String_Node_Str"");
  if (!parentList.isEmpty()) {
    ((Group)parentList.get(0).getRepresentation()).getChildren().remove(view.getRepresentation());
  }
  String operator=parent.getProperty(""String_Node_Str"");
  if (operator != null && OperatorType.valueOf(parent.getProperty(""String_Node_Str"")) == OperatorType.Union) {
    ((Group)parent.getRepresentation()).getChildren().remove(view.getRepresentation());
  }
  super.setParent(parent);
}","@Override public void setParent(Shape parent){
  List<AbstractController> parentList=model.getEntitiesByCategory(""String_Node_Str"");
  if (!parentList.isEmpty()) {
    ((Group)parentList.get(0).getRepresentation()).getChildren().remove(view.getRepresentation());
  }
  String operator=parent.getProperty(""String_Node_Str"");
  if (operator != null && OperatorType.valueOf(parent.getProperty(""String_Node_Str"")) == OperatorType.Union) {
    ((Group)parent.getRepresentation()).getChildren().add((Group)view.getRepresentation());
  }
  super.setParent(parent);
}",0.9838420107719928
133431,"/** 
 * Sets the representation to the appropriate type of Shape3D.
 * @param type The type of shape to display
 */
private void createShape(ShapeType type){
  if (type == null) {
    return;
  }
  boolean initial=(shape == null ? true : false);
  Shape3D prevShape=null;
switch (type) {
case Cone:
    return;
case Cube:
  if (!(shape instanceof Box)) {
    prevShape=shape;
    node.getChildren().remove(shape);
    Box box=new Box(50,50,50);
    defaultMaterial=new PhongMaterial(Color.rgb(50,50,255));
    defaultMaterial.setSpecularColor(Color.WHITE);
    shape=box;
  }
break;
case Cylinder:
if (!(shape instanceof Cylinder)) {
prevShape=shape;
Cylinder cyl=new Cylinder(50,50);
defaultMaterial=new PhongMaterial(Color.rgb(0,181,255));
defaultMaterial.setSpecularColor(Color.WHITE);
cyl.setMaterial(defaultMaterial);
shape=cyl;
}
break;
case None:
return;
case Sphere:
if (!(shape instanceof Sphere)) {
prevShape=shape;
Sphere sphere=new Sphere(50,50);
defaultMaterial=new PhongMaterial(Color.rgb(131,0,157));
defaultMaterial.setSpecularColor(Color.WHITE);
sphere.setMaterial(defaultMaterial);
shape=sphere;
}
break;
case Tube:
if (!(shape instanceof Cylinder)) {
prevShape=shape;
Cylinder tube=new Cylinder(50,50);
defaultMaterial=new PhongMaterial(Color.rgb(0,131,157));
defaultMaterial.setSpecularColor(Color.WHITE);
shape=tube;
}
break;
default :
return;
}
if (prevShape != null) {
node.getChildren().remove(prevShape);
node.getChildren().add(shape);
}
 else if (initial) {
node.getChildren().add(shape);
}
}","/** 
 * Sets the representation to the appropriate type of Shape3D.
 * @param type The type of shape to display
 */
private void createShape(ShapeType type){
  if (type == null) {
    return;
  }
  boolean initial=(shape == null ? true : false);
  Shape3D prevShape=null;
switch (type) {
case Cone:
    return;
case Cube:
  if (!(shape instanceof Box)) {
    prevShape=shape;
    node.getChildren().remove(shape);
    Box box=new Box(50,50,50);
    defaultMaterial=new PhongMaterial(Color.rgb(50,50,255));
    defaultMaterial.setSpecularColor(Color.WHITE);
    box.setMaterial(defaultMaterial);
    shape=box;
  }
break;
case Cylinder:
if (!(shape instanceof Cylinder)) {
prevShape=shape;
Cylinder cyl=new Cylinder(50,50);
defaultMaterial=new PhongMaterial(Color.rgb(0,181,255));
defaultMaterial.setSpecularColor(Color.WHITE);
cyl.setMaterial(defaultMaterial);
shape=cyl;
}
break;
case None:
return;
case Sphere:
if (!(shape instanceof Sphere)) {
prevShape=shape;
Sphere sphere=new Sphere(50,50);
defaultMaterial=new PhongMaterial(Color.rgb(131,0,157));
defaultMaterial.setSpecularColor(Color.WHITE);
sphere.setMaterial(defaultMaterial);
shape=sphere;
}
break;
case Tube:
if (!(shape instanceof Cylinder)) {
prevShape=shape;
Cylinder tube=new Cylinder(50,50);
defaultMaterial=new PhongMaterial(Color.rgb(0,131,157));
defaultMaterial.setSpecularColor(Color.WHITE);
tube.setMaterial(defaultMaterial);
shape=tube;
}
break;
default :
return;
}
if (prevShape != null) {
node.getChildren().remove(prevShape);
node.getChildren().add(shape);
}
 else if (initial) {
node.getChildren().add(shape);
}
}",0.9765197812801544
133432,"/** 
 * The default constructor.
 * @param model The model which this view will display
 */
public FXShapeView(ShapeComponent model){
  super();
  gizmo=new TransformGizmo(100);
  gizmo.showHandles(false);
  gizmo.setVisible(false);
  node=new Group();
  node.setId(model.getProperty(""String_Node_Str""));
  node.getTransforms().setAll(Util.convertTransformation(transformation));
  createShape(ShapeType.valueOf(model.getProperty(""String_Node_Str"")));
  node.getChildren().add(gizmo);
}","/** 
 * The default constructor.
 * @param model The model which this view will display
 */
public FXShapeView(ShapeComponent model){
  super();
  node=new Group();
  node.setId(model.getProperty(""String_Node_Str""));
  node.getTransforms().setAll(Util.convertTransformation(transformation));
  if (""String_Node_Str"".equals(model.getProperty(""String_Node_Str""))) {
    gizmo=new TransformGizmo(100);
    gizmo.showHandles(false);
  }
 else {
    gizmo=new TransformGizmo(0);
  }
  gizmo.setVisible(false);
  node.getChildren().add(gizmo);
  createShape(ShapeType.valueOf(model.getProperty(""String_Node_Str"")));
}",0.5742935278030994
133433,"@Override public void addGeometry(Shape geom){
  super.addGeometry(geom);
  if (fxAttachmentNode == null) {
    fxAttachmentNode=new Group();
  }
  if (knownGeometry == null) {
    knownGeometry=new ArrayList<>();
  }
  if (!knownGeometry.contains(geom)) {
    geom.register(new IVizUpdateableListener(){
      @Override public void update(      IVizUpdateable component){
        javafx.application.Platform.runLater(new Runnable(){
          @Override public void run(){
            fxAttachmentNode.getChildren().clear();
            for (            AbstractController child : geom.getEntities()) {
              if (!fxAttachmentNode.getChildren().contains(child)) {
                fxAttachmentNode.getChildren().add((Group)child.getRepresentation());
              }
            }
          }
        }
);
      }
    }
);
    knownGeometry.add(geom);
  }
}","@Override public void addGeometry(Shape geom){
  super.addGeometry(geom);
  if (fxAttachmentNode == null) {
    fxAttachmentNode=new Group();
  }
  if (knownGeometry == null) {
    knownGeometry=new ArrayList<>();
  }
  if (!knownGeometry.contains(geom)) {
    geom.register(new IVizUpdateableListener(){
      @Override public void update(      IVizUpdateable component){
        javafx.application.Platform.runLater(new Runnable(){
          @Override public void run(){
            fxAttachmentNode.getChildren().clear();
            for (            AbstractController child : geom.getEntities()) {
              fxAttachmentNode.getChildren().add((Group)child.getRepresentation());
            }
          }
        }
);
      }
    }
);
    knownGeometry.add(geom);
  }
}",0.7982937233394272
133434,"@Override public void update(IVizUpdateable component){
  javafx.application.Platform.runLater(new Runnable(){
    @Override public void run(){
      fxAttachmentNode.getChildren().clear();
      for (      AbstractController child : geom.getEntities()) {
        if (!fxAttachmentNode.getChildren().contains(child)) {
          fxAttachmentNode.getChildren().add((Group)child.getRepresentation());
        }
      }
    }
  }
);
}","@Override public void update(IVizUpdateable component){
  javafx.application.Platform.runLater(new Runnable(){
    @Override public void run(){
      fxAttachmentNode.getChildren().clear();
      for (      AbstractController child : geom.getEntities()) {
        fxAttachmentNode.getChildren().add((Group)child.getRepresentation());
      }
    }
  }
);
}",0.8335451080050826
133435,"@Override public void run(){
  fxAttachmentNode.getChildren().clear();
  for (  AbstractController child : geom.getEntities()) {
    if (!fxAttachmentNode.getChildren().contains(child)) {
      fxAttachmentNode.getChildren().add((Group)child.getRepresentation());
    }
  }
}","@Override public void run(){
  fxAttachmentNode.getChildren().clear();
  for (  AbstractController child : geom.getEntities()) {
    fxAttachmentNode.getChildren().add((Group)child.getRepresentation());
  }
}",0.8612836438923396
133436,"/** 
 * @param axisSize
 */
public TransformGizmo(double axisSize){
  super();
  PhongMaterial axisXMaterial=new PhongMaterial();
  axisXMaterial.setDiffuseColor(Color.RED);
  PhongMaterial axisYMaterial=new PhongMaterial();
  axisYMaterial.setDiffuseColor(Color.GREEN);
  PhongMaterial axisZMaterial=new PhongMaterial();
  axisZMaterial.setDiffuseColor(Color.BLUE);
  PhongMaterial handleMaterial=new PhongMaterial();
  handleMaterial.setDiffuseColor(Color.BLUE);
  setDepthTest(DepthTest.DISABLE);
  handleX=new Box(15,15,15);
  handleX.setDepthTest(DepthTest.DISABLE);
  handleX.setMaterial(handleMaterial);
  handleX.setTranslateX(axisSize);
  handleX.setTranslateY(0);
  handleX.setTranslateZ(0);
  axisX=new Box(axisSize,axisWidth,axisWidth);
  axisX.setDepthTest(DepthTest.DISABLE);
  axisX.setMaterial(axisXMaterial);
  axisX.setTranslateX(axisSize / 2f);
  axisX.setTranslateY(0);
  axisX.setTranslateZ(0);
  handleY=new Box(15,15,15);
  handleY.setDepthTest(DepthTest.DISABLE);
  handleY.setMaterial(handleMaterial);
  handleY.setTranslateX(0);
  handleY.setTranslateY(-axisSize);
  handleY.setTranslateZ(0);
  axisY=new Box(axisWidth,axisSize,axisWidth);
  axisY.setDepthTest(DepthTest.DISABLE);
  axisY.setMaterial(axisYMaterial);
  axisY.setTranslateX(0);
  axisY.setTranslateY((axisSize / 2f));
  axisY.setTranslateZ(0);
  handleZ=new Box(15,15,15);
  handleZ.setDepthTest(DepthTest.DISABLE);
  handleZ.setMaterial(handleMaterial);
  handleZ.setTranslateX(0);
  handleZ.setTranslateY(0);
  handleZ.setTranslateZ(axisSize);
  axisZ=new Box(axisWidth,axisWidth,axisSize);
  axisZ.setDepthTest(DepthTest.DISABLE);
  axisZ.setMaterial(axisZMaterial);
  axisZ.setTranslateX(0);
  axisZ.setTranslateY(0);
  axisZ.setTranslateZ(axisSize / 2f);
  ObservableList<Node> children=getChildren();
  children.add(handleX);
  children.add(handleY);
  children.add(handleZ);
  children.add(axisX);
  children.add(axisY);
  children.add(axisZ);
}","/** 
 * @param axisSize
 */
public TransformGizmo(double axisSize){
  super();
  if (axisSize > 0) {
    PhongMaterial axisXMaterial=new PhongMaterial();
    axisXMaterial.setDiffuseColor(Color.RED);
    PhongMaterial axisYMaterial=new PhongMaterial();
    axisYMaterial.setDiffuseColor(Color.GREEN);
    PhongMaterial axisZMaterial=new PhongMaterial();
    axisZMaterial.setDiffuseColor(Color.BLUE);
    PhongMaterial handleMaterial=new PhongMaterial();
    handleMaterial.setDiffuseColor(Color.BLUE);
    setDepthTest(DepthTest.DISABLE);
    handleX=new Box(15,15,15);
    handleX.setDepthTest(DepthTest.DISABLE);
    handleX.setMaterial(handleMaterial);
    handleX.setTranslateX(axisSize);
    handleX.setTranslateY(0);
    handleX.setTranslateZ(0);
    axisX=new Box(axisSize,axisWidth,axisWidth);
    axisX.setDepthTest(DepthTest.DISABLE);
    axisX.setMaterial(axisXMaterial);
    axisX.setTranslateX(axisSize / 2f);
    axisX.setTranslateY(0);
    axisX.setTranslateZ(0);
    handleY=new Box(15,15,15);
    handleY.setDepthTest(DepthTest.DISABLE);
    handleY.setMaterial(handleMaterial);
    handleY.setTranslateX(0);
    handleY.setTranslateY(-axisSize);
    handleY.setTranslateZ(0);
    axisY=new Box(axisWidth,axisSize,axisWidth);
    axisY.setDepthTest(DepthTest.DISABLE);
    axisY.setMaterial(axisYMaterial);
    axisY.setTranslateX(0);
    axisY.setTranslateY((axisSize / 2f));
    axisY.setTranslateZ(0);
    handleZ=new Box(15,15,15);
    handleZ.setDepthTest(DepthTest.DISABLE);
    handleZ.setMaterial(handleMaterial);
    handleZ.setTranslateX(0);
    handleZ.setTranslateY(0);
    handleZ.setTranslateZ(axisSize);
    axisZ=new Box(axisWidth,axisWidth,axisSize);
    axisZ.setDepthTest(DepthTest.DISABLE);
    axisZ.setMaterial(axisZMaterial);
    axisZ.setTranslateX(0);
    axisZ.setTranslateY(0);
    axisZ.setTranslateZ(axisSize / 2f);
    ObservableList<Node> children=getChildren();
    children.add(handleX);
    children.add(handleY);
    children.add(handleZ);
    children.add(axisX);
    children.add(axisY);
    children.add(axisZ);
  }
}",0.8615537848605578
133437,"/** 
 * Setter function for the part's transformation.
 * @param newTransformation The transformation to apply to this part.
 */
public void setTransformation(Transformation newTransformation){
  transformation=newTransformation;
  notifyListeners();
}","/** 
 * Setter function for the part's transformation.
 * @param newTransformation The transformation to apply to this part.
 */
public void setTransformation(Transformation newTransformation){
  transformation=newTransformation;
  update(transformation);
  notifyListeners();
}",0.9509433962264152
133438,"/** 
 * (non-Javadoc)
 * @see org.eclipse.ui.ISaveablePart#doSave(IProgressMonitor monitor)
 */
@Override public void doSave(IProgressMonitor monitor){
  System.out.println(""String_Node_Str"");
  setDirty(false);
  notifyUpdateListeners();
  if (iceDataForm.isReady() && goButton != null) {
    goButton.setEnabled(iceDataForm.isReady());
  }
  for (  IFormPart part : ((ICEFormPage)this.getSelectedPage()).getManagedForm().getParts()) {
    part.refresh();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    setTreeCompositeViewerInput();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    MasterDetailsComponent comp=(MasterDetailsComponent)(componentMap.get(""String_Node_Str"").get(0));
    String name=comp.getName();
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      if (formPage.getPartName().equals(name)) {
        ICEMasterDetailsPage masterPage=(ICEMasterDetailsPage)formPage;
        masterPage.refreshMaster();
      }
    }
  }
  if (!(componentMap.get(""String_Node_Str"")).isEmpty()) {
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      EMFComponent comp=(EMFComponent)componentMap.get(""String_Node_Str"").get(0);
      if (formPage.getPartName().equals(comp.getName())) {
        formPage.doSave(null);
      }
    }
  }
}","/** 
 * (non-Javadoc)
 * @see org.eclipse.ui.ISaveablePart#doSave(IProgressMonitor monitor)
 */
@Override public void doSave(IProgressMonitor monitor){
  setDirty(false);
  notifyUpdateListeners();
  if (iceDataForm.isReady() && goButton != null) {
    goButton.setEnabled(iceDataForm.isReady());
  }
  for (  IFormPart part : ((ICEFormPage)this.getSelectedPage()).getManagedForm().getParts()) {
    part.refresh();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    setTreeCompositeViewerInput();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    MasterDetailsComponent comp=(MasterDetailsComponent)(componentMap.get(""String_Node_Str"").get(0));
    String name=comp.getName();
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      if (formPage.getPartName().equals(name)) {
        ICEMasterDetailsPage masterPage=(ICEMasterDetailsPage)formPage;
        masterPage.refreshMaster();
      }
    }
  }
  if (!(componentMap.get(""String_Node_Str"")).isEmpty()) {
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      EMFComponent comp=(EMFComponent)componentMap.get(""String_Node_Str"").get(0);
      if (formPage.getPartName().equals(comp.getName())) {
        formPage.doSave(null);
      }
    }
  }
}",0.9849209268113276
133439,"/** 
 * This operation overrides init so that the ICE Form, passed as an IEditorInput, can be stored.
 * @param site the site on the workbench where the Form is drawn
 * @param input the input for this editor
 */
@Override public void init(IEditorSite site,IEditorInput input) throws RuntimeException {
  setPartName(input.getName());
  setSite(site);
  if (input instanceof ICEFormInput) {
    ICEFormInput=(ICEFormInput)input;
    iceDataForm=ICEFormInput.getForm();
    setInput(input);
  }
 else   if (input instanceof FileEditorInput) {
    IFile formFile=((FileEditorInput)input).getFile();
    try {
      IClient client=IClient.getClient();
      iceDataForm=client.loadItem(formFile);
      logger.info(""String_Node_Str"");
      ICEFormInput=new ICEFormInput(iceDataForm);
      setInput(ICEFormInput);
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  iceDataForm.register(this);
  return;
}","/** 
 * This operation overrides init so that the ICE Form, passed as an IEditorInput, can be stored.
 * @param site the site on the workbench where the Form is drawn
 * @param input the input for this editor
 */
@Override public void init(IEditorSite site,IEditorInput input) throws RuntimeException {
  setPartName(input.getName());
  setSite(site);
  if (input instanceof ICEFormInput) {
    ICEFormInput=(ICEFormInput)input;
    iceDataForm=ICEFormInput.getForm();
    setInput(input);
  }
 else   if (input instanceof FileEditorInput) {
    IFile formFile=((FileEditorInput)input).getFile();
    try {
      IClient client=IClient.getClient();
      iceDataForm=client.loadItem(formFile);
      logger.info(""String_Node_Str"");
      ICEFormInput=new ICEFormInput(iceDataForm);
      setInput(ICEFormInput);
      registerUpdateListener(IUpdateEventListener.getUpdateEventListener());
      registerProcessListener(IProcessEventListener.getProcessEventListener());
      registerResourceProvider(ISimpleResourceProvider.getSimpleResourceProvider());
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  iceDataForm.register(this);
  return;
}",0.8976311336717429
133440,"/** 
 * (non-Javadoc)
 * @see IObservableWidget#notifyUpdateListeners()
 */
@Override public void notifyUpdateListeners(){
  for (  IUpdateEventListener eventListener : updateListeners) {
    System.out.println(""String_Node_Str"" + eventListener.getClass().toString());
    eventListener.formUpdated(iceDataForm);
  }
  return;
}","/** 
 * (non-Javadoc)
 * @see IObservableWidget#notifyUpdateListeners()
 */
@Override public void notifyUpdateListeners(){
  for (  IUpdateEventListener eventListener : updateListeners) {
    eventListener.formUpdated(iceDataForm);
  }
  return;
}",0.6852173913043478
133441,"@Override public Item getInstance(IProject projectSpace){
  BatMLModel batML=new BatMLModel(projectSpace);
  batML.setItemBuilderName(getItemName());
  return batML;
}","@Override public Item getInstance(IProject projectSpace){
  Item batML=new BatMLModel(projectSpace);
  batML.setItemBuilderName(getItemName());
  return batML;
}",0.9695121951219512
133442,"/** 
 * This operation provides a deep copy of the EMFComponent.
 */
@Override public Object clone(){
  EMFComponent emfComponent=new EMFComponent();
  emfComponent.copy(this);
  return emfComponent;
}","/** 
 * This operation provides a deep copy of the EMFComponent.
 */
@Override public Object clone(){
  EMFComponent emfComponent=new EMFComponent();
  if (iceEMFTree.getEcoreMetaData() != null) {
    emfComponent.iceEMFTree.setECoreNodeMetaData(iceEMFTree.getEcoreMetaData());
  }
  emfComponent.copy(this);
  return emfComponent;
}",0.7528089887640449
133443,"/** 
 * This operation performs a deep copy of the attributes of another EMFTreeComposite into the current EMFTreeComposite. It copies ALL of the children of the EMFTreeComposite, data and child nodes alike.
 * @param otherTreeComposite
 */
public void copy(EMFTreeComposite otherTreeComposite){
  if (otherTreeComposite == null) {
    return;
  }
  ecoreNodeMetaData=otherTreeComposite.ecoreNodeMetaData;
  ecoreNode=EcoreUtil.create(ecoreNodeMetaData);
  super.copy(otherTreeComposite,true);
  return;
}","/** 
 * This operation performs a deep copy of the attributes of another EMFTreeComposite into the current EMFTreeComposite. It copies ALL of the children of the EMFTreeComposite, data and child nodes alike.
 * @param otherTreeComposite
 */
public void copy(EMFTreeComposite otherTreeComposite){
  if (otherTreeComposite == null) {
    return;
  }
  if (otherTreeComposite.ecoreNodeMetaData != null) {
    ecoreNodeMetaData=otherTreeComposite.ecoreNodeMetaData;
    ecoreNode=EcoreUtil.create(ecoreNodeMetaData);
  }
  super.copy(otherTreeComposite,true);
  return;
}",0.9421641791044776
133444,"@Override public void stop(BundleContext context) throws Exception {
  itemManager.persistItems();
  bundleContext.ungetService(httpServiceRef);
  registration.unregister();
}","@Override public void stop(BundleContext context) throws Exception {
  itemManager.persistItems();
  if (httpServiceRef != null) {
    bundleContext.ungetService(httpServiceRef);
  }
  registration.unregister();
}",0.9020618556701032
133445,"/** 
 * @throws java.lang.Exception
 */
@BeforeClass public static void setUpBeforeClass() throws Exception {
  String separator=System.getProperty(""String_Node_Str"");
  String userHome=System.getProperty(""String_Node_Str"");
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  IProject project=null;
  String projectName=""String_Node_Str"";
  String filename=""String_Node_Str"";
  IPath projectPath=new Path(userHome + separator + ""String_Node_Str""+ separator+ projectName+ separator+ ""String_Node_Str"");
  try {
    IProjectDescription desc=ResourcesPlugin.getWorkspace().loadProjectDescription(projectPath);
    project=workspaceRoot.getProject(desc.getName());
    project.create(desc,new NullProgressMonitor());
    if (project.exists() && !project.isOpen()) {
      project.open(new NullProgressMonitor());
    }
    project.refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
    testFile=project.getFile(filename);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  reader=new CSVReader();
  return;
}","/** 
 * @throws java.lang.Exception
 */
@BeforeClass public static void setUpBeforeClass() throws Exception {
  String separator=System.getProperty(""String_Node_Str"");
  String userHome=System.getProperty(""String_Node_Str"");
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  IProject project=null;
  String projectName=""String_Node_Str"";
  String filename=""String_Node_Str"";
  IPath projectPath=new Path(userHome + separator + ""String_Node_Str""+ separator+ projectName+ separator+ ""String_Node_Str"");
  try {
    IProjectDescription desc=ResourcesPlugin.getWorkspace().loadProjectDescription(projectPath);
    project=workspaceRoot.getProject(desc.getName());
    if (!project.exists()) {
      project.create(desc,new NullProgressMonitor());
    }
    if (project.exists() && !project.isOpen()) {
      project.open(new NullProgressMonitor());
    }
    project.refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
    testFile=project.getFile(filename);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  reader=new CSVReader();
  return;
}",0.9829728485964104
133446,"/** 
 * Test method for   {@link org.eclipse.ice.io.csv.CSVReader#getReaderType()}.
 */
@Test public void testGetReaderType(){
  assertEquals(""String_Node_Str"",reader.getReaderType());
}","/** 
 * Test method for  {@link org.eclipse.ice.io.csv.SpaceDelimitedReader#getReaderType()}.
 */
@Test public void testGetReaderType(){
  assertEquals(""String_Node_Str"",reader.getReaderType());
}",0.9581151832460733
133447,"/** 
 * @throws java.lang.Exception
 */
@BeforeClass public static void setUpBeforeClass() throws Exception {
  String separator=System.getProperty(""String_Node_Str"");
  String userHome=System.getProperty(""String_Node_Str"");
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  IProject project=null;
  String projectName=""String_Node_Str"";
  String filename=""String_Node_Str"";
  IPath projectPath=new Path(userHome + separator + ""String_Node_Str""+ separator+ projectName+ separator+ ""String_Node_Str"");
  try {
    IProjectDescription desc=ResourcesPlugin.getWorkspace().loadProjectDescription(projectPath);
    project=workspaceRoot.getProject(desc.getName());
    project.create(desc,new NullProgressMonitor());
    if (project.exists() && !project.isOpen()) {
      project.open(new NullProgressMonitor());
    }
    project.refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
    testFile=project.getFile(filename);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  reader=new SpaceDelimitedReader();
  return;
}","/** 
 * @throws java.lang.Exception
 */
@BeforeClass public static void setUpBeforeClass() throws Exception {
  String separator=System.getProperty(""String_Node_Str"");
  String userHome=System.getProperty(""String_Node_Str"");
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  IProject project=null;
  String projectName=""String_Node_Str"";
  String filename=""String_Node_Str"";
  IPath projectPath=new Path(userHome + separator + ""String_Node_Str""+ separator+ projectName+ separator+ ""String_Node_Str"");
  try {
    IProjectDescription desc=ResourcesPlugin.getWorkspace().loadProjectDescription(projectPath);
    project=workspaceRoot.getProject(desc.getName());
    if (!project.exists()) {
      project.create(desc,new NullProgressMonitor());
    }
    if (project.exists() && !project.isOpen()) {
      project.open(new NullProgressMonitor());
    }
    project.refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
    testFile=project.getFile(filename);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  reader=new SpaceDelimitedReader();
  return;
}",0.9831435079726653
133448,"/** 
 * Test method for  {@link org.eclipse.ice.io.csv.CSVReader#findAll(org.eclipse.core.resources.IFile,java.lang.String)}.
 */
public void testFindAll(){
  fail(""String_Node_Str"");
}","/** 
 * Test method for  {@link org.eclipse.ice.io.csv.SpaceDelimitedReader#findAll(org.eclipse.core.resources.IFile,java.lang.String)}.
 */
public void testFindAll(){
  fail(""String_Node_Str"");
}",0.9606299212598424
133449,"/** 
 * Test method for  {@link org.eclipse.ice.io.csv.CSVReader#read(org.eclipse.core.resources.IFile)}.
 * @throws CoreException
 * @throws IOException
 */
@Test public void testRead() throws CoreException, IOException {
  Form form=reader.read(testFile);
  assertTrue(form.getComponents().get(0) instanceof ListComponent);
  ListComponent<String[]> lines=(ListComponent<String[]>)form.getComponents().get(0);
  assertTrue(lines.get(0) instanceof String[]);
  assertEquals(402,lines.size());
  String[] line=lines.get(0);
  assertEquals(4,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  assertEquals(""String_Node_Str"",line[3]);
  line=lines.get(lines.size() - 1);
  assertEquals(4,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  assertEquals(""String_Node_Str"",line[3]);
  return;
}","/** 
 * Test method for  {@link org.eclipse.ice.io.csv.SpaceDelimitedReader#read(org.eclipse.core.resources.IFile)}.
 * @throws CoreException
 * @throws IOException
 */
@Test public void testRead() throws CoreException, IOException {
  Form form=reader.read(testFile);
  assertTrue(form.getComponents().get(0) instanceof ListComponent);
  ListComponent<String[]> lines=(ListComponent<String[]>)form.getComponents().get(0);
  assertTrue(lines.get(0) instanceof String[]);
  assertEquals(402,lines.size());
  String[] line=lines.get(0);
  assertEquals(4,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  assertEquals(""String_Node_Str"",line[3]);
  line=lines.get(lines.size() - 1);
  assertEquals(4,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  assertEquals(""String_Node_Str"",line[3]);
  return;
}",0.9913486005089058
133450,"/** 
 * This method checks that we can give and get valid IReaders and IWriters. 
 */
@Test public void checkAddGetReaderWriter(){
  service=new IOService();
  IReader fakeReader=new IReader(){
    @Override public Form read(    IFile file){
      return new Form();
    }
    @Override public ArrayList<Entry> findAll(    IFile file,    String regex){
      ArrayList<Entry> fakeEntry=new ArrayList<Entry>();
      return fakeEntry;
    }
    @Override public String getReaderType(){
      return ""String_Node_Str"";
    }
  }
;
  IWriter fakeWriter=new IWriter(){
    @Override public void write(    Form formToWrite,    IFile file){
      return;
    }
    @Override public void replace(    IFile file,    String regex,    String value){
      return;
    }
    @Override public String getWriterType(){
      return ""String_Node_Str"";
    }
  }
;
  assertEquals(0,service.getNumberOfReaders());
  assertEquals(0,service.getNumberOfWriters());
  service.addReader(fakeReader);
  assertNotNull(service.getReader(""String_Node_Str""));
  assertTrue(fakeReader == service.getReader(""String_Node_Str""));
  assertEquals(1,service.getNumberOfReaders());
  service.addReader(null);
  assertEquals(1,service.getNumberOfReaders());
  assertNull(service.getReader(""String_Node_Str""));
  service.addWriter(fakeWriter);
  assertNotNull(service.getWriter(""String_Node_Str""));
  assertTrue(fakeWriter == service.getWriter(""String_Node_Str""));
  assertEquals(1,service.getNumberOfWriters());
  service.addWriter(null);
  assertEquals(1,service.getNumberOfWriters());
  assertNull(service.getWriter(""String_Node_Str""));
}","/** 
 * This method checks that we can give and get valid IReaders and IWriters.
 */
@Test public void checkAddGetReaderWriter(){
  service=new IOService();
  IReader fakeReader=new IReader(){
    @Override public Form read(    IFile file){
      return new Form();
    }
    @Override public ArrayList<Entry> findAll(    IFile file,    String regex){
      ArrayList<Entry> fakeEntry=new ArrayList<Entry>();
      return fakeEntry;
    }
    @Override public String getReaderType(){
      return ""String_Node_Str"";
    }
  }
;
  IWriter fakeWriter=new IWriter(){
    @Override public void write(    Form formToWrite,    IFile file){
      return;
    }
    @Override public void replace(    IFile file,    String regex,    String value){
      return;
    }
    @Override public String getWriterType(){
      return ""String_Node_Str"";
    }
  }
;
  int numDefaultReaders=6;
  assertEquals(numDefaultReaders,service.getNumberOfReaders());
  int numDefaultWriters=4;
  assertEquals(numDefaultWriters,service.getNumberOfWriters());
  service.addReader(fakeReader);
  assertNotNull(service.getReader(""String_Node_Str""));
  assertTrue(fakeReader == service.getReader(""String_Node_Str""));
  assertEquals(numDefaultReaders + 1,service.getNumberOfReaders());
  service.addReader(null);
  assertEquals(numDefaultReaders + 1,service.getNumberOfReaders());
  assertNull(service.getReader(""String_Node_Str""));
  service.addWriter(fakeWriter);
  assertNotNull(service.getWriter(""String_Node_Str""));
  assertTrue(fakeWriter == service.getWriter(""String_Node_Str""));
  assertEquals(numDefaultWriters + 1,service.getNumberOfWriters());
  service.addWriter(null);
  assertEquals(numDefaultWriters + 1,service.getNumberOfWriters());
  assertNull(service.getWriter(""String_Node_Str""));
}",0.9493032908390158
133451,"/** 
 * This operation configures the Materials database.
 */
private void getMaterialsDatabase(){
  matDBServiceRef=bundleContext.getServiceReference(IMaterialsDatabase.class);
  IMaterialsDatabase database=bundleContext.getService(matDBServiceRef);
  AbstractModelBuilder.setMaterialsDatabase(database);
  return;
}","/** 
 * This operation configures the Materials database.
 */
private void getMaterialsDatabase(){
  if (bundleContext != null) {
    matDBServiceRef=bundleContext.getServiceReference(IMaterialsDatabase.class);
    IMaterialsDatabase database=bundleContext.getService(matDBServiceRef);
    AbstractModelBuilder.setMaterialsDatabase(database);
  }
  return;
}",0.9392592592592592
133452,"/** 
 * <p>This operation builds the IFormWidget.</p>
 * @return <p>The specialized IFormWidget from the service.</p>
 */
public IFormWidget build();","/** 
 * <p> This operation builds the IFormWidget. </p>
 * @return <p> The specialized IFormWidget from the service. </p>
 */
public IFormWidget build();",0.9867549668874172
133453,"/** 
 * <p>This operation returns the name of the target Form that the Builder will render.</p>
 * @return <p>The name of the Form.</p>
 */
public String getTargetFormName();","/** 
 * <p> This operation returns the name of the target Form that the Builder will render. </p>
 * @return <p> The name of the Form. </p>
 */
public String getTargetFormName();",0.9886363636363636
133454,"/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String host=""String_Node_Str"";
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      logger.error(""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      host=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
    }
    String thisHost=""String_Node_Str"";
    try {
      thisHost=InetAddress.getByName(InetAddress.getLocalHost().getHostName()).getHostAddress();
    }
 catch (    UnknownHostException e) {
      e.printStackTrace();
      logger.error(this.getClass().getName() + ""String_Node_Str"",e);
    }
    if (!thisHost.isEmpty()) {
      createICEUpdaterBlock(thisHost);
    }
    if (populateListOfLauncherFiles() != FormStatus.ReadyToProcess) {
      logger.error(getClass().getName() + ""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(host);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
    outputFile=mooseLauncher.getOutputFile();
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}","/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String host=""String_Node_Str"";
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      logger.error(""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      host=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
    }
    String thisHost=""String_Node_Str"";
    try {
      thisHost=InetAddress.getLocalHost().getCanonicalHostName();
    }
 catch (    UnknownHostException e) {
      e.printStackTrace();
      logger.error(this.getClass().getName() + ""String_Node_Str"",e);
    }
    if (!thisHost.isEmpty()) {
      System.out.println(""String_Node_Str"" + thisHost);
      createICEUpdaterBlock(thisHost);
    }
    if (populateListOfLauncherFiles() != FormStatus.ReadyToProcess) {
      logger.error(getClass().getName() + ""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(host);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
    outputFile=mooseLauncher.getOutputFile();
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}",0.975082767032584
133455,"/** 
 * This method generates the YAML and Action syntax files in the local projectSpace/MOOSE directory from a remotely hosted MOOSE-based application.
 * @param monitor
 */
public FormStatus execute(Dictionary<String,String> map){
  IRemoteProcessService processService=null;
  IRemoteProcess yamlRemoteJob=null, syntaxRemoteJob=null;
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    String errorMessage=""String_Node_Str"";
    return FormStatus.InfoError;
  }
  if (connection.isOpen()) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    processService=connection.getService(IRemoteProcessService.class);
    IRemoteProcessBuilder yamlProcessBuilder=processService.getProcessBuilder(""String_Node_Str"",""String_Node_Str"",appPath + ""String_Node_Str"");
    IRemoteProcessBuilder syntaxProcessBuilder=processService.getProcessBuilder(""String_Node_Str"",""String_Node_Str"",appPath + ""String_Node_Str"");
    yamlProcessBuilder.redirectErrorStream(false);
    syntaxProcessBuilder.redirectErrorStream(false);
    try {
      logger.info(""String_Node_Str"" + ""String_Node_Str"");
      logger.info(""String_Node_Str"" + yamlProcessBuilder.command().toString());
      yamlRemoteJob=yamlProcessBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
      syntaxRemoteJob=syntaxProcessBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
    }
 catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      String errorMessage=""String_Node_Str"";
      return FormStatus.InfoError;
    }
    while (!yamlRemoteJob.isCompleted() && !syntaxRemoteJob.isCompleted()) {
      try {
        Thread.currentThread();
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
    InputStream yamlStream=yamlRemoteJob.getInputStream();
    InputStream syntaxStream=syntaxRemoteJob.getInputStream();
    try {
      String yamlString=IOUtils.toString(yamlStream);
      String syntaxString=IOUtils.toString(syntaxStream);
      String animal=Paths.get(appPath).getFileName().toString();
      Path yamlPath=Paths.get(mooseFolder.getLocation().toOSString() + ""String_Node_Str"" + animal+ ""String_Node_Str"");
      Path syntaxPath=Paths.get(mooseFolder.getLocation().toOSString() + ""String_Node_Str"" + animal+ ""String_Node_Str"");
      if (Files.exists(yamlPath)) {
        Files.delete(yamlPath);
      }
      if (Files.exists(syntaxPath)) {
        Files.delete(syntaxPath);
      }
      Files.write(yamlPath,yamlString.getBytes());
      Files.write(syntaxPath,syntaxString.getBytes());
    }
 catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      String errorMessage=""String_Node_Str"";
      return FormStatus.InfoError;
    }
  }
  return FormStatus.Processed;
}","/** 
 * This method generates the YAML and Action syntax files in the local projectSpace/MOOSE directory from a remotely hosted MOOSE-based application.
 * @param monitor
 */
public FormStatus execute(Dictionary<String,String> map){
  File appFile=new File(appPath);
  IRemoteProcessService processService=null;
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    return FormStatus.InfoError;
  }
  if (connection.isOpen()) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    try {
      String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
      String script=remoteSeparator + ""String_Node_Str"" + remoteSeparator+ ""String_Node_Str"";
      String fileLoc=remoteSeparator + ""String_Node_Str"" + remoteSeparator+ appFile.getName();
      IRemoteFileService fileManager=connection.getService(IRemoteFileService.class);
      IFileStore tmp=fileManager.getResource(script);
      PrintStream p=new PrintStream(tmp.openOutputStream(EFS.NONE,null));
      p.println(""String_Node_Str"");
      p.println(appPath + ""String_Node_Str"" + fileLoc+ ""String_Node_Str"");
      p.println(appPath + ""String_Node_Str"" + fileLoc+ ""String_Node_Str"");
      p.close();
      IFileInfo info=tmp.fetchInfo();
      info.setAttribute(EFS.ATTRIBUTE_EXECUTABLE,true);
      tmp.putInfo(info,EFS.SET_ATTRIBUTES,null);
      processService=connection.getService(IRemoteProcessService.class);
      IRemoteProcessBuilder pb=processService.getProcessBuilder(script);
      IRemoteProcess process=pb.start(IRemoteProcessBuilder.FORWARD_X11);
      while (!process.isCompleted()) {
        try {
          Thread.currentThread();
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
          logger.error(getClass().getName() + ""String_Node_Str"",e);
        }
      }
      IFileStore localMooseFolder=EFS.getLocalFileSystem().fromLocalFile(mooseFolder.getLocation().toFile());
      IFileStore yamlStore=localMooseFolder.getChild(appFile.getName() + ""String_Node_Str"");
      IFileStore actionStore=localMooseFolder.getChild(appFile.getName() + ""String_Node_Str"");
      IFileStore remoteYaml=fileManager.getResource(fileLoc + ""String_Node_Str"");
      IFileStore remoteAction=fileManager.getResource(fileLoc + ""String_Node_Str"");
      remoteYaml.copy(yamlStore,EFS.OVERWRITE,null);
      remoteAction.copy(actionStore,EFS.OVERWRITE,null);
      tmp.delete(EFS.NONE,null);
      remoteYaml.delete(EFS.NONE,null);
      remoteAction.delete(EFS.NONE,null);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return FormStatus.InfoError;
    }
  }
  return FormStatus.Processed;
}",0.2080169521455059
133456,"/** 
 * This operations loads a MOOSE YAML file at the specified path and returns a fully-configured set of ICE TreeComposites.
 * @param filePath The file path from which the MOOSE blocks written in YAML should be read. If the path is null or empty, the operation returns without doing any work.
 * @return The MOOSE input file specification as read from the YAML inputand stored in TreeComposites. Each TreeComposite contains both parameters and exemplar children. Any parameters in a TreeComposite are contained in a DataComponent. The id of the data component is 1.
 * @throws IOException
 */
public ArrayList<TreeComposite> loadYAML(String filePath) throws IOException {
  InputStream input=null;
  String syntaxFilePath, treeName;
  ArrayList<String> hardPathsList=null;
  ArrayList<TreeComposite> trees=new ArrayList<TreeComposite>();
  Map<String,TreeComposite> treeMap=null;
  TreeComposite oneUpTree=null;
  if (filePath == null || filePath.isEmpty()) {
    return null;
  }
  File yamlFile=new File(filePath);
  input=new FileInputStream(yamlFile);
  String projectDir=new File(yamlFile.getParent()).getParent();
  if (debugFlag) {
    logger.info(""String_Node_Str"" + filePath.toString());
  }
  Yaml yaml=new Yaml();
  ArrayList<?> list=(ArrayList<?>)yaml.load(input);
  if (debugFlag) {
    logger.info(""String_Node_Str"");
  }
  for (int i=0; i < list.size(); i++) {
    Block block=new YAMLBlock();
    block.loadFromMap((Map<String,Object>)list.get(i));
    setFileEntries(block,projectDir);
    block.active=true;
    trees.add(block.toTreeComposite());
  }
  try {
    input.close();
  }
 catch (  IOException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  ArrayList<String> topLevelNodes=new ArrayList<String>();
  for (  TreeComposite node : trees) {
    topLevelNodes.add(node.getName());
  }
  treeMap=new HashMap<String,TreeComposite>();
  Stack<TreeComposite> treeStack=new Stack<TreeComposite>();
  treeStack.push(null);
  for (  TreeComposite tree : trees) {
    treeStack.push(tree);
  }
  TreeComposite tree=treeStack.pop();
  ArrayList<TreeComposite> childExemplars;
  treeName=""String_Node_Str"";
  int prevNameIndex;
  while (tree != null) {
    treeName+=""String_Node_Str"" + tree.getName();
    treeMap.put((treeName.startsWith(""String_Node_Str"") ? treeName.substring(1) : treeName),tree);
    childExemplars=tree.getChildExemplars();
    for (int i=(childExemplars.size() - 1); i >= 0; i--) {
      treeStack.push(childExemplars.get(i));
    }
    if (trees.contains(treeStack.peek())) {
      treeName=""String_Node_Str"";
    }
 else     if (childExemplars.isEmpty()) {
      prevNameIndex=treeName.lastIndexOf(""String_Node_Str"" + tree.getName());
      treeName=treeName.substring(0,prevNameIndex);
      oneUpTree=treeMap.get(treeName.substring(1));
      if (oneUpTree != null && !oneUpTree.getChildExemplars().contains(treeStack.peek())) {
        prevNameIndex=treeName.lastIndexOf(""String_Node_Str"");
        treeName=((prevNameIndex == 0 || prevNameIndex == -1) ? treeName : treeName.substring(0,prevNameIndex));
      }
    }
    tree=treeStack.pop();
  }
  int yamlIndex=filePath.indexOf(""String_Node_Str"");
  syntaxFilePath=filePath.substring(0,yamlIndex) + ""String_Node_Str"";
  try {
    hardPathsList=loadActionSyntax(syntaxFilePath);
  }
 catch (  IOException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  TreeComposite currTree;
  boolean hasType=false;
  int typeIndex=-1;
  String cleanPath;
  ArrayList<TreeComposite> types, currChildExemplars;
  DataComponent typeParameters=null, treeParameters=null;
  for (  String path : hardPathsList) {
    cleanPath=(path.endsWith(""String_Node_Str"") ? path.substring(0,path.length() - 1) : path);
    currTree=treeMap.get(cleanPath);
    if (currTree != null && !(currTree.getChildExemplars().isEmpty())) {
      currChildExemplars=currTree.getChildExemplars();
      for (int i=0; i < currChildExemplars.size(); i++) {
        hasType=""String_Node_Str"".equals(currChildExemplars.get(i).getName());
        if (hasType) {
          typeIndex=i;
          break;
        }
      }
      if (hasType) {
        types=currTree.getChildExemplars().get(typeIndex).getChildExemplars();
        currChildExemplars.remove(typeIndex);
        currTree.setChildExemplars(currChildExemplars);
        Map<String,Entry> parameterMap=new HashMap<String,Entry>();
        for (        TreeComposite currType : types) {
          typeParameters=(DataComponent)currType.getDataNodes().get(0);
          treeParameters=(DataComponent)currTree.getDataNodes().get(0);
          parameterMap.clear();
          for (          Entry parameter : typeParameters.retrieveAllEntries()) {
            parameterMap.put(parameter.getName(),parameter);
          }
          for (          Entry currEntry : treeParameters.retrieveAllEntries()) {
            if (!parameterMap.containsKey(currEntry.getName())) {
              typeParameters.addEntry(currEntry);
            }
          }
        }
        AdaptiveTreeComposite adapTree=new AdaptiveTreeComposite(types);
        adapTree.copy(currTree);
        currTree=adapTree;
        treeMap.put(cleanPath,adapTree);
        if (!topLevelNodes.contains(currTree.getName())) {
          prevNameIndex=cleanPath.indexOf(""String_Node_Str"" + currTree.getName());
          treeName=cleanPath.substring(0,prevNameIndex);
          TreeComposite exemplarParent=treeMap.get(treeName);
          if (exemplarParent != null) {
            exemplarParent.addChildExemplar(currTree);
          }
        }
      }
    }
    hasType=false;
    typeIndex=-1;
  }
  ArrayList<TreeComposite> newTrees=new ArrayList<TreeComposite>();
  for (  String nodeName : topLevelNodes) {
    newTrees.add(treeMap.get(nodeName));
  }
  return newTrees;
}","/** 
 * This operations loads a MOOSE YAML file at the specified path and returns a fully-configured set of ICE TreeComposites.
 * @param filePath The file path from which the MOOSE blocks written in YAML should be read. If the path is null or empty, the operation returns without doing any work.
 * @return The MOOSE input file specification as read from the YAML inputand stored in TreeComposites. Each TreeComposite contains both parameters and exemplar children. Any parameters in a TreeComposite are contained in a DataComponent. The id of the data component is 1.
 * @throws IOException
 */
public ArrayList<TreeComposite> loadYAML(String filePath) throws IOException {
  InputStream input=null;
  String syntaxFilePath, treeName;
  ArrayList<String> hardPathsList=null;
  ArrayList<TreeComposite> trees=new ArrayList<TreeComposite>();
  Map<String,TreeComposite> treeMap=null;
  TreeComposite oneUpTree=null;
  if (filePath == null || filePath.isEmpty()) {
    return null;
  }
  File yamlFile=new File(filePath);
  input=new FileInputStream(yamlFile);
  String projectDir=new File(yamlFile.getParent()).getParent();
  if (debugFlag) {
    logger.info(""String_Node_Str"" + filePath.toString());
  }
  Yaml yaml=new Yaml();
  ArrayList<?> list=(ArrayList<?>)yaml.load(input);
  if (debugFlag) {
    logger.info(""String_Node_Str"");
  }
  if (list == null || list.isEmpty()) {
    logger.error(""String_Node_Str"" + yamlFile.getAbsolutePath());
    return trees;
  }
  for (int i=0; i < list.size(); i++) {
    Block block=new YAMLBlock();
    block.loadFromMap((Map<String,Object>)list.get(i));
    setFileEntries(block,projectDir);
    block.active=true;
    trees.add(block.toTreeComposite());
  }
  try {
    input.close();
  }
 catch (  IOException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  ArrayList<String> topLevelNodes=new ArrayList<String>();
  for (  TreeComposite node : trees) {
    topLevelNodes.add(node.getName());
  }
  treeMap=new HashMap<String,TreeComposite>();
  Stack<TreeComposite> treeStack=new Stack<TreeComposite>();
  treeStack.push(null);
  for (  TreeComposite tree : trees) {
    treeStack.push(tree);
  }
  TreeComposite tree=treeStack.pop();
  ArrayList<TreeComposite> childExemplars;
  treeName=""String_Node_Str"";
  int prevNameIndex;
  while (tree != null) {
    treeName+=""String_Node_Str"" + tree.getName();
    treeMap.put((treeName.startsWith(""String_Node_Str"") ? treeName.substring(1) : treeName),tree);
    childExemplars=tree.getChildExemplars();
    for (int i=(childExemplars.size() - 1); i >= 0; i--) {
      treeStack.push(childExemplars.get(i));
    }
    if (trees.contains(treeStack.peek())) {
      treeName=""String_Node_Str"";
    }
 else     if (childExemplars.isEmpty()) {
      prevNameIndex=treeName.lastIndexOf(""String_Node_Str"" + tree.getName());
      treeName=treeName.substring(0,prevNameIndex);
      oneUpTree=treeMap.get(treeName.substring(1));
      if (oneUpTree != null && !oneUpTree.getChildExemplars().contains(treeStack.peek())) {
        prevNameIndex=treeName.lastIndexOf(""String_Node_Str"");
        treeName=((prevNameIndex == 0 || prevNameIndex == -1) ? treeName : treeName.substring(0,prevNameIndex));
      }
    }
    tree=treeStack.pop();
  }
  int yamlIndex=filePath.indexOf(""String_Node_Str"");
  syntaxFilePath=filePath.substring(0,yamlIndex) + ""String_Node_Str"";
  try {
    hardPathsList=loadActionSyntax(syntaxFilePath);
  }
 catch (  IOException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  TreeComposite currTree;
  boolean hasType=false;
  int typeIndex=-1;
  String cleanPath;
  ArrayList<TreeComposite> types, currChildExemplars;
  DataComponent typeParameters=null, treeParameters=null;
  for (  String path : hardPathsList) {
    cleanPath=(path.endsWith(""String_Node_Str"") ? path.substring(0,path.length() - 1) : path);
    currTree=treeMap.get(cleanPath);
    if (currTree != null && !(currTree.getChildExemplars().isEmpty())) {
      currChildExemplars=currTree.getChildExemplars();
      for (int i=0; i < currChildExemplars.size(); i++) {
        hasType=""String_Node_Str"".equals(currChildExemplars.get(i).getName());
        if (hasType) {
          typeIndex=i;
          break;
        }
      }
      if (hasType) {
        types=currTree.getChildExemplars().get(typeIndex).getChildExemplars();
        currChildExemplars.remove(typeIndex);
        currTree.setChildExemplars(currChildExemplars);
        Map<String,Entry> parameterMap=new HashMap<String,Entry>();
        for (        TreeComposite currType : types) {
          typeParameters=(DataComponent)currType.getDataNodes().get(0);
          treeParameters=(DataComponent)currTree.getDataNodes().get(0);
          parameterMap.clear();
          for (          Entry parameter : typeParameters.retrieveAllEntries()) {
            parameterMap.put(parameter.getName(),parameter);
          }
          for (          Entry currEntry : treeParameters.retrieveAllEntries()) {
            if (!parameterMap.containsKey(currEntry.getName())) {
              typeParameters.addEntry(currEntry);
            }
          }
        }
        AdaptiveTreeComposite adapTree=new AdaptiveTreeComposite(types);
        adapTree.copy(currTree);
        currTree=adapTree;
        treeMap.put(cleanPath,adapTree);
        if (!topLevelNodes.contains(currTree.getName())) {
          prevNameIndex=cleanPath.indexOf(""String_Node_Str"" + currTree.getName());
          treeName=cleanPath.substring(0,prevNameIndex);
          TreeComposite exemplarParent=treeMap.get(treeName);
          if (exemplarParent != null) {
            exemplarParent.addChildExemplar(currTree);
          }
        }
      }
    }
    hasType=false;
    typeIndex=-1;
  }
  ArrayList<TreeComposite> newTrees=new ArrayList<TreeComposite>();
  for (  String nodeName : topLevelNodes) {
    newTrees.add(treeMap.get(nodeName));
  }
  return newTrees;
}",0.9890784982935154
133457,"/** 
 * (non-Javadoc)
 * @see org.eclipse.ui.ISaveablePart#doSave(IProgressMonitor monitor)
 */
@Override public void doSave(IProgressMonitor monitor){
  setDirty(false);
  notifyUpdateListeners();
  if (iceDataForm.isReady() && goButton != null) {
    goButton.setEnabled(iceDataForm.isReady());
  }
  for (  IFormPart part : ((ICEFormPage)this.getSelectedPage()).getManagedForm().getParts()) {
    part.refresh();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    setTreeCompositeViewerInput();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    MasterDetailsComponent comp=(MasterDetailsComponent)(componentMap.get(""String_Node_Str"").get(0));
    String name=comp.getName();
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      if (formPage.getPartName().equals(name)) {
        ICEMasterDetailsPage masterPage=(ICEMasterDetailsPage)formPage;
        masterPage.refreshMaster();
      }
    }
  }
  if (!(componentMap.get(""String_Node_Str"")).isEmpty()) {
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      EMFComponent comp=(EMFComponent)componentMap.get(""String_Node_Str"").get(0);
      if (formPage.getPartName().equals(comp.getName())) {
        formPage.doSave(null);
      }
    }
  }
}","/** 
 * (non-Javadoc)
 * @see org.eclipse.ui.ISaveablePart#doSave(IProgressMonitor monitor)
 */
@Override public void doSave(IProgressMonitor monitor){
  System.out.println(""String_Node_Str"");
  setDirty(false);
  notifyUpdateListeners();
  if (iceDataForm.isReady() && goButton != null) {
    goButton.setEnabled(iceDataForm.isReady());
  }
  for (  IFormPart part : ((ICEFormPage)this.getSelectedPage()).getManagedForm().getParts()) {
    part.refresh();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    setTreeCompositeViewerInput();
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    MasterDetailsComponent comp=(MasterDetailsComponent)(componentMap.get(""String_Node_Str"").get(0));
    String name=comp.getName();
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      if (formPage.getPartName().equals(name)) {
        ICEMasterDetailsPage masterPage=(ICEMasterDetailsPage)formPage;
        masterPage.refreshMaster();
      }
    }
  }
  if (!(componentMap.get(""String_Node_Str"")).isEmpty()) {
    for (int i=0; i < this.getPageCount(); i++) {
      FormPage formPage=(FormPage)this.pages.get(i);
      EMFComponent comp=(EMFComponent)componentMap.get(""String_Node_Str"").get(0);
      if (formPage.getPartName().equals(comp.getName())) {
        formPage.doSave(null);
      }
    }
  }
}",0.9849209268113276
133458,"/** 
 * This operation changes the dirty state of the FormEditor.
 * @param value
 */
public void setDirty(boolean value){
  dirty=value;
  firePropertyChange(PROP_DIRTY);
  if (getHeaderForm() != null) {
    final IMessageManager messageManager=getHeaderForm().getMessageManager();
    messageManager.addMessage(""String_Node_Str"",""String_Node_Str"",null,IMessageProvider.WARNING);
  }
}","/** 
 * This operation changes the dirty state of the FormEditor.
 * @param value
 */
public void setDirty(boolean value){
  dirty=value;
  firePropertyChange(PROP_DIRTY);
  if (getHeaderForm() != null) {
    final IMessageManager messageManager=getHeaderForm().getMessageManager();
    if (dirty) {
      messageManager.addMessage(""String_Node_Str"",""String_Node_Str"",null,IMessageProvider.WARNING);
    }
 else {
      messageManager.removeMessage(""String_Node_Str"");
    }
  }
}",0.8914549653579676
133459,"/** 
 * (non-Javadoc)
 * @see IObservableWidget#notifyUpdateListeners()
 */
@Override public void notifyUpdateListeners(){
  for (  IUpdateEventListener eventListener : updateListeners) {
    eventListener.formUpdated(iceDataForm);
  }
  return;
}","/** 
 * (non-Javadoc)
 * @see IObservableWidget#notifyUpdateListeners()
 */
@Override public void notifyUpdateListeners(){
  for (  IUpdateEventListener eventListener : updateListeners) {
    System.out.println(""String_Node_Str"" + eventListener.getClass().toString());
    eventListener.formUpdated(iceDataForm);
  }
  return;
}",0.8591304347826086
133460,"@Override public String getProviderName(){
  return null;
}","@Override public String getProviderName(){
  return ""String_Node_Str"";
}",0.8549618320610687
133461,"@Override public List<Class> getClasses(){
  return null;
}","@Override public List<Class> getClasses(){
  List<Class> classList=new ArrayList<Class>();
  classList.add(this.getClass());
  return classList;
}",0.5463414634146342
133462,"/** 
 * Test for  {@link org.eclipse.ice.datastructures.jaxbclassprovider.IJAXBClassProvider}.
 * @throws CoreException
 * @throws BundleException
 * @throws ClassNotFoundException
 * @throws URISyntaxException
 * @throws FileNotFoundException
 */
@Test public void test() throws CoreException, BundleException, ClassNotFoundException, URISyntaxException, FileNotFoundException {
  IJAXBClassProvider[] jaxbProviders=null;
  String id=""String_Node_Str"";
  IExtensionPoint point=Platform.getExtensionRegistry().getExtensionPoint(id);
  IConfigurationElement[] elements=point.getConfigurationElements();
  jaxbProviders=new IJAXBClassProvider[elements.length];
  for (int i=0; i < elements.length; i++) {
    jaxbProviders[i]=(IJAXBClassProvider)elements[i].createExecutableExtension(""String_Node_Str"");
  }
  IJAXBClassProvider[] providers=IJAXBClassProvider.getJAXBProviders();
  assertNotNull(providers);
  assertTrue(providers.length > 0);
  return;
}","/** 
 * Test for  {@link org.eclipse.ice.datastructures.jaxbclassprovider.IJAXBClassProvider}.
 * @throws CoreException
 * @throws BundleException
 * @throws ClassNotFoundException
 * @throws URISyntaxException
 * @throws FileNotFoundException
 */
@Ignore @Test public void test() throws CoreException, BundleException, ClassNotFoundException, URISyntaxException, FileNotFoundException {
  IJAXBClassProvider[] jaxbProviders=null;
  String id=""String_Node_Str"";
  IExtensionPoint point=Platform.getExtensionRegistry().getExtensionPoint(id);
  IConfigurationElement[] elements=point.getConfigurationElements();
  jaxbProviders=new IJAXBClassProvider[elements.length];
  for (int i=0; i < elements.length; i++) {
    jaxbProviders[i]=(IJAXBClassProvider)elements[i].createExecutableExtension(""String_Node_Str"");
  }
  IJAXBClassProvider[] providers=IJAXBClassProvider.getJAXBProviders();
  assertNotNull(providers);
  assertTrue(providers.length > 0);
  return;
}",0.9958202716823408
133463,"/** 
 * This operation pulls the list of JAXB class providers from the registry for classes that need custom handling.
 * @return The list of class providers.
 * @throws CoreException
 */
public static IJAXBClassProvider[] getJAXBProviders() throws CoreException {
  Logger logger=LoggerFactory.getLogger(IJAXBClassProvider.class);
  IJAXBClassProvider[] jaxbProviders=null;
  String id=""String_Node_Str"";
  IExtensionPoint point=Platform.getExtensionRegistry().getExtensionPoint(id);
  if (point != null) {
    IConfigurationElement[] elements=point.getConfigurationElements();
    jaxbProviders=new IJAXBClassProvider[elements.length];
    for (int i=0; i < elements.length; i++) {
      jaxbProviders[i]=(IJAXBClassProvider)elements[i].createExecutableExtension(""String_Node_Str"");
    }
  }
 else {
    System.err.println(""String_Node_Str"" + id + ""String_Node_Str"");
    logger.error(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return jaxbProviders;
}","/** 
 * This operation pulls the list of JAXB class providers from the registry for classes that need custom handling.
 * @return The list of class providers.
 * @throws CoreException
 */
public static IJAXBClassProvider[] getJAXBProviders() throws CoreException {
  Logger logger=LoggerFactory.getLogger(IJAXBClassProvider.class);
  IJAXBClassProvider[] jaxbProviders=null;
  String id=""String_Node_Str"";
  IExtensionPoint point=Platform.getExtensionRegistry().getExtensionPoint(id);
  if (point != null) {
    IConfigurationElement[] elements=point.getConfigurationElements();
    jaxbProviders=new IJAXBClassProvider[elements.length];
    for (int i=0; i < elements.length; i++) {
      jaxbProviders[i]=(IJAXBClassProvider)elements[i].createExecutableExtension(""String_Node_Str"");
    }
  }
 else {
    logger.error(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return jaxbProviders;
}",0.9504310344827588
133464,"@Override public Object create() throws CoreException {
  if (provider == null) {
    provider=new XMLPersistenceProvider();
    for (    ItemBuilder builder : ItemBuilder.getItemBuilders()) {
      provider.addBuilder(builder);
    }
    for (    IJAXBClassProvider jaxbProvider : IJAXBClassProvider.getJAXBProviders()) {
      provider.registerClassProvider(jaxbProvider);
    }
    try {
      provider.start();
    }
 catch (    JAXBException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return provider;
}","@Override public Object create() throws CoreException {
  if (provider == null) {
    provider=new XMLPersistenceProvider();
    for (    ItemBuilder builder : ItemBuilder.getItemBuilders()) {
      provider.addBuilder(builder);
    }
    IJAXBClassProvider[] jaxbProviders=IJAXBClassProvider.getJAXBProviders();
    if (jaxbProviders != null && jaxbProviders.length > 0) {
      for (      IJAXBClassProvider jaxbProvider : jaxbProviders) {
        provider.registerClassProvider(jaxbProvider);
      }
    }
    try {
      provider.start();
    }
 catch (    JAXBException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return provider;
}",0.6927659574468085
133465,"/** 
 * This operation overrides init so that the ICE Form, passed as an IEditorInput, can be stored.
 * @param site the site on the workbench where the Form is drawn
 * @param input the input for this editor
 */
@Override public void init(IEditorSite site,IEditorInput input) throws RuntimeException {
  setPartName(input.getName());
  setSite(site);
  setInput(input);
  if (input instanceof ICEFormInput) {
    ICEFormInput=(ICEFormInput)input;
    iceDataForm=ICEFormInput.getForm();
  }
 else   if (input instanceof FileEditorInput) {
    IFile formFile=((FileEditorInput)input).getFile();
    System.out.println(""String_Node_Str"" + formFile.getLocation().toOSString());
    try {
      IClient client=IClient.getClient();
      iceDataForm=client.loadItem(formFile);
      logger.info(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return;
}","/** 
 * This operation overrides init so that the ICE Form, passed as an IEditorInput, can be stored.
 * @param site the site on the workbench where the Form is drawn
 * @param input the input for this editor
 */
@Override public void init(IEditorSite site,IEditorInput input) throws RuntimeException {
  setPartName(input.getName());
  setSite(site);
  setInput(input);
  if (input instanceof ICEFormInput) {
    ICEFormInput=(ICEFormInput)input;
    iceDataForm=ICEFormInput.getForm();
  }
 else   if (input instanceof FileEditorInput) {
    IFile formFile=((FileEditorInput)input).getFile();
    System.out.println(""String_Node_Str"" + formFile.getLocation().toOSString());
    try {
      IClient client=IClient.getClient();
      iceDataForm=client.loadItem(formFile);
      logger.info(""String_Node_Str"");
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return;
}",0.8342042755344418
133466,"/** 
 * This operation starts the Core, sets the component context and starts the web client if the HTTP service is available.
 * @param context The bundle context for this OSGi bundle.
 */
public void start(ComponentContext context) throws CoreException {
  componentContext=context;
  logger.info(""String_Node_Str"");
  IExtensionPoint point=Platform.getExtensionRegistry().getExtensionPoint(providerID);
  if (point != null) {
    IConfigurationElement element=point.getConfigurationElements()[0];
    provider=(IPersistenceProvider)element.createExecutableExtension(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else {
    logger.error(""String_Node_Str"" + providerID + ""String_Node_Str"");
  }
  itemManager.setPersistenceProvider(provider);
  ItemBuilder builder=null;
  point=Platform.getExtensionRegistry().getExtensionPoint(id);
  if (point != null) {
    IConfigurationElement[] elements=point.getConfigurationElements();
    for (int i=0; i < elements.length; i++) {
      builder=(ItemBuilder)elements[i].createExecutableExtension(""String_Node_Str"");
      itemManager.registerBuilder(builder);
    }
  }
 else {
    logger.error(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  itemManager.loadItems(projectTable.get(""String_Node_Str""));
  startHttpService();
  debugCheckExtensions();
  return;
}","/** 
 * This operation starts the Core, sets the component context and starts the web client if the HTTP service is available.
 * @param context The bundle context for this OSGi bundle.
 */
public void start(ComponentContext context) throws CoreException {
  componentContext=context;
  logger.info(""String_Node_Str"");
  IExtensionPoint point=Platform.getExtensionRegistry().getExtensionPoint(providerID);
  if (point != null) {
    IConfigurationElement element=point.getConfigurationElements()[0];
    provider=(IPersistenceProvider)element.createExecutableExtension(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else {
    logger.error(""String_Node_Str"" + providerID + ""String_Node_Str"");
  }
  itemManager.setPersistenceProvider(provider);
  ItemBuilder builder=null;
  point=Platform.getExtensionRegistry().getExtensionPoint(id);
  if (point != null) {
    IConfigurationElement[] elements=point.getConfigurationElements();
    for (int i=0; i < elements.length; i++) {
      builder=(ItemBuilder)elements[i].createExecutableExtension(""String_Node_Str"");
      itemManager.registerBuilder(builder);
    }
  }
 else {
    logger.error(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  createItemDBProjectSpace();
  provider.setDefaultProject(itemDBProject);
  itemManager.loadItems(itemDBProject);
  startHttpService();
  debugCheckExtensions();
  return;
}",0.9591160220994476
133467,"@Override public void setDefaultProject(IProject project){
  this.project=project;
}","@Override public void setDefaultProject(IProject project){
  this.project=project;
  loadItemIdMap();
}",0.8983957219251337
133468,"/** 
 * This operation is called to start the XMLPersistenceProvider by the OSGi Declarative Services engine. It sets up the project space and starts the event loop.
 * @throws JAXBException An exception indicating that the JAXB Context could not be created.
 */
public void start() throws JAXBException {
  logger.info(""String_Node_Str"" + ""String_Node_Str"");
  if (project == null) {
    createProjectSpace();
  }
  createJAXBContext();
  loadItemIdMap();
  runFlag.set(true);
  eventLoop=new Thread(this);
  eventLoop.start();
  logger.info(""String_Node_Str"" + ""String_Node_Str"");
  return;
}","/** 
 * This operation is called to start the XMLPersistenceProvider by the OSGi Declarative Services engine. It sets up the project space and starts the event loop.
 * @throws JAXBException An exception indicating that the JAXB Context could not be created.
 */
public void start() throws JAXBException {
  logger.info(""String_Node_Str"" + ""String_Node_Str"");
  createJAXBContext();
  runFlag.set(true);
  eventLoop=new Thread(this);
  eventLoop.start();
  logger.info(""String_Node_Str"" + ""String_Node_Str"");
  return;
}",0.933572710951526
133469,"@Override public void widgetSelected(SelectionEvent e){
  if (""String_Node_Str"".equals(processName)) {
    Thread ppThread=new Thread(new Runnable(){
      @Override public void run(){
        ArrayList<ICEResource> resourceList=new ArrayList<ICEResource>();
        ArrayList<String> enabledPPs=new ArrayList<String>();
        ResourceComponent resources;
        for (        Entry postProcessor : postProcessors.retrieveAllEntries()) {
          if (""String_Node_Str"".equals(postProcessor.getValue())) {
            enabledPPs.add(postProcessor.getName());
          }
        }
        if (!enabledPPs.isEmpty()) {
          while (resourceList.size() != enabledPPs.size()) {
            resources=resourceComponentPage.getResourceComponent();
            try {
              Thread.sleep(500);
            }
 catch (            InterruptedException e) {
              logger.error(getClass().getName() + ""String_Node_Str"",e);
            }
            for (            ICEResource r : resources.getResources()) {
              if (enabledPPs.contains(FilenameUtils.removeExtension(r.getName())) && hasValidPostprocessorData(r)) {
                resourceList.add(r);
              }
            }
          }
          for (          final ICEResource r : resourceList) {
            PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
              @Override public void run(){
                try {
                  MOOSEFormEditor.this.setActivePage(1);
                  resourceComponentPage.showResource(r);
                }
 catch (                PartInitException e) {
                  logger.error(getClass().getName() + ""String_Node_Str"",e);
                }
              }
            }
);
          }
        }
      }
    }
);
    ppThread.start();
  }
}","@Override public void widgetSelected(SelectionEvent e){
  if (""String_Node_Str"".equals(processName)) {
    Thread ppThread=new Thread(new Runnable(){
      @Override public void run(){
        ArrayList<ICEResource> resourceList=new ArrayList<ICEResource>();
        ArrayList<String> enabledPPs=new ArrayList<String>();
        ResourceComponent resources;
        for (        Entry postProcessor : postProcessors.retrieveAllEntries()) {
          if (""String_Node_Str"".equals(postProcessor.getValue())) {
            enabledPPs.add(postProcessor.getName());
          }
        }
        if (!enabledPPs.isEmpty()) {
          while (resourceList.size() != enabledPPs.size()) {
            resources=resourceComponentPage.getResourceComponent();
            try {
              Thread.sleep(500);
            }
 catch (            InterruptedException e) {
              logger.error(getClass().getName() + ""String_Node_Str"",e);
            }
            for (            ICEResource r : resources.getResources()) {
              if (enabledPPs.contains(FilenameUtils.removeExtension(r.getName())) && hasValidPostprocessorData(r)) {
                resourceList.add(r);
              }
            }
          }
          for (          final ICEResource r : resourceList) {
            PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
              @Override public void run(){
                try {
                  if (!resourceComponentPage.isResourceDisplayed(r)) {
                    MOOSEFormEditor.this.setActivePage(resourceComponentPage.getId());
                    resourceComponentPage.showResource(r);
                  }
                }
 catch (                PartInitException e) {
                  logger.error(getClass().getName() + ""String_Node_Str"",e);
                }
              }
            }
);
          }
        }
      }
    }
);
    ppThread.start();
  }
}",0.9662800107903964
133470,"@Override protected void createHeaderContents(IManagedForm headerForm){
  super.createHeaderContents(headerForm);
  goButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (""String_Node_Str"".equals(processName)) {
        Thread ppThread=new Thread(new Runnable(){
          @Override public void run(){
            ArrayList<ICEResource> resourceList=new ArrayList<ICEResource>();
            ArrayList<String> enabledPPs=new ArrayList<String>();
            ResourceComponent resources;
            for (            Entry postProcessor : postProcessors.retrieveAllEntries()) {
              if (""String_Node_Str"".equals(postProcessor.getValue())) {
                enabledPPs.add(postProcessor.getName());
              }
            }
            if (!enabledPPs.isEmpty()) {
              while (resourceList.size() != enabledPPs.size()) {
                resources=resourceComponentPage.getResourceComponent();
                try {
                  Thread.sleep(500);
                }
 catch (                InterruptedException e) {
                  logger.error(getClass().getName() + ""String_Node_Str"",e);
                }
                for (                ICEResource r : resources.getResources()) {
                  if (enabledPPs.contains(FilenameUtils.removeExtension(r.getName())) && hasValidPostprocessorData(r)) {
                    resourceList.add(r);
                  }
                }
              }
              for (              final ICEResource r : resourceList) {
                PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
                  @Override public void run(){
                    try {
                      MOOSEFormEditor.this.setActivePage(1);
                      resourceComponentPage.showResource(r);
                    }
 catch (                    PartInitException e) {
                      logger.error(getClass().getName() + ""String_Node_Str"",e);
                    }
                  }
                }
);
              }
            }
          }
        }
);
        ppThread.start();
      }
    }
  }
);
  return;
}","@Override protected void createHeaderContents(IManagedForm headerForm){
  super.createHeaderContents(headerForm);
  goButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (""String_Node_Str"".equals(processName)) {
        Thread ppThread=new Thread(new Runnable(){
          @Override public void run(){
            ArrayList<ICEResource> resourceList=new ArrayList<ICEResource>();
            ArrayList<String> enabledPPs=new ArrayList<String>();
            ResourceComponent resources;
            for (            Entry postProcessor : postProcessors.retrieveAllEntries()) {
              if (""String_Node_Str"".equals(postProcessor.getValue())) {
                enabledPPs.add(postProcessor.getName());
              }
            }
            if (!enabledPPs.isEmpty()) {
              while (resourceList.size() != enabledPPs.size()) {
                resources=resourceComponentPage.getResourceComponent();
                try {
                  Thread.sleep(500);
                }
 catch (                InterruptedException e) {
                  logger.error(getClass().getName() + ""String_Node_Str"",e);
                }
                for (                ICEResource r : resources.getResources()) {
                  if (enabledPPs.contains(FilenameUtils.removeExtension(r.getName())) && hasValidPostprocessorData(r)) {
                    resourceList.add(r);
                  }
                }
              }
              for (              final ICEResource r : resourceList) {
                PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
                  @Override public void run(){
                    try {
                      if (!resourceComponentPage.isResourceDisplayed(r)) {
                        MOOSEFormEditor.this.setActivePage(resourceComponentPage.getId());
                        resourceComponentPage.showResource(r);
                      }
                    }
 catch (                    PartInitException e) {
                      logger.error(getClass().getName() + ""String_Node_Str"",e);
                    }
                  }
                }
);
              }
            }
          }
        }
);
        ppThread.start();
      }
    }
  }
);
  return;
}",0.9703983975072334
133471,"/** 
 * <p> This operation processes the Item with the specified id and action. The action name must be one of the set of actions from the Form that represents the Item with the specified id. </p> <p> It is possible that ICE may require information in addition to that which was requested in the original Form, such as for a username and password for a remote machine. If this is the case, processItem will return FormStatus.NeedsInfo and a new, temporary Form will be available for the Item by calling getItem(). Once this new Form is submitted It is possible that ICE may require information in addition to that which was requested in the original Form, such as for a username and password for a remote machine. If this is the case, processItem will return FormStatus.NeedsInfo and a new, temporary Form will be available for the Item by calling getItem(). Once this new Form is submitted (by calling updateItem() with the completed Form), the Item will finish processing. </p> <p> The ItemManager will call the persistence provider to update the Item when this operation is called. </p>
 * @param itemId <p> The identification number of the Item. </p>
 * @param actionName <p> The name of the action that should be performed for the Item. </p>
 * @return <p>The status of the Item after the action has been performed. </p>
 */
public FormStatus processItem(int itemId,String actionName){
  FormStatus status=FormStatus.InfoError;
  Item tmpItem=null;
  if (itemId > 0 && actionName != null) {
    tmpItem=itemList.get(itemId);
    if (tmpItem != null) {
      status=tmpItem.process(actionName);
    }
  }
  return status;
}","/** 
 * <p> This operation processes the Item with the specified id and action. The action name must be one of the set of actions from the Form that represents the Item with the specified id. </p> <p> It is possible that ICE may require information in addition to that which was requested in the original Form, such as for a username and password for a remote machine. If this is the case, processItem will return FormStatus.NeedsInfo and a new, temporary Form will be available for the Item by calling getItem(). Once this new Form is submitted It is possible that ICE may require information in addition to that which was requested in the original Form, such as for a username and password for a remote machine. If this is the case, processItem will return FormStatus.NeedsInfo and a new, temporary Form will be available for the Item by calling getItem(). Once this new Form is submitted (by calling updateItem() with the completed Form), the Item will finish processing. </p> <p> The ItemManager will call the persistence provider to update the Item when this operation is called. </p>
 * @param itemId <p> The identification number of the Item. </p>
 * @param actionName <p> The name of the action that should be performed for the Item. </p>
 * @return <p>The status of the Item after the action has been performed. </p>
 */
public FormStatus processItem(int itemId,String actionName){
  FormStatus status=FormStatus.InfoError;
  Item tmpItem=null;
  if (itemId > 0 && actionName != null) {
    tmpItem=itemList.get(itemId);
    if (tmpItem != null) {
      status=tmpItem.process(actionName);
    }
  }
 else {
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ status.toString());
  }
  return status;
}",0.9598333829217496
133472,"/** 
 * This operation instantiates the output file.
 */
private void setupOutputFile(){
  String outputFilename=form.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + getId()+ ""String_Node_Str"";
  if (project != null) {
    IFile outputFileHandle=project.getFile(outputFilename);
    outputFile=outputFileHandle.getLocation().toFile();
    try {
      outputFile.createNewFile();
    }
 catch (    Exception fileFailException) {
      logger.info(""String_Node_Str"" + ""String_Node_Str"");
      fileFailException.printStackTrace();
      return;
    }
  }
  return;
}","/** 
 * This operation instantiates the output file.
 */
protected void setupOutputFile(){
  String outputFilename=form.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + getId()+ ""String_Node_Str"";
  if (project != null) {
    IFile outputFileHandle=project.getFile(outputFilename);
    outputFile=outputFileHandle.getLocation().toFile();
    try {
      outputFile.createNewFile();
    }
 catch (    Exception fileFailException) {
      logger.info(""String_Node_Str"" + ""String_Node_Str"");
      fileFailException.printStackTrace();
      return;
    }
  }
  return;
}",0.9899497487437184
133473,"/** 
 * This method is called whenever the current   {@link #resourceComponent} isupdated. It adds any new plots to the map of  {@link #plots} if possible.
 */
@Override public void update(IUpdateable component){
  if (component != null && component == resourceComponent) {
  }
 else   if (component != null && component instanceof VizResource) {
    final VizResource resource=(VizResource)component;
    plotGridComposite.refreshPlots(resource.getPath());
    if (pageComposite != null) {
      pageComposite.getDisplay().asyncExec(new Runnable(){
        @Override public void run(){
          pageComposite.layout();
          activateEditor();
        }
      }
);
    }
  }
  return;
}","/** 
 * This method is called whenever the current   {@link #resourceComponent} isupdated. It adds any new plots to the map of  {@link #plots} if possible.
 */
@Override public void update(IUpdateable component){
  if (component != null && component == resourceComponent) {
    for (    ICEResource resource : resourceComponent.getResources()) {
      if (resource instanceof VizResource) {
        resource.register(this);
      }
    }
  }
 else   if (component != null && component instanceof VizResource) {
    final VizResource resource=(VizResource)component;
    plotGridComposite.refreshPlots(resource.getPath());
    if (pageComposite != null) {
      pageComposite.getDisplay().asyncExec(new Runnable(){
        @Override public void run(){
          pageComposite.layout();
          activateEditor();
        }
      }
);
    }
  }
  return;
}",0.8939197930142303
133474,"/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String host=""String_Node_Str"";
  outputFile=mooseLauncher.getOutputFile();
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      host=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
    }
    createICEUpdaterBlock(host);
    if (populateListOfLauncherFiles() != FormStatus.ReadyToProcess) {
      return FormStatus.InfoError;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(host);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}","/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String host=""String_Node_Str"";
  outputFile=mooseLauncher.getOutputFile();
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      logger.error(""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      host=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
    }
    String thisHost=""String_Node_Str"";
    try {
      thisHost=InetAddress.getByName(InetAddress.getLocalHost().getHostName()).getHostAddress();
    }
 catch (    UnknownHostException e) {
      e.printStackTrace();
      logger.error(this.getClass().getName() + ""String_Node_Str"",e);
    }
    if (!thisHost.isEmpty()) {
      createICEUpdaterBlock(thisHost);
    }
    if (populateListOfLauncherFiles() != FormStatus.ReadyToProcess) {
      logger.error(getClass().getName() + ""String_Node_Str"");
      return FormStatus.InfoError;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(host);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}",0.9150549867273416
133475,"/** 
 * This private method is used to create a new ICEUpdater block for the launch. It checks to see if one can, or even should be created, and then creates it, configures it, and adds it to the tree.
 * @param isRemote
 * @return
 */
private void createICEUpdaterBlock(String host){
  TreeComposite outputs=getTopLevelTreeByName(""String_Node_Str"");
  TreeComposite postProcessors=getTopLevelTreeByName(""String_Node_Str"");
  TreeComposite iceUpdater=null;
  boolean display=false, iNeedUpdater=true, updaterExists=false;
  for (int i=0; i < outputs.getNumberOfChildren(); i++) {
    if (""String_Node_Str"".equals(outputs.getChildAtIndex(i).getName())) {
      updaterExists=true;
      break;
    }
  }
  if (postProcessors == null || !postProcessors.isActive() || postProcessors.getNumberOfChildren() < 1 || !updaterExists) {
    return;
  }
  DataComponent displayPPs=(DataComponent)form.getComponent(MOOSE.ppDataId);
  for (  Entry e : displayPPs.retrieveAllEntries()) {
    if (e.getValue().equals(""String_Node_Str"")) {
      display=true;
      break;
    }
  }
  if (display) {
    for (int i=0; i < outputs.getNumberOfChildren(); i++) {
      if (""String_Node_Str"".equals(outputs.getChildAtIndex(i).getName())) {
        iceUpdater=outputs.getChildAtIndex(i);
        DataComponent data=(DataComponent)iceUpdater.getDataNodes().get(0);
        Entry itemIdEntry=data.retrieveEntry(""String_Node_Str"");
        if (Integer.valueOf(itemIdEntry.getValue()) != getId()) {
          itemIdEntry.setValue(String.valueOf(getId()));
        }
        data.retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"" + host + ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
        iNeedUpdater=false;
        break;
      }
    }
    if (iNeedUpdater) {
      for (int i=0; i < outputs.getChildExemplars().size(); i++) {
        if (""String_Node_Str"".equals(outputs.getChildExemplars().get(i).getName())) {
          iceUpdater=(TreeComposite)outputs.getChildExemplars().get(i).clone();
          outputs.setNextChild(iceUpdater);
          DataComponent data=(DataComponent)iceUpdater.getDataNodes().get(0);
          data.retrieveEntry(""String_Node_Str"").setValue(String.valueOf(getId()));
          data.retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"" + host + ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
          iceUpdater.setActive(true);
          iceUpdater.setActiveDataNode(data);
          break;
        }
      }
    }
  }
 else {
    for (int i=0; i < outputs.getNumberOfChildren(); i++) {
      if (""String_Node_Str"".equals(outputs.getChildAtIndex(i).getName())) {
        outputs.removeChild(outputs.getChildAtIndex(i));
        break;
      }
    }
  }
  return;
}","/** 
 * This private method is used to create a new ICEUpdater block for the launch. It checks to see if one can, or even should be created, and then creates it, configures it, and adds it to the tree.
 * @param isRemote
 * @return
 */
private void createICEUpdaterBlock(String host){
  TreeComposite outputs=getTopLevelTreeByName(""String_Node_Str"");
  TreeComposite postProcessors=getTopLevelTreeByName(""String_Node_Str"");
  TreeComposite iceUpdater=null;
  boolean display=false, iNeedUpdater=true, updaterExists=false;
  for (  TreeComposite child : outputs.getChildExemplars()) {
    if (""String_Node_Str"".equals(child.getName())) {
      updaterExists=true;
      break;
    }
  }
  if (postProcessors == null || !postProcessors.isActive() || postProcessors.getNumberOfChildren() < 1 || !updaterExists) {
    return;
  }
  DataComponent displayPPs=(DataComponent)form.getComponent(MOOSE.ppDataId);
  for (  Entry e : displayPPs.retrieveAllEntries()) {
    if (e.getValue().equals(""String_Node_Str"")) {
      display=true;
      break;
    }
  }
  if (display) {
    for (int i=0; i < outputs.getNumberOfChildren(); i++) {
      if (""String_Node_Str"".equals(outputs.getChildAtIndex(i).getName())) {
        iceUpdater=outputs.getChildAtIndex(i);
        DataComponent data=(DataComponent)iceUpdater.getDataNodes().get(0);
        Entry itemIdEntry=data.retrieveEntry(""String_Node_Str"");
        if (Integer.valueOf(itemIdEntry.getValue()) != getId()) {
          itemIdEntry.setValue(String.valueOf(getId()));
        }
        data.retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"" + host + ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
        iNeedUpdater=false;
        break;
      }
    }
    if (iNeedUpdater) {
      for (int i=0; i < outputs.getChildExemplars().size(); i++) {
        if (""String_Node_Str"".equals(outputs.getChildExemplars().get(i).getName())) {
          iceUpdater=(TreeComposite)outputs.getChildExemplars().get(i).clone();
          outputs.setNextChild(iceUpdater);
          DataComponent data=(DataComponent)iceUpdater.getDataNodes().get(0);
          data.retrieveEntry(""String_Node_Str"").setValue(String.valueOf(getId()));
          data.retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"" + host + ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
          iceUpdater.setActive(true);
          iceUpdater.setActiveDataNode(data);
          break;
        }
      }
    }
  }
 else {
    for (int i=0; i < outputs.getNumberOfChildren(); i++) {
      if (""String_Node_Str"".equals(outputs.getChildAtIndex(i).getName())) {
        outputs.removeChild(outputs.getChildAtIndex(i));
        break;
      }
    }
  }
  return;
}",0.313739763421292
133476,"@Override protected ArrayList<VizEntry> createConnectionTemplate(){
  ArrayList<VizEntry> template=super.createConnectionTemplate();
  IVizEntryContentProvider contentProvider;
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry proxyEntry=new VizEntry(contentProvider);
  proxyEntry.setName(""String_Node_Str"");
  template.add(proxyEntry);
  PortEntryContentProvider portContentProvider=new PortEntryContentProvider();
  portContentProvider.setRange(PortEntryContentProvider.MIN_PORT,PortEntryContentProvider.MAX_PORT);
  portContentProvider.setDefaultValue(22);
  VizEntry proxyPortEntry=new PortEntry(portContentProvider);
  proxyPortEntry.setName(""String_Node_Str"");
  template.add(proxyPortEntry);
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setAllowedValueType(VizAllowedValueType.Undefined);
  contentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry visitUserEntry=new VizEntry(contentProvider);
  visitUserEntry.setName(""String_Node_Str"");
  template.add(visitUserEntry);
  return template;
}","@Override protected ArrayList<VizEntry> createConnectionTemplate(){
  ArrayList<VizEntry> template=super.createConnectionTemplate();
  IVizEntryContentProvider contentProvider;
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry proxyEntry=new VizEntry(contentProvider);
  proxyEntry.setName(""String_Node_Str"");
  template.add(proxyEntry);
  PortEntryContentProvider portContentProvider=new PortEntryContentProvider();
  portContentProvider.setRange(PortEntryContentProvider.MIN_PORT,PortEntryContentProvider.MAX_PORT);
  portContentProvider.setDefaultValue(22);
  VizEntry proxyPortEntry=new PortEntry(portContentProvider);
  proxyPortEntry.setName(""String_Node_Str"");
  template.add(proxyPortEntry);
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setAllowedValueType(VizAllowedValueType.Undefined);
  contentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry visitUserEntry=new VizEntry(contentProvider);
  visitUserEntry.setName(""String_Node_Str"");
  template.add(visitUserEntry);
  Iterator<VizEntry> it=template.iterator();
  while (it.hasNext()) {
    VizEntry entry=it.next();
    if (""String_Node_Str"".equals(entry.getName())) {
      it.remove();
    }
  }
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setAllowedValueType(VizAllowedValueType.Executable);
  ArrayList<String> allowedValues=new ArrayList<String>();
  String defaultPath=System.getProperty(""String_Node_Str"");
  if (defaultPath != null) {
    if (defaultPath.contains(""String_Node_Str"")) {
      defaultPath=defaultPath.replace(""String_Node_Str"",System.getProperty(""String_Node_Str""));
      allowedValues.add(defaultPath);
    }
  }
  contentProvider.setAllowedValues(allowedValues);
  VizEntry pathEntry=new VizEntry(contentProvider);
  pathEntry.setName(""String_Node_Str"");
  pathEntry.setDescription(""String_Node_Str"");
  template.add(3,pathEntry);
  return template;
}",0.7111690003256268
133477,"@Override protected ConnectionTable createConnectionTable(){
  return new ConnectionTable(){
    @Override protected ArrayList<VizEntry> createConnectionTemplate(){
      ArrayList<VizEntry> template=super.createConnectionTemplate();
      IVizEntryContentProvider contentProvider;
      contentProvider=new BasicVizEntryContentProvider();
      contentProvider.setDefaultValue(""String_Node_Str"");
      VizEntry proxyEntry=new VizEntry(contentProvider);
      proxyEntry.setName(""String_Node_Str"");
      template.add(proxyEntry);
      PortEntryContentProvider portContentProvider=new PortEntryContentProvider();
      portContentProvider.setRange(PortEntryContentProvider.MIN_PORT,PortEntryContentProvider.MAX_PORT);
      portContentProvider.setDefaultValue(22);
      VizEntry proxyPortEntry=new PortEntry(portContentProvider);
      proxyPortEntry.setName(""String_Node_Str"");
      template.add(proxyPortEntry);
      contentProvider=new BasicVizEntryContentProvider();
      contentProvider.setAllowedValueType(VizAllowedValueType.Undefined);
      contentProvider.setDefaultValue(""String_Node_Str"");
      VizEntry visitUserEntry=new VizEntry(contentProvider);
      visitUserEntry.setName(""String_Node_Str"");
      template.add(visitUserEntry);
      return template;
    }
  }
;
}","@Override protected ConnectionTable createConnectionTable(){
  return new ConnectionTable(){
    @Override protected ArrayList<VizEntry> createConnectionTemplate(){
      ArrayList<VizEntry> template=super.createConnectionTemplate();
      IVizEntryContentProvider contentProvider;
      contentProvider=new BasicVizEntryContentProvider();
      contentProvider.setDefaultValue(""String_Node_Str"");
      VizEntry proxyEntry=new VizEntry(contentProvider);
      proxyEntry.setName(""String_Node_Str"");
      template.add(proxyEntry);
      PortEntryContentProvider portContentProvider=new PortEntryContentProvider();
      portContentProvider.setRange(PortEntryContentProvider.MIN_PORT,PortEntryContentProvider.MAX_PORT);
      portContentProvider.setDefaultValue(22);
      VizEntry proxyPortEntry=new PortEntry(portContentProvider);
      proxyPortEntry.setName(""String_Node_Str"");
      template.add(proxyPortEntry);
      contentProvider=new BasicVizEntryContentProvider();
      contentProvider.setAllowedValueType(VizAllowedValueType.Undefined);
      contentProvider.setDefaultValue(""String_Node_Str"");
      VizEntry visitUserEntry=new VizEntry(contentProvider);
      visitUserEntry.setName(""String_Node_Str"");
      template.add(visitUserEntry);
      Iterator<VizEntry> it=template.iterator();
      while (it.hasNext()) {
        VizEntry entry=it.next();
        if (""String_Node_Str"".equals(entry.getName())) {
          it.remove();
        }
      }
      contentProvider=new BasicVizEntryContentProvider();
      contentProvider.setAllowedValueType(VizAllowedValueType.Executable);
      ArrayList<String> allowedValues=new ArrayList<String>();
      String defaultPath=System.getProperty(""String_Node_Str"");
      if (defaultPath != null) {
        if (defaultPath.contains(""String_Node_Str"")) {
          defaultPath=defaultPath.replace(""String_Node_Str"",System.getProperty(""String_Node_Str""));
          allowedValues.add(defaultPath);
        }
      }
      contentProvider.setAllowedValues(allowedValues);
      VizEntry pathEntry=new VizEntry(contentProvider);
      pathEntry.setName(""String_Node_Str"");
      pathEntry.setDescription(""String_Node_Str"");
      template.add(3,pathEntry);
      return template;
    }
  }
;
}",0.7232117613797003
133478,"/** 
 * Adds a new connection based on the specified name and preference value. The connection will attempt to connect.
 * @param name The name of the connection (a preference name in the store).
 * @param preferences The preference value for the connection. This value should come straight from the  {@link #preferenceStore}.
 */
private void addConnection(String name,String preferences){
  logger.debug(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ preferences+ ""String_Node_Str"");
  VizConnection<T> connection=createConnection(name,preferences);
  String[] split=preferences.split(getConnectionPreferenceDelimiter(),-1);
  try {
    connection.setName(name);
    connection.setHost(split[0]);
    connection.setPort(Integer.parseInt(split[1]));
    connection.setPath(split[2]);
    connectionsByName.put(name,connection);
    String host=connection.getHost();
    Set<String> connections=connectionsByHost.get(host);
    if (connections == null) {
      connections=new HashSet<String>();
      connectionsByHost.put(host,connections);
    }
    connections.add(name);
    connection.connect();
  }
 catch (  IndexOutOfBoundsException|NullPointerException|NumberFormatException e) {
  }
  return;
}","/** 
 * Adds a new connection based on the specified name and preference value. The connection will attempt to connect.
 * @param name The name of the connection (a preference name in the store).
 * @param preferences The preference value for the connection. This value should come straight from the  {@link #preferenceStore}.
 */
private void addConnection(String name,String preferences){
  logger.info(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ preferences+ ""String_Node_Str"");
  VizConnection<T> connection=createConnection(name,preferences);
  String[] split=preferences.split(getConnectionPreferenceDelimiter(),-1);
  try {
    connection.setName(name);
    connection.setHost(split[0]);
    connection.setPort(Integer.parseInt(split[1]));
    connection.setPath(split[2].split(""String_Node_Str"")[0]);
    connectionsByName.put(name,connection);
    String host=connection.getHost();
    Set<String> connections=connectionsByHost.get(host);
    if (connections == null) {
      connections=new HashSet<String>();
      connectionsByHost.put(host,connections);
    }
    connections.add(name);
    connection.connect();
  }
 catch (  IndexOutOfBoundsException|NullPointerException|NumberFormatException e) {
  }
  return;
}",0.9850505050505052
133479,"/** 
 * Gets the row template for a connection as defined in the  {@link ConnectionTable documentation for the class}.
 * @return An {@code ArrayList<Entry>} containing the template {@code Entry}s for each exposed connection property.
 */
protected ArrayList<VizEntry> createConnectionTemplate(){
  ArrayList<VizEntry> template=new ArrayList<VizEntry>();
  IVizEntryContentProvider contentProvider;
  KeyEntryContentProvider keyContentProvider=new KeyEntryContentProvider(keyManager);
  VizEntry keyEntry=new KeyEntry(keyContentProvider);
  keyEntry.setName(""String_Node_Str"");
  keyEntry.setDescription(""String_Node_Str"");
  template.add(keyEntry);
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry hostEntry=new VizEntry(contentProvider);
  hostEntry.setName(""String_Node_Str"");
  hostEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  template.add(hostEntry);
  PortEntryContentProvider portContentProvider=new PortEntryContentProvider();
  portContentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry hostPortEntry=new PortEntry(portContentProvider);
  hostPortEntry.setName(""String_Node_Str"");
  hostPortEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"" + Integer.toString(PortEntryContentProvider.MIN_PORT) + ""String_Node_Str""+ Integer.toString(PortEntryContentProvider.MAX_PORT)+ ""String_Node_Str"");
  template.add(hostPortEntry);
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setAllowedValueType(VizAllowedValueType.Undefined);
  VizEntry pathEntry=new VizEntry(contentProvider);
  pathEntry.setName(""String_Node_Str"");
  pathEntry.setDescription(""String_Node_Str"");
  template.add(pathEntry);
  return template;
}","/** 
 * Gets the row template for a connection as defined in the  {@link ConnectionTable documentation for the class}.
 * @return An {@code ArrayList<Entry>} containing the template {@code Entry}s for each exposed connection property.
 */
protected ArrayList<VizEntry> createConnectionTemplate(){
  ArrayList<VizEntry> template=new ArrayList<VizEntry>();
  IVizEntryContentProvider contentProvider;
  KeyEntryContentProvider keyContentProvider=new KeyEntryContentProvider(keyManager);
  VizEntry keyEntry=new KeyEntry(keyContentProvider);
  keyEntry.setName(""String_Node_Str"");
  keyEntry.setDescription(""String_Node_Str"");
  template.add(keyEntry);
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry hostEntry=new VizEntry(contentProvider);
  hostEntry.setName(""String_Node_Str"");
  hostEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  template.add(hostEntry);
  PortEntryContentProvider portContentProvider=new PortEntryContentProvider();
  portContentProvider.setDefaultValue(""String_Node_Str"");
  VizEntry hostPortEntry=new PortEntry(portContentProvider);
  hostPortEntry.setName(""String_Node_Str"");
  hostPortEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"" + Integer.toString(PortEntryContentProvider.MIN_PORT) + ""String_Node_Str""+ Integer.toString(PortEntryContentProvider.MAX_PORT)+ ""String_Node_Str"");
  template.add(hostPortEntry);
  contentProvider=new BasicVizEntryContentProvider();
  contentProvider.setAllowedValueType(VizAllowedValueType.Executable);
  VizEntry pathEntry=new VizEntry(contentProvider);
  pathEntry.setName(""String_Node_Str"");
  pathEntry.setDescription(""String_Node_Str"");
  template.add(pathEntry);
  return template;
}",0.994554313556893
133480,"/** 
 * An   {@link Entry} requires a combo widget if its {@link AllowedValueType}is discrete.
 */
@Override public boolean requiresCombo(Object element){
  return isValid(element) && ((VizEntry)element).getValueType() == VizAllowedValueType.Discrete;
}","/** 
 * An   {@link Entry} requires a combo widget if its {@link AllowedValueType}is discrete.
 */
@Override public boolean requiresCombo(Object element){
  return isValid(element) && (((VizEntry)element).getValueType() == VizAllowedValueType.Discrete || ((VizEntry)element).getValueType() == VizAllowedValueType.Executable);
}",0.8724137931034482
133481,"/** 
 * The default constructor.
 * @param viewer The viewer that is using this <code>EditingSupport</code>. <code>Control</code>s required by this class will be constructed under this viewer's <code>Control</code> (usually a <code>Table</code>).
 * @param contentProvider The content provider. The methods required as an <code>EditingSupport</code> are passed to this content provider.
 */
public EntryCellEditingSupport(ColumnViewer viewer,EntryCellContentProvider contentProvider){
  super(viewer);
  this.contentProvider=contentProvider;
  Composite parent=(Composite)viewer.getControl();
  textCell=new TextCellEditor(parent,SWT.LEFT);
  comboCell=new ComboBoxCellEditor(parent,new String[]{},SWT.DROP_DOWN | SWT.READ_ONLY);
  comboCell.getControl().setBackground(parent.getBackground());
  valueMap=new HashMap<String,Integer>();
  return;
}","/** 
 * The default constructor.
 * @param viewer The viewer that is using this <code>EditingSupport</code>. <code>Control</code>s required by this class will be constructed under this viewer's <code>Control</code> (usually a <code>Table</code>).
 * @param contentProvider The content provider. The methods required as an <code>EditingSupport</code> are passed to this content provider.
 */
public EntryCellEditingSupport(ColumnViewer viewer,EntryCellContentProvider contentProvider){
  super(viewer);
  this.contentProvider=contentProvider;
  parent=(Composite)viewer.getControl();
  textCell=new TextCellEditor(parent,SWT.LEFT);
  valueMap=new HashMap<String,Integer>();
  return;
}",0.8935336381450033
133482,"/** 
 * By default, this returns a   {@link TextCellEditor}.
 */
@Override protected CellEditor getCellEditor(Object element){
  CellEditor editor=null;
  if (contentProvider.isValid(element)) {
    if (contentProvider.requiresCombo(element)) {
      editor=comboCell;
      List<String> allowedValues=contentProvider.getAllowedValues(element);
      String[] items=new String[allowedValues.size()];
      comboCell.setItems(allowedValues.toArray(items));
      valueMap.clear();
      for (int i=0; i < items.length; i++) {
        valueMap.put(items[i],i);
      }
    }
 else {
      editor=textCell;
      char echo=ISecretCellContentProvider.PUBLIC_CHAR;
      if (contentProvider.isSecret(element)) {
        echo=contentProvider.getSecretChar();
      }
      Text text=(Text)textCell.getControl();
      text.setEchoChar(echo);
    }
  }
  return editor;
}","/** 
 * By default, this returns a   {@link TextCellEditor}.
 */
@Override protected CellEditor getCellEditor(Object element){
  CellEditor editor=null;
  if (contentProvider.isValid(element)) {
    if (contentProvider.requiresCombo(element)) {
      VizEntry entry=(VizEntry)element;
      System.out.println(""String_Node_Str"");
      boolean isExecutable=entry.getValueType() == VizAllowedValueType.Executable;
      if (isExecutable) {
        comboCell=new FileComboBoxCellEditor(parent,new String[]{},SWT.DROP_DOWN,this,entry);
      }
 else {
        comboCell=new ComboBoxCellEditor(parent,new String[]{},SWT.DROP_DOWN | SWT.READ_ONLY);
      }
      comboCell.getControl().setBackground(parent.getBackground());
      editor=comboCell;
      List<String> allowedValues=contentProvider.getAllowedValues(element);
      String[] items=new String[allowedValues.size()];
      comboCell.setItems(allowedValues.toArray(items));
      valueMap.clear();
      for (int i=0; i < items.length; i++) {
        valueMap.put(items[i],i);
      }
    }
 else {
      editor=textCell;
      char echo=ISecretCellContentProvider.PUBLIC_CHAR;
      if (contentProvider.isSecret(element)) {
        echo=contentProvider.getSecretChar();
      }
      Text text=(Text)textCell.getControl();
      text.setEchoChar(echo);
    }
  }
  return editor;
}",0.784384929641398
133483,"/** 
 * This method creates a Local/Remote file browser button for  an Entry with the Executable AllowedValueType. 
 */
private void createExecutableBrowser(){
  boolean redraw=buttons.isEmpty();
  if (redraw) {
    Button browseButton=new Button(this,SWT.PUSH);
    browseButton.setText(""String_Node_Str"");
    browseButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        String entryValue=null;
        MessageDialog dialog=new MessageDialog(getShell(),""String_Node_Str"",null,""String_Node_Str"",MessageDialog.QUESTION_WITH_CANCEL,new String[]{""String_Node_Str"",""String_Node_Str""},0);
        int result=dialog.open();
        if (result == 1) {
          RemoteResourceBrowser browser=new RemoteResourceBrowser(getShell(),SWT.NONE);
          browser.setTitle(""String_Node_Str"");
          browser.setType(RemoteResourceBrowser.FILE_BROWSER);
          if (browser.open() != Window.OK) {
            return;
          }
          IFileStore fs=browser.getResource();
          entryValue=fs.toURI().toString();
        }
 else {
          FileDialog fileDialog=new FileDialog(getShell());
          fileDialog.setText(""String_Node_Str"");
          String filePath=fileDialog.open();
          if (filePath != null) {
            File importedFile=new File(filePath);
            entryValue=importedFile.toURI().toString();
          }
        }
        if (entryValue != null && !entryValue.isEmpty()) {
          IEntryContentProvider prov=new BasicEntryContentProvider();
          ArrayList<String> valueList=entry.getAllowedValues();
          if (!valueList.contains(entryValue)) {
            valueList.add(entryValue);
          }
          prov.setAllowedValueType(AllowedValueType.Executable);
          prov.setAllowedValues(valueList);
          entry.setContentProvider(prov);
          setEntryValue(entryValue);
        }
        notifyListeners(SWT.Selection,new Event());
        return;
      }
    }
);
    buttons.add(browseButton);
  }
}","/** 
 * This method creates a Local/Remote file browser button for  an Entry with the Executable AllowedValueType. 
 */
private void createExecutableBrowser(){
  boolean redraw=buttons.isEmpty();
  if (redraw) {
    Button browseButton=new Button(this,SWT.PUSH);
    browseButton.setText(""String_Node_Str"");
    browseButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        String entryValue=null;
        MessageDialog dialog=new MessageDialog(getShell(),""String_Node_Str"",null,""String_Node_Str"",MessageDialog.QUESTION_WITH_CANCEL,new String[]{""String_Node_Str"",""String_Node_Str""},0);
        int result=dialog.open();
        if (result == 1) {
          RemoteResourceBrowser browser=new RemoteResourceBrowser(getShell(),SWT.NONE);
          browser.setTitle(""String_Node_Str"");
          browser.setType(RemoteResourceBrowser.FILE_BROWSER);
          if (browser.open() != Window.OK) {
            return;
          }
          IFileStore fs=browser.getResource();
          String hostName=browser.getConnection().getService(IRemoteConnectionHostService.class).getHostname();
          URI uri=fs.toURI();
          entryValue=uri.getScheme() + ""String_Node_Str"" + hostName+ uri.getPath();
        }
 else {
          FileDialog fileDialog=new FileDialog(getShell());
          fileDialog.setText(""String_Node_Str"");
          String filePath=fileDialog.open();
          if (filePath != null) {
            File importedFile=new File(filePath);
            entryValue=importedFile.toURI().toString();
          }
        }
        if (entryValue != null && !entryValue.isEmpty()) {
          IEntryContentProvider prov=new BasicEntryContentProvider();
          ArrayList<String> valueList=entry.getAllowedValues();
          if (!valueList.contains(entryValue)) {
            valueList.add(entryValue);
          }
          prov.setAllowedValueType(AllowedValueType.Executable);
          prov.setAllowedValues(valueList);
          entry.setContentProvider(prov);
          setEntryValue(entryValue);
        }
        notifyListeners(SWT.Selection,new Event());
        return;
      }
    }
);
    buttons.add(browseButton);
  }
}",0.9453345900094252
133484,"@Override public void widgetSelected(SelectionEvent e){
  String entryValue=null;
  MessageDialog dialog=new MessageDialog(getShell(),""String_Node_Str"",null,""String_Node_Str"",MessageDialog.QUESTION_WITH_CANCEL,new String[]{""String_Node_Str"",""String_Node_Str""},0);
  int result=dialog.open();
  if (result == 1) {
    RemoteResourceBrowser browser=new RemoteResourceBrowser(getShell(),SWT.NONE);
    browser.setTitle(""String_Node_Str"");
    browser.setType(RemoteResourceBrowser.FILE_BROWSER);
    if (browser.open() != Window.OK) {
      return;
    }
    IFileStore fs=browser.getResource();
    entryValue=fs.toURI().toString();
  }
 else {
    FileDialog fileDialog=new FileDialog(getShell());
    fileDialog.setText(""String_Node_Str"");
    String filePath=fileDialog.open();
    if (filePath != null) {
      File importedFile=new File(filePath);
      entryValue=importedFile.toURI().toString();
    }
  }
  if (entryValue != null && !entryValue.isEmpty()) {
    IEntryContentProvider prov=new BasicEntryContentProvider();
    ArrayList<String> valueList=entry.getAllowedValues();
    if (!valueList.contains(entryValue)) {
      valueList.add(entryValue);
    }
    prov.setAllowedValueType(AllowedValueType.Executable);
    prov.setAllowedValues(valueList);
    entry.setContentProvider(prov);
    setEntryValue(entryValue);
  }
  notifyListeners(SWT.Selection,new Event());
  return;
}","@Override public void widgetSelected(SelectionEvent e){
  String entryValue=null;
  MessageDialog dialog=new MessageDialog(getShell(),""String_Node_Str"",null,""String_Node_Str"",MessageDialog.QUESTION_WITH_CANCEL,new String[]{""String_Node_Str"",""String_Node_Str""},0);
  int result=dialog.open();
  if (result == 1) {
    RemoteResourceBrowser browser=new RemoteResourceBrowser(getShell(),SWT.NONE);
    browser.setTitle(""String_Node_Str"");
    browser.setType(RemoteResourceBrowser.FILE_BROWSER);
    if (browser.open() != Window.OK) {
      return;
    }
    IFileStore fs=browser.getResource();
    String hostName=browser.getConnection().getService(IRemoteConnectionHostService.class).getHostname();
    URI uri=fs.toURI();
    entryValue=uri.getScheme() + ""String_Node_Str"" + hostName+ uri.getPath();
  }
 else {
    FileDialog fileDialog=new FileDialog(getShell());
    fileDialog.setText(""String_Node_Str"");
    String filePath=fileDialog.open();
    if (filePath != null) {
      File importedFile=new File(filePath);
      entryValue=importedFile.toURI().toString();
    }
  }
  if (entryValue != null && !entryValue.isEmpty()) {
    IEntryContentProvider prov=new BasicEntryContentProvider();
    ArrayList<String> valueList=entry.getAllowedValues();
    if (!valueList.contains(entryValue)) {
      valueList.add(entryValue);
    }
    prov.setAllowedValueType(AllowedValueType.Executable);
    prov.setAllowedValues(valueList);
    entry.setContentProvider(prov);
    setEntryValue(entryValue);
  }
  notifyListeners(SWT.Selection,new Event());
  return;
}",0.7537212449255751
133485,"/** 
 * This method is invoked before the check-input capability to  verify that we have any files we may need for the simulation.  Moose will throw an error before any input validation  occurs if it can't find a file. 
 * @return
 */
private boolean validateFileEntries(){
  refreshProjectSpace();
  for (  final Entry entry : getFileEntries()) {
    try {
      if (entry.getValue().isEmpty() || !project.getFile(entry.getValue()).exists()) {
        throw new Exception(""String_Node_Str"" + entry.getValue());
      }
    }
 catch (    Exception e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      String errorMessage=""String_Node_Str"" + ""String_Node_Str"" + project.getLocation().toOSString() + ""String_Node_Str""+ (entry.getValue().isEmpty() ? entry.getName() : entry.getValue())+ ""String_Node_Str""+ e.getMessage();
      throwErrorMessage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",errorMessage);
      return false;
    }
  }
  return true;
}","/** 
 * This method is invoked before the check-input capability to verify that we have any files we may need for the simulation. Moose will throw an error before any input validation occurs if it can't find a file.
 * @return
 */
private boolean validateFileEntries(){
  refreshProjectSpace();
  for (  final Entry entry : getFileEntries()) {
    try {
      if (entry.getValue().isEmpty() || !project.getFile(entry.getValue()).exists()) {
        throw new Exception(""String_Node_Str"" + entry.getValue());
      }
    }
 catch (    Exception e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      String errorMessage=""String_Node_Str"" + ""String_Node_Str"" + project.getLocation().toOSString() + ""String_Node_Str""+ (entry.getValue().isEmpty() ? entry.getName() : entry.getValue())+ ""String_Node_Str""+ e.getMessage();
      throwErrorMessage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",errorMessage);
      return false;
    }
  }
  return true;
}",0.9979550102249488
133486,"@Override public FormStatus execute(Dictionary<String,String> dictionary){
  IRemoteProcessService processService=null;
  IRemoteProcess checkInputRemoteJob=null;
  MOOSEFileHandler writer=new MOOSEFileHandler();
  Form tempForm=new Form();
  String checkInputString=""String_Node_Str"", line;
  status=FormStatus.ReadyToProcess;
  IFile inputFile=project.getFile(appComponent.retrieveEntry(""String_Node_Str"").getValue());
  URI appUri=URI.create(appComponent.retrieveEntry(""String_Node_Str"").getValue());
  if (!validateFileEntries()) {
    status=FormStatus.InfoError;
    return status;
  }
  tempForm.addComponent(mooseTree);
  writer.write(tempForm,inputFile);
  if (connection != null) {
    ArrayList<IFile> files=new ArrayList<IFile>();
    files.add(inputFile);
    for (    Entry fileE : getFileEntries()) {
      files.add(project.getFile(fileE.getValue()));
    }
    try {
      connection.open(null);
    }
 catch (    RemoteConnectionException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      String errorMessage=""String_Node_Str"";
      throwErrorMessage(""String_Node_Str"",""String_Node_Str"",errorMessage,errorMessage);
      status=FormStatus.InfoError;
      return status;
    }
    if (connection.isOpen()) {
      RemoteFileUploadAction uploadAction=new RemoteFileUploadAction(files,connection);
      uploadAction.execute(null);
      processService=connection.getService(IRemoteProcessService.class);
      processService.setWorkingDirectory(uploadAction.getRemoteUploadDirectoryPath());
      IRemoteProcessBuilder checkInputProcessBuilder=processService.getProcessBuilder(""String_Node_Str"",""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"" + uploadAction.getRemoteUploadDirectoryPath()+ System.getProperty(""String_Node_Str"")+ inputFile.getName());
      checkInputProcessBuilder.redirectErrorStream(true);
      try {
        checkInputRemoteJob=checkInputProcessBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
      }
 catch (      IOException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        String errorMessage=""String_Node_Str"";
        throwErrorMessage(""String_Node_Str"",""String_Node_Str"",errorMessage,errorMessage);
        status=FormStatus.InfoError;
        return status;
      }
      while (!checkInputRemoteJob.isCompleted()) {
        try {
          Thread.currentThread();
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
          logger.error(getClass().getName() + ""String_Node_Str"",e);
        }
      }
      try {
        BufferedReader input=new BufferedReader(new InputStreamReader(checkInputRemoteJob.getInputStream()));
        while ((line=input.readLine()) != null) {
          System.out.println(line);
          checkInputString+=line + ""String_Node_Str"";
        }
        input.close();
        if (checkInputString.contains(""String_Node_Str"")) {
          String errorString=checkInputString.substring(checkInputString.indexOf(""String_Node_Str""),checkInputString.indexOf(""String_Node_Str""));
          errorString=""String_Node_Str"" + errorString.trim() + ""String_Node_Str"";
          throwErrorMessage(""String_Node_Str"",""String_Node_Str"",errorString,""String_Node_Str"" + checkInputString.trim());
          status=FormStatus.InfoError;
          return status;
        }
      }
 catch (      IOException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        status=FormStatus.InfoError;
        return status;
      }
    }
  }
 else {
    File execFile=new File(appUri);
    String[] checkInputCmd={""String_Node_Str"",""String_Node_Str"",execFile.getAbsolutePath() + ""String_Node_Str"" + project.getLocation().toOSString()+ System.getProperty(""String_Node_Str"")+ inputFile.getName()+ ""String_Node_Str""};
    try {
      ProcessBuilder builder=new ProcessBuilder(checkInputCmd).directory(new File(project.getLocation().toOSString()));
      builder.redirectErrorStream(true);
      Process checkInputProcess=builder.start();
      BufferedReader input=new BufferedReader(new InputStreamReader(checkInputProcess.getInputStream()));
      while ((line=input.readLine()) != null) {
        checkInputString+=line + ""String_Node_Str"";
      }
      input.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      status=FormStatus.InfoError;
      return status;
    }
    if (checkInputString.contains(""String_Node_Str"")) {
      String errorString=checkInputString.substring(checkInputString.indexOf(""String_Node_Str""),checkInputString.indexOf(""String_Node_Str""));
      errorString=""String_Node_Str"" + errorString.trim() + ""String_Node_Str"";
      throwErrorMessage(""String_Node_Str"",""String_Node_Str"",errorString,""String_Node_Str"" + checkInputString.trim());
      status=FormStatus.InfoError;
      return status;
    }
  }
  return status;
}","@Override public FormStatus execute(Dictionary<String,String> dictionary){
  IRemoteProcessService processService=null;
  IRemoteProcess checkInputRemoteJob=null;
  MOOSEFileHandler writer=new MOOSEFileHandler();
  Form tempForm=new Form();
  InputStream inputStream=null;
  String checkInputString=""String_Node_Str"", line;
  status=FormStatus.ReadyToProcess;
  IFile inputFile=project.getFile(appComponent.retrieveEntry(""String_Node_Str"").getValue());
  URI appUri=URI.create(appComponent.retrieveEntry(""String_Node_Str"").getValue());
  if (!validateFileEntries()) {
    status=FormStatus.InfoError;
    return status;
  }
  tempForm.addComponent(mooseTree);
  writer.write(tempForm,inputFile);
  if (connection != null) {
    ArrayList<IFile> files=new ArrayList<IFile>();
    files.add(inputFile);
    for (    Entry fileE : getFileEntries()) {
      files.add(project.getFile(fileE.getValue()));
    }
    try {
      connection.open(null);
    }
 catch (    RemoteConnectionException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      String errorMessage=""String_Node_Str"";
      throwErrorMessage(""String_Node_Str"",""String_Node_Str"",errorMessage,errorMessage);
      status=FormStatus.InfoError;
      return status;
    }
    if (connection.isOpen()) {
      RemoteFileUploadAction uploadAction=new RemoteFileUploadAction(files,connection);
      uploadAction.execute(null);
      processService=connection.getService(IRemoteProcessService.class);
      processService.setWorkingDirectory(uploadAction.getRemoteUploadDirectoryPath());
      IRemoteProcessBuilder checkInputProcessBuilder=processService.getProcessBuilder(""String_Node_Str"",""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"" + uploadAction.getRemoteUploadDirectoryPath()+ System.getProperty(""String_Node_Str"")+ inputFile.getName());
      checkInputProcessBuilder.redirectErrorStream(true);
      try {
        checkInputRemoteJob=checkInputProcessBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
      }
 catch (      IOException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        String errorMessage=""String_Node_Str"";
        throwErrorMessage(""String_Node_Str"",""String_Node_Str"",errorMessage,errorMessage);
        status=FormStatus.InfoError;
        return status;
      }
      while (!checkInputRemoteJob.isCompleted()) {
        try {
          Thread.currentThread();
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
          logger.error(getClass().getName() + ""String_Node_Str"",e);
        }
      }
      inputStream=checkInputRemoteJob.getInputStream();
    }
  }
 else {
    File execFile=new File(appUri);
    String[] checkInputCmd={""String_Node_Str"",""String_Node_Str"",execFile.getAbsolutePath() + ""String_Node_Str"" + project.getLocation().toOSString()+ System.getProperty(""String_Node_Str"")+ inputFile.getName()+ ""String_Node_Str""};
    try {
      ProcessBuilder builder=new ProcessBuilder(checkInputCmd).directory(new File(project.getLocation().toOSString()));
      builder.redirectErrorStream(true);
      Process checkInputProcess=builder.start();
      inputStream=checkInputProcess.getInputStream();
    }
 catch (    IOException e) {
      e.printStackTrace();
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      status=FormStatus.InfoError;
      return status;
    }
  }
  try {
    BufferedReader input=new BufferedReader(new InputStreamReader(inputStream));
    while ((line=input.readLine()) != null) {
      checkInputString+=line + ""String_Node_Str"";
    }
    input.close();
    if (checkInputString.contains(""String_Node_Str"")) {
      String errorString=checkInputString.substring(checkInputString.indexOf(""String_Node_Str""),checkInputString.indexOf(""String_Node_Str""));
      errorString=""String_Node_Str"" + errorString.trim() + ""String_Node_Str"";
      throwErrorMessage(""String_Node_Str"",""String_Node_Str"",errorString,""String_Node_Str"" + checkInputString.trim());
      status=FormStatus.InfoError;
      return status;
    }
  }
 catch (  IOException e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    status=FormStatus.InfoError;
    return status;
  }
  return status;
}",0.6608905461724063
133487,"/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String treeNode=null, host=""String_Node_Str"";
  outputFile=mooseLauncher.getOutputFile();
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      host=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
    }
    createICEUpdaterBlock(host);
    retStatus=populateListOfLauncherFiles();
    if (retStatus != FormStatus.ReadyToProcess) {
      return retStatus;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(host);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}","/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#process(java.lang.String)
 */
@Override public FormStatus process(String actionName){
  FormStatus retStatus=FormStatus.InfoError;
  String host=""String_Node_Str"";
  outputFile=mooseLauncher.getOutputFile();
  if (""String_Node_Str"".equals(actionName)) {
    URI appUri=URI.create(modelFiles.retrieveEntry(""String_Node_Str"").getValue());
    boolean isRemote=""String_Node_Str"".equals(appUri.getScheme());
    if (!fullTreeValidation(appUri,isRemote)) {
      return FormStatus.InfoError;
    }
    if (isRemote) {
      IRemoteConnection remoteConnection=mooseLauncher.getRemoteConnection(appUri.getHost());
      host=remoteConnection.getService(IRemoteConnectionHostService.class).getHostname();
    }
    createICEUpdaterBlock(host);
    retStatus=populateListOfLauncherFiles();
    if (retStatus != FormStatus.ReadyToProcess) {
      return retStatus;
    }
    if (isRemote) {
      mooseLauncher.setExecutable(Paths.get(appUri.getRawPath()).getFileName().toString(),""String_Node_Str"",appUri.getRawPath() + ""String_Node_Str"");
      TableComponent hostsTable=(TableComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.parallelId + 1);
      int index=hostsTable.addRow();
      ArrayList<Entry> row=hostsTable.getRow(index);
      ArrayList<Integer> selected=new ArrayList<Integer>();
      selected.add(new Integer(index));
      row.get(0).setValue(host);
      hostsTable.setSelectedRows(selected);
    }
 else {
      mooseLauncher.setExecutable(new File(appUri).getName(),""String_Node_Str"",appUri.getPath() + ""String_Node_Str"");
    }
    ((ResourceComponent)mooseLauncher.getForm().getComponent(JobLauncherForm.outputId)).register(this);
    retStatus=mooseLauncher.process(actionName);
  }
 else   if (""String_Node_Str"".equals(actionName)) {
    retStatus=mooseModel.process(actionName);
  }
  status=retStatus;
  if (status.equals(FormStatus.Processing)) {
    Thread statusThread=new Thread(new Runnable(){
      @Override public void run(){
        while (!status.equals(FormStatus.Processed)) {
          Thread.currentThread();
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
          status=mooseLauncher.getStatus();
        }
        return;
      }
    }
);
    statusThread.start();
  }
  return retStatus;
}",0.9969268592501536
133488,"@Override public void run(){
  new MOOSEFileHandler().setupVariables(modelTree);
  new MOOSEFileHandler().setupAuxVariables(modelTree);
}","@Override public void run(){
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  new MOOSEFileHandler().setupVariables(modelTree);
  new MOOSEFileHandler().setupAuxVariables(modelTree);
}",0.7306666666666667
133489,"/** 
 * The Constructor
 */
public MOOSEBuilder(){
  setName(""String_Node_Str"");
  setType(ItemType.Simulation);
}","/** 
 * The Constructor
 */
public MOOSEBuilder(){
  setName(""String_Node_Str"");
  setType(ItemType.Application);
}",0.960698689956332
133490,"/** 
 * This operation handles a re-draw of EntryComposites that have been recently changed. This method attempts to avoid a complete redraw of all EntryComposites and only re-draws those that have been recently changed.
 */
public void refresh(){
  List<Entry> entries=dataComp.retrieveAllEntries();
  if (!entries.isEmpty() && emptyLabel != null) {
    emptyLabel.dispose();
    emptyLabel=null;
  }
  for (int i=0; i < entries.size(); i++) {
    Entry entry=dataComp.retrieveAllEntries().get(i);
    EntryComposite entryComp=entryMap.get(i);
    if (entryComp != null && !entry.getValue().equals(entryComp.entry.getValue())) {
      entry.setValue(entryComp.entry.getValue());
    }
  }
  int maxIterations=entries.size() > entryMap.size() ? entries.size() : entryMap.size();
  for (int i=0; i < maxIterations; i++) {
    Entry entry=(i < entries.size() ? entries.get(i) : null);
    EntryComposite entryComp=(i < entryMap.size() ? entryMap.get(i) : null);
    String value=(entryComp != null ? entryComp.entry.getValue() : (entry != null ? entry.getValue() : ""String_Node_Str""));
    if (entry == null || !entry.isReady()) {
      disposeEntry(i);
      continue;
    }
 else     if (entryComp == null && entry.isReady()) {
      renderEntry(entry,i);
      entryComp=entryMap.get(i);
      entryComp.setEntryValue(value);
      entryComp.refresh();
    }
 else {
      for (int j=0; j < entry.getAllowedValues().size(); j++) {
        String allowedValue=entry.getAllowedValues().get(j);
        if (!entryComp.entry.getAllowedValues().contains(allowedValue)) {
          disposeEntry(i);
          renderEntry(entry,i);
          entryComp=entryMap.get(i);
          entryComp.setEntryValue(value);
          entryComp.refresh();
        }
      }
    }
  }
  layout();
  return;
}","/** 
 * This operation handles a re-draw of EntryComposites that have been recently changed. This method attempts to avoid a complete redraw of all EntryComposites and only re-draws those that have been recently changed.
 */
public void refresh(){
  List<Entry> entries=dataComp.retrieveAllEntries();
  if (!entries.isEmpty() && emptyLabel != null) {
    emptyLabel.dispose();
    emptyLabel=null;
  }
  for (int i=0; i < entries.size(); i++) {
    Entry entry=dataComp.retrieveAllEntries().get(i);
    EntryComposite entryComp=entryMap.get(i);
    if (entryComp != null && !entry.getValue().equals(entryComp.entry.getValue())) {
      entryComp.entry.setValue(entry.getValue());
    }
  }
  int maxIterations=entries.size() > entryMap.size() ? entries.size() : entryMap.size();
  for (int i=0; i < maxIterations; i++) {
    Entry entry=(i < entries.size() ? entries.get(i) : null);
    EntryComposite entryComp=(i < entryMap.size() ? entryMap.get(i) : null);
    String value=(entryComp != null ? entryComp.entry.getValue() : (entry != null ? entry.getValue() : ""String_Node_Str""));
    if (entry == null || !entry.isReady()) {
      disposeEntry(i);
      continue;
    }
 else     if (entryComp == null && entry.isReady()) {
      renderEntry(entry,i);
      entryComp=entryMap.get(i);
      entryComp.setEntryValue(value);
      entryComp.refresh();
    }
 else {
      for (int j=0; j < entry.getAllowedValues().size(); j++) {
        String allowedValue=entry.getAllowedValues().get(j);
        if (!entryComp.entry.getAllowedValues().contains(allowedValue)) {
          disposeEntry(i);
          renderEntry(entry,i);
          entryComp=entryMap.get(i);
          entryComp.setEntryValue(value);
          entryComp.refresh();
        }
      }
    }
  }
  layout();
  return;
}",0.9944040290990488
133491,"@Override public void update(IUpdateable component){
  if (component == dataComp) {
    PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable(){
      @Override public void run(){
        if (!DataComponentComposite.this.isDisposed()) {
          refresh();
        }
 else {
          dataComp.unregister(DataComponentComposite.this);
        }
      }
    }
);
  }
  return;
}","@Override public void update(IUpdateable component){
  if (component == dataComp) {
    PlatformUI.getWorkbench().getDisplay().syncExec(new Runnable(){
      @Override public void run(){
        if (!DataComponentComposite.this.isDisposed()) {
          refresh();
        }
 else {
          dataComp.unregister(DataComponentComposite.this);
        }
      }
    }
);
  }
  return;
}",0.9987029831387808
133492,"/** 
 * This operation returns the list of reafiles in the ""Nek5000_Model_Builder"" folder of the project space, or null if the folder does not exist or there are no files.
 * @return
 */
private ArrayList<String> getProjectFiles(){
  ArrayList<String> files=new ArrayList<String>();
  if (project != null) {
    try {
      IFolder nekFolder=getPreferencesDirectory();
      if (nekFolder.exists()) {
        IResource[] resources=nekFolder.members();
        for (        IResource resource : resources) {
          logger.debug(""String_Node_Str"" + ""String_Node_Str"" + resource.getName() + ""String_Node_Str"");
          if (resource.getType() == IResource.FILE && resource.getProjectRelativePath().lastSegment().contains(""String_Node_Str"")) {
            files.add(resource.getName());
          }
        }
      }
 else {
        return null;
      }
    }
 catch (    CoreException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
  return files;
}","/** 
 * This operation returns the list of reafiles in the ""Nek5000_Model_Builder"" folder of the project space, or null if the folder does not exist or there are no files.
 * @return
 */
private ArrayList<String> getProjectFiles(){
  ArrayList<String> files=new ArrayList<String>();
  if (project != null) {
    try {
      IFolder nekFolder=getPreferencesDirectory();
      project.refreshLocal(IResource.DEPTH_INFINITE,null);
      if (nekFolder.exists()) {
        IResource[] resources=nekFolder.members();
        for (        IResource resource : resources) {
          logger.debug(""String_Node_Str"" + ""String_Node_Str"" + resource.getName() + ""String_Node_Str"");
          if (resource.getType() == IResource.FILE && resource.getProjectRelativePath().lastSegment().contains(""String_Node_Str"")) {
            files.add(resource.getName());
          }
        }
      }
 else {
        return null;
      }
    }
 catch (    CoreException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
  }
  return files;
}",0.9708353929807216
133493,"/** 
 * This operation handles a re-draw of EntryComposites that have been recently changed. This method attempts to avoid a complete redraw of all EntryComposites and only re-draws those that have been recently changed.
 */
public void refresh(){
  List<Entry> entries=dataComp.retrieveAllEntries();
  if (!entries.isEmpty() && emptyLabel != null) {
    emptyLabel.dispose();
    emptyLabel=null;
  }
  for (int i=0; i < entries.size(); i++) {
    Entry entry=dataComp.retrieveAllEntries().get(i);
    EntryComposite entryComp=entryMap.get(i);
    if (entryComp != null && !entry.getValue().equals(entryComp.entry.getValue())) {
      entryComp.entry.setValue(entry.getValue());
    }
  }
  int maxIterations=entries.size() > entryMap.size() ? entries.size() : entryMap.size();
  for (int i=0; i < maxIterations; i++) {
    Entry entry=(i < entries.size() ? entries.get(i) : null);
    EntryComposite entryComp=(i < entryMap.size() ? entryMap.get(i) : null);
    String value=(entryComp != null ? entryComp.entry.getValue() : (entry != null ? entry.getValue() : ""String_Node_Str""));
    if (entry == null || !entry.isReady()) {
      disposeEntry(i);
      continue;
    }
 else     if (entryComp == null && entry.isReady()) {
      renderEntry(entry,i);
      entryComp=entryMap.get(i);
      entryComp.setEntryValue(value);
      entryComp.refresh();
    }
 else {
      for (int j=0; j < entry.getAllowedValues().size(); j++) {
        String allowedValue=entry.getAllowedValues().get(j);
        if (!entryComp.entry.getAllowedValues().contains(allowedValue)) {
          disposeEntry(i);
          renderEntry(entry,i);
          entryComp=entryMap.get(i);
          entryComp.setEntryValue(value);
          entryComp.refresh();
        }
      }
    }
  }
  layout();
  return;
}","/** 
 * This operation handles a re-draw of EntryComposites that have been recently changed. This method attempts to avoid a complete redraw of all EntryComposites and only re-draws those that have been recently changed.
 */
public void refresh(){
  List<Entry> entries=dataComp.retrieveAllEntries();
  if (!entries.isEmpty() && emptyLabel != null) {
    emptyLabel.dispose();
    emptyLabel=null;
  }
  for (int i=0; i < entries.size(); i++) {
    Entry entry=dataComp.retrieveAllEntries().get(i);
    EntryComposite entryComp=entryMap.get(i);
    if (entryComp != null && !entry.getValue().equals(entryComp.entry.getValue())) {
      entryComp.entry=entry;
      entryComp.refresh();
    }
  }
  int maxIterations=entries.size() > entryMap.size() ? entries.size() : entryMap.size();
  for (int i=0; i < maxIterations; i++) {
    Entry entry=(i < entries.size() ? entries.get(i) : null);
    EntryComposite entryComp=(i < entryMap.size() ? entryMap.get(i) : null);
    String value=(entryComp != null ? entryComp.entry.getValue() : (entry != null ? entry.getValue() : ""String_Node_Str""));
    if (entry == null || !entry.isReady()) {
      disposeEntry(i);
      continue;
    }
 else     if (entryComp == null && entry.isReady()) {
      renderEntry(entry,i);
      entryComp=entryMap.get(i);
      entryComp.setEntryValue(value);
      entryComp.refresh();
    }
 else {
      for (int j=0; j < entry.getAllowedValues().size(); j++) {
        String allowedValue=entry.getAllowedValues().get(j);
        if (!entryComp.entry.getAllowedValues().contains(allowedValue)) {
          disposeEntry(i);
          renderEntry(entry,i);
          entryComp=entryMap.get(i);
          entryComp.setEntryValue(value);
          entryComp.refresh();
        }
      }
    }
  }
  layout();
  return;
}",0.9837988826815642
133494,"/** 
 * The default constructor.
 * @param pageName The name of the page.
 */
public ImportFileWizardPage(String pageName){
  super(pageName);
  setTitle(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  fileDialogStyle=SWT.MULTI;
  filterPath=""String_Node_Str"";
  selectedFileNames=new ArrayList<String>();
  return;
}","/** 
 * The default constructor.
 * @param pageName The name of the page.
 */
public ImportFileWizardPage(String pageName){
  super(pageName);
  if (ClientHolder.getClient() == null) {
    new Client();
  }
  setTitle(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  fileDialogStyle=SWT.MULTI;
  filterPath=""String_Node_Str"";
  selectedFileNames=new ArrayList<String>();
  return;
}",0.9111111111111112
133495,"/** 
 * <p> </p>
 * @param input The name of the input input file, including the file extension
 */
@Override public void loadInput(String input){
  String[] schemas={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  IFile xsdIFile, xmlIFile;
  IFile inputFile=null;
  File temp=null;
  for (  String schemaFile : schemas) {
    try {
      String defaultFilePath=project.getLocation().toOSString() + System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
      temp=new File(defaultFilePath);
      if (!temp.exists()) {
        temp.mkdir();
      }
      temp=new File(defaultFilePath + System.getProperty(""String_Node_Str"") + schemaFile);
      if (!temp.exists()) {
        temp.createNewFile();
        URI uri=new URI(""String_Node_Str"" + schemaFile);
        InputStream reader=uri.toURL().openStream();
        FileOutputStream outStream=new FileOutputStream(temp);
        int fileByte;
        while ((fileByte=reader.read()) != -1) {
          outStream.write(fileByte);
        }
        outStream.close();
      }
    }
 catch (    URISyntaxException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      logger.error(""String_Node_Str"");
    }
catch (    MalformedURLException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      logger.error(""String_Node_Str"");
    }
catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      logger.error(""String_Node_Str"");
    }
  }
  try {
    project.refreshLocal(IResource.DEPTH_INFINITE,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  if (input == null) {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
  }
 else {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFile(input);
  }
  xsdFile=xsdIFile.getRawLocation().makeAbsolute().toFile();
  xmlFile=xmlIFile.getRawLocation().makeAbsolute().toFile();
  if (xsdFile != null) {
    emfComp=new EMFComponent(xsdFile);
    emfComp.load(xsdFile,xmlFile);
    emfComp.setName(""String_Node_Str"");
    emfComp.setId(1);
  }
 else {
    emfComp=new EMFComponent();
    emfComp.setName(""String_Node_Str"");
    emfComp.setDescription(""String_Node_Str"");
    emfComp.setId(1);
  }
  form.addComponent(emfComp);
}","/** 
 * <p> </p>
 * @param input The name of the input input file, including the file extension
 */
@Override public void loadInput(String input){
  form=new Form();
  String[] schemas={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  IFile xsdIFile, xmlIFile;
  IFile inputFile=null;
  File temp=null;
  String defaultFilePath=project.getLocation().toOSString() + System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  temp=new File(defaultFilePath);
  if (!temp.exists()) {
    temp.mkdir();
  }
  for (  String schemaFile : schemas) {
    try {
      temp=new File(defaultFilePath + System.getProperty(""String_Node_Str"") + schemaFile);
      if (!temp.exists()) {
        temp.createNewFile();
        URI uri=new URI(""String_Node_Str"" + schemaFile);
        InputStream reader=uri.toURL().openStream();
        FileOutputStream outStream=new FileOutputStream(temp);
        int fileByte;
        while ((fileByte=reader.read()) != -1) {
          outStream.write(fileByte);
        }
        outStream.close();
      }
    }
 catch (    URISyntaxException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      logger.error(""String_Node_Str"");
    }
catch (    MalformedURLException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      logger.error(""String_Node_Str"");
    }
catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      logger.error(""String_Node_Str"");
    }
  }
  try {
    project.refreshLocal(IResource.DEPTH_INFINITE,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  if (input == null) {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
  }
 else {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFile(input);
  }
  xsdFile=xsdIFile.getRawLocation().makeAbsolute().toFile();
  xmlFile=xmlIFile.getRawLocation().makeAbsolute().toFile();
  if (xsdFile != null) {
    emfComp=new EMFComponent();
    emfComp.load(xsdFile,xmlFile);
    emfComp.setName(""String_Node_Str"");
    emfComp.setId(1);
  }
 else {
    emfComp=new EMFComponent();
    emfComp.setName(""String_Node_Str"");
    emfComp.setDescription(""String_Node_Str"");
    emfComp.setId(1);
  }
  form.addComponent(emfComp);
}",0.972285497342445
133496,"/** 
 * Load the given File as an XMLResource.
 * @param file
 * @return
 */
public boolean load(File file){
  EObject documentRoot=null;
  if (xmlProcessor != null) {
    try {
      xmlResource=(XMLResource)xmlProcessor.load(new FileInputStream(file),null);
    }
 catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      return false;
    }
  }
  if (xmlResource != null && xmlResource.getContents().size() > 0) {
    documentRoot=xmlResource.getContents().get(0);
  }
 else {
    System.out.println(""String_Node_Str"" + file.getAbsolutePath());
    return false;
  }
  if (documentRoot != null) {
    iceEMFTree=new EMFTreeComposite(documentRoot);
    HashMap<EObject,EMFTreeComposite> map=new HashMap<EObject,EMFTreeComposite>();
    map.put(documentRoot,iceEMFTree);
    TreeIterator<EObject> tree=documentRoot.eAllContents();
    while (tree.hasNext()) {
      EObject obj=tree.next();
      map.put(obj,new EMFTreeComposite(obj));
    }
    for (    EObject o : map.keySet()) {
      EObject parent=o.eContainer();
      if (parent != null) {
        map.get(parent).setNextChild(map.get(o));
      }
    }
  }
 else {
    return false;
  }
  return true;
}","/** 
 * Load the given File as an XMLResource.
 * @param file
 * @return whether the operation was successful
 */
public boolean load(File file){
  EObject documentRoot=null;
  if (xmlProcessor != null) {
    try {
      xmlResource=(XMLResource)xmlProcessor.load(new FileInputStream(file),null);
    }
 catch (    IOException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
      return false;
    }
  }
  if (xmlResource != null && xmlResource.getContents().size() > 0) {
    documentRoot=xmlResource.getContents().get(0);
  }
 else {
    System.out.println(""String_Node_Str"" + file.getAbsolutePath());
    return false;
  }
  if (documentRoot != null) {
    int id=1;
    iceEMFTree=new EMFTreeComposite(documentRoot);
    iceEMFTree.setId(id);
    HashMap<EObject,EMFTreeComposite> map=new HashMap<EObject,EMFTreeComposite>();
    map.put(documentRoot,iceEMFTree);
    TreeIterator<EObject> tree=documentRoot.eAllContents();
    EObject obj=null;
    EMFTreeComposite tempTree=null;
    while (tree.hasNext()) {
      id++;
      obj=tree.next();
      tempTree=new EMFTreeComposite(obj);
      tempTree.setId(id);
      map.put(obj,tempTree);
    }
    for (    EObject o : map.keySet()) {
      EObject parent=o.eContainer();
      if (parent != null) {
        map.get(parent).setNextChild(map.get(o));
      }
    }
  }
 else {
    return false;
  }
  return true;
}",0.8823076923076923
133497,"/** 
 * Sets the connection and updates the proxy's information and properties based on the new connection.
 * @param connection The new connection.
 * @return True if the connection could be changed (the URI could beopened), false otherwise.
 */
private boolean setConnection(IVizConnection<IParaViewWebClient> connection){
  boolean opened=false;
  if (connection != this.connection && connection.getState() == ConnectionState.Connected) {
    IParaViewWebClient widget=connection.getWidget();
    if (openFile(widget,uri.getPath())) {
      opened=true;
      this.connection=connection;
      times.clear();
      times.addAll(findTimesteps());
      timestep=0;
      featureMap.clear();
      for (      ProxyFeature featureInfo : findFeatures()) {
        if (featureInfo.setConnection(connection)) {
          featureMap.put(featureInfo.name,featureInfo);
        }
      }
      propertyMap.clear();
      for (      ProxyProperty propertyInfo : findProperties()) {
        if (propertyInfo.setConnection(connection)) {
          propertyMap.put(propertyInfo.name,propertyInfo);
        }
      }
      category=null;
      feature=null;
    }
  }
  return opened;
}","/** 
 * Sets the connection and updates the proxy's information and properties based on the new connection.
 * @param connection The new connection.
 * @return True if the connection could be changed (the URI could beopened), false otherwise.
 */
private boolean setConnection(IVizConnection<IParaViewWebClient> connection){
  boolean opened=false;
  if (connection != this.connection && connection.getState() == ConnectionState.Connected) {
    IParaViewWebClient widget=connection.getWidget();
    if (openFile(widget,uri.getPath())) {
      opened=true;
      this.connection=connection;
      times.clear();
      times.addAll(findTimesteps());
      timestep=0;
      featureMap.clear();
      for (      ProxyFeature featureInfo : findFeatures()) {
        if (featureInfo.setConnection(connection)) {
          featureMap.put(featureInfo.name,featureInfo);
        }
      }
      propertyMap.clear();
      for (      ProxyProperty propertyInfo : findProperties()) {
        if (propertyInfo.setConnection(connection)) {
          propertyMap.put(propertyInfo.name,propertyInfo);
        }
      }
      category=null;
      feature=null;
      ProxyFeature selectedFeature=null;
      for (      ProxyFeature featureInfo : featureMap.values()) {
        if (featureInfo.type == PropertyType.DISCRETE_MULTI) {
          List<String> values=featureInfo.getValues();
          if (!values.isEmpty()) {
            selectedFeature=featureInfo;
            feature=values.get(0);
            break;
          }
        }
 else         if (featureInfo.getValue() != null) {
          selectedFeature=featureInfo;
          feature=featureInfo.getValue();
          break;
        }
      }
      if (selectedFeature != null) {
        category=selectedFeature.name;
        setColorBy(selectedFeature,feature);
        rescale();
        refreshScalarBar();
      }
    }
  }
  return opened;
}",0.7545572916666666
133498,"/** 
 * Refreshes the contents of the viewer. <p> <b>Note:</b> This method should be called on the UI thread! </p>
 */
private void refreshViewer(){
  boolean columnsChanged=false;
  List<VizEntry> newRowTemplate=tableComponent.getRowTemplate();
  if (!newRowTemplate.equals(rowTemplate)) {
    columnsChanged=true;
    rowTemplate=newRowTemplate;
  }
  if (columnsChanged) {
    for (    TableViewerColumn column : columns) {
      column.getColumn().dispose();
    }
    columns.clear();
    EntryCellContentProvider basicContentProvider=new EntryCellContentProvider();
    EntryCellEditingSupport basicEditingSupport=new EntryCellEditingSupport(viewer,basicContentProvider);
    for (int i=0; i < rowTemplate.size(); i++) {
      VizEntry entry=rowTemplate.get(i);
      TableViewerColumn column=new TableViewerColumn(viewer,SWT.LEFT);
      columns.add(column);
      TableColumn columnWidget=column.getColumn();
      columnWidget.setText(entry.getName());
      columnWidget.setToolTipText(entry.getDescription());
      columnWidget.setResizable(true);
      columnWidget.pack();
      ICellContentProvider contentProvider=new TableComponentCellContentProvider(basicContentProvider,i);
      EditingSupport editingSupport=new TableComponentCellEditingSupport(viewer,basicEditingSupport,i);
      column.setLabelProvider(new CellColumnLabelProvider(contentProvider));
      column.setEditingSupport(editingSupport);
    }
  }
  viewer.refresh();
  return;
}","/** 
 * Refreshes the contents of the viewer. <p> <b>Note:</b> This method should be called on the UI thread! </p>
 */
private void refreshViewer(){
  boolean columnsChanged=false;
  List<VizEntry> newRowTemplate=tableComponent.getRowTemplate();
  if (!newRowTemplate.equals(rowTemplate)) {
    columnsChanged=true;
    rowTemplate=newRowTemplate;
  }
  if (columnsChanged) {
    for (    TableViewerColumn column : columns) {
      column.getColumn().dispose();
    }
    columns.clear();
    EntryCellContentProvider basicContentProvider=new EntryCellContentProvider();
    EntryCellEditingSupport basicEditingSupport=new EntryCellEditingSupport(viewer,basicContentProvider);
    GC gc=new GC(viewer.getTable());
    for (int i=0; i < rowTemplate.size(); i++) {
      VizEntry entry=rowTemplate.get(i);
      String header=entry.getName();
      int headerWidth=gc.stringExtent(header).x + 20;
      TableViewerColumn column=new TableViewerColumn(viewer,SWT.LEFT);
      columns.add(column);
      TableColumn columnWidget=column.getColumn();
      columnWidget.setText(header);
      columnWidget.setToolTipText(entry.getDescription());
      columnWidget.setResizable(true);
      columnWidget.setWidth(headerWidth);
      ICellContentProvider contentProvider=new TableComponentCellContentProvider(basicContentProvider,i);
      EditingSupport editingSupport=new TableComponentCellEditingSupport(viewer,basicEditingSupport,i);
      column.setLabelProvider(new CellColumnLabelProvider(contentProvider));
      column.setEditingSupport(editingSupport);
    }
    gc.dispose();
  }
  viewer.refresh();
  return;
}",0.9012345679012346
133499,"/** 
 * This method sets up the BatMLModel Item's Form reference, specifically, it searches for the correct XML schema and creates an EMFComponent and adds it to the Form.
 */
@Override protected void setupForm(){
  if (project != null && project.isAccessible()) {
    try {
      project.refreshLocal(IResource.DEPTH_INFINITE,null);
    }
 catch (    CoreException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
    loadInput(null);
  }
}","/** 
 * This method sets up the BatMLModel Item's Form reference, specifically, it searches for the correct XML schema and creates an EMFComponent and adds it to the Form.
 */
@Override protected void setupForm(){
  form=new Form();
  if (project != null && project.isAccessible()) {
    try {
      project.refreshLocal(IResource.DEPTH_INFINITE,null);
    }
 catch (    CoreException e) {
      logger.error(getClass().getName() + ""String_Node_Str"",e);
    }
    loadInput(null);
  }
}",0.9800629590766002
133500,"/** 
 * Loads a file into the form.  If null input is given a default form will be populated by transferring files from the plugin itself.
 * @param input The name of the input input file, including the file extension
 */
@Override public void loadInput(String input){
  IFile xsdIFile, xmlIFile;
  File temp=null;
  if (form == null) {
    form=new Form();
    String[] schemas={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    String defaultFilePath=project.getLocation().toOSString() + System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
    temp=new File(defaultFilePath);
    if (!temp.exists()) {
      temp.mkdir();
    }
    for (    String schemaFile : schemas) {
      try {
        temp=new File(defaultFilePath + System.getProperty(""String_Node_Str"") + schemaFile);
        if (!temp.exists()) {
          temp.createNewFile();
          URI uri=new URI(""String_Node_Str"" + schemaFile);
          InputStream reader=uri.toURL().openStream();
          FileOutputStream outStream=new FileOutputStream(temp);
          int fileByte;
          while ((fileByte=reader.read()) != -1) {
            outStream.write(fileByte);
          }
          outStream.close();
          reader.close();
        }
      }
 catch (      URISyntaxException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        logger.error(""String_Node_Str"");
      }
catch (      MalformedURLException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        logger.error(""String_Node_Str"");
      }
catch (      IOException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        logger.error(""String_Node_Str"");
      }
    }
    try {
      project.refreshLocal(IResource.DEPTH_INFINITE,null);
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"");
    }
  }
  if (input == null) {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
  }
 else {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFile(input);
  }
  xsdFile=xsdIFile.getRawLocation().makeAbsolute().toFile();
  xmlFile=xmlIFile.getRawLocation().makeAbsolute().toFile();
  if (xsdFile != null) {
    emfComp=new EMFComponent();
    emfComp.load(xsdFile,xmlFile);
    emfComp.setName(""String_Node_Str"");
    emfComp.setId(1);
  }
 else {
    emfComp=new EMFComponent();
    emfComp.setName(""String_Node_Str"");
    emfComp.setDescription(""String_Node_Str"");
    emfComp.setId(1);
  }
  form.addComponent(emfComp);
}","/** 
 * Loads a file into the form.  If null input is given a default form will be populated by transferring files from the plugin itself.
 * @param input The name of the input input file, including the file extension
 */
@Override public void loadInput(String input){
  IFile xsdIFile, xmlIFile;
  File temp=null;
  if (form.getNumberOfComponents() == 0) {
    form=new Form();
    String[] schemas={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    String defaultFilePath=project.getLocation().toOSString() + System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
    temp=new File(defaultFilePath);
    if (!temp.exists()) {
      temp.mkdir();
    }
    for (    String schemaFile : schemas) {
      try {
        temp=new File(defaultFilePath + System.getProperty(""String_Node_Str"") + schemaFile);
        if (!temp.exists()) {
          temp.createNewFile();
          URI uri=new URI(""String_Node_Str"" + schemaFile);
          InputStream reader=uri.toURL().openStream();
          FileOutputStream outStream=new FileOutputStream(temp);
          int fileByte;
          while ((fileByte=reader.read()) != -1) {
            outStream.write(fileByte);
          }
          outStream.close();
          reader.close();
        }
      }
 catch (      URISyntaxException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        logger.error(""String_Node_Str"");
      }
catch (      MalformedURLException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        logger.error(""String_Node_Str"");
      }
catch (      IOException e) {
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        logger.error(""String_Node_Str"");
      }
    }
    try {
      project.refreshLocal(IResource.DEPTH_INFINITE,null);
    }
 catch (    CoreException e) {
      logger.error(""String_Node_Str"");
    }
  }
  if (input == null) {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
  }
 else {
    xsdIFile=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
    xmlIFile=project.getFile(input);
  }
  xsdFile=xsdIFile.getRawLocation().makeAbsolute().toFile();
  xmlFile=xmlIFile.getRawLocation().makeAbsolute().toFile();
  if (xsdFile != null) {
    emfComp=new EMFComponent();
    emfComp.load(xsdFile,xmlFile);
    emfComp.setName(""String_Node_Str"");
    emfComp.setId(1);
  }
 else {
    emfComp=new EMFComponent();
    emfComp.setName(""String_Node_Str"");
    emfComp.setDescription(""String_Node_Str"");
    emfComp.setId(1);
  }
  form.addComponent(emfComp);
}",0.9949766152780184
133501,"protected void reloadSeries(){
  proxySeries.clear();
  if (source != null) {
    proxySeries.putAll(createProxySeries(source));
  }
  return;
}","protected void reloadSeries(){
  if (source != null) {
    Map<String,List<ISeries>> newSeries=createProxySeries(source);
    for (    String category : newSeries.keySet()) {
      List<ISeries> listSeries=newSeries.get(category);
      List<ISeries> oldSeries=proxySeries.get(category);
      if (oldSeries != null) {
        for (int i=0; i < listSeries.size() && i < oldSeries.size(); i++) {
          listSeries.get(i).setEnabled(oldSeries.get(i).isEnabled());
        }
      }
    }
    proxySeries.clear();
    proxySeries.putAll(newSeries);
  }
 else {
    proxySeries.clear();
  }
  return;
}",0.2442953020134228
133502,"@Override public void createControl(Composite parent){
  setMessage(""String_Node_Str"" + ""String_Node_Str"");
  Composite container=new Composite(parent,SWT.NULL);
  container.setLayout(new GridLayout(1,true));
  Composite nameAndDensityComposite=new Composite(container,SWT.None);
  nameAndDensityComposite.setLayout(new GridLayout(2,true));
  nameAndDensityComposite.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  Composite nameComposite=new Composite(nameAndDensityComposite,SWT.NONE);
  GridData nameCompositeGridData=new GridData(SWT.FILL,SWT.FILL,true,false,1,1);
  nameCompositeGridData.widthHint=1;
  nameCompositeGridData.minimumWidth=1;
  nameComposite.setLayoutData(nameCompositeGridData);
  nameComposite.setLayout(new GridLayout(2,false));
  Label nameLabel=new Label(nameComposite,SWT.NONE);
  nameLabel.setText(""String_Node_Str"");
  nameText=new Text(nameComposite,SWT.BORDER);
  nameText.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  Composite densityComposite=new Composite(nameAndDensityComposite,SWT.NONE);
  densityComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  densityComposite.setLayout(new GridLayout(3,false));
  Label densityLabel=new Label(densityComposite,SWT.NONE);
  densityLabel.setText(""String_Node_Str"");
  densityText=new Text(densityComposite,SWT.BORDER);
  densityText.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  Label densityUnitsLabel=new Label(densityComposite,SWT.NONE);
  densityUnitsLabel.setText(""String_Node_Str"");
  ModifyListener listener=new ModifyListener(){
    @Override public void modifyText(    ModifyEvent arg0){
      getWizard().getContainer().updateButtons();
    }
  }
;
  nameText.addModifyListener(listener);
  densityText.addModifyListener(listener);
  Composite stoichiometryComposite=new Composite(container,SWT.NONE);
  stoichiometryComposite.setLayout(new GridLayout(2,false));
  stoichiometryComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  Composite stoichiometryTableComposite=new Composite(stoichiometryComposite,SWT.NONE);
  stoichiometryTableComposite.setLayout(new GridLayout(1,false));
  stoichiometryTableComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  list=new ListComponent<MaterialStack>();
  list.setTableFormat(new MaterialStackWritableTableFormat());
  stoichiometryTable=new ListComponentNattable(stoichiometryTableComposite,list,true);
  Composite stoichiometryButtonComposite=new Composite(stoichiometryComposite,SWT.NONE);
  stoichiometryButtonComposite.setLayout(new GridLayout(1,false));
  stoichiometryButtonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.FILL,false,true,1,1));
  Button addMaterialButton=new Button(stoichiometryButtonComposite,SWT.PUSH);
  addMaterialButton.setText(""String_Node_Str"");
  addMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ElementSourceDialog dialog=new ElementSourceDialog(shell,source);
      if (dialog.open() == Window.OK) {
        Material matToAdd=(Material)dialog.getSelection();
        IMaterialsDatabase database=(IMaterialsDatabase)source;
        for (        Material mat : database.getMaterials()) {
          if (matToAdd.equals(mat)) {
            matToAdd=mat;
            break;
          }
        }
        list.add(new MaterialStack(matToAdd,1));
      }
    }
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
  }
);
  Button deleteMaterialButton=new Button(stoichiometryButtonComposite,SWT.PUSH);
  deleteMaterialButton.setText(""String_Node_Str"");
  deleteMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ListComponent<MaterialStack> selected=stoichiometryTable.getSelectedObjects();
      if (selected.size() > 0) {
        for (        MaterialStack stack : selected) {
          list.remove(stack);
        }
      }
    }
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
  }
);
  setControl(container);
}","@Override public void createControl(Composite parent){
  setMessage(""String_Node_Str"" + ""String_Node_Str"");
  Composite container=new Composite(parent,SWT.NULL);
  container.setLayout(new GridLayout(1,true));
  Composite nameAndDensityComposite=new Composite(container,SWT.None);
  nameAndDensityComposite.setLayout(new GridLayout(2,true));
  nameAndDensityComposite.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  Composite nameComposite=new Composite(nameAndDensityComposite,SWT.NONE);
  GridData nameCompositeGridData=new GridData(SWT.FILL,SWT.FILL,true,false,1,1);
  nameCompositeGridData.widthHint=1;
  nameCompositeGridData.minimumWidth=1;
  nameComposite.setLayoutData(nameCompositeGridData);
  nameComposite.setLayout(new GridLayout(2,false));
  Label nameLabel=new Label(nameComposite,SWT.NONE);
  nameLabel.setText(""String_Node_Str"");
  nameText=new Text(nameComposite,SWT.BORDER);
  nameText.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  Composite densityComposite=new Composite(nameAndDensityComposite,SWT.NONE);
  densityComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  densityComposite.setLayout(new GridLayout(3,false));
  Label densityLabel=new Label(densityComposite,SWT.NONE);
  densityLabel.setText(""String_Node_Str"");
  densityText=new Text(densityComposite,SWT.BORDER);
  densityText.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  Label densityUnitsLabel=new Label(densityComposite,SWT.NONE);
  densityUnitsLabel.setText(""String_Node_Str"");
  ModifyListener listener=new ModifyListener(){
    @Override public void modifyText(    ModifyEvent arg0){
      getWizard().getContainer().updateButtons();
    }
  }
;
  nameText.addModifyListener(listener);
  densityText.addModifyListener(listener);
  Composite stoichiometryComposite=new Composite(container,SWT.NONE);
  stoichiometryComposite.setLayout(new GridLayout(2,false));
  stoichiometryComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  Composite stoichiometryTableComposite=new Composite(stoichiometryComposite,SWT.NONE);
  stoichiometryTableComposite.setLayout(new GridLayout(1,false));
  stoichiometryTableComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  list=new ListComponent<MaterialStack>();
  list.setTableFormat(new MaterialStackWritableTableFormat());
  stoichiometryTable=new ListComponentNattable(stoichiometryTableComposite,list,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stoichiometryTable.getTable());
  Composite stoichiometryButtonComposite=new Composite(stoichiometryComposite,SWT.NONE);
  stoichiometryButtonComposite.setLayout(new GridLayout(1,false));
  stoichiometryButtonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.FILL,false,true,1,1));
  Button addMaterialButton=new Button(stoichiometryButtonComposite,SWT.PUSH);
  addMaterialButton.setText(""String_Node_Str"");
  addMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ElementSourceDialog dialog=new ElementSourceDialog(shell,source);
      if (dialog.open() == Window.OK) {
        Material matToAdd=(Material)dialog.getSelection();
        IMaterialsDatabase database=(IMaterialsDatabase)source;
        for (        Material mat : database.getMaterials()) {
          if (matToAdd.equals(mat)) {
            matToAdd=mat;
            break;
          }
        }
        list.add(new MaterialStack(matToAdd,1));
      }
    }
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
  }
);
  Button deleteMaterialButton=new Button(stoichiometryButtonComposite,SWT.PUSH);
  deleteMaterialButton.setText(""String_Node_Str"");
  deleteMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ListComponent<MaterialStack> selected=stoichiometryTable.getSelectedObjects();
      if (selected.size() > 0) {
        for (        MaterialStack stack : selected) {
          list.remove(stack);
        }
      }
    }
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
  }
);
  setControl(container);
}",0.989332374445643
133503,"/** 
 * If the action name is ReflectivityModel.processActionName, then calculates the reflectivity and scattering density profiles for the material layers and input fields.
 * @see {@link org.eclipse.ice.item.Item#process(String)}
 */
@Override public FormStatus process(String actionName){
  FormStatus retVal=null;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    double[] waveVector;
    double[] rData;
    double[] error;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    IFile userDataFile=project.getFile(fileName);
    Form dataForm=new CSVReader().read(userDataFile);
    ListComponent<String[]> userData=(ListComponent<String[]>)dataForm.getComponent(1);
    waveVector=new double[userData.size()];
    rData=new double[userData.size()];
    error=new double[userData.size()];
    for (int i=0; i < userData.size(); i++) {
      String[] dataLine=userData.get(i);
      double waveDataPoint=Double.parseDouble(dataLine[0]);
      waveVector[i]=waveDataPoint;
      double rDataPoint=Double.parseDouble(dataLine[1]);
      rData[i]=rDataPoint;
      double errorDataPoint=Double.parseDouble(dataLine[2]);
      error[i]=errorDataPoint;
    }
    ReflectivityCalculator calculator=new ReflectivityCalculator();
    ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,false);
    ReflectivityProfile rq4Profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,true);
    double[] reflectivity=profile.reflectivity;
    double[] scatDensity=profile.scatteringDensity;
    double[] depth=profile.depth;
    double[] rq4=rq4Profile.reflectivity;
    double[] rq4Data=new double[rq4.length];
    double rChiSquare=0;
    double rq4ChiSquare=0;
    for (int i=0; i < reflectivity.length; i++) {
      double rPoint=reflectivity[i];
      double rDataPoint=rData[i];
      double rq4Point=rq4[i];
      double rq4DataPoint=rDataPoint * (Math.pow(waveVector[i],4));
      rq4Data[i]=rq4DataPoint;
      rChiSquare+=(rPoint - rDataPoint) * (rPoint - rDataPoint) / rPoint;
      rq4ChiSquare+=(rq4Point - rq4DataPoint) * (rq4Point - rq4DataPoint) / rq4Point;
    }
    ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredEntryName).setValue(Double.toString(rChiSquare));
    ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredRQ4EntryName).setValue(Double.toString(rq4ChiSquare));
    String reflectData=""String_Node_Str"";
    for (int i=0; i < reflectivity.length; i++) {
      reflectData+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(reflectivity[i])+ ""String_Node_Str""+ Double.toString(rData[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
    String scatData=""String_Node_Str"";
    for (int i=0; i < depth.length; i++) {
      scatData+=Double.toString(depth[i]) + ""String_Node_Str"" + Double.toString(scatDensity[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
    String rq4DataStr=""String_Node_Str"";
    for (int i=0; i < rq4.length; i++) {
      rq4DataStr+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(rq4[i])+ ""String_Node_Str""+ Double.toString(rData[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream rq4Stream=new ByteArrayInputStream(rq4DataStr.getBytes());
    ResourceComponent resources=(ResourceComponent)form.getComponent(resourceCompId);
    if (resources.isEmpty()) {
      String basename=""String_Node_Str"" + form.getId() + ""String_Node_Str"";
      IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
      IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
      IFile rq4File=project.getFile(basename + ""String_Node_Str"");
      try {
        if (!reflectivityFile.exists()) {
          reflectivityFile.create(reflectStream,true,null);
        }
        if (!scatteringFile.exists()) {
          scatteringFile.create(scatStream,true,null);
        }
        if (!rq4File.exists()) {
          rq4File.create(rq4Stream,true,null);
        }
        VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
        reflectivitySource.setName(""String_Node_Str"");
        reflectivitySource.setId(1);
        reflectivitySource.setDescription(""String_Node_Str"");
        VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
        scatDensitySource.setName(""String_Node_Str"");
        scatDensitySource.setId(2);
        scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
        VizResource rq4Source=new VizResource(rq4File.getLocation().toFile());
        rq4Source.setName(""String_Node_Str"");
        rq4Source.setId(3);
        rq4Source.setDescription(""String_Node_Str"");
        resources.addResource(reflectivitySource);
        resources.addResource(scatDensitySource);
        resources.addResource(rq4Source);
      }
 catch (      CoreException|IOException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"");
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
 else {
      try {
        VizResource reflectSource=(VizResource)resources.get(0);
        IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
        reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
        reflectSource.setName(reflectSource.getName());
        VizResource scatSource=(VizResource)resources.get(1);
        IFile scatteringFile=project.getFile(scatSource.getContents().getName());
        scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
        scatSource.setName(scatSource.getName());
        VizResource rq4Source=(VizResource)resources.get(2);
        IFile rq4File=project.getFile(rq4Source.getContents().getName());
        rq4File.setContents(new BufferedInputStream(rq4Stream),true,false,null);
        rq4Source.setName(rq4Source.getName());
      }
 catch (      CoreException|NullPointerException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"");
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        retVal=FormStatus.InfoError;
      }
    }
    if (retVal == null) {
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}","/** 
 * If the action name is ReflectivityModel.processActionName, then calculates the reflectivity and scattering density profiles for the material layers and input fields.
 * @see {@link org.eclipse.ice.item.Item#process(String)}
 */
@Override public FormStatus process(String actionName){
  FormStatus retVal=null;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    double[] waveVector;
    double[] rData;
    double[] error;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    IFile userDataFile=project.getFile(fileName);
    Form dataForm=new CSVReader().read(userDataFile);
    ListComponent<String[]> userData=(ListComponent<String[]>)dataForm.getComponent(1);
    waveVector=new double[userData.size()];
    rData=new double[userData.size()];
    error=new double[userData.size()];
    for (int i=0; i < userData.size(); i++) {
      String[] dataLine=userData.get(i);
      double waveDataPoint=Double.parseDouble(dataLine[0]);
      waveVector[i]=waveDataPoint;
      double rDataPoint=Double.parseDouble(dataLine[1]);
      rData[i]=rDataPoint;
      double errorDataPoint=Double.parseDouble(dataLine[2]);
      error[i]=errorDataPoint;
    }
    ReflectivityCalculator calculator=new ReflectivityCalculator();
    ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,false);
    ReflectivityProfile rq4Profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,true);
    double[] reflectivity=profile.reflectivity;
    double[] scatDensity=profile.scatteringDensity;
    double[] depth=profile.depth;
    double[] rq4=rq4Profile.reflectivity;
    double[] rq4Data=new double[rq4.length];
    double rChiSquare=0;
    double rq4ChiSquare=0;
    for (int i=0; i < reflectivity.length; i++) {
      double rPoint=reflectivity[i];
      double rDataPoint=rData[i];
      double rq4Point=rq4[i];
      double rq4DataPoint=rDataPoint * (Math.pow(waveVector[i],4));
      rq4Data[i]=rq4DataPoint;
      rChiSquare+=(rPoint - rDataPoint) * (rPoint - rDataPoint) / rPoint;
      rq4ChiSquare+=(rq4Point - rq4DataPoint) * (rq4Point - rq4DataPoint) / rq4Point;
    }
    ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredEntryName).setValue(Double.toString(rChiSquare));
    ((DataComponent)form.getComponent(outputCompId)).retrieveEntry(ChiSquaredRQ4EntryName).setValue(Double.toString(rq4ChiSquare));
    String reflectData=""String_Node_Str"";
    for (int i=0; i < reflectivity.length; i++) {
      reflectData+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(reflectivity[i])+ ""String_Node_Str""+ Double.toString(rData[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
    String scatData=""String_Node_Str"";
    for (int i=0; i < depth.length; i++) {
      scatData+=Double.toString(depth[i]) + ""String_Node_Str"" + Double.toString(scatDensity[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
    String rq4DataStr=""String_Node_Str"";
    for (int i=0; i < rq4.length; i++) {
      rq4DataStr+=Double.toString(waveVector[i]) + ""String_Node_Str"" + Double.toString(rq4[i])+ ""String_Node_Str""+ Double.toString(rq4Data[i])+ ""String_Node_Str""+ Double.toString(error[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream rq4Stream=new ByteArrayInputStream(rq4DataStr.getBytes());
    ResourceComponent resources=(ResourceComponent)form.getComponent(resourceCompId);
    if (resources.isEmpty()) {
      String basename=""String_Node_Str"" + form.getId() + ""String_Node_Str"";
      IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
      IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
      IFile rq4File=project.getFile(basename + ""String_Node_Str"");
      try {
        if (!reflectivityFile.exists()) {
          reflectivityFile.create(reflectStream,true,null);
        }
        if (!scatteringFile.exists()) {
          scatteringFile.create(scatStream,true,null);
        }
        if (!rq4File.exists()) {
          rq4File.create(rq4Stream,true,null);
        }
        VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
        reflectivitySource.setName(""String_Node_Str"");
        reflectivitySource.setId(1);
        reflectivitySource.setDescription(""String_Node_Str"");
        VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
        scatDensitySource.setName(""String_Node_Str"");
        scatDensitySource.setId(2);
        scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
        VizResource rq4Source=new VizResource(rq4File.getLocation().toFile());
        rq4Source.setName(""String_Node_Str"");
        rq4Source.setId(3);
        rq4Source.setDescription(""String_Node_Str"");
        resources.addResource(reflectivitySource);
        resources.addResource(scatDensitySource);
        resources.addResource(rq4Source);
      }
 catch (      CoreException|IOException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"");
        logger.error(getClass().getName() + ""String_Node_Str"",e);
      }
    }
 else {
      try {
        VizResource reflectSource=(VizResource)resources.get(0);
        IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
        reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
        reflectSource.setName(reflectSource.getName());
        VizResource scatSource=(VizResource)resources.get(1);
        IFile scatteringFile=project.getFile(scatSource.getContents().getName());
        scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
        scatSource.setName(scatSource.getName());
        VizResource rq4Source=(VizResource)resources.get(2);
        IFile rq4File=project.getFile(rq4Source.getContents().getName());
        rq4File.setContents(new BufferedInputStream(rq4Stream),true,false,null);
        rq4Source.setName(rq4Source.getName());
      }
 catch (      CoreException|NullPointerException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"");
        logger.error(getClass().getName() + ""String_Node_Str"",e);
        retVal=FormStatus.InfoError;
      }
    }
    if (retVal == null) {
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}",0.9998715808398612
133504,"/** 
 * Resets the entire graphical viewer with the current settings.
 */
private void resetViewer(){
  int size=assembly.getSize();
  int rows=size;
  int columns=size;
  int fullColumns=size;
  List<State> states;
  TreeSet<Integer> validLocations=new TreeSet<Integer>();
  fullIndices.clear();
  int rowMin=size - 1;
  int rowMax=0;
  int colMin=rowMin;
  int colMax=rowMax;
  if (symmetry == Symmetry.FULL) {
    for (int row=0; row < rows; row++) {
      for (int column=0; column < columns; column++) {
        validLocations.add(row * columns + column);
        fullIndices.add(row * columns + column);
      }
    }
    states=assemblyCellStates;
    rowMin=0;
    rowMax=rows - 1;
    colMin=0;
    colMax=columns - 1;
  }
 else {
    List<Point> locations;
    if (symmetry == Symmetry.QUARTER) {
      locations=GridEditorTools.getQuadrant(size,symmetryIndex);
    }
 else {
      locations=GridEditorTools.getOctant(size,symmetryIndex);
    }
    for (    Point p : locations) {
      if (p.y < rowMin) {
        rowMin=p.y;
      }
      if (p.y > rowMax) {
        rowMax=p.y;
      }
      if (p.x < colMin) {
        colMin=p.x;
      }
      if (p.x > colMax) {
        colMax=p.x;
      }
      validLocations.add(p.y * fullColumns + p.x);
    }
    size=(int)Math.ceil(size / 2.0);
    rows=size;
    columns=size;
    states=new ArrayList<State>(rows * columns);
    for (int row=0; row < rows; row++) {
      for (int col=0; col < columns; col++) {
        int fullIndex=(row + rowMin) * fullColumns + col + colMin;
        fullIndices.add(fullIndex);
        Cell.State state=assemblyCellStates.get(fullIndex);
        if (!validLocations.contains(fullIndex)) {
          state=State.INVALID;
        }
        states.add(state);
      }
    }
  }
  GridEditorInput input=new GridEditorInput(rows,columns);
  input.setStates(states);
  GridLabelProvider labelProvider=assembly.getGridLabelProvider();
  if (labelProvider != null) {
    List<String> labels=new ArrayList<String>();
    for (int row=rowMin; row <= rowMax; row++) {
      labels.add(labelProvider.getLabelFromRow(row));
    }
    if (!labels.contains(null)) {
      input.setRowLabels(labels);
    }
 else {
      input.showRowLabels=false;
    }
    labels.clear();
    for (int column=colMin; column <= colMax; column++) {
      labels.add(labelProvider.getLabelFromColumn(column));
    }
    if (!labels.contains(null)) {
      input.setColumnLabels(labels);
    }
 else {
      input.showColumnLabels=false;
    }
  }
  input.showCellLabels=false;
  grid=new Grid(input);
  GridEditorTools.setViewerContents(viewer,grid);
  Map<?,?> registry=viewer.getEditPartRegistry();
  List<Cell> cells=grid.getCells();
  figures.clear();
  for (int row=0; row < rows; row++) {
    for (int col=0; col < columns; col++) {
      int fullIndex=(row + rowMin) * fullColumns + col + colMin;
      int gridIndex=row * columns + col;
      LWRComponent lwrComp;
      if (validLocations.contains(fullIndex) && (lwrComp=assemblyLocations.get(fullIndex)) != null) {
        AssemblyCellEditPart editPart=(AssemblyCellEditPart)registry.get(cells.get(gridIndex));
        RodFigure figure=(RodFigure)editPart.getFigure();
        figures.add(figure);
        figure.setComponent(lwrComp,maxRadius);
        figure.setDataProvider(assemblyData.get(fullIndex));
        figure.setFeature(feature);
        figure.setAxialLevel(axialLevel);
        figure.setDisplayType(displayType);
        figure.setMinValue(customMinValue);
        figure.setMaxValue(customMaxValue);
        figure.useCustomExtrema(extrema != Extrema.PIECEWISE);
      }
    }
  }
  return;
}","/** 
 * Resets the entire graphical viewer with the current settings.
 */
private void resetViewer(){
  int size=assembly.getSize();
  int rows=size;
  int columns=size;
  int fullColumns=size;
  List<State> states;
  TreeSet<Integer> validLocations=new TreeSet<Integer>();
  fullIndices.clear();
  int rowMin=size - 1;
  int rowMax=0;
  int colMin=rowMin;
  int colMax=rowMax;
  if (symmetry == Symmetry.FULL) {
    for (int row=0; row < rows; row++) {
      for (int column=0; column < columns; column++) {
        validLocations.add(row * columns + column);
        fullIndices.add(row * columns + column);
      }
    }
    states=assemblyCellStates;
    rowMin=0;
    rowMax=rows - 1;
    colMin=0;
    colMax=columns - 1;
  }
 else {
    List<Point> locations;
    if (symmetry == Symmetry.QUARTER) {
      locations=GridEditorTools.getQuadrant(size,symmetryIndex);
    }
 else {
      locations=GridEditorTools.getOctant(size,symmetryIndex);
    }
    for (    Point p : locations) {
      if (p.y < rowMin) {
        rowMin=p.y;
      }
      if (p.y > rowMax) {
        rowMax=p.y;
      }
      if (p.x < colMin) {
        colMin=p.x;
      }
      if (p.x > colMax) {
        colMax=p.x;
      }
      validLocations.add(p.y * fullColumns + p.x);
    }
    size=(int)Math.ceil(size / 2.0);
    rows=size;
    columns=size;
    states=new ArrayList<State>(rows * columns);
    for (int row=0; row < rows; row++) {
      for (int col=0; col < columns; col++) {
        int fullIndex=(row + rowMin) * fullColumns + col + colMin;
        fullIndices.add(fullIndex);
        Cell.State state=assemblyCellStates.get(fullIndex);
        if (!validLocations.contains(fullIndex)) {
          state=State.INVALID;
        }
        states.add(state);
      }
    }
  }
  GridEditorInput input=new GridEditorInput(rows,columns);
  input.setStates(states);
  GridLabelProvider labelProvider=assembly.getGridLabelProvider();
  if (labelProvider != null) {
    List<String> labels=new ArrayList<String>();
    for (int row=rowMin; row <= rowMax; row++) {
      labels.add(labelProvider.getLabelFromRow(row));
    }
    if (!labels.contains(null)) {
      input.setRowLabels(labels);
    }
 else {
      input.showRowLabels=false;
    }
    labels.clear();
    for (int column=colMin; column <= colMax; column++) {
      labels.add(labelProvider.getLabelFromColumn(column));
    }
    if (!labels.contains(null)) {
      input.setColumnLabels(labels);
    }
 else {
      input.showColumnLabels=false;
    }
  }
  input.showCellLabels=false;
  grid=new Grid(input);
  GridEditorTools.setViewerContents(viewer,grid);
  Map<?,?> registry=viewer.getEditPartRegistry();
  List<Cell> cells=grid.getCells();
  figures.clear();
  for (int row=0; row < rows; row++) {
    for (int col=0; col < columns; col++) {
      int fullIndex=(row + rowMin) * fullColumns + col + colMin;
      int gridIndex=row * columns + col;
      LWRComponent lwrComp;
      if (validLocations.contains(fullIndex) && (lwrComp=assemblyLocations.get(fullIndex)) != null) {
        AssemblyCellEditPart editPart=(AssemblyCellEditPart)registry.get(cells.get(gridIndex));
        RodFigure figure=(RodFigure)editPart.getFigure();
        figures.add(figure);
        figure.setColorFactory(colorFactory);
        figure.setComponent(lwrComp,maxRadius);
        figure.setDataProvider(assemblyData.get(fullIndex));
        figure.setFeature(feature);
        figure.setAxialLevel(axialLevel);
        figure.setDisplayType(displayType);
        figure.setMinValue(customMinValue);
        figure.setMaxValue(customMaxValue);
        figure.useCustomExtrema(extrema != Extrema.PIECEWISE);
      }
    }
  }
  return;
}",0.9937038050917054
133505,"/** 
 * Fills out the parent Composite with information and widgets related to this particular IAnalysisView.
 * @param container The Composite containing this IAnalysisView.
 */
@Override public void createViewContent(Composite container){
  super.createViewContent(container);
  container.setLayout(new FillLayout());
  sashForm=new SashForm(container,SWT.HORIZONTAL | SWT.SMOOTH);
  viewer=GridEditorTools.createViewer(sashForm,new AssemblyEditPartFactory(this));
  axialComposite=new Composite(sashForm,SWT.NONE);
  sashForm.setWeights(new int[]{3,1});
  axialScale=new Scale(axialComposite,SWT.VERTICAL);
  axialCanvas=new Canvas(axialComposite,SWT.DOUBLE_BUFFERED);
  axialSpinner=new Spinner(axialComposite,SWT.NONE);
  axialScale.setEnabled(false);
  axialSpinner.setEnabled(false);
  axialScale.setIncrement(1);
  axialScale.setMinimum(1);
  axialScale.setSelection(axialScale.getMaximum());
  axialSpinner.setMinimum(1);
  axialSpinner.setMinimum(1);
  axialSpinner.setSelection(1);
  axialFigure=new AxialRodFigure();
  LightweightSystem lws=new LightweightSystem(axialCanvas);
  lws.setContents(axialFigure);
  axialScale.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      Scale scale=(Scale)e.widget;
      setAxialLevel(scale.getMaximum() - scale.getSelection(),AxialLevelWidget.SCALE);
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      widgetSelected(e);
    }
  }
);
  axialSpinner.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      Spinner spinner=(Spinner)e.widget;
      setAxialLevel(spinner.getSelection() - 1,AxialLevelWidget.SPINNER);
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      widgetSelected(e);
    }
  }
);
  axialComposite.setLayout(new GridLayout(2,false));
  axialScale.setLayoutData(new GridData(GridData.FILL_VERTICAL));
  axialCanvas.setLayoutData(new GridData(GridData.FILL_BOTH));
  viewer.setContextMenu(actionMenuManager);
  axialCanvas.setMenu(actionMenuManager.createContextMenu(container));
  return;
}","/** 
 * Fills out the parent Composite with information and widgets related to this particular IAnalysisView.
 * @param container The Composite containing this IAnalysisView.
 */
@Override public void createViewContent(Composite container){
  super.createViewContent(container);
  container.setLayout(new FillLayout());
  sashForm=new SashForm(container,SWT.HORIZONTAL | SWT.SMOOTH);
  viewer=GridEditorTools.createViewer(sashForm,new AssemblyEditPartFactory(this));
  axialComposite=new Composite(sashForm,SWT.NONE);
  sashForm.setWeights(new int[]{3,1});
  axialScale=new Scale(axialComposite,SWT.VERTICAL);
  axialCanvas=new Canvas(axialComposite,SWT.DOUBLE_BUFFERED);
  axialSpinner=new Spinner(axialComposite,SWT.NONE);
  axialScale.setEnabled(false);
  axialSpinner.setEnabled(false);
  axialScale.setIncrement(1);
  axialScale.setMinimum(1);
  axialScale.setSelection(axialScale.getMaximum());
  axialSpinner.setMinimum(1);
  axialSpinner.setMinimum(1);
  axialSpinner.setSelection(1);
  axialFigure=new AxialRodFigure();
  axialFigure.setColorFactory(colorFactory);
  LightweightSystem lws=new LightweightSystem(axialCanvas);
  lws.setContents(axialFigure);
  axialScale.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      Scale scale=(Scale)e.widget;
      setAxialLevel(scale.getMaximum() - scale.getSelection(),AxialLevelWidget.SCALE);
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      widgetSelected(e);
    }
  }
);
  axialSpinner.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      Spinner spinner=(Spinner)e.widget;
      setAxialLevel(spinner.getSelection() - 1,AxialLevelWidget.SPINNER);
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      widgetSelected(e);
    }
  }
);
  axialComposite.setLayout(new GridLayout(2,false));
  axialScale.setLayoutData(new GridData(GridData.FILL_VERTICAL));
  axialCanvas.setLayoutData(new GridData(GridData.FILL_BOTH));
  viewer.setContextMenu(actionMenuManager);
  axialCanvas.setMenu(actionMenuManager.createContextMenu(container));
  return;
}",0.9896049896049895
133506,"/** 
 * Overrides the parent behavior to provide an axial view of the component's data.
 */
@Override protected void refreshData(){
  data.removeAll();
  double value;
  Color bg;
  Color fg;
  Label label;
  GridData gridData;
  for (int i=featureData.size() - 1; i >= 0; i--) {
    value=featureData.get(i).getValue();
    bg=colorScale.getColor((value - minValue) / (maxValue - minValue));
    int luma=(int)(0.2126 * bg.getRed() + 0.7152 * bg.getGreen() + 0.0722 * bg.getBlue());
    fg=(luma < 75 ? ColorConstants.white : ColorConstants.black);
    label=new Label(String.format(""String_Node_Str"",value));
    label.setBackgroundColor(bg);
    label.setForegroundColor(fg);
    label.setOpaque(true);
    gridData=new GridData(0,0,true,true,1,1);
    gridData=new GridData(GridData.FILL_BOTH);
    data.add(label,gridData);
  }
  if (featureData.isEmpty()) {
    label=new Label(""String_Node_Str"");
    label.setBackgroundColor(ColorConstants.black);
    label.setForegroundColor(ColorConstants.white);
    label.setOpaque(true);
    gridData=new GridData(0,0,true,true,1,1);
    data.add(label,gridData);
  }
  return;
}","/** 
 * Overrides the parent behavior to provide an axial view of the component's data.
 */
@Override protected void refreshData(){
  data.removeAll();
  double value;
  Color bg;
  Color fg;
  Label label;
  GridData gridData;
  for (int i=featureData.size() - 1; i >= 0; i--) {
    value=featureData.get(i).getValue();
    int color=colorFactory.findColor((value - minValue) / (maxValue - minValue));
    bg=colorFactory.createColor(null,color);
    int luma=(int)(0.2126 * bg.getRed() + 0.7152 * bg.getGreen() + 0.0722 * bg.getBlue());
    fg=(luma < 75 ? ColorConstants.white : ColorConstants.black);
    label=new Label(String.format(""String_Node_Str"",value));
    label.setBackgroundColor(bg);
    label.setForegroundColor(fg);
    label.setOpaque(true);
    gridData=new GridData(0,0,true,true,1,1);
    gridData=new GridData(GridData.FILL_BOTH);
    data.add(label,gridData);
  }
  if (featureData.isEmpty()) {
    label=new Label(""String_Node_Str"");
    label.setBackgroundColor(ColorConstants.black);
    label.setForegroundColor(ColorConstants.white);
    label.setOpaque(true);
    gridData=new GridData(0,0,true,true,1,1);
    data.add(label,gridData);
  }
  return;
}",0.9666233203294322
133507,"/** 
 * This method is called whenever the current   {@link #resourceComponent} isupdated. It adds any new plots to the map of  {@link #plots} if possible.
 */
@Override public void update(IUpdateable component){
  if (component != null && component == resourceComponent) {
    ResourceComponent resourceComponent=(ResourceComponent)component;
  }
 else   if (component != null && component instanceof VizResource) {
    final VizResource resource=(VizResource)component;
    plotGridComposite.refreshPlots(resource.getPath());
    if (pageComposite != null) {
      pageComposite.getDisplay().asyncExec(new Runnable(){
        @Override public void run(){
          pageComposite.layout();
          activateEditor();
        }
      }
);
    }
  }
  return;
}","/** 
 * This method is called whenever the current   {@link #resourceComponent} isupdated. It adds any new plots to the map of  {@link #plots} if possible.
 */
@Override public void update(IUpdateable component){
  if (component != null && component == resourceComponent) {
    ResourceComponent resourceComponent=(ResourceComponent)component;
    for (    ICEResource resource : resourceComponent.getResources()) {
      if (resource instanceof VizResource) {
        resource.register(this);
      }
    }
  }
 else   if (component != null && component instanceof VizResource) {
    final VizResource resource=(VizResource)component;
    plotGridComposite.refreshPlots(resource.getPath());
    if (pageComposite != null) {
      pageComposite.getDisplay().asyncExec(new Runnable(){
        @Override public void run(){
          pageComposite.layout();
          activateEditor();
        }
      }
);
    }
  }
  return;
}",0.9027283511269276
133508,"/** 
 * This operation completely recreates the trace for the specified series and replaces the current trace with this one.
 * @param series The series to recreate the trace for
 */
private void redrawSeries(ISeries series){
  double[] xValues=getDoubleValue(independentSeries);
  double[] xPlusError=new double[xValues.length];
  double[] xMinusError=new double[xValues.length];
  if (seriesMap.containsKey(independentSeries)) {
    List<ISeries> errors=seriesMap.get(independentSeries);
    if (errors != null && errors.size() > 0) {
      for (      ISeries errSeries : errors) {
        BasicErrorStyle errStyle=(BasicErrorStyle)errSeries.getStyle();
        if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.PLUS)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.MINUS)) {
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.BOTH)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
      }
    }
  }
  Trace trace=configureTrace(series,xValues,xPlusError,xMinusError);
  if (trace != null) {
    XYZSeriesStyle indepStyle=(XYZSeriesStyle)independentSeries.getStyle();
    trace.setXErrorBarType((ErrorBarType)indepStyle.getProperty(XYZSeriesStyle.ERROR_TYPE));
  }
  xyGraph.remove(this.existingTraces.remove(series));
  xyGraph.addTrace(trace);
  existingTraces.put(series,trace);
}","/** 
 * This operation completely recreates the trace for the specified series and replaces the current trace with this one.
 * @param series The series to recreate the trace for
 */
private void redrawSeries(ISeries series){
  double[] xValues=getDoubleValue(independentSeries);
  double[] xPlusError=new double[xValues.length];
  double[] xMinusError=new double[xValues.length];
  if (seriesMap.containsKey(independentSeries)) {
    List<ISeries> errors=seriesMap.get(independentSeries);
    if (errors != null && errors.size() > 0) {
      for (      ISeries errSeries : errors) {
        BasicErrorStyle errStyle=(BasicErrorStyle)errSeries.getStyle();
        if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.PLUS)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.MINUS)) {
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.BOTH)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
      }
    }
  }
  Trace trace=configureTrace(series,xValues,xPlusError,xMinusError);
  if (trace != null) {
    XYZSeriesStyle indepStyle=(XYZSeriesStyle)independentSeries.getStyle();
    trace.setXErrorBarType((ErrorBarType)indepStyle.getProperty(XYZSeriesStyle.ERROR_TYPE));
  }
  Trace toRemove=this.existingTraces.remove(series);
  trace.setTraceColor(toRemove.getTraceColor());
  xyGraph.remove(toRemove);
  xyGraph.addTrace(trace);
  existingTraces.put(series,trace);
}",0.9288299155609168
133509,"/** 
 * @param plotProvider
 * @param time
 */
private void showXYGraph(PlotProvider plotProvider,double time,boolean resetTraces){
  if (this.xyGraph == null) {
    xyGraph=new XYGraph();
    graphToolbar=new ToolbarArmedXYGraph(xyGraph);
    lws.setContents(graphToolbar);
    existingTraces.clear();
    xyGraph.setTitle(plotProvider.getPlotTitle());
    XYZPlotStyle plotStyle=plotProvider.getPlotStyle();
    if (plotStyle != null) {
      xyGraph.setTransparent((boolean)plotStyle.getProperty(XYZPlotStyle.IS_TRANSPARENT));
      xyGraph.setBackgroundColor((Color)plotStyle.getProperty(XYZPlotStyle.PLOT_COLOR));
      xyGraph.setShowLegend((boolean)plotStyle.getProperty(XYZPlotStyle.SHOW_LEGEND));
      xyGraph.getPlotArea().setShowBorder((boolean)plotStyle.getProperty(XYZPlotStyle.SHOW_PLOT_BORDER));
    }
    XYZAxisStyle xStyle=plotProvider.getXAxisStyle();
    XYZAxisStyle yStyle=plotProvider.getYAxisStyle();
    configureAxis(xyGraph.primaryXAxis,xStyle);
    configureAxis(xyGraph.primaryYAxis,yStyle);
  }
  lws.setContents(graphToolbar);
  ArrayList<ISeries> seriesToPlot=plotProvider.getSeriesAtTime(time);
  if (seriesToPlot == null) {
    seriesToPlot=new ArrayList<ISeries>();
  }
  double[] xValues=getDoubleValue(independentSeries);
  double[] xPlusError=new double[xValues.length];
  double[] xMinusError=new double[xValues.length];
  if (seriesMap.containsKey(independentSeries)) {
    List<ISeries> errors=seriesMap.get(independentSeries);
    if (errors != null && errors.size() > 0) {
      for (      ISeries errSeries : errors) {
        BasicErrorStyle errStyle=(BasicErrorStyle)errSeries.getStyle();
        if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.PLUS)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.MINUS)) {
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.BOTH)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
      }
    }
  }
  XYZSeriesStyle indepStyle=(XYZSeriesStyle)independentSeries.getStyle();
  for (  ISeries iseries : seriesToPlot) {
    ISeries series=(ISeries)iseries;
    Trace trace=configureTrace(series,xValues,xPlusError,xMinusError);
    if (trace != null) {
      trace.setXErrorBarType((ErrorBarType)indepStyle.getProperty(XYZSeriesStyle.ERROR_TYPE));
      this.existingTraces.put(series,trace);
      xyGraph.addTrace(trace);
    }
  }
  xyGraph.repaint();
  return;
}","/** 
 * @param plotProvider
 * @param time
 */
private void showXYGraph(PlotProvider plotProvider,double time,boolean resetTraces){
  if (this.xyGraph == null) {
    xyGraph=new XYGraph();
    graphToolbar=new ToolbarArmedXYGraph(xyGraph);
    lws.setContents(graphToolbar);
    existingTraces.clear();
    xyGraph.setTitle(plotProvider.getPlotTitle());
    XYZPlotStyle plotStyle=plotProvider.getPlotStyle();
    if (plotStyle != null) {
      xyGraph.setTransparent((boolean)plotStyle.getProperty(XYZPlotStyle.IS_TRANSPARENT));
      xyGraph.setBackgroundColor((Color)plotStyle.getProperty(XYZPlotStyle.PLOT_COLOR));
      xyGraph.setShowLegend((boolean)plotStyle.getProperty(XYZPlotStyle.SHOW_LEGEND));
      xyGraph.getPlotArea().setShowBorder((boolean)plotStyle.getProperty(XYZPlotStyle.SHOW_PLOT_BORDER));
    }
    XYZAxisStyle xStyle=plotProvider.getXAxisStyle();
    XYZAxisStyle yStyle=plotProvider.getYAxisStyle();
    configureAxis(xyGraph.primaryXAxis,xStyle);
    configureAxis(xyGraph.primaryYAxis,yStyle);
  }
  lws.setContents(graphToolbar);
  ArrayList<ISeries> seriesToPlot=plotProvider.getSeriesAtTime(time);
  if (seriesToPlot == null) {
    seriesToPlot=new ArrayList<ISeries>();
  }
  double[] xValues=getDoubleValue(independentSeries);
  double[] xPlusError=new double[xValues.length];
  double[] xMinusError=new double[xValues.length];
  if (seriesMap.containsKey(independentSeries)) {
    List<ISeries> errors=seriesMap.get(independentSeries);
    if (errors != null && errors.size() > 0) {
      for (      ISeries errSeries : errors) {
        BasicErrorStyle errStyle=(BasicErrorStyle)errSeries.getStyle();
        if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.PLUS)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.MINUS)) {
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
 else         if (errStyle.getProperty(BasicErrorStyle.ERROR_BAR_TYPE).equals(ErrorBarType.BOTH)) {
          sumArrays(xPlusError,getDoubleValue(errSeries));
          sumArrays(xMinusError,getDoubleValue(errSeries));
        }
      }
    }
  }
  XYZSeriesStyle indepStyle=(XYZSeriesStyle)independentSeries.getStyle();
  for (  ISeries iseries : seriesToPlot) {
    ISeries series=(ISeries)iseries;
    Trace trace=configureTrace(series,xValues,xPlusError,xMinusError);
    if (trace != null) {
      trace.setXErrorBarType((ErrorBarType)indepStyle.getProperty(XYZSeriesStyle.ERROR_TYPE));
      this.existingTraces.put(series,trace);
      if (trace.getTraceColor() == null) {
        List<ISeries> keys=new ArrayList<ISeries>(existingTraces.keySet());
        trace.setTraceColor(XYGraphMediaFactory.getInstance().getColor(XYGraph.DEFAULT_TRACES_COLOR[keys.indexOf(series) % XYGraph.DEFAULT_TRACES_COLOR.length]));
      }
      xyGraph.addTrace(trace);
    }
  }
  return;
}",0.9362231302185112
133510,"/** 
 * Refreshes any plots that may be associated with the specified URI.
 * @param uri The data file.
 */
public void refreshPlots(URI uri){
  for (int i=0; i < plots.size(); i++) {
    IPlot plot=plots.get(i);
    if (plot.getDataSource() == uri) {
      try {
        plot.draw(grid);
      }
 catch (      Exception e) {
        logger.warn(getClass().getName() + ""String_Node_Str"" + ""String_Node_Str""+ uri.getPath()+ ""String_Node_Str"",e);
      }
    }
  }
  return;
}","/** 
 * Refreshes any plots that may be associated with the specified URI.
 * @param uri The data file.
 */
public void refreshPlots(URI uri){
  for (int i=0; i < plots.size(); i++) {
    IPlot plot=plots.get(i);
    if (plot.getDataSource().equals(uri)) {
      try {
        plot.redraw();
      }
 catch (      Exception e) {
        logger.warn(getClass().getName() + ""String_Node_Str"" + ""String_Node_Str""+ uri.getPath()+ ""String_Node_Str"",e);
      }
    }
  }
  return;
}",0.9737118822292324
133511,"/** 
 * Adds the components of the model to the reflectivity page.
 * @see org.eclipse.ice.client.widgets.ICEFormEditor#addPages()
 */
@Override protected void addPages(){
  for (  Component i : iceDataForm.getComponents()) {
    System.out.println(""String_Node_Str"" + i.getName() + ""String_Node_Str""+ i.getId());
    i.accept(this);
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty())) {
    DataComponent dataComp=(DataComponent)componentMap.get(""String_Node_Str"").get(0);
    DataComponent outputComp=(DataComponent)componentMap.get(""String_Node_Str"").get(1);
    ListComponent listComp=(ListComponent)componentMap.get(""String_Node_Str"").get(0);
    ResourceComponent resComp=(ResourceComponent)componentMap.get(""String_Node_Str"").get(0);
    ReflectivityPage page=new ReflectivityPage(this,dataComp.getName() + listComp.getName() + resComp.getName()+ outputComp.getName(),""String_Node_Str"");
    super.resourceComponentPage=page;
    page.setVizService(this.getVizServiceFactory());
    page.setResourceComponent(resComp);
    page.setDataComponent(dataComp);
    page.setList(listComp);
    page.setOutputComponent(outputComp);
    try {
      addPage(page);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
    reflectPage=page;
  }
}","/** 
 * Adds the components of the model to the reflectivity page.
 * @see org.eclipse.ice.client.widgets.ICEFormEditor#addPages()
 */
@Override protected void addPages(){
  for (  Component i : iceDataForm.getComponents()) {
    System.out.println(""String_Node_Str"" + i.getName() + ""String_Node_Str""+ i.getId());
    i.accept(this);
  }
  if (!(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty()) && !(componentMap.get(""String_Node_Str"").isEmpty())) {
    DataComponent dataComp=(DataComponent)componentMap.get(""String_Node_Str"").get(0);
    DataComponent outputComp=(DataComponent)componentMap.get(""String_Node_Str"").get(1);
    ListComponent listComp=(ListComponent)componentMap.get(""String_Node_Str"").get(0);
    ResourceComponent resComp=(ResourceComponent)componentMap.get(""String_Node_Str"").get(0);
    ReflectivityPage page=new ReflectivityPage(this,dataComp.getName() + listComp.getName() + resComp.getName()+ outputComp.getName(),""String_Node_Str"");
    super.resourceComponentPage=page;
    page.setResourceComponent(resComp);
    page.setDataComponent(dataComp);
    page.setList(listComp);
    page.setOutputComponent(outputComp);
    try {
      addPage(page);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
    reflectPage=page;
  }
}",0.9803630974434976
133512,"@Override protected IStatus run(IProgressMonitor monitor){
  monitor.beginTask(""String_Node_Str"",100);
  String sourcePath=getSourcePath(uri);
  ViewerMethods methods=connection.getWidget().getViewerMethods();
  methods.openDatabase(sourcePath);
  monitor.worked(20);
  FileInfo info=methods.getDatabaseInfo();
  monitor.worked(20);
  addIndependentSeries(info);
  monitor.worked(10);
  addPlotCategory(""String_Node_Str"",info.getMeshes());
  monitor.worked(10);
  addPlotCategory(""String_Node_Str"",info.getMaterials());
  monitor.worked(10);
  addPlotCategory(""String_Node_Str"",info.getScalars());
  monitor.worked(10);
  addPlotCategory(""String_Node_Str"",info.getVectors());
  monitor.worked(10);
  loadLock.lock();
  try {
    loading=false;
    loaded=true;
  }
  finally {
    loadLock.unlock();
  }
  notifyPlotListeners(""String_Node_Str"",""String_Node_Str"");
  monitor.worked(10);
  return new Status(Status.OK,""String_Node_Str"",1,""String_Node_Str"",null);
}","@Override protected IStatus run(IProgressMonitor monitor){
  monitor.beginTask(""String_Node_Str"",100);
  String sourcePath=getSourcePath(uri);
  ViewerMethods methods=connection.getWidget().getViewerMethods();
  methods.openDatabase(sourcePath);
  monitor.worked(20);
  FileInfo info=methods.getDatabaseInfo();
  monitor.worked(20);
  addIndependentSeries(info);
  monitor.worked(5);
  addPlotCategory(""String_Node_Str"",info.getMeshes());
  monitor.worked(10);
  addPlotCategory(""String_Node_Str"",info.getMaterials());
  monitor.worked(10);
  addPlotCategory(""String_Node_Str"",info.getScalars());
  monitor.worked(10);
  addPlotCategory(""String_Node_Str"",info.getVectors());
  monitor.worked(10);
  setInitialPlotType();
  monitor.worked(5);
  loadLock.lock();
  try {
    loading=false;
    loaded=true;
  }
  finally {
    loadLock.unlock();
  }
  notifyPlotListeners(""String_Node_Str"",""String_Node_Str"");
  monitor.worked(10);
  return new Status(Status.OK,""String_Node_Str"",1,""String_Node_Str"",null);
}",0.891260162601626
133513,"/** 
 * Loads the plot categories and types (dependent series) as well as the time/cycle data (independent series) from the data source using the viz connection's widget. Work is performed on a separate thread.
 */
private void load(){
  loaded=false;
  loadLock.lock();
  try {
    final URI uri=getDataSource();
    final IVizConnection<VisItSwtConnection> connection=getConnection();
    if (!loading && uri != null && connection != null && connection.getState() == ConnectionState.Connected) {
      loading=true;
      plotTypes.clear();
      super.setIndependentSeries(null);
      Job loadJob=new Job(""String_Node_Str""){
        @Override protected IStatus run(        IProgressMonitor monitor){
          monitor.beginTask(""String_Node_Str"",100);
          String sourcePath=getSourcePath(uri);
          ViewerMethods methods=connection.getWidget().getViewerMethods();
          methods.openDatabase(sourcePath);
          monitor.worked(20);
          FileInfo info=methods.getDatabaseInfo();
          monitor.worked(20);
          addIndependentSeries(info);
          monitor.worked(10);
          addPlotCategory(""String_Node_Str"",info.getMeshes());
          monitor.worked(10);
          addPlotCategory(""String_Node_Str"",info.getMaterials());
          monitor.worked(10);
          addPlotCategory(""String_Node_Str"",info.getScalars());
          monitor.worked(10);
          addPlotCategory(""String_Node_Str"",info.getVectors());
          monitor.worked(10);
          loadLock.lock();
          try {
            loading=false;
            loaded=true;
          }
  finally {
            loadLock.unlock();
          }
          notifyPlotListeners(""String_Node_Str"",""String_Node_Str"");
          monitor.worked(10);
          return new Status(Status.OK,""String_Node_Str"",1,""String_Node_Str"",null);
        }
      }
;
      loadJob.schedule();
    }
  }
  finally {
    loadLock.unlock();
  }
  return;
}","/** 
 * Loads the plot categories and types (dependent series) as well as the time/cycle data (independent series) from the data source using the viz connection's widget. Work is performed on a separate thread.
 */
private void load(){
  loaded=false;
  loadLock.lock();
  try {
    final URI uri=getDataSource();
    final IVizConnection<VisItSwtConnection> connection=getConnection();
    if (!loading && uri != null && connection != null && connection.getState() == ConnectionState.Connected) {
      loading=true;
      plotTypes.clear();
      super.setIndependentSeries(null);
      Job loadJob=new Job(""String_Node_Str""){
        @Override protected IStatus run(        IProgressMonitor monitor){
          monitor.beginTask(""String_Node_Str"",100);
          String sourcePath=getSourcePath(uri);
          ViewerMethods methods=connection.getWidget().getViewerMethods();
          methods.openDatabase(sourcePath);
          monitor.worked(20);
          FileInfo info=methods.getDatabaseInfo();
          monitor.worked(20);
          addIndependentSeries(info);
          monitor.worked(5);
          addPlotCategory(""String_Node_Str"",info.getMeshes());
          monitor.worked(10);
          addPlotCategory(""String_Node_Str"",info.getMaterials());
          monitor.worked(10);
          addPlotCategory(""String_Node_Str"",info.getScalars());
          monitor.worked(10);
          addPlotCategory(""String_Node_Str"",info.getVectors());
          monitor.worked(10);
          setInitialPlotType();
          monitor.worked(5);
          loadLock.lock();
          try {
            loading=false;
            loaded=true;
          }
  finally {
            loadLock.unlock();
          }
          notifyPlotListeners(""String_Node_Str"",""String_Node_Str"");
          monitor.worked(10);
          return new Status(Status.OK,""String_Node_Str"",1,""String_Node_Str"",null);
        }
      }
;
      loadJob.schedule();
    }
  }
  finally {
    loadLock.unlock();
  }
  return;
}",0.9514811031664964
133514,"@Override public void setInput(IWorkbenchPart part,ISelection selection){
  super.setInput(part,selection);
  System.out.println(""String_Node_Str"");
  if (selection instanceof IStructuredSelection) {
    Object second=((IStructuredSelection)selection).toArray()[1];
    if (second instanceof MaterialSelection && second != null) {
      this.selection=(MaterialSelection)second;
      selectionLabel.setText(this.selection.getMaterial().getName() + ""String_Node_Str"" + this.selection.getSelectedProperty()+ ""String_Node_Str"");
      this.selectionText.setText(Double.toString(this.selection.getMaterial().getProperty(this.selection.getSelectedProperty())));
    }
  }
}","@Override public void setInput(IWorkbenchPart part,ISelection selection){
  super.setInput(part,selection);
  if (selection instanceof IStructuredSelection && ((IStructuredSelection)selection).size() >= 2) {
    Object second=((IStructuredSelection)selection).toArray()[1];
    if (second instanceof MaterialSelection && second != null) {
      this.selection=(MaterialSelection)second;
      selectionLabel.setText(this.selection.getMaterial().getName() + ""String_Node_Str"" + this.selection.getSelectedProperty()+ ""String_Node_Str"");
      if (this.selection.getSelectedProperty().equals(""String_Node_Str"")) {
        this.selectionText.setText(this.selection.getMaterial().getName());
        this.selectionText.setEnabled(false);
      }
 else {
        this.selectionText.setText(Double.toString(this.selection.getMaterial().getProperty(this.selection.getSelectedProperty())));
        this.selectionText.setEnabled(true);
      }
    }
  }
}",0.7777089783281734
133515,"@Override public List<Object> toList(){
  List<Object> list=new ArrayList<Object>();
  list.add(data);
  list.add(selectedCell);
  return list;
}","@Override public List<Object> toList(){
  List<Object> list=new ArrayList<Object>();
  list.add(data);
  if (selectedCell != null) {
    list.add(selectedCell);
  }
  return list;
}",0.8895705521472392
133516,"@Override public Iterator iterator(){
  List<Object> list=new ArrayList<Object>();
  list.add(data);
  list.add(selectedCell);
  return list.iterator();
}","@Override public Iterator iterator(){
  List<Object> list=new ArrayList<Object>();
  list.add(data);
  if (selectedCell != null) {
    list.add(selectedCell);
  }
  return list.iterator();
}",0.8953488372093024
133517,"/** 
 * Gets the current selection for this page. If nothing in the list component table is selected, should return the data component for editing its entries, and a material selection for editing the table. Part of the ISelectionProvider interface.
 */
@Override public ISelection getSelection(){
  return new IStructuredSelection(){
    @Override public boolean isEmpty(){
      return false;
    }
    @Override public Object getFirstElement(){
      return data;
    }
    @Override public Iterator iterator(){
      List<Object> list=new ArrayList<Object>();
      list.add(data);
      list.add(selectedCell);
      return list.iterator();
    }
    @Override public int size(){
      return 2;
    }
    @Override public Object[] toArray(){
      return new Object[]{data,selectedCell};
    }
    @Override public List<Object> toList(){
      List<Object> list=new ArrayList<Object>();
      list.add(data);
      list.add(selectedCell);
      return list;
    }
  }
;
}","/** 
 * Gets the current selection for this page. If nothing in the list component table is selected, should return the data component for editing its entries, and a material selection for editing the table. Part of the ISelectionProvider interface.
 */
@Override public ISelection getSelection(){
  return new IStructuredSelection(){
    @Override public boolean isEmpty(){
      return false;
    }
    @Override public Object getFirstElement(){
      return data;
    }
    @Override public Iterator iterator(){
      List<Object> list=new ArrayList<Object>();
      list.add(data);
      if (selectedCell != null) {
        list.add(selectedCell);
      }
      return list.iterator();
    }
    @Override public int size(){
      return selectedCell == null ? 1 : 2;
    }
    @Override public Object[] toArray(){
      if (selectedCell != null) {
        return new Object[]{data,selectedCell};
      }
 else {
        return new DataComponent[]{data};
      }
    }
    @Override public List<Object> toList(){
      List<Object> list=new ArrayList<Object>();
      list.add(data);
      if (selectedCell != null) {
        list.add(selectedCell);
      }
      return list;
    }
  }
;
}",0.8760939659143252
133518,"@Override public int size(){
  return 2;
}","@Override public int size(){
  return selectedCell == null ? 1 : 2;
}",0.7567567567567568
133519,"@Override public Object[] toArray(){
  return new Object[]{data,selectedCell};
}","@Override public Object[] toArray(){
  if (selectedCell != null) {
    return new Object[]{data,selectedCell};
  }
 else {
    return new DataComponent[]{data};
  }
}",0.6504065040650406
133520,"@Override public ITabDescriptor[] getTabDescriptors(IWorkbenchPart part,ISelection selection){
  if (selection != null && selection instanceof IStructuredSelection) {
    Object[] selectedObjects=((IStructuredSelection)selection).toArray();
    if (selectedObjects.length >= 4) {
      Object first=selectedObjects[0];
      if (first instanceof DataComponent) {
        component=(DataComponent)first;
      }
      Object second=selectedObjects[1];
      if (second instanceof DataComponent) {
        output=(DataComponent)second;
      }
      Object third=selectedObjects[2];
      if (third instanceof ListComponent) {
        listComp=(ListComponent)third;
      }
      Object fourth=selectedObjects[3];
      if (fourth instanceof MaterialSelection) {
        tableSelection=(MaterialSelection)fourth;
      }
    }
    Object obj=((IStructuredSelection)selection).getFirstElement();
    if (obj instanceof DataComponent) {
      component=(DataComponent)obj;
    }
    if (descriptors[0] == null) {
      AbstractTabDescriptor inputTabDescriptor=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[0]=inputTabDescriptor;
    }
    if (descriptors[1] == null) {
      AbstractTabDescriptor editCellTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[1]=editCellTab;
    }
    if (descriptors[2] == null) {
      AbstractTabDescriptor outputTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[2]=outputTab;
    }
    ITabDescriptor tab=descriptors[0];
    AbstractSectionDescriptor generalSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(component);
        return section;
      }
      @Override public String getTargetTab(){
        return tab.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    List<AbstractSectionDescriptor> sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(generalSection);
    ((AbstractTabDescriptor)tab).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab2=descriptors[1];
    AbstractSectionDescriptor cellSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityCellEditorSection section;
        section=new ReflectivityCellEditorSection();
        section.setMaterialSelection(tableSelection);
        section.setListComponent(listComp);
        return section;
      }
      @Override public String getTargetTab(){
        return tab2.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(cellSection);
    ((AbstractTabDescriptor)tab2).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab3=descriptors[2];
    AbstractSectionDescriptor outputSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(output);
        return section;
      }
      @Override public String getTargetTab(){
        return tab3.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(outputSection);
    ((AbstractTabDescriptor)tab3).setSectionDescriptors(sectionDescriptors);
  }
  return descriptors;
}","@Override public ITabDescriptor[] getTabDescriptors(IWorkbenchPart part,ISelection selection){
  if (selection != null && selection instanceof IStructuredSelection) {
    Object[] selectedObjects=((IStructuredSelection)selection).toArray();
    if (selectedObjects.length >= 4) {
      Object first=selectedObjects[0];
      if (first instanceof DataComponent) {
        component=(DataComponent)first;
      }
      Object second=selectedObjects[1];
      if (second instanceof DataComponent) {
        output=(DataComponent)second;
      }
      Object third=selectedObjects[2];
      if (third instanceof ListComponent) {
        listComp=(ListComponent)third;
      }
      Object fourth=selectedObjects[3];
      if (fourth instanceof MaterialSelection) {
        tableSelection=(MaterialSelection)fourth;
      }
    }
    Object obj=((IStructuredSelection)selection).getFirstElement();
    if (obj instanceof DataComponent) {
      component=(DataComponent)obj;
    }
    Object obj2=((IStructuredSelection)selection).toList().get(1);
    if (obj2 instanceof DataComponent) {
      output=(DataComponent)obj2;
    }
    if (descriptors[0] == null) {
      AbstractTabDescriptor inputTabDescriptor=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[0]=inputTabDescriptor;
    }
    if (descriptors[1] == null) {
      AbstractTabDescriptor editCellTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[1]=editCellTab;
    }
    if (descriptors[2] == null) {
      AbstractTabDescriptor outputTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[2]=outputTab;
    }
    ITabDescriptor tab=descriptors[0];
    AbstractSectionDescriptor generalSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(component);
        return section;
      }
      @Override public String getTargetTab(){
        return tab.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    List<AbstractSectionDescriptor> sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(generalSection);
    ((AbstractTabDescriptor)tab).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab2=descriptors[1];
    AbstractSectionDescriptor cellSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityCellEditorSection section;
        section=new ReflectivityCellEditorSection();
        section.setMaterialSelection(tableSelection);
        section.setListComponent(listComp);
        return section;
      }
      @Override public String getTargetTab(){
        return tab2.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(cellSection);
    ((AbstractTabDescriptor)tab2).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab3=descriptors[2];
    AbstractSectionDescriptor outputSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(output);
        return section;
      }
      @Override public String getTargetTab(){
        return tab3.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(outputSection);
    ((AbstractTabDescriptor)tab3).setSectionDescriptors(sectionDescriptors);
  }
  return descriptors;
}",0.9845091061335566
133521,"@Override protected void disposePlotContent(Composite plotContent,IVizConnection<VisItSwtConnection> connection){
  if (canvas != null && !canvas.isDisposed()) {
    canvas.dispose();
    canvas=null;
  }
  super.disposePlotContent(plotContent,connection);
}","@Override protected void disposePlotContent(Composite plotContent,IVizConnection<VisItSwtConnection> connection){
  if (canvas != null && !canvas.isDisposed()) {
    canvas.dispose();
    canvas=null;
    timeSlider.dispose();
    timeSlider=null;
  }
  super.disposePlotContent(plotContent,connection);
}",0.91651865008881
133522,"/** 
 * This listens for selection change events in the fileTreeViewer and updates   {@link #deleteFileAction} depending on whether or not a file isselected. Also, this method shows an appropriate plot viewer based on the file type of the selection.
 * @param event The SelectionChangedEvent that fired this method.
 */
@Override public void selectionChanged(SelectionChangedEvent event){
  ISelection selection=event.getSelection();
  if (selection instanceof IStructuredSelection) {
    deleteFileAction.setEnabled(!selection.isEmpty());
    IStructuredSelection structuredSelection=(IStructuredSelection)selection;
    if (!structuredSelection.isEmpty()) {
      Object object=structuredSelection.getFirstElement();
      if (object instanceof VizResource) {
        VizResource vizResource=(VizResource)object;
        String fileName=""String_Node_Str"";
        if (vizResource.getFileSet() != null && vizResource.getFileSetTitle() != null) {
          fileName=vizResource.getFileSetTitle();
        }
 else {
          fileName=vizResource.getContents().getAbsolutePath();
        }
        IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
        File file=vizResource.getContents();
        fileName=file.getAbsolutePath();
        if (fileName.matches(""String_Node_Str"")) {
          try {
            CSVPlot plot=new CSVPlot();
            plot.setDataSource(file.toURI());
            page.openEditor(new PlotEditorInput(plot),PlotEditor.ID);
          }
 catch (          PartInitException e) {
            logger.error(""String_Node_Str"" + file.getAbsolutePath(),e);
          }
        }
 else {
          try {
            getSite().getWorkbenchWindow().getActivePage().showView(VisitPlotViewer.ID);
            IViewReference[] refs=getSite().getWorkbenchWindow().getActivePage().getViewReferences();
            for (            IViewReference ref : refs) {
              if (""String_Node_Str"".equals(ref.getPartName())) {
                VisitPlotViewer view=(VisitPlotViewer)ref.getView(false);
                view.setResource(vizResource);
              }
            }
          }
 catch (          PartInitException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
        }
      }
    }
  }
  return;
}","/** 
 * This listens for selection change events in the fileTreeViewer and updates   {@link #deleteFileAction} depending on whether or not a file isselected. Also, this method shows an appropriate plot viewer based on the file type of the selection.
 * @param event The SelectionChangedEvent that fired this method.
 */
@Override public void selectionChanged(SelectionChangedEvent event){
  ISelection selection=event.getSelection();
  if (selection instanceof IStructuredSelection) {
    deleteFileAction.setEnabled(!selection.isEmpty());
    IStructuredSelection structuredSelection=(IStructuredSelection)selection;
    if (!structuredSelection.isEmpty()) {
      Object object=structuredSelection.getFirstElement();
      if (object instanceof VizResource) {
        VizResource vizResource=(VizResource)object;
        String fileName=""String_Node_Str"";
        if (vizResource.getFileSet() != null && vizResource.getFileSetTitle() != null) {
          fileName=vizResource.getFileSetTitle();
        }
 else {
          fileName=vizResource.getContents().getAbsolutePath();
        }
        IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
        File file=vizResource.getContents();
        fileName=file.getAbsolutePath();
        if (fileName.matches(""String_Node_Str"")) {
          try {
            CSVPlot dataPlot=new CSVPlot();
            dataPlot.setDataSource(file.toURI());
            CSVProxyPlot plot=new CSVProxyPlot();
            plot.setSource(dataPlot);
            page.openEditor(new PlotEditorInput(plot),PlotEditor.ID);
          }
 catch (          Exception e) {
            logger.error(""String_Node_Str"" + file.getAbsolutePath(),e);
          }
        }
 else {
          try {
            getSite().getWorkbenchWindow().getActivePage().showView(VisitPlotViewer.ID);
            IViewReference[] refs=getSite().getWorkbenchWindow().getActivePage().getViewReferences();
            for (            IViewReference ref : refs) {
              if (""String_Node_Str"".equals(ref.getPartName())) {
                VisitPlotViewer view=(VisitPlotViewer)ref.getView(false);
                view.setResource(vizResource);
              }
            }
          }
 catch (          PartInitException e) {
            logger.error(getClass().getName() + ""String_Node_Str"",e);
          }
        }
      }
    }
  }
  return;
}",0.9770212765957448
133523,"/** 
 * This operation draws the (initial) controls in the properties view based on the input.
 */
@Override public void createControls(Composite parent,TabbedPropertySheetPage aTabbedPropertySheetPage){
  super.createControls(parent,aTabbedPropertySheetPage);
  Color backgroundColor=parent.getBackground();
  section=getWidgetFactory().createSection(parent,Section.SHORT_TITLE_BAR | Section.DESCRIPTION);
  section.setText(data.getName());
  section.setDescription(data.getDescription());
  section.setBackground(backgroundColor);
  dataComposite=new DataComponentComposite(data,section,SWT.NONE);
  GridLayout clientLayout=new GridLayout(2,true);
  clientLayout.marginLeft=ITabbedPropertyConstants.HMARGIN;
  clientLayout.marginRight=ITabbedPropertyConstants.HMARGIN;
  clientLayout.marginTop=ITabbedPropertyConstants.VMARGIN;
  clientLayout.marginBottom=ITabbedPropertyConstants.VMARGIN;
  clientLayout.horizontalSpacing=ITabbedPropertyConstants.HSPACE;
  clientLayout.verticalSpacing=ITabbedPropertyConstants.VSPACE;
  dataComposite.setLayout(clientLayout);
  if (System.getProperty(""String_Node_Str"") == null) {
    dataComposite.setBackground(backgroundColor);
  }
 else {
    dataComposite.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
  }
  getWidgetFactory().adapt(dataComposite);
  section.setClient(dataComposite);
  return;
}","/** 
 * This operation draws the (initial) controls in the properties view based on the input.
 */
@Override public void createControls(Composite parent,TabbedPropertySheetPage aTabbedPropertySheetPage){
  super.createControls(parent,aTabbedPropertySheetPage);
  Color backgroundColor=parent.getBackground();
  section=getWidgetFactory().createSection(parent,Section.SHORT_TITLE_BAR | Section.DESCRIPTION);
  section.setText(data.getName());
  section.setDescription(data.getDescription());
  section.setBackground(backgroundColor);
  dataComposite=new DataComponentComposite(data,section,SWT.NONE);
  Control[] children=dataComposite.getChildren();
  for (  Control child : children) {
    if (child instanceof EntryComposite) {
      EntryComposite entry=(EntryComposite)child;
      entry.setEnabled(isEnabled);
    }
  }
  GridLayout clientLayout=new GridLayout(2,true);
  clientLayout.marginLeft=ITabbedPropertyConstants.HMARGIN;
  clientLayout.marginRight=ITabbedPropertyConstants.HMARGIN;
  clientLayout.marginTop=ITabbedPropertyConstants.VMARGIN;
  clientLayout.marginBottom=ITabbedPropertyConstants.VMARGIN;
  clientLayout.horizontalSpacing=ITabbedPropertyConstants.HSPACE;
  clientLayout.verticalSpacing=ITabbedPropertyConstants.VSPACE;
  dataComposite.setLayout(clientLayout);
  if (System.getProperty(""String_Node_Str"") == null) {
    dataComposite.setBackground(backgroundColor);
  }
 else {
    dataComposite.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
  }
  getWidgetFactory().adapt(dataComposite);
  section.setClient(dataComposite);
  return;
}",0.9235474006116208
133524,"@Override public ISection getSectionClass(){
  ReflectivityDataPropertySection section;
  section=new ReflectivityDataPropertySection();
  section.setDataComponent(output);
  return section;
}","@Override public ISection getSectionClass(){
  ReflectivityDataPropertySection section;
  section=new ReflectivityDataPropertySection();
  section.setDataComponent(output);
  section.setIsEnabled(false);
  return section;
}",0.9253012048192772
133525,"@Override public ITabDescriptor[] getTabDescriptors(IWorkbenchPart part,ISelection selection){
  if (selection != null && selection instanceof IStructuredSelection) {
    Object[] selectedObjects=((IStructuredSelection)selection).toArray();
    if (selectedObjects.length >= 4) {
      Object first=selectedObjects[0];
      if (first instanceof DataComponent) {
        component=(DataComponent)first;
      }
      Object second=selectedObjects[1];
      if (second instanceof DataComponent) {
        output=(DataComponent)second;
      }
      Object third=selectedObjects[2];
      if (third instanceof ListComponent) {
        listComp=(ListComponent)third;
      }
      Object fourth=selectedObjects[3];
      if (fourth instanceof MaterialSelection) {
        tableSelection=(MaterialSelection)fourth;
      }
    }
    Object obj=((IStructuredSelection)selection).getFirstElement();
    if (obj instanceof DataComponent) {
      component=(DataComponent)obj;
    }
    Object obj2=((IStructuredSelection)selection).toList().get(1);
    if (obj2 instanceof DataComponent) {
      output=(DataComponent)obj2;
    }
    if (descriptors[0] == null) {
      AbstractTabDescriptor inputTabDescriptor=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[0]=inputTabDescriptor;
    }
    if (descriptors[1] == null) {
      AbstractTabDescriptor editCellTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[1]=editCellTab;
    }
    if (descriptors[2] == null) {
      AbstractTabDescriptor outputTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[2]=outputTab;
    }
    ITabDescriptor tab=descriptors[0];
    AbstractSectionDescriptor generalSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(component);
        return section;
      }
      @Override public String getTargetTab(){
        return tab.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    List<AbstractSectionDescriptor> sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(generalSection);
    ((AbstractTabDescriptor)tab).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab2=descriptors[1];
    AbstractSectionDescriptor cellSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityCellEditorSection section;
        section=new ReflectivityCellEditorSection();
        section.setMaterialSelection(tableSelection);
        section.setListComponent(listComp);
        return section;
      }
      @Override public String getTargetTab(){
        return tab2.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(cellSection);
    ((AbstractTabDescriptor)tab2).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab3=descriptors[2];
    AbstractSectionDescriptor outputSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(output);
        return section;
      }
      @Override public String getTargetTab(){
        return tab3.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(outputSection);
    ((AbstractTabDescriptor)tab3).setSectionDescriptors(sectionDescriptors);
  }
  return descriptors;
}","@Override public ITabDescriptor[] getTabDescriptors(IWorkbenchPart part,ISelection selection){
  if (selection != null && selection instanceof IStructuredSelection) {
    Object[] selectedObjects=((IStructuredSelection)selection).toArray();
    if (selectedObjects.length >= 4) {
      Object first=selectedObjects[0];
      if (first instanceof DataComponent) {
        component=(DataComponent)first;
      }
      Object second=selectedObjects[1];
      if (second instanceof DataComponent) {
        output=(DataComponent)second;
      }
      Object third=selectedObjects[2];
      if (third instanceof ListComponent) {
        listComp=(ListComponent)third;
      }
      Object fourth=selectedObjects[3];
      if (fourth instanceof MaterialSelection) {
        tableSelection=(MaterialSelection)fourth;
      }
    }
    Object obj=((IStructuredSelection)selection).getFirstElement();
    if (obj instanceof DataComponent) {
      component=(DataComponent)obj;
    }
    Object obj2=((IStructuredSelection)selection).toList().get(1);
    if (obj2 instanceof DataComponent) {
      output=(DataComponent)obj2;
    }
    if (descriptors[0] == null) {
      AbstractTabDescriptor inputTabDescriptor=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[0]=inputTabDescriptor;
    }
    if (descriptors[1] == null) {
      AbstractTabDescriptor editCellTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[1]=editCellTab;
    }
    if (descriptors[2] == null) {
      AbstractTabDescriptor outputTab=new AbstractTabDescriptor(){
        @Override public String getCategory(){
          return ""String_Node_Str"";
        }
        @Override public String getId(){
          return ""String_Node_Str"";
        }
        @Override public String getLabel(){
          return ""String_Node_Str"";
        }
      }
;
      descriptors[2]=outputTab;
    }
    ITabDescriptor tab=descriptors[0];
    AbstractSectionDescriptor generalSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(component);
        return section;
      }
      @Override public String getTargetTab(){
        return tab.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    List<AbstractSectionDescriptor> sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(generalSection);
    ((AbstractTabDescriptor)tab).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab2=descriptors[1];
    AbstractSectionDescriptor cellSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityCellEditorSection section;
        section=new ReflectivityCellEditorSection();
        section.setMaterialSelection(tableSelection);
        section.setListComponent(listComp);
        return section;
      }
      @Override public String getTargetTab(){
        return tab2.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(cellSection);
    ((AbstractTabDescriptor)tab2).setSectionDescriptors(sectionDescriptors);
    ITabDescriptor tab3=descriptors[2];
    AbstractSectionDescriptor outputSection=new AbstractSectionDescriptor(){
      @Override public String getId(){
        return ""String_Node_Str"";
      }
      @Override public ISection getSectionClass(){
        ReflectivityDataPropertySection section;
        section=new ReflectivityDataPropertySection();
        section.setDataComponent(output);
        section.setIsEnabled(false);
        return section;
      }
      @Override public String getTargetTab(){
        return tab3.getId();
      }
      @Override public IFilter getFilter(){
        return filter;
      }
    }
;
    sectionDescriptors=new ArrayList<AbstractSectionDescriptor>();
    sectionDescriptors.add(outputSection);
    ((AbstractTabDescriptor)tab3).setSectionDescriptors(sectionDescriptors);
  }
  return descriptors;
}",0.996200841975562
133526,"@Override protected void setup(){
  allowedValueType=AllowedValueType.Continuous;
  defaultValue=""String_Node_Str"";
  return;
}","@Override protected void setup(){
  allowedValueType=AllowedValueType.Continuous;
  allowedValues.add(""String_Node_Str"");
  allowedValues.add(""String_Node_Str"");
  defaultValue=""String_Node_Str"";
  return;
}",0.7604790419161677
133527,"@Override protected void setupForm(){
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(paramsCompId);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(WaveEntryName);
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  Entry numLayersEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  numLayersEntry.setId(2);
  numLayersEntry.setName(RoughnessEntryName);
  numLayersEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(numLayersEntry);
  Entry deltaQ0Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  deltaQ0Entry.setId(3);
  deltaQ0Entry.setName(deltaQ0EntryName);
  deltaQ0Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ0Entry);
  Entry deltaQ1Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  deltaQ1Entry.setId(4);
  deltaQ1Entry.setName(deltaQ1ByQEntryName);
  deltaQ1Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ1Entry);
  Entry waveEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  waveEntry.setId(5);
  waveEntry.setName(WaveLengthEntryName);
  waveEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(waveEntry);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(matListId);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  ResourceComponent resources=new ResourceComponent();
  resources.setName(""String_Node_Str"");
  resources.setDescription(""String_Node_Str"");
  resources.setId(resourceCompId);
  form.addComponent(resources);
  DataComponent output=new DataComponent();
  output.setDescription(""String_Node_Str"");
  output.setName(""String_Node_Str"");
  output.setId(outputCompId);
  Entry chiSquared=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  chiSquared.setId(1);
  chiSquared.setName(ChiSquaredEntryName);
  chiSquared.setDescription(""String_Node_Str"");
  output.addEntry(chiSquared);
  Entry chiSquaredrq4=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  chiSquaredrq4.setId(2);
  chiSquaredrq4.setName(ChiSquaredRQ4EntryName);
  chiSquaredrq4.setDescription(""String_Node_Str"");
  output.addEntry(chiSquaredrq4);
  form.addComponent(output);
  allowedActions.add(0,processActionName);
  return;
}","@Override protected void setupForm(){
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(paramsCompId);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(WaveEntryName);
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  Entry numLayersEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  numLayersEntry.setId(2);
  numLayersEntry.setName(RoughnessEntryName);
  numLayersEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(numLayersEntry);
  Entry deltaQ0Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  deltaQ0Entry.setId(3);
  deltaQ0Entry.setName(deltaQ0EntryName);
  deltaQ0Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ0Entry);
  Entry deltaQ1Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  deltaQ1Entry.setId(4);
  deltaQ1Entry.setName(deltaQ1ByQEntryName);
  deltaQ1Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ1Entry);
  Entry waveEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  waveEntry.setId(5);
  waveEntry.setName(WaveLengthEntryName);
  waveEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(waveEntry);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(matListId);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  ResourceComponent resources=new ResourceComponent();
  resources.setName(""String_Node_Str"");
  resources.setDescription(""String_Node_Str"");
  resources.setId(resourceCompId);
  form.addComponent(resources);
  DataComponent output=new DataComponent();
  output.setDescription(""String_Node_Str"");
  output.setName(""String_Node_Str"");
  output.setId(outputCompId);
  Entry chiSquared=new Entry();
  chiSquared.setId(1);
  chiSquared.setName(ChiSquaredEntryName);
  chiSquared.setDescription(""String_Node_Str"");
  output.addEntry(chiSquared);
  Entry chiSquaredrq4=new Entry();
  chiSquaredrq4.setId(2);
  chiSquaredrq4.setName(ChiSquaredRQ4EntryName);
  chiSquaredrq4.setDescription(""String_Node_Str"");
  output.addEntry(chiSquaredrq4);
  form.addComponent(output);
  allowedActions.add(0,processActionName);
  return;
}",0.9610816274955776
133528,"public void addShape(ICEShape newShape){
  if (isComplex()) {
    notifyListeners();
    ((ComplexShape)shape).addShape(newShape.getShape());
    children.add(newShape);
  }
}","public void addShape(ICEShape newShape){
  if (isComplex()) {
    ((ComplexShape)shape).addShape(newShape.getShape());
    newShape.setParent(this);
    children.add(newShape);
    notifyListeners();
  }
}",0.4736842105263157
133529,"public double[] getRotation(){
  return transformation.getSkew();
}","public double[] getRotation(){
  return transformation.getRotation();
}",0.9130434782608696
133530,"public double[] getScale(){
  return transformation.getSkew();
}","public double[] getScale(){
  return transformation.getScale();
}",0.9612403100775194
133531,"public double[] getTranslation(){
  return transformation.getSkew();
}","public double[] getTranslation(){
  return transformation.getTranslation();
}",0.8979591836734694
133532,"/** 
 * Adds a plot to be drawn inside the plot grid. Note that the same plot can be added more than once.
 * @param plot The plot to draw inside the grid.
 * @return The index of the plot in the grid, or -1 if the plot could not bedrawn.
 * @throws Exception An exception is thrown if the  {@link IPlot} implementationcannot be rendered.
 */
public int addPlot(IPlot plot) throws Exception {
  int index=-1;
  ISeries independent=null;
  List<ISeries> dependent=null;
  if (plot != null && drawnPlots.size() < rows * columns && (independent=plot.getIndependentSeries()) != null && (dependent=plot.getAllDependentSeries(null)) != null) {
    if (dependent.size() > 0 && independent.getBounds() != null) {
      final DrawnPlot drawnPlot=new DrawnPlot(gridComposite,plot);
      drawnPlot.setBackground(getBackground());
      try {
        drawnPlot.draw();
      }
 catch (      Exception e) {
        drawnPlot.dispose();
        throw e;
      }
      index=drawnPlots.size();
      drawnPlots.add(drawnPlot);
      drawnPlotMap.put(drawnPlot,index);
      drawnPlot.addDisposeListener(plotDisposeListener);
      GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true);
      drawnPlot.setLayoutData(gridData);
      refreshLayout();
    }
  }
  return index;
}","/** 
 * Adds a plot to be drawn inside the plot grid. Note that the same plot can be added more than once.
 * @param plot The plot to draw inside the grid.
 * @return The index of the plot in the grid, or -1 if the plot could not bedrawn.
 * @throws Exception An exception is thrown if the  {@link IPlot} implementationcannot be rendered.
 */
public int addPlot(IPlot plot) throws Exception {
  int index=-1;
  if (plot != null && drawnPlots.size() < rows * columns && plot.getIndependentSeries() != null && plot.getCategories().length > 0) {
    final DrawnPlot drawnPlot=new DrawnPlot(gridComposite,plot);
    drawnPlot.setBackground(getBackground());
    try {
      drawnPlot.draw();
    }
 catch (    Exception e) {
      drawnPlot.dispose();
      throw e;
    }
    index=drawnPlots.size();
    drawnPlots.add(drawnPlot);
    drawnPlotMap.put(drawnPlot,index);
    drawnPlot.addDisposeListener(plotDisposeListener);
    GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true);
    drawnPlot.setLayoutData(gridData);
    refreshLayout();
  }
  return index;
}",0.7031650983746792
133533,"/** 
 * Gets the number of times that   {@link #draw(String,String,Composite)}was called.
 */
public int getDrawCount(){
  return children.size();
}","/** 
 * Gets the number of times that   {@link #draw(Composite)} was called.
 */
public int getDrawCount(){
  return children.size();
}",0.9469964664310954
133534,"@Override public IPlot createPlot(URI file) throws Exception {
  createWasCalled.set(true);
  super.createPlot(file);
  FakePlot plot=new FakePlot();
  createCompleted.set(true);
  return plot;
}","@Override public IPlot createPlot(URI file) throws Exception {
  createWasCalled.set(true);
  super.createPlot(file);
  FakePlot plot=new FakePlot();
  plots.add(plot);
  createCompleted.set(true);
  return plot;
}",0.9535452322738386
133535,"/** 
 * Checks that when the same resource is double-clicked in the Resources View, the same editor or plot is opened. In the case of   {@code IPlot}s, the plot should be re-used, although it should be drawn a second time.
 */
@Test public void checkReuse(){
  openNewEditor();
  ICEResource resource;
  ICEResource firstResource;
  vizServiceFactory=new BasicVizServiceFactory();
  FakeCSVVizService csvVizService=new FakeCSVVizService();
  vizServiceFactory.register(csvVizService);
  page.setVizService(vizServiceFactory);
  assertFalse(csvVizService.createWasCalled.getAndSet(false));
  assertFalse(csvVizService.createCompleted.getAndSet(false));
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(0).getDrawCount());
  firstResource=resource;
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(1).getDrawCount());
  doubleClickResource(firstResource);
  assertFalse(csvVizService.createWasCalled.getAndSet(false));
  assertFalse(csvVizService.createCompleted.getAndSet(false));
  assertEquals(2,csvVizService.plots.get(0).getDrawCount());
  closeEditor();
  return;
}","/** 
 * Checks that when the same resource is double-clicked in the Resources View, the same editor or plot is opened. In the case of   {@code IPlot}s, the plot should be re-used, although it should be drawn a second time.
 */
@Test public void checkReuse(){
  openNewEditor();
  ICEResource resource;
  ICEResource firstResource;
  vizServiceFactory=new BasicVizServiceFactory();
  FakeCSVVizService csvVizService=new FakeCSVVizService(){
    @Override public IPlot createPlot(    URI file) throws Exception {
      FakePlot plot=(FakePlot)super.createPlot(file);
      plot.addDependentSeries(""String_Node_Str"",new CSVSeries(null));
      return plot;
    }
  }
;
  vizServiceFactory.register(csvVizService);
  page.setVizService(vizServiceFactory);
  assertFalse(csvVizService.createWasCalled.getAndSet(false));
  assertFalse(csvVizService.createCompleted.getAndSet(false));
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(0).getDrawCount());
  firstResource=resource;
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(1).getDrawCount());
  doubleClickResource(firstResource);
  assertFalse(csvVizService.createWasCalled.getAndSet(false));
  assertFalse(csvVizService.createCompleted.getAndSet(false));
  assertEquals(2,csvVizService.plots.get(0).getDrawCount());
  closeEditor();
  return;
}",0.7838983050847458
133536,"/** 
 * This checks that the   {@code ICEResourcePage} properly handles differentresource file types based on the viz services available in its {@link IVizServiceFactory}.
 */
@Test public void checkVizChainOfCommand(){
  openNewEditor();
  ICEResource resource;
  vizServiceFactory=new BasicVizServiceFactory();
  FakeCSVVizService csvVizService=new FakeCSVVizService();
  FakeTXTVizService txtVizService=new FakeTXTVizService();
  vizServiceFactory.register(csvVizService);
  vizServiceFactory.register(txtVizService);
  page.setVizService(vizServiceFactory);
  assertFalse(csvVizService.createWasCalled.getAndSet(false));
  assertFalse(csvVizService.createCompleted.getAndSet(false));
  assertFalse(txtVizService.createWasCalled.getAndSet(false));
  assertFalse(txtVizService.createCompleted.getAndSet(false));
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  if (txtVizService.createWasCalled.getAndSet(false)) {
    assertFalse(txtVizService.createCompleted.getAndSet(false));
  }
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(0).getDrawCount());
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  if (csvVizService.createWasCalled.getAndSet(false)) {
    assertFalse(csvVizService.createCompleted.getAndSet(false));
  }
  assertTrue(txtVizService.createWasCalled.getAndSet(false));
  assertTrue(txtVizService.createCompleted.getAndSet(false));
  assertEquals(1,txtVizService.plots.get(0).getDrawCount());
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  if (txtVizService.createWasCalled.getAndSet(false)) {
    assertFalse(txtVizService.createCompleted.getAndSet(false));
  }
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(1).getDrawCount());
  closeEditor();
  return;
}","/** 
 * This checks that the   {@code ICEResourcePage} properly handles differentresource file types based on the viz services available in its {@link IVizServiceFactory}.
 */
@Test public void checkVizChainOfCommand(){
  openNewEditor();
  ICEResource resource;
  vizServiceFactory=new BasicVizServiceFactory();
  FakeCSVVizService csvVizService=new FakeCSVVizService(){
    @Override public IPlot createPlot(    URI file) throws Exception {
      FakePlot plot=(FakePlot)super.createPlot(file);
      plot.addDependentSeries(""String_Node_Str"",new CSVSeries(null));
      return plot;
    }
  }
;
  FakeTXTVizService txtVizService=new FakeTXTVizService(){
    @Override public IPlot createPlot(    URI file) throws Exception {
      FakePlot plot=(FakePlot)super.createPlot(file);
      plot.addDependentSeries(""String_Node_Str"",new CSVSeries(null));
      return plot;
    }
  }
;
  vizServiceFactory.register(csvVizService);
  vizServiceFactory.register(txtVizService);
  page.setVizService(vizServiceFactory);
  assertFalse(csvVizService.createWasCalled.getAndSet(false));
  assertFalse(csvVizService.createCompleted.getAndSet(false));
  assertFalse(txtVizService.createWasCalled.getAndSet(false));
  assertFalse(txtVizService.createCompleted.getAndSet(false));
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  if (txtVizService.createWasCalled.getAndSet(false)) {
    assertFalse(txtVizService.createCompleted.getAndSet(false));
  }
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(0).getDrawCount());
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  if (csvVizService.createWasCalled.getAndSet(false)) {
    assertFalse(csvVizService.createCompleted.getAndSet(false));
  }
  assertTrue(txtVizService.createWasCalled.getAndSet(false));
  assertTrue(txtVizService.createCompleted.getAndSet(false));
  assertEquals(1,txtVizService.plots.get(0).getDrawCount());
  resource=createVizResource(new File(""String_Node_Str""));
  resources.add(resource);
  doubleClickResource(resource);
  if (txtVizService.createWasCalled.getAndSet(false)) {
    assertFalse(txtVizService.createCompleted.getAndSet(false));
  }
  assertTrue(csvVizService.createWasCalled.getAndSet(false));
  assertTrue(csvVizService.createCompleted.getAndSet(false));
  assertEquals(1,csvVizService.plots.get(1).getDrawCount());
  closeEditor();
  return;
}",0.7265392781316348
133537,"/** 
 * Checks that exceptions are properly handled by  {@link PlotGridComposite#addPlot(IPlot)}.
 */
@Test public void checkAddPlotExceptions(){
  FakePlot fakePlot;
  IPlot plot;
  final IPlot nullPlot=null;
  final AtomicReference<Exception> eRef=new AtomicReference<Exception>();
  plot=nullPlot;
  try {
    assertEquals(-1,addPlot(plot));
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  fakePlot=new FakePlot(){
    @Override public List<ISeries> getAllDependentSeries(    String category){
      return null;
    }
  }
;
  plot=fakePlot;
  try {
    assertEquals(-1,addPlot(plot));
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  assertEquals(0,fakePlot.getDrawCount());
  fakePlot=new FakePlot();
  plot=fakePlot;
  try {
    assertEquals(-1,addPlot(plot));
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  assertEquals(0,fakePlot.getDrawCount());
  fakePlot=new FakePlot(){
    @Override public Composite draw(    Composite parent) throws Exception {
      super.draw(parent);
      Exception e=new Exception(""String_Node_Str"");
      eRef.set(e);
      throw e;
    }
  }
;
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot=fakePlot;
  try {
    addPlot(plot);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  Exception e) {
    assertSame(eRef.get(),e);
  }
  assertEquals(1,fakePlot.getDrawCount());
  assertTrue(fakePlot.children.get(0).isDisposed());
  return;
}","/** 
 * Checks that exceptions are properly handled by  {@link PlotGridComposite#addPlot(IPlot)}.
 */
@Test public void checkAddPlotExceptions(){
  FakePlot fakePlot;
  IPlot plot;
  final IPlot nullPlot=null;
  final AtomicReference<Exception> eRef=new AtomicReference<Exception>();
  plot=nullPlot;
  try {
    assertEquals(-1,addPlot(plot));
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  fakePlot=new FakePlot();
  plot=fakePlot;
  try {
    assertEquals(-1,addPlot(plot));
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  assertEquals(0,fakePlot.getDrawCount());
  fakePlot=new FakePlot(){
    @Override public Composite draw(    Composite parent) throws Exception {
      super.draw(parent);
      Exception e=new Exception(""String_Node_Str"");
      eRef.set(e);
      throw e;
    }
  }
;
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  fakePlot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot=fakePlot;
  try {
    addPlot(plot);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  Exception e) {
    assertSame(eRef.get(),e);
  }
  assertEquals(1,fakePlot.getDrawCount());
  assertTrue(fakePlot.children.get(0).isDisposed());
  return;
}",0.346095869761833
133538,"/** 
 * Creates a FakePlot that will draw something and has a set of plot types.
 */
private FakePlot createValidPlot(){
  FakePlot plot=new FakePlot();
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  return plot;
}","/** 
 * Creates a FakePlot that will draw something and has a set of plot types.
 */
private FakePlot createValidPlot(){
  FakePlot plot=new FakePlot();
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.addDependentSeries(""String_Node_Str"",getSeries(""String_Node_Str""));
  plot.setIndependentSeries(getSeries(""String_Node_Str""));
  return plot;
}",0.9748615253515126
133539,"/** 
 * <p> Constructor for creating new ComplexShapes with a given OperatorType </p>
 * @param view <p> The current ShapeTreeViewer </p>
 * @param operatorType <p> The type of ComplexShape to create with the action is triggered </p>
 */
public ActionAddShape(ShapeTreeView view,ICEOperatorType operatorType){
  this.view=view;
  this.shapeType=null;
  this.operatorType=operatorType;
  currentShapeId=0;
  this.setText(""String_Node_Str"" + operatorType.toString());
  Map<ICEOperatorType,String> operatorIcons=new HashMap<ICEOperatorType,String>();
  operatorIcons.put(ICEOperatorType.Union,""String_Node_Str"");
  operatorIcons.put(ICEOperatorType.Intersection,""String_Node_Str"");
  operatorIcons.put(ICEOperatorType.Complement,""String_Node_Str"");
  Bundle bundle=FrameworkUtil.getBundle(getClass());
  URL imagePath=BundleUtility.find(bundle,""String_Node_Str"" + operatorIcons.get(operatorType));
  imageDescriptor=ImageDescriptor.createFromURL(imagePath);
}","/** 
 * <p> Constructor for creating new ComplexShapes with a given OperatorType </p>
 * @param view <p> The current ShapeTreeViewer </p>
 * @param operatorType <p> The type of ComplexShape to create with the action is triggered </p>
 */
public ActionAddShape(ShapeTreeView view,OperatorType operatorType){
  this.view=view;
  this.shapeType=null;
  this.operatorType=operatorType;
  currentShapeId=0;
  this.setText(""String_Node_Str"" + operatorType.toString());
  Map<OperatorType,String> operatorIcons=new HashMap<OperatorType,String>();
  operatorIcons.put(OperatorType.Union,""String_Node_Str"");
  operatorIcons.put(OperatorType.Intersection,""String_Node_Str"");
  operatorIcons.put(OperatorType.Complement,""String_Node_Str"");
  Bundle bundle=FrameworkUtil.getBundle(getClass());
  URL imagePath=BundleUtility.find(bundle,""String_Node_Str"" + operatorIcons.get(operatorType));
  imageDescriptor=ImageDescriptor.createFromURL(imagePath);
}",0.931434599156118
133540,"/** 
 * <p> Opens the replicate dialog box and clones the selected shape to the properties </p>
 */
@Override public void run(){
  GeometryComponent geometry=(GeometryComponent)view.treeViewer.getInput();
  ITreeSelection selection=(ITreeSelection)view.treeViewer.getSelection();
  TreePath[] paths=selection.getPaths();
  if (paths.length != 1) {
    return;
  }
  Object selectedObject=paths[0].getLastSegment();
  if (!(selectedObject instanceof ICEShape)) {
    return;
  }
  ICEShape selectedShape=(ICEShape)selectedObject;
  ICETransformation accumulatedTransformation=(ICETransformation)selectedShape.getTransformation().clone();
  ReplicateDialog replicateDialog=new ReplicateDialog(view.getSite().getShell());
  if (replicateDialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  int quantity=replicateDialog.getQuantity();
  double[] shift=replicateDialog.getShift();
  if (quantity == 1) {
    return;
  }
  ICEShape parentShape=selectedShape.getShapeParent();
synchronized (geometry) {
    if (parentShape != null) {
      parentShape.removeShape(selectedShape);
    }
 else {
      geometry.getGeometry().removeShape(selectedShape);
    }
  }
  ICEShape replicateUnion=new ICEShape(ICEOperatorType.Union);
  replicateUnion.setName(""String_Node_Str"");
  replicateUnion.setId(((ICEObject)selectedShape).getId());
  for (int i=1; i <= quantity; i++) {
    ICEShape clonedShape=(ICEShape)((ICEShape)selectedShape).clone();
    clonedShape.removeProperty(""String_Node_Str"");
    ((ICEObject)clonedShape).setId(i);
    clonedShape.setTransformation((ICETransformation)accumulatedTransformation.clone());
    replicateUnion.addShape(clonedShape);
    accumulatedTransformation.translate(shift);
  }
  if (parentShape != null) {
synchronized (geometry) {
      parentShape.addShape(replicateUnion);
    }
    view.treeViewer.refresh(parentShape);
  }
 else {
synchronized (geometry) {
      geometry.getGeometry().addShape(replicateUnion);
    }
    view.treeViewer.refresh();
  }
  view.treeViewer.expandToLevel(parentShape,1);
}","/** 
 * <p> Opens the replicate dialog box and clones the selected shape to the properties </p>
 */
@Override public void run(){
  GeometryComponent geometry=(GeometryComponent)view.treeViewer.getInput();
  ITreeSelection selection=(ITreeSelection)view.treeViewer.getSelection();
  TreePath[] paths=selection.getPaths();
  if (paths.length != 1) {
    return;
  }
  Object selectedObject=paths[0].getLastSegment();
  if (!(selectedObject instanceof ICEShape)) {
    return;
  }
  ICEShape selectedShape=(ICEShape)selectedObject;
  Transformation accumulatedTransformation=(Transformation)selectedShape.getTransformation().clone();
  ReplicateDialog replicateDialog=new ReplicateDialog(view.getSite().getShell());
  if (replicateDialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  int quantity=replicateDialog.getQuantity();
  double[] shift=replicateDialog.getShift();
  if (quantity == 1) {
    return;
  }
  ICEShape parentShape=selectedShape.getShapeParent();
synchronized (geometry) {
    if (parentShape != null) {
      parentShape.removeShape(selectedShape);
    }
 else {
      geometry.getGeometry().removeShape(selectedShape);
    }
  }
  ICEShape replicateUnion=new ICEShape(OperatorType.Union);
  replicateUnion.setName(""String_Node_Str"");
  replicateUnion.setId(((ICEObject)selectedShape).getId());
  for (int i=1; i <= quantity; i++) {
    ICEShape clonedShape=(ICEShape)((ICEShape)selectedShape).clone();
    clonedShape.removeProperty(""String_Node_Str"");
    ((ICEObject)clonedShape).setId(i);
    clonedShape.setTransformation((Transformation)accumulatedTransformation.clone());
    replicateUnion.addShape(clonedShape);
    accumulatedTransformation.translate(shift);
  }
  if (parentShape != null) {
synchronized (geometry) {
      parentShape.addShape(replicateUnion);
    }
    view.treeViewer.refresh(parentShape);
  }
 else {
synchronized (geometry) {
      geometry.getGeometry().addShape(replicateUnion);
    }
    view.treeViewer.refresh();
  }
  view.treeViewer.expandToLevel(parentShape,1);
}",0.9970515970515972
133541,"/** 
 * Converts a geometry Transformation data structure to a JME3 Transform
 * @param The Geometry transformation data structure
 * @return The JME3 transformation
 */
private Transform convertTransformation(ICETransformation transformation){
  Transform transform=new Transform();
  double size=transformation.getSize();
  double[] scale=transformation.getScale();
  double[] rotation=transformation.getRotation();
  double[] translation=transformation.getTranslation();
  transform.setScale((float)(size * scale[0]),(float)(size * scale[1]),(float)(size * scale[2]));
  Quaternion rotationQuat=new Quaternion();
  rotationQuat.fromAngles((float)rotation[0],(float)rotation[1],(float)rotation[2]);
  transform.setRotation(rotationQuat);
  transform.setTranslation((float)translation[0],(float)translation[1],(float)translation[2]);
  return transform;
}","/** 
 * Converts a geometry Transformation data structure to a JME3 Transform
 * @param The Geometry transformation data structure
 * @return The JME3 transformation
 */
private Transform convertTransformation(Transformation transformation){
  Transform transform=new Transform();
  double size=transformation.getSize();
  double[] scale=transformation.getScale();
  double[] rotation=transformation.getRotation();
  double[] translation=transformation.getTranslation();
  transform.setScale((float)(size * scale[0]),(float)(size * scale[1]),(float)(size * scale[2]));
  Quaternion rotationQuat=new Quaternion();
  rotationQuat.fromAngles((float)rotation[0],(float)rotation[1],(float)rotation[2]);
  transform.setRotation(rotationQuat);
  transform.setTranslation((float)translation[0],(float)translation[1],(float)translation[2]);
  return transform;
}",0.9982445874780572
133542,"/** 
 * Performs the synchronization of the node and the list of shapes
 */
public void commit(){
  ICEShape nodeShape=null;
  int primitiveShapeIndex=-1;
  int complexShapeIndex=-1;
  Vector<Integer> removeNodeIndices=new Vector<Integer>();
  int numNodeChildren=this.parentNode.getQuantity();
  for (int nodeIndex=0; nodeIndex < numNodeChildren; nodeIndex++) {
    Spatial childSpatial=this.parentNode.getChild(nodeIndex);
    Node childNode=null;
    try {
      childNode=(Node)childSpatial;
    }
 catch (    ClassCastException e) {
    }
    if (childSpatial.getUserData(""String_Node_Str"") != null) {
      nodeShape=((ShapeTransient)childSpatial.getUserData(""String_Node_Str"")).getShape();
      primitiveShapeIndex=primitiveShapes.indexOf(nodeShape);
      complexShapeIndex=complexShapes.indexOf(nodeShape);
    }
    if (primitiveShapeIndex >= 0) {
      ICEShape primitiveShape=primitiveShapes.get(primitiveShapeIndex);
      childSpatial.setLocalTransform(convertTransformation(primitiveShape.getTransformation()));
      if (primitiveShape.getShapeType() == ICEShapeType.Cylinder) {
        childSpatial.rotate(FastMath.PI / 2,0.0f,0.0f);
      }
      ShapeMaterial shapeMaterial=new ShapeMaterial(assetManager,primitiveShape);
      shapeMaterial.setMaterial(baseMaterial);
      shapeMaterial.setHighlightedMaterial(highlightedMaterial);
      childSpatial.setMaterial(shapeMaterial.getMaterial());
      this.primitiveShapes.remove(primitiveShapeIndex);
    }
 else     if (complexShapeIndex >= 0) {
      ICEShape complexShape=complexShapes.get(complexShapeIndex);
      childSpatial.setLocalTransform(convertTransformation(complexShape.getTransformation()));
      SyncShapes syncComplexShapes=new SyncShapes(childNode);
      ArrayList<ICEShape> complexShapeChildren=complexShape.getShapes();
      for (      ICEShape complexShapeChild : complexShapeChildren) {
        syncComplexShapes.addShape(complexShapeChild);
      }
      syncComplexShapes.commit();
      this.complexShapes.remove(complexShapeIndex);
    }
 else {
      removeNodeIndices.add(new Integer(nodeIndex));
    }
  }
  Collections.reverse(removeNodeIndices);
  for (  Integer nodeIndex : removeNodeIndices) {
    this.parentNode.detachChildAt(nodeIndex);
  }
  AddShapeToNode addShape=new AddShapeToNode(this.parentNode);
  for (  ICEShape primitiveShape : primitiveShapes) {
    addShape.addShape(primitiveShape);
  }
  for (  ICEShape complexShape : complexShapes) {
    addShape.addShape(complexShape);
  }
}","/** 
 * Performs the synchronization of the node and the list of shapes
 */
public void commit(){
  ICEShape nodeShape=null;
  int primitiveShapeIndex=-1;
  int complexShapeIndex=-1;
  Vector<Integer> removeNodeIndices=new Vector<Integer>();
  int numNodeChildren=this.parentNode.getQuantity();
  for (int nodeIndex=0; nodeIndex < numNodeChildren; nodeIndex++) {
    Spatial childSpatial=this.parentNode.getChild(nodeIndex);
    Node childNode=null;
    try {
      childNode=(Node)childSpatial;
    }
 catch (    ClassCastException e) {
    }
    if (childSpatial.getUserData(""String_Node_Str"") != null) {
      nodeShape=((ShapeTransient)childSpatial.getUserData(""String_Node_Str"")).getShape();
      primitiveShapeIndex=primitiveShapes.indexOf(nodeShape);
      complexShapeIndex=complexShapes.indexOf(nodeShape);
    }
    if (primitiveShapeIndex >= 0) {
      ICEShape primitiveShape=primitiveShapes.get(primitiveShapeIndex);
      childSpatial.setLocalTransform(convertTransformation(primitiveShape.getTransformation()));
      if (primitiveShape.getShapeType() == ShapeType.Cylinder) {
        childSpatial.rotate(FastMath.PI / 2,0.0f,0.0f);
      }
      ShapeMaterial shapeMaterial=new ShapeMaterial(assetManager,primitiveShape);
      shapeMaterial.setMaterial(baseMaterial);
      shapeMaterial.setHighlightedMaterial(highlightedMaterial);
      childSpatial.setMaterial(shapeMaterial.getMaterial());
      this.primitiveShapes.remove(primitiveShapeIndex);
    }
 else     if (complexShapeIndex >= 0) {
      ICEShape complexShape=complexShapes.get(complexShapeIndex);
      childSpatial.setLocalTransform(convertTransformation(complexShape.getTransformation()));
      SyncShapes syncComplexShapes=new SyncShapes(childNode);
      ArrayList<ICEShape> complexShapeChildren=complexShape.getShapes();
      for (      ICEShape complexShapeChild : complexShapeChildren) {
        syncComplexShapes.addShape(complexShapeChild);
      }
      syncComplexShapes.commit();
      this.complexShapes.remove(complexShapeIndex);
    }
 else {
      removeNodeIndices.add(new Integer(nodeIndex));
    }
  }
  Collections.reverse(removeNodeIndices);
  for (  Integer nodeIndex : removeNodeIndices) {
    this.parentNode.detachChildAt(nodeIndex);
  }
  AddShapeToNode addShape=new AddShapeToNode(this.parentNode);
  for (  ICEShape primitiveShape : primitiveShapes) {
    addShape.addShape(primitiveShape);
  }
  for (  ICEShape complexShape : complexShapes) {
    addShape.addShape(complexShape);
  }
}",0.9994003597841296
133543,"public void addShape(ICEShape newShape){
  if (newShape.isComplex()) {
    if (newShape.getOperatorType() == ICEOperatorType.Union) {
      Node node=new Node();
      spatial=node;
    }
  }
 else {
    Mesh mesh=new Box(1.0f,1.0f,1.0f);
    spatial=new Geometry(newShape.getName(),mesh);
  }
}","public void addShape(ICEShape newShape){
  if (newShape.isComplex()) {
    if (newShape.getOperatorType() == OperatorType.Union) {
      Node node=new Node();
      spatial=node;
    }
  }
 else {
    Mesh mesh=new Box(1.0f,1.0f,1.0f);
    spatial=new Geometry(newShape.getName(),mesh);
  }
}",0.9948892674616696
133544,"public RenderShape(ICEOperatorType operatorType){
  super(operatorType);
}","public RenderShape(OperatorType operatorType){
  super(operatorType);
}",0.9793103448275862
133545,"/** 
 * Converts the IShape's Transformation to a JME3 Transform
 */
private Transform getTransform(){
  ICETransformation transformation=getTransformation();
  Transform transform=new Transform();
  double size=transformation.getSize();
  double[] scale=transformation.getScale();
  double[] rotation=transformation.getRotation();
  double[] translation=transformation.getTranslation();
  transform.setScale((float)(size * scale[0]),(float)(size * scale[1]),(float)(size * scale[2]));
  Quaternion rotationQuat=new Quaternion();
  rotationQuat.fromAngles((float)rotation[0],(float)rotation[1],(float)rotation[2]);
  transform.setRotation(rotationQuat);
  transform.setTranslation((float)translation[0],(float)translation[1],(float)translation[2]);
  return transform;
}","/** 
 * Converts the IShape's Transformation to a JME3 Transform
 */
private Transform getTransform(){
  Transformation transformation=getTransformation();
  Transform transform=new Transform();
  double size=transformation.getSize();
  double[] scale=transformation.getScale();
  double[] rotation=transformation.getRotation();
  double[] translation=transformation.getTranslation();
  transform.setScale((float)(size * scale[0]),(float)(size * scale[1]),(float)(size * scale[2]));
  Quaternion rotationQuat=new Quaternion();
  rotationQuat.fromAngles((float)rotation[0],(float)rotation[1],(float)rotation[2]);
  transform.setRotation(rotationQuat);
  transform.setTranslation((float)translation[0],(float)translation[1],(float)translation[2]);
  return transform;
}",0.9980481457384516
133546,"/** 
 * <p> Creates actions required for manipulating the ShapeTreeView and adds them to the view's toolbar </p>
 */
private void createActions(){
  IActionBars actionBars=getViewSite().getActionBars();
  IToolBarManager toolbarManager=actionBars.getToolBarManager();
  addPrimitiveShapes=new DropdownAction(""String_Node_Str"");
  addComplexShapes=new DropdownAction(""String_Node_Str"");
  Action addSphere=new ActionAddShape(this,ICEShapeType.Sphere);
  addPrimitiveShapes.addAction(addSphere);
  Action addCube=new ActionAddShape(this,ICEShapeType.Cube);
  addPrimitiveShapes.addAction(addCube);
  Action addCylinder=new ActionAddShape(this,ICEShapeType.Cylinder);
  addPrimitiveShapes.addAction(addCylinder);
  Action addTube=new ActionAddShape(this,ICEShapeType.Tube);
  addPrimitiveShapes.addAction(addTube);
  Action addUnion=new ActionAddShape(this,ICEOperatorType.Union);
  addComplexShapes.addAction(addUnion);
  Action addIntersection=new ActionAddShape(this,ICEOperatorType.Intersection);
  addIntersection.setEnabled(false);
  addComplexShapes.addAction(addIntersection);
  Action addComplement=new ActionAddShape(this,ICEOperatorType.Complement);
  addComplement.setEnabled(false);
  addComplexShapes.addAction(addComplement);
  duplicateShapes=new ActionDuplicateShape(this);
  replicateShapes=new ActionReplicateShape(this);
  deleteShape=new ActionDeleteShape(this);
  toolbarManager.add(addPrimitiveShapes);
  toolbarManager.add(addComplexShapes);
  toolbarManager.add(duplicateShapes);
  toolbarManager.add(replicateShapes);
  toolbarManager.add(deleteShape);
}","/** 
 * <p> Creates actions required for manipulating the ShapeTreeView and adds them to the view's toolbar </p>
 */
private void createActions(){
  IActionBars actionBars=getViewSite().getActionBars();
  IToolBarManager toolbarManager=actionBars.getToolBarManager();
  addPrimitiveShapes=new DropdownAction(""String_Node_Str"");
  addComplexShapes=new DropdownAction(""String_Node_Str"");
  Action addSphere=new ActionAddShape(this,ShapeType.Sphere);
  addPrimitiveShapes.addAction(addSphere);
  Action addCube=new ActionAddShape(this,ShapeType.Cube);
  addPrimitiveShapes.addAction(addCube);
  Action addCylinder=new ActionAddShape(this,ShapeType.Cylinder);
  addPrimitiveShapes.addAction(addCylinder);
  Action addTube=new ActionAddShape(this,ShapeType.Tube);
  addPrimitiveShapes.addAction(addTube);
  Action addUnion=new ActionAddShape(this,OperatorType.Union);
  addComplexShapes.addAction(addUnion);
  Action addIntersection=new ActionAddShape(this,OperatorType.Intersection);
  addIntersection.setEnabled(false);
  addComplexShapes.addAction(addIntersection);
  Action addComplement=new ActionAddShape(this,OperatorType.Complement);
  addComplement.setEnabled(false);
  addComplexShapes.addAction(addComplement);
  duplicateShapes=new ActionDuplicateShape(this);
  replicateShapes=new ActionReplicateShape(this);
  deleteShape=new ActionDeleteShape(this);
  toolbarManager.add(addPrimitiveShapes);
  toolbarManager.add(addComplexShapes);
  toolbarManager.add(duplicateShapes);
  toolbarManager.add(replicateShapes);
  toolbarManager.add(deleteShape);
}",0.993297159272263
133547,"/** 
 */
private void createListeners(){
  IWidgetValueProperty property=WidgetProperties.selection();
  RealSpinnerListener listener=new RealSpinnerListener(){
    @Override public void update(    RealSpinner realSpinner){
      if (currentShape == null) {
        return;
      }
      double size=sizeSpinner.getValue();
      double scaleX=scaleSpinners[0].getValue();
      double scaleY=scaleSpinners[1].getValue();
      double scaleZ=scaleSpinners[2].getValue();
      double rotationX=rotationSpinners[0].getValue();
      double rotationY=rotationSpinners[1].getValue();
      double rotationZ=rotationSpinners[2].getValue();
      double translationX=translateSpinners[0].getValue();
      double translationY=translateSpinners[1].getValue();
      double translationZ=translateSpinners[2].getValue();
      if (degrees) {
        rotationX=Math.toRadians(rotationX);
        rotationY=Math.toRadians(rotationY);
        rotationZ=Math.toRadians(rotationZ);
      }
      ICETransformation transformation=new ICETransformation();
      transformation.setSize(size);
      transformation.setScale(scaleX,scaleY,scaleZ);
      transformation.setRotation(rotationX,rotationY,rotationZ);
      transformation.setTranslation(translationX,translationY,translationZ);
      currentShape.setTransformation(transformation);
    }
  }
;
  sizeSpinner.listen(listener);
  for (  RealSpinner spinner : scaleSpinners) {
    spinner.listen(listener);
  }
  for (  RealSpinner spinner : rotationSpinners) {
    spinner.listen(listener);
  }
  for (  RealSpinner spinner : translateSpinners) {
    spinner.listen(listener);
  }
}","/** 
 */
private void createListeners(){
  IWidgetValueProperty property=WidgetProperties.selection();
  RealSpinnerListener listener=new RealSpinnerListener(){
    @Override public void update(    RealSpinner realSpinner){
      if (currentShape == null) {
        return;
      }
      double size=sizeSpinner.getValue();
      double scaleX=scaleSpinners[0].getValue();
      double scaleY=scaleSpinners[1].getValue();
      double scaleZ=scaleSpinners[2].getValue();
      double rotationX=rotationSpinners[0].getValue();
      double rotationY=rotationSpinners[1].getValue();
      double rotationZ=rotationSpinners[2].getValue();
      double translationX=translateSpinners[0].getValue();
      double translationY=translateSpinners[1].getValue();
      double translationZ=translateSpinners[2].getValue();
      if (degrees) {
        rotationX=Math.toRadians(rotationX);
        rotationY=Math.toRadians(rotationY);
        rotationZ=Math.toRadians(rotationZ);
      }
      Transformation transformation=new Transformation();
      transformation.setSize(size);
      transformation.setScale(scaleX,scaleY,scaleZ);
      transformation.setRotation(rotationX,rotationY,rotationZ);
      transformation.setTranslation(translationX,translationY,translationZ);
      currentShape.setTransformation(transformation);
    }
  }
;
  sizeSpinner.listen(listener);
  for (  RealSpinner spinner : scaleSpinners) {
    spinner.listen(listener);
  }
  for (  RealSpinner spinner : rotationSpinners) {
    spinner.listen(listener);
  }
  for (  RealSpinner spinner : translateSpinners) {
    spinner.listen(listener);
  }
}",0.998149290561382
133548,"@Override public void update(RealSpinner realSpinner){
  if (currentShape == null) {
    return;
  }
  double size=sizeSpinner.getValue();
  double scaleX=scaleSpinners[0].getValue();
  double scaleY=scaleSpinners[1].getValue();
  double scaleZ=scaleSpinners[2].getValue();
  double rotationX=rotationSpinners[0].getValue();
  double rotationY=rotationSpinners[1].getValue();
  double rotationZ=rotationSpinners[2].getValue();
  double translationX=translateSpinners[0].getValue();
  double translationY=translateSpinners[1].getValue();
  double translationZ=translateSpinners[2].getValue();
  if (degrees) {
    rotationX=Math.toRadians(rotationX);
    rotationY=Math.toRadians(rotationY);
    rotationZ=Math.toRadians(rotationZ);
  }
  ICETransformation transformation=new ICETransformation();
  transformation.setSize(size);
  transformation.setScale(scaleX,scaleY,scaleZ);
  transformation.setRotation(rotationX,rotationY,rotationZ);
  transformation.setTranslation(translationX,translationY,translationZ);
  currentShape.setTransformation(transformation);
}","@Override public void update(RealSpinner realSpinner){
  if (currentShape == null) {
    return;
  }
  double size=sizeSpinner.getValue();
  double scaleX=scaleSpinners[0].getValue();
  double scaleY=scaleSpinners[1].getValue();
  double scaleZ=scaleSpinners[2].getValue();
  double rotationX=rotationSpinners[0].getValue();
  double rotationY=rotationSpinners[1].getValue();
  double rotationZ=rotationSpinners[2].getValue();
  double translationX=translateSpinners[0].getValue();
  double translationY=translateSpinners[1].getValue();
  double translationZ=translateSpinners[2].getValue();
  if (degrees) {
    rotationX=Math.toRadians(rotationX);
    rotationY=Math.toRadians(rotationY);
    rotationZ=Math.toRadians(rotationZ);
  }
  Transformation transformation=new Transformation();
  transformation.setSize(size);
  transformation.setScale(scaleX,scaleY,scaleZ);
  transformation.setRotation(rotationX,rotationY,rotationZ);
  transformation.setTranslation(translationX,translationY,translationZ);
  currentShape.setTransformation(transformation);
}",0.9971671388101984
133549,"/** 
 * <p> Sets the input shape and updates the state of the TransformationView to manipulate the input shape's transformation </p> <p> Passing a null value for the input shape reinitializes and disables all the text boxes in the view. </p>
 * @param shape
 */
public void setShape(ICEShape shape){
  this.currentShape=shape;
  ICETransformation transformation;
  if (shape == null) {
    transformation=new ICETransformation();
  }
 else {
    transformation=shape.getTransformation();
  }
  double size=transformation.getSize();
  sizeSpinner.setValue(size);
  double[] scale=transformation.getScale();
  for (int i=0; i < 3; i++) {
    scaleSpinners[i].setValue(scale[i]);
  }
  double[] rotation=transformation.getRotation();
  for (int i=0; i < 3; i++) {
    if (degrees) {
      rotationSpinners[i].setValue(Math.toDegrees(rotation[i]));
    }
 else {
      rotationSpinners[i].setValue(rotation[i]);
    }
  }
  double[] translations=transformation.getTranslation();
  for (int i=0; i < 3; i++) {
    translateSpinners[i].setValue(translations[i]);
  }
  setSpinnersEnabled(shape != null);
}","/** 
 * <p> Sets the input shape and updates the state of the TransformationView to manipulate the input shape's transformation </p> <p> Passing a null value for the input shape reinitializes and disables all the text boxes in the view. </p>
 * @param shape
 */
public void setShape(ICEShape shape){
  this.currentShape=shape;
  Transformation transformation;
  if (shape == null) {
    transformation=new Transformation();
  }
 else {
    transformation=shape.getTransformation();
  }
  double size=transformation.getSize();
  sizeSpinner.setValue(size);
  double[] scale=transformation.getScale();
  for (int i=0; i < 3; i++) {
    scaleSpinners[i].setValue(scale[i]);
  }
  double[] rotation=transformation.getRotation();
  for (int i=0; i < 3; i++) {
    if (degrees) {
      rotationSpinners[i].setValue(Math.toDegrees(rotation[i]));
    }
 else {
      rotationSpinners[i].setValue(rotation[i]);
    }
  }
  double[] translations=transformation.getTranslation();
  for (int i=0; i < 3; i++) {
    translateSpinners[i].setValue(translations[i]);
  }
  setSpinnersEnabled(shape != null);
}",0.9972627737226276
133550,"@Override protected Composite createPlotComposite(Composite parent,int style,final VisItSwtConnection connection) throws Exception {
  Composite container=new Composite(parent,style);
  container.setBackground(parent.getBackground());
  container.setLayout(new GridLayout(1,false));
  canvas=new VisItSwtWidget(container,SWT.DOUBLE_BUFFERED);
  canvas.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  canvas.setBackground(parent.getBackground());
  int windowWidth=Integer.parseInt(adapter.getConnectionProperty(""String_Node_Str""));
  int windowHeight=Integer.parseInt(adapter.getConnectionProperty(""String_Node_Str""));
  int windowId=plot.getVisItConnectionAdapter().getNextWindowId();
  canvas.setVisItSwtConnection(connection,windowId,windowWidth,windowHeight);
  new VisItMouseManager(canvas);
  MenuManager menuManager=new MenuManager();
  Menu menu=parent.getMenu();
  if (menu == null) {
    menu=menuManager.createContextMenu(canvas);
  }
  menu.addMenuListener(new MenuListener(){
    @Override public void menuHidden(    MenuEvent e){
    }
    @Override public void menuShown(    MenuEvent e){
      repTree.getContributionItem().fill((Menu)e.widget,-1);
    }
  }
);
  canvas.setMenu(menu);
  timeSlider=new TimeSliderComposite(container,SWT.NONE);
  timeSlider.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  timeSlider.setBackground(parent.getBackground());
  timeSlider.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      widgetTimestep.set(timeSlider.getTimestep());
      executorService.submit(new Runnable(){
        @Override public void run(){
          ViewerMethods methods=connection.getViewerMethods();
          int targetStep;
          while (renderedTimestep != (targetStep=widgetTimestep.get())) {
            if (renderedTimestep < targetStep) {
              methods.animationNextState();
              renderedTimestep++;
            }
 else {
              methods.animationPreviousState();
              renderedTimestep--;
            }
          }
          return;
        }
      }
);
      return;
    }
  }
);
  ViewerMethods widget=connection.getViewerMethods();
  int timestepCount=widget.timeSliderGetNStates();
  List<Double> times=new ArrayList<Double>(timestepCount);
  for (double i=0.0; i < timestepCount; i++) {
    times.add(i);
  }
  timeSlider.setTimes(times);
  return container;
}","@Override protected Composite createPlotComposite(Composite parent,int style,final VisItSwtConnection connection) throws Exception {
  Composite container=new Composite(parent,style);
  container.setBackground(parent.getBackground());
  container.setLayout(new GridLayout(1,false));
  canvas=new VisItSwtWidget(container,SWT.DOUBLE_BUFFERED);
  canvas.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  canvas.setBackground(parent.getBackground());
  int windowWidth=Integer.parseInt(adapter.getConnectionProperty(""String_Node_Str""));
  int windowHeight=Integer.parseInt(adapter.getConnectionProperty(""String_Node_Str""));
  int windowId=plot.getVisItConnectionAdapter().getNextWindowId();
  canvas.setVisItSwtConnection(connection,windowId,windowWidth,windowHeight);
  new VisItMouseManager(canvas);
  MenuManager menuManager=new MenuManager();
  Menu menu=parent.getMenu();
  if (menu == null) {
    menu=menuManager.createContextMenu(canvas);
  }
  menu.addMenuListener(new MenuListener(){
    @Override public void menuHidden(    MenuEvent e){
    }
    @Override public void menuShown(    MenuEvent e){
      for (      MenuItem item : ((Menu)e.widget).getItems()) {
        item.dispose();
      }
      repTree.getContributionItem().fill((Menu)e.widget,-1);
    }
  }
);
  canvas.setMenu(menu);
  timeSlider=new TimeSliderComposite(container,SWT.NONE);
  timeSlider.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  timeSlider.setBackground(parent.getBackground());
  timeSlider.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      widgetTimestep.set(timeSlider.getTimestep());
      executorService.submit(new Runnable(){
        @Override public void run(){
          ViewerMethods methods=connection.getViewerMethods();
          int targetStep;
          while (renderedTimestep != (targetStep=widgetTimestep.get())) {
            if (renderedTimestep < targetStep) {
              methods.animationNextState();
              renderedTimestep++;
            }
 else {
              methods.animationPreviousState();
              renderedTimestep--;
            }
          }
          return;
        }
      }
);
      return;
    }
  }
);
  ViewerMethods widget=connection.getViewerMethods();
  int timestepCount=widget.timeSliderGetNStates();
  List<Double> times=new ArrayList<Double>(timestepCount);
  for (double i=0.0; i < timestepCount; i++) {
    times.add(i);
  }
  timeSlider.setTimes(times);
  return container;
}",0.9805668016194332
133551,"@Override public void menuShown(MenuEvent e){
  repTree.getContributionItem().fill((Menu)e.widget,-1);
}","@Override public void menuShown(MenuEvent e){
  for (  MenuItem item : ((Menu)e.widget).getItems()) {
    item.dispose();
  }
  repTree.getContributionItem().fill((Menu)e.widget,-1);
}",0.7222222222222222
133552,"/** 
 * Creates the UI for the PlotEditor and calls the visualization service to draw the opened plot.
 * @param barManager Manager for the editor's toolbar
 * @param body The composite in which the editor will be drawn
 * @param selectedService A PlotEditorInput containing the IPlot created with the selected visualization service
 * @param thisEditor A reference to the editor being created.
 * @param seriesToPlot The list of the valid series for this editor to be able to plot. should have already checked the validity (at least one element) in this list.
 * @param selectedPlotType The type of the initial plot to draw
 */
private void createUI(ToolBarManager barManager,final Composite body,final PlotEditorInput selectedService,final IEditorPart thisEditor,final List<ISeries> seriesToPlot,final ISeries independentSeries,final String[] categories){
  body.setLayout(new GridLayout());
  body.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  ToolBar bar=barManager.createControl(body);
  final Composite plotComposite=new Composite(body,SWT.NONE);
  MenuManager menu=new MenuManager(""String_Node_Str"");
  ActionTree menuTree=new ActionTree(""String_Node_Str"");
  Map<String,ActionTree> categoryTrees=null;
  ActionTree seriesTree=new ActionTree(""String_Node_Str"");
  if (categories.length > 1) {
    categoryTrees=new TreeMap<String,ActionTree>();
    for (int i=0; i < categories.length; i++) {
      String category=categories[i];
      ActionTree catTree=new ActionTree(category);
      menuTree.add(catTree);
      categoryTrees.put(category,catTree);
    }
  }
 else {
    menuTree.add(seriesTree);
  }
  for (  final ISeries series : seriesToPlot) {
    Action tempAction=new Action(series.getLabel()){
      @Override public void run(){
        try {
          series.setEnabled(true);
          if (series instanceof ConnectionSeries) {
            selectedService.getPlot().setIndependentSeries(series);
          }
          selectedService.getPlot().draw(plotComposite);
          body.layout();
        }
 catch (        Exception e) {
          logger.error(getClass().getName() + ""String_Node_Str"",e);
        }
      }
    }
;
    if (categoryTrees == null) {
      seriesTree.add(new ActionTree(tempAction));
    }
 else {
      categoryTrees.get(series.getCategory()).add(new ActionTree(tempAction));
    }
  }
  Action close=new Action(""String_Node_Str""){
    @Override public void run(){
      thisEditor.getEditorSite().getPage().closeEditor(thisEditor,false);
    }
  }
;
  menuTree.add(new ActionTree(close));
  if (categoryTrees == null) {
    seriesTree.getContributionItem().fill(menu.getMenu(),-1);
  }
 else {
    for (    String category : categoryTrees.keySet()) {
      categoryTrees.get(category).getContributionItem().fill(menu.getMenu(),-1);
    }
  }
  menu.updateAll(true);
  barManager.add(menuTree.getContributionItem());
  bar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  barManager.update(true);
  plotComposite.setBackground(body.getBackground());
  plotComposite.setLayout(new FillLayout());
  GridDataFactory.fillDefaults().grab(true,true).applyTo(plotComposite);
  try {
    if (independentSeries instanceof ConnectionSeries) {
      selectedService.getPlot().setIndependentSeries(independentSeries);
    }
    selectedService.getPlot().draw(plotComposite);
    body.layout();
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    e.printStackTrace();
  }
  body.layout();
}","/** 
 * Creates the UI for the PlotEditor and calls the visualization service to draw the opened plot.
 * @param barManager Manager for the editor's toolbar
 * @param body The composite in which the editor will be drawn
 * @param selectedService A PlotEditorInput containing the IPlot created with the selected visualization service
 * @param thisEditor A reference to the editor being created.
 * @param seriesToPlot The list of the valid series for this editor to be able to plot. should have already checked the validity (at least one element) in this list.
 * @param selectedPlotType The type of the initial plot to draw
 */
private void createUI(ToolBarManager barManager,final Composite body,final PlotEditorInput selectedService,final IEditorPart thisEditor,final List<ISeries> seriesToPlot,final ISeries independentSeries,final String[] categories){
  body.setLayout(new GridLayout());
  body.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  ToolBar bar=barManager.createControl(body);
  final Composite plotComposite=new Composite(body,SWT.NONE);
  MenuManager menu=new MenuManager(""String_Node_Str"");
  ActionTree menuTree=new ActionTree(""String_Node_Str"");
  Map<String,ActionTree> categoryTrees=null;
  ActionTree seriesTree=new ActionTree(""String_Node_Str"");
  if (categories.length > 1) {
    categoryTrees=new TreeMap<String,ActionTree>();
    for (int i=0; i < categories.length; i++) {
      String category=categories[i];
      ActionTree catTree=new ActionTree(category);
      menuTree.add(catTree);
      categoryTrees.put(category,catTree);
    }
  }
 else {
    menuTree.add(seriesTree);
  }
  for (  final ISeries series : seriesToPlot) {
    Action tempAction=new Action(series.getLabel()){
      @Override public void run(){
        try {
          series.setEnabled(true);
          if (series instanceof ConnectionSeries) {
            selectedService.getPlot().setIndependentSeries(series);
          }
          series.setEnabled(true);
          selectedService.getPlot().draw(plotComposite);
          body.layout();
        }
 catch (        Exception e) {
          logger.error(getClass().getName() + ""String_Node_Str"",e);
        }
      }
    }
;
    if (categoryTrees == null) {
      seriesTree.add(new ActionTree(tempAction));
    }
 else {
      categoryTrees.get(series.getCategory()).add(new ActionTree(tempAction));
    }
  }
  Action close=new Action(""String_Node_Str""){
    @Override public void run(){
      thisEditor.getEditorSite().getPage().closeEditor(thisEditor,false);
    }
  }
;
  menuTree.add(new ActionTree(close));
  if (categoryTrees == null) {
    seriesTree.getContributionItem().fill(menu.getMenu(),-1);
  }
 else {
    for (    String category : categoryTrees.keySet()) {
      categoryTrees.get(category).getContributionItem().fill(menu.getMenu(),-1);
    }
  }
  menu.updateAll(true);
  barManager.add(menuTree.getContributionItem());
  bar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  barManager.update(true);
  plotComposite.setBackground(body.getBackground());
  plotComposite.setLayout(new FillLayout());
  GridDataFactory.fillDefaults().grab(true,true).applyTo(plotComposite);
  try {
    if (independentSeries instanceof ConnectionSeries) {
      selectedService.getPlot().setIndependentSeries(independentSeries);
    }
    selectedService.getPlot().draw(plotComposite);
    body.layout();
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
    e.printStackTrace();
  }
  body.layout();
}",0.9950192116123524
133553,"/** 
 * @see org.eclipse.ice.viz.service.IPlot#draw(java.lang.String,java.lang.String,org.eclipse.swt.widgets.Composite)
 */
@Override public Composite draw(Composite parent) throws Exception {
  Composite child=null;
  if (parent == null) {
    throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (parent.isDisposed()) {
    throw new SWTException(SWT.ERROR_WIDGET_DISPOSED,""String_Node_Str"" + ""String_Node_Str"");
  }
  PlotRender plotRender=plotRenders.get(parent);
  if (plotRender == null) {
    plotRender=createPlotRender(parent);
    plotRenders.put(parent,plotRender);
  }
  plotRender=(CSVPlotRender)plotRenders.get(parent);
  parent.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      ((CSVPlotRender)plotRenders.remove(e.widget)).dispose();
    }
  }
);
  updatePlotRender(plotRender);
  plotRender.refresh();
  child=((CSVPlotRender)plotRender).getEditor().getPlotCanvas();
  return child;
}","/** 
 * @see org.eclipse.ice.viz.service.IPlot#draw(java.lang.String,java.lang.String,org.eclipse.swt.widgets.Composite)
 */
@Override public Composite draw(Composite parent) throws Exception {
  Composite child=null;
  if (parent == null) {
    throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (parent.isDisposed()) {
    throw new SWTException(SWT.ERROR_WIDGET_DISPOSED,""String_Node_Str"" + ""String_Node_Str"");
  }
  PlotRender plotRender=plotRenders.get(parent);
  if (plotRender == null) {
    plotRender=createPlotRender(parent);
    plotRenders.put(parent,plotRender);
  }
  plotRender=(CSVPlotRender)plotRenders.get(parent);
  parent.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      ((CSVPlotRender)plotRenders.remove(e.widget)).dispose();
    }
  }
);
  for (  ISeries series : getAllDependentSeries(IPlot.DEFAULT_CATEGORY)) {
    if (series.enabled()) {
      ((CSVPlotRender)plotRender).addSeries(series);
    }
  }
  updatePlotRender(plotRender);
  child=((CSVPlotRender)plotRender).getEditor().getPlotCanvas();
  return child;
}",0.8799249530956847
133554,"/** 
 * Creates a context   {@code Menu} for the drawn plot's main{@code Composite}. It includes the following controls by default: <ol> <li>Remove Plot</li> <li>Separator</li> <li>Set Plot Type</li> <li>Separator</li> <li>Any implementation-specific plot actions...</li> </ol> It is up to the related   {@code IPlot} implementation to take thecreated  {@code Menu} and add it to child {@code Composite}s or update it.
 * @return The JFace {@code MenuManager} for the context {@code Menu}.
 */
private MenuManager createContextMenu(){
  MenuManager contextMenuManager=new MenuManager();
  final Action removeAction=new Action(""String_Node_Str""){
    @Override public void run(){
      dispose();
    }
  }
;
  final ActionTree plotTypeTree=new ActionTree(""String_Node_Str"");
  try {
    Map<String,String[]> plotTypes=plot.getPlotTypes();
    for (    Entry<String,String[]> entry : plotTypes.entrySet()) {
      String category=entry.getKey();
      String[] types=entry.getValue();
      if (category != null && types != null && types.length > 0) {
        ActionTree categoryTree=new ActionTree(category);
        plotTypeTree.add(categoryTree);
        final String categoryRef=category;
        for (        String type : types) {
          final String typeRef=type;
          categoryTree.add(new ActionTree(new Action(type){
            @Override public void run(){
              try {
                draw(categoryRef,typeRef);
              }
 catch (              Exception e) {
                logger.error(getClass().getName() + ""String_Node_Str"",e);
              }
            }
          }
));
        }
      }
    }
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
  contextMenuManager.add(removeAction);
  contextMenuManager.add(new Separator());
  contextMenuManager.add(plotTypeTree.getContributionItem());
  setMenu(contextMenuManager.createContextMenu(this));
  return contextMenuManager;
}","/** 
 * Creates a context   {@code Menu} for the drawn plot's main{@code Composite}. It includes the following controls by default: <ol> <li>Remove Plot</li> <li>Separator</li> <li>Set Plot Type</li> <li>Separator</li> <li>Any implementation-specific plot actions...</li> </ol> It is up to the related   {@code IPlot} implementation to take thecreated  {@code Menu} and add it to child {@code Composite}s or update it.
 * @return The JFace {@code MenuManager} for the context {@code Menu}.
 */
private MenuManager createContextMenu(){
  final Action removeAction=new Action(""String_Node_Str""){
    @Override public void run(){
      dispose();
    }
  }
;
  final List<IContributionItem> actions=new ArrayList<IContributionItem>();
  actions.add(new ActionContributionItem(removeAction));
  final MenuManager menuManager=new MenuManager();
  Menu contextMenu=menuManager.createContextMenu(this);
  menuManager.setRemoveAllWhenShown(true);
  contextMenu.addMenuListener(new MenuListener(){
    @Override public void menuHidden(    MenuEvent e){
    }
    @Override public void menuShown(    MenuEvent e){
      Menu menu=(Menu)e.widget;
      for (      IContributionItem item : actions) {
        item.fill(menu,-1);
      }
    }
  }
);
  setMenu(contextMenu);
  return menuManager;
}",0.4475955610357583
133555,"@Override public void run(){
  try {
    draw(categoryRef,typeRef);
  }
 catch (  Exception e) {
    logger.error(getClass().getName() + ""String_Node_Str"",e);
  }
}","@Override public void run(){
  dispose();
}",0.357487922705314
133556,"@Override public void menuShown(MenuEvent e){
  Menu menu=(Menu)e.widget;
  if (parent.getMenu() == null) {
    for (    MenuItem item : menu.getItems()) {
      item.dispose();
    }
  }
  addSeriesTree.getContributionItem().fill(menu,-1);
  removeSeriesTree.getContributionItem().fill(menu,-1);
  separator.fill(menu,-1);
  clearAction.getContributionItem().fill(menu,-1);
}","@Override public void menuShown(MenuEvent e){
  Menu menu=(Menu)e.widget;
  for (  IContributionItem item : menuManager.getItems()) {
    item.fill(menu,-1);
  }
}",0.5343228200371057
133557,"/** 
 * Creates a   {@link CSVPlotEditor} and all providers necessary topopulate it. The editor is created inside the specified parent {@code Composite}.
 * @param parent The  {@code Composite} in which to draw the CSV ploteditor.
 */
public DrawnPlot(final Composite parent) throws Exception {
  editor=new CSVPlotEditor();
  plotProvider=new PlotProvider();
  int lastSeparator=source.getPath().lastIndexOf(""String_Node_Str"");
  String plotTitle=(lastSeparator > -1 ? source.getPath().substring(lastSeparator + 1) : source.getPath());
  plotProvider.setPlotTitle(plotTitle);
  editor.createPartControl(parent);
  Composite canvas=editor.getPlotCanvas();
  Menu menu=parent.getMenu();
  if (menu == null) {
    MenuManager menuManager=new MenuManager();
    menu=menuManager.createContextMenu(canvas);
  }
  addSeriesTree=new ActionTree(""String_Node_Str"");
  removeSeriesTree=new ActionTree(""String_Node_Str"");
  final Separator separator=new Separator();
  final ActionTree clearAction=new ActionTree(new Action(""String_Node_Str""){
    @Override public void run(){
      clear();
      refresh();
    }
  }
);
  for (  Entry<String,String[]> e : getPlotTypes().entrySet()) {
    final String category=e.getKey();
    String[] types=e.getValue();
    if (category != null && types != null) {
      ActionTree catTree=new ActionTree(category);
      addSeriesTree.add(catTree);
      for (      final String type : types) {
        if (type != null) {
          catTree.add(new ActionTree(new Action(type){
            @Override public void run(){
              addSeries(category,type);
              refresh();
            }
          }
));
        }
      }
    }
  }
  menu.addMenuListener(new MenuListener(){
    @Override public void menuHidden(    MenuEvent e){
    }
    @Override public void menuShown(    MenuEvent e){
      Menu menu=(Menu)e.widget;
      if (parent.getMenu() == null) {
        for (        MenuItem item : menu.getItems()) {
          item.dispose();
        }
      }
      addSeriesTree.getContributionItem().fill(menu,-1);
      removeSeriesTree.getContributionItem().fill(menu,-1);
      separator.fill(menu,-1);
      clearAction.getContributionItem().fill(menu,-1);
    }
  }
);
  editor.getPlotCanvas().setMenu(menu);
  return;
}","/** 
 * Creates a   {@link CSVPlotEditor} and all providers necessary topopulate it. The editor is created inside the specified parent {@code Composite}.
 * @param parent The  {@code Composite} in which to draw the CSV ploteditor.
 */
public DrawnPlot(final Composite parent) throws Exception {
  editor=new CSVPlotEditor();
  plotProvider=new PlotProvider();
  int lastSeparator=source.getPath().lastIndexOf(""String_Node_Str"");
  String plotTitle=(lastSeparator > -1 ? source.getPath().substring(lastSeparator + 1) : source.getPath());
  plotProvider.setPlotTitle(plotTitle);
  editor.createPartControl(parent);
  addSeriesTree=new ActionTree(""String_Node_Str"");
  removeSeriesTree=new ActionTree(""String_Node_Str"");
  final ActionTree clearAction=new ActionTree(new Action(""String_Node_Str""){
    @Override public void run(){
      clear();
      refresh();
    }
  }
);
  for (  Entry<String,String[]> e : getPlotTypes().entrySet()) {
    final String category=e.getKey();
    String[] types=e.getValue();
    if (category != null && types != null) {
      ActionTree catTree=new ActionTree(category);
      addSeriesTree.add(catTree);
      for (      final String type : types) {
        if (type != null) {
          catTree.add(new ActionTree(new Action(type){
            @Override public void run(){
              addSeries(category,type);
              refresh();
            }
          }
));
        }
      }
    }
  }
  final MenuManager menuManager=new MenuManager();
  menuManager.add(addSeriesTree.getContributionItem());
  menuManager.add(removeSeriesTree.getContributionItem());
  menuManager.add(clearAction.getContributionItem());
  Menu contextMenu=parent.getMenu();
  if (contextMenu != null) {
    contextMenu.addMenuListener(new MenuListener(){
      @Override public void menuHidden(      MenuEvent e){
      }
      @Override public void menuShown(      MenuEvent e){
        Menu menu=(Menu)e.widget;
        for (        IContributionItem item : menuManager.getItems()) {
          item.fill(menu,-1);
        }
      }
    }
);
  }
 else {
    contextMenu=menuManager.createContextMenu(parent);
  }
  editor.getPlotCanvas().setMenu(contextMenu);
  return;
}",0.7473613294408264
133558,"/** 
 * The default constructor.
 */
public VisItConnection(){
  propertyHandlers.remove(""String_Node_Str"");
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.get(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      return ""String_Node_Str"";
    }
  }
);
  IPropertyHandler positiveIntHandler=new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        String trimmedValue=value.trim();
        try {
          if (Integer.parseInt(trimmedValue) > 0) {
            newValue=trimmedValue;
          }
        }
 catch (        NumberFormatException e) {
        }
      }
      return newValue;
    }
  }
;
  propertyHandlers.put(""String_Node_Str"",positiveIntHandler);
  propertyHandlers.put(""String_Node_Str"",positiveIntHandler);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        String trimmedValue=value.trim();
        try {
          int intValue=Integer.parseInt(trimmedValue);
          if (intValue == -1 || (intValue >= 1 && intValue <= 16)) {
            newValue=trimmedValue;
          }
        }
 catch (        NumberFormatException e) {
        }
      }
      return newValue;
    }
  }
);
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setPort(9600);
  return;
}","/** 
 * The default constructor.
 */
public VisItConnection(){
  setProperty(""String_Node_Str"",""String_Node_Str"");
  propertyHandlers.remove(""String_Node_Str"");
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      return value != null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.get(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      return value != null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      return false;
    }
  }
);
  IPropertyHandler positiveIntHandler=new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      boolean valid=false;
      if (value != null) {
        String trimmedValue=value.trim();
        try {
          if (Integer.parseInt(trimmedValue) > 0) {
            valid=true;
          }
        }
 catch (        NumberFormatException e) {
        }
      }
      return valid;
    }
  }
;
  propertyHandlers.put(""String_Node_Str"",positiveIntHandler);
  propertyHandlers.put(""String_Node_Str"",positiveIntHandler);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      boolean valid=false;
      if (value != null) {
        String trimmedValue=value.trim();
        try {
          int intValue=Integer.parseInt(trimmedValue);
          if (intValue == -1 || (intValue >= 1 && intValue <= 16)) {
            valid=true;
          }
        }
 catch (        NumberFormatException e) {
        }
      }
      return valid;
    }
  }
);
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setProperty(""String_Node_Str"",""String_Node_Str"");
  setPort(9600);
  return;
}",0.8912209889001009
133559,"@Override public String validateValue(String value){
  String newValue=null;
  if (value != null) {
    String trimmedValue=value.trim();
    try {
      int intValue=Integer.parseInt(trimmedValue);
      if (intValue == -1 || (intValue >= 1 && intValue <= 16)) {
        newValue=trimmedValue;
      }
    }
 catch (    NumberFormatException e) {
    }
  }
  return newValue;
}","@Override public boolean validateValue(String value){
  boolean valid=false;
  if (value != null) {
    String trimmedValue=value.trim();
    try {
      int intValue=Integer.parseInt(trimmedValue);
      if (intValue == -1 || (intValue >= 1 && intValue <= 16)) {
        valid=true;
      }
    }
 catch (    NumberFormatException e) {
    }
  }
  return valid;
}",0.8086253369272237
133560,"/** 
 * Validates the specified value for the associated property.
 * @param value The value to check.
 * @return An acceptable, validated value if it is allowed, or{@code null} if it is not allowed.
 */
public String validateValue(String value);","/** 
 * Validates the specified value for the associated property.
 * @param value The value to check.
 * @return True if the value allowed, false otherwise.
 */
public boolean validateValue(String value);",0.5764966740576497
133561,"/** 
 * The default constructor. Initializes the connection to the default values.
 */
public VizConnection(){
  widget=null;
  state=ConnectionState.Disconnected;
  statusMessage=""String_Node_Str"";
  properties=new HashMap<String,String>();
  propertyHandlers=new HashMap<String,IPropertyHandler>();
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue != null && !newValue.isEmpty() ? newValue : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      return value != null ? value.trim() : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue != null && !newValue.isEmpty() ? newValue : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      try {
        int port=Integer.parseInt(value);
        if (port >= MIN_PORT && port <= MAX_PORT) {
          newValue=Integer.toString(port);
        }
      }
 catch (      NumberFormatException e) {
      }
      return newValue;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      return value != null ? value.trim() : null;
    }
  }
);
  setName(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  setHost(""String_Node_Str"");
  setPort(50000);
  setPath(""String_Node_Str"");
  listeners=new HashSet<IVizConnectionListener<T>>();
  notificationLock=new ReentrantLock(true);
  connectionLock=new ReentrantLock(true);
  return;
}","/** 
 * The default constructor. Initializes the connection to the default values.
 */
public VizConnection(){
  widget=null;
  state=ConnectionState.Disconnected;
  statusMessage=""String_Node_Str"";
  properties=new HashMap<String,String>();
  propertyHandlers=new HashMap<String,IPropertyHandler>();
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      return value != null && !value.trim().isEmpty();
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      return value != null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      return value != null && !value.trim().isEmpty();
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      boolean valid=false;
      try {
        int port=Integer.parseInt(value);
        if (port >= MIN_PORT && port <= MAX_PORT) {
          valid=true;
        }
      }
 catch (      NumberFormatException e) {
      }
      return valid;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public boolean validateValue(    String value){
      return value != null;
    }
  }
);
  setName(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  setHost(""String_Node_Str"");
  setPort(50000);
  setPath(""String_Node_Str"");
  listeners=new HashSet<IVizConnectionListener<T>>();
  notificationLock=new ReentrantLock(true);
  connectionLock=new ReentrantLock(true);
  return;
}",0.7002164502164502
133562,"/** 
 * Sets the specified property to the new value, provided the value is both allowed and new.
 * @param name The name of the property to update.
 * @param value The new value of the property. If  {@code null}, the property will be removed.
 * @return True if the property specified by the name was updated to a newvalue, false otherwise.
 */
public boolean setProperty(String name,String value){
  boolean changed=false;
  boolean canChange=true;
  String newValue=value;
  IPropertyHandler handler=propertyHandlers.get(name);
  if (handler != null) {
    newValue=handler.validateValue(value);
    canChange=(newValue != null);
  }
  if (canChange) {
    if (value != null) {
      String oldValue=properties.put(name,value);
      changed=(oldValue == null || !oldValue.equals(value));
    }
 else {
      changed=(properties.remove(name) != null);
    }
  }
  return changed;
}","/** 
 * Sets the specified property to the new value, provided the value is both allowed and new.
 * @param name The name of the property to update.
 * @param value The new value of the property. If  {@code null}, the property will be removed.
 * @return True if the property specified by the name was updated to a newvalue, false otherwise.
 */
public boolean setProperty(String name,String value){
  boolean changed=false;
  IPropertyHandler handler=propertyHandlers.get(name);
  if (handler == null || handler.validateValue(value)) {
    if (value != null) {
      String oldValue=properties.put(name,value);
      changed=(oldValue == null || !oldValue.equals(value));
    }
 else {
      changed=(properties.remove(name) != null);
    }
  }
  return changed;
}",0.7556094602789569
133563,"/** 
 * Adds a new series to the drawn plot.
 * @param category The category of the series to add.
 * @param type The type of the series to add.
 * @param drawnPlot The drawn plot that will get a new series.
 */
public void addSeries(ISeries series){
  double plotTime=0.0;
  if (series.enabled() && !seriesMap.containsKey(series)) {
    plotProvider.addSeries(plotTime,series);
    final ISeries finSeries=series;
    ActionTree tree=new ActionTree(new Action(series.getLabel()){
      @Override public void run(){
        finSeries.setEnabled(false);
        removeSeries(finSeries);
        refresh();
      }
    }
);
    removeSeriesTree.add(tree);
    seriesMap.put(series,tree);
  }
  return;
}","/** 
 * Adds a new series to the drawn plot.
 * @param category The category of the series to add.
 * @param type The type of the series to add.
 * @param drawnPlot The drawn plot that will get a new series.
 */
public void addSeries(ISeries series){
  double plotTime=0.0;
  if (series.enabled() && !seriesMap.containsKey(series)) {
    plotProvider.addSeries(plotTime,series);
    final ISeries finSeries=series;
    ActionTree tree=new ActionTree(new Action(series.getLabel()){
      @Override public void run(){
        removeSeries(finSeries);
        finSeries.setEnabled(false);
        refresh();
      }
    }
);
    removeSeriesTree.add(tree);
    seriesMap.put(finSeries,tree);
  }
  return;
}",0.8256227758007118
133564,"@Override public void run(){
  finSeries.setEnabled(false);
  removeSeries(finSeries);
  refresh();
}","@Override public void run(){
  removeSeries(finSeries);
  finSeries.setEnabled(false);
  refresh();
}",0.7326732673267327
133565,"/** 
 * Removes the specified series from the drawn plot.
 * @param series The series to remove.
 */
public void removeSeries(ISeries series){
  ActionTree tree=seriesMap.remove(series);
  if (tree != null) {
    double plotTime=0.0;
    removeSeriesTree.remove(tree);
    plotProvider.removeSeries(plotTime,series);
    editor.removeSeries(series);
  }
  return;
}","/** 
 * Removes the specified series from the drawn plot.
 * @param series The series to remove.
 */
public void removeSeries(ISeries series){
  ActionTree tree=seriesMap.remove(series);
  if (tree != null) {
    double plotTime=0.0;
    removeSeriesTree.remove(tree);
    plotProvider.removeSeries(plotTime,series);
    editor.removeSeries(series);
    seriesMap.remove(series);
  }
  return;
}",0.9605263157894736
133566,"@Override public boolean equals(Object other){
  boolean isEqual=false;
  if (other != null || (other instanceof CSVSeries) && super.equals(other)) {
    if (other == this) {
      isEqual=true;
    }
 else {
      CSVSeries series=(CSVSeries)other;
      isEqual=this.isEnabled == series.isEnabled && label == series.label && (parent == null ? parent == series.parent : parent.equals(series.parent)) && style.equals(series.style) && time == series.time && unit.equals(series.unit);
    }
  }
  return isEqual;
}","@Override public boolean equals(Object other){
  boolean isEqual=false;
  if (other != null && (other instanceof CSVSeries) && super.equals(other)) {
    if (other == this) {
      isEqual=true;
    }
 else {
      CSVSeries series=(CSVSeries)other;
      isEqual=this.isEnabled == series.isEnabled && label == series.label && (parent == null ? series.parent == null : parent.equals(series.parent)) && style.equals(series.style) && time == series.time && unit.equals(series.unit);
    }
  }
  return isEqual;
}",0.9373776908023485
133567,"public void setIOService(IOService service){
  (new Item(null)).setIOService(service);
}","/** 
 * This operation configures the IOService that should be used by Items
 * @param service The IOService that provides Input/Output capabilities to Items managed by the Core.
 */
public void setIOService(IOService service){
  itemManager.setIOService(service);
}",0.4067796610169492
133568,"/** 
 * The Constructor
 */
public Core(){
  itemManager=new ItemManager();
  projectTable=new Hashtable<String,IProject>();
  if (!setupProjectLocation()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (System.getProperty(""String_Node_Str"") != null) {
    debuggingEnabled=true;
  }
  updateLock=new AtomicBoolean(false);
  return;
}","/** 
 * The Constructor
 */
public Core(){
  itemManager=new ItemManager();
  projectTable=new Hashtable<String,IProject>();
  if (!setupProjectLocation()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  updateLock=new AtomicBoolean(false);
  return;
}",0.8594771241830066
133569,"/** 
 * This operation updates the properties for this material based on the code from John Ankner's compound calculator written in Visual Basic. The code was ported for the Reflectivity Model. Calculates the number density, scattering length density, true (coherent) scattering length absorption coefficient, and the incoherent scattering length absorption coefficient all from the density of the material (in g/cm^3) and its components. If called on a elemental material, does nothing.
 */
public void updateProperties(){
  if (!isElemental()) {
    final double nA=6.02E23;
    double numberDensity=0;
    double muMAbs=0;
    double muMInc=0;
    double b=0;
    double density=getProperty(DENSITY);
    int molMass=0;
    List<MaterialStack> list=getComponents();
    for (    MaterialStack stack : list) {
      molMass+=stack.getAmount() * (stack.getMaterial().getProperty(ATOMIC_MASS));
    }
    if (list.size() > 0 && molMass >= 1) {
      numberDensity=(1E-24) * (nA) * (density / molMass);
      for (int j=0; j < list.size(); j++) {
        MaterialStack stack=list.get(j);
        Material mat=stack.getMaterial();
        int N=stack.getAmount();
        double cohb=mat.getProperty(COHERENT_SCAT_LENGTH);
        b+=N * cohb;
        double massPercent=mat.getProperty(ATOMIC_MASS) / molMass;
        muMAbs+=N * massPercent * (mat.getProperty(MASS_ABS_COHERENT));
        muMInc+=N * massPercent * (mat.getProperty(MASS_ABS_INCOHERENT));
      }
    }
    setProperty(ATOMIC_MASS,molMass);
    setProperty(NUMBER_DENSITY,numberDensity);
    setProperty(SCAT_LENGTH_DENSITY,numberDensity * b);
    muMAbs*=1E-24 * getProperty(DENSITY);
    setProperty(MASS_ABS_COHERENT,muMAbs);
    muMInc*=1E-24 * getProperty(DENSITY);
    setProperty(MASS_ABS_INCOHERENT,muMInc);
  }
}","/** 
 * This operation updates the properties for this material based on the code from John Ankner's compound calculator written in Visual Basic. The code was ported for the Reflectivity Model. Calculates the number density, scattering length density, true (coherent) scattering length absorption coefficient, and the incoherent scattering length absorption coefficient all from the density of the material (in g/cm^3) and its components. If called on a elemental material, does nothing.
 */
public void updateProperties(){
  if (!isElemental()) {
    final double nA=6.02E23;
    double numberDensity=0;
    double muMAbs=0;
    double muMInc=0;
    double b=0;
    double density=getProperty(DENSITY);
    double molMass=0;
    List<MaterialStack> list=getComponents();
    for (    MaterialStack stack : list) {
      molMass+=(stack.getAmount() * (stack.getMaterial().getProperty(ATOMIC_MASS)));
      System.out.println(""String_Node_Str"" + stack.getMaterial().getName() + ""String_Node_Str""+ molMass);
    }
    if (list.size() > 0 && molMass >= 1) {
      numberDensity=(1E-24) * (nA) * (density / molMass);
      for (int j=0; j < list.size(); j++) {
        MaterialStack stack=list.get(j);
        Material mat=stack.getMaterial();
        int N=stack.getAmount();
        double cohb=1E-5 * mat.getProperty(COHERENT_SCAT_LENGTH);
        b+=N * cohb;
        double massPercent=mat.getProperty(ATOMIC_MASS) / molMass;
        muMAbs+=N * massPercent * (mat.getProperty(MASS_ABS_COHERENT));
        muMInc+=N * massPercent * (mat.getProperty(MASS_ABS_INCOHERENT));
      }
    }
    setProperty(ATOMIC_MASS,molMass);
    setProperty(NUMBER_DENSITY,numberDensity);
    setProperty(SCAT_LENGTH_DENSITY,numberDensity * b);
    muMAbs*=1E-24 * getProperty(DENSITY);
    setProperty(MASS_ABS_COHERENT,muMAbs);
    muMInc*=1E-24 * getProperty(DENSITY);
    setProperty(MASS_ABS_INCOHERENT,muMInc);
  }
}",0.9664138678223184
133570,"/** 
 * Updates the properties for a connection based on the specified name and preference value. If necessary, the connection may be reset.
 * @param name The name of the connection (a preference name in the store).
 * @param preferences The <i>new</i> preference value for the connection. This value should come straight from the  {@link #preferenceStore}.
 */
private void updateConnection(String name,String preferences){
  final VizConnection<T> connection=connectionsByName.get(name);
  if (updateConnectionPreferences(connection,preferences)) {
    final Future<ConnectionState> disconnectRequest=connection.disconnect();
    final ExecutorService executor=Executors.newSingleThreadExecutor();
    executor.submit(new Runnable(){
      @Override public void run(){
        try {
          disconnectRequest.get();
        }
 catch (        InterruptedException|ExecutionException e) {
          e.printStackTrace();
        }
        connection.connect();
      }
    }
);
  }
  return;
}","/** 
 * Updates the properties for a connection based on the specified name and preference value. If necessary, the connection may be reset.
 * @param name The name of the connection (a preference name in the store).
 * @param preferences The <i>new</i> preference value for the connection. This value should come straight from the  {@link #preferenceStore}.
 */
private void updateConnection(String name,String preferences){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ preferences+ ""String_Node_Str"");
  final VizConnection<T> connection=connectionsByName.get(name);
  if (updateConnectionPreferences(connection,preferences)) {
    final Future<ConnectionState> disconnectRequest=connection.disconnect();
    final ExecutorService executor=Executors.newSingleThreadExecutor();
    executor.submit(new Runnable(){
      @Override public void run(){
        try {
          disconnectRequest.get();
        }
 catch (        InterruptedException|ExecutionException e) {
          e.printStackTrace();
        }
        connection.connect();
      }
    }
);
  }
  return;
}",0.943127962085308
133571,"/** 
 * Adds a new connection based on the specified name and preference value. The connection will attempt to connect.
 * @param name The name of the connection (a preference name in the store).
 * @param preferences The preference value for the connection. This value should come straight from the  {@link #preferenceStore}.
 */
private void addConnection(String name,String preferences){
  VizConnection<T> connection=createConnection(name,preferences);
  String[] split=preferences.split(getDelimiter());
  try {
    connection.setName(name);
    connection.setHost(split[0]);
    connection.setPort(Integer.parseInt(split[1]));
    connection.setPath(split[2]);
    connectionsByName.put(name,connection);
    String host=connection.getHost();
    Set<String> connections=connectionsByHost.get(host);
    if (connections == null) {
      connections=new HashSet<String>();
      connectionsByHost.put(host,connections);
    }
    connections.add(name);
    connection.connect();
  }
 catch (  IndexOutOfBoundsException|NullPointerException|NumberFormatException e) {
  }
  return;
}","/** 
 * Adds a new connection based on the specified name and preference value. The connection will attempt to connect.
 * @param name The name of the connection (a preference name in the store).
 * @param preferences The preference value for the connection. This value should come straight from the  {@link #preferenceStore}.
 */
private void addConnection(String name,String preferences){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ preferences+ ""String_Node_Str"");
  VizConnection<T> connection=createConnection(name,preferences);
  String[] split=preferences.split(getDelimiter(),-1);
  try {
    connection.setName(name);
    connection.setHost(split[0]);
    connection.setPort(Integer.parseInt(split[1]));
    connection.setPath(split[2]);
    connectionsByName.put(name,connection);
    String host=connection.getHost();
    Set<String> connections=connectionsByHost.get(host);
    if (connections == null) {
      connections=new HashSet<String>();
      connectionsByHost.put(host,connections);
    }
    connections.add(name);
    connection.connect();
  }
 catch (  IndexOutOfBoundsException|NullPointerException|NumberFormatException e) {
  }
  return;
}",0.9464518937744884
133572,"/** 
 * Removes a connection based on the specified name. The connection will be disconnected.
 * @param name The name of the connection to remove.
 */
private void removeConnection(String name){
  VizConnection<T> connection=connectionsByName.remove(name);
  String host=connection.getHost();
  Set<String> connections=connectionsByHost.get(host);
  connections.remove(name);
  if (connections.isEmpty()) {
    connectionsByHost.remove(host);
  }
  return;
}","/** 
 * Removes a connection based on the specified name. The connection will be disconnected.
 * @param name The name of the connection to remove.
 */
private void removeConnection(String name){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
  VizConnection<T> connection=connectionsByName.remove(name);
  String host=connection.getHost();
  Set<String> connections=connectionsByHost.get(host);
  connections.remove(name);
  if (connections.isEmpty()) {
    connectionsByHost.remove(host);
  }
  return;
}",0.9125248508946322
133573,"/** 
 * Gets each connection property from the string of preferences, if possible, and updates the connection based on them.
 * @return True if one of the properties changed and a reset of theconnection is required, false if a reset is <i>not</i> required.
 */
protected boolean updateConnectionPreferences(VizConnection<T> connection,String preferences){
  boolean requiresReset=false;
  String[] split=preferences.split(getDelimiter());
  try {
    String host=split[0];
    int port=Integer.parseInt(split[1]);
    String path=split[2];
    requiresReset|=connection.setHost(host);
    requiresReset|=connection.setPort(port);
    requiresReset|=connection.setPath(path);
  }
 catch (  IndexOutOfBoundsException|NullPointerException|NumberFormatException e) {
    requiresReset=false;
  }
  return requiresReset;
}","/** 
 * Gets each connection property from the string of preferences, if possible, and updates the connection based on them. <p> <b>Note:</b> If overridden, it is recommended to call the super method so that teh host, port, and path will be updated. This method will return true if any of those three properties change. </p>
 * @param connection The connection whose preferences are being updated.
 * @param preferences The serialized string of preferences.
 * @return True if one of the properties changed and a reset of theconnection is required, false if a reset is <i>not</i> required.
 */
protected boolean updateConnectionPreferences(VizConnection<T> connection,String preferences){
  boolean requiresReset=false;
  String[] split=preferences.split(getDelimiter(),-1);
  try {
    String host=split[0];
    int port=Integer.parseInt(split[1]);
    String path=split[2];
    requiresReset|=connection.setHost(host);
    requiresReset|=connection.setPort(port);
    requiresReset|=connection.setPath(path);
  }
 catch (  IndexOutOfBoundsException|NullPointerException|NumberFormatException e) {
    requiresReset=false;
  }
  return requiresReset;
}",0.8294416243654822
133574,"/** 
 * Initializes the viz connection manager that is tested as well as any other class variables frequently used to test the connection.
 */
@Before public void beforeEachTest(){
  fakeConnections=new HashMap<String,FakeVizConnection>();
  manager=new VizConnectionManager<FakeClient>(){
    @Override protected VizConnection<FakeClient> createConnection(    String name,    String preferences){
      FakeVizConnection fakeConnection=new FakeVizConnection();
      fakeConnections.put(name,fakeConnection);
      return fakeConnection;
    }
  }
;
  store=new CustomScopedPreferenceStore(getClass());
  return;
}","/** 
 * Initializes the viz connection manager that is tested as well as any other class variables frequently used to test the connection.
 */
@Before public void beforeEachTest(){
  fakeConnections=new HashMap<String,FakeVizConnection>();
  manager=new VizConnectionManager<FakeClient>(){
    @Override protected VizConnection<FakeClient> createConnection(    String name,    String preferences){
      FakeVizConnection fakeConnection=new FakeVizConnection();
      fakeConnections.put(name,fakeConnection);
      return fakeConnection;
    }
  }
;
  store=new CustomScopedPreferenceStore(getClass());
  store.removeNode(NODE_ID);
  return;
}",0.976965845909452
133575,"/** 
 * This operation retrieves the DataComponent that is currently rendered, updated and monitored by the ICESectionPart.
 * @return The DataComponent
 */
public DataComponent getDataComponent(){
  return dataComposite.getDataComponent();
}","/** 
 * This operation retrieves the DataComponent that is currently rendered, updated and monitored by the ICESectionPart.
 * @return The DataComponent
 */
public DataComponent getDataComponent(){
  return dataComp;
}",0.9478260869565216
133576,"/** 
 * <p> This operation retrieves the Components that are managed by this page. This operation should not be generally used, but for testing purposes where there is a setter there must be a getter. </p>
 * @return <p>The set of Components managed by this page. </p>
 */
public ArrayList<Component> getComponents(){
  ArrayList<Component> compList=new ArrayList<Component>();
  compList.addAll(dataComponents);
  compList.addAll(tableComponents);
  compList.addAll(matrixComponents);
  return components;
}","/** 
 * <p> This operation retrieves the Components that are managed by this page. This operation should not be generally used, but for testing purposes where there is a setter there must be a getter. </p>
 * @return <p>The set of Components managed by this page. </p>
 */
public ArrayList<Component> getComponents(){
  ArrayList<Component> compList=new ArrayList<Component>();
  compList.addAll(dataComponents);
  compList.addAll(tableComponents);
  compList.addAll(matrixComponents);
  return compList;
}",0.990138067061144
133577,"/** 
 * <p> The Constructor </p>
 * @param editor <p> The FormEditor for which the Page should be constructed. </p>
 * @param id <p> The id of the page. </p>
 * @param title <p> The title of the page. </p>
 */
public ICESectionPage(FormEditor editor,String id,String title){
  super(editor,id,title);
  if (editor != null && editor instanceof ICEFormEditor) {
    this.editor=(ICEFormEditor)editor;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  components=new ArrayList<Component>();
  dataComponents=new ArrayList<DataComponent>();
  tableComponents=new ArrayList<TableComponent>();
  matrixComponents=new ArrayList<MatrixComponent>();
  return;
}","/** 
 * <p> The Constructor </p>
 * @param editor <p> The FormEditor for which the Page should be constructed. </p>
 * @param id <p> The id of the page. </p>
 * @param title <p> The title of the page. </p>
 */
public ICESectionPage(FormEditor editor,String id,String title){
  super(editor,id,title);
  if (editor != null && editor instanceof ICEFormEditor) {
    this.editor=(ICEFormEditor)editor;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  dataComponents=new ArrayList<DataComponent>();
  tableComponents=new ArrayList<TableComponent>();
  matrixComponents=new ArrayList<MatrixComponent>();
  return;
}",0.9142431021625652
133578,"@Override public void register(IVizService service){
  if (service != null) {
    String name=service.getName();
    serviceMap.put(name,service);
    Set<String> supportedExtensions=new HashSet<String>();
    supportedExtensions.addAll(((AbstractVizService)service).supportedExtensions);
    for (    String ext : supportedExtensions) {
      EditorRegistry editorReg=(EditorRegistry)PlatformUI.getWorkbench().getEditorRegistry();
      EditorDescriptor editor=(EditorDescriptor)editorReg.findEditor(""String_Node_Str"");
      FileEditorMapping mapping=new FileEditorMapping(ext);
      mapping.addEditor(editor);
      mapping.setDefaultEditor(editor);
      IFileEditorMapping[] mappings=editorReg.getFileEditorMappings();
      FileEditorMapping[] newMappings=new FileEditorMapping[mappings.length + 1];
      for (int i=0; i < mappings.length; i++) {
        newMappings[i]=(FileEditorMapping)mappings[i];
      }
      newMappings[mappings.length]=mapping;
      editorReg.setFileEditorMappings(newMappings);
    }
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
    if (getPreferenceStore().getBoolean(""String_Node_Str"")) {
      if (service.connect()) {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
  }
  return;
}","@Override public void register(IVizService service){
  if (service != null) {
    String name=service.getName();
    serviceMap.put(name,service);
    if (service instanceof AbstractVizService) {
      Set<String> supportedExtensions=new HashSet<String>();
      supportedExtensions.addAll(((AbstractVizService)service).supportedExtensions);
      for (      String ext : supportedExtensions) {
        EditorRegistry editorReg=(EditorRegistry)PlatformUI.getWorkbench().getEditorRegistry();
        EditorDescriptor editor=(EditorDescriptor)editorReg.findEditor(""String_Node_Str"");
        FileEditorMapping mapping=new FileEditorMapping(ext);
        mapping.addEditor(editor);
        mapping.setDefaultEditor(editor);
        IFileEditorMapping[] mappings=editorReg.getFileEditorMappings();
        FileEditorMapping[] newMappings=new FileEditorMapping[mappings.length + 1];
        for (int i=0; i < mappings.length; i++) {
          newMappings[i]=(FileEditorMapping)mappings[i];
        }
        newMappings[mappings.length]=mapping;
        editorReg.setFileEditorMappings(newMappings);
      }
    }
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
    if (getPreferenceStore().getBoolean(""String_Node_Str"")) {
      if (service.connect()) {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
  }
  return;
}",0.9085303186022612
133579,"@Override public boolean disconnect(){
  return connections.disconnect();
}","@Override public boolean disconnect(){
  return false;
}",0.7938931297709924
133580,"/** 
 * The default constructor. <p> <b>Note:</b> Only OSGi should call this method! </p>
 */
public VisItVizService(){
  instance=this;
  connections=null;
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  return;
}","/** 
 * The default constructor. <p> <b>Note:</b> Only OSGi should call this method! </p>
 */
public VisItVizService(){
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  supportedExtensions.add(""String_Node_Str"");
  manager=new VisItConnectionManager();
  manager.setPreferenceStore((CustomScopedPreferenceStore)getPreferenceStore(),CONNECTIONS_NODE_ID);
  return;
}",0.2160883280757097
133581,"/** 
 * The default constructor.
 */
public VisItConnection(){
  propertyHandlers.remove(""String_Node_Str"");
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.get(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.get(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.get(""String_Node_Str""));
  return;
}","/** 
 * The default constructor.
 */
public VisItConnection(){
  propertyHandlers.remove(""String_Node_Str"");
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.remove(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",propertyHandlers.get(""String_Node_Str""));
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue;
    }
  }
);
  return;
}",0.7020316027088036
133582,"/** 
 * Gets the key (""connection ID"") associated with the default connection. This can be set on the preference page.
 * @return The key for the default connection, or null if one is not set.
 */
private String getDefaultConnectionKey(){
  int id=getPreferenceStore().getInt(""String_Node_Str"");
  List<String> connectionNames=table.getConnectionNames();
  return (id < connectionNames.size() ? connectionNames.get(id) : null);
}","/** 
 * Gets the key (""connection ID"") associated with the default connection. This can be set on the preference page.
 * @return The key for the default connection, or null if one is not set.
 */
private String getDefaultConnectionKey(){
  int id=getPreferenceStore().getInt(""String_Node_Str"");
  String key=null;
  if (id >= 0 && id < table.numberOfRows()) {
    key=table.getRow(id).get(0).getValue();
  }
  return key;
}",0.7479484173505275
133583,"@Override public void init(IWorkbench workbench){
  setDescription(getVizService().getName() + ""String_Node_Str"");
  TableComponentPreferenceAdapter adapter=new TableComponentPreferenceAdapter();
  adapter.toTableComponent((CustomScopedPreferenceStore)getPreferenceStore(),connectionManager);
  resetKeyChangeInfo();
  connectionManager.addKeyChangeListener(this);
  return;
}","@Override public void init(IWorkbench workbench){
  super.init(workbench);
  TableComponentPreferenceAdapter adapter=new TableComponentPreferenceAdapter();
  adapter.toTableComponent((CustomScopedPreferenceStore)getPreferenceStore(),connectionManager);
  resetKeyChangeInfo();
  return;
}",0.2469879518072289
133584,"@Override protected void createFieldEditors(){
  Composite parent=getFieldEditorParent();
  final DynamicComboFieldEditor defaultConnection;
  defaultConnection=new DynamicComboFieldEditor(""String_Node_Str"",""String_Node_Str"",parent,connectionManager.getConnectionNames());
  addField(defaultConnection);
  connectionManager.addKeyChangeListener(new IKeyChangeListener(){
    @Override public void keyChanged(    String oldKey,    String newKey){
      String value=defaultConnection.getValue();
      List<String> names=connectionManager.getConnectionNames();
      defaultConnection.setAllowedValues(names);
      if (oldKey != null && newKey != null && oldKey.equals(value)) {
        defaultConnection.setValue(newKey);
      }
      return;
    }
  }
);
  return;
}","@Override protected void createFieldEditors(){
  Composite parent=getFieldEditorParent();
  return;
}",0.232183908045977
133585,"/** 
 * This operation is used to check equality between the MOOSE Item and another MOOSE Item. It returns true if the Items are equal and false if they are not.
 * @param otherMoose The MOOSE Item that should be checked for equality.
 * @return True if the launchers are equal, false if not
 */
public boolean equals(MOOSE otherMoose){
  boolean retVal;
  if (this == otherMoose) {
    return true;
  }
  if (otherMoose == null || !(otherMoose instanceof Item) || !super.equals(otherMoose)) {
    return false;
  }
  retVal=(this.allowedActions.equals(otherMoose.allowedActions)) && (this.form.equals(otherMoose.form)) && (this.itemType == otherMoose.itemType)&& (this.status.equals(otherMoose.status));
  if (this.project != null && otherMoose.project != null && (!(this.project.equals(otherMoose.project)))) {
    return false;
  }
  if (this.project == null && otherMoose.project != null || this.project != null && otherMoose.project == null) {
    return false;
  }
  if (!mooseModel.equals(otherMoose.mooseModel) && !mooseLauncher.equals(otherMoose.mooseLauncher)) {
    return false;
  }
  return retVal;
}","/** 
 * This operation is used to check equality between the MOOSE Item and another MOOSE Item. It returns true if the Items are equal and false if they are not.
 * @param otherMoose The MOOSE Item that should be checked for equality.
 * @return True if the launchers are equal, false if not
 */
public boolean equals(Object other){
  boolean retVal;
  if (this == other) {
    return true;
  }
  if (other == null || !(other instanceof MOOSE) || !super.equals(other)) {
    return false;
  }
  MOOSE otherMoose=(MOOSE)other;
  retVal=(this.allowedActions.equals(otherMoose.allowedActions)) && (this.form.equals(otherMoose.form)) && (this.itemType == otherMoose.itemType)&& (this.status.equals(otherMoose.status));
  if (this.project != null && otherMoose.project != null && (!(this.project.equals(otherMoose.project)))) {
    return false;
  }
  if (this.project == null && otherMoose.project != null || this.project != null && otherMoose.project == null) {
    return false;
  }
  if (!mooseModel.equals(otherMoose.mooseModel) && !mooseLauncher.equals(otherMoose.mooseLauncher)) {
    return false;
  }
  return retVal;
}",0.3479427549194991
133586,"/** 
 * <p> This operation returns the hashcode value of the MOOSELauncher. </p>
 * @return <p> The hashcode </p>
 */
public int hashCode(){
  int hash=9;
  hash=31 * hash + super.hashCode();
  hash=31 * hash + inputFileName.hashCode();
  return hash;
}","/** 
 * <p> This operation returns the hashcode value of the MOOSELauncher. </p>
 * @return <p>The hashcode </p>
 */
public int hashCode(){
  int hash=9;
  hash=31 * hash + super.hashCode();
  hash=31 * hash + inputFileName.hashCode();
  return hash;
}",0.998019801980198
133587,"/** 
 * <p> This operation is used to check equality between the MOOSEModel Item and another MOOSEModel Item. It returns true if the Items are equal and false if they are not. </p>
 * @param otherMoose <p> The MOOSEModel Item that should be checked for equality. </p>
 * @return <p> True if the launchers are equal, false if not </p>
 */
public boolean equals(MOOSELauncher otherMoose){
  boolean retVal;
  if (this == otherMoose) {
    return true;
  }
  if (otherMoose == null || !(otherMoose instanceof Item) || !super.equals(otherMoose)) {
    return false;
  }
  retVal=(this.allowedActions.equals(otherMoose.allowedActions)) && (this.form.equals(otherMoose.form)) && (this.itemType == otherMoose.itemType)&& (this.status.equals(otherMoose.status));
  if (this.project != null && otherMoose.project != null && (!(this.project.equals(otherMoose.project)))) {
    return false;
  }
  if (this.project == null && otherMoose.project != null || this.project != null && otherMoose.project == null) {
    return false;
  }
  return retVal;
}","/** 
 * <p> This operation is used to check equality between the MOOSEModel Item and another MOOSEModel Item. It returns true if the Items are equal and false if they are not. </p>
 * @param otherMoose <p> The MOOSEModel Item that should be checked for equality. </p>
 * @return <p>True if the launchers are equal, false if not </p>
 */
public boolean equals(Object other){
  boolean retVal;
  if (this == other) {
    return true;
  }
  if (other == null || !(other instanceof MOOSELauncher) || !super.equals(other)) {
    return false;
  }
  MOOSELauncher otherMooseLauncher=(MOOSELauncher)other;
  retVal=(this.allowedActions.equals(otherMooseLauncher.allowedActions)) && (this.form.equals(otherMooseLauncher.form)) && (this.itemType == otherMooseLauncher.itemType)&& (this.status.equals(otherMooseLauncher.status));
  if (this.project != null && otherMooseLauncher.project != null && (!(this.project.equals(otherMooseLauncher.project)))) {
    return false;
  }
  if (this.project == null && otherMooseLauncher.project != null || this.project != null && otherMooseLauncher.project == null) {
    return false;
  }
  return retVal;
}",0.8229885057471265
133588,"/** 
 * <p> This operation provides a deep copy of the MOOSELauncher Item. </p>
 * @return <p> A clone of the MOOSELauncher Item. </p>
 */
public Object clone(){
  MOOSELauncher clone=new MOOSELauncher();
  clone.copy(this);
  return clone;
}","/** 
 * <p> This operation provides a deep copy of the MOOSELauncher Item. </p>
 * @return <p>A clone of the MOOSELauncher Item. </p>
 */
public Object clone(){
  MOOSELauncher clone=new MOOSELauncher();
  clone.copy(this);
  return clone;
}",0.9979296066252588
133589,"/** 
 * <p> This operation is used to check equality between the MOOSEModel Item and another MOOSEModel Item. It returns true if the Items are equal and false if they are not. </p>
 * @param otherMoose <p> The MOOSEModel Item that should be checked for equality. </p>
 * @return <p> True if the launchers are equal, false if not </p>
 */
public boolean equals(MOOSEModel otherMooseModel){
  boolean retVal;
  if (this == otherMooseModel) {
    return true;
  }
  if (otherMooseModel == null || !(otherMooseModel instanceof Item) || !super.equals(otherMooseModel)) {
    return false;
  }
  retVal=(this.allowedActions.equals(otherMooseModel.allowedActions)) && (this.form.equals(otherMooseModel.form)) && (this.itemType == otherMooseModel.itemType)&& (this.status.equals(otherMooseModel.status));
  if (this.project != null && otherMooseModel.project != null && (!(this.project.equals(otherMooseModel.project)))) {
    return false;
  }
  if (this.project == null && otherMooseModel.project != null || this.project != null && otherMooseModel.project == null) {
    return false;
  }
  return retVal;
}","/** 
 * <p> This operation is used to check equality between the MOOSEModel Item and another MOOSEModel Item. It returns true if the Items are equal and false if they are not. </p>
 * @param otherMoose <p> The MOOSEModel Item that should be checked for equality. </p>
 * @return <p> True if the launchers are equal, false if not </p>
 */
public boolean equals(Object other){
  boolean retVal;
  if (this == other) {
    return true;
  }
  if (other == null || !(other instanceof MOOSEModel) || !super.equals(other)) {
    return false;
  }
  MOOSEModel otherMooseModel=(MOOSEModel)other;
  retVal=(this.allowedActions.equals(otherMooseModel.allowedActions)) && (this.form.equals(otherMooseModel.form)) && (this.itemType == otherMooseModel.itemType)&& (this.status.equals(otherMooseModel.status));
  if (this.project != null && otherMooseModel.project != null && (!(this.project.equals(otherMooseModel.project)))) {
    return false;
  }
  if (this.project == null && otherMooseModel.project != null || this.project != null && otherMooseModel.project == null) {
    return false;
  }
  return retVal;
}",0.8474114441416893
133590,"@Override public boolean deleteRow(int index){
  boolean deleted=false;
  if (index >= 0 && index < numberOfRows()) {
    List<Entry> row=getRow(index);
    deleted=super.deleteRow(index);
    if (deleted) {
      row.get(0).unregister(keyListeners.remove(index));
      String key=row.get(0).getValue();
      keyToIndexMap.remove(key);
      for (int i=index; i < numberOfRows(); i++) {
        key=getRow(index).get(0).getValue();
        keyToIndexMap.put(key,i);
      }
    }
  }
  return deleted;
}","@Override public boolean deleteRow(int index){
  boolean deleted=false;
  if (index >= 0 && index < numberOfRows()) {
    List<Entry> row=getRow(index);
    deleted=super.deleteRow(index);
    if (deleted) {
      row.get(0).unregister(keyListeners.remove(index));
      String key=row.get(0).getValue();
      keyToIndexMap.remove(key);
      for (int i=index; i < numberOfRows(); i++) {
        key=getRow(i).get(0).getValue();
        keyToIndexMap.put(key,i);
      }
    }
  }
  return deleted;
}",0.9960238568588468
133591,"/** 
 * Checks that connections can be removed, at which point they can no longer be queried from the table.
 */
@Test public void checkRemoveConnection(){
  List<Entry> row;
  String name;
  String host=""String_Node_Str"";
  assertEquals(0,table.addRow());
  assertEquals(1,table.addRow());
  assertNotNull(table.getConnection(""String_Node_Str""));
  assertNotNull(table.getConnection(""String_Node_Str""));
  table.deleteRow(0);
  assertNull(table.getConnection(""String_Node_Str""));
  assertNotNull(table.getConnection(""String_Node_Str""));
  assertEquals(1,table.numberOfRows());
  assertFalse(table.getConnectionNames().contains(""String_Node_Str""));
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  name=""String_Node_Str"";
  row=table.getRow(0);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(DEFAULT_HOST,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  row.get(1).setValue(host);
  name=""String_Node_Str"";
  assertEquals(1,table.addRow());
  row=table.getRow(1);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(DEFAULT_HOST,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  name=""String_Node_Str"";
  row=table.getRow(0);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(host,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  assertEquals(2,table.numberOfRows());
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  return;
}","/** 
 * Checks that connections can be removed, at which point they can no longer be queried from the table.
 */
@Test public void checkRemoveConnection(){
  List<Entry> row;
  String name;
  String host=""String_Node_Str"";
  assertEquals(0,table.addRow());
  assertEquals(1,table.addRow());
  assertEquals(2,table.addRow());
  assertNotNull(table.getConnection(""String_Node_Str""));
  assertNotNull(table.getConnection(""String_Node_Str""));
  assertNotNull(table.getConnection(""String_Node_Str""));
  table.deleteRow(0);
  assertNull(table.getConnection(""String_Node_Str""));
  assertNotNull(table.getConnection(""String_Node_Str""));
  assertNotNull(table.getConnection(""String_Node_Str""));
  assertEquals(2,table.numberOfRows());
  assertFalse(table.getConnectionNames().contains(""String_Node_Str""));
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  name=""String_Node_Str"";
  row=table.getRow(0);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(DEFAULT_HOST,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  name=""String_Node_Str"";
  row=table.getRow(1);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(DEFAULT_HOST,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  row.get(1).setValue(host);
  name=""String_Node_Str"";
  assertEquals(2,table.addRow());
  row=table.getRow(2);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(DEFAULT_HOST,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  name=""String_Node_Str"";
  row=table.getRow(0);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(DEFAULT_HOST,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  name=""String_Node_Str"";
  row=table.getRow(1);
  assertNotNull(row);
  assertFalse(row.isEmpty());
  assertEquals(4,row.size());
  assertEquals(name,row.get(0).getValue());
  assertEquals(host,row.get(1).getValue());
  assertEquals(DEFAULT_PORT,row.get(2).getValue());
  assertEquals(DEFAULT_PATH,row.get(3).getValue());
  assertEquals(row,table.getConnection(name));
  assertEquals(3,table.numberOfRows());
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  assertTrue(table.getConnectionNames().contains(""String_Node_Str""));
  return;
}",0.7447539107210989
133592,"/** 
 * If the action name is ReflectivityModel.processActionName, then calculates the reflectivity and scattering density profiles for the material layers and input fields.
 * @see {@link org.eclipse.ice.item.Item#process(String)}
 */
@Override public FormStatus process(String actionName){
  FormStatus retVal=null;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    String qr4Val=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(QR4EntryName).getValue();
    boolean qr4=qr4Val.equalsIgnoreCase(""String_Node_Str"");
    double[] waveVector;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    IFile waveInput=project.getFile(fileName);
    Form waveForm=new CSVReader().read(waveInput);
    ListComponent<String[]> waveData=(ListComponent<String[]>)waveForm.getComponent(1);
    waveVector=new double[waveData.size()];
    for (int i=0; i < waveData.size(); i++) {
      String[] dataLine=waveData.get(i);
      double dataEntry=Double.parseDouble(dataLine[0]);
      waveVector[i]=dataEntry;
    }
    ReflectivityCalculator calculator=new ReflectivityCalculator();
    ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,qr4);
    double[] reflectivity=profile.reflectivity;
    double[] scatDensity=profile.scatteringDensity;
    double[] depth=profile.depth;
    String reflectData=""String_Node_Str"";
    for (int i=0; i < reflectivity.length; i++) {
      reflectData+=Double.toString(reflectivity[i]) + ""String_Node_Str"" + Double.toString(waveVector[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
    String scatData=""String_Node_Str"";
    for (int i=0; i < depth.length; i++) {
      scatData+=Double.toString(scatDensity[i]) + ""String_Node_Str"" + Double.toString(depth[i])+ ""String_Node_Str"";
    }
    ResourceComponent resComp=(ResourceComponent)form.getComponent(resourceCompId);
    ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
    try {
      VizResource reflectSource=(VizResource)resComp.get(0);
      IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
      reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
      VizResource scatSource=(VizResource)resComp.get(1);
      IFile scatteringFile=project.getFile(scatSource.getContents().getName());
      scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
    }
 catch (    CoreException|NullPointerException e) {
      e.printStackTrace();
      retVal=FormStatus.InfoError;
    }
    if (retVal == null) {
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}","/** 
 * If the action name is ReflectivityModel.processActionName, then calculates the reflectivity and scattering density profiles for the material layers and input fields.
 * @see {@link org.eclipse.ice.item.Item#process(String)}
 */
@Override public FormStatus process(String actionName){
  FormStatus retVal=null;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    String qr4Val=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(QR4EntryName).getValue();
    boolean qr4=qr4Val.equalsIgnoreCase(""String_Node_Str"");
    double[] waveVector;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    IFile waveInput=project.getFile(fileName);
    Form waveForm=new CSVReader().read(waveInput);
    ListComponent<String[]> waveData=(ListComponent<String[]>)waveForm.getComponent(1);
    waveVector=new double[waveData.size()];
    for (int i=0; i < waveData.size(); i++) {
      String[] dataLine=waveData.get(i);
      double dataEntry=Double.parseDouble(dataLine[0]);
      waveVector[i]=dataEntry;
    }
    ReflectivityCalculator calculator=new ReflectivityCalculator();
    ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,qr4);
    double[] reflectivity=profile.reflectivity;
    double[] scatDensity=profile.scatteringDensity;
    double[] depth=profile.depth;
    String reflectData=""String_Node_Str"";
    for (int i=0; i < reflectivity.length; i++) {
      reflectData+=Double.toString(reflectivity[i]) + ""String_Node_Str"" + Double.toString(waveVector[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
    String scatData=""String_Node_Str"";
    for (int i=0; i < depth.length; i++) {
      scatData+=Double.toString(scatDensity[i]) + ""String_Node_Str"" + Double.toString(depth[i])+ ""String_Node_Str"";
    }
    ResourceComponent resources=(ResourceComponent)form.getComponent(resourceCompId);
    ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
    if (resources.isEmpty()) {
      String basename=""String_Node_Str"" + form.getId() + ""String_Node_Str"";
      IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
      IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
      try {
        if (!reflectivityFile.exists()) {
          reflectivityFile.create(reflectStream,true,null);
        }
        if (!scatteringFile.exists()) {
          scatteringFile.create(scatStream,true,null);
        }
        VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
        reflectivitySource.setName(""String_Node_Str"");
        reflectivitySource.setId(1);
        reflectivitySource.setDescription(""String_Node_Str"");
        VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
        scatDensitySource.setName(""String_Node_Str"");
        scatDensitySource.setId(2);
        scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
        resources.addResource(reflectivitySource);
        resources.addResource(scatDensitySource);
      }
 catch (      CoreException|IOException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"");
        e.printStackTrace();
      }
    }
 else {
      try {
        VizResource reflectSource=(VizResource)resources.get(0);
        IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
        reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
        VizResource scatSource=(VizResource)resources.get(1);
        IFile scatteringFile=project.getFile(scatSource.getContents().getName());
        scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
      }
 catch (      CoreException|NullPointerException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"");
        e.printStackTrace();
        retVal=FormStatus.InfoError;
      }
    }
    if (retVal == null) {
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}",0.8220766670245893
133593,"@Override protected void setup(){
  allowedValueType=AllowedValueType.Discrete;
  allowedValues.add(""String_Node_Str"");
  allowedValues.add(""String_Node_Str"");
  return;
}","@Override protected void setup(){
  allowedValueType=AllowedValueType.Discrete;
  allowedValues.add(""String_Node_Str"");
  allowedValues.add(""String_Node_Str"");
  defaultValue=""String_Node_Str"";
  return;
}",0.9095744680851064
133594,"@Override protected void setupForm(){
  String line1=""String_Node_Str"";
  String line2=""String_Node_Str"";
  String line3=""String_Node_Str"";
  String line4=""String_Node_Str"";
  String line5=""String_Node_Str"";
  String allLines=line1 + line2 + line3+ line4+ line5;
  ByteArrayInputStream stream=new ByteArrayInputStream(allLines.getBytes());
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(paramsCompId);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(WaveEntryName);
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  Entry numLayersEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  numLayersEntry.setId(2);
  numLayersEntry.setName(RoughnessEntryName);
  numLayersEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  paramComponent.addEntry(numLayersEntry);
  Entry deltaQ0Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  deltaQ0Entry.setId(3);
  deltaQ0Entry.setName(deltaQ0EntryName);
  deltaQ0Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ0Entry);
  Entry deltaQ1Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  deltaQ1Entry.setId(4);
  deltaQ1Entry.setName(deltaQ1ByQEntryName);
  deltaQ1Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ1Entry);
  Entry waveEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  waveEntry.setId(5);
  waveEntry.setName(WaveLengthEntryName);
  waveEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(waveEntry);
  Entry qr4=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Discrete;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  qr4.setId(6);
  qr4.setName(QR4EntryName);
  qr4.setDescription(""String_Node_Str"");
  paramComponent.addEntry(qr4);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(matListId);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  ResourceComponent resources=new ResourceComponent();
  resources.setName(""String_Node_Str"");
  resources.setDescription(""String_Node_Str"");
  resources.setId(resourceCompId);
  form.addComponent(resources);
  if (project != null) {
    String basename=""String_Node_Str"" + getId() + ""String_Node_Str"";
    IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
    IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
    try {
      if (!reflectivityFile.exists()) {
        reflectivityFile.create(stream,true,null);
        stream.reset();
      }
      if (!scatteringFile.exists()) {
        scatteringFile.create(stream,true,null);
      }
      VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
      reflectivitySource.setName(""String_Node_Str"");
      reflectivitySource.setId(1);
      reflectivitySource.setDescription(""String_Node_Str"");
      VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
      scatDensitySource.setName(""String_Node_Str"");
      scatDensitySource.setId(2);
      scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
      resources.addResource(reflectivitySource);
      resources.addResource(scatDensitySource);
    }
 catch (    CoreException|IOException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  allowedActions.add(0,processActionName);
  return;
}","@Override protected void setupForm(){
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(paramsCompId);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(WaveEntryName);
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  Entry numLayersEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  numLayersEntry.setId(2);
  numLayersEntry.setName(RoughnessEntryName);
  numLayersEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  paramComponent.addEntry(numLayersEntry);
  Entry deltaQ0Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  deltaQ0Entry.setId(3);
  deltaQ0Entry.setName(deltaQ0EntryName);
  deltaQ0Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ0Entry);
  Entry deltaQ1Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  deltaQ1Entry.setId(4);
  deltaQ1Entry.setName(deltaQ1ByQEntryName);
  deltaQ1Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ1Entry);
  Entry waveEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  waveEntry.setId(5);
  waveEntry.setName(WaveLengthEntryName);
  waveEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(waveEntry);
  Entry qr4=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Discrete;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      defaultValue=""String_Node_Str"";
      return;
    }
  }
;
  qr4.setId(6);
  qr4.setName(QR4EntryName);
  qr4.setDescription(""String_Node_Str"");
  paramComponent.addEntry(qr4);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(matListId);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  ResourceComponent resources=new ResourceComponent();
  resources.setName(""String_Node_Str"");
  resources.setDescription(""String_Node_Str"");
  resources.setId(resourceCompId);
  form.addComponent(resources);
  allowedActions.add(0,processActionName);
  return;
}",0.7957894736842105
133595,"@Override public void setupFormWithServices(){
  IMaterialsDatabase database=getMaterialsDatabase();
  if (database != null) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    matList.setElementSource(database);
  }
  return;
}","@Override public void setupFormWithServices(){
  ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  matList.setTableFormat(format);
  IMaterialsDatabase database=getMaterialsDatabase();
  if (database != null) {
    matList.setElementSource(database);
  }
  return;
}",0.3918191603875134
133596,"@Override public FormStatus process(String actionName){
  FormStatus retVal=null;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    double[] waveVector;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    IFile waveInput=project.getFile(fileName);
    Form waveForm=new CSVReader().read(waveInput);
    ListComponent<String[]> waveData=(ListComponent<String[]>)waveForm.getComponent(1);
    waveVector=new double[waveData.size()];
    for (int i=0; i < waveData.size(); i++) {
      String[] dataLine=waveData.get(i);
      double dataEntry=Double.parseDouble(dataLine[0]);
      waveVector[i]=dataEntry;
    }
    ReflectivityCalculator calculator=new ReflectivityCalculator();
    ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,false);
    double[] reflectivity=profile.reflectivity;
    double[] scatDensity=profile.scatteringDensity;
    double[] depth=profile.depth;
    String reflectData=""String_Node_Str"";
    for (int i=0; i < reflectivity.length; i++) {
      reflectData+=Double.toString(reflectivity[i]) + ""String_Node_Str"" + Double.toString(waveVector[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
    String scatData=""String_Node_Str"";
    for (int i=0; i < depth.length; i++) {
      scatData+=Double.toString(scatDensity[i]) + ""String_Node_Str"" + Double.toString(depth[i])+ ""String_Node_Str"";
    }
    ResourceComponent resComp=(ResourceComponent)form.getComponent(resourceCompId);
    ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
    try {
      VizResource reflectSource=(VizResource)resComp.get(0);
      IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
      reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
      VizResource scatSource=(VizResource)resComp.get(1);
      IFile scatteringFile=project.getFile(scatSource.getContents().getName());
      scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
    }
 catch (    CoreException|NullPointerException e) {
      e.printStackTrace();
      retVal=FormStatus.InfoError;
    }
    if (retVal == null) {
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}","@Override public FormStatus process(String actionName){
  FormStatus retVal=null;
  if (actionName.equals(processActionName)) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    ArrayList<Slab> slabs=new ArrayList<Slab>();
    for (    Material mat : matList) {
      Slab slab=new Slab();
      slab.thickness=mat.getProperty(""String_Node_Str"");
      slab.interfaceWidth=mat.getProperty(""String_Node_Str"");
      slab.scatteringLength=mat.getProperty(Material.SCAT_LENGTH_DENSITY);
      slab.trueAbsLength=mat.getProperty(Material.MASS_ABS_COHERENT);
      slab.incAbsLength=mat.getProperty(Material.MASS_ABS_INCOHERENT);
      slabs.add(slab);
    }
    int numRough=Integer.parseInt(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(RoughnessEntryName).getValue());
    double deltaQ0=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ0EntryName).getValue());
    double deltaQ1ByQ=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(deltaQ1ByQEntryName).getValue());
    double wavelength=Double.parseDouble(((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveLengthEntryName).getValue());
    String qr4Val=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(QR4EntryName).getValue();
    boolean qr4=qr4Val.equalsIgnoreCase(""String_Node_Str"");
    double[] waveVector;
    String fileName=((DataComponent)form.getComponent(paramsCompId)).retrieveEntry(WaveEntryName).getValue();
    IFile waveInput=project.getFile(fileName);
    Form waveForm=new CSVReader().read(waveInput);
    ListComponent<String[]> waveData=(ListComponent<String[]>)waveForm.getComponent(1);
    waveVector=new double[waveData.size()];
    for (int i=0; i < waveData.size(); i++) {
      String[] dataLine=waveData.get(i);
      double dataEntry=Double.parseDouble(dataLine[0]);
      waveVector[i]=dataEntry;
    }
    ReflectivityCalculator calculator=new ReflectivityCalculator();
    ReflectivityProfile profile=calculator.getReflectivityProfile(slabs.toArray(new Slab[slabs.size()]),numRough,deltaQ0,deltaQ1ByQ,wavelength,waveVector,qr4);
    double[] reflectivity=profile.reflectivity;
    double[] scatDensity=profile.scatteringDensity;
    double[] depth=profile.depth;
    String reflectData=""String_Node_Str"";
    for (int i=0; i < reflectivity.length; i++) {
      reflectData+=Double.toString(reflectivity[i]) + ""String_Node_Str"" + Double.toString(waveVector[i])+ ""String_Node_Str"";
    }
    ByteArrayInputStream reflectStream=new ByteArrayInputStream(reflectData.getBytes());
    String scatData=""String_Node_Str"";
    for (int i=0; i < depth.length; i++) {
      scatData+=Double.toString(scatDensity[i]) + ""String_Node_Str"" + Double.toString(depth[i])+ ""String_Node_Str"";
    }
    ResourceComponent resComp=(ResourceComponent)form.getComponent(resourceCompId);
    ByteArrayInputStream scatStream=new ByteArrayInputStream(scatData.getBytes());
    try {
      VizResource reflectSource=(VizResource)resComp.get(0);
      IFile reflectivityFile=project.getFile(reflectSource.getContents().getName());
      reflectivityFile.setContents(new BufferedInputStream(reflectStream),true,false,null);
      VizResource scatSource=(VizResource)resComp.get(1);
      IFile scatteringFile=project.getFile(scatSource.getContents().getName());
      scatteringFile.setContents(new BufferedInputStream(scatStream),true,false,null);
    }
 catch (    CoreException|NullPointerException e) {
      e.printStackTrace();
      retVal=FormStatus.InfoError;
    }
    if (retVal == null) {
      retVal=FormStatus.Processed;
    }
  }
 else {
    retVal=super.process(actionName);
  }
  return retVal;
}",0.976024112892177
133597,"@Override protected void setup(){
  allowedValueType=AllowedValueType.Continuous;
  allowedValues.add(""String_Node_Str"");
  allowedValues.add(""String_Node_Str"");
  return;
}","@Override protected void setup(){
  allowedValueType=AllowedValueType.Discrete;
  allowedValues.add(""String_Node_Str"");
  allowedValues.add(""String_Node_Str"");
  return;
}",0.9534883720930232
133598,"@Override protected void setupForm(){
  String line1=""String_Node_Str"";
  String line2=""String_Node_Str"";
  String line3=""String_Node_Str"";
  String line4=""String_Node_Str"";
  String line5=""String_Node_Str"";
  String allLines=line1 + line2 + line3+ line4+ line5;
  ByteArrayInputStream stream=new ByteArrayInputStream(allLines.getBytes());
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(paramsCompId);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(WaveEntryName);
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  Entry numLayersEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  numLayersEntry.setId(2);
  numLayersEntry.setName(RoughnessEntryName);
  numLayersEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  paramComponent.addEntry(numLayersEntry);
  Entry deltaQ0Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  deltaQ0Entry.setId(3);
  deltaQ0Entry.setName(deltaQ0EntryName);
  deltaQ0Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ0Entry);
  Entry deltaQ1Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  deltaQ1Entry.setId(4);
  deltaQ1Entry.setName(deltaQ1ByQEntryName);
  deltaQ1Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ1Entry);
  Entry waveEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  waveEntry.setId(5);
  waveEntry.setName(WaveLengthEntryName);
  waveEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(waveEntry);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(matListId);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  ResourceComponent resources=new ResourceComponent();
  resources.setName(""String_Node_Str"");
  resources.setDescription(""String_Node_Str"");
  resources.setId(resourceCompId);
  form.addComponent(resources);
  if (project != null) {
    String basename=""String_Node_Str"" + getId() + ""String_Node_Str"";
    IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
    IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
    try {
      if (reflectivityFile.exists()) {
        reflectivityFile.delete(true,null);
      }
      reflectivityFile.create(stream,true,null);
      if (scatteringFile.exists()) {
        scatteringFile.delete(true,null);
      }
      stream.reset();
      scatteringFile.create(stream,true,null);
      VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
      reflectivitySource.setName(""String_Node_Str"");
      reflectivitySource.setId(1);
      reflectivitySource.setDescription(""String_Node_Str"");
      VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
      scatDensitySource.setName(""String_Node_Str"");
      scatDensitySource.setId(2);
      scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
      resources.addResource(reflectivitySource);
      resources.addResource(scatDensitySource);
    }
 catch (    CoreException|IOException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  allowedActions.add(0,processActionName);
  return;
}","@Override protected void setupForm(){
  String line1=""String_Node_Str"";
  String line2=""String_Node_Str"";
  String line3=""String_Node_Str"";
  String line4=""String_Node_Str"";
  String line5=""String_Node_Str"";
  String allLines=line1 + line2 + line3+ line4+ line5;
  ByteArrayInputStream stream=new ByteArrayInputStream(allLines.getBytes());
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(paramsCompId);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(WaveEntryName);
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  Entry numLayersEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  numLayersEntry.setId(2);
  numLayersEntry.setName(RoughnessEntryName);
  numLayersEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  paramComponent.addEntry(numLayersEntry);
  Entry deltaQ0Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  deltaQ0Entry.setId(3);
  deltaQ0Entry.setName(deltaQ0EntryName);
  deltaQ0Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ0Entry);
  Entry deltaQ1Entry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  deltaQ1Entry.setId(4);
  deltaQ1Entry.setName(deltaQ1ByQEntryName);
  deltaQ1Entry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(deltaQ1Entry);
  Entry waveEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  waveEntry.setId(5);
  waveEntry.setName(WaveLengthEntryName);
  waveEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(waveEntry);
  Entry qr4=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Discrete;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  qr4.setId(6);
  qr4.setName(QR4EntryName);
  qr4.setDescription(""String_Node_Str"");
  paramComponent.addEntry(qr4);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(matListId);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  ResourceComponent resources=new ResourceComponent();
  resources.setName(""String_Node_Str"");
  resources.setDescription(""String_Node_Str"");
  resources.setId(resourceCompId);
  form.addComponent(resources);
  if (project != null) {
    String basename=""String_Node_Str"" + getId() + ""String_Node_Str"";
    IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
    IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
    try {
      if (!reflectivityFile.exists()) {
        reflectivityFile.create(stream,true,null);
        stream.reset();
      }
      if (!scatteringFile.exists()) {
        scatteringFile.create(stream,true,null);
      }
      VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
      reflectivitySource.setName(""String_Node_Str"");
      reflectivitySource.setId(1);
      reflectivitySource.setDescription(""String_Node_Str"");
      VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
      scatDensitySource.setName(""String_Node_Str"");
      scatDensitySource.setId(2);
      scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
      resources.addResource(reflectivitySource);
      resources.addResource(scatDensitySource);
    }
 catch (    CoreException|IOException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  allowedActions.add(0,processActionName);
  return;
}",0.935756816045127
133599,"/** 
 * Attempts to disconnect from the connection widget on a separate worker thread.
 * @return A future wrapping the connection's state when the disconnectoperation completes. To wait for the connection to disconnect (or fail), use the future's  {@code get()} method.
 */
public Future<ConnectionState> disconnect(){
  return null;
}","/** 
 * Attempts to disconnect from the connection widget on a separate worker thread.
 * @return A future wrapping the connection's state when the disconnectoperation completes. To wait for the connection to disconnect (or fail), use the future's  {@code get()} method.
 */
public Future<ConnectionState> disconnect(){
  Future<ConnectionState> retVal;
  connectionLock.lock();
  try {
    if (state == ConnectionState.Disconnected) {
      retVal=createInstantFuture(state);
    }
 else     if (state == ConnectionState.Failed && widget == null) {
      retVal=createInstantFuture(state);
    }
 else {
      retVal=startDisconnectThread();
    }
  }
  finally {
    connectionLock.unlock();
  }
  return retVal;
}",0.6197718631178707
133600,"@Override public ConnectionState call() throws Exception {
  return state;
}","@Override public ConnectionState call() throws Exception {
  ConnectionState threadState;
  T connectionWidget;
  connectionLock.lock();
  try {
    threadState=state;
    connectionWidget=widget;
  }
  finally {
    connectionLock.unlock();
  }
  if (threadState != ConnectionState.Disconnected && connectionWidget != null) {
    boolean success=disconnectFromWidget(connectionWidget);
    connectionLock.lock();
    try {
      if (success) {
        state=ConnectionState.Disconnected;
        statusMessage=""String_Node_Str"";
        widget=null;
        executorService.shutdown();
        executorService=null;
      }
 else {
        state=ConnectionState.Failed;
        statusMessage=""String_Node_Str"";
      }
      threadState=state;
    }
  finally {
      connectionLock.unlock();
    }
    notifyListeners(threadState,statusMessage);
  }
  return state;
}",0.1312169312169312
133601,"@Override public void connectionStateChanged(IVizConnection<FakeClient> connection,ConnectionState state,String message){
  wasNotified.set(true);
}","@Override public void connectionStateChanged(IVizConnection<FakeClient> connection,ConnectionState state,String message){
  notifyCount.incrementAndGet();
  wasNotified.set(true);
}",0.8996960486322189
133602,"/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#disconnect()} operation fails.
 */
@Test public void checkNotificationsForFailedDisconnect(){
  int size;
  fakeConnection.failOperation=false;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    size=notificationQueue.size();
  }
  finally {
    notificationLock.unlock();
  }
  if (size != 6) {
    assertTrue(fakeListener1.wasNotified());
  }
  notificationLock.lock();
  try {
    assertEquals(6,notificationQueue.size());
    notificationQueue.clear();
  }
  finally {
    notificationLock.unlock();
  }
  fakeConnection.failOperation=true;
  try {
    connection.disconnect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Failed,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}","/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#disconnect()} operation fails.
 */
@Test public void checkNotificationsForFailedDisconnect(){
  fakeConnection.failOperation=false;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified(2));
  notificationLock.lock();
  try {
    assertEquals(6,notificationQueue.size());
    notificationQueue.clear();
  }
  finally {
    notificationLock.unlock();
  }
  fakeListener1.wasNotified.set(false);
  fakeConnection.failOperation=true;
  try {
    connection.disconnect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Failed,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}",0.8899810964083176
133603,"/** 
 * Determines if the listener was notified of a connection state change since the last call to this method. <p> This will wait for a certain amount of time until either the flag is true or a timeout occurs. </p>
 * @return True if the listener was notified, false otherwise.
 */
public boolean wasNotified(){
  boolean notified;
  long threshold=3000;
  long interval=50;
  long time=0;
  while (!(notified=wasNotified.getAndSet(false)) && time < threshold) {
    try {
      Thread.sleep(interval);
      time+=threshold;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
      fail(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return notified;
}","/** 
 * Determines if the listener was notified of a connection state change a certain number of times. <p> This will wait for a certain amount of time until either the count is reached or a timeout occurs. </p>
 * @param expectedCount The number of times the listener is expected to be updated.
 * @return True if the listener was updated the expected number oftimes, false otherwise.
 */
public boolean wasNotified(int expectedCount){
  long threshold=3000;
  long interval=50;
  long time=0;
  while (notifyCount.get() < expectedCount && time < threshold) {
    try {
      Thread.sleep(interval);
      time+=threshold;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
      fail(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return notifyCount.get() >= expectedCount;
}",0.7597840755735492
133604,"/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#disconnect()} operation issuccessful.
 */
@Test public void checkNotificationsForSuccessfulDisconnect(){
  int size;
  fakeConnection.failOperation=false;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    size=notificationQueue.size();
  }
  finally {
    notificationLock.unlock();
  }
  if (size != 6) {
    assertTrue(fakeListener1.wasNotified());
  }
  notificationLock.lock();
  try {
    assertEquals(6,notificationQueue.size());
    notificationQueue.clear();
  }
  finally {
    notificationLock.unlock();
  }
  try {
    connection.disconnect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Disconnected,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}","/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#disconnect()} operation issuccessful.
 */
@Test public void checkNotificationsForSuccessfulDisconnect(){
  fakeConnection.failOperation=false;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified(2));
  notificationLock.lock();
  try {
    assertEquals(6,notificationQueue.size());
    notificationQueue.clear();
  }
  finally {
    notificationLock.unlock();
  }
  fakeListener1.wasNotified.set(false);
  try {
    connection.disconnect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Disconnected,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}",0.8882917466410749
133605,"/** 
 * (non-Javadoc)
 * @see IEntryContentProvider#equals(IEntryContentProvider otherProvider)
 */
@Override public boolean equals(IEntryContentProvider otherProvider){
  boolean retVal=false;
  if (otherProvider != null) {
    if (this == otherProvider) {
      retVal=true;
    }
 else {
      retVal=super.equals((ICEObject)otherProvider) && (this.defaultValue.equals(otherProvider.getDefaultValue())) && (this.allowedValues.equals(otherProvider.getAllowedValues()))&& (this.parent.equals(otherProvider.getParent()))&& (this.allowedValueType.equals(otherProvider.getAllowedValueType()));
      if (this.tag != null) {
        retVal=retVal && (this.tag.equals(otherProvider.getTag()));
      }
 else {
        if (otherProvider.getTag() != null) {
          return false;
        }
      }
    }
  }
  return retVal;
}","/** 
 * (non-Javadoc)
 * @see IEntryContentProvider#equals(IEntryContentProvider otherProvider)
 */
@Override public boolean equals(Object otherProvider){
  boolean retVal=false;
  if (otherProvider != null && otherProvider instanceof IEntryContentProvider) {
    IEntryContentProvider provider=(IEntryContentProvider)otherProvider;
    if (this == otherProvider) {
      retVal=true;
    }
 else {
      retVal=super.equals((ICEObject)provider) && (this.defaultValue.equals(provider.getDefaultValue())) && (this.allowedValues.equals(provider.getAllowedValues()))&& (this.parent.equals(provider.getParent()))&& (this.allowedValueType.equals(provider.getAllowedValueType()));
      if (this.tag != null) {
        retVal=retVal && (this.tag.equals(provider.getTag()));
      }
 else {
        if (provider.getTag() != null) {
          return false;
        }
      }
    }
  }
  return retVal;
}",0.8316831683168316
133606,"/** 
 * <p> Returns true if equal. False otherwise. </p>
 * @param otherProvider <p> The other provider to compare against. </p>
 * @return True if equivalent, false otherwise.
 */
public boolean equals(IEntryContentProvider otherProvider);","/** 
 * <p> Returns true if equal. False otherwise. </p>
 * @param otherProvider <p> The other provider to compare against. </p>
 * @return True if equivalent, false otherwise.
 */
public boolean equals(Object otherProvider);",0.9419354838709676
133607,"/** 
 * <p> This operation is used to check equality between the MatrixComponent and another MatrixComponent. It returns true if the MatrixComponents are equal and false if they are not. </p>
 * @param otherMatrixComponent <p> The TableComponent that should be checked for equality. </p>
 * @return <p>True if the TableComponents are equal, false if not </p>
 */
public boolean equals(MatrixComponent otherMatrixComponent){
  boolean retVal=true;
  if (this == otherMatrixComponent) {
    return true;
  }
  if (otherMatrixComponent == null || !(otherMatrixComponent instanceof MatrixComponent)) {
    return false;
  }
  if (!super.equals(otherMatrixComponent)) {
    return false;
  }
  MatrixComponent castedComponent=(MatrixComponent)otherMatrixComponent;
  retVal=(this.isSquare == castedComponent.isSquare) && (this.resizable == castedComponent.resizable) && (this.allowedValues.equals(castedComponent.allowedValues))&& (this.elements.equals(castedComponent.elements))&& (this.nCols == castedComponent.nCols)&& (this.nRows == castedComponent.nRows)&& (this.valueType == castedComponent.valueType);
  return retVal;
}","/** 
 * <p> This operation is used to check equality between the MatrixComponent and another MatrixComponent. It returns true if the MatrixComponents are equal and false if they are not. </p>
 * @param otherMatrixComponent <p> The TableComponent that should be checked for equality. </p>
 * @return <p>True if the TableComponents are equal, false if not </p>
 */
public boolean equals(Object otherMatrixComponent){
  boolean retVal=true;
  if (this == otherMatrixComponent) {
    return true;
  }
  if (otherMatrixComponent == null || !(otherMatrixComponent instanceof MatrixComponent)) {
    return false;
  }
  if (!super.equals(otherMatrixComponent)) {
    return false;
  }
  MatrixComponent castedComponent=(MatrixComponent)otherMatrixComponent;
  retVal=(this.isSquare == castedComponent.isSquare) && (this.resizable == castedComponent.resizable) && (this.allowedValues.equals(castedComponent.allowedValues))&& (this.elements.equals(castedComponent.elements))&& (this.nCols == castedComponent.nCols)&& (this.nRows == castedComponent.nRows)&& (this.valueType == castedComponent.valueType);
  return retVal;
}",0.9914988814317672
133608,"/** 
 * <p> This operation is used to check equality between the TableComponent and another TableComponent. It returns true if the TableComponents are equal and false if they are not. </p>
 * @param otherTableComponent <p> The TableComponent that should be checked for equality. </p>
 * @return <p>True if the TableComponents are equal, false if not </p>
 */
public boolean equals(TableComponent otherTableComponent){
  boolean retVal=true;
  if (this == otherTableComponent) {
    return true;
  }
  if (otherTableComponent == null || !(otherTableComponent instanceof TableComponent)) {
    return false;
  }
  if (!super.equals(otherTableComponent)) {
    return false;
  }
  TableComponent castedComponent=(TableComponent)otherTableComponent;
  retVal=(this.columnNames.equals(castedComponent.columnNames)) && (this.rowComponents.equals(castedComponent.rowComponents)) && (this.selectedRows.equals(castedComponent.selectedRows));
  return retVal;
}","/** 
 * <p> This operation is used to check equality between the TableComponent and another TableComponent. It returns true if the TableComponents are equal and false if they are not. </p>
 * @param otherTableComponent <p> The TableComponent that should be checked for equality. </p>
 * @return <p>True if the TableComponents are equal, false if not </p>
 */
public boolean equals(Object otherTableComponent){
  boolean retVal=true;
  if (this == otherTableComponent) {
    return true;
  }
  if (otherTableComponent == null || !(otherTableComponent instanceof TableComponent)) {
    return false;
  }
  if (!super.equals(otherTableComponent)) {
    return false;
  }
  TableComponent castedComponent=(TableComponent)otherTableComponent;
  retVal=(this.columnNames.equals(castedComponent.columnNames)) && (this.rowComponents.equals(castedComponent.rowComponents)) && (this.selectedRows.equals(castedComponent.selectedRows));
  return retVal;
}",0.9904963041182682
133609,"/** 
 * <p> This operation is used to check equality between the JobLauncher and another JobLauncher. It returns true if the Items are equal and false if they are not. </p>
 * @param otherLauncher <p> The JobLauncher that should be checked for equality. </p>
 * @return <p>True if the launchers are equal, false if not </p>
 */
public boolean equals(JobLauncher otherLauncher){
  boolean retVal;
  if (this == otherLauncher) {
    return true;
  }
  if (otherLauncher == null || !(otherLauncher instanceof Item) || !super.equals(otherLauncher)) {
    return false;
  }
  retVal=(this.allowedActions.equals(otherLauncher.allowedActions)) && (this.form.equals(otherLauncher.form)) && (this.itemType == otherLauncher.itemType)&& (this.status.equals(otherLauncher.status))&& (this.mpiEnabled == otherLauncher.mpiEnabled)&& (this.openMPEnabled == otherLauncher.openMPEnabled)&& (this.tbbEnabled == otherLauncher.tbbEnabled)&& (this.hostsTable.equals(otherLauncher.hostsTable))&& (this.hosts.equals(otherLauncher.hosts));
  if (remoteDownloadDir != null) {
    retVal&=(this.remoteDownloadDir.equals(otherLauncher.remoteDownloadDir));
  }
  if (this.project != null && otherLauncher.project != null && (!(this.project.equals(otherLauncher.project)))) {
    return false;
  }
  if (this.project == null && otherLauncher.project != null || this.project != null && otherLauncher.project == null) {
    return false;
  }
  if (this.executableCommandName != null && otherLauncher.executableCommandName != null && !(this.executableCommandName.equals(otherLauncher.executableCommandName))) {
    return false;
  }
  if (this.actionDataMap != null && otherLauncher.actionDataMap != null && (!(this.actionDataMap.equals(otherLauncher.actionDataMap)))) {
    return false;
  }
  return retVal;
}","/** 
 * <p> This operation is used to check equality between the JobLauncher and another JobLauncher. It returns true if the Items are equal and false if they are not. </p>
 * @param otherLauncher <p> The JobLauncher that should be checked for equality. </p>
 * @return <p>True if the launchers are equal, false if not </p>
 */
public boolean equals(Object otherLauncher){
  boolean retVal;
  if (this == otherLauncher) {
    return true;
  }
  if (otherLauncher == null || !(otherLauncher instanceof Item) || !super.equals(otherLauncher)) {
    return false;
  }
  JobLauncher launcher=(JobLauncher)otherLauncher;
  retVal=(this.allowedActions.equals(launcher.allowedActions)) && (this.form.equals(launcher.form)) && (this.itemType == launcher.itemType)&& (this.status.equals(launcher.status))&& (this.mpiEnabled == launcher.mpiEnabled)&& (this.openMPEnabled == launcher.openMPEnabled)&& (this.tbbEnabled == launcher.tbbEnabled)&& (this.hostsTable.equals(launcher.hostsTable))&& (this.hosts.equals(launcher.hosts));
  if (remoteDownloadDir != null) {
    retVal&=(this.remoteDownloadDir.equals(launcher.remoteDownloadDir));
  }
  if (this.project != null && launcher.project != null && (!(this.project.equals(launcher.project)))) {
    return false;
  }
  if (this.project == null && launcher.project != null || this.project != null && launcher.project == null) {
    return false;
  }
  if (this.executableCommandName != null && launcher.executableCommandName != null && !(this.executableCommandName.equals(launcher.executableCommandName))) {
    return false;
  }
  if (this.actionDataMap != null && launcher.actionDataMap != null && (!(this.actionDataMap.equals(launcher.actionDataMap)))) {
    return false;
  }
  return retVal;
}",0.9447922595332954
133610,"/** 
 * This operation overrides JobLauncher.equals() to check the additional pieces of this class.
 * @param otherLauncher The launcher to compare against.
 * @return True if equal, false otherwise.
 */
public boolean equals(SuiteLauncher otherLauncher){
  boolean retVal=super.equals(otherLauncher) && executablesList.equals(otherLauncher.executablesList);
  return retVal;
}","/** 
 * This operation overrides JobLauncher.equals() to check the additional pieces of this class.
 * @param otherLauncher The launcher to compare against.
 * @return True if equal, false otherwise.
 */
public boolean equals(Object otherLauncher){
  boolean retVal=super.equals(otherLauncher) && executablesList.equals(((SuiteLauncher)otherLauncher).executablesList);
  return retVal;
}",0.918848167539267
133611,"/** 
 * <p> This method indicates whether or not this KDDMatrix and the given KDDMatrix argument are equal. </p>
 * @param matrix
 * @return
 */
public boolean equals(KDDMatrix matrix){
  if (matrix.numberOfColumns() != nCols || matrix.numberOfRows() != nRows) {
    return false;
  }
  for (int i=0; i < nRows; i++) {
    for (int j=0; j < nCols; j++) {
      if (!matrix.getElement(i,j).equals(getElement(i,j))) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * <p> This method indicates whether or not this KDDMatrix and the given KDDMatrix argument are equal. </p>
 * @param matrix
 * @return true if the matrices are equal to each other, false otherwise.
 */
public boolean equals(Object matrix){
  boolean retVal=true;
  if (matrix != null && matrix instanceof KDDMatrix && matrix != this) {
    KDDMatrix otherMatrix=(KDDMatrix)matrix;
    if (otherMatrix.numberOfColumns() != nCols || otherMatrix.numberOfRows() != nRows) {
      retVal=false;
    }
    for (int i=0; i < nRows; i++) {
      for (int j=0; j < nCols; j++) {
        if (!otherMatrix.getElement(i,j).equals(getElement(i,j))) {
          retVal=false;
        }
      }
    }
  }
  return retVal;
}",0.7032040472175379
133612,"/** 
 * This operation checks to see if this PlotEntryContentProvider is equal to an input IEntryContentProvider.
 * @param otherProvider The IEntryContentProvider to check if this is equal to.
 */
@Override public boolean equals(IEntryContentProvider otherProvider){
  boolean equal=false;
  if (otherProvider != null && otherProvider instanceof PlotEntryContentProvider) {
    PlotEntryContentProvider other=(PlotEntryContentProvider)otherProvider;
    equal=(super.equals(otherProvider) && parent.equals(other.parent));
  }
  return equal;
}","/** 
 * This operation checks to see if this PlotEntryContentProvider is equal to an input IEntryContentProvider.
 * @param otherProvider The IEntryContentProvider to check if this is equal to.
 */
@Override public boolean equals(Object otherProvider){
  boolean equal=false;
  if (otherProvider != null && otherProvider instanceof PlotEntryContentProvider) {
    PlotEntryContentProvider other=(PlotEntryContentProvider)otherProvider;
    equal=(super.equals(otherProvider) && parent.equals(other.parent));
  }
  return equal;
}",0.9748369058713886
133613,"/** 
 * <p> This operation sets the input files that may be selected in the Form for the input type with the specified name. Passing null for the name or file list will not make any changes to the Form. </p>
 * @param name	Name of the input file type.
 * @param desc	Description of the file type.
 * @param files	List of files available for the job.
 */
public void setInputFiles(String name,String desc,ArrayList<String> files){
  int oldId=0;
  Entry oldEntry=null;
  DataComponent fileComponent=((DataComponent)getComponent(1));
  final ArrayList<String> finalFiles=(files != null) ? (ArrayList<String>)files.clone() : new ArrayList<String>();
  String oldValue=""String_Node_Str"";
  if (fileComponent.contains(name)) {
    oldEntry=fileComponent.retrieveEntry(name);
    oldId=oldEntry.getId();
    oldValue=oldEntry.getValue();
  }
  Entry fileEntry=new Entry(){
    @Override public void setup(){
      this.allowedValues=finalFiles;
      this.allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setDescription(desc);
  fileEntry.setName(name);
  fileEntry.setId((oldId > 0) ? oldId : fileComponent.retrieveAllEntries().size());
  if (fileEntry.getAllowedValues().contains(oldValue)) {
    fileEntry.setValue(oldValue);
  }
  if (oldEntry != null) {
    oldEntry.copy(fileEntry);
  }
 else {
    fileComponent.addEntry(fileEntry);
  }
  return;
}","/** 
 * <p> This operation sets the input files that may be selected in the Form for the input type with the specified name. Passing null for the name or file list will not make any changes to the Form. </p>
 * @param name	Name of the input file type.
 * @param desc	Description of the file type.
 * @param files	List of files available for the job.
 */
public void setInputFiles(String name,String desc,ArrayList<String> files){
  int oldId=0;
  Entry oldEntry=null;
  DataComponent fileComponent=((DataComponent)getComponent(1));
  final ArrayList<String> finalFiles=(files != null) ? (ArrayList<String>)files.clone() : new ArrayList<String>();
  String oldValue=""String_Node_Str"";
  if (fileComponent.contains(name)) {
    oldEntry=fileComponent.retrieveEntry(name);
    oldId=oldEntry.getId();
    oldValue=oldEntry.getValue();
  }
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      this.allowedValues=finalFiles;
      this.allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setDescription(desc);
  fileEntry.setName(name);
  fileEntry.setId((oldId > 0) ? oldId : fileComponent.retrieveAllEntries().size());
  if (fileEntry.getAllowedValues().contains(oldValue)) {
    fileEntry.setValue(oldValue);
  }
  if (oldEntry != null) {
    oldEntry.copy(fileEntry);
  }
 else {
    fileComponent.addEntry(fileEntry);
  }
  return;
}",0.9960130482058716
133614,"@Override protected void setupForm(){
  String line1=""String_Node_Str"";
  String line2=""String_Node_Str"";
  String line3=""String_Node_Str"";
  String line4=""String_Node_Str"";
  String line5=""String_Node_Str"";
  String allLines=line1 + line2 + line3+ line4+ line5;
  ByteArrayInputStream stream=new ByteArrayInputStream(allLines.getBytes());
  super.setupForm();
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(1);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  if (project != null) {
    String basename=""String_Node_Str"" + getId() + ""String_Node_Str"";
    IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
    IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
    try {
      if (reflectivityFile.exists()) {
        reflectivityFile.delete(true,null);
      }
      reflectivityFile.create(stream,true,null);
      if (scatteringFile.exists()) {
        scatteringFile.delete(true,null);
      }
      stream.reset();
      scatteringFile.create(stream,true,null);
      VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
      reflectivitySource.setName(""String_Node_Str"");
      reflectivitySource.setId(1);
      reflectivitySource.setDescription(""String_Node_Str"");
      VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
      scatDensitySource.setName(""String_Node_Str"");
      scatDensitySource.setId(2);
      scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
      ResourceComponent resources=new ResourceComponent();
      resources.setName(""String_Node_Str"");
      resources.setDescription(""String_Node_Str"");
      resources.setId(2);
      resources.addResource(reflectivitySource);
      resources.addResource(scatDensitySource);
      form.addComponent(resources);
    }
 catch (    CoreException|IOException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  allowedActions.add(0,processActionName);
  return;
}","@Override protected void setupForm(){
  String line1=""String_Node_Str"";
  String line2=""String_Node_Str"";
  String line3=""String_Node_Str"";
  String line4=""String_Node_Str"";
  String line5=""String_Node_Str"";
  String allLines=line1 + line2 + line3+ line4+ line5;
  ByteArrayInputStream stream=new ByteArrayInputStream(allLines.getBytes());
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(1);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(""String_Node_Str"");
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(2);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  if (project != null) {
    String basename=""String_Node_Str"" + getId() + ""String_Node_Str"";
    IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
    IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
    try {
      if (reflectivityFile.exists()) {
        reflectivityFile.delete(true,null);
      }
      reflectivityFile.create(stream,true,null);
      if (scatteringFile.exists()) {
        scatteringFile.delete(true,null);
      }
      stream.reset();
      scatteringFile.create(stream,true,null);
      VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
      reflectivitySource.setName(""String_Node_Str"");
      reflectivitySource.setId(1);
      reflectivitySource.setDescription(""String_Node_Str"");
      VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
      scatDensitySource.setName(""String_Node_Str"");
      scatDensitySource.setId(2);
      scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
      ResourceComponent resources=new ResourceComponent();
      resources.setName(""String_Node_Str"");
      resources.setDescription(""String_Node_Str"");
      resources.setId(2);
      resources.addResource(reflectivitySource);
      resources.addResource(scatDensitySource);
      form.addComponent(resources);
    }
 catch (    CoreException|IOException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  allowedActions.add(0,processActionName);
  return;
}",0.908761110103392
133615,"/** 
 * Attempts to establish the connection on a separate worker thread.
 * @return A future wrapping the connection's state when the connectionoperation completes. To wait for the connection to connect (or fail), use the future's  {@code get()} method.
 */
public Future<ConnectionState> connect(){
  return null;
}","/** 
 * Attempts to establish the connection on a separate worker thread.
 * @return A future wrapping the connection's state when the connectionoperation completes. To wait for the connection to connect (or fail), use the future's  {@code get()} method.
 */
public Future<ConnectionState> connect(){
  Future<ConnectionState> retVal;
  connectionLock.lock();
  try {
    if (state == ConnectionState.Connected) {
      retVal=createInstantFuture(state);
    }
 else     if (state == ConnectionState.Connecting) {
      retVal=hookIntoConnectThread();
    }
 else {
      retVal=startConnectThread();
    }
  }
  finally {
    connectionLock.unlock();
  }
  return retVal;
}",0.6195761856710393
133616,"/** 
 * The default constructor. Initializes the connection to the default values.
 */
public VizConnection(){
  widget=null;
  state=ConnectionState.Disconnected;
  statusMessage=""String_Node_Str"";
  properties=new HashMap<String,String>();
  propertyHandlers=new HashMap<String,IPropertyHandler>();
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue != null && !newValue.isEmpty() ? newValue : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      return value != null ? value.trim() : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue != null && !newValue.isEmpty() ? newValue : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      try {
        int port=Integer.parseInt(value);
        if (port >= MIN_PORT && port <= MAX_PORT) {
          newValue=Integer.toString(port);
        }
      }
 catch (      NumberFormatException e) {
      }
      return newValue;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      return value != null ? value.trim() : null;
    }
  }
);
  setName(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  setHost(""String_Node_Str"");
  setPort(50000);
  setPath(""String_Node_Str"");
  listeners=new HashSet<IVizConnectionListener<T>>();
  return;
}","/** 
 * The default constructor. Initializes the connection to the default values.
 */
public VizConnection(){
  widget=null;
  state=ConnectionState.Disconnected;
  statusMessage=""String_Node_Str"";
  properties=new HashMap<String,String>();
  propertyHandlers=new HashMap<String,IPropertyHandler>();
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue != null && !newValue.isEmpty() ? newValue : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      return value != null ? value.trim() : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      if (value != null) {
        newValue=value.trim();
      }
      return newValue != null && !newValue.isEmpty() ? newValue : null;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      String newValue=null;
      try {
        int port=Integer.parseInt(value);
        if (port >= MIN_PORT && port <= MAX_PORT) {
          newValue=Integer.toString(port);
        }
      }
 catch (      NumberFormatException e) {
      }
      return newValue;
    }
  }
);
  propertyHandlers.put(""String_Node_Str"",new IPropertyHandler(){
    @Override public String validateValue(    String value){
      return value != null ? value.trim() : null;
    }
  }
);
  setName(""String_Node_Str"");
  setDescription(""String_Node_Str"");
  setHost(""String_Node_Str"");
  setPort(50000);
  setPath(""String_Node_Str"");
  listeners=new HashSet<IVizConnectionListener<T>>();
  connectionLock=new ReentrantLock(true);
  return;
}",0.9890965732087228
133617,"/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#connect()} operation<i>fails</i>.
 */
@Test public void checkNotificationsForFailedConnect(){
  int size;
  fakeConnection.failOperation=true;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Connecting,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    size=notificationQueue.size();
  }
  finally {
    notificationLock.unlock();
  }
  if (size != 0) {
    assertTrue(fakeListener1.wasNotified());
  }
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Failed,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}","/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#connect()} operation<i>fails</i>.
 */
@Test public void checkNotificationsForFailedConnect(){
  int size;
  fakeConnection.failOperation=true;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Connecting,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    size=notificationQueue.size();
  }
  finally {
    notificationLock.unlock();
  }
  if (size == 0) {
    assertTrue(fakeListener1.wasNotified());
  }
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Failed,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}",0.9991568296795952
133618,"/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#connect()} operation issuccessful.
 */
@Test public void checkNotificationsForSuccessfulConnect(){
  int size;
  fakeConnection.failOperation=false;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Connecting,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    size=notificationQueue.size();
  }
  finally {
    notificationLock.unlock();
  }
  if (size != 0) {
    assertTrue(fakeListener1.wasNotified());
  }
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Connected,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}","/** 
 * Checks that the proper sequence of notifications are posted to registered listeners when the   {@link VizConnection#connect()} operation issuccessful.
 */
@Test public void checkNotificationsForSuccessfulConnect(){
  int size;
  fakeConnection.failOperation=false;
  try {
    connection.connect().get();
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertTrue(fakeListener1.wasNotified());
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Connecting,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    size=notificationQueue.size();
  }
  finally {
    notificationLock.unlock();
  }
  if (size == 0) {
    assertTrue(fakeListener1.wasNotified());
  }
  notificationLock.lock();
  try {
    assertSame(connection,notificationQueue.poll());
    assertEquals(ConnectionState.Connected,notificationQueue.poll());
    assertEquals(""String_Node_Str"",notificationQueue.poll());
    assertTrue(notificationQueue.isEmpty());
  }
  finally {
    notificationLock.unlock();
  }
  return;
}",0.999163179916318
133619,"@Override public void setupFormWithServices(){
  IMaterialsDatabase database=getMaterialsDatabase();
  if (database != null) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(1);
    matList.setElementSource(database);
  }
  return;
}","@Override public void setupFormWithServices(){
  IMaterialsDatabase database=getMaterialsDatabase();
  if (database != null) {
    ListComponent<Material> matList=(ListComponent<Material>)form.getComponent(matListId);
    matList.setElementSource(database);
  }
  return;
}",0.9814126394052044
133620,"@Override protected void setup(){
  allowedValueType=AllowedValueType.File;
  return;
}","@Override protected void setup(){
  allowedValueType=AllowedValueType.Continuous;
  allowedValues.add(""String_Node_Str"");
  allowedValues.add(""String_Node_Str"");
  return;
}",0.6615384615384615
133621,"@Override protected void setupForm(){
  String line1=""String_Node_Str"";
  String line2=""String_Node_Str"";
  String line3=""String_Node_Str"";
  String line4=""String_Node_Str"";
  String line5=""String_Node_Str"";
  String allLines=line1 + line2 + line3+ line4+ line5;
  ByteArrayInputStream stream=new ByteArrayInputStream(allLines.getBytes());
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(1);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(""String_Node_Str"");
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(2);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  if (project != null) {
    String basename=""String_Node_Str"" + getId() + ""String_Node_Str"";
    IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
    IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
    try {
      if (reflectivityFile.exists()) {
        reflectivityFile.delete(true,null);
      }
      reflectivityFile.create(stream,true,null);
      if (scatteringFile.exists()) {
        scatteringFile.delete(true,null);
      }
      stream.reset();
      scatteringFile.create(stream,true,null);
      VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
      reflectivitySource.setName(""String_Node_Str"");
      reflectivitySource.setId(1);
      reflectivitySource.setDescription(""String_Node_Str"");
      VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
      scatDensitySource.setName(""String_Node_Str"");
      scatDensitySource.setId(2);
      scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
      ResourceComponent resources=new ResourceComponent();
      resources.setName(""String_Node_Str"");
      resources.setDescription(""String_Node_Str"");
      resources.setId(2);
      resources.addResource(reflectivitySource);
      resources.addResource(scatDensitySource);
      form.addComponent(resources);
    }
 catch (    CoreException|IOException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  allowedActions.add(0,processActionName);
  return;
}","@Override protected void setupForm(){
  String line1=""String_Node_Str"";
  String line2=""String_Node_Str"";
  String line3=""String_Node_Str"";
  String line4=""String_Node_Str"";
  String line5=""String_Node_Str"";
  String allLines=line1 + line2 + line3+ line4+ line5;
  ByteArrayInputStream stream=new ByteArrayInputStream(allLines.getBytes());
  super.setupForm();
  DataComponent paramComponent=new DataComponent();
  paramComponent.setDescription(""String_Node_Str"");
  paramComponent.setName(""String_Node_Str"");
  paramComponent.setId(paramsCompId);
  form.addComponent(paramComponent);
  Entry fileEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.File;
      return;
    }
  }
;
  fileEntry.setId(1);
  fileEntry.setName(""String_Node_Str"");
  fileEntry.setDescription(""String_Node_Str"");
  paramComponent.addEntry(fileEntry);
  Entry numLayersEntry=new Entry(){
    @Override protected void setup(){
      allowedValueType=AllowedValueType.Continuous;
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return;
    }
  }
;
  numLayersEntry.setId(2);
  numLayersEntry.setName(""String_Node_Str"");
  numLayersEntry.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  paramComponent.addEntry(numLayersEntry);
  ArrayList<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(Material.SCAT_LENGTH_DENSITY);
  names.add(Material.MASS_ABS_COHERENT);
  names.add(Material.MASS_ABS_INCOHERENT);
  MaterialWritableTableFormat format=new MaterialWritableTableFormat(names);
  ListComponent<Material> matList=new ListComponent<Material>();
  matList.setId(matListId);
  matList.setName(""String_Node_Str"");
  matList.setDescription(""String_Node_Str"");
  matList.setTableFormat(format);
  fillMaterialList(matList);
  form.addComponent(matList);
  if (project != null) {
    String basename=""String_Node_Str"" + getId() + ""String_Node_Str"";
    IFile reflectivityFile=project.getFile(basename + ""String_Node_Str"");
    IFile scatteringFile=project.getFile(basename + ""String_Node_Str"");
    try {
      if (reflectivityFile.exists()) {
        reflectivityFile.delete(true,null);
      }
      reflectivityFile.create(stream,true,null);
      if (scatteringFile.exists()) {
        scatteringFile.delete(true,null);
      }
      stream.reset();
      scatteringFile.create(stream,true,null);
      VizResource reflectivitySource=new VizResource(reflectivityFile.getLocation().toFile());
      reflectivitySource.setName(""String_Node_Str"");
      reflectivitySource.setId(1);
      reflectivitySource.setDescription(""String_Node_Str"");
      VizResource scatDensitySource=new VizResource(scatteringFile.getLocation().toFile());
      scatDensitySource.setName(""String_Node_Str"");
      scatDensitySource.setId(2);
      scatDensitySource.setDescription(""String_Node_Str"" + ""String_Node_Str"");
      ResourceComponent resources=new ResourceComponent();
      resources.setName(""String_Node_Str"");
      resources.setDescription(""String_Node_Str"");
      resources.setId(2);
      resources.addResource(reflectivitySource);
      resources.addResource(scatDensitySource);
      form.addComponent(resources);
    }
 catch (    CoreException|IOException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  allowedActions.add(0,processActionName);
  return;
}",0.9310027598896043
133622,"/** 
 * Test method for  {@link org.eclipse.ice.item.AbstractItemBuilder#build(org.eclipse.core.resources.IProject)}.
 */
@Test public void testBuild(){
  int listID=1;
  ListComponent<Material> list;
  ReflectivityModelBuilder builder=new ReflectivityModelBuilder();
  builder.setMaterialsDatabase(this);
  ReflectivityModel model=(ReflectivityModel)builder.build(null);
  assertNotNull(model.getForm());
  assertEquals(1,model.getForm().getComponents().size());
  list=(ListComponent<Material>)model.getForm().getComponent(listID);
  assertNotNull(list);
  assertEquals(""String_Node_Str"",list.getName());
  assertNotNull(list.getElementSource());
  assertEquals(list.getElementSource(),this);
}","/** 
 * Test method for  {@link org.eclipse.ice.item.AbstractItemBuilder#build(org.eclipse.core.resources.IProject)}.
 */
@Test public void testBuild(){
  ListComponent<Material> list;
  ReflectivityModelBuilder builder=new ReflectivityModelBuilder();
  builder.setMaterialsDatabase(this);
  ReflectivityModel model=(ReflectivityModel)builder.build(null);
  assertNotNull(model.getForm());
  assertEquals(2,model.getForm().getComponents().size());
  list=(ListComponent<Material>)model.getForm().getComponent(ReflectivityModel.matListId);
  assertNotNull(list);
  assertEquals(""String_Node_Str"",list.getName());
  assertNotNull(list.getElementSource());
  assertEquals(list.getElementSource(),this);
}",0.9692197566213314
133623,"/** 
 * This operation checks the ReflectivityModel and makes sure that it can properly construct its Form.
 */
@Test public void checkConstruction(){
  int listID=1;
  ListComponent<Material> list;
  ReflectivityModel model=new ReflectivityModel();
  model.setMaterialsDatabase(this);
  model.setupFormWithServices();
  assertNotNull(model.getForm());
  assertEquals(1,model.getForm().getComponents().size());
  list=(ListComponent<Material>)model.getForm().getComponent(listID);
  assertNotNull(list);
  assertEquals(""String_Node_Str"",list.getName());
  assertNotNull(list.getElementSource());
  assertEquals(list.getElementSource(),this);
  return;
}","/** 
 * This operation checks the ReflectivityModel and makes sure that it can properly construct its Form.
 */
@Test public void checkConstruction(){
  ListComponent<Material> list;
  ReflectivityModel model=new ReflectivityModel();
  model.setMaterialsDatabase(this);
  model.setupFormWithServices();
  assertNotNull(model.getForm());
  assertEquals(2,model.getForm().getComponents().size());
  list=(ListComponent<Material>)model.getForm().getComponent(ReflectivityModel.matListId);
  assertNotNull(list);
  assertEquals(""String_Node_Str"",list.getName());
  assertNotNull(list.getElementSource());
  assertEquals(list.getElementSource(),this);
  return;
}",0.9672006102212052
133624,"/** 
 * Compares two material stacks to tell if they are equal to one another.
 * @param stack The stack to compare this one with
 * @return Returns true if the stacks are equal (same material, same amount)and false if otherwise.
 */
public boolean equals(MaterialStack stack){
  boolean val=(number == stack.getAmount()) && material.equals(stack.getMaterial());
  System.out.println(number == stack.getAmount());
  return val;
}","/** 
 * Compares two material stacks to tell if they are equal to one another.
 * @param stack The stack to compare this one with
 * @return Returns true if the stacks are equal (same material, same amount)and false if otherwise.
 */
@Override public boolean equals(Object toCompare){
  boolean isEqual=false;
  if (toCompare instanceof MaterialStack) {
    if (this == toCompare) {
      isEqual=true;
    }
 else {
      MaterialStack stack=(MaterialStack)toCompare;
      isEqual=(number == stack.getAmount()) && material.equals(stack.getMaterial());
    }
  }
  return isEqual;
}",0.6956521739130435
133625,"/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#getAmount()}.
 */
public void testGetAmount(){
  fail(""String_Node_Str"");
}","/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#getAmount()}.
 */
@Test public void testGetAmount(){
  int amount=3;
  MaterialStack stack=new MaterialStack(TestMaterialFactory.createH2O(),amount);
  int testAmount=stack.getAmount();
  assertTrue(amount == testAmount);
}",0.5991379310344828
133626,"/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#incrementAmount()}.
 */
public void testIncrementAmount(){
  fail(""String_Node_Str"");
}","/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#incrementAmount()}.
 */
@Test public void testIncrementAmount(){
  int startAmount=2;
  MaterialStack stack=new MaterialStack(TestMaterialFactory.createH2O(),startAmount);
  stack.incrementAmount();
  assertEquals(startAmount + 1,stack.getAmount());
  startAmount++;
  int add=5;
  stack.addAmount(add);
  assertEquals(startAmount + add,stack.getAmount());
}",0.4942716857610474
133627,"/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#getMaterial()}.
 */
public void testGetMaterial(){
  fail(""String_Node_Str"");
}","/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#getMaterial()}.
 */
@Test public void testGetMaterial(){
  Material C02=TestMaterialFactory.createCO2();
  MaterialStack stack=new MaterialStack(C02,3);
  Material testMat=stack.getMaterial();
  assertTrue(C02.equals(testMat));
}",0.6075949367088608
133628,"/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#MaterialStack()}.
 */
public void testConstruction(){
  fail(""String_Node_Str"");
}","/** 
 * Test method for   {@link org.eclipse.ice.datastructures.form.MaterialStack#MaterialStack()}.
 */
@Test public void testConstruction(){
  Material matTest1=new Material();
  matTest1.setName(""String_Node_Str"");
  MaterialStack stack1=new MaterialStack(matTest1,3);
  assertNotNull(matTest1);
  MaterialStack stack2=new MaterialStack();
  stack2.setMaterial(matTest1);
  stack2.setAmount(3);
  assertTrue(stack1.equals(stack2));
}",0.5357737104825291
133629,"@Override protected void createMasterPart(IManagedForm managedForm,Composite parent){
  mForm=managedForm;
  FormToolkit toolkit=mForm.getToolkit();
  Section section=toolkit.createSection(parent,Section.TITLE_BAR | Section.DESCRIPTION | Section.EXPANDED);
  GridData gridData=new GridData(GridData.FILL_BOTH);
  section.setLayoutData(gridData);
  section.setLayout(new GridLayout(1,true));
  section.setText(""String_Node_Str"");
  section.setDescription(""String_Node_Str"");
  Composite sectionClient=toolkit.createComposite(section);
  GridLayout layout=new GridLayout();
  layout.numColumns=2;
  layout.marginWidth=2;
  layout.marginHeight=2;
  sectionClient.setLayout(layout);
  sectionClient.setLayoutData(new GridData(GridData.FILL_BOTH));
  section.setClient(sectionClient);
  final SectionPart sectionPart=new SectionPart(section);
  mForm.addPart(sectionPart);
  TreeViewer treeViewer=new TreeViewer(sectionClient);
  treeViewer.setContentProvider(new MaterialsDatabaseContentProvider());
  treeViewer.setLabelProvider(new MaterialsDatabaseLabelProvider());
  List<Material> materials=materialsDatabase.getMaterials();
  treeViewer.setInput(materialsDatabase.getMaterials());
  treeViewer.getTree().setLayout(new GridLayout(1,true));
  GridData data=new GridData(SWT.FILL,SWT.FILL,true,true,1,1);
  data.widthHint=sectionClient.getClientArea().width;
  data.heightHint=sectionClient.getClientArea().height;
  treeViewer.getTree().setLayoutData(data);
  treeViewer.addSelectionChangedListener(new ISelectionChangedListener(){
    @Override public void selectionChanged(    SelectionChangedEvent event){
      mForm.fireSelectionChanged(sectionPart,event.getSelection());
    }
  }
);
  Composite buttonComposite=new Composite(sectionClient,SWT.NONE);
  buttonComposite.setLayout(new GridLayout(1,false));
  buttonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.FILL,false,true,1,1));
  Button addMaterialButton=new Button(buttonComposite,SWT.PUSH);
  addMaterialButton.setText(""String_Node_Str"");
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  AddMaterialWizard addMaterialWizard=new AddMaterialWizard(window);
  addMaterialWizard.setWindowTitle(""String_Node_Str"");
  final WizardDialog addMaterialDialog=new WizardDialog(window.getShell(),addMaterialWizard);
  addMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      addMaterialDialog.create();
      addMaterialDialog.open();
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      addMaterialDialog.create();
      addMaterialDialog.open();
    }
  }
);
  Button deleteMaterialButton=new Button(buttonComposite,SWT.PUSH);
  deleteMaterialButton.setText(""String_Node_Str"");
  String title=""String_Node_Str"";
  String msg=""String_Node_Str"";
  String[] labels={""String_Node_Str"",""String_Node_Str""};
  final MessageDialog deletionDialog=new MessageDialog(parent.getShell(),title,null,msg,MessageDialog.WARNING,labels,0);
  SelectionListener deletionListener=new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      int index=deletionDialog.open();
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      int index=deletionDialog.open();
    }
  }
;
  deleteMaterialButton.addSelectionListener(deletionListener);
  Button restoreMaterialButton=new Button(buttonComposite,SWT.PUSH);
  restoreMaterialButton.setText(""String_Node_Str"");
  restoreMaterialButton.setToolTipText(""String_Node_Str"" + ""String_Node_Str"");
  title=""String_Node_Str"";
  msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  final MessageDialog restoreDialog=new MessageDialog(parent.getShell(),title,null,msg,MessageDialog.WARNING,labels,0);
  SelectionListener restoreListener=new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      int index=restoreDialog.open();
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      int index=restoreDialog.open();
    }
  }
;
  restoreMaterialButton.addSelectionListener(restoreListener);
  return;
}","@Override protected void createMasterPart(IManagedForm managedForm,Composite parent){
  mForm=managedForm;
  FormToolkit toolkit=mForm.getToolkit();
  Section section=toolkit.createSection(parent,Section.TITLE_BAR | Section.DESCRIPTION | Section.EXPANDED);
  GridData gridData=new GridData(GridData.FILL_BOTH);
  section.setLayoutData(gridData);
  section.setLayout(new GridLayout(1,true));
  section.setText(""String_Node_Str"");
  section.setDescription(""String_Node_Str"");
  Composite sectionClient=toolkit.createComposite(section);
  GridLayout layout=new GridLayout();
  layout.numColumns=2;
  layout.marginWidth=2;
  layout.marginHeight=2;
  sectionClient.setLayout(layout);
  sectionClient.setLayoutData(new GridData(GridData.FILL_BOTH));
  section.setClient(sectionClient);
  final SectionPart sectionPart=new SectionPart(section);
  mForm.addPart(sectionPart);
  Composite treeComp=new Composite(sectionClient,SWT.NONE);
  treeComp.setLayout(new GridLayout(1,false));
  treeComp.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  final Text filter=new Text(treeComp,SWT.BORDER | SWT.SEARCH);
  filter.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  treeViewer=new TreeViewer(treeComp);
  treeViewer.setContentProvider(new MaterialsDatabaseContentProvider());
  treeViewer.setLabelProvider(new MaterialsDatabaseLabelProvider());
  materials=materialsDatabase.getMaterials();
  Collections.sort(materials,new Comparator<Material>(){
    public int compare(    Material first,    Material second){
      return (first.getName().compareTo(second.getName()));
    }
  }
);
  List<Material> editableCopy=new ArrayList<Material>();
  for (int i=0; i < materials.size(); i++) {
    editableCopy.add(materials.get(i));
  }
  treeViewer.setInput(editableCopy);
  filter.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent arg0){
      List<Material> listFromTree=(List<Material>)treeViewer.getInput();
      String filterText=filter.getText().toLowerCase();
      int numRemoved=0;
      for (int i=0; i < materials.size(); i++) {
        Material mat=materials.get(i);
        if (mat.getName().toLowerCase().startsWith(filterText)) {
          if (!listFromTree.contains(mat)) {
            listFromTree.add(i - numRemoved,mat);
          }
        }
 else {
          if (listFromTree.contains(mat)) {
            listFromTree.remove(mat);
          }
          numRemoved++;
        }
      }
      treeViewer.refresh();
    }
  }
);
  treeViewer.getTree().setLayout(new GridLayout(1,true));
  GridData data=new GridData(SWT.FILL,SWT.FILL,true,true,1,1);
  data.widthHint=sectionClient.getClientArea().width;
  data.heightHint=sectionClient.getClientArea().height;
  treeViewer.getTree().setLayoutData(data);
  treeViewer.addSelectionChangedListener(new ISelectionChangedListener(){
    @Override public void selectionChanged(    SelectionChangedEvent event){
      mForm.fireSelectionChanged(sectionPart,event.getSelection());
    }
  }
);
  Composite buttonComposite=new Composite(sectionClient,SWT.NONE);
  buttonComposite.setLayout(new GridLayout(1,false));
  buttonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.FILL,false,true,1,1));
  Button addMaterialButton=new Button(buttonComposite,SWT.PUSH);
  addMaterialButton.setText(""String_Node_Str"");
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  AddMaterialWizard addMaterialWizard=new AddMaterialWizard(window);
  addMaterialWizard.setWindowTitle(""String_Node_Str"");
  final WizardDialog addMaterialDialog=new WizardDialog(window.getShell(),addMaterialWizard);
  addMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      addMaterialDialog.create();
      addMaterialDialog.open();
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      addMaterialDialog.create();
      addMaterialDialog.open();
    }
  }
);
  Button deleteMaterialButton=new Button(buttonComposite,SWT.PUSH);
  deleteMaterialButton.setText(""String_Node_Str"");
  String title=""String_Node_Str"";
  String msg=""String_Node_Str"";
  String[] labels={""String_Node_Str"",""String_Node_Str""};
  final MessageDialog deletionDialog=new MessageDialog(parent.getShell(),title,null,msg,MessageDialog.WARNING,labels,0);
  SelectionListener deletionListener=new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      int index=deletionDialog.open();
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      int index=deletionDialog.open();
    }
  }
;
  deleteMaterialButton.addSelectionListener(deletionListener);
  Button restoreMaterialButton=new Button(buttonComposite,SWT.PUSH);
  restoreMaterialButton.setText(""String_Node_Str"");
  restoreMaterialButton.setToolTipText(""String_Node_Str"" + ""String_Node_Str"");
  title=""String_Node_Str"";
  msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  final MessageDialog restoreDialog=new MessageDialog(parent.getShell(),title,null,msg,MessageDialog.WARNING,labels,0);
  SelectionListener restoreListener=new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      int index=restoreDialog.open();
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
      int index=restoreDialog.open();
    }
  }
;
  restoreMaterialButton.addSelectionListener(restoreListener);
  return;
}",0.8123771085584187
133630,"@Override public Material setColumnValue(Material baseObject,Object editedValue,int column){
  if (column != 0) {
    baseObject.setProperty(properties.get(column),Double.valueOf(editedValue.toString()));
  }
  return baseObject;
}","@Override public Material setColumnValue(Material baseObject,Object editedValue,int column){
  if (column != 0) {
    try {
      baseObject.setProperty(properties.get(column),Double.valueOf(editedValue.toString()));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return baseObject;
}",0.8555555555555555
133631,"@Override public void update(IUpdateable updateable){
  if (updateable instanceof ResourceComponent) {
    ResourceComponent comp=(ResourceComponent)updateable;
    ResourceComponent ourComp=(ResourceComponent)form.getComponent(3);
    ArrayList<String> names=new ArrayList<String>();
    for (    ICEResource r : ourComp.getResources()) {
      names.add(r.getName());
    }
    for (    ICEResource r : comp.getResources()) {
      if (!names.contains(r.getName())) {
        System.out.println(""String_Node_Str"" + r.getName());
        ourComp.add(r);
      }
    }
  }
 else   if (updateable instanceof TreeComposite) {
    TreeComposite tree=(TreeComposite)updateable;
    if (tree.getName().equals(""String_Node_Str"") || (tree.getParent() != null && tree.getParent().getName().equals(""String_Node_Str""))) {
      System.out.println(""String_Node_Str"" + tree.getName() + ""String_Node_Str"");
      if (tree.getName().equals(""String_Node_Str"") && tree.getNumberOfChildren() < variables.size()) {
        variables.clear();
      }
      for (int i=0; i < tree.getNumberOfChildren(); i++) {
        TreeComposite variable=tree.getChildAtIndex(i);
        if (!variables.contains(variable)) {
          variables.add(variable);
          variable.register(this);
        }
      }
      updateAllVariableEntries();
    }
 else {
      BreadthFirstTreeCompositeIterator iter=new BreadthFirstTreeCompositeIterator(tree);
      while (iter.hasNext()) {
        updateBlockVariableEntries(iter.next());
      }
    }
  }
}","@Override public boolean update(Message message){
  super.update(message);
  String type=message.getType();
  String text=message.getMessage();
  if (""String_Node_Str"".equals(type)) {
  }
 else   if (""String_Node_Str"".equals(type)) {
  }
  return true;
}",0.0463015245623941
133632,"public void run(){
  while (!status.equals(FormStatus.Processed)) {
    Thread.currentThread();
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    status=mooseLauncher.getStatus();
  }
  return;
}","@Override public void run(){
  new MOOSEFileHandler().setupVariables(modelTree);
  new MOOSEFileHandler().setupAuxVariables(modelTree);
}",0.271356783919598
133633,"/** 
 * The constructor.
 * @param projectSpace
 */
public MOOSE(IProject projectSpace){
  super(projectSpace);
  mooseModel=new MOOSEModel(projectSpace);
  mooseLauncher=new MOOSELauncher(projectSpace);
  for (  Component c : mooseModel.getForm().getComponents()) {
    if (c.getName().equals(""String_Node_Str"")) {
      c.setName(""String_Node_Str"");
    }
    form.addComponent(c);
  }
  modelFiles=(DataComponent)form.getComponent(1);
  form.addComponent(mooseLauncher.getForm().getComponent(3));
  modelTree=(TreeComposite)form.getComponent(2);
  variables=new ArrayList<TreeComposite>();
}","/** 
 * The constructor.
 * @param projectSpace
 */
public MOOSE(IProject projectSpace){
  super(projectSpace);
  mooseModel=new MOOSEModel(projectSpace);
  mooseLauncher=new MOOSELauncher(projectSpace);
  for (  Component c : mooseModel.getForm().getComponents()) {
    if (c.getName().equals(""String_Node_Str"")) {
      c.setName(""String_Node_Str"");
    }
    form.addComponent(c);
  }
  modelFiles=(DataComponent)form.getComponent(1);
  form.addComponent(mooseLauncher.getForm().getComponent(3));
  modelTree=(TreeComposite)form.getComponent(2);
}",0.9615384615384616
133634,"/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#loadInput(java.lang.String)
 */
@Override public void loadInput(String input){
  mooseModel.loadInput(input);
  form=new Form();
  String description=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  form.setName(""String_Node_Str"");
  form.setDescription(description);
  form.setItemID(getId());
  form.setActionList(allowedActions);
  for (  Component c : mooseModel.getForm().getComponents()) {
    form.addComponent(c);
  }
  modelFiles=(DataComponent)form.getComponent(1);
  for (  Component c : mooseLauncher.getForm().getComponents()) {
    if (""String_Node_Str"".equals(c.getName()) || ""String_Node_Str"".equals(c.getName())) {
      form.addComponent(c);
    }
  }
  modelTree=(TreeComposite)form.getComponent(2);
  loadFileEntries();
  TreeComposite variablesTree=getTreeByName(""String_Node_Str"");
  update(variablesTree);
  variablesTree.register(this);
  modelTree.register(this);
  registered=true;
  return;
}","/** 
 * (non-Javadoc)
 * @see org.eclipse.ice.item.Item#loadInput(java.lang.String)
 */
@Override public void loadInput(String input){
  mooseModel.loadInput(input);
  form=new Form();
  String description=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  form.setName(""String_Node_Str"");
  form.setDescription(description);
  form.setItemID(getId());
  form.setActionList(allowedActions);
  for (  Component c : mooseModel.getForm().getComponents()) {
    form.addComponent(c);
  }
  modelFiles=(DataComponent)form.getComponent(1);
  for (  Component c : mooseLauncher.getForm().getComponents()) {
    if (""String_Node_Str"".equals(c.getName()) || ""String_Node_Str"".equals(c.getName())) {
      form.addComponent(c);
    }
  }
  modelTree=(TreeComposite)form.getComponent(2);
  loadFileEntries();
  getTreeByName(""String_Node_Str"").register(this);
  getTreeByName(""String_Node_Str"").register(this);
  modelTree.register(this);
  registered=true;
  return;
}",0.9176470588235294
133635,"/** 
 * Finds the properties in the file by querying the associated ParaView connection. <p> The connection should be both valid and connected when this method is called, and the file will already be opened using the ParaView connection. </p>
 * @param connection The connection used by this proxy.
 * @return A map of properties that can be rendered, keyed on their names.If none can be found, then the returned list should be empty and <i>not</i>  {@code null}.
 */
protected List<IProxyProperty> findProperties(ParaViewConnectionAdapter connection){
  List<IProxyProperty> properties=new ArrayList<IProxyProperty>();
  return properties;
}","/** 
 * Finds the properties in the file by querying the associated ParaView connection. <p> The connection should be both valid and connected when this method is called, and the file will already be opened using the ParaView connection. </p>
 * @param connection The connection used by this proxy.
 * @return A map of properties that can be rendered, keyed on their names.If none can be found, then the returned list should be empty and <i>not</i>  {@code null}.
 */
protected List<IProxyProperty> findProperties(ParaViewConnectionAdapter connection){
  List<IProxyProperty> properties=new ArrayList<IProxyProperty>();
  properties.add(new AbstractProxyProperty(""String_Node_Str"",this,connection){
    @Override protected String findValue(    ParaViewConnectionAdapter connection){
      return ""String_Node_Str"";
    }
    @Override protected Set<String> findAllowedValues(    ParaViewConnectionAdapter connection){
      Set<String> allowedValues=new HashSet<String>();
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return allowedValues;
    }
    @Override protected boolean setValueOnClient(    String value,    ParaViewConnectionAdapter connection){
      VtkWebClient client=connection.getConnection();
      boolean updated=false;
      JsonArray args=new JsonArray();
      args.add(new JsonPrimitive(value));
      try {
        JsonObject response=client.call(""String_Node_Str"",args).get();
        System.out.println(response.toString());
        updated=true;
      }
 catch (      InterruptedException|ExecutionException e) {
        e.printStackTrace();
      }
      return updated;
    }
  }
);
  properties.add(new AbstractProxyProperty(""String_Node_Str"",this,connection){
    @Override protected String findValue(    ParaViewConnectionAdapter connection){
      return ""String_Node_Str"";
    }
    @Override protected Set<String> findAllowedValues(    ParaViewConnectionAdapter connection){
      Set<String> allowedValues=new HashSet<String>();
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      allowedValues.add(""String_Node_Str"");
      return allowedValues;
    }
    @Override protected boolean setValueOnClient(    String value,    ParaViewConnectionAdapter connection){
      VtkWebClient client=connection.getConnection();
      boolean updated=false;
      JsonArray args=new JsonArray();
      JsonArray updatedProperties=new JsonArray();
      JsonObject repProperty=new JsonObject();
      repProperty.addProperty(""String_Node_Str"",Integer.toString(getRepresentationId()));
      repProperty.addProperty(""String_Node_Str"",""String_Node_Str"");
      repProperty.addProperty(""String_Node_Str"",value);
      updatedProperties.add(repProperty);
      args=new JsonArray();
      args.add(updatedProperties);
      JsonObject response;
      try {
        response=client.call(""String_Node_Str"",args).get();
        if (!response.get(""String_Node_Str"").getAsBoolean()) {
          System.out.println(""String_Node_Str"");
          JsonArray array=response.get(""String_Node_Str"").getAsJsonArray();
          for (int i=0; i < array.size(); i++) {
            System.out.println(array.get(i));
          }
        }
        updated=true;
      }
 catch (      InterruptedException|ExecutionException e) {
        e.printStackTrace();
      }
      return updated;
    }
  }
);
  return properties;
}",0.2884927066450567
133636,"@Override public Future<Boolean> setFeature(String category,String feature) throws NullPointerException, IllegalArgumentException {
  if (category == null || feature == null) {
    throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final String newCategory=category;
  final String newFeature=feature;
  Callable<Boolean> operation=new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      boolean changed=false;
      String category=getCategory();
      String feature=getFeature();
      if (!newCategory.equals(category) || !newFeature.equals(feature)) {
        Set<String> featureSet=featureMap.get(category);
        if (featureSet != null) {
          if (featureSet.contains(feature)) {
            if (connection.getState() == ConnectionState.Connected && setFeatureOnClient(connection,category,feature)) {
              category=newCategory;
              feature=newFeature;
              changed=true;
            }
          }
 else {
            throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + feature + ""String_Node_Str"");
          }
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + category + ""String_Node_Str"");
        }
      }
      return changed;
    }
  }
;
  return requestExecutor.submit(operation);
}","@Override public Future<Boolean> setFeature(String category,String feature) throws NullPointerException, IllegalArgumentException {
  if (category == null || feature == null) {
    throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final String newCategory=category;
  final String newFeature=feature;
  Callable<Boolean> operation=new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      boolean changed=false;
      String category=getCategory();
      String feature=getFeature();
      if (!newCategory.equals(category) || !newFeature.equals(feature)) {
        Set<String> featureSet=featureMap.get(newCategory);
        if (featureSet != null) {
          if (featureSet.contains(newFeature)) {
            if (connection.getState() == ConnectionState.Connected && setFeatureOnClient(connection,newCategory,newFeature)) {
              AbstractParaViewProxy.this.category=newCategory;
              AbstractParaViewProxy.this.feature=newFeature;
              changed=true;
            }
          }
 else {
            throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + newFeature + ""String_Node_Str"");
          }
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + newCategory + ""String_Node_Str"");
        }
      }
      return changed;
    }
  }
;
  return requestExecutor.submit(operation);
}",0.9699785561115082
133637,"@SuppressWarnings(""String_Node_Str"") @Override public void widgetSelected(SelectionEvent arg0){
  if (list.size() > 0) {
    ListComponent selected=table.getSelectedObjects();
    if (selected.size() > 0) {
      int numSelected=selected.size();
      if (!(selected.get(numSelected - 1).equals(list.get(list.size() - 1)))) {
        list.getReadWriteLock().writeLock().lock();
        int index=0;
        Object toMove=list.get(0);
        for (int i=0; i < numSelected; i++) {
          index=list.indexOf(selected.get(i)) + 1;
          toMove=list.get(index);
          list.set(index,selected.get(i));
          list.set(index - 1,toMove);
        }
        list.set(index - 1,toMove);
        list.getReadWriteLock().writeLock().unlock();
        table.setSelection(selected);
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void widgetSelected(SelectionEvent arg0){
  if (list.size() > 0) {
    ListComponent selected=table.getSelectedObjects();
    if (selected.size() > 0) {
      int numSelected=selected.size();
      if (!(selected.get(numSelected - 1).equals(list.get(list.size() - 1)))) {
        list.getReadWriteLock().writeLock().lock();
        int index=0;
        Object toMove=list.get(0);
        for (int i=numSelected - 1; i >= 0; i--) {
          index=list.indexOf(selected.get(i)) + 1;
          toMove=list.get(index);
          list.set(index,selected.get(i));
          list.set(index - 1,toMove);
        }
        list.set(index - 1,toMove);
        list.getReadWriteLock().writeLock().unlock();
        table.setSelection(selected);
      }
    }
  }
}",0.9819987585350712
133638,"/** 
 * This operation creates the add and delete buttons that are used to add layers to the table. Also creates buttons for moving layers around. 
 */
private void createAddDeleteButtons(){
  Composite listButtonComposite=new Composite(sectionClient,SWT.NONE);
  listButtonComposite.setLayout(new GridLayout(1,false));
  listButtonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.FILL,false,true,1,1));
  Button addMaterialButton=new Button(listButtonComposite,SWT.PUSH);
  addMaterialButton.setText(""String_Node_Str"");
  addMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (source == null) {
        int index=list.size() - 1;
        list.getReadWriteLock().writeLock().lock();
        try {
          list.add(list.get(index));
        }
  finally {
          list.getReadWriteLock().writeLock().unlock();
        }
      }
 else {
        ElementSourceDialog dialog=new ElementSourceDialog(shell,source);
        if (dialog.open() == Window.OK) {
          list.getReadWriteLock().writeLock().lock();
          try {
            list.add(dialog.getSelection());
          }
  finally {
            list.getReadWriteLock().writeLock().unlock();
          }
        }
      }
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  Button deleteMaterialButton=new Button(listButtonComposite,SWT.PUSH);
  deleteMaterialButton.setText(""String_Node_Str"");
  deleteMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (list.size() > 0) {
        ListComponent selected=table.getSelectedObjects();
        if (selected.size() > 0) {
          list.getReadWriteLock().writeLock().lock();
          try {
            for (            Object o : selected) {
              list.remove(o);
            }
          }
  finally {
            list.getReadWriteLock().writeLock().unlock();
          }
        }
      }
    }
  }
);
  Button moveUpButton=new Button(listButtonComposite,SWT.PUSH);
  moveUpButton.setText(""String_Node_Str"");
  moveUpButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
    @SuppressWarnings(""String_Node_Str"") @Override public void widgetSelected(    SelectionEvent arg0){
      if (list.size() > 0) {
        ListComponent selected=table.getSelectedObjects();
        if (selected.size() > 0) {
          int numSelected=selected.size();
          if (!(selected.get(0).equals(list.get(0)))) {
            list.getReadWriteLock().writeLock().lock();
            int index=0;
            Object toMove=list.get(0);
            for (int i=0; i < numSelected; i++) {
              index=list.indexOf(selected.get(i)) - 1;
              toMove=list.get(index);
              list.set(index,selected.get(i));
              list.set(index + 1,toMove);
            }
            list.set(index + 1,toMove);
            list.getReadWriteLock().writeLock().unlock();
            table.setSelection(selected);
          }
        }
      }
    }
  }
);
  Button moveDownButton=new Button(listButtonComposite,SWT.PUSH);
  moveDownButton.setText(""String_Node_Str"");
  moveDownButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
    @SuppressWarnings(""String_Node_Str"") @Override public void widgetSelected(    SelectionEvent arg0){
      if (list.size() > 0) {
        ListComponent selected=table.getSelectedObjects();
        if (selected.size() > 0) {
          int numSelected=selected.size();
          if (!(selected.get(numSelected - 1).equals(list.get(list.size() - 1)))) {
            list.getReadWriteLock().writeLock().lock();
            int index=0;
            Object toMove=list.get(0);
            for (int i=0; i < numSelected; i++) {
              index=list.indexOf(selected.get(i)) + 1;
              toMove=list.get(index);
              list.set(index,selected.get(i));
              list.set(index - 1,toMove);
            }
            list.set(index - 1,toMove);
            list.getReadWriteLock().writeLock().unlock();
            table.setSelection(selected);
          }
        }
      }
    }
  }
);
  return;
}","/** 
 * This operation creates the add and delete buttons that are used to add layers to the table. Also creates buttons for moving layers around. 
 */
private void createAddDeleteButtons(){
  Composite listButtonComposite=new Composite(sectionClient,SWT.NONE);
  listButtonComposite.setLayout(new GridLayout(1,false));
  listButtonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.FILL,false,true,1,1));
  Button addMaterialButton=new Button(listButtonComposite,SWT.PUSH);
  addMaterialButton.setText(""String_Node_Str"");
  addMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (source == null) {
        int index=list.size() - 1;
        list.getReadWriteLock().writeLock().lock();
        try {
          list.add(list.get(index));
        }
  finally {
          list.getReadWriteLock().writeLock().unlock();
        }
      }
 else {
        ElementSourceDialog dialog=new ElementSourceDialog(shell,source);
        if (dialog.open() == Window.OK) {
          list.getReadWriteLock().writeLock().lock();
          try {
            list.add(dialog.getSelection());
          }
  finally {
            list.getReadWriteLock().writeLock().unlock();
          }
        }
      }
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  Button deleteMaterialButton=new Button(listButtonComposite,SWT.PUSH);
  deleteMaterialButton.setText(""String_Node_Str"");
  deleteMaterialButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (list.size() > 0) {
        ListComponent selected=table.getSelectedObjects();
        if (selected.size() > 0) {
          list.getReadWriteLock().writeLock().lock();
          try {
            for (            Object o : selected) {
              list.remove(o);
            }
          }
  finally {
            list.getReadWriteLock().writeLock().unlock();
          }
        }
      }
    }
  }
);
  Button moveUpButton=new Button(listButtonComposite,SWT.PUSH);
  moveUpButton.setText(""String_Node_Str"");
  moveUpButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
    @SuppressWarnings(""String_Node_Str"") @Override public void widgetSelected(    SelectionEvent arg0){
      if (list.size() > 0) {
        ListComponent selected=table.getSelectedObjects();
        if (selected.size() > 0) {
          int numSelected=selected.size();
          if (!(selected.get(0).equals(list.get(0)))) {
            list.getReadWriteLock().writeLock().lock();
            int index=0;
            Object toMove=list.get(0);
            for (int i=0; i < numSelected; i++) {
              index=list.indexOf(selected.get(i)) - 1;
              toMove=list.get(index);
              list.set(index,selected.get(i));
              list.set(index + 1,toMove);
            }
            list.set(index + 1,toMove);
            list.getReadWriteLock().writeLock().unlock();
            table.setSelection(selected);
          }
        }
      }
    }
  }
);
  Button moveDownButton=new Button(listButtonComposite,SWT.PUSH);
  moveDownButton.setText(""String_Node_Str"");
  moveDownButton.addSelectionListener(new SelectionListener(){
    @Override public void widgetDefaultSelected(    SelectionEvent arg0){
    }
    @SuppressWarnings(""String_Node_Str"") @Override public void widgetSelected(    SelectionEvent arg0){
      if (list.size() > 0) {
        ListComponent selected=table.getSelectedObjects();
        if (selected.size() > 0) {
          int numSelected=selected.size();
          if (!(selected.get(numSelected - 1).equals(list.get(list.size() - 1)))) {
            list.getReadWriteLock().writeLock().lock();
            int index=0;
            Object toMove=list.get(0);
            for (int i=numSelected - 1; i >= 0; i--) {
              index=list.indexOf(selected.get(i)) + 1;
              toMove=list.get(index);
              list.set(index,selected.get(i));
              list.set(index - 1,toMove);
            }
            list.set(index - 1,toMove);
            list.getReadWriteLock().writeLock().unlock();
            table.setSelection(selected);
          }
        }
      }
    }
  }
);
  return;
}",0.9951164111300398
133639,"@Override public void mouseScrolled(MouseEvent e){
  String direction=(e.count > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
  widget.zoom(direction);
}","@Override public void mouseScrolled(MouseEvent e){
  String direction=(e.count > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
  widget.zoom(direction);
  System.out.println(direction);
}",0.9020771513353116
133640,"/** 
 * Creates and registers all listeners for the specified widget.
 * @param widget The widget that will receive listeners.
 */
private void registerListeners(final VisItSwtWidget widget){
  if (wheelListener == null) {
    wheelListener=new MouseWheelListener(){
      @Override public void mouseScrolled(      MouseEvent e){
        String direction=(e.count > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
        widget.zoom(direction);
      }
    }
;
    widget.addMouseWheelListener(wheelListener);
  }
  if (moveListener == null) {
    moveListener=new MouseMoveListener(){
      @Override public void mouseMove(      MouseEvent e){
        if (mousePressed) {
          enqueueMouseLocation(e.x,e.y);
        }
      }
    }
;
    widget.addMouseMoveListener(moveListener);
  }
  if (mouseListener == null) {
    mouseListener=new MouseListener(){
      @Override public void mouseUp(      MouseEvent e){
        mousePressed=false;
        stop();
      }
      @Override public void mouseDown(      MouseEvent e){
        mousePressed=true;
        start(e.x,e.y,(e.stateMask & SWT.CTRL) != 0,(e.stateMask & SWT.SHIFT) != 0);
      }
      @Override public void mouseDoubleClick(      MouseEvent e){
      }
    }
;
    widget.addMouseListener(mouseListener);
  }
  if (disposeListener == null) {
    disposeListener=new DisposeListener(){
      @Override public void widgetDisposed(      DisposeEvent e){
        dispose();
      }
    }
;
    widget.addDisposeListener(disposeListener);
  }
  return;
}","/** 
 * Creates and registers all listeners for the specified widget.
 * @param widget The widget that will receive listeners.
 */
private void registerListeners(final VisItSwtWidget widget){
  if (wheelListener == null) {
    wheelListener=new MouseWheelListener(){
      @Override public void mouseScrolled(      MouseEvent e){
        String direction=(e.count > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
        widget.zoom(direction);
        System.out.println(direction);
      }
    }
;
    Listener dummy=new Listener(){
      @Override public void handleEvent(      org.eclipse.swt.widgets.Event event){
      }
    }
;
    widget.addListener(SWT.KeyDown,dummy);
    widget.addMouseWheelListener(wheelListener);
  }
  if (moveListener == null) {
    moveListener=new MouseMoveListener(){
      @Override public void mouseMove(      MouseEvent e){
        if (mousePressed) {
          enqueueMouseLocation(e.x,e.y);
        }
      }
    }
;
    widget.addMouseMoveListener(moveListener);
  }
  if (mouseListener == null) {
    mouseListener=new MouseListener(){
      @Override public void mouseUp(      MouseEvent e){
        mousePressed=false;
        stop();
      }
      @Override public void mouseDown(      MouseEvent e){
        mousePressed=true;
        start(e.x,e.y,(e.stateMask & SWT.CTRL) != 0,(e.stateMask & SWT.SHIFT) != 0);
      }
      @Override public void mouseDoubleClick(      MouseEvent e){
      }
    }
;
    widget.addMouseListener(mouseListener);
  }
  if (disposeListener == null) {
    disposeListener=new DisposeListener(){
      @Override public void widgetDisposed(      DisposeEvent e){
        dispose();
      }
    }
;
    widget.addDisposeListener(disposeListener);
  }
  return;
}",0.933210218528778
133641,"/** 
 * This operation gets the radio selection and sets the fields of this class appropriately.
 */
public boolean setFinishFields(){
  int index=connectionCombo.getSelectionIndex();
  connectionId=connectionCombo.getText();
  windowId=""String_Node_Str"".equals(windowIdCombo.getText()) ? ""String_Node_Str"" : windowIdCombo.getText();
  if (index == -1) {
    windowId=""String_Node_Str"";
  }
  if (index == 0) {
    MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    return false;
  }
  if (index > 0) {
    dialogExitSelection=""String_Node_Str"";
    return true;
  }
  if (localRadio.getSelection()) {
    dialogExitSelection=""String_Node_Str"";
    if (!localPathComp.getPathString().isEmpty()) {
      visItDir=localPathComp.getPathString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    hostname=""String_Node_Str"";
    if (!localPortComp.getPortString().isEmpty()) {
      port=localPortComp.getPortString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    password=localPasswordComp.getPassword();
    use_tunneling=false;
  }
 else   if (remoteRadio.getSelection()) {
    dialogExitSelection=""String_Node_Str"";
    if (!remoteHostComp.getHostString().isEmpty()) {
      hostname=remoteHostComp.getHostString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!remotePathComp.getPathString().isEmpty()) {
      visItDir=remotePathComp.getPathString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!remotePortComp.getPortString().isEmpty()) {
      port=remotePortComp.getPortString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    password=remotePasswordComp.getPassword();
    use_tunneling=true;
    gateway=remoteGatewayComp.getURLString();
    localGatewayPort=remoteGatewayComp.getPortString();
  }
 else   if (serviceRadio.getSelection()) {
    dialogExitSelection=""String_Node_Str"";
    if (!serviceHostComp.getHostString().isEmpty()) {
      hostname=serviceHostComp.getHostString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!servicePortText.getText().isEmpty()) {
      port=servicePortText.getText();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    password=servicePassText.getText();
    use_tunneling=false;
    gateway=serviceGatewayComp.getURLString();
    localGatewayPort=serviceGatewayComp.getPortString();
  }
 else {
    dialogExitSelection=null;
  }
  return true;
}","/** 
 * This operation gets the radio selection and sets the fields of this class appropriately.
 */
public boolean setFinishFields(){
  int index=connectionCombo.getSelectionIndex();
  connectionId=connectionCombo.getText();
  windowId=""String_Node_Str"".equals(windowIdCombo.getText()) ? ""String_Node_Str"" : windowIdCombo.getText();
  if (index == -1) {
    windowId=""String_Node_Str"";
  }
  if (index == 0) {
    MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    return false;
  }
  if (index > 0) {
    dialogExitSelection=""String_Node_Str"";
    return true;
  }
  if (localRadio.getSelection()) {
    dialogExitSelection=""String_Node_Str"";
    if (!localPathComp.getPathString().isEmpty()) {
      visItDir=localPathComp.getPathString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    hostname=""String_Node_Str"";
    if (!localPortComp.getPortString().isEmpty()) {
      port=localPortComp.getPortString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    try (Socket test=new Socket(""String_Node_Str"",Integer.valueOf(port))){
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
 catch (    IOException e) {
    }
    password=localPasswordComp.getPassword();
    use_tunneling=false;
  }
 else   if (remoteRadio.getSelection()) {
    dialogExitSelection=""String_Node_Str"";
    if (!remoteHostComp.getHostString().isEmpty()) {
      hostname=remoteHostComp.getHostString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!remotePathComp.getPathString().isEmpty()) {
      visItDir=remotePathComp.getPathString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!remotePortComp.getPortString().isEmpty()) {
      port=remotePortComp.getPortString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    try (Socket test=new Socket(""String_Node_Str"",Integer.valueOf(port))){
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
 catch (    IOException e) {
    }
    password=remotePasswordComp.getPassword();
    use_tunneling=true;
    gateway=remoteGatewayComp.getURLString();
    localGatewayPort=remoteGatewayComp.getPortString();
  }
 else   if (serviceRadio.getSelection()) {
    dialogExitSelection=""String_Node_Str"";
    if (!serviceHostComp.getHostString().isEmpty()) {
      hostname=serviceHostComp.getHostString();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!servicePortText.getText().isEmpty()) {
      port=servicePortText.getText();
    }
 else {
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
    try (Socket test=new Socket(""String_Node_Str"",Integer.valueOf(port))){
      MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      return false;
    }
 catch (    IOException e) {
    }
    password=servicePassText.getText();
    use_tunneling=false;
    gateway=serviceGatewayComp.getURLString();
    localGatewayPort=serviceGatewayComp.getPortString();
  }
 else {
    dialogExitSelection=null;
  }
  return true;
}",0.8931332423829014
133642,"/** 
 * This operation sets up the Composite that contains the VisIt canvas and create the VisIt widget.
 */
@Override public void createPartControl(Composite parent){
  vizComposite=new Composite(parent,SWT.FILL);
  vizComposite.setLayout(new FillLayout());
  if (getEditorInput() != null && getEditorInput() instanceof VisitEditorInput) {
    vizWidget=new VisItSwtWidget(vizComposite,SWT.BORDER | SWT.DOUBLE_BUFFERED);
    mouseManager=new VisitMouseManager(vizWidget);
    vizWidget.addMouseWheelListener(new MouseWheelListener(){
      @Override public void mouseScrolled(      MouseEvent e){
        String direction=(e.count > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
        vizWidget.zoom(direction);
      }
    }
);
    vizWidget.addMouseMoveListener(new MouseMoveListener(){
      @Override public void mouseMove(      MouseEvent e){
        if (mousePressed) {
          mouseManager.enqueueMouseLocation(e.x,e.y);
        }
      }
    }
);
    vizWidget.addMouseListener(new MouseListener(){
      @Override public void mouseUp(      MouseEvent e){
        mousePressed=false;
        mouseManager.stop();
      }
      @Override public void mouseDown(      MouseEvent e){
        mousePressed=true;
        mouseManager.start(e.x,e.y,(e.stateMask & SWT.CTRL) != 0,(e.stateMask & SWT.SHIFT) != 0);
      }
      @Override public void mouseDoubleClick(      MouseEvent e){
      }
    }
);
    vizWidget.addDisposeListener(new DisposeListener(){
      @Override public void widgetDisposed(      DisposeEvent e){
      }
    }
);
    HashMap<String,String> inputMap=((VisitEditorInput)getEditorInput()).getInputMap();
    VisItSwtConnection conn=null;
    String key=inputMap.get(""String_Node_Str"");
    if (VisItSwtConnectionManager.hasConnection(key)) {
      conn=VisItSwtConnectionManager.getConnection(key);
    }
 else {
      conn=VisItSwtConnectionManager.createConnection(key,new Shell(Display.getDefault()),inputMap);
    }
    boolean result=(conn != null);
    boolean isRemote=Boolean.valueOf(inputMap.get(""String_Node_Str""));
    if (!result) {
      if (isRemote) {
        MessageDialog.openError(parent.getShell(),""String_Node_Str"",""String_Node_Str"");
      }
 else {
        MessageDialog.openError(parent.getShell(),""String_Node_Str"",""String_Node_Str"");
      }
    }
    if (result) {
      try {
        int windowId=Integer.parseInt(inputMap.get(""String_Node_Str""));
        int windowWidth=Integer.parseInt(inputMap.get(""String_Node_Str""));
        int windowHeight=Integer.parseInt(inputMap.get(""String_Node_Str""));
        vizWidget.setVisItSwtConnection(conn,windowId,windowWidth,windowHeight);
      }
 catch (      Exception e) {
        MessageDialog.openError(parent.getShell(),""String_Node_Str"",e.getMessage());
      }
    }
  }
 else {
    Text errText=new Text(vizComposite,SWT.NONE);
    errText.setText(""String_Node_Str"");
  }
  return;
}","/** 
 * This operation sets up the Composite that contains the VisIt canvas and create the VisIt widget.
 */
@Override public void createPartControl(Composite parent){
  vizComposite=new Composite(parent,SWT.FILL);
  vizComposite.setLayout(new FillLayout());
  if (getEditorInput() != null && getEditorInput() instanceof VisitEditorInput) {
    vizWidget=new VisItSwtWidget(vizComposite,SWT.BORDER | SWT.DOUBLE_BUFFERED);
    mouseManager=new VisitMouseManager(vizWidget);
    vizWidget.addMouseWheelListener(new MouseWheelListener(){
      @Override public void mouseScrolled(      MouseEvent e){
        String direction=(e.count > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
        vizWidget.zoom(direction);
      }
    }
);
    Listener dummy=new Listener(){
      @Override public void handleEvent(      org.eclipse.swt.widgets.Event event){
      }
    }
;
    vizWidget.addListener(SWT.KeyDown,dummy);
    vizWidget.addMouseMoveListener(new MouseMoveListener(){
      @Override public void mouseMove(      MouseEvent e){
        if (mousePressed) {
          mouseManager.enqueueMouseLocation(e.x,e.y);
        }
      }
    }
);
    vizWidget.addMouseListener(new MouseListener(){
      @Override public void mouseUp(      MouseEvent e){
        mousePressed=false;
        mouseManager.stop();
      }
      @Override public void mouseDown(      MouseEvent e){
        mousePressed=true;
        mouseManager.start(e.x,e.y,(e.stateMask & SWT.CTRL) != 0,(e.stateMask & SWT.SHIFT) != 0);
      }
      @Override public void mouseDoubleClick(      MouseEvent e){
      }
    }
);
    vizWidget.addDisposeListener(new DisposeListener(){
      @Override public void widgetDisposed(      DisposeEvent e){
      }
    }
);
    HashMap<String,String> inputMap=((VisitEditorInput)getEditorInput()).getInputMap();
    VisItSwtConnection conn=null;
    String key=inputMap.get(""String_Node_Str"");
    if (VisItSwtConnectionManager.hasConnection(key)) {
      conn=VisItSwtConnectionManager.getConnection(key);
    }
 else {
      conn=VisItSwtConnectionManager.createConnection(key,new Shell(Display.getDefault()),inputMap);
    }
    boolean result=(conn != null);
    boolean isRemote=Boolean.valueOf(inputMap.get(""String_Node_Str""));
    if (!result) {
      if (isRemote) {
        MessageDialog.openError(parent.getShell(),""String_Node_Str"",""String_Node_Str"");
      }
 else {
        MessageDialog.openError(parent.getShell(),""String_Node_Str"",""String_Node_Str"");
      }
    }
    if (result) {
      try {
        int windowId=Integer.parseInt(inputMap.get(""String_Node_Str""));
        int windowWidth=Integer.parseInt(inputMap.get(""String_Node_Str""));
        int windowHeight=Integer.parseInt(inputMap.get(""String_Node_Str""));
        vizWidget.setVisItSwtConnection(conn,windowId,windowWidth,windowHeight);
      }
 catch (      Exception e) {
        MessageDialog.openError(parent.getShell(),""String_Node_Str"",e.getMessage());
      }
    }
  }
 else {
    Text errText=new Text(vizComposite,SWT.NONE);
    errText.setText(""String_Node_Str"");
  }
  return;
}",0.9696359671196108
133643,"/** 
 * Disposes class instance resources (i.e., the   {@link #bot}) after the instance's tests have been run. <p> <b>Note:</b> If overridden, be sure to call   {@code super.afterTests()} atthe end of the method, or the bot will not be freed. </p>
 */
@After public void afterTests(){
  bot=null;
}","/** 
 * Disposes class instance resources (i.e., the   {@link #bot}) after the instance's tests have been run. <p> <b>Note:</b> If overridden, be sure to call   {@code super.afterTests()} atthe end of the method, or the bot will not be freed. </p>
 */
@After public void afterTests(){
  disposeTestResources();
  bot=null;
}",0.9581993569131833
133644,"/** 
 * Creates the   {@link #bot} for testing <i>after</i> the {@link #shell} iscreated. <p> <b>Note:</b> If overridden, be sure to call  {@code super.beforeTests()}at the beginning of the method, or the bot will not be created. </p>
 * @throws InterruptedException If there is an error while waiting for the shell to be created.
 */
@Before public void beforeTests() throws InterruptedException {
  shellLatch.await();
  bot=new SWTBot(shell);
}","/** 
 * Creates the   {@link #bot} for testing <i>after</i> the {@link #shell} iscreated. <p> <b>Note:</b> If overridden, be sure to call  {@code super.beforeTests()}at the beginning of the method, or the bot will not be created. </p>
 * @throws InterruptedException If there is an error while waiting for the shell to be created.
 */
@Before public void beforeTests() throws InterruptedException {
  shellLatch.await();
  bot=new SWTBot(shell);
  createTestResources(shell);
}",0.9675324675324676
133645,"/** 
 * This operations loads a MOOSE GetPot file at the specified path and returns a fully-configured set of ICE TreeComposites.
 * @param filePath The file path from which the MOOSE blocks written in GetPot should be read. If the path is null or empty, the operation returns without doing any work.
 * @return The MOOSE input file specification as read from the GetPot inputand stored in TreeComposites. Each TreeComposite contains both parameters and exemplar children. Any parameters in a TreeComposite are contained in a DataComponent. The id of the data component is 1.
 */
public ArrayList<TreeComposite> loadFromGetPot(String filePath){
  ArrayList<TreeComposite> trees=new ArrayList<TreeComposite>();
  byte[] fileByteArray=null;
  String mooseFileString=null, potLine=null;
  if (filePath == null || filePath.isEmpty()) {
    return null;
  }
  if (debugFlag) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath);
  }
  try {
    RandomAccessFile mooseFile=new RandomAccessFile(filePath,""String_Node_Str"");
    fileByteArray=new byte[(int)mooseFile.length()];
    mooseFile.read(fileByteArray);
    mooseFileString=new String(fileByteArray);
    mooseFile.close();
    if (debugFlag) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  if (mooseFileString != null && !mooseFileString.isEmpty()) {
    ArrayList<String> potLines=new ArrayList<String>(Arrays.asList(mooseFileString.split(""String_Node_Str"")));
    String trimmedPotLine=""String_Node_Str"";
    for (int i=0; i < potLines.size(); i++) {
      trimmedPotLine=potLines.get(i).trim();
      if (trimmedPotLine.startsWith(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"")&& !trimmedPotLine.contains(""String_Node_Str"")) {
        potLines.remove(i);
        --i;
      }
 else       if (potLines.get(i).isEmpty()) {
        potLines.remove(i);
        --i;
      }
 else {
        if (trimmedPotLine.startsWith(""String_Node_Str"") && trimmedPotLine.contains(""String_Node_Str"")) {
          String[] splitTrimmedPotLine=trimmedPotLine.split(""String_Node_Str"");
          if (splitTrimmedPotLine.length > 4) {
            potLines.remove(i);
            --i;
            continue;
          }
        }
        potLines.set(i,potLines.get(i).trim());
      }
    }
    int counter=0, endCounter=1;
    while (counter < potLines.size()) {
      potLine=potLines.get(counter);
      ++counter;
      if (potLine.contains(""String_Node_Str"") && potLine.contains(""String_Node_Str"")) {
        potLine=potLines.get(endCounter);
        while (!potLine.contains(""String_Node_Str"")) {
          potLine=potLines.get(endCounter);
          ++endCounter;
        }
        Block block=new Block();
        ArrayList<String> blockLines=new ArrayList<String>(potLines.subList(counter - 1,endCounter));
        StringBuilder stringBuilder=new StringBuilder(blockLines.get(0));
        blockLines.set(0,stringBuilder.toString());
        block.fromGetPot(blockLines);
        trees.add(block.toTreeComposite());
        counter=endCounter;
        if (debugFlag) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
          for (          String line : blockLines) {
            System.out.println(line);
          }
        }
      }
    }
  }
 else   if (debugFlag) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
  }
  return trees;
}","/** 
 * This operations loads a MOOSE GetPot file at the specified path and returns a fully-configured set of ICE TreeComposites.
 * @param filePath The file path from which the MOOSE blocks written in GetPot should be read. If the path is null or empty, the operation returns without doing any work.
 * @return The MOOSE input file specification as read from the GetPot inputand stored in TreeComposites. Each TreeComposite contains both parameters and exemplar children. Any parameters in a TreeComposite are contained in a DataComponent. The id of the data component is 1.
 */
public ArrayList<TreeComposite> loadFromGetPot(String filePath){
  ArrayList<TreeComposite> trees=new ArrayList<TreeComposite>();
  byte[] fileByteArray=null;
  String mooseFileString=null, potLine=null;
  if (filePath == null || filePath.isEmpty()) {
    return null;
  }
  if (debugFlag) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath);
  }
  try {
    RandomAccessFile mooseFile=new RandomAccessFile(filePath,""String_Node_Str"");
    fileByteArray=new byte[(int)mooseFile.length()];
    mooseFile.read(fileByteArray);
    mooseFileString=new String(fileByteArray);
    mooseFile.close();
    if (debugFlag) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  if (mooseFileString != null && !mooseFileString.isEmpty()) {
    ArrayList<String> potLines=new ArrayList<String>(Arrays.asList(mooseFileString.split(""String_Node_Str"")));
    String trimmedPotLine=""String_Node_Str"";
    for (int i=0; i < potLines.size(); i++) {
      trimmedPotLine=potLines.get(i).trim();
      if (trimmedPotLine.startsWith(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"")&& !trimmedPotLine.contains(""String_Node_Str"")) {
        potLines.remove(i);
        --i;
      }
 else       if (potLines.get(i).isEmpty()) {
        potLines.remove(i);
        --i;
      }
 else {
        if (trimmedPotLine.startsWith(""String_Node_Str"") && trimmedPotLine.contains(""String_Node_Str"")) {
          String[] splitTrimmedPotLine=trimmedPotLine.split(""String_Node_Str"");
          if (splitTrimmedPotLine.length > 4) {
            potLines.remove(i);
            --i;
            continue;
          }
        }
        potLines.set(i,potLines.get(i).trim());
      }
    }
    int counter=0, endCounter=1;
    while (counter < potLines.size()) {
      potLine=potLines.get(counter);
      ++counter;
      if (potLine.contains(""String_Node_Str"") && potLine.contains(""String_Node_Str"")) {
        potLine=potLines.get(endCounter);
        while (!potLine.contains(""String_Node_Str"")) {
          potLine=potLines.get(endCounter);
          ++endCounter;
        }
        Block block=new Block();
        ArrayList<String> blockLines=null;
        if (endCounter >= counter - 1) {
          blockLines=new ArrayList<String>(potLines.subList(counter - 1,endCounter));
        }
        if (blockLines != null && !blockLines.isEmpty()) {
          StringBuilder stringBuilder=new StringBuilder(blockLines.get(0));
          blockLines.set(0,stringBuilder.toString());
          block.fromGetPot(blockLines);
          trees.add(block.toTreeComposite());
          counter=endCounter;
        }
        if (debugFlag) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
          for (          String line : blockLines) {
            System.out.println(line);
          }
        }
      }
    }
  }
 else   if (debugFlag) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
  }
  return trees;
}",0.978642361583458
133646,"/** 
 * This operation checks the JobProfile by processing it and reviewing comparing the Item it creates to the original. It also checks the quantities in the XML to make sure that they are consistent with the specification and useful for launching jobs.
 * @throws IOException 
 * @throws JAXBException 
 * @throws NullPointerException 
 */
@Test public void checkProfileWriting() throws NullPointerException, JAXBException, IOException {
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  URI defaultProjectLocation=null;
  IProject project=null;
  String separator=System.getProperty(""String_Node_Str"");
  try {
    project=workspaceRoot.getProject(""String_Node_Str"");
    if (!project.exists()) {
      defaultProjectLocation=(new File(System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str"")).toURI();
      IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(""String_Node_Str"");
      desc.setLocationURI(defaultProjectLocation);
      project.create(desc,null);
    }
    if (project.exists() && !project.isOpen()) {
      project.open(null);
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  jobProfile=new JobProfile(project);
  jobProfile.process(""String_Node_Str"");
  IFile file=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"" + ""String_Node_Str"");
  assertTrue(file.exists());
  ByteArrayInputStream inputStream=null;
  try {
    BufferedReader br=new BufferedReader(new InputStreamReader(file.getContents()));
    StringBuilder sb=new StringBuilder();
    String line;
    try {
      while ((line=br.readLine()) != null) {
        sb.append(line);
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    System.out.println(sb.toString());
    inputStream=new ByteArrayInputStream(sb.toString().getBytes());
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  JobLauncher launcher=new JobLauncher();
  ICEJAXBHandler xmlHandler=new ICEJAXBHandler();
  ArrayList<Class> classList=new ArrayList<Class>();
  classList.add(JobLauncher.class);
  classList.add(ResourceComponent.class);
  launcher=(JobLauncher)xmlHandler.read(classList,inputStream);
  JobLauncher comparisonLauncher=new JobLauncher();
  comparisonLauncher.setName(""String_Node_Str"");
  comparisonLauncher.setDescription(""String_Node_Str"");
  comparisonLauncher.setItemBuilderName(""String_Node_Str"");
  assertEquals(comparisonLauncher.getName(),launcher.getName());
  assertEquals(comparisonLauncher.getDescription(),launcher.getDescription());
  assertEquals(comparisonLauncher.getItemType(),launcher.getItemType());
  assertEquals(comparisonLauncher.getStatus(),launcher.getStatus());
  assertEquals(comparisonLauncher.getItemBuilderName(),launcher.getItemBuilderName());
  assertEquals(launcher.getName(),launcher.getItemBuilderName());
  Form form=launcher.getForm();
  assertEquals(""String_Node_Str"",form.getName());
  assertEquals(""String_Node_Str"",form.getDescription());
  assertEquals(3,form.getComponents().size());
  launcher.enableMPI(1,512000,1);
  launcher.enableOpenMP(1,16,1);
  DataComponent component=(DataComponent)form.getComponents().get(3);
  Entry mpiEntry=(Entry)component.retrieveAllEntries().get(1);
  Entry openMPEntry=(Entry)component.retrieveAllEntries().get(2);
  assertEquals(""String_Node_Str"",mpiEntry.getValue());
  assertEquals(""String_Node_Str"",openMPEntry.getValue());
  try {
    for (    IResource resource : project.members()) {
      if (resource.getType() == IResource.FILE && !(""String_Node_Str"").equals(resource.getName())) {
        resource.delete(true,null);
      }
    }
    project.refreshLocal(IResource.DEPTH_INFINITE,null);
  }
 catch (  CoreException e1) {
    e1.printStackTrace();
    fail();
  }
  return;
}","/** 
 * This operation checks the JobProfile by processing it and reviewing comparing the Item it creates to the original. It also checks the quantities in the XML to make sure that they are consistent with the specification and useful for launching jobs.
 * @throws IOException 
 * @throws JAXBException 
 * @throws NullPointerException 
 */
@Test public void checkProfileWriting() throws NullPointerException, JAXBException, IOException {
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  URI defaultProjectLocation=null;
  IProject project=null;
  String separator=System.getProperty(""String_Node_Str"");
  try {
    project=workspaceRoot.getProject(""String_Node_Str"");
    if (!project.exists()) {
      defaultProjectLocation=(new File(System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str"")).toURI();
      IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(""String_Node_Str"");
      desc.setLocationURI(defaultProjectLocation);
      project.create(desc,null);
    }
    if (project.exists() && !project.isOpen()) {
      project.open(null);
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
    fail();
  }
  jobProfile=new JobProfile(project);
  jobProfile.process(""String_Node_Str"");
  IFile file=project.getFolder(""String_Node_Str"").getFile(""String_Node_Str"");
  assertTrue(file.exists());
  ByteArrayInputStream inputStream=null;
  try {
    BufferedReader br=new BufferedReader(new InputStreamReader(file.getContents()));
    StringBuilder sb=new StringBuilder();
    String line;
    try {
      while ((line=br.readLine()) != null) {
        sb.append(line);
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    System.out.println(sb.toString());
    inputStream=new ByteArrayInputStream(sb.toString().getBytes());
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  JobLauncher launcher=new JobLauncher();
  ICEJAXBHandler xmlHandler=new ICEJAXBHandler();
  ArrayList<Class> classList=new ArrayList<Class>();
  classList.add(JobLauncher.class);
  classList.add(ResourceComponent.class);
  launcher=(JobLauncher)xmlHandler.read(classList,inputStream);
  JobLauncher comparisonLauncher=new JobLauncher();
  comparisonLauncher.setName(""String_Node_Str"");
  comparisonLauncher.setDescription(""String_Node_Str"");
  comparisonLauncher.setItemBuilderName(""String_Node_Str"");
  assertEquals(comparisonLauncher.getName(),launcher.getName());
  assertEquals(comparisonLauncher.getDescription(),launcher.getDescription());
  assertEquals(comparisonLauncher.getItemType(),launcher.getItemType());
  assertEquals(comparisonLauncher.getStatus(),launcher.getStatus());
  assertEquals(comparisonLauncher.getItemBuilderName(),launcher.getItemBuilderName());
  assertEquals(launcher.getName(),launcher.getItemBuilderName());
  Form form=launcher.getForm();
  assertEquals(""String_Node_Str"",form.getName());
  assertEquals(""String_Node_Str"",form.getDescription());
  assertEquals(3,form.getComponents().size());
  launcher.enableMPI(1,512000,1);
  launcher.enableOpenMP(1,16,1);
  DataComponent component=(DataComponent)form.getComponents().get(3);
  Entry mpiEntry=(Entry)component.retrieveAllEntries().get(1);
  Entry openMPEntry=(Entry)component.retrieveAllEntries().get(2);
  assertEquals(""String_Node_Str"",mpiEntry.getValue());
  assertEquals(""String_Node_Str"",openMPEntry.getValue());
  try {
    for (    IResource resource : project.members()) {
      if (resource.getType() == IResource.FILE && !(""String_Node_Str"").equals(resource.getName())) {
        File fileResource=new File(resource.getLocation().toOSString());
        fileResource.deleteOnExit();
      }
    }
    project.refreshLocal(IResource.DEPTH_INFINITE,null);
  }
 catch (  CoreException e1) {
    e1.printStackTrace();
    fail();
  }
  return;
}",0.9811122770199372
133647,"/** 
 * This method is responsible for toggling a ControlDecoration on and off on the EntryComposite. The decoration will toggle on if the editor is dirty and the selection was recently changed (monitored by   {@link EntryComposite#currentSelection}). Otherwise, it will toggle off.
 */
public void toggleSaveDecoration(){
  if (decoration == null) {
    decoration=new ControlDecoration(this,SWT.TOP | SWT.LEFT);
    final String saveMessage=""String_Node_Str"";
    decoration.setDescriptionText(saveMessage);
    Image image=FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_WARNING).getImage();
    decoration.setImage(image);
    final IEditorPart editor=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
    editor.addPropertyListener(new IPropertyListener(){
      @Override public void propertyChanged(      Object source,      int propId){
        if (editor != null && editor.isDirty()) {
          EntryComposite.this.decoration.show();
          if (messageManager != null) {
            messageManager.addMessage(messageName,saveMessage,null,IMessageProvider.ERROR);
          }
        }
 else         if (editor != null) {
          EntryComposite.this.decoration.hide();
          messageManager.removeMessage(messageName);
        }
        return;
      }
    }
);
  }
  return;
}","/** 
 * This method is responsible for toggling a ControlDecoration on and off on the EntryComposite. The decoration will toggle on if the editor is dirty and the selection was recently changed (monitored by   {@link EntryComposite#currentSelection}). Otherwise, it will toggle off.
 */
public void toggleSaveDecoration(){
  if (decoration == null) {
    decoration=new ControlDecoration(this,SWT.TOP | SWT.LEFT);
    final String saveMessage=""String_Node_Str"";
    decoration.setDescriptionText(saveMessage);
    Image image=FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_WARNING).getImage();
    decoration.setImage(image);
    final IEditorPart editor=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
    editor.addPropertyListener(new IPropertyListener(){
      @Override public void propertyChanged(      Object source,      int propId){
        if (editor != null) {
          if (editor.isDirty() && !EntryComposite.this.entry.getValue().equals(currentSelection)) {
            EntryComposite.this.decoration.show();
            if (messageManager != null) {
            }
          }
 else           if (!editor.isDirty()) {
            EntryComposite.this.decoration.hide();
          }
        }
        return;
      }
    }
);
  }
  return;
}",0.7983691623424759
133648,"@Override public void propertyChanged(Object source,int propId){
  if (editor != null && editor.isDirty()) {
    EntryComposite.this.decoration.show();
    if (messageManager != null) {
      messageManager.addMessage(messageName,saveMessage,null,IMessageProvider.ERROR);
    }
  }
 else   if (editor != null) {
    EntryComposite.this.decoration.hide();
    messageManager.removeMessage(messageName);
  }
  return;
}","@Override public void propertyChanged(Object source,int propId){
  if (editor != null) {
    if (editor.isDirty() && !EntryComposite.this.entry.getValue().equals(currentSelection)) {
      EntryComposite.this.decoration.show();
      if (messageManager != null) {
      }
    }
 else     if (!editor.isDirty()) {
      EntryComposite.this.decoration.hide();
    }
  }
  return;
}",0.4648241206030151
133649,"/** 
 * If the specified value is an allowed key for the   {@link #keyManager}, then this   {@code KeyEntry} will assume that key within the key manager.Otherwise, this method will return false and set an appropriate error message.
 */
@Override public boolean setValue(String newValue){
  boolean returnCode=false;
  AllowedValueType valueType=iEntryContentProvider.getAllowedValueType();
  if (valueType == AllowedValueType.Undefined) {
    if (contentProvider.keyAvailable(newValue)) {
      value=newValue;
      returnCode=true;
      changeState=true;
      errorMessage=null;
      notifyListeners();
    }
 else {
      String error=undefinedErrMsg;
      error=error.replace(""String_Node_Str"",newValue);
    }
  }
 else {
    returnCode=super.setValue(newValue);
  }
  return returnCode;
}","/** 
 * If the specified value is an allowed key for the   {@link #keyManager}, then this   {@code KeyEntry} will assume that key within the key manager.Otherwise, this method will return false and set an appropriate error message.
 */
@Override public boolean setValue(String newValue){
  boolean returnCode=false;
  AllowedValueType valueType=contentProvider.getAllowedValueType();
  if (value == newValue || (value != null && value.equals(newValue))) {
    returnCode=true;
    changeState=false;
    errorMessage=null;
  }
 else   if (valueType == AllowedValueType.Undefined) {
    if (contentProvider.keyAvailable(newValue)) {
      value=newValue;
      returnCode=true;
      changeState=true;
      errorMessage=null;
      notifyListeners();
    }
 else {
      String error=undefinedErrMsg;
      changeState=false;
      errorMessage=error.replace(""String_Node_Str"",newValue != null ? newValue : ""String_Node_Str"");
    }
  }
 else {
    returnCode=super.setValue(newValue);
  }
  return returnCode;
}",0.8685082872928177
133650,"@Override public boolean equals(Object object){
  boolean equals=false;
  if (super.equals(object) && object instanceof KeyEntry) {
    equals=true;
  }
  return equals;
}","@Override public boolean equals(Object object){
  boolean equals=false;
  if (object != null) {
    if (object == this) {
      equals=true;
    }
 else     if (object instanceof KeyEntry) {
      equals=super.equals(object);
    }
  }
  return equals;
}",0.5270588235294118
133651,"/** 
 * The copy constructor. When used, both   {@code KeyEntry}s will use the exact same   {@link #keyManager} (but valid or unique keys).<p> <b>Note:</b> This method should not be used. It is implemented so that a template  {@code KeyEntry} can be copied when used in{@code ConnectionManager} {@code TableComponent}s. </p>
 * @param otherEntry The other  {@code KeyEntry} to copy.
 */
private KeyEntry(KeyEntry entry){
  this(entry != null ? entry.contentProvider : null);
  if (entry != null) {
    super.copy(entry);
  }
  return;
}","/** 
 * The copy constructor. When used, both   {@code KeyEntry}s will use the exact same   {@link #keyManager} (but valid or unique keys).<p> <b>Note:</b> This method should not be used. It is implemented so that a template  {@code KeyEntry} can be copied when used in{@code ConnectionManager} {@code TableComponent}s. </p>
 * @param otherEntry The other  {@code KeyEntry} to copy.
 */
public KeyEntry(KeyEntry entry){
  if (entry != null) {
    super.copy(entry);
    contentProvider=(KeyEntryContentProvider)iEntryContentProvider;
  }
 else {
    throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return;
}",0.7849829351535836
133652,"/** 
 * Disconnects the associated   {@link #connection} if not alreadydisconnected. <p> <b>Note:</b> This method is <i>not</i> intended to be overridden by sub-classes. </p>
 * @param block If true, then the calling thread will be blocked until the disconnection succeeds or fails. If false, then the disconnection process will not block the calling thread.
 * @return True if the connection is closed upon returning, false otherwise.
 */
public boolean disconnect(boolean block){
  boolean connected=false;
  String key=getKey();
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str""+ (block ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  if (state == ConnectionState.Connected) {
    connected=true;
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
    Thread thread=new Thread(){
      @Override public void run(){
        if (closeConnection(connection)) {
          setState(ConnectionState.Disconnected);
          connection=null;
        }
      }
    }
;
    thread.setDaemon(false);
    thread.start();
    if (block) {
      try {
        thread.join();
        connected=(state == ConnectionState.Disconnected);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
        e.printStackTrace();
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
  }
  return !connected;
}","/** 
 * Disconnects the associated   {@link #connection} if not alreadydisconnected. <p> <b>Note:</b> This method is <i>not</i> intended to be overridden by sub-classes. </p>
 * @param block If true, then the calling thread will be blocked until the disconnection succeeds or fails. If false, then the disconnection process will not block the calling thread.
 * @return True if the connection is closed upon returning, false otherwise.
 */
public boolean disconnect(boolean block){
  String key=getKey();
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str""+ (block ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  if (state == ConnectionState.Connected) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
    Thread thread=new Thread(){
      @Override public void run(){
        if (closeConnection(connection)) {
          setState(ConnectionState.Disconnected);
          connection=null;
        }
      }
    }
;
    thread.setDaemon(false);
    thread.start();
    if (block) {
      try {
        thread.join();
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
        e.printStackTrace();
      }
    }
  }
 else   if (state == ConnectionState.Connecting) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
    setState(ConnectionState.Disconnected);
  }
  return state == ConnectionState.Disconnected;
}",0.7361419068736141
133653,"public int getPort(){
  String port=getConnectionProperty(""String_Node_Str"");
  return (port != null ? Integer.parseInt(port) : -1);
}","public int getPort(){
  int port=-1;
  String portString=getConnectionProperty(""String_Node_Str"");
  if (portString != null) {
    try {
      port=Integer.parseInt(portString);
    }
 catch (    NumberFormatException e) {
    }
  }
  return port;
}",0.5117493472584856
133654,"/** 
 * Connects to the associated   {@link #connection} if not already connectedor connecting. <p> <b>Note:</b> This method is <i>not</i> intended to be overridden by sub-classes. </p>
 * @param block If true, then the calling thread will be blocked until the connection succeeds or fails. If false, then the connection process will not block the calling thread.
 * @return True if the connection is established upon returning, falseotherwise.
 */
public boolean connect(boolean block){
  boolean connected=false;
  String key=getKey();
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str""+ (block ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  if (state == ConnectionState.Connected) {
    connected=true;
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
  }
 else   if (state != ConnectionState.Connecting) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
    Thread thread=new Thread(){
      @Override public void run(){
        setState(ConnectionState.Connecting);
        connection=openConnection();
        if (connection != null) {
          setState(ConnectionState.Connected);
        }
 else {
          setState(ConnectionState.Failed);
        }
      }
    }
;
    thread.start();
    if (block) {
      try {
        thread.join();
        connected=(state == ConnectionState.Connected);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
        e.printStackTrace();
      }
    }
  }
  return connected;
}","/** 
 * Connects to the associated   {@link #connection} if not already connectedor connecting. <p> <b>Note:</b> This method is <i>not</i> intended to be overridden by sub-classes. </p>
 * @param block If true, then the calling thread will be blocked until the connection succeeds or fails. If false, then the connection process will not block the calling thread.
 * @return True if the connection is established upon returning, falseotherwise.
 */
public boolean connect(boolean block){
  String key=getKey();
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str""+ (block ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  if (state == ConnectionState.Connected) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
  }
 else   if (state != ConnectionState.Connecting) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
    setState(ConnectionState.Connecting);
    Thread thread=new Thread(){
      @Override public void run(){
        connection=openConnection();
        if (connection != null) {
          setState(ConnectionState.Connected);
        }
 else {
          setState(ConnectionState.Failed);
        }
      }
    }
;
    thread.start();
    if (block) {
      try {
        thread.join();
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str"");
        e.printStackTrace();
      }
    }
  }
  return state == ConnectionState.Connected;
}",0.8292834890965732
133655,"public String getHost(){
  return getConnectionProperty(""String_Node_Str"");
}","public String getHost(){
  String host=getConnectionProperty(""String_Node_Str"");
  return (host != null && !host.isEmpty() ? host : ""String_Node_Str"");
}",0.6260869565217392
133656,"/** 
 * Sets the data source (which is currently rendered if the plot is drawn). If the data source is valid and new, then the plot will be updated accordingly. <p> <b>Note:</b>   {@link ConnectionPlot} additionally performs basic checks onthe files. For instance, it will throw an exception if the file does not exist or if there are read permission issues. </p>
 * @param file The new data source URI.
 * @throws NullPointerException if the specified file is null
 * @throws IOException if there was an error while reading the file's contents
 * @throws IllegalArgumentException if there are no plots available
 * @throws Exception if there is some other unspecified problem with the file
 */
@Override public void setDataSource(URI file) throws NullPointerException, IOException, IllegalArgumentException, Exception {
  if (file != null) {
    if (adapter != null) {
      throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
    }
    final String message;
    if (!adapter.isRemote()) {
      File fileRef=new File(file);
      if (!fileRef.isFile()) {
        message=""String_Node_Str"" + file + ""String_Node_Str"";
      }
 else       if (!fileRef.canRead()) {
        message=""String_Node_Str"" + file + ""String_Node_Str"";
      }
 else {
        message=null;
      }
    }
 else {
      message=null;
    }
    if (message != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + message);
    }
  }
  super.setDataSource(file);
}","/** 
 * Sets the data source (which is currently rendered if the plot is drawn). If the data source is valid and new, then the plot will be updated accordingly. <p> <b>Note:</b>   {@link ConnectionPlot} additionally performs basic checks onthe files. For instance, it will throw an exception if the file does not exist or if there are read permission issues. </p>
 * @param file The new data source URI.
 * @throws NullPointerException if the specified file is null
 * @throws IOException if there was an error while reading the file's contents
 * @throws IllegalArgumentException if there are no plots available
 * @throws Exception if there is some other unspecified problem with the file
 */
@Override public void setDataSource(URI file) throws NullPointerException, IOException, IllegalArgumentException, Exception {
  if (file != null) {
    if (adapter == null) {
      throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"");
    }
    final String message;
    if (!adapter.isRemote()) {
      File fileRef=new File(file);
      if (!fileRef.isFile()) {
        message=""String_Node_Str"" + file + ""String_Node_Str"";
      }
 else       if (!fileRef.canRead()) {
        message=""String_Node_Str"" + file + ""String_Node_Str"";
      }
 else {
        message=null;
      }
    }
 else {
      message=null;
    }
    if (message != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + message);
    }
  }
  super.setDataSource(file);
}",0.9993197278911564
133657,"/** 
 * Checks the new value before attempting to set it. The value must be an integer that lies within the port range (inclusive) defined by its associated   {@link PortEntryContentProvider}.
 */
@Override public boolean setValue(String newValue){
  boolean returnCode=false;
  List<String> allowedValues=iEntryContentProvider.getAllowedValues();
  int lowerBound=Integer.valueOf(allowedValues.get(0));
  int upperBound=Integer.valueOf(allowedValues.get(1));
  try {
    int newValueInt=Integer.valueOf(newValue);
    if (newValueInt >= lowerBound && newValueInt <= upperBound) {
      value=newValue;
      returnCode=true;
    }
  }
 catch (  NumberFormatException e) {
  }
  if (returnCode) {
    changeState=true;
    errorMessage=null;
    notifyListeners();
  }
 else {
    String error=continuousErrMsg;
    error=error.replace(""String_Node_Str"",newValue);
    error=error.replace(""String_Node_Str"",allowedValues.get(0));
    error=error.replace(""String_Node_Str"",allowedValues.get(1));
    errorMessage=error;
  }
  return returnCode;
}","/** 
 * Checks the new value before attempting to set it. The value must be an integer that lies within the port range (inclusive) defined by its associated   {@link PortEntryContentProvider}.
 */
@Override public boolean setValue(String newValue){
  boolean returnCode=false;
  List<String> allowedValues=iEntryContentProvider.getAllowedValues();
  int lowerBound=Integer.valueOf(allowedValues.get(0));
  int upperBound=Integer.valueOf(allowedValues.get(1));
  try {
    int newValueInt=Integer.valueOf(newValue);
    if (newValueInt >= lowerBound && newValueInt <= upperBound) {
      value=newValue;
      returnCode=true;
    }
  }
 catch (  NumberFormatException e) {
  }
  if (returnCode) {
    changeState=true;
    errorMessage=null;
    notifyListeners();
  }
 else {
    String error=continuousErrMsg;
    error=error.replace(""String_Node_Str"",newValue != null ? newValue : ""String_Node_Str"");
    error=error.replace(""String_Node_Str"",allowedValues.get(0));
    error=error.replace(""String_Node_Str"",allowedValues.get(1));
    errorMessage=error;
  }
  return returnCode;
}",0.9365899483325504
133658,"/** 
 * This checks the constructor for   {@code KeyEntry} to ensure that thedefault values are properly set.
 */
@Test public void checkConstruction(){
}","/** 
 * This checks the constructor for   {@code KeyEntry} to ensure that thedefault values are properly set.
 */
@Test public void checkConstruction(){
  PortEntry entry;
  PortEntryContentProvider contentProvider;
  final PortEntryContentProvider nullContentProvider=null;
  int defaultValue=5555;
  int value=-1;
  contentProvider=new PortEntryContentProvider();
  contentProvider.setDefaultValue(defaultValue);
  entry=new PortEntry(contentProvider);
  value=parseIntString(entry.getDefaultValue());
  assertEquals(defaultValue,value);
  value=parseIntString(entry.getValue());
  assertEquals(defaultValue,value);
  assertEquals(contentProvider.getAllowedValueType(),entry.getValueType());
  contentProvider=new PortEntryContentProvider();
  defaultValue=Integer.parseInt(contentProvider.getDefaultValue());
  entry=new PortEntry(nullContentProvider);
  value=parseIntString(entry.getDefaultValue());
  assertEquals(defaultValue,value);
  value=parseIntString(entry.getValue());
  assertEquals(defaultValue,value);
  assertEquals(contentProvider.getAllowedValueType(),entry.getValueType());
  return;
}",0.2444444444444444
133659,"/** 
 * Tests the clone operation to ensure that it properly returns a copied  {@code PortEntry} rather than a plain {@code Entry}.
 */
@Test public void checkCopy(){
}","/** 
 * Tests the clone operation to ensure that it properly returns a copied  {@code PortEntry} rather than a plain {@code Entry}.
 */
@Test public void checkCopy(){
  PortEntry entry;
  PortEntry copy;
  Object clone;
  PortEntryContentProvider contentProvider=new PortEntryContentProvider();
  contentProvider.setRange(50000,60000);
  contentProvider.setDefaultValue(55000);
  entry=new PortEntry(contentProvider);
  entry.setName(""String_Node_Str"");
  entry.setValue(Integer.toString(55001));
  copy=new PortEntry(new PortEntryContentProvider());
  copy.setName(""String_Node_Str"");
  assertFalse(entry.equals(copy));
  copy.copy(entry);
  assertNotSame(entry,copy);
  assertEquals(entry,copy);
  assertEquals(copy,entry);
  clone=entry.clone();
  assertNotNull(clone);
  assertTrue(clone instanceof PortEntry);
  assertNotSame(entry,clone);
  assertEquals(entry,clone);
  assertEquals(clone,entry);
  return;
}",0.310536044362292
133660,"/** 
 * Checks that the   {@link PortEntry#setValue(String)} properly assigns validvalues (integers managed by the  {@link PortEntryContentProvider}) and rejects invalid values (non-integers or integers outside the range).
 */
@Test public void checkValue(){
}","/** 
 * Checks that the   {@link PortEntry#setValue(String)} properly assigns validvalues (integers managed by the  {@link PortEntryContentProvider}) and rejects invalid values (non-integers or integers outside the range).
 */
@Test public void checkValue(){
  PortEntry entry;
  PortEntryContentProvider contentProvider;
  final int defaultValue=1337;
  final int min=343;
  final int max=43770;
  int lastValue=8000;
  int value=-1;
  final String nullString=null;
  boolean changed;
  contentProvider=new PortEntryContentProvider();
  contentProvider.setRange(min,max);
  contentProvider.setDefaultValue(defaultValue);
  entry=new PortEntry(contentProvider);
  value=parseIntString(entry.getDefaultValue());
  assertEquals(defaultValue,value);
  value=parseIntString(entry.getValue());
  assertEquals(defaultValue,value);
  assertNull(entry.getErrorMessage());
  lastValue=8000;
  changed=entry.setValue(Integer.toString(lastValue));
  assertTrue(changed);
  value=parseIntString(entry.getValue());
  assertEquals(lastValue,value);
  assertNull(entry.getErrorMessage());
  lastValue=min;
  changed=entry.setValue(Integer.toString(lastValue));
  assertTrue(changed);
  value=parseIntString(entry.getValue());
  assertEquals(lastValue,value);
  assertNull(entry.getErrorMessage());
  changed=entry.setValue(Integer.toString(min - 1));
  assertFalse(changed);
  value=parseIntString(entry.getValue());
  assertEquals(lastValue,value);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",entry.getErrorMessage());
  lastValue=max;
  changed=entry.setValue(Integer.toString(lastValue));
  assertTrue(changed);
  value=parseIntString(entry.getValue());
  assertEquals(lastValue,value);
  assertNull(entry.getErrorMessage());
  changed=entry.setValue(Integer.toString(max + 1));
  assertFalse(changed);
  value=parseIntString(entry.getValue());
  assertEquals(lastValue,value);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",entry.getErrorMessage());
  changed=entry.setValue(nullString);
  assertFalse(changed);
  value=parseIntString(entry.getValue());
  assertEquals(lastValue,value);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",entry.getErrorMessage());
  changed=entry.setValue(""String_Node_Str"");
  assertFalse(changed);
  value=parseIntString(entry.getValue());
  assertEquals(lastValue,value);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",entry.getErrorMessage());
  return;
}",0.1951951951951951
133661,"/** 
 * This realization of IReader.findAll() reads a Form in from the given file reference and walks the corresponding TreeComposite for occurrences of the  given regular expression.
 * @param file The reference to the file we are searching in.
 * @param regex The regular expression we should search for.
 */
@Override public ArrayList<Entry> findAll(IFile file,String regex){
  ArrayList<Entry> retEntries=new ArrayList<Entry>();
  Form form=read(file);
  TreeComposite tree=(TreeComposite)form.getComponent(MOOSEModel.mooseTreeCompositeId);
  if (tree == null || tree.getNumberOfChildren() < 1) {
    return retEntries;
  }
  BreadthFirstTreeCompositeIterator iter=new BreadthFirstTreeCompositeIterator(tree);
  while (iter.hasNext()) {
    TreeComposite child=iter.next();
    if (child.getActiveDataNode() != null) {
      DataComponent data=(DataComponent)child.getActiveDataNode();
      for (      Entry e : data.retrieveAllEntries()) {
        if (!""String_Node_Str"".equals(e.getTag()) && e.getValue() != null && !e.getValue().isEmpty() && e.getName().toLowerCase().contains(regex) && !e.getName().toLowerCase().contains(""String_Node_Str"")) {
          if (""String_Node_Str"".equals(e.getName().toLowerCase()) || ""String_Node_Str"".equals(e.getName().toLowerCase())) {
            e.setName(child.getName());
          }
          retEntries.add((Entry)e.clone());
        }
      }
    }
  }
  return retEntries;
}","/** 
 * This realization of IReader.findAll() reads a Form in from the given file reference and walks the corresponding TreeComposite for occurrences of the  given regular expression.
 * @param file The reference to the file we are searching in.
 * @param regex The regular expression we should search for.
 */
@Override public ArrayList<Entry> findAll(IFile file,String regex){
  ArrayList<Entry> retEntries=new ArrayList<Entry>();
  Form form=read(file);
  TreeComposite tree=(TreeComposite)form.getComponent(MOOSEModel.mooseTreeCompositeId);
  if (tree == null || tree.getNumberOfChildren() < 1) {
    return retEntries;
  }
  BreadthFirstTreeCompositeIterator iter=new BreadthFirstTreeCompositeIterator(tree);
  while (iter.hasNext()) {
    TreeComposite child=iter.next();
    if (child.getActiveDataNode() != null) {
      DataComponent data=(DataComponent)child.getActiveDataNode();
      for (      Entry e : data.retrieveAllEntries()) {
        if (!""String_Node_Str"".equals(e.getTag()) && e.getValue() != null && !e.getValue().isEmpty() && e.getName().toLowerCase().contains(regex) && !e.getName().toLowerCase().contains(""String_Node_Str"") && !e.getName().toLowerCase().contains(""String_Node_Str"")) {
          if (""String_Node_Str"".equals(e.getName().toLowerCase()) || ""String_Node_Str"".equals(e.getName().toLowerCase())) {
            e.setName(child.getName());
          }
          retEntries.add((Entry)e.clone());
        }
      }
    }
  }
  return retEntries;
}",0.96831955922865
133662,"/** 
 * This operation sets the TreeComposite that should be displayed for the current FormEditor.
 * @param tree The tree composite
 * @param source The source editor for the tree.
 */
public void setInput(TreeComposite tree,ICEFormEditor source){
  if (tree != inputTree) {
    if (tree != null) {
      tree.unregister(this);
    }
    inputTree=tree;
    clearMetaData();
    if (inputTree != null) {
      loadTree(inputTree);
      inputTree.register(this);
    }
    treeViewer.setInput(inputTree);
    setPartName(inputTree.getName() + ""String_Node_Str"");
  }
  this.editor=source;
  return;
}","/** 
 * This operation sets the TreeComposite that should be displayed for the current FormEditor.
 * @param tree The tree composite
 * @param source The source editor for the tree.
 */
public void setInput(TreeComposite tree,ICEFormEditor source){
  if (tree != inputTree) {
    if (tree != null) {
      tree.unregister(this);
    }
    inputTree=tree;
    clearMetaData();
    if (inputTree != null) {
      loadTree(inputTree);
      inputTree.register(this);
    }
    Tree treeWidget=treeViewer.getTree();
    if (treeWidget != null && !treeWidget.isDisposed()) {
      treeViewer.setInput(inputTree);
    }
    setPartName(inputTree.getName() + ""String_Node_Str"");
  }
  this.editor=source;
  return;
}",0.917557251908397
133663,"/** 
 * @param shell
 * @param plotViewer
 * @param resource
 */
public void plotFile(Shell shell,CSVPlotViewer plotViewer,VizResource resource){
  File file=resource.getContents();
  String fileName=file.getAbsolutePath();
  CSVDataProvider newDataProvider=null;
  if (fileName.matches(""String_Node_Str"")) {
    CSVDataLoader newCSVDataLoader=new CSVDataLoader();
    newDataProvider=newCSVDataLoader.load(fileName);
  }
 else {
    return;
  }
  newDataProvider.setSource(file.getName());
  if (newDataProvider.getFeatureList().size() > 1) {
    setIndependentVar(shell,newDataProvider);
  }
  AddPlotDialog plotDialog=new AddPlotDialog(shell);
  if (plotDialog.open() == Window.CANCEL) {
    return;
  }
  String[] userSelectedPlotTypes=plotDialog.getSelections();
  if (userSelectedPlotTypes != null && userSelectedPlotTypes.length > 0) {
    final String plotType=userSelectedPlotTypes[0];
    if (""String_Node_Str"".equals(plotType)) {
      if (newDataProvider.getDataHeight() == 0 || newDataProvider.getDataWidth() == 0) {
        return;
      }
      PlotProvider newPlotProvider=new PlotProvider();
      newPlotProvider.setPlotAsContour();
      String newPlotTitle=newDataProvider.getSourceInfo();
      Double plotTime=newDataProvider.getTimes().get(0);
      newDataProvider.setTime(plotTime);
      newPlotProvider.setPlotTitle(newPlotTitle);
      String yAxisFeature=newDataProvider.getFeatureList().get(0);
      SeriesProvider newContourSeries=new SeriesProvider();
      newContourSeries.setDataProvider(newDataProvider);
      newContourSeries.setDataMax(newDataProvider.getDataMax());
      newContourSeries.setDataMin(newDataProvider.getDataMin());
      newContourSeries.setTimeForDataProvider(plotTime);
      newContourSeries.setYDataFeature(yAxisFeature);
      newContourSeries.setSeriesTitle(""String_Node_Str"" + yAxisFeature);
      newPlotProvider.addSeries(plotTime,newContourSeries);
      plotViewer.addPlot(newPlotProvider);
    }
 else {
      SelectFeatureDialog featureDialog=new SelectFeatureDialog(shell);
      featureDialog.setXAxisFeatures(newDataProvider.getIndependentVariables());
      featureDialog.setYAxisFeatures(newDataProvider.getFeatureList());
      if (featureDialog.open() == Window.OK && !featureDialog.getXAxisFeatures().isEmpty() && !featureDialog.getYAxisFeatures().isEmpty()) {
        PlotProvider newPlotProvider=new PlotProvider();
        String newPlotTitle=newDataProvider.getSourceInfo();
        newPlotProvider.setPlotTitle(newPlotTitle);
        List<String> xAxisFeatures=featureDialog.getXAxisFeatures();
        List<String> yAxisFeatures=featureDialog.getYAxisFeatures();
        Double plotTime=newDataProvider.getTimes().get(0);
        newDataProvider.setTime(plotTime);
        for (        String xAxisFeature : xAxisFeatures) {
          String baseTitle=""String_Node_Str"" + xAxisFeature + ""String_Node_Str""+ plotTime;
          for (          String yAxisFeature : yAxisFeatures) {
            String newSeriesTitle=yAxisFeature + baseTitle;
            SeriesProvider newSeriesProvider=new SeriesProvider();
            newSeriesProvider.setDataProvider(newDataProvider);
            newSeriesProvider.setTimeForDataProvider(plotTime);
            newSeriesProvider.setSeriesTitle(newSeriesTitle);
            newSeriesProvider.setXDataFeature(xAxisFeature);
            newSeriesProvider.setYDataFeature(yAxisFeature);
            newSeriesProvider.setSeriesType(plotType);
            newPlotProvider.addSeries(plotTime,newSeriesProvider);
            plotViewer.addPlot(newPlotProvider);
          }
        }
      }
    }
  }
  return;
}","/** 
 * @param shell
 * @param plotViewer
 * @param resource
 */
public void plotFile(Shell shell,CSVPlotViewer plotViewer,VizResource resource){
  File file=resource.getContents();
  String fileName=file.getAbsolutePath();
  CSVDataProvider newDataProvider=null;
  if (fileName.matches(""String_Node_Str"")) {
    CSVDataLoader newCSVDataLoader=new CSVDataLoader();
    newDataProvider=newCSVDataLoader.load(fileName);
  }
 else {
    return;
  }
  newDataProvider.setSource(file.getName());
  if (newDataProvider.getFeatureList().size() > 1) {
    setIndependentVar(shell,newDataProvider);
  }
  AddPlotDialog plotDialog=new AddPlotDialog(shell);
  if (plotDialog.open() == Window.CANCEL) {
    return;
  }
  String[] userSelectedPlotTypes=plotDialog.getSelections();
  if (userSelectedPlotTypes != null && userSelectedPlotTypes.length > 0) {
    final String plotType=userSelectedPlotTypes[0];
    if (""String_Node_Str"".equals(plotType)) {
      if (newDataProvider.getDataHeight() == 0 || newDataProvider.getDataWidth() == 0) {
        return;
      }
      PlotProvider newPlotProvider=new PlotProvider();
      newPlotProvider.setPlotAsContour();
      String newPlotTitle=newDataProvider.getSourceInfo();
      Double plotTime=newDataProvider.getTimes().get(0);
      newDataProvider.setTime(plotTime);
      newPlotProvider.setPlotTitle(newPlotTitle);
      String yAxisFeature=newDataProvider.getFeatureList().get(0);
      SeriesProvider newContourSeries=new SeriesProvider();
      newContourSeries.setDataProvider(newDataProvider);
      newContourSeries.setDataMax(newDataProvider.getDataMax());
      newContourSeries.setDataMin(newDataProvider.getDataMin());
      newContourSeries.setTimeForDataProvider(plotTime);
      newContourSeries.setYDataFeature(yAxisFeature);
      newContourSeries.setSeriesTitle(""String_Node_Str"" + yAxisFeature);
      newPlotProvider.addSeries(plotTime,newContourSeries);
      plotViewer.addPlot(newPlotProvider);
    }
 else {
      SelectFeatureDialog featureDialog=new SelectFeatureDialog(shell);
      featureDialog.setXAxisFeatures(newDataProvider.getIndependentVariables());
      featureDialog.setYAxisFeatures(newDataProvider.getFeatureList());
      if (featureDialog.open() == Window.OK && !featureDialog.getXAxisFeatures().isEmpty() && !featureDialog.getYAxisFeatures().isEmpty()) {
        PlotProvider newPlotProvider=new PlotProvider();
        String newPlotTitle=newDataProvider.getSourceInfo();
        newPlotProvider.setPlotTitle(newPlotTitle);
        List<String> xAxisFeatures=featureDialog.getXAxisFeatures();
        List<String> yAxisFeatures=featureDialog.getYAxisFeatures();
        Double plotTime=newDataProvider.getTimes().get(0);
        newDataProvider.setTime(plotTime);
        for (        String xAxisFeature : xAxisFeatures) {
          String baseTitle=""String_Node_Str"" + xAxisFeature + ""String_Node_Str""+ plotTime;
          for (          String yAxisFeature : yAxisFeatures) {
            String newSeriesTitle=yAxisFeature + baseTitle;
            SeriesProvider newSeriesProvider=new SeriesProvider();
            newSeriesProvider.setDataProvider(newDataProvider);
            newSeriesProvider.setTimeForDataProvider(plotTime);
            newSeriesProvider.setSeriesTitle(newSeriesTitle);
            newSeriesProvider.setXDataFeature(xAxisFeature);
            newSeriesProvider.setYDataFeature(yAxisFeature);
            newSeriesProvider.setSeriesType(plotType);
            newPlotProvider.addSeries(plotTime,newSeriesProvider);
          }
        }
        plotViewer.addPlot(newPlotProvider);
      }
    }
  }
  return;
}",0.9922715981231024
133664,"@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  Shell shell=HandlerUtil.getActiveWorkbenchWindow(event).getShell();
  wizard=new GenerateYAMLWizard();
  WizardDialog dialog=new WizardDialog(shell,wizard);
  launcher=new MOOSELauncher(ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str""));
  if (dialog.open() != 0) {
    return null;
  }
  IEntryContentProvider execContentProvider=new BasicEntryContentProvider();
  ArrayList<String> execList=((DataComponent)launcher.getForm().getComponent(5)).retrieveEntry(""String_Node_Str"").getAllowedValues();
  execList.add(""String_Node_Str"");
  execContentProvider.setAllowedValues(execList);
  execContentProvider.setAllowedValueType(AllowedValueType.Discrete);
  execContentProvider.setDefaultValue(""String_Node_Str"");
  ((DataComponent)launcher.getForm().getComponent(5)).retrieveEntry(""String_Node_Str"").setContentProvider(execContentProvider);
  ((DataComponent)launcher.getForm().getComponent(5)).retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"");
  ((TableComponent)launcher.getForm().getComponent(4)).getRow(0).get(0).setValue(wizard.getHostName());
  ((TableComponent)launcher.getForm().getComponent(4)).getRow(0).get(2).setValue(wizard.getExecPath());
  launcher.submitForm(launcher.getForm());
  Thread thread=new Thread(this);
  thread.start();
  return null;
}","@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  Shell shell=HandlerUtil.getActiveWorkbenchWindow(event).getShell();
  wizard=new GenerateYAMLWizard();
  WizardDialog dialog=new WizardDialog(shell,wizard);
  launcher=new MOOSELauncher(ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str""));
  if (dialog.open() != 0) {
    return null;
  }
  IEntryContentProvider execContentProvider=new BasicEntryContentProvider();
  ArrayList<String> execList=((DataComponent)launcher.getForm().getComponent(JobLauncherForm.parallelId + 2)).retrieveEntry(""String_Node_Str"").getAllowedValues();
  execList.add(""String_Node_Str"");
  execContentProvider.setAllowedValues(execList);
  execContentProvider.setAllowedValueType(AllowedValueType.Discrete);
  execContentProvider.setDefaultValue(""String_Node_Str"");
  ((DataComponent)launcher.getForm().getComponent(JobLauncherForm.filesId)).clearEntries();
  ((DataComponent)launcher.getForm().getComponent(JobLauncherForm.parallelId + 2)).retrieveEntry(""String_Node_Str"").setContentProvider(execContentProvider);
  ((DataComponent)launcher.getForm().getComponent(JobLauncherForm.parallelId + 2)).retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"");
  ((TableComponent)launcher.getForm().getComponent(JobLauncherForm.parallelId + 1)).getRow(0).get(0).setValue(wizard.getHostName());
  ((TableComponent)launcher.getForm().getComponent(JobLauncherForm.parallelId + 1)).getRow(0).get(2).setValue(wizard.getExecPath());
  launcher.submitForm(launcher.getForm());
  Thread thread=new Thread(this);
  thread.start();
  return null;
}",0.9175292153589316
133665,"/** 
 * In additon to the default behavior when saved, this makes sure the plant and/or mesh view pages are visible depending on the current MOOSE app and input file settings.
 */
@Override public void doSave(IProgressMonitor monitor){
  super.doSave(monitor);
  String appStr=appsEntry.getValue();
  if (""String_Node_Str"".equals(appStr)) {
    addPlantPage();
  }
 else {
    removePlantPage();
  }
  return;
}","/** 
 * In additon to the default behavior when saved, this makes sure the plant and/or mesh view pages are visible depending on the current MOOSE app and input file settings.
 */
@Override public void doSave(IProgressMonitor monitor){
  super.doSave(monitor);
  String appStr=appsEntry.getValue().toLowerCase();
  if (""String_Node_Str"".equals(appStr)) {
    addPlantPage();
  }
 else {
    removePlantPage();
  }
  return;
}",0.9832535885167464
133666,"/** 
 * Adds a plot to be drawn inside the plot grid. Note that the same plot can be added more than once.
 * @param plot The plot to draw inside the grid.
 * @return The index of the plot in the grid, or -1 if the plot could not bedrawn.
 * @throws Exception An exception is thrown if the  {@link IPlot} implementationcannot be rendered.
 */
public int addPlot(IPlot plot) throws Exception {
  int index=-1;
  if (plot != null && drawnPlots.size() < rows * columns) {
    Map<String,String[]> plotTypes=plot.getPlotTypes();
    String category=null;
    String type=null;
    for (    Entry<String,String[]> entry : plotTypes.entrySet()) {
      category=entry.getKey();
      String[] types=entry.getValue();
      if (category != null && types != null) {
        for (int i=0; i < types.length && type == null; i++) {
          type=types[i];
        }
        if (type != null) {
          break;
        }
      }
    }
    if (category != null && type != null) {
      final DrawnPlot drawnPlot=new DrawnPlot(gridComposite,plot);
      try {
        drawnPlot.draw(category,type);
      }
 catch (      Exception e) {
        drawnPlot.dispose();
      }
      index=drawnPlots.size();
      drawnPlots.add(drawnPlot);
      drawnPlotMap.put(drawnPlot,index);
      drawnPlot.addDisposeListener(plotDisposeListener);
      GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true);
      drawnPlot.setLayoutData(gridData);
      refreshLayout();
    }
  }
  return index;
}","/** 
 * Adds a plot to be drawn inside the plot grid. Note that the same plot can be added more than once.
 * @param plot The plot to draw inside the grid.
 * @return The index of the plot in the grid, or -1 if the plot could not bedrawn.
 * @throws Exception An exception is thrown if the  {@link IPlot} implementationcannot be rendered.
 */
public int addPlot(IPlot plot) throws Exception {
  int index=-1;
  if (plot != null && drawnPlots.size() < rows * columns) {
    Map<String,String[]> plotTypes=plot.getPlotTypes();
    String category=null;
    String type=null;
    for (    Entry<String,String[]> entry : plotTypes.entrySet()) {
      category=entry.getKey();
      String[] types=entry.getValue();
      if (category != null && types != null) {
        for (int i=0; i < types.length && type == null; i++) {
          type=types[i];
        }
        if (type != null) {
          break;
        }
      }
    }
    if (category != null && type != null) {
      final DrawnPlot drawnPlot=new DrawnPlot(gridComposite,plot);
      try {
        drawnPlot.draw(category,type);
      }
 catch (      Exception e) {
        drawnPlot.dispose();
        throw e;
      }
      index=drawnPlots.size();
      drawnPlots.add(drawnPlot);
      drawnPlotMap.put(drawnPlot,index);
      drawnPlot.addDisposeListener(plotDisposeListener);
      GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true);
      drawnPlot.setLayoutData(gridData);
      refreshLayout();
    }
  }
  return index;
}",0.9942933870426316
133667,"private void hideCloseButton(MouseEvent e){
  Control c=null;
  if (e.widget instanceof Composite) {
    c=(Composite)e.widget;
  }
 else {
    c=(Control)e.widget;
  }
  if (c instanceof Composite) {
    for (    Control child : ((Composite)c).getChildren()) {
      if (child.getBounds().contains(new Point(e.x,e.y))) {
        return;
      }
    }
  }
  if (closeButton != null && !closeButton.isDisposed()) {
    closeButton.dispose();
    closeButton=null;
  }
  return;
}","private void hideCloseButton(MouseEvent e){
  if (closeButton != null && !closeButton.isDisposed() && !closeButton.getBounds().contains(e.x,e.y)) {
    closeButton.dispose();
    closeButton=null;
  }
  return;
}",0.2318840579710145
133668,"private void showCloseButton(MouseEvent e){
  Composite comp=(Composite)e.widget;
  if (closeButton == null || closeButton.isDisposed()) {
    closeButton=new Button(comp,SWT.FLAT | SWT.CENTER);
    closeButton.setText(""String_Node_Str"");
    FontData[] smallFont=closeButton.getFont().getFontData();
    for (    FontData fd : smallFont) {
      fd.setHeight(7);
    }
    closeButton.setFont(new Font(comp.getDisplay(),smallFont));
    closeButton.setToolTipText(""String_Node_Str"");
    closeButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        Control c=(Control)e.widget;
        for (        Control plot : gridManager) {
          if (!(plot instanceof EmptyControl) && isChildControl(c,(Composite)plot)) {
            plot.dispose();
            break;
          }
        }
      }
    }
);
    closeButton.pack();
    pageComposite.layout();
  }
  closeButton.setLocation(comp.getBounds().width - closeButton.getBounds().width - 4,0);
  return;
}","private void showCloseButton(MouseEvent e){
  if (closeButton == null || closeButton.isDisposed()) {
    Composite comp=(Composite)e.widget;
    closeButton=new Button(comp,SWT.FLAT | SWT.CENTER);
    closeButton.addMouseTrackListener(closeButtonListener);
    closeButton.setText(""String_Node_Str"");
    FontData[] smallFont=closeButton.getFont().getFontData();
    for (    FontData fd : smallFont) {
      fd.setHeight(7);
    }
    closeButton.setFont(new Font(comp.getDisplay(),smallFont));
    closeButton.setToolTipText(""String_Node_Str"");
    closeButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        Control c=(Control)e.widget;
        for (        Control plot : gridManager) {
          if (!(plot instanceof EmptyControl) && isChildControl(c,(Composite)plot)) {
            plot.dispose();
            break;
          }
        }
      }
    }
);
    closeButton.pack();
    pageComposite.layout();
    closeButton.setLocation(comp.getBounds().width - closeButton.getBounds().width - 4,0);
  }
  return;
}",0.9246704331450094
133669,"@Override public void widgetDisposed(DisposeEvent e){
  Composite c=(Composite)e.widget;
  gridManager.remove(c);
  addEmptyControls(gridComposite);
  Display display=pageComposite.getDisplay();
  display.asyncExec(new Runnable(){
    @Override public void run(){
      if (!pageComposite.isDisposed()) {
        gridComposite.pack();
        drawingComposite.pack();
        pageComposite.layout();
        child.removeMouseTrackListener(closeButtonListener);
      }
      return;
    }
  }
);
}","@Override public void widgetDisposed(DisposeEvent e){
  Composite c=(Composite)e.widget;
  gridManager.remove(c);
  addEmptyControls(gridComposite);
  Display display=pageComposite.getDisplay();
  display.asyncExec(new Runnable(){
    @Override public void run(){
      if (!pageComposite.isDisposed()) {
        gridComposite.pack();
        drawingComposite.pack();
        pageComposite.layout();
      }
      return;
    }
  }
);
}",0.934619506966774
133670,"/** 
 * This method attempts to create a plot   {@code Composite} for the specifiedresource. If one could be created, it will be added to the map of {@link #plotComposites}. <p> <b>Note (1):</b> This method assumes it is called from the UI thread. </p> <p> <b>Note (2):</b> If there is not a corresponding   {@link IPlot} in the mapof  {@link #plots}, no   {@code Composite} will be created.</p>
 * @param parent The parent  {@code Composite} in which to draw the new plot{@code Composite}.
 * @param resource The resource that needs a plot  {@code Composite}.
 * @return The plot {@code Composite}, or   {@code null} if one could not becreated.
 */
private Composite createPlotComposite(Composite parent,VizResource resource){
  Composite plotComposite=null;
  final String key=getPlotKey(resource);
  IPlot plot=plots.get(key);
  if (plot != null) {
    try {
      Map<String,String[]> plotTypes=plot.getPlotTypes();
      String category=null;
      String[] types=null;
      Iterator<Entry<String,String[]>> iter=plotTypes.entrySet().iterator();
      while (iter.hasNext() && (types == null || types.length == 0)) {
        Entry<String,String[]> entry=iter.next();
        category=entry.getKey();
        types=entry.getValue();
      }
      if (types != null && types.length > 0) {
        String plotType=types[0];
        try {
          FormToolkit toolkit=getManagedForm().getToolkit();
          plotComposite=toolkit.createComposite(parent);
          plotComposite.setLayout(new FillLayout());
          plotComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
          final Composite child;
          child=plot.draw(category,plotType,plotComposite);
          parent.pack();
          plotComposites.put(key,plotComposite);
          gridManager.add(plotComposite);
          child.addMouseTrackListener(closeButtonListener);
          plotComposite.addDisposeListener(new DisposeListener(){
            @Override public void widgetDisposed(            DisposeEvent e){
              Composite c=(Composite)e.widget;
              gridManager.remove(c);
              addEmptyControls(gridComposite);
              Display display=pageComposite.getDisplay();
              display.asyncExec(new Runnable(){
                @Override public void run(){
                  if (!pageComposite.isDisposed()) {
                    gridComposite.pack();
                    drawingComposite.pack();
                    pageComposite.layout();
                    child.removeMouseTrackListener(closeButtonListener);
                  }
                  return;
                }
              }
);
            }
          }
);
        }
 catch (        Exception drawException) {
          drawException.printStackTrace();
          plotComposite.dispose();
          plotComposite=null;
        }
      }
    }
 catch (    Exception plotTypeException) {
      plotTypeException.printStackTrace();
    }
  }
  return plotComposite;
}","/** 
 * This method attempts to create a plot   {@code Composite} for the specifiedresource. If one could be created, it will be added to the map of {@link #plotComposites}. <p> <b>Note (1):</b> This method assumes it is called from the UI thread. </p> <p> <b>Note (2):</b> If there is not a corresponding   {@link IPlot} in the mapof  {@link #plots}, no   {@code Composite} will be created.</p>
 * @param parent The parent  {@code Composite} in which to draw the new plot{@code Composite}.
 * @param resource The resource that needs a plot  {@code Composite}.
 * @return The plot {@code Composite}, or   {@code null} if one could not becreated.
 */
private Composite createPlotComposite(Composite parent,VizResource resource){
  Composite plotComposite=null;
  final String key=getPlotKey(resource);
  IPlot plot=plots.get(key);
  if (plot != null) {
    try {
      Map<String,String[]> plotTypes=plot.getPlotTypes();
      String category=null;
      String[] types=null;
      Iterator<Entry<String,String[]>> iter=plotTypes.entrySet().iterator();
      while (iter.hasNext() && (types == null || types.length == 0)) {
        Entry<String,String[]> entry=iter.next();
        category=entry.getKey();
        types=entry.getValue();
      }
      if (types != null && types.length > 0) {
        String plotType=types[0];
        try {
          FormToolkit toolkit=getManagedForm().getToolkit();
          plotComposite=toolkit.createComposite(parent);
          plotComposite.setLayout(new FillLayout());
          plotComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
          final Composite child;
          child=plot.draw(category,plotType,plotComposite);
          parent.pack();
          plotComposites.put(key,plotComposite);
          gridManager.add(plotComposite);
          child.addMouseTrackListener(closeButtonListener);
          plotComposite.addDisposeListener(new DisposeListener(){
            @Override public void widgetDisposed(            DisposeEvent e){
              Composite c=(Composite)e.widget;
              gridManager.remove(c);
              addEmptyControls(gridComposite);
              Display display=pageComposite.getDisplay();
              display.asyncExec(new Runnable(){
                @Override public void run(){
                  if (!pageComposite.isDisposed()) {
                    gridComposite.pack();
                    drawingComposite.pack();
                    pageComposite.layout();
                  }
                  return;
                }
              }
);
            }
          }
);
        }
 catch (        Exception drawException) {
          drawException.printStackTrace();
          plotComposite.dispose();
          plotComposite=null;
        }
      }
    }
 catch (    Exception plotTypeException) {
      plotTypeException.printStackTrace();
    }
  }
  return plotComposite;
}",0.987532023911187
133671,"/** 
 * Adds a plot to be drawn inside the plot grid. Note that the same plot can be added more than once.
 * @param plot The plot to draw inside the grid.
 * @return The index of the plot in the grid, or -1 if the plot could not bedrawn.
 * @throws Exception An exception is thrown if the  {@link IPlot} implementationcannot be rendered.
 */
public int addPlot(IPlot plot) throws Exception {
  int index=-1;
  if (plot != null) {
    Map<String,String[]> plotTypes=plot.getPlotTypes();
    String category=null;
    String type=null;
    for (    Entry<String,String[]> entry : plotTypes.entrySet()) {
      category=entry.getKey();
      String[] types=entry.getValue();
      if (category != null && types != null) {
        for (int i=0; i < types.length && type == null; i++) {
          type=types[i];
        }
        if (type != null) {
          break;
        }
      }
    }
    if (category != null && type != null) {
      Composite composite=new Composite(gridComposite,SWT.NONE);
      DrawnPlot drawnPlot;
      try {
        drawnPlot=new DrawnPlot(plot,composite,category,type);
      }
 catch (      Exception e) {
        composite.dispose();
        throw e;
      }
      drawnPlot.childComposite.addMouseTrackListener(closeButtonListener);
      index=drawnPlots.size();
      drawnPlots.add(drawnPlot);
      refreshLayout();
    }
  }
  return index;
}","/** 
 * Adds a plot to be drawn inside the plot grid. Note that the same plot can be added more than once.
 * @param plot The plot to draw inside the grid.
 * @return The index of the plot in the grid, or -1 if the plot could not bedrawn.
 * @throws Exception An exception is thrown if the  {@link IPlot} implementationcannot be rendered.
 */
public int addPlot(IPlot plot) throws Exception {
  int index=-1;
  if (plot != null) {
    Map<String,String[]> plotTypes=plot.getPlotTypes();
    String category=null;
    String type=null;
    for (    Entry<String,String[]> entry : plotTypes.entrySet()) {
      category=entry.getKey();
      String[] types=entry.getValue();
      if (category != null && types != null) {
        for (int i=0; i < types.length && type == null; i++) {
          type=types[i];
        }
        if (type != null) {
          break;
        }
      }
    }
    if (category != null && type != null) {
      Composite composite=new Composite(gridComposite,SWT.NONE);
      DrawnPlot drawnPlot;
      try {
        drawnPlot=new DrawnPlot(plot,composite,category,type);
      }
 catch (      Exception e) {
        composite.dispose();
        throw e;
      }
      index=drawnPlots.size();
      drawnPlots.add(drawnPlot);
      drawnPlot.childComposite.addMouseTrackListener(closeButtonListener);
      GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true);
      drawnPlot.composite.setLayoutData(gridData);
      drawnPlot.composite.setLayout(new FillLayout());
      refreshLayout();
    }
  }
  return index;
}",0.8712871287128713
133672,"/** 
 * This function is called whenever a Workbench part is closed. If the current   {@link #editor} is closed, then we need to clear the view'scontents.
 */
@Override public void partClosed(IWorkbenchPartReference partRef){
  if (ICEFormEditor.ID.equals(partRef.getId())) {
    ICEFormEditor activeEditor=(ICEFormEditor)partRef.getPart(false);
    if (activeEditor == editor) {
      setActiveEditor(null);
    }
  }
  return;
}","/** 
 * This function is called whenever a Workbench part is closed. If the current   {@link #editor} is closed, then we need to clear the view'scontents.
 */
@Override public void partClosed(IWorkbenchPartReference partRef){
  IWorkbenchPart part=partRef.getPart(false);
  if (part != null && part instanceof ICEFormEditor) {
    ICEFormEditor activeEditor=(ICEFormEditor)partRef.getPart(false);
    if (activeEditor == editor) {
      setActiveEditor(null);
    }
  }
  return;
}",0.8715697036223929
133673,"/** 
 * This function is called whenever a Workbench part gains focus. Here, we are only interested if the part is an ICEFormEditor. When a new ICEFormEditor is activated, sync the view with the activated editor.
 */
@Override public void partActivated(IWorkbenchPartReference partRef){
  if (ICEFormEditor.ID.equals(partRef.getId())) {
    ICEFormEditor activeEditor=(ICEFormEditor)partRef.getPart(false);
    if (activeEditor != editor) {
      setActiveEditor(activeEditor);
    }
  }
  return;
}","/** 
 * This function is called whenever a Workbench part gains focus. Here, we are only interested if the part is an ICEFormEditor. When a new ICEFormEditor is activated, sync the view with the activated editor.
 */
@Override public void partActivated(IWorkbenchPartReference partRef){
  IWorkbenchPart part=partRef.getPart(false);
  if (part != null && part instanceof ICEFormEditor) {
    ICEFormEditor activeEditor=(ICEFormEditor)part;
    if (activeEditor != editor) {
      setActiveEditor(activeEditor);
    }
  }
  return;
}",0.7119301648884578
133674,"@Override public void widgetDisposed(DisposeEvent e){
  Composite c=(Composite)e.widget;
  gridManager.remove(c);
  addEmptyControls(gridComposite);
  Display display=pageComposite.getDisplay();
  display.asyncExec(new Runnable(){
    @Override public void run(){
      gridComposite.pack();
      drawingComposite.pack();
      pageComposite.layout();
    }
  }
);
}","@Override public void widgetDisposed(DisposeEvent e){
  Composite c=(Composite)e.widget;
  gridManager.remove(c);
  addEmptyControls(gridComposite);
  Display display=pageComposite.getDisplay();
  display.asyncExec(new Runnable(){
    @Override public void run(){
      if (!pageComposite.isDisposed()) {
        gridComposite.pack();
        drawingComposite.pack();
        pageComposite.layout();
      }
    }
  }
);
}",0.9226869455006336
133675,"/** 
 * This method attempts to create a plot   {@code Composite} for the specifiedresource. If one could be created, it will be added to the map of {@link #plotComposites}. <p> <b>Note (1):</b> This method assumes it is called from the UI thread. </p> <p> <b>Note (2):</b> If there is not a corresponding   {@link IPlot} in the mapof  {@link #plots}, no   {@code Composite} will be created.</p>
 * @param parent The parent  {@code Composite} in which to draw the new plot{@code Composite}.
 * @param resource The resource that needs a plot  {@code Composite}.
 * @return The plot {@code Composite}, or   {@code null} if one could not becreated.
 */
private Composite createPlotComposite(Composite parent,VizResource resource){
  Composite plotComposite=null;
  final String key=getPlotKey(resource);
  IPlot plot=plots.get(key);
  if (plot != null) {
    try {
      Map<String,String[]> plotTypes=plot.getPlotTypes();
      String category=null;
      String[] types=null;
      Iterator<Entry<String,String[]>> iter=plotTypes.entrySet().iterator();
      while (iter.hasNext() && (types == null || types.length == 0)) {
        Entry<String,String[]> entry=iter.next();
        category=entry.getKey();
        types=entry.getValue();
      }
      if (types != null && types.length > 0) {
        String plotType=types[0];
        try {
          FormToolkit toolkit=getManagedForm().getToolkit();
          plotComposite=toolkit.createComposite(parent);
          plotComposite.setLayout(new FillLayout());
          plotComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
          plot.draw(category,plotType,plotComposite);
          parent.pack();
          plotComposites.put(key,plotComposite);
          gridManager.add(plotComposite);
          plotComposite.addDisposeListener(new DisposeListener(){
            @Override public void widgetDisposed(            DisposeEvent e){
              Composite c=(Composite)e.widget;
              gridManager.remove(c);
              addEmptyControls(gridComposite);
              Display display=pageComposite.getDisplay();
              display.asyncExec(new Runnable(){
                @Override public void run(){
                  gridComposite.pack();
                  drawingComposite.pack();
                  pageComposite.layout();
                }
              }
);
            }
          }
);
          Listener mouseEnterListener=new Listener(){
            @Override public void handleEvent(            Event event){
              showCloseButton(event);
            }
          }
;
          Listener mouseExitListener=new Listener(){
            @Override public void handleEvent(            Event event){
              hideCloseButton(event);
            }
          }
;
          plot.setEventListener(SWT.MouseEnter,mouseEnterListener);
          plot.setEventListener(SWT.MouseExit,mouseExitListener);
        }
 catch (        Exception drawException) {
          drawException.printStackTrace();
          plotComposite.dispose();
          plotComposite=null;
        }
      }
    }
 catch (    Exception plotTypeException) {
      plotTypeException.printStackTrace();
    }
  }
  return plotComposite;
}","/** 
 * This method attempts to create a plot   {@code Composite} for the specifiedresource. If one could be created, it will be added to the map of {@link #plotComposites}. <p> <b>Note (1):</b> This method assumes it is called from the UI thread. </p> <p> <b>Note (2):</b> If there is not a corresponding   {@link IPlot} in the mapof  {@link #plots}, no   {@code Composite} will be created.</p>
 * @param parent The parent  {@code Composite} in which to draw the new plot{@code Composite}.
 * @param resource The resource that needs a plot  {@code Composite}.
 * @return The plot {@code Composite}, or   {@code null} if one could not becreated.
 */
private Composite createPlotComposite(Composite parent,VizResource resource){
  Composite plotComposite=null;
  final String key=getPlotKey(resource);
  IPlot plot=plots.get(key);
  if (plot != null) {
    try {
      Map<String,String[]> plotTypes=plot.getPlotTypes();
      String category=null;
      String[] types=null;
      Iterator<Entry<String,String[]>> iter=plotTypes.entrySet().iterator();
      while (iter.hasNext() && (types == null || types.length == 0)) {
        Entry<String,String[]> entry=iter.next();
        category=entry.getKey();
        types=entry.getValue();
      }
      if (types != null && types.length > 0) {
        String plotType=types[0];
        try {
          FormToolkit toolkit=getManagedForm().getToolkit();
          plotComposite=toolkit.createComposite(parent);
          plotComposite.setLayout(new FillLayout());
          plotComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
          plot.draw(category,plotType,plotComposite);
          parent.pack();
          plotComposites.put(key,plotComposite);
          gridManager.add(plotComposite);
          plotComposite.addDisposeListener(new DisposeListener(){
            @Override public void widgetDisposed(            DisposeEvent e){
              Composite c=(Composite)e.widget;
              gridManager.remove(c);
              addEmptyControls(gridComposite);
              Display display=pageComposite.getDisplay();
              display.asyncExec(new Runnable(){
                @Override public void run(){
                  if (!pageComposite.isDisposed()) {
                    gridComposite.pack();
                    drawingComposite.pack();
                    pageComposite.layout();
                  }
                }
              }
);
            }
          }
);
          Listener mouseEnterListener=new Listener(){
            @Override public void handleEvent(            Event event){
              showCloseButton(event);
            }
          }
;
          Listener mouseExitListener=new Listener(){
            @Override public void handleEvent(            Event event){
              hideCloseButton(event);
            }
          }
;
          plot.setEventListener(SWT.MouseEnter,mouseEnterListener);
          plot.setEventListener(SWT.MouseExit,mouseExitListener);
        }
 catch (        Exception drawException) {
          drawException.printStackTrace();
          plotComposite.dispose();
          plotComposite=null;
        }
      }
    }
 catch (    Exception plotTypeException) {
      plotTypeException.printStackTrace();
    }
  }
  return plotComposite;
}",0.9807306921535378
133676,"public boolean isRemote(){
  return ""String_Node_Str"".equals(getHost());
}","public boolean isRemote(){
  return !(""String_Node_Str"".equals(getHost()));
}",0.9801324503311258
133677,"@Override protected Map<String,String[]> findPlotTypes(URI file) throws IOException, Exception {
  Map<String,String[]> plotTypes=new HashMap<String,String[]>();
  ParaViewConnectionAdapter adapter=getParaViewConnectionAdapter();
  VtkWebClient client=adapter.getConnection();
  List<Object> args=new ArrayList<Object>();
  JSONObject object;
  args.clear();
  args.add(adapter.findRelativePath(file.getPath()));
  object=client.call(""String_Node_Str"",args).get();
  viewId=object.getInt(""String_Node_Str"");
  fileId=object.getInt(""String_Node_Str"");
  repId=object.getInt(""String_Node_Str"");
  args.clear();
  args.add(fileId);
  object=client.call(""String_Node_Str"",args).get();
  JSONArray array=object.getJSONArray(""String_Node_Str"");
  for (int i=0; i < array.length(); i++) {
    object=array.getJSONObject(i);
    String name=object.getString(""String_Node_Str"");
    JSONArray valueArray=object.getJSONArray(""String_Node_Str"");
    String[] values=new String[valueArray.length()];
    for (int j=0; j < values.length; j++) {
      values[j]=valueArray.getString(j);
    }
    plotTypes.put(name,values);
  }
  return plotTypes;
}","@Override protected Map<String,String[]> findPlotTypes(URI file) throws IOException, Exception {
  Map<String,String[]> plotTypes=new HashMap<String,String[]>();
  ParaViewConnectionAdapter adapter=getParaViewConnectionAdapter();
  VtkWebClient client=adapter.getConnection();
  List<Object> args=new ArrayList<Object>();
  JSONObject object;
  args.clear();
  args.add(adapter.findRelativePath(file.getPath()));
  object=client.call(""String_Node_Str"",args).get();
  viewId=object.getInt(""String_Node_Str"");
  fileId=object.getInt(""String_Node_Str"");
  repId=object.getInt(""String_Node_Str"");
  args.clear();
  args.add(fileId);
  object=client.call(""String_Node_Str"",args).get();
  JSONArray array=object.getJSONArray(""String_Node_Str"");
  for (int i=0; i < array.length(); i++) {
    object=array.getJSONObject(i);
    String name=object.getString(""String_Node_Str"");
    if (!""String_Node_Str"".equals(name)) {
      JSONArray valueArray=object.getJSONArray(""String_Node_Str"");
      String[] values=new String[valueArray.length()];
      for (int j=0; j < values.length; j++) {
        values[j]=valueArray.getString(j);
      }
      plotTypes.put(name,values);
    }
  }
  return plotTypes;
}",0.9738534076296612
133678,"/** 
 * Refreshes the widget by activating the associated view (and, of course, it's related file and representation proxies). <p> This method handles the proper JSON RPC to activate the associated view. </p>
 * @param connection The current connection.
 * @throws Exception If the connection is invalid or the command could not be completed.
 */
private void refreshWidget(VtkWebClient connection) throws Exception {
  List<Object> args=new ArrayList<Object>(1);
  args.add(viewId);
  connection.call(""String_Node_Str"",args).get();
}","/** 
 * Refreshes the widget by activating the associated view (and, of course, it's related file and representation proxies). <p> This method handles the proper JSON RPC to activate the associated view. </p>
 * @param render If true, the widget will be re-rendered. If false, then the associated view will only be ""activated"".
 * @param connection The current connection.
 * @throws Exception If the connection is invalid or the command could not be completed.
 */
private void refreshWidget(boolean render,VtkWebClient connection) throws Exception {
  List<Object> args=new ArrayList<Object>(1);
  args.add(viewId);
  connection.call(""String_Node_Str"",args).get();
  if (render) {
    System.out.println(""String_Node_Str"");
    renderPanel.dirty();
  }
  return;
}",0.8215384615384616
133679,"@Override protected Composite createPlotComposite(Composite parent,int style,VtkWebClient connection) throws Exception {
  if (viewId < 0 || fileId < 0 || repId < 0) {
    String fullPath=((ParaViewPlot)plot).getParaViewConnectionAdapter().findRelativePath(plot.getDataSource().getPath());
    List<Object> args=new ArrayList<Object>();
    JSONObject object;
    args.add(fullPath);
    object=connection.call(""String_Node_Str"",args).get();
    viewId=object.getInt(""String_Node_Str"");
    fileId=object.getInt(""String_Node_Str"");
    repId=object.getInt(""String_Node_Str"");
    if (viewId < 0 || fileId < 0 || repId < 0) {
      throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + plot.getVizService().getName() + ""String_Node_Str"");
    }
  }
  Composite plotContainer=new Composite(parent,style);
  plotContainer.setBackground(parent.getBackground());
  plotContainer.setFont(parent.getFont());
  GridLayout gridLayout=new GridLayout();
  gridLayout.marginWidth=0;
  gridLayout.marginHeight=0;
  plotContainer.setLayout(gridLayout);
  ToolBarManager toolBarManager=new ToolBarManager();
  this.toolBar=toolBarManager;
  ToolBar toolBar=toolBarManager.createControl(plotContainer);
  toolBar.setBackground(parent.getBackground());
  toolBar.setFont(parent.getFont());
  toolBar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  fillToolBar(toolBarManager,connection);
  final Composite composite=new Composite(plotContainer,SWT.EMBEDDED | SWT.DOUBLE_BUFFERED);
  composite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  final InteractiveRenderPanel renderPanel=new InteractiveRenderPanel(connection,viewId,4,80,1);
  Frame frame=SWT_AWT.new_Frame(composite);
  frame.setLayout(new BorderLayout());
  frame.add(renderPanel,BorderLayout.CENTER);
  composite.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent e){
      renderPanel.dirty();
    }
  }
);
  return plotContainer;
}","@Override protected Composite createPlotComposite(Composite parent,int style,VtkWebClient connection) throws Exception {
  if (viewId < 0 || fileId < 0 || repId < 0) {
    String fullPath=((ParaViewPlot)plot).getParaViewConnectionAdapter().findRelativePath(plot.getDataSource().getPath());
    List<Object> args=new ArrayList<Object>();
    JSONObject object;
    args.add(fullPath);
    object=connection.call(""String_Node_Str"",args).get();
    viewId=object.getInt(""String_Node_Str"");
    fileId=object.getInt(""String_Node_Str"");
    repId=object.getInt(""String_Node_Str"");
    if (viewId < 0 || fileId < 0 || repId < 0) {
      throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + plot.getVizService().getName() + ""String_Node_Str"");
    }
  }
  Composite plotContainer=new Composite(parent,style);
  plotContainer.setBackground(parent.getBackground());
  plotContainer.setFont(parent.getFont());
  GridLayout gridLayout=new GridLayout();
  gridLayout.marginWidth=0;
  gridLayout.marginHeight=0;
  plotContainer.setLayout(gridLayout);
  ToolBarManager toolBarManager=new ToolBarManager();
  this.toolBar=toolBarManager;
  ToolBar toolBar=toolBarManager.createControl(plotContainer);
  toolBar.setBackground(parent.getBackground());
  toolBar.setFont(parent.getFont());
  toolBar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  fillToolBar(toolBarManager,connection);
  final Composite composite=new Composite(plotContainer,SWT.EMBEDDED | SWT.DOUBLE_BUFFERED);
  composite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  renderPanel=new InteractiveRenderPanel(connection,viewId,4,80,1);
  Frame frame=SWT_AWT.new_Frame(composite);
  frame.setLayout(new BorderLayout());
  frame.add(renderPanel,BorderLayout.CENTER);
  composite.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent e){
      renderPanel.dirty();
    }
  }
);
  refreshWidget(true,connection);
  return plotContainer;
}",0.9839408615855212
133680,"/** 
 * Refreshes the current plot category and type. <p> This method handles the proper JSON RPC to change the plot contents for the associated view. </p>
 * @param plotType The new plot type.
 * @param connection The current connection.
 * @throws Exception If the connection is invalid or the command could not be completed.
 */
private void refreshPlotType(String plotType,VtkWebClient connection) throws Exception {
  List<Object> args=new ArrayList<Object>();
  JSONObject object;
  JSONArray updatedProperties=new JSONArray();
  JSONObject pointStatusProperty=new JSONObject();
  pointStatusProperty.put(""String_Node_Str"",Integer.toString(fileId));
  pointStatusProperty.put(""String_Node_Str"",""String_Node_Str"");
  JSONArray pointArrays=new JSONArray();
  pointArrays.put(plotType);
  pointStatusProperty.put(""String_Node_Str"",pointArrays);
  updatedProperties.put(pointStatusProperty);
  args.add(updatedProperties);
  object=connection.call(""String_Node_Str"",args).get();
  if (!object.getBoolean(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    JSONArray array=object.getJSONArray(""String_Node_Str"");
    for (int i=0; i < array.length(); i++) {
      System.out.println(array.get(i));
    }
  }
  args.clear();
  args.add(Integer.toString(repId));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(plotType);
  args.add(""String_Node_Str"");
  args.add(0);
  args.add(true);
  object=connection.call(""String_Node_Str"",args).get();
  args.clear();
  JSONObject legendVisibilities=new JSONObject();
  legendVisibilities.put(Integer.toString(fileId),true);
  args.add(legendVisibilities);
  object=connection.call(""String_Node_Str"",args).get();
  System.out.println(object.toString(4));
  args.clear();
  JSONObject scaleOptions=new JSONObject();
  scaleOptions.put(""String_Node_Str"",""String_Node_Str"");
  scaleOptions.put(""String_Node_Str"",fileId);
  args.add(scaleOptions);
  object=connection.call(""String_Node_Str"",args).get();
  System.out.println(object.toString(4));
  return;
}","/** 
 * Refreshes the current plot category and type. <p> This method handles the proper JSON RPC to change the plot contents for the associated view. </p>
 * @param plotType The new plot type.
 * @param connection The current connection.
 * @throws Exception If the connection is invalid or the command could not be completed.
 */
private void refreshPlotType(String plotCategory,String plotType,VtkWebClient connection) throws Exception {
  List<Object> args=new ArrayList<Object>();
  JSONObject object;
  JSONArray updatedProperties=new JSONArray();
  JSONObject statusProperty;
  JSONArray array;
  if (this.plotCategory != null) {
    statusProperty=new JSONObject();
    statusProperty.put(""String_Node_Str"",Integer.toString(fileId));
    statusProperty.put(""String_Node_Str"",plotTypeArrays.get(this.plotCategory));
    array=new JSONArray();
    statusProperty.put(""String_Node_Str"",array);
    updatedProperties.put(statusProperty);
  }
  statusProperty=new JSONObject();
  statusProperty.put(""String_Node_Str"",Integer.toString(fileId));
  statusProperty.put(""String_Node_Str"",plotTypeArrays.get(plotCategory));
  array=new JSONArray();
  array.put(plotType);
  statusProperty.put(""String_Node_Str"",array);
  updatedProperties.put(statusProperty);
  args.add(updatedProperties);
  object=connection.call(""String_Node_Str"",args).get();
  if (!object.getBoolean(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    array=object.getJSONArray(""String_Node_Str"");
    for (int i=0; i < array.length(); i++) {
      System.out.println(array.get(i));
    }
  }
  args.clear();
  args.add(Integer.toString(repId));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(plotType);
  args.add(""String_Node_Str"");
  args.add(0);
  args.add(true);
  object=connection.call(""String_Node_Str"",args).get();
  args.clear();
  args.add(viewId);
  connection.call(""String_Node_Str"",args).get();
  args.clear();
  JSONObject legendVisibilities=new JSONObject();
  legendVisibilities.put(Integer.toString(fileId),true);
  args.add(legendVisibilities);
  object=connection.call(""String_Node_Str"",args).get();
  System.out.println(object.toString(4));
  args.clear();
  JSONObject scaleOptions=new JSONObject();
  scaleOptions.put(""String_Node_Str"",""String_Node_Str"");
  scaleOptions.put(""String_Node_Str"",fileId);
  args.add(scaleOptions);
  object=connection.call(""String_Node_Str"",args).get();
  System.out.println(object.toString(4));
  return;
}",0.7447847314691523
133681,"@Override protected void updatePlotComposite(Composite plotComposite,VtkWebClient connection) throws Exception {
  refreshToolBar(toolBar);
  final String representation=getPlotRepresentation();
  boolean representationChanged=(representation != null && !representation.equals(plotRepresentation) && getPlotRepresentations().contains(representation));
  final String category=getPlotCategory();
  final String type=getPlotType();
  boolean plotTypeChanged=((category != null && !category.equals(plotCategory)) || (type != null && !type.equals(plotType)));
  if (plotTypeChanged && type != null) {
    plotTypeChanged=false;
    String[] types=plot.getPlotTypes().get(category);
    if (types != null) {
      for (int i=0; !plotTypeChanged && i < types.length; i++) {
        if (type.equals(types[i])) {
          plotTypeChanged=true;
        }
      }
    }
  }
  if (representationChanged || plotTypeChanged) {
    refreshWidget(connection);
  }
  if (representationChanged) {
    plotRepresentation=representation;
    refreshRepresentation(representation,connection);
  }
  if (plotTypeChanged) {
    if (category != null) {
      plotCategory=category;
    }
    if (type != null) {
      plotType=type;
    }
    refreshPlotType(type,connection);
  }
  if (representationChanged || plotTypeChanged) {
    refreshWidget(connection);
  }
  return;
}","@Override protected void updatePlotComposite(Composite plotComposite,VtkWebClient connection) throws Exception {
  refreshToolBar(toolBar);
  final String representation=getPlotRepresentation();
  boolean representationChanged=(representation != null && !representation.equals(plotRepresentation) && getPlotRepresentations().contains(representation));
  final String category=getPlotCategory();
  final String type=getPlotType();
  boolean plotTypeChanged=((category != null && !category.equals(plotCategory)) || (type != null && !type.equals(plotType)));
  if (plotTypeChanged && type != null) {
    plotTypeChanged=false;
    String[] types=plot.getPlotTypes().get(category);
    if (types != null) {
      for (int i=0; !plotTypeChanged && i < types.length; i++) {
        if (type.equals(types[i])) {
          plotTypeChanged=true;
        }
      }
    }
  }
  if (representationChanged || plotTypeChanged) {
    refreshWidget(false,connection);
  }
  if (representationChanged) {
    refreshRepresentation(representation,connection);
    plotRepresentation=representation;
  }
  if (plotTypeChanged) {
    refreshPlotType(category,type,connection);
    if (category != null) {
      plotCategory=category;
    }
    if (type != null) {
      plotType=type;
    }
  }
  if (representationChanged || plotTypeChanged) {
    refreshWidget(true,connection);
  }
  return;
}",0.8322344322344323
133682,"/** 
 * The full constructor. <i>This should only be called once per plot so that the view created to read the file's contents is not wasted.</i>
 * @param parent The parent Composite that contains the plot render.
 * @param plot The rendered ConnectionPlot. This cannot be changed.
 * @param viewId The ID of the view that was created to read the file's contents, or -1 to indicate that a view has not been created.
 * @param repId The ID of the representation (i.e., the render properties) of the file.
 */
public ParaViewPlotRender(Composite parent,ParaViewPlot plot,int viewId,int fileId,int repId){
  super(parent,plot);
  this.viewId=viewId;
  this.fileId=fileId;
  this.repId=repId;
  this.adapter=plot.getParaViewConnectionAdapter();
  return;
}","/** 
 * The full constructor. <i>This should only be called once per plot so that the view created to read the file's contents is not wasted.</i>
 * @param parent The parent Composite that contains the plot render.
 * @param plot The rendered ConnectionPlot. This cannot be changed.
 * @param viewId The ID of the view that was created to read the file's contents, or -1 to indicate that a view has not been created.
 * @param repId The ID of the representation (i.e., the render properties) of the file.
 */
public ParaViewPlotRender(Composite parent,ParaViewPlot plot,int viewId,int fileId,int repId){
  super(parent,plot);
  this.viewId=viewId;
  this.fileId=fileId;
  this.repId=repId;
  this.adapter=plot.getParaViewConnectionAdapter();
  plotTypeArrays=new HashMap<String,String>();
  plotTypeArrays.put(""String_Node_Str"",""String_Node_Str"");
  plotTypeArrays.put(""String_Node_Str"",""String_Node_Str"");
  plotTypeArrays.put(""String_Node_Str"",""String_Node_Str"");
  plotTypeArrays.put(""String_Node_Str"",""String_Node_Str"");
  return;
}",0.8362213527110117
133683,"@Override protected void disposePlotComposite(Composite plotComposite){
  if (plotTypeTree != null) {
    plotTypeTree.dispose();
    plotTypeTree=null;
  }
  if (representationTree != null) {
    representationTree.dispose();
    representationTree=null;
  }
  return;
}","@Override protected void disposePlotComposite(Composite plotComposite){
  if (plotTypeTree != null) {
    plotTypeTree.dispose();
    plotTypeTree=null;
  }
  if (representationTree != null) {
    representationTree.dispose();
    representationTree=null;
  }
  renderPanel=null;
  return;
}",0.9644128113879004
133684,"/** 
 * Creates the content used for the mesh view.
 * @param section The  {@code Section} that should contain the mesh view.
 * @param toolkit The  {@code FormToolkit} used to decorate widgets as necessary.
 */
private void populateMeshViewSection(Section section,FormToolkit toolkit){
  section.setText(""String_Node_Str"");
  section.setDescription(""String_Node_Str"");
  Composite container=toolkit.createComposite(section,SWT.NONE);
  section.setClient(container);
  container.setLayout(new GridLayout(1,false));
  ToolBarManager toolBarManager=new ToolBarManager();
  ToolBar toolBar=toolBarManager.createControl(container);
  toolkit.adapt(toolBar);
  toolBar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  meshPlotParent=toolkit.createComposite(container,SWT.BORDER);
  meshPlotParent.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  IVizServiceFactory vizFactory=getVizServiceFactory();
  if (vizFactory != null) {
    vizService=(ParaViewVizService)vizFactory.get(""String_Node_Str"");
  }
  if (vizService != null) {
    meshPlotParent.setLayout(new FillLayout());
    try {
      plot=(ParaViewPlot)vizService.createPlot(meshURI);
      toolBarManager.update(true);
      plot.draw(""String_Node_Str"",""String_Node_Str"",meshPlotParent);
      final Composite parent0=new Composite(meshPlotParent,SWT.NONE);
      Composite parent1=new Composite(meshPlotParent,SWT.NONE);
      Composite parent2=new Composite(meshPlotParent,SWT.NONE);
      plot.draw(""String_Node_Str"",""String_Node_Str"",parent0);
      plot.draw(""String_Node_Str"",""String_Node_Str"",parent1);
      plot.draw(""String_Node_Str"",""String_Node_Str"",parent2);
      Thread thread=new Thread(){
        @Override public void run(){
          try {
            Thread.sleep(4000);
            plot.draw(""String_Node_Str"",""String_Node_Str"",parent0);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
;
      thread.start();
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
 else {
    String errorMessage=""String_Node_Str"" + ""String_Node_Str"";
    meshPlotParent.setLayout(new GridLayout(2,false));
    Label iconLabel=toolkit.createLabel(meshPlotParent,""String_Node_Str"");
    iconLabel.setImage(Display.getCurrent().getSystemImage(SWT.ICON_ERROR));
    iconLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.BEGINNING,false,false));
    Label msgLabel=toolkit.createLabel(meshPlotParent,errorMessage);
    msgLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.CENTER,false,false));
  }
  section.setClient(container);
  return;
}","/** 
 * Creates the content used for the mesh view.
 * @param section The  {@code Section} that should contain the mesh view.
 * @param toolkit The  {@code FormToolkit} used to decorate widgets as necessary.
 */
private void populateMeshViewSection(Section section,FormToolkit toolkit){
  section.setText(""String_Node_Str"");
  section.setDescription(""String_Node_Str"");
  Composite container=toolkit.createComposite(section,SWT.NONE);
  section.setClient(container);
  container.setLayout(new GridLayout(1,false));
  ToolBarManager toolBarManager=new ToolBarManager();
  ToolBar toolBar=toolBarManager.createControl(container);
  toolkit.adapt(toolBar);
  toolBar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  meshPlotParent=toolkit.createComposite(container,SWT.BORDER);
  meshPlotParent.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  IVizServiceFactory vizFactory=getVizServiceFactory();
  if (vizFactory != null) {
    vizService=(ParaViewVizService)vizFactory.get(""String_Node_Str"");
  }
  if (vizService != null) {
    meshPlotParent.setLayout(new FillLayout());
    try {
      plot=(ParaViewPlot)vizService.createPlot(meshURI);
      toolBarManager.update(true);
      plot.draw(""String_Node_Str"",""String_Node_Str"",meshPlotParent);
      final Composite parent0=new Composite(meshPlotParent,SWT.NONE);
      Composite parent1=new Composite(meshPlotParent,SWT.NONE);
      Composite parent2=new Composite(meshPlotParent,SWT.NONE);
      parent0.setLayout(new FillLayout());
      parent1.setLayout(new FillLayout());
      parent2.setLayout(new FillLayout());
      plot.draw(""String_Node_Str"",""String_Node_Str"",parent0);
      plot.draw(""String_Node_Str"",""String_Node_Str"",parent1);
      plot.draw(""String_Node_Str"",""String_Node_Str"",parent2);
      Thread thread=new Thread(){
        @Override public void run(){
          try {
            Thread.sleep(4000);
            plot.draw(""String_Node_Str"",""String_Node_Str"",parent0);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
;
      thread.start();
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
 else {
    String errorMessage=""String_Node_Str"" + ""String_Node_Str"";
    meshPlotParent.setLayout(new GridLayout(2,false));
    Label iconLabel=toolkit.createLabel(meshPlotParent,""String_Node_Str"");
    iconLabel.setImage(Display.getCurrent().getSystemImage(SWT.ICON_ERROR));
    iconLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.BEGINNING,false,false));
    Label msgLabel=toolkit.createLabel(meshPlotParent,errorMessage);
    msgLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.CENTER,false,false));
  }
  section.setClient(container);
  return;
}",0.9770911028236547
133685,"/** 
 * This operations loads a MOOSE GetPot file at the specified path and returns a fully-configured set of ICE TreeComposites.
 * @param filePath The file path from which the MOOSE blocks written in GetPot should be read. If the path is null or empty, the operation returns without doing any work.
 * @return The MOOSE input file specification as read from the GetPot inputand stored in TreeComposites. Each TreeComposite contains both parameters and exemplar children. Any parameters in a TreeComposite are contained in a DataComponent. The id of the data component is 1.
 */
public ArrayList<TreeComposite> loadFromGetPot(String filePath){
  ArrayList<TreeComposite> trees=new ArrayList<TreeComposite>();
  byte[] fileByteArray=null;
  String mooseFileString=null, potLine=null;
  if (filePath == null || filePath.isEmpty()) {
    return null;
  }
  if (debugFlag) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath);
  }
  try {
    RandomAccessFile mooseFile=new RandomAccessFile(filePath,""String_Node_Str"");
    fileByteArray=new byte[(int)mooseFile.length()];
    mooseFile.read(fileByteArray);
    mooseFileString=new String(fileByteArray);
    mooseFile.close();
    if (debugFlag) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  if (mooseFileString != null && !mooseFileString.isEmpty()) {
    ArrayList<String> potLines=new ArrayList<String>(Arrays.asList(mooseFileString.split(""String_Node_Str"")));
    String trimmedPotLine=""String_Node_Str"";
    for (int i=0; i < potLines.size(); i++) {
      trimmedPotLine=potLines.get(i).trim();
      if (trimmedPotLine.startsWith(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"")&& !trimmedPotLine.contains(""String_Node_Str"")) {
        potLines.remove(i);
        --i;
      }
 else       if (potLines.get(i).isEmpty()) {
        potLines.remove(i);
        --i;
      }
 else {
        potLines.set(i,potLines.get(i).trim());
      }
    }
    int counter=0, endCounter=1;
    while (counter < potLines.size()) {
      potLine=potLines.get(counter);
      ++counter;
      if (potLine.contains(""String_Node_Str"") && potLine.contains(""String_Node_Str"")) {
        potLine=potLines.get(endCounter);
        while (!potLine.contains(""String_Node_Str"")) {
          potLine=potLines.get(endCounter);
          ++endCounter;
        }
        Block block=new Block();
        ArrayList<String> blockLines=new ArrayList<String>(potLines.subList(counter - 1,endCounter));
        StringBuilder stringBuilder=new StringBuilder(blockLines.get(0));
        blockLines.set(0,stringBuilder.toString());
        block.fromGetPot(blockLines);
        trees.add(block.toTreeComposite());
        counter=endCounter;
        if (debugFlag) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
          for (          String line : blockLines) {
            System.out.println(line);
          }
        }
      }
    }
  }
 else   if (debugFlag) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
  }
  return trees;
}","/** 
 * This operations loads a MOOSE GetPot file at the specified path and returns a fully-configured set of ICE TreeComposites.
 * @param filePath The file path from which the MOOSE blocks written in GetPot should be read. If the path is null or empty, the operation returns without doing any work.
 * @return The MOOSE input file specification as read from the GetPot inputand stored in TreeComposites. Each TreeComposite contains both parameters and exemplar children. Any parameters in a TreeComposite are contained in a DataComponent. The id of the data component is 1.
 */
public ArrayList<TreeComposite> loadFromGetPot(String filePath){
  ArrayList<TreeComposite> trees=new ArrayList<TreeComposite>();
  byte[] fileByteArray=null;
  String mooseFileString=null, potLine=null;
  if (filePath == null || filePath.isEmpty()) {
    return null;
  }
  if (debugFlag) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath);
  }
  try {
    RandomAccessFile mooseFile=new RandomAccessFile(filePath,""String_Node_Str"");
    fileByteArray=new byte[(int)mooseFile.length()];
    mooseFile.read(fileByteArray);
    mooseFileString=new String(fileByteArray);
    mooseFile.close();
    if (debugFlag) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  if (mooseFileString != null && !mooseFileString.isEmpty()) {
    ArrayList<String> potLines=new ArrayList<String>(Arrays.asList(mooseFileString.split(""String_Node_Str"")));
    String trimmedPotLine=""String_Node_Str"";
    for (int i=0; i < potLines.size(); i++) {
      trimmedPotLine=potLines.get(i).trim();
      if (trimmedPotLine.startsWith(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"") && !trimmedPotLine.contains(""String_Node_Str"")&& !trimmedPotLine.contains(""String_Node_Str"")) {
        potLines.remove(i);
        --i;
      }
 else       if (potLines.get(i).isEmpty()) {
        potLines.remove(i);
        --i;
      }
 else {
        if (trimmedPotLine.startsWith(""String_Node_Str"") && trimmedPotLine.contains(""String_Node_Str"")) {
          String[] splitTrimmedPotLine=trimmedPotLine.split(""String_Node_Str"");
          if (splitTrimmedPotLine.length > 4) {
            potLines.remove(i);
            --i;
            continue;
          }
        }
        potLines.set(i,potLines.get(i).trim());
      }
    }
    int counter=0, endCounter=1;
    while (counter < potLines.size()) {
      potLine=potLines.get(counter);
      ++counter;
      if (potLine.contains(""String_Node_Str"") && potLine.contains(""String_Node_Str"")) {
        potLine=potLines.get(endCounter);
        while (!potLine.contains(""String_Node_Str"")) {
          potLine=potLines.get(endCounter);
          ++endCounter;
        }
        Block block=new Block();
        ArrayList<String> blockLines=new ArrayList<String>(potLines.subList(counter - 1,endCounter));
        StringBuilder stringBuilder=new StringBuilder(blockLines.get(0));
        blockLines.set(0,stringBuilder.toString());
        block.fromGetPot(blockLines);
        trees.add(block.toTreeComposite());
        counter=endCounter;
        if (debugFlag) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
          for (          String line : blockLines) {
            System.out.println(line);
          }
        }
      }
    }
  }
 else   if (debugFlag) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + filePath + ""String_Node_Str"");
  }
  return trees;
}",0.9523809523809524
133686,"/** 
 * Load the data for a component that was listed in the ports table and return the information as a DataComponent. Each parameter in the component is added to the DataComponent as an entry.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return A DataComponent containing information for one of the portentries.
 */
private DataComponent loadComponent(Iterator<String> it){
  DataComponent portComponent=new DataComponent();
  Entry entry;
  String[] splitLine=null;
  String line=it.next();
  while (!line.contains(""String_Node_Str"") && !line.contains(""String_Node_Str"") && it.hasNext()) {
    line=it.next();
  }
  String portName=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
  portComponent.setName(portName);
  portComponent.setDescription(""String_Node_Str"");
  portComponent.setId(currID);
  currID++;
  while (line.trim().length() > 0) {
    if (line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
      }
      splitLine=line.split(""String_Node_Str"",2);
      entry=makeIPSEntry();
      entry.setName(splitLine[0]);
      entry.setValue(splitLine[1]);
      entry.setId(currID);
      currID++;
      portComponent.addEntry(entry);
    }
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  return portComponent;
}","/** 
 * Load the data for a component that was listed in the ports table and return the information as a DataComponent. Each parameter in the component is added to the DataComponent as an entry.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return A DataComponent containing information for one of the portentries.
 */
private DataComponent loadComponent(Iterator<String> it){
  DataComponent portComponent=new DataComponent();
  Entry entry;
  String[] splitLine=null;
  String line=it.next();
  while (!line.contains(""String_Node_Str"") && !line.contains(""String_Node_Str"") && it.hasNext()) {
    line=it.next();
  }
  String portName=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
  portComponent.setName(portName);
  portComponent.setDescription(""String_Node_Str"");
  portComponent.setId(currID);
  currID++;
  if (portComponent.getName().equals(""String_Node_Str"")) {
    return portComponent;
  }
  while (line.trim().length() > 0) {
    if (line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
      }
      splitLine=line.split(""String_Node_Str"",2);
      entry=makeIPSEntry();
      entry.setName(splitLine[0]);
      entry.setValue(splitLine[1]);
      entry.setId(currID);
      currID++;
      portComponent.addEntry(entry);
    }
    line=it.next();
  }
  if (!it.hasNext()) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  return portComponent;
}",0.9696142027995904
133687,"/** 
 * <p> Reads in the given IFile to the CaebatModel datastructures. There are four components in each IPS INI file that are parsed and arranged into the form that will be displayed to the user. Returns a form composed of the data read in from the specified location which can be modified and written out by the user. </p>
 * @param ifile The file to be read in
 * @return a form with the imported data
 */
@Override public Form read(IFile ifile){
  if (ifile == null) {
    return null;
  }
  Form form=new Form();
  ArrayList<String> lines=null;
  try {
    lines=readFileLines(ifile);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return null;
  }
catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  Iterator<String> iniIterator=lines.iterator();
  TableComponent globalConfiguration=loadGlobalConfiguration(iniIterator);
  TableComponent portsData=loadPortsData(iniIterator);
  int numberPorts=portsData.numberOfRows();
  ArrayList<DataComponent> ipsComponents=new ArrayList<DataComponent>();
  ArrayList<String> names=new ArrayList<String>();
  for (int i=0; i < numberPorts; i++) {
    DataComponent ipsComponent=loadComponent(iniIterator);
    ipsComponents.add(ipsComponent);
    names.add(ipsComponent.getName());
  }
  MasterDetailsComponent portsMaster=buildMasterDetailsComponent(ipsComponents);
  DataComponent timeLoopComponent=loadTimeLoopComponent(iniIterator);
  form.addComponent(timeLoopComponent);
  form.addComponent(globalConfiguration);
  form.addComponent(portsData);
  form.addComponent(portsMaster);
  return form;
}","/** 
 * <p> Reads in the given IFile to the CaebatModel datastructures. There are four components in each IPS INI file that are parsed and arranged into the form that will be displayed to the user. Returns a form composed of the data read in from the specified location which can be modified and written out by the user. </p>
 * @param ifile The file to be read in
 * @return a form with the imported data
 */
@Override public Form read(IFile ifile){
  if (ifile == null) {
    return null;
  }
  Form form=new Form();
  ArrayList<String> lines=null;
  try {
    lines=readFileLines(ifile);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return null;
  }
catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  Iterator<String> iniIterator=lines.iterator();
  TableComponent globalConfiguration=loadGlobalConfiguration(iniIterator);
  TableComponent portsData=loadPortsData(iniIterator);
  int numberPorts=portsData.numberOfRows();
  ArrayList<DataComponent> ipsComponents=new ArrayList<DataComponent>();
  ArrayList<String> names=new ArrayList<String>();
  String name=""String_Node_Str"";
  while (!name.equals(""String_Node_Str"")) {
    DataComponent ipsComponent=loadComponent(iniIterator);
    name=ipsComponent.getName();
    if (!name.equals(""String_Node_Str"")) {
      ipsComponents.add(ipsComponent);
      names.add(ipsComponent.getName());
    }
  }
  MasterDetailsComponent portsMaster=buildMasterDetailsComponent(ipsComponents);
  DataComponent timeLoopComponent=loadTimeLoopComponent(iniIterator);
  form.addComponent(timeLoopComponent);
  form.addComponent(globalConfiguration);
  form.addComponent(portsData);
  form.addComponent(portsMaster);
  return form;
}",0.9150133254367782
133688,"/** 
 * Load the Time Loop Data from the INI file and return the data as a DataComponent. Each parameter in the section is added to the DataComponent as an Entry.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return a DataComponent of Entries containing the information from theTime Loop Component of the INI file.
 */
private DataComponent loadTimeLoopComponent(Iterator<String> it){
  DataComponent timeLoopData=new DataComponent();
  Entry entry;
  String[] splitLine=null;
  String line=""String_Node_Str"";
  if (it.hasNext()) {
    line=it.next();
  }
 else {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  while (!line.contains(""String_Node_Str"") && it.hasNext()) {
    line=it.next();
  }
  timeLoopData.setName(""String_Node_Str"");
  timeLoopData.setDescription(""String_Node_Str"");
  timeLoopData.setId(currID);
  currID++;
  while (it.hasNext()) {
    if (line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
      }
      splitLine=line.split(""String_Node_Str"",2);
      entry=makeIPSEntry();
      entry.setName(splitLine[0]);
      entry.setValue(splitLine[1]);
      entry.setId(currID);
      currID++;
      timeLoopData.addEntry(entry);
    }
    line=it.next();
  }
  return timeLoopData;
}","/** 
 * Load the Time Loop Data from the INI file and return the data as a DataComponent. Each parameter in the section is added to the DataComponent as an Entry.
 * @param it Iterator over the lines of the INI file as an ArrayList
 * @return a DataComponent of Entries containing the information from theTime Loop Component of the INI file.
 */
private DataComponent loadTimeLoopComponent(Iterator<String> it){
  DataComponent timeLoopData=new DataComponent();
  Entry entry;
  String[] splitLine=null;
  String line=""String_Node_Str"";
  if (it.hasNext()) {
    line=it.next();
  }
 else {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return null;
  }
  timeLoopData.setName(""String_Node_Str"");
  timeLoopData.setDescription(""String_Node_Str"");
  timeLoopData.setId(currID);
  currID++;
  while (it.hasNext()) {
    if (line.contains(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"",2)[0];
      }
      splitLine=line.split(""String_Node_Str"",2);
      entry=makeIPSEntry();
      entry.setName(splitLine[0]);
      entry.setValue(splitLine[1]);
      entry.setId(currID);
      currID++;
      timeLoopData.addEntry(entry);
    }
    line=it.next();
  }
  return timeLoopData;
}",0.9675716440422324
133689,"@Override public void createControl(Composite parent){
  if (parent != null) {
    GridData gridData;
    wizardPageComposite=new Composite(parent,SWT.NONE);
    wizardPageComposite.setLayout(new GridLayout(2,false));
    Label fileLabel=new Label(wizardPageComposite,SWT.NONE);
    fileLabel.setText(""String_Node_Str"");
    gridData=new GridData(SWT.LEFT,SWT.END,false,false);
    gridData.horizontalSpan=2;
    fileLabel.setLayoutData(gridData);
    final Text fileText=new Text(wizardPageComposite,SWT.NONE | SWT.BORDER);
    fileText.setEditable(false);
    fileText.setLayoutData(new GridData(SWT.FILL,SWT.BEGINNING,true,true));
    Button browseButton=new Button(wizardPageComposite,SWT.NONE);
    browseButton.setLayoutData(new GridData(SWT.RIGHT,SWT.BEGINNING,false,true));
    browseButton.setText(""String_Node_Str"");
    final Shell shell=parent.getShell();
    browseButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        FileDialog fileDialog=new FileDialog(shell,fileDialogStyle);
        fileDialog.setText(""String_Node_Str"");
        fileDialog.open();
        selectedFileNames.clear();
        for (        String fileName : fileDialog.getFileNames()) {
          selectedFileNames.add(fileName);
        }
        filterPath=fileDialog.getFilterPath();
        int numFiles=selectedFileNames.size();
        if (numFiles == 1) {
          fileText.setText(filterPath + System.getProperty(""String_Node_Str"") + selectedFileNames.get(0));
        }
 else         if (numFiles > 1) {
          String text=""String_Node_Str"" + selectedFileNames.get(0) + ""String_Node_Str"";
          for (int i=1; i < selectedFileNames.size(); i++) {
            text+=""String_Node_Str"" + selectedFileNames.get(i) + ""String_Node_Str"";
          }
          fileText.setText(text);
        }
        setPageComplete(checkSelection());
        return;
      }
    }
);
    setControl(wizardPageComposite);
    setPageComplete(false);
  }
  return;
}","@Override public void createControl(Composite parent){
  if (parent != null) {
    GridData gridData;
    wizardPageComposite=new Composite(parent,SWT.NONE);
    wizardPageComposite.setLayout(new GridLayout(2,false));
    Label fileLabel=new Label(wizardPageComposite,SWT.NONE);
    fileLabel.setText(""String_Node_Str"");
    gridData=new GridData(SWT.LEFT,SWT.END,false,false);
    gridData.horizontalSpan=2;
    fileLabel.setLayoutData(gridData);
    gridData=new GridData(SWT.FILL,SWT.BEGINNING,true,true);
    gridData.minimumHeight=30;
    final Text fileText=new Text(wizardPageComposite,SWT.NONE | SWT.BORDER);
    fileText.setEditable(false);
    fileText.setLayoutData(gridData);
    gridData=new GridData(SWT.RIGHT,SWT.BEGINNING,false,true);
    gridData.minimumHeight=30;
    Button browseButton=new Button(wizardPageComposite,SWT.NONE);
    browseButton.setLayoutData(gridData);
    browseButton.setText(""String_Node_Str"");
    final Shell shell=parent.getShell();
    browseButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        FileDialog fileDialog=new FileDialog(shell,fileDialogStyle);
        fileDialog.setText(""String_Node_Str"");
        fileDialog.open();
        selectedFileNames.clear();
        for (        String fileName : fileDialog.getFileNames()) {
          selectedFileNames.add(fileName);
        }
        filterPath=fileDialog.getFilterPath();
        int numFiles=selectedFileNames.size();
        if (numFiles == 1) {
          fileText.setText(filterPath + System.getProperty(""String_Node_Str"") + selectedFileNames.get(0));
        }
 else         if (numFiles > 1) {
          String text=""String_Node_Str"" + selectedFileNames.get(0) + ""String_Node_Str"";
          for (int i=1; i < selectedFileNames.size(); i++) {
            text+=""String_Node_Str"" + selectedFileNames.get(i) + ""String_Node_Str"";
          }
          fileText.setText(text);
        }
        setPageComplete(checkSelection());
        return;
      }
    }
);
    setControl(wizardPageComposite);
    setPageComplete(false);
  }
  return;
}",0.8632850241545894
133690,"/** 
 * This operation overrides the ViewPart.createPartControl method to create and draw the TreeViewer before registering it as a selection provider.
 * @param parent The Composite used to create the TreeViewer.
 */
@Override public void createPartControl(Composite parent){
  tabFolder=new TabFolder(parent,SWT.NONE);
  TabItem textTab=new TabItem(tabFolder,SWT.NONE,0);
  textTab.setText(""String_Node_Str"");
  TabItem imageTab=new TabItem(tabFolder,SWT.NONE,1);
  imageTab.setText(""String_Node_Str"");
  TabItem plotTab=new TabItem(tabFolder,SWT.NONE,2);
  plotTab.setText(""String_Node_Str"");
  createActions();
  resourceTreeViewer=new TreeViewer(tabFolder);
  initializeTreeViewer(resourceTreeViewer);
  textTab.setControl(resourceTreeViewer.getControl());
  imageTab.setControl(resourceTreeViewer.getControl());
  getSite().setSelectionProvider(resourceTreeViewer);
  tabFolder.addListener(SWT.Selection,new Listener(){
    @Override public void handleEvent(    Event event){
      if (playAction.isInPlayState()) {
        playAction.stop();
      }
      setTreeContent(tabFolder.indexOf((TabItem)event.item));
    }
  }
);
  Table listTable=new Table(tabFolder,SWT.FLAT);
  DefaultEventTableViewer<VizResource> listTableViewer=new DefaultEventTableViewer<VizResource>(plotList,listTable,plotList);
  plotTab.setControl(listTable);
  IPartService partService=getSite().getWorkbenchWindow().getPartService();
  IWorkbenchPartReference partRef=partService.getActivePartReference();
  if (ICEFormEditor.ID.equals(partRef.getId())) {
    ICEFormEditor activeEditor=(ICEFormEditor)partRef.getPart(false);
    if (activeEditor != editor) {
      setActiveEditor(activeEditor);
    }
  }
  partService.addPartListener(this);
  return;
}","/** 
 * This operation overrides the ViewPart.createPartControl method to create and draw the TreeViewer before registering it as a selection provider.
 * @param parent The Composite used to create the TreeViewer.
 */
@Override public void createPartControl(Composite parent){
  tabFolder=new TabFolder(parent,SWT.NONE);
  TabItem textTab=new TabItem(tabFolder,SWT.NONE,0);
  textTab.setText(""String_Node_Str"");
  TabItem imageTab=new TabItem(tabFolder,SWT.NONE,1);
  imageTab.setText(""String_Node_Str"");
  TabItem plotTab=new TabItem(tabFolder,SWT.NONE,2);
  plotTab.setText(""String_Node_Str"");
  createActions();
  resourceTreeViewer=new TreeViewer(tabFolder);
  initializeTreeViewer(resourceTreeViewer);
  textTab.setControl(resourceTreeViewer.getControl());
  imageTab.setControl(resourceTreeViewer.getControl());
  getSite().setSelectionProvider(resourceTreeViewer);
  tabFolder.addListener(SWT.Selection,new Listener(){
    @Override public void handleEvent(    Event event){
      if (playAction.isInPlayState()) {
        playAction.stop();
      }
      setTreeContent(tabFolder.indexOf((TabItem)event.item));
    }
  }
);
  Table listTable=new Table(tabFolder,SWT.FLAT);
  DefaultEventTableViewer<VizResource> listTableViewer=new DefaultEventTableViewer<VizResource>(plotList,listTable,plotList);
  plotTab.setControl(listTable);
  IPartService partService=getSite().getWorkbenchWindow().getPartService();
  IWorkbenchPartReference partRef=partService.getActivePartReference();
  if (partRef != null && ICEFormEditor.ID.equals(partRef.getId())) {
    ICEFormEditor activeEditor=(ICEFormEditor)partRef.getPart(false);
    if (activeEditor != editor) {
      setActiveEditor(activeEditor);
    }
  }
  partService.addPartListener(this);
  return;
}",0.99456054967077
133691,"/** 
 * Override of update so that the CaebatLauncher can check if the user wants to select a  custom KV Pair file.
 */
public void update(IUpdateable component){
  refreshProjectSpace();
  super.update(component);
  if (component.getName() == ""String_Node_Str"" && ((Entry)component).getValue() == ""String_Node_Str"") {
    addInputType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (component.getName() == ""String_Node_Str"" && ((Entry)component).getValue() == ""String_Node_Str"") {
    removeInputType(""String_Node_Str"");
  }
}","/** 
 * Override of update so that the CaebatLauncher can check if the user wants to select a  custom KV Pair file.
 */
public void update(IUpdateable component){
  refreshProjectSpace();
  if (component instanceof Entry) {
    if (component.getName() == ""String_Node_Str"" && ((Entry)component).getValue() == ""String_Node_Str"") {
      addInputType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
 else     if (component.getName() == ""String_Node_Str"" && ((Entry)component).getValue() == ""String_Node_Str"") {
      DataComponent fileComponent=(DataComponent)form.getComponent(1);
      fileComponent.deleteEntry(""String_Node_Str"");
    }
  }
}",0.8520900321543409
133692,"/** 
 * The Constructor
 * @param editor The FormEditor for which the Page should be constructed.
 * @param id The id of the page.
 * @param title The title of the page.
 */
public ICEResourcePage(FormEditor editor,String id,String title){
  super(editor,id,title);
  if (editor instanceof ICEFormEditor) {
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  plotMap=new Hashtable<String,IPlot>();
  return;
}","/** 
 * The Constructor
 * @param editor 	The FormEditor for which the Page should be constructed.
 * @param id		The id of the page.
 * @param title		The title of the page.
 */
public ICEResourcePage(FormEditor editor,String id,String title){
  super(editor,id,title);
  if (editor instanceof ICEFormEditor) {
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  plotMap=new Hashtable<String,IPlot>();
  return;
}",0.9916567342073898
133693,"/** 
 * <!-- begin-UML-doc --> <p> This operation overrides the default/abstract implementation of FormPage.createFormContents to create the contents of the ICEResourcePage. </p> <!-- end-UML-doc -->
 * @param managedForm <p> The Form widget on which the ICEResourcePage exists. </p>
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void createFormContent(IManagedForm managedForm){
  final ScrolledForm form=managedForm.getForm();
  FormToolkit toolkit=managedForm.getToolkit();
  try {
    getSite().getWorkbenchWindow().getActivePage().showView(ICEResourceView.ID);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
  resourceView=(ICEResourceView)getSite().getWorkbenchWindow().getActivePage().findView(ICEResourceView.ID);
  resourceView.setResourceComponent(resourceComponent);
  form.getBody().setLayout(new GridLayout());
  form.getBody().setLayoutData(new GridData(GridData.FILL_BOTH));
  parent=new Composite(form.getBody(),SWT.None);
  parent.setLayoutData(new GridData(GridData.FILL_BOTH));
  layout=new StackLayout();
  parent.setLayout(layout);
  plotComposite=new Composite(parent,SWT.NONE);
  managedForm.getToolkit().adapt(plotComposite);
  managedForm.getToolkit().paintBordersFor(plotComposite);
  plotComposite.setLayout(new GridLayout(1,true));
  plotComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
  drawBrowser(toolkit,managedForm);
  getSite().getPage().addSelectionListener(this);
  getSite().getWorkbenchWindow().getPartService().addPartListener(resourceView);
  return;
}","/** 
 * This operation overrides the default/abstract implementation of FormPage.createFormContents to create the contents of the ICEResourcePage.
 * @param managedForm The Form widget on which the ICEResourcePage exists.
 */
protected void createFormContent(IManagedForm managedForm){
  final ScrolledForm form=managedForm.getForm();
  FormToolkit toolkit=managedForm.getToolkit();
  try {
    getSite().getWorkbenchWindow().getActivePage().showView(ICEResourceView.ID);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
  resourceView=(ICEResourceView)getSite().getWorkbenchWindow().getActivePage().findView(ICEResourceView.ID);
  resourceView.setResourceComponent(resourceComponent);
  form.getBody().setLayout(new GridLayout());
  form.getBody().setLayoutData(new GridData(GridData.FILL_BOTH));
  parent=new Composite(form.getBody(),SWT.None);
  parent.setLayoutData(new GridData(GridData.FILL_BOTH));
  layout=new StackLayout();
  parent.setLayout(layout);
  parent.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent event){
      getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(ICEResourcePage.this);
    }
  }
);
  plotComposite=new Composite(parent,SWT.NONE);
  managedForm.getToolkit().adapt(plotComposite);
  managedForm.getToolkit().paintBordersFor(plotComposite);
  plotComposite.setLayout(new GridLayout(1,true));
  plotComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
  drawBrowser(toolkit,managedForm);
  getSite().getPage().addSelectionListener(this);
  getSite().getWorkbenchWindow().getPartService().addPartListener(resourceView);
  return;
}",0.8795811518324608
133694,"/** 
 * This operation overrides the default/abstract implementation of ISelectionListener.selectionChanged to display the resource selected in the ICEResourceView.
 * @param part The IWorkbenchPart that called this function.
 * @param selection The ISelection chosen in the part parameter.
 */
@Override public void selectionChanged(IWorkbenchPart part,ISelection selection){
  if (part.getSite().getId().equals(ICEResourceView.ID)) {
    Object selectedElement=((ITreeSelection)selection).getFirstElement();
    ICEResource selectedResource=null;
    if (selectedElement instanceof String) {
      selectedResource=resourceView.resourceChildMap.get(selectedElement);
    }
 else     if (selectedElement instanceof PropertySource) {
      PropertySource source=(PropertySource)selectedElement;
      selectedResource=(ICEResource)source.getWrappedData();
    }
    if (selectedResource != null && !(selectedResource instanceof VizResource)) {
      if (browser != null && !browser.isDisposed()) {
        currentResource=selectedResource;
        browser.setUrl(currentResource.getPath().toString());
        layout.topControl=browser;
        parent.layout();
      }
    }
 else     if (selectedResource != null) {
      layout.topControl=plotComposite;
      try {
        IPlot plot=plotMap.get(selectedResource.getPath().toString());
        if (plot == null) {
          plot=vizFactory.get().createPlot(selectedResource.getPath());
        }
        Map<String,String[]> plotTypes=plot.getPlotTypes();
        ArrayList<String> keys=new ArrayList<String>(plotTypes.keySet());
        String category;
        category=keys.get(0);
        String[] types=plotTypes.get(category);
        String type=types[0];
        plot.draw(category,type,plotComposite);
        plotComposite.layout();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      parent.layout();
    }
  }
  return;
}","/** 
 * This operation overrides the default/abstract implementation of ISelectionListener.selectionChanged to display the resource selected in the ICEResourceView.
 * @param part 			The IWorkbenchPart that called this function.
 * @param selection		The ISelection chosen in the part parameter.
 */
@Override public void selectionChanged(IWorkbenchPart part,ISelection selection){
  if (part.getSite().getId().equals(ICEResourceView.ID)) {
    Object selectedElement=((ITreeSelection)selection).getFirstElement();
    ICEResource selectedResource=null;
    if (selectedElement instanceof String) {
      selectedResource=resourceView.resourceChildMap.get(selectedElement);
    }
 else     if (selectedElement instanceof PropertySource) {
      PropertySource source=(PropertySource)selectedElement;
      selectedResource=(ICEResource)source.getWrappedData();
    }
    if (selectedResource != null && !(selectedResource instanceof VizResource)) {
      if (browser != null && !browser.isDisposed()) {
        currentResource=selectedResource;
        browser.setUrl(currentResource.getPath().toString());
        layout.topControl=browser;
        parent.layout();
      }
    }
 else     if (selectedResource != null) {
      layout.topControl=plotComposite;
      try {
        IPlot plot=plotMap.get(selectedResource.getPath().toString());
        if (plot == null) {
          plot=vizFactory.get().createPlot(selectedResource.getPath());
        }
        Map<String,String[]> plotTypes=plot.getPlotTypes();
        ArrayList<String> keys=new ArrayList<String>(plotTypes.keySet());
        String category=keys.get(0);
        String type=plotTypes.get(category)[0];
        plot.draw(category,type,plotComposite);
        plotComposite.layout();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      parent.layout();
    }
  }
  return;
}",0.9830956154252508
133695,"/** 
 * This update method is called whenever the ResourceComponent is updated. It compares the contents of the ResourceComponent to the plotMap, and adds any VizResources to the plotMap that haven't been added yet.
 */
@Override public void update(IUpdateable component){
  if (component instanceof ResourceComponent) {
    if (resourceComponent != null) {
      for (      ICEResource resource : resourceComponent.getResources()) {
        if (resource instanceof VizResource && !plotMap.containsKey(resource.getPath().toString())) {
          try {
            IPlot plot=vizFactory.get().createPlot(resource.getPath());
            plotMap.put(plot.getDataSource().toString(),plot);
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  return;
}","/** 
 * This update method is called whenever the ResourceComponent is updated. It compares the contents of the ResourceComponent to the plotMap, and adds any VizResources to the plotMap that haven't been added yet.
 */
@Override public void update(IUpdateable component){
  if (component instanceof ResourceComponent) {
    if (resourceComponent != null) {
      for (      ICEResource resource : resourceComponent.getResources()) {
        if (resource instanceof VizResource && !plotMap.containsKey(resource.getPath().toString())) {
          try {
            IPlot plot=vizFactory.get().createPlot(resource.getPath());
            if (plot != null) {
              plotMap.put(plot.getDataSource().toString(),plot);
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  return;
}",0.9714285714285714
133696,"/** 
 * This operation sets the ResourceComponent that should be used by the ICEResourcePage. It also registers the ICEResourcePage with the ResourceComponent so that it can be notified of state changes through the IUpdateableListener interface.
 * @param component <p> The ResourceComponent </p>
 */
public void setResourceComponent(ResourceComponent component){
  if (component != null) {
    resourceComponent=component;
    for (    ICEResource resource : resourceComponent.getResources()) {
      if (resource instanceof VizResource) {
        try {
          IPlot plot=vizFactory.get().createPlot(resource.getPath());
          plotMap.put(plot.getDataSource().toString(),plot);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
  resourceComponent.register(this);
  return;
}","/** 
 * This operation sets the ResourceComponent that should be used by the ICEResourcePage. It also registers the ICEResourcePage with the ResourceComponent so that it can be notified of state changes through the IUpdateableListener interface.
 * @param component The ResourceComponent
 */
public void setResourceComponent(ResourceComponent component){
  if (component != null) {
    resourceComponent=component;
    for (    ICEResource resource : resourceComponent.getResources()) {
      if (resource instanceof VizResource) {
        try {
          IPlot plot=vizFactory.get().createPlot(resource.getPath());
          plotMap.put(plot.getDataSource().toString(),plot);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
  resourceComponent.register(this);
  return;
}",0.9945684972842488
133697,"/** 
 * Creates the content used for the mesh view.
 * @param section The  {@code Section} that should contain the mesh view.
 * @param toolkit The  {@code FormToolkit} used to decorate widgets as necessary.
 */
private void populateMeshViewSection(Section section,FormToolkit toolkit){
  section.setText(""String_Node_Str"");
  section.setDescription(""String_Node_Str"");
  Composite container=toolkit.createComposite(section,SWT.NONE);
  section.setClient(container);
  container.setLayout(new GridLayout(1,false));
  ToolBarManager toolBarManager=new ToolBarManager();
  ToolBar toolBar=toolBarManager.createControl(container);
  toolkit.adapt(toolBar);
  toolBar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  meshPlotParent=toolkit.createComposite(container,SWT.BORDER);
  meshPlotParent.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  IVizServiceFactory vizFactory=getVizServiceFactory();
  if (vizFactory != null) {
    vizService=(VisItVizService)vizFactory.get(""String_Node_Str"");
  }
  if (vizService != null) {
    meshPlotParent.setLayout(new FillLayout());
    try {
      VisItPlot plot=(VisItPlot)vizService.createPlot(meshURI);
      for (      IAction action : plot.getActions()) {
        toolBarManager.add(action);
      }
      toolBarManager.update(true);
      plot.draw(""String_Node_Str"",""String_Node_Str"",meshPlotParent);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
 else {
    String errorMessage=""String_Node_Str"" + ""String_Node_Str"";
    meshPlotParent.setLayout(new GridLayout(2,false));
    Label iconLabel=toolkit.createLabel(meshPlotParent,""String_Node_Str"");
    iconLabel.setImage(Display.getCurrent().getSystemImage(SWT.ICON_ERROR));
    iconLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.BEGINNING,false,false));
    Label msgLabel=toolkit.createLabel(meshPlotParent,errorMessage);
    msgLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.CENTER,false,false));
  }
  section.setClient(container);
  return;
}","/** 
 * Creates the content used for the mesh view.
 * @param section The  {@code Section} that should contain the mesh view.
 * @param toolkit The  {@code FormToolkit} used to decorate widgets as necessary.
 */
private void populateMeshViewSection(Section section,FormToolkit toolkit){
  section.setText(""String_Node_Str"");
  section.setDescription(""String_Node_Str"");
  Composite container=toolkit.createComposite(section,SWT.NONE);
  section.setClient(container);
  container.setLayout(new GridLayout(1,false));
  ToolBarManager toolBarManager=new ToolBarManager();
  ToolBar toolBar=toolBarManager.createControl(container);
  toolkit.adapt(toolBar);
  toolBar.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  meshPlotParent=toolkit.createComposite(container,SWT.BORDER);
  meshPlotParent.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  IVizServiceFactory vizFactory=getVizServiceFactory();
  if (vizFactory != null) {
    vizService=(VisItVizService)vizFactory.get(""String_Node_Str"");
  }
  if (vizService != null) {
    meshPlotParent.setLayout(new FillLayout());
    try {
      plot=(VisItPlot)vizService.createPlot(meshURI);
      for (      IAction action : plot.getActions()) {
        toolBarManager.add(action);
      }
      toolBarManager.update(true);
      plot.draw(""String_Node_Str"",""String_Node_Str"",meshPlotParent);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
 else {
    String errorMessage=""String_Node_Str"" + ""String_Node_Str"";
    meshPlotParent.setLayout(new GridLayout(2,false));
    Label iconLabel=toolkit.createLabel(meshPlotParent,""String_Node_Str"");
    iconLabel.setImage(Display.getCurrent().getSystemImage(SWT.ICON_ERROR));
    iconLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.BEGINNING,false,false));
    Label msgLabel=toolkit.createLabel(meshPlotParent,errorMessage);
    msgLabel.setLayoutData(new GridData(SWT.BEGINNING,SWT.CENTER,false,false));
  }
  section.setClient(container);
  return;
}",0.9975704567541304
133698,"/** 
 * Removes the Mesh View page if possible.
 */
public void removeMeshPage(){
  removePageWithID(MESH_PAGE_ID);
}","/** 
 * Removes the Mesh View page if possible.
 */
public void removeMeshPage(){
  if (meshPlotParent != null && !meshPlotParent.isDisposed()) {
    meshPlotParent.dispose();
    meshPlotParent=null;
  }
  plot=null;
  vizService=null;
  removePageWithID(MESH_PAGE_ID);
}",0.6015424164524421
133699,"@Override protected void setInput(IEditorInput input){
  super.setInput(input);
  if (input instanceof ICEFormInput) {
    Form form=((ICEFormInput)input).getForm();
    int id=MOOSEModel.resourceComponentId;
    final ResourceComponent resources=(ResourceComponent)form.getComponent(id);
    if (resources != null) {
      if (!resources.isEmpty()) {
        meshURI=resources.get(0).getPath();
      }
      ListEventListener<ICEResource> listener=new ListEventListener<ICEResource>(){
        @Override public void listChanged(        ListEvent<ICEResource> listChanges){
          while (listChanges.next()) {
            int type=listChanges.getType();
            int index=listChanges.getIndex();
            if (type == ListEvent.INSERT | type == ListEvent.UPDATE) {
              meshURI=resources.get(index).getPath();
            }
 else {
              meshURI=null;
            }
            if (plot != null) {
              plot.setDataSource(meshURI);
            }
            return;
          }
        }
      }
;
      resources.addListEventListener(listener);
    }
  }
  return;
}","/** 
 * In addition to the default behavior, this method registers with the MOOSE form's mesh   {@link ResourceComponent} to listen for add/insert/removeevents. The intent is to pull the current  {@link #meshURI} from the modeland render it in the  {@link #plot} on the mesh page.
 * @param input The editor's input. This should be of the type {@link ICEFormInput}.
 */
@Override protected void setInput(IEditorInput input){
  super.setInput(input);
  if (input instanceof ICEFormInput) {
    Form form=((ICEFormInput)input).getForm();
    int id=MOOSEModel.resourceComponentId;
    final ResourceComponent resources=(ResourceComponent)form.getComponent(id);
    if (resources != null) {
      if (!resources.isEmpty()) {
        meshURI=resources.get(0).getPath();
      }
      ListEventListener<ICEResource> listener=new ListEventListener<ICEResource>(){
        @Override public void listChanged(        ListEvent<ICEResource> listChanges){
          while (listChanges.next()) {
            int type=listChanges.getType();
            int index=listChanges.getIndex();
            if (type == ListEvent.INSERT | type == ListEvent.UPDATE) {
              meshURI=resources.get(index).getPath();
            }
 else {
              meshURI=null;
            }
            if (plot != null) {
              plot.setDataSource(meshURI);
            }
            return;
          }
        }
      }
;
      resources.addListEventListener(listener);
    }
  }
  return;
}",0.8563664596273292
133700,"/** 
 * Removes the Plant View page if possible.
 */
public void removePlantPage(){
  removePageWithID(PLANT_PAGE_ID);
}","/** 
 * Removes the Plant View page if possible.
 */
public void removePlantPage(){
  plantView=null;
  removePageWithID(PLANT_PAGE_ID);
}",0.9302325581395348
133701,"/** 
 * Load the given File as an XMLResource.
 * @param file
 * @return
 */
public boolean load(File file){
  EObject documentRoot=null;
  if (xmlProcessor != null) {
    try {
      xmlResource=(XMLResource)xmlProcessor.load(new FileInputStream(file),null);
    }
 catch (    IOException e) {
      e.printStackTrace();
      return false;
    }
  }
  if (xmlResource != null) {
    documentRoot=(EObject)xmlResource.getContents().get(0);
  }
 else {
    return false;
  }
  if (documentRoot != null) {
    iceEMFTree=new EMFTreeComposite(documentRoot);
    mapToEMFTreeComposite(documentRoot.eContents().get(0),iceEMFTree);
  }
 else {
    return false;
  }
  return true;
}","/** 
 * Load the given File as an XMLResource.
 * @param file
 * @return
 */
public boolean load(File file){
  EObject documentRoot=null;
  if (xmlProcessor != null) {
    try {
      xmlResource=(XMLResource)xmlProcessor.load(new FileInputStream(file),null);
    }
 catch (    IOException e) {
      e.printStackTrace();
      return false;
    }
  }
  if (xmlResource != null) {
    documentRoot=(EObject)xmlResource.getContents().get(0);
  }
 else {
    return false;
  }
  if (documentRoot != null) {
    iceEMFTree=new EMFTreeComposite(documentRoot);
    HashMap<EObject,EMFTreeComposite> map=new HashMap<EObject,EMFTreeComposite>();
    map.put(documentRoot,iceEMFTree);
    TreeIterator<EObject> tree=documentRoot.eAllContents();
    while (tree.hasNext()) {
      EObject obj=tree.next();
      map.put(obj,new EMFTreeComposite(obj));
    }
    for (    EObject o : map.keySet()) {
      EObject parent=o.eContainer();
      if (parent != null) {
        map.get(parent).setNextChild(map.get(o));
      }
    }
  }
 else {
    return false;
  }
  return true;
}",0.6918671248568156
133702,"/** 
 * This method overrides TreeComposite.checkExemplars to use the overridden getChildExemplars method to see if a given TreeComposite can be added as a new child of this tree.
 * @param cNode
 * @return
 */
@Override protected boolean checkExemplars(TreeComposite cNode){
  for (  TreeComposite exemplar : getChildExemplars()) {
    if (cNode.getName().equals(exemplar.getName())) {
      return true;
    }
  }
  return false;
}","/** 
 * This method overrides TreeComposite.checkExemplars to use the overridden getChildExemplars method to see if a given TreeComposite can be added as a new child of this tree.
 * @param cNode
 * @return
 */
@Override protected boolean checkExemplars(TreeComposite cNode){
  for (  TreeComposite exemplar : getChildExemplars()) {
    if (cNode.getName().equals(""String_Node_Str"")) {
      System.out.print(""String_Node_Str"" + exemplar.getName());
    }
    if (cNode.getName().equals(exemplar.getName())) {
      return true;
    }
  }
  return false;
}",0.8169868554095046
133703,"/** 
 * The constructor, takes a Ecore model tree EObject node instance
 * @param treeNode
 */
public EMFTreeComposite(EObject treeNode){
  super();
  ecoreNode=treeNode;
  ecoreNodeMetaData=ecoreNode.eClass();
  setName(ecoreNodeMetaData.getName());
  setDescription(toString());
  loadedFromEObject=true;
  createActiveDataNode();
  return;
}","/** 
 * The constructor, takes a Ecore model tree EObject node instance
 * @param treeNode
 */
public EMFTreeComposite(EObject treeNode){
  super();
  ecoreNode=treeNode;
  ecoreNodeMetaData=ecoreNode.eClass();
  setName(ecoreNodeMetaData.getName());
  setDescription(toString());
  createActiveDataNode();
  return;
}",0.8731117824773413
133704,"/** 
 * This method overrides TreeComposite.getChildExemplars to dynamically generate a list of exemplar children based on the EClass metadata's list of EReferences.
 * @return
 */
@Override public ArrayList<TreeComposite> getChildExemplars(){
  ArrayList<TreeComposite> exemplars=new ArrayList<TreeComposite>();
  boolean childExists=false;
  for (  EReference exemplar : ecoreNodeMetaData.getEReferences()) {
    if (""String_Node_Str"".equals(exemplar.getEReferenceType().getName())) {
      continue;
    }
    int upperBound=exemplar.getUpperBound();
    if (upperBound == -1) {
      exemplars.add(new EMFTreeComposite(exemplar.getEReferenceType()));
      continue;
    }
 else     if (upperBound <= 1) {
      for (      TreeComposite currentChild : children) {
        if (currentChild.getName().equals(exemplar.getEReferenceType().getName())) {
          childExists=true;
          break;
        }
      }
      if (!childExists) {
        exemplars.add(new EMFTreeComposite(exemplar.getEReferenceType()));
      }
    }
  }
  return exemplars;
}","/** 
 * This method overrides TreeComposite.getChildExemplars to dynamically generate a list of exemplar children based on the EClass metadata's list of EReferences.
 * @return
 */
@Override public ArrayList<TreeComposite> getChildExemplars(){
  ArrayList<TreeComposite> exemplars=new ArrayList<TreeComposite>();
  boolean childExists=false;
  for (  EReference exemplar : ecoreNodeMetaData.getEAllReferences()) {
    if (""String_Node_Str"".equals(exemplar.getEReferenceType().getName())) {
      continue;
    }
    int upperBound=exemplar.getUpperBound();
    if (upperBound == -1) {
      exemplars.add(new EMFTreeComposite(exemplar.getEReferenceType()));
      continue;
    }
 else     if (upperBound <= 1) {
      for (      TreeComposite currentChild : children) {
        if (currentChild.getName().equals(exemplar.getEReferenceType().getName())) {
          childExists=true;
          break;
        }
      }
      if (!childExists) {
        exemplars.add(new EMFTreeComposite(exemplar.getEReferenceType()));
      }
    }
  }
  return exemplars;
}",0.998581560283688
133705,"/** 
 * <!-- begin-UML-doc --> <p> </p> <!-- end-UML-doc -->
 */
@Test public void checkLoad(){
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String expectedFilePath=userDir + separator + ""String_Node_Str"";
  File loadFile=new File(expectedFilePath);
  emfComponent.save();
  assertTrue(emfComponent.load(loadFile));
  emfComponent.save();
  EMFTreeComposite emfTree=(EMFTreeComposite)emfComponent.getEMFTreeComposite();
  assertNotNull(emfTree);
  assertEquals(""String_Node_Str"",emfTree.getName());
  assertEquals(1,emfTree.getNumberOfChildren());
  EMFTreeComposite shipOrder=(EMFTreeComposite)emfTree.getChildAtIndex(0);
  assertEquals(3,shipOrder.getNumberOfChildren());
  assertEquals(""String_Node_Str"",shipOrder.getName());
  assertEquals(1,shipOrder.getNumberOfDataNodes());
  DataComponent component=(DataComponent)shipOrder.getActiveDataNode();
  assertEquals(""String_Node_Str"",component.getName());
  assertEquals(2,component.retrieveAllEntries().size());
  TreeComposite child1=shipOrder.getChildAtIndex(0);
  assertEquals(""String_Node_Str"",child1.getName());
  assertEquals(0,child1.getNumberOfChildren());
  assertEquals(1,child1.getNumberOfDataNodes());
  component=(DataComponent)child1.getActiveDataNode();
  assertEquals(""String_Node_Str"",component.getName());
  assertEquals(4,component.retrieveAllEntries().size());
  TreeComposite child2=shipOrder.getChildAtIndex(1);
  assertEquals(""String_Node_Str"",child2.getName());
  assertEquals(0,child2.getNumberOfChildren());
  assertEquals(1,child2.getNumberOfDataNodes());
  component=(DataComponent)child2.getActiveDataNode();
  assertEquals(""String_Node_Str"",component.getName());
  assertEquals(4,component.retrieveAllEntries().size());
  TreeComposite child3=shipOrder.getChildAtIndex(2);
  assertEquals(""String_Node_Str"",child3.getName());
  assertEquals(0,child3.getNumberOfChildren());
  assertEquals(1,child3.getNumberOfDataNodes());
  component=(DataComponent)child3.getActiveDataNode();
  assertEquals(""String_Node_Str"",component.getName());
  assertEquals(4,component.retrieveAllEntries().size());
  String xmlString=emfComponent.saveToString();
  assertNotNull(xmlString);
  assertEquals(2,xmlString.split(Pattern.quote(""String_Node_Str""),-1).length - 1);
}","/** 
 * <!-- begin-UML-doc --> <p> </p> <!-- end-UML-doc -->
 */
@Test public void checkLoad(){
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String expectedFilePath=userDir + separator + ""String_Node_Str"";
  File loadFile=new File(expectedFilePath);
  emfComponent.save();
  assertTrue(emfComponent.load(loadFile));
  emfComponent.save();
  EMFTreeComposite emfTree=(EMFTreeComposite)emfComponent.getEMFTreeComposite();
  assertNotNull(emfTree);
  assertEquals(""String_Node_Str"",emfTree.getName());
  assertEquals(1,emfTree.getNumberOfChildren());
  EMFTreeComposite shipOrder=(EMFTreeComposite)emfTree.getChildAtIndex(0);
  assertEquals(3,shipOrder.getNumberOfChildren());
  assertEquals(""String_Node_Str"",shipOrder.getName());
  assertEquals(1,shipOrder.getNumberOfDataNodes());
  DataComponent component=(DataComponent)shipOrder.getActiveDataNode();
  assertEquals(""String_Node_Str"",component.getName());
  assertEquals(2,component.retrieveAllEntries().size());
  assertEquals(3,shipOrder.getNumberOfChildren());
  int itemCount=0;
  int shiptoCount=0;
  for (int i=0; i < 3; i++) {
    TreeComposite child=shipOrder.getChildAtIndex(i);
    assertNotNull(child);
    if (""String_Node_Str"".equals(child.getName())) {
      shiptoCount++;
      assertEquals(0,child.getNumberOfChildren());
      assertEquals(1,child.getNumberOfDataNodes());
      component=(DataComponent)child.getActiveDataNode();
      assertEquals(""String_Node_Str"",component.getName());
      assertEquals(4,component.retrieveAllEntries().size());
    }
 else     if (""String_Node_Str"".equals(child.getName())) {
      itemCount++;
      assertEquals(0,child.getNumberOfChildren());
      assertEquals(1,child.getNumberOfDataNodes());
      component=(DataComponent)child.getActiveDataNode();
      assertEquals(""String_Node_Str"",component.getName());
      assertEquals(4,component.retrieveAllEntries().size());
    }
 else {
      fail();
    }
  }
  assertEquals(1,shiptoCount);
  assertEquals(2,itemCount);
  String xmlString=emfComponent.saveToString();
  assertNotNull(xmlString);
  assertEquals(2,xmlString.split(Pattern.quote(""String_Node_Str""),-1).length - 1);
}",0.8121499353726842
133706,"/** 
 * <!-- begin-UML-doc --> <p> </p> <!-- end-UML-doc -->
 */
@Ignore public void checkBatML(){
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String filePath1=userDir + separator + ""String_Node_Str"";
  String filePath2=userDir + separator + ""String_Node_Str"";
  ArrayList<String> treeNames=new ArrayList<String>();
  HashMap<String,Integer> verificationMap=new HashMap<String,Integer>();
  EMFComponent batmlEMFComponent=new EMFComponent(new File(filePath1));
  assertTrue(batmlEMFComponent.load(new File(filePath2)));
  EMFTreeComposite docRootTree=(EMFTreeComposite)batmlEMFComponent.getEMFTreeComposite();
  assertNotNull(docRootTree);
  assertNotNull(docRootTree.getChildAtIndex(0));
  assertTrue(docRootTree.getChildAtIndex(0).getChildAtIndex(0).getName().equals(""String_Node_Str""));
  EMFTreeComposite modelDB=(EMFTreeComposite)docRootTree.getChildAtIndex(0).getChildAtIndex(0).getChildAtIndex(0);
  System.out.println(""String_Node_Str"");
  for (  TreeComposite t : modelDB.getChildExemplars()) {
    System.out.println(""String_Node_Str"" + t.getName());
  }
  System.out.println(""String_Node_Str"" + docRootTree.getChildAtIndex(0).getChildAtIndex(0).getChildAtIndex(0).getName());
  BreadthFirstTreeCompositeIterator iter=new BreadthFirstTreeCompositeIterator(batmlEMFComponent.getEMFTreeComposite());
  while (iter.hasNext()) {
    EMFTreeComposite tree=(EMFTreeComposite)iter.next();
    String treeName=tree.getName();
    treeNames.add(treeName);
    System.out.println(""String_Node_Str"" + treeName);
    if (verificationMap.keySet().contains(treeName)) {
      int newValue=verificationMap.get(treeName) + 1;
      verificationMap.put(treeName,newValue);
    }
 else {
      verificationMap.put(treeName,1);
    }
  }
  assertEquals((Integer)141,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)141,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)10,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
}","/** 
 * <!-- begin-UML-doc --> <p> </p> <!-- end-UML-doc -->
 */
@Test public void checkBatML(){
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String filePath1=userDir + separator + ""String_Node_Str"";
  String filePath2=userDir + separator + ""String_Node_Str"";
  ArrayList<String> treeNames=new ArrayList<String>();
  HashMap<String,Integer> verificationMap=new HashMap<String,Integer>();
  EMFComponent batmlEMFComponent=new EMFComponent(new File(filePath1));
  assertTrue(batmlEMFComponent.load(new File(filePath2)));
  EMFTreeComposite docRootTree=(EMFTreeComposite)batmlEMFComponent.getEMFTreeComposite();
  assertNotNull(docRootTree);
  assertNotNull(docRootTree.getChildAtIndex(0));
  assertTrue(docRootTree.getChildAtIndex(0).getChildAtIndex(0).getName().equals(""String_Node_Str""));
  EMFTreeComposite modelDB=(EMFTreeComposite)docRootTree.getChildAtIndex(0).getChildAtIndex(0).getChildAtIndex(0);
  for (  TreeComposite t : modelDB.getChildExemplars()) {
    System.out.println(""String_Node_Str"" + t.getName());
  }
  BreadthFirstTreeCompositeIterator iter=new BreadthFirstTreeCompositeIterator(batmlEMFComponent.getEMFTreeComposite());
  while (iter.hasNext()) {
    EMFTreeComposite tree=(EMFTreeComposite)iter.next();
    String treeName=tree.getName();
    treeNames.add(treeName);
    System.out.println(""String_Node_Str"" + treeName);
    if (verificationMap.keySet().contains(treeName)) {
      int newValue=verificationMap.get(treeName) + 1;
      verificationMap.put(treeName,newValue);
    }
 else {
      verificationMap.put(treeName,1);
    }
  }
  assertEquals((Integer)141,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)141,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)10,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
  assertEquals((Integer)1,(Integer)verificationMap.get(""String_Node_Str""));
}",0.9649868447682656
133707,"/** 
 * This operation returns the value of the squared modulus of the specular reflectivity for a single wave vector Q.
 * @param waveVectorQ the value of the wave vector
 * @param wavelength the wavelength of the incident neutrons
 * @param tiles the list of TIles that contains the physical parameters needed for the calculation, including the scattering densities, absorption parameters and thicknesses.
 * @return the squared modulus of the specular reflectivity
 */
public double getModSqrdSpecRef(double waveVectorQ,double wavelength,Tile[] tiles){
  double modSqrdSpecRef=0.0;
  if (wavelength > 0.0) {
    Tile tile;
    Complex aNm1Sq, fNm1N, rNm1N=new Complex(0.0,0.0), one=new Complex(1.0,0.0), qN=new Complex(0.0,0.0), rNNp1=new Complex(0.0,0.0);
    int nLayers=tiles.length;
    tile=tiles[nLayers - 1];
    double qCSq=16.0 * Math.PI * tile.scatteringLength;
    double muLAbs=tile.trueAbsLength;
    double mulInc=tile.incAbsLength;
    double thickness=tile.thickness;
    double betaNm1=4.0 * Math.PI * (muLAbs + mulInc / wavelength);
    Complex qNm1=new Complex(waveVectorQ * waveVectorQ - qCSq,-2.0 * betaNm1);
    qNm1=qNm1.multiply(qNm1);
    for (int i=nLayers - 1; i > 0; i--) {
      tile=tiles[i - 1];
      qN=qNm1;
      qCSq=16.0 * Math.PI * tile.scatteringLength;
      muLAbs=tile.trueAbsLength;
      mulInc=tile.incAbsLength;
      thickness=tile.thickness;
      betaNm1=4.0 * Math.PI * (muLAbs + mulInc / wavelength);
      qNm1=new Complex(waveVectorQ * waveVectorQ - qCSq,-2.0 * betaNm1);
      qNm1=qNm1.sqrt();
      aNm1Sq=(new Complex(qNm1.getImaginary(),qNm1.getReal()).multiply(-0.5 * thickness)).exp();
      fNm1N=qNm1.subtract(qN).divide(qNm1.add(qN));
      Complex y=rNNp1.multiply(fNm1N).add(one);
      Complex z=rNNp1.add(fNm1N);
      rNm1N=aNm1Sq.multiply(aNm1Sq).multiply(z.divide((y)));
      rNNp1=rNm1N;
    }
    modSqrdSpecRef=rNm1N.getReal() * rNm1N.getReal() + rNm1N.getImaginary() * rNm1N.getImaginary();
  }
  return modSqrdSpecRef;
}","/** 
 * This operation returns the value of the squared modulus of the specular reflectivity for a single wave vector Q.
 * @param waveVectorQ the value of the wave vector
 * @param wavelength the wavelength of the incident neutrons
 * @param tiles the list of TIles that contains the physical parameters needed for the calculation, including the scattering densities, absorption parameters and thicknesses.
 * @return the squared modulus of the specular reflectivity
 */
public double getModSqrdSpecRef(double waveVectorQ,double wavelength,Tile[] tiles){
  double modSqrdSpecRef=0.0;
  if (wavelength > 0.0) {
    Tile tile;
    Complex aNm1Sq, fNm1N, rNm1N=new Complex(0.0,0.0), one=new Complex(1.0,0.0), qN=new Complex(0.0,0.0), rNNp1=new Complex(0.0,0.0);
    int nLayers=tiles.length;
    tile=tiles[nLayers - 1];
    double qCSq=16.0 * Math.PI * tile.scatteringLength;
    double muLAbs=tile.trueAbsLength;
    double mulInc=tile.incAbsLength;
    double thickness=tile.thickness;
    double betaNm1=4.0 * Math.PI * (muLAbs + mulInc / wavelength);
    Complex qNm1=new Complex(waveVectorQ * waveVectorQ - qCSq,-2.0 * betaNm1);
    qNm1=qNm1.sqrt();
    for (int i=nLayers - 1; i > 0; i--) {
      tile=tiles[i - 1];
      qN=qNm1;
      qCSq=16.0 * Math.PI * tile.scatteringLength;
      muLAbs=tile.trueAbsLength;
      mulInc=tile.incAbsLength;
      thickness=tile.thickness;
      betaNm1=4.0 * Math.PI * (muLAbs + mulInc / wavelength);
      qNm1=new Complex(waveVectorQ * waveVectorQ - qCSq,-2.0 * betaNm1);
      qNm1=qNm1.sqrt();
      aNm1Sq=(new Complex(qNm1.getImaginary(),qNm1.getReal()).multiply(-0.5 * thickness)).exp();
      fNm1N=qNm1.subtract(qN).divide(qNm1.add(qN));
      Complex y=rNNp1.multiply(fNm1N).add(one);
      Complex z=rNNp1.add(fNm1N);
      rNm1N=aNm1Sq.multiply(aNm1Sq).multiply(z.divide((y)));
      rNNp1=rNm1N;
    }
    modSqrdSpecRef=rNm1N.getReal() * rNm1N.getReal() + rNm1N.getImaginary() * rNm1N.getImaginary();
  }
  return modSqrdSpecRef;
}",0.9954887218045112
133708,"/** 
 * Test method for  {@link org.eclipse.ice.io.csv.CSVReader#read(org.eclipse.core.resources.IFile)}.
 * @throws CoreException
 * @throws IOException
 */
@Test public void testRead() throws CoreException, IOException {
  Form form=reader.read(testFile);
  assertTrue(form.getComponents().get(0) instanceof ListComponent);
  ListComponent<String[]> lines=(ListComponent<String[]>)form.getComponents().get(0);
  assertTrue(lines.get(0) instanceof String[]);
  assertEquals(lines.size(),174);
  String[] line=lines.get(0);
  assertEquals(3,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  line=lines.get(173);
  assertEquals(4,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  assertEquals(""String_Node_Str"",line[3]);
  return;
}","/** 
 * Test method for  {@link org.eclipse.ice.io.csv.CSVReader#read(org.eclipse.core.resources.IFile)}.
 * @throws CoreException
 * @throws IOException
 */
@Test public void testRead() throws CoreException, IOException {
  Form form=reader.read(testFile);
  assertTrue(form.getComponents().get(0) instanceof ListComponent);
  ListComponent<String[]> lines=(ListComponent<String[]>)form.getComponents().get(0);
  assertTrue(lines.get(0) instanceof String[]);
  assertEquals(lines.size(),175);
  String[] line=lines.get(0);
  assertEquals(3,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  line=lines.get(lines.size() - 1);
  assertEquals(4,line.length);
  assertEquals(""String_Node_Str"",line[0]);
  assertEquals(""String_Node_Str"",line[1]);
  assertEquals(""String_Node_Str"",line[2]);
  assertEquals(""String_Node_Str"",line[3]);
  return;
}",0.5671159029649596
133709,"/** 
 * This operation loads the set of Tiles from the reference file, ignoring the first line that stores the reference values.
 * @param lines The ListComponent with the lines from the file
 * @return the list of Tiles from the file
 */
private Tile[] loadTiles(ListComponent<String[]> lines){
  Tile[] tiles=new Tile[lines.size() - 1];
  for (int i=1; i < lines.size(); i++) {
    String[] line=lines.get(i);
    Tile tile=new Tile();
    tile.scatteringLength=Double.valueOf(line[0]);
    tile.trueAbsLength=Double.valueOf(line[1]);
    tile.incAbsLength=Double.valueOf(line[2]);
    tile.thickness=Double.valueOf(line[3]);
    tiles[i - 1]=tile;
  }
  return tiles;
}","/** 
 * This operation loads the set of Tiles from the reference file, ignoring the first and second lines that store the reference values.
 * @param lines The ListComponent with the lines from the file
 * @return the list of Tiles from the file
 */
private Tile[] loadTiles(ListComponent<String[]> lines){
  Tile[] tiles=new Tile[lines.size() - 2];
  for (int i=2; i < lines.size(); i++) {
    String[] line=lines.get(i);
    Tile tile=new Tile();
    tile.scatteringLength=Double.valueOf(line[0]);
    tile.trueAbsLength=Double.valueOf(line[1]);
    tile.incAbsLength=Double.valueOf(line[2]);
    tile.thickness=Double.valueOf(line[3]);
    tiles[i - 2]=tile;
  }
  return tiles;
}",0.9402214022140222
133710,"/** 
 * This class tests   {@link ReflectivityCalculator#getSpectRefSqrdMod}.
 */
@Test public void testGetSpecRefSqrdMod(){
  Form form=reader.read(project.getFile(""String_Node_Str""));
  ListComponent<String[]> lines=(ListComponent<String[]>)form.getComponent(1);
  String[] line=lines.get(0);
  double waveVectorQ, wavelength, expectedSpecRefSqrd;
  waveVectorQ=Double.valueOf(line[0]);
  wavelength=Double.valueOf(line[1]);
  expectedSpecRefSqrd=Double.valueOf(line[2]);
  Tile[] tiles=loadTiles(lines);
  ReflectivityCalculator calculator=new ReflectivityCalculator();
  double specRefSqrd=calculator.getModSqrdSpecRef(waveVectorQ,wavelength,tiles);
  System.out.println(""String_Node_Str"" + (specRefSqrd - expectedSpecRefSqrd) / expectedSpecRefSqrd);
  assertEquals(expectedSpecRefSqrd,specRefSqrd,3.3 * 1.0e-4);
  return;
}","/** 
 * This class tests   {@link ReflectivityCalculator#getSpectRefSqrdMod}.
 */
@Test public void testGetSpecRefSqrdMod(){
  Form form=reader.read(project.getFile(""String_Node_Str""));
  ListComponent<String[]> lines=(ListComponent<String[]>)form.getComponent(1);
  String[] line=lines.get(0);
  double waveVectorQ, wavelength, expectedSpecRefSqrd;
  waveVectorQ=Double.valueOf(line[0]);
  wavelength=Double.valueOf(line[1]);
  expectedSpecRefSqrd=Double.valueOf(line[2]);
  Tile[] tiles=loadTiles(lines);
  assertEquals(173,tiles.length);
  ReflectivityCalculator calculator=new ReflectivityCalculator();
  double specRefSqrd=calculator.getModSqrdSpecRef(waveVectorQ,wavelength,tiles);
  System.out.println(specRefSqrd + ""String_Node_Str"" + expectedSpecRefSqrd);
  System.out.println(""String_Node_Str"" + (specRefSqrd - expectedSpecRefSqrd) / expectedSpecRefSqrd);
  assertEquals(expectedSpecRefSqrd,specRefSqrd,4.0e-4);
  line=lines.get(1);
  waveVectorQ=Double.valueOf(line[0]);
  wavelength=Double.valueOf(line[1]);
  expectedSpecRefSqrd=Double.valueOf(line[2]);
  System.out.println(waveVectorQ + ""String_Node_Str"" + wavelength+ ""String_Node_Str""+ expectedSpecRefSqrd);
  specRefSqrd=calculator.getModSqrdSpecRef(waveVectorQ,wavelength,tiles);
  System.out.println(specRefSqrd + ""String_Node_Str"" + expectedSpecRefSqrd);
  System.out.println(""String_Node_Str"" + (specRefSqrd - expectedSpecRefSqrd) / expectedSpecRefSqrd);
  assertEquals(expectedSpecRefSqrd,specRefSqrd,9.0e-4 * Math.abs(expectedSpecRefSqrd));
  return;
}",0.697536108751062
133711,"/** 
 * Tests the IPSWriter
 * @throws IOException 
 * @throws MalformedURLException 
 */
@Test public void checkIPSWriter() throws MalformedURLException, IOException {
  IPSWriter writer=null;
  IPSReader reader=null;
  FileReader fileReader=null;
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String outputFilePath=userDir + separator + ""String_Node_Str"";
  String exampleFilePath=userDir + separator + ""String_Node_Str"";
  IPath fileIPath=new Path(outputFilePath);
  IPath inputIPath=new Path(exampleFilePath);
  IFile outIFile=ResourcesPlugin.getWorkspace().getRoot().getFile(fileIPath);
  IFile inIFile=ResourcesPlugin.getWorkspace().getRoot().getFile(inputIPath);
  File exampleFile=new File(exampleFilePath);
  File outFile=new File(outputFilePath);
  if (!outFile.exists()) {
    outFile.createNewFile();
  }
  BufferedReader exampleReader=new BufferedReader(new FileReader(exampleFile));
  BufferedReader buffer=new BufferedReader(new FileReader(outFile));
  assertNotNull(buffer);
  try {
    assertTrue(buffer.read() == -1);
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  writer=new IPSWriter();
  assertNotNull(writer);
  Form fakeForm=null;
  IFile fakeFile=null;
  writer.write(fakeForm,fakeFile);
  try {
    assertTrue(buffer.read() == -1);
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  Form inputForm=null;
  reader=new IPSReader();
  inputForm=reader.read(inIFile);
  assertNotNull(inputForm);
  writer.write(inputForm,outIFile);
  try {
    buffer=new BufferedReader(new FileReader(outFile));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  int numLines=0;
  try {
    while (buffer.readLine() != null) {
      numLines++;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  assertEquals(113,numLines);
  Form outputForm=reader.read(outIFile);
  ArrayList<Component> components=outputForm.getComponents();
  ArrayList<Component> testComponents=inputForm.getComponents();
  assertEquals(components.size(),testComponents.size());
  for (int i=0; i < components.size(); i++) {
    assertTrue(components.get(i).getName().equals(testComponents.get(i).getName()));
  }
  try {
    buffer.close();
    exampleReader.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  if (outFile.exists()) {
    outFile.delete();
  }
  File tempFile=new File(inIFile.getFullPath().toOSString().split(""String_Node_Str"")[0] + ""String_Node_Str"");
  if (tempFile.exists())   tempFile.delete();
  Files.copy(exampleFile.toPath(),tempFile.toPath());
  assertTrue(tempFile.exists());
  String replace=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + inIFile.getFullPath().toOSString());
  writer.replace(inIFile,""String_Node_Str"",replace);
  boolean foundReplacement=false;
  try {
    Scanner scanner=new Scanner(exampleFile);
    while (scanner.hasNextLine()) {
      String line=scanner.nextLine();
      if (line.contains(replace)) {
        foundReplacement=true;
      }
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
  assertTrue(foundReplacement);
  if (exampleFile.exists())   exampleFile.delete();
  Files.copy(tempFile.toPath(),exampleFile.toPath());
  tempFile.delete();
  return;
}","/** 
 * Tests the IPSWriter
 * @throws IOException 
 * @throws MalformedURLException 
 */
@Test public void checkIPSWriter() throws MalformedURLException, IOException {
  IPSWriter writer=null;
  IPSReader reader=null;
  FileReader fileReader=null;
  String separator=System.getProperty(""String_Node_Str"");
  String userDir=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str""+ separator+ ""String_Node_Str"";
  String outputFilePath=userDir + separator + ""String_Node_Str"";
  String exampleFilePath=userDir + separator + ""String_Node_Str"";
  IPath fileIPath=new Path(outputFilePath);
  IPath inputIPath=new Path(exampleFilePath);
  IFile outIFile=ResourcesPlugin.getWorkspace().getRoot().getFile(fileIPath);
  IFile inIFile=ResourcesPlugin.getWorkspace().getRoot().getFile(inputIPath);
  File exampleFile=new File(exampleFilePath);
  File outFile=new File(outputFilePath);
  if (!outFile.exists()) {
    outFile.createNewFile();
  }
  BufferedReader exampleReader=new BufferedReader(new FileReader(exampleFile));
  BufferedReader buffer=new BufferedReader(new FileReader(outFile));
  assertNotNull(buffer);
  try {
    assertTrue(buffer.read() == -1);
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  writer=new IPSWriter();
  assertNotNull(writer);
  Form fakeForm=null;
  IFile fakeFile=null;
  writer.write(fakeForm,fakeFile);
  try {
    assertTrue(buffer.read() == -1);
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  Form inputForm=null;
  reader=new IPSReader();
  inputForm=reader.read(inIFile);
  assertNotNull(inputForm);
  writer.write(inputForm,outIFile);
  try {
    buffer=new BufferedReader(new FileReader(outFile));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  int numLines=0;
  try {
    while (buffer.readLine() != null) {
      numLines++;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  assertEquals(113,numLines);
  Form outputForm=reader.read(outIFile);
  ArrayList<Component> components=outputForm.getComponents();
  ArrayList<Component> testComponents=inputForm.getComponents();
  assertEquals(components.size(),testComponents.size());
  for (int i=0; i < components.size(); i++) {
    assertTrue(components.get(i).getName().equals(testComponents.get(i).getName()));
  }
  try {
    buffer.close();
    exampleReader.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
  if (outFile.exists()) {
    outFile.delete();
  }
  File tempFile=new File(inIFile.getFullPath().toOSString().split(""String_Node_Str"")[0] + ""String_Node_Str"");
  if (tempFile.exists())   tempFile.delete();
  Files.copy(exampleFile.toPath(),tempFile.toPath());
  assertTrue(tempFile.exists());
  String replace=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + inIFile.getFullPath().toOSString());
  writer.replace(inIFile,""String_Node_Str"",replace);
  boolean foundReplacement=false;
  try {
    Scanner scanner=new Scanner(exampleFile);
    while (scanner.hasNextLine()) {
      String line=scanner.nextLine();
      if (line.contains(replace)) {
        foundReplacement=true;
      }
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
  assertTrue(foundReplacement);
  if (exampleFile.getAbsoluteFile().exists()) {
    exampleFile.delete();
  }
  Files.copy(tempFile.toPath(),exampleFile.toPath(),StandardCopyOption.REPLACE_EXISTING);
  tempFile.delete();
  return;
}",0.9911781445645989
133712,"/** 
 * Creates a new   {@code TableViewer} to show a {@link TableComponent}.
 * @param parent The containing  {@code Composite}.
 * @return The created JFace {@code TableViewer}.
 */
private TableViewer createTableViewer(Composite parent){
  TableViewer viewer=new TableViewer(this,SWT.BORDER | SWT.MULTI | SWT.FULL_SELECTION| SWT.H_SCROLL| SWT.V_SCROLL);
  final Table table=viewer.getTable();
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  viewer.setContentProvider(new TableComponentContentProvider());
  ColumnViewerToolTipSupport.enableFor(viewer,ToolTip.NO_RECREATE);
  ISelectionChangedListener listener=new ISelectionChangedListener(){
    @Override public void selectionChanged(    SelectionChangedEvent event){
      int[] selected=table.getSelectionIndices();
      List<Integer> rowIds=tableComponent.getRowIds();
      ArrayList<Integer> rows=new ArrayList<Integer>(selected.length);
      selectedIndices.clear();
      for (      int i : selected) {
        selectedIndices.add(i);
        rows.add(rowIds.get(i));
      }
      tableComponent.setSelectedRows(rows);
      removeRowAction.setEnabled(!event.getSelection().isEmpty());
      return;
    }
  }
;
  viewer.addSelectionChangedListener(listener);
  return viewer;
}","/** 
 * Creates a new   {@code TableViewer} to show a {@link TableComponent}.
 * @param parent The containing  {@code Composite}.
 * @return The created JFace {@code TableViewer}.
 */
private TableViewer createTableViewer(Composite parent){
  TableViewer viewer=new TableViewer(this,SWT.BORDER | SWT.MULTI | SWT.FULL_SELECTION| SWT.H_SCROLL| SWT.V_SCROLL);
  final Table table=viewer.getTable();
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  viewer.setContentProvider(new TableComponentContentProvider());
  ColumnViewerToolTipSupport.enableFor(viewer,ToolTip.NO_RECREATE);
  ISelectionChangedListener listener=new ISelectionChangedListener(){
    @Override public void selectionChanged(    SelectionChangedEvent event){
      int[] selected=table.getSelectionIndices();
      List<Integer> rowIds=tableComponent.getRowIds();
      ArrayList<Integer> rows=new ArrayList<Integer>(selected.length);
      selectedIndices.clear();
      for (      int i : selected) {
        selectedIndices.add(i);
        rows.add(rowIds.get(i));
      }
      tableComponent.setSelectedRows(rows);
      removeRowAction.setEnabled(!event.getSelection().isEmpty());
      return;
    }
  }
;
  viewer.addSelectionChangedListener(listener);
  viewer.setComparer(new IElementComparer(){
    @Override public int hashCode(    Object element){
      return element.hashCode();
    }
    @Override public boolean equals(    Object a,    Object b){
      return a == b;
    }
  }
);
  return viewer;
}",0.9038810301051868
133713,"/** 
 * Creates the JFace   {@code Action}s used to add or remove rows to or from the   {@link #tableComponent}.
 */
private void createActions(){
  addRowAction=new Action(""String_Node_Str"",Action.AS_PUSH_BUTTON){
    @Override public void run(){
      tableComponent.addRow();
    }
  }
;
  addRowAction.setToolTipText(""String_Node_Str"");
  removeRowAction=new Action(""String_Node_Str"",Action.AS_PUSH_BUTTON){
    @Override public void run(){
      setEnabled(false);
      for (int i=selectedIndices.size() - 1; i >= 0; i--) {
        tableComponent.deleteRow(selectedIndices.get(i));
      }
      selectedIndices.clear();
      tableComponent.setSelectedRows(new ArrayList<Integer>());
    }
  }
;
  removeRowAction.setToolTipText(""String_Node_Str"");
  removeRowAction.setEnabled(false);
  return;
}","/** 
 * Creates the JFace   {@code Action}s used to add or remove rows to or from the   {@link #tableComponent}.
 */
private void createActions(){
  addRowAction=new Action(""String_Node_Str"",Action.AS_PUSH_BUTTON){
    @Override public void run(){
      tableComponent.addRow();
      System.out.println(""String_Node_Str"");
      for (int i=0; i < tableComponent.getRowIds().size(); i++) {
        System.out.println(tableComponent.getRow(i).toString());
      }
    }
  }
;
  addRowAction.setToolTipText(""String_Node_Str"");
  removeRowAction=new Action(""String_Node_Str"",Action.AS_PUSH_BUTTON){
    @Override public void run(){
      setEnabled(false);
      for (int i=selectedIndices.size() - 1; i >= 0; i--) {
        tableComponent.deleteRow(selectedIndices.get(i));
      }
      selectedIndices.clear();
      tableComponent.setSelectedRows(new ArrayList<Integer>());
    }
  }
;
  removeRowAction.setToolTipText(""String_Node_Str"");
  removeRowAction.setEnabled(false);
  return;
}",0.8973214285714286
133714,"/** 
 * This operation returns the value of the material property with the given name.
 * @param key The key/name of the property whose value should be returned
 * @return the value
 */
public double getProperty(String key){
  return properties.get(key);
}","/** 
 * This operation returns the value of the material property with the given name.
 * @param key The key/name of the property whose value should be returned
 * @return the value or 0.0 if this value is not in the map, butnever null.
 */
public double getProperty(String key){
  double value=0.0;
  if (properties.containsKey(key)) {
    value=properties.get(key);
  }
  return value;
}",0.772093023255814
133715,"/** 
 * This operation checks the Material class to make sure that simple attributes such as names and properties can be changed.
 */
@Test public void checkSimpleAttributes(){
  Material testMaterial=TestMaterialFactory.createCO2();
  testMaterial.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",testMaterial.getName());
  testMaterial.setSize(1);
  assertEquals(1,testMaterial.getSize());
  testMaterial.setProperty(""String_Node_Str"",44.01);
  double mass=testMaterial.getProperty(""String_Node_Str"");
  assertEquals(44.01,mass,1.0e-16);
  testMaterial.setProperty(""String_Node_Str"",5.73);
  double pressure=testMaterial.getProperty(""String_Node_Str"");
  assertEquals(5.73,pressure,1.0e-16);
  Map<String,Double> properties=testMaterial.getProperties();
  assertTrue(properties.containsKey(""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str""));
  return;
}","/** 
 * This operation checks the Material class to make sure that simple attributes such as names and properties can be changed.
 */
@Test public void checkSimpleAttributes(){
  Material testMaterial=TestMaterialFactory.createCO2();
  testMaterial.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",testMaterial.getName());
  testMaterial.setSize(1);
  assertEquals(1,testMaterial.getSize());
  testMaterial.setProperty(""String_Node_Str"",44.01);
  double mass=testMaterial.getProperty(""String_Node_Str"");
  assertEquals(44.01,mass,1.0e-16);
  testMaterial.setProperty(""String_Node_Str"",5.73);
  double pressure=testMaterial.getProperty(""String_Node_Str"");
  assertEquals(5.73,pressure,1.0e-16);
  Map<String,Double> properties=testMaterial.getProperties();
  assertTrue(properties.containsKey(""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str""));
  assertEquals(0.0,testMaterial.getProperty(""String_Node_Str""),1.0e-8);
  return;
}",0.961248654467169
133716,"/** 
 * This private method recursively walks the EObject tree and creates  a EMFTreeComposite representing the XML data. 
 * @param rootNode
 * @param parent
 */
private void mapToEMFTreeComposite(EObject rootNode,EMFTreeComposite parent){
  EList<EObject> subChildren=rootNode.eContents();
  if (subChildren.isEmpty()) {
    parent.setNextChild(new EMFTreeComposite(rootNode));
  }
 else {
    EMFTreeComposite thisTreeNode=new EMFTreeComposite(rootNode);
    for (    EObject obj : subChildren) {
      mapToEMFTreeComposite(obj,thisTreeNode);
    }
    parent.setNextChild(thisTreeNode);
  }
  return;
}","/** 
 * This private method recursively walks the EObject tree and creates  a EMFTreeComposite representing the XML data. 
 * @param rootNode
 * @param parent
 */
private void mapToEMFTreeComposite(EObject rootNode,EMFTreeComposite parent){
  EList<EObject> subChildren=rootNode.eContents();
  if (subChildren.isEmpty()) {
    parent.setNextChild(new EMFTreeComposite(rootNode));
  }
 else {
    EMFTreeComposite thisTreeNode=new EMFTreeComposite(rootNode);
    for (    EObject obj : subChildren) {
      mapToEMFTreeComposite(obj,thisTreeNode);
    }
    if (parent.getName().equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + thisTreeNode.getName() + ""String_Node_Str""+ parent.getName());
    }
    parent.setNextChild(thisTreeNode);
  }
  return;
}",0.8784370477568741
133717,"/** 
 * The constructor
 */
public EMFEntry(EAttribute attribute,EObject ecoreNode,boolean initializeDefaultValues){
  super();
  entryMetaData=attribute;
  containingEcoreNode=ecoreNode;
  setName(entryMetaData.getName());
  typeName=attribute.getEType().getInstanceClassName();
  if (containingEcoreNode != null) {
    if (typeName != null && initializeDefaultValues && entryMetaData.getUpperBound() != -1) {
      if (typeName.equals(""String_Node_Str"")) {
        containingEcoreNode.eSet(entryMetaData,""String_Node_Str"");
      }
 else       if (typeName.equals(""String_Node_Str"")) {
        BigInteger b=new BigInteger(""String_Node_Str"");
        containingEcoreNode.eSet(entryMetaData,b);
      }
 else       if (typeName.equals(""String_Node_Str"")) {
        BigDecimal d=new BigDecimal(0.0);
        containingEcoreNode.eSet(entryMetaData,d);
      }
    }
  }
}","/** 
 * The constructor
 */
public EMFEntry(EAttribute attribute,EObject ecoreNode){
  super();
  entryMetaData=attribute;
  containingEcoreNode=ecoreNode;
  setName(entryMetaData.getName());
  typeName=attribute.getEType().getInstanceClassName();
  Object initialValue=containingEcoreNode.eGet(entryMetaData);
  if (initialValue != null && typeName != null) {
    try {
      if (typeName.equals(""String_Node_Str"")) {
        BigInteger b=(BigInteger)initialValue;
        setValue(b.toString());
      }
 else       if (typeName.equals(""String_Node_Str"")) {
        BigDecimal d=(BigDecimal)initialValue;
        setValue(d.toString());
      }
 else       if (typeName.equals(""String_Node_Str"")) {
        setValue((String)initialValue);
      }
    }
 catch (    ClassCastException e) {
      return;
    }
  }
}",0.5317507418397626
133718,"/** 
 * This operation provides a deep copy of the EMFEntry.
 */
public Object clone(){
  EMFEntry entry=new EMFEntry(entryMetaData,EcoreUtil.create(entryMetaData.getEContainingClass()),false);
  entry.copy(this);
  return entry;
}","/** 
 * This operation provides a deep copy of the EMFEntry.
 */
public Object clone(){
  EMFEntry entry=new EMFEntry(entryMetaData,EcoreUtil.create(entryMetaData.getEContainingClass()));
  entry.copy(this);
  return entry;
}",0.986842105263158
133719,"/** 
 * This operation overrides the default/abstract implementation of ISelectionListener.selectionChanged to display the resource selected in the ICEResourceView.
 * @param part The IWorkbenchPart that called this function.
 * @param selection The ISelection chosen in the part parameter.
 */
@Override public void selectionChanged(IWorkbenchPart part,ISelection selection){
  if (part.getSite().getId().equals(ICEResourceView.ID)) {
    Object selectedElement=((ITreeSelection)selection).getFirstElement();
    ICEResource selectedResource=null;
    if (selectedElement instanceof String) {
      selectedResource=resourceView.resourceChildMap.get(selectedElement);
    }
 else     if (selectedElement instanceof PropertySource) {
      PropertySource source=(PropertySource)selectedElement;
      selectedResource=(ICEResource)source.getWrappedData();
    }
    if (selectedResource != null && !(selectedResource instanceof VizResource)) {
      if (browser != null && !browser.isDisposed()) {
        currentResource=selectedResource;
        browser.setUrl(currentResource.getPath().toString());
        layout.topControl=browser;
        parent.layout();
      }
    }
 else     if (selectedResource != null) {
      layout.topControl=plotComposite;
      try {
        IPlot plot=plotMap.get(selectedResource.getPath().toString());
        Map<String,String[]> plotTypes=plot.getPlotTypes();
        ArrayList<String> keys=new ArrayList<String>(plotTypes.keySet());
        String category=keys.get(0);
        String type=plotTypes.get(category)[0];
        plot.draw(category,type,plotComposite);
        plotComposite.layout();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      parent.layout();
    }
  }
  return;
}","/** 
 * This operation overrides the default/abstract implementation of ISelectionListener.selectionChanged to display the resource selected in the ICEResourceView.
 * @param part The IWorkbenchPart that called this function.
 * @param selection The ISelection chosen in the part parameter.
 */
@Override public void selectionChanged(IWorkbenchPart part,ISelection selection){
  if (part.getSite().getId().equals(ICEResourceView.ID)) {
    Object selectedElement=((ITreeSelection)selection).getFirstElement();
    ICEResource selectedResource=null;
    if (selectedElement instanceof String) {
      selectedResource=resourceView.resourceChildMap.get(selectedElement);
    }
 else     if (selectedElement instanceof PropertySource) {
      PropertySource source=(PropertySource)selectedElement;
      selectedResource=(ICEResource)source.getWrappedData();
    }
    if (selectedResource != null && !(selectedResource instanceof VizResource)) {
      if (browser != null && !browser.isDisposed()) {
        currentResource=selectedResource;
        browser.setUrl(currentResource.getPath().toString());
        layout.topControl=browser;
        parent.layout();
      }
    }
 else     if (selectedResource != null) {
      layout.topControl=plotComposite;
      try {
        IPlot plot=plotMap.get(selectedResource.getPath().toString());
        Map<String,String[]> plotTypes=plot.getPlotTypes();
        ArrayList<String> keys=new ArrayList<String>(plotTypes.keySet());
        String category=keys.get(0);
        String type=plotTypes.get(category)[0];
        for (        Control control : plotComposite.getChildren()) {
          control.dispose();
        }
        plot.draw(category,type,plotComposite);
        plotComposite.layout();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      parent.layout();
    }
  }
  return;
}",0.9699144355506486
133720,"/** 
 * Creates a new SWT   {@link Composite} with this <code>ViewAppState</code>embedded within it. This method gets an  {@link EmbeddedView} from the{@link MasterApplication}, connects with that view, and embeds that view in the <code>Composite</code>.
 * @param parent The parent <code>Composite</code>.
 * @return The <code>Composite</code> that has an embedded jME view managedby this <code>ViewAppState</code>. This <code>Composite</code>'s layout should be set by the caller. <b>This <code>Composite</code> should be disposed when it is no longer required</b>.
 */
public Composite createComposite(Composite parent){
  Composite composite=null;
  if (parent != null && embeddedView == null) {
    embeddedView=app.getEmbeddedView();
    composite=new Composite(parent,SWT.EMBEDDED){
      @Override public void dispose(){
        disposeView(embeddedView);
        super.dispose();
      }
    }
;
    Frame embeddedFrame=SWT_AWT.new_Frame(composite);
    embeddedFrame.setLayout(new BorderLayout());
    embeddedView.addToEmbeddedFrame(embeddedFrame);
    embeddedFrame.pack();
    embeddedFrame.setVisible(true);
    int limit=5000;
    int count=0;
    while (!isInitialized() && count < limit) {
      try {
        Thread.sleep(50);
        count+=50;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    embeddedView.registerViewClient(this);
  }
  return composite;
}","/** 
 * Creates a new SWT   {@link Composite} with this <code>ViewAppState</code>embedded within it. This method gets an  {@link EmbeddedView} from the{@link MasterApplication}, connects with that view, and embeds that view in the <code>Composite</code>.
 * @param parent The parent <code>Composite</code>.
 * @return The <code>Composite</code> that has an embedded jME view managedby this <code>ViewAppState</code>. This <code>Composite</code>'s layout should be set by the caller. <b>This <code>Composite</code> should be disposed when it is no longer required</b>.
 */
public Composite createComposite(Composite parent){
  Composite composite=null;
  if (parent != null && embeddedView == null) {
    embeddedView=app.getEmbeddedView();
    composite=new Composite(parent,SWT.EMBEDDED){
      @Override public void dispose(){
        disposeView(embeddedView);
        super.dispose();
      }
    }
;
    Frame embeddedFrame=SWT_AWT.new_Frame(composite);
    embeddedFrame.setLayout(new BorderLayout());
    embeddedView.addToEmbeddedFrame(embeddedFrame);
    embeddedFrame.pack();
    embeddedFrame.setVisible(true);
    int limit=5000;
    int count=0;
    while (!isInitialized() && count < limit) {
      try {
        Thread.sleep(50);
        count+=50;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    embeddedView.registerViewClient(this);
    enableControls();
  }
  return composite;
}",0.9923291492329148
133721,"/** 
 * Creates a default   {@link FlightCamera} for the specified<code>EmbeddedView</code>.
 */
@Override public Object createViewCamera(EmbeddedView view){
  Object cam=null;
  if (view != null && view == embeddedView) {
    FlightCamera flyCam=new FlightCamera(view.getCamera());
    flyCam.setInputManager(app.getInputManager());
    flyCam.setEnabled(false);
    cam=flyCam;
  }
  return cam;
}","/** 
 * Creates a default   {@link FlightCamera} for the specified<code>EmbeddedView</code>.
 */
@Override public Object createViewCamera(EmbeddedView view){
  Object cam=null;
  if (view != null && view == embeddedView) {
    FlightCamera flyCam=new FlightCamera(view.getCamera());
    flyCam.setInputManager(app.getInputManager());
    flyCam.setEnabled(true);
    cam=flyCam;
  }
  return cam;
}",0.9912170639899625
133722,"/** 
 * Enables or disables the default   {@link FlightCamera} associated withthe <code>EmbeddedView</code>.
 */
@Override public void updateViewCamera(EmbeddedView view,boolean enabled){
  if (view != null && view == embeddedView) {
    FlightCamera flyCam=(FlightCamera)view.getViewCamera();
    flyCam.setEnabled(enabled);
  }
  return;
}","/** 
 * Enables or disables the default   {@link FlightCamera} associated with the<code>EmbeddedView</code>.
 */
@Override public void updateViewCamera(EmbeddedView view,boolean enabled){
  if (view != null && view == embeddedView) {
    FlightCamera flyCam=(FlightCamera)view.getViewCamera();
    flyCam.setEnabled(enabled);
  }
  return;
}",0.9882697947214076
133723,"/** 
 * Overrides the default view camera to set its initial location based on the default position and orientation.
 */
@Override public Object createViewCamera(EmbeddedView view){
  Object cam=super.createViewCamera(view);
  if (cam != null) {
    FlightCamera flyCam=(FlightCamera)cam;
    flyCam.setPosition(defaultPosition);
    flyCam.setOrientation(defaultDirection,defaultUp);
  }
  return cam;
}","/** 
 * Overrides the default view camera to set its initial location based on the default position and orientation.
 */
@Override public Object createViewCamera(EmbeddedView view){
  Object cam=super.createViewCamera(view);
  if (cam != null) {
    FlightCamera flyCam=(FlightCamera)cam;
    flyCam.setPosition(defaultPosition);
    flyCam.setOrientation(defaultDirection,defaultUp);
    flyCam.setEnabled(true);
  }
  return cam;
}",0.965352449223417
133724,"private void setWorkingDirectoryName(){
  Date currentDate=new Date();
  SimpleDateFormat shortDate=new SimpleDateFormat(""String_Node_Str"");
  String separator=System.getProperty(""String_Node_Str"");
  String homeDir=System.getProperty(""String_Node_Str"");
  String launchDir=""String_Node_Str"";
  workingDirectoryBaseName=""String_Node_Str"" + shortDate.format(currentDate);
  if (isLocal.get()) {
    launchDir=homeDir + separator + ""String_Node_Str""+ separator+ ""String_Node_Str""+ separator+ ""String_Node_Str""+ separator+ workingDirectoryBaseName;
  }
 else   if (execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    String projId=execDictionary.get(""String_Node_Str"");
    launchDir=""String_Node_Str"" + separator + projId+ separator+ workingDirectoryBaseName;
  }
 else {
    launchDir=workingDirectoryBaseName;
  }
  execDictionary.put(""String_Node_Str"",launchDir);
  System.out.println(""String_Node_Str"" + execDictionary.get(""String_Node_Str""));
  return;
}","private void setWorkingDirectoryName(){
  Date currentDate=new Date();
  SimpleDateFormat shortDate=new SimpleDateFormat(""String_Node_Str"");
  String separator=System.getProperty(""String_Node_Str"");
  String homeDir=System.getProperty(""String_Node_Str"");
  String launchDir=""String_Node_Str"";
  workingDirectoryBaseName=""String_Node_Str"" + shortDate.format(currentDate);
  if (isLocal.get()) {
    launchDir=projectSpaceDir + separator + ""String_Node_Str""+ separator+ workingDirectoryBaseName;
  }
 else   if (execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    String projId=execDictionary.get(""String_Node_Str"");
    launchDir=""String_Node_Str"" + separator + projId+ separator+ workingDirectoryBaseName;
  }
 else {
    launchDir=workingDirectoryBaseName;
  }
  execDictionary.put(""String_Node_Str"",launchDir);
  System.out.println(""String_Node_Str"" + execDictionary.get(""String_Node_Str""));
  return;
}",0.9610526315789474
133725,"/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on the local machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchLocally(){
  FormStatus launchStatus;
  String separator=System.getProperty(""String_Node_Str"");
  String userHome=System.getProperty(""String_Node_Str"");
  String localProjectDir=userHome + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  File workingDirectory=new File(execDictionary.get(""String_Node_Str""));
  for (int i=0; i < splitCMD.size(); i++) {
    if (cancelled.get()) {
      break;
    }
    launchStatus=launchStageLocally(splitCMD.get(i),stdOut,stdErr);
    monitorJob();
    if (launchStatus.equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
  }
  status=FormStatus.Processed;
  return;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on the local machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchLocally(){
  FormStatus launchStatus;
  for (int i=0; i < splitCMD.size(); i++) {
    if (cancelled.get()) {
      break;
    }
    launchStatus=launchStageLocally(splitCMD.get(i),stdOut,stdErr);
    monitorJob();
    if (launchStatus.equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
  }
  status=FormStatus.Processed;
  return;
}",0.808338937457969
133726,"/** 
 * (non-Javadoc)
 * @see Runnable#run()
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
public void run(){
  String executable=null, inputFile=null, hostname=null;
  String stdOutFileName=null, stdErrFileName=null;
  String stdOutHeader=null, stdErrHeader=null;
  if (execDictionary != null) {
    executable=execDictionary.get(""String_Node_Str"");
    inputFile=execDictionary.get(""String_Node_Str"");
    stdOutFileName=execDictionary.get(""String_Node_Str"");
    stdErrFileName=execDictionary.get(""String_Node_Str"");
    hostname=execDictionary.get(""String_Node_Str"");
    uploadInput=Boolean.valueOf(execDictionary.get(""String_Node_Str""));
  }
  if (executable == null || (uploadInput && inputFile == null) || stdOutFileName == null || stdErrFileName == null || hostname == null) {
    status=FormStatus.InfoError;
    return;
  }
  if (execDictionary.get(""String_Node_Str"") != null && (""String_Node_Str"").equals(execDictionary.get((""String_Node_Str"")))) {
    appendInput=false;
  }
  setWorkingDirectoryName();
  fullCMD=fixExecutableName();
  stdOutFileName=execDictionary.get(""String_Node_Str"");
  stdOut=getBufferedWriter(stdOutFileName);
  stdErrFileName=execDictionary.get(""String_Node_Str"");
  stdErr=getBufferedWriter(stdErrFileName);
  stdOutHeader=createOutputHeader(""String_Node_Str"");
  stdErrHeader=createOutputHeader(""String_Node_Str"");
  try {
    stdOut.write(stdOutHeader);
    stdErr.write(stdErrHeader);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  if (isLocal.get()) {
    launchLocally();
  }
 else {
    launchRemotely();
  }
  try {
    stdOut.close();
    stdErr.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  return;
}","/** 
 * (non-Javadoc)
 * @see Runnable#run()
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
public void run(){
  String executable=null, inputFile=null, hostname=null;
  String stdOutFileName=null, stdErrFileName=null;
  String stdOutHeader=null, stdErrHeader=null;
  if (execDictionary != null) {
    executable=execDictionary.get(""String_Node_Str"");
    inputFile=execDictionary.get(""String_Node_Str"");
    stdOutFileName=execDictionary.get(""String_Node_Str"");
    stdErrFileName=execDictionary.get(""String_Node_Str"");
    hostname=execDictionary.get(""String_Node_Str"");
    projectSpaceDir=execDictionary.get(""String_Node_Str"");
    uploadInput=Boolean.valueOf(execDictionary.get(""String_Node_Str""));
  }
  if (executable == null || (uploadInput && inputFile == null) || stdOutFileName == null || stdErrFileName == null || hostname == null) {
    status=FormStatus.InfoError;
    return;
  }
  if (execDictionary.get(""String_Node_Str"") != null && (""String_Node_Str"").equals(execDictionary.get((""String_Node_Str"")))) {
    appendInput=false;
  }
  setWorkingDirectoryName();
  fullCMD=fixExecutableName();
  stdOutFileName=execDictionary.get(""String_Node_Str"");
  stdOut=getBufferedWriter(stdOutFileName);
  stdErrFileName=execDictionary.get(""String_Node_Str"");
  stdErr=getBufferedWriter(stdErrFileName);
  stdOutHeader=createOutputHeader(""String_Node_Str"");
  stdErrHeader=createOutputHeader(""String_Node_Str"");
  try {
    stdOut.write(stdOutHeader);
    stdErr.write(stdErrHeader);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  if (isLocal.get()) {
    launchLocally();
  }
 else {
    launchRemotely();
  }
  try {
    stdOut.close();
    stdErr.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  return;
}",0.9837420777073574
133727,"/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on a remote machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchRemotely(){
  IRemoteServices remoteServices=RemoteServices.getRemoteServices(""String_Node_Str"");
  IRemoteConnection connection=null;
  String remoteDownloadDirectory=execDictionary.get(""String_Node_Str"");
  String separator=System.getProperty(""String_Node_Str"");
  File localStorageDir=null;
  Date currentDate=new Date();
  SimpleDateFormat shortDate=new SimpleDateFormat(""String_Node_Str"");
  String homeDir=System.getProperty(""String_Node_Str"");
  String localDirectoryPath=""String_Node_Str"";
  localDirectoryPath=homeDir + separator + ""String_Node_Str""+ separator+ ""String_Node_Str""+ separator+ ""String_Node_Str""+ separator+ ""String_Node_Str""+ shortDate.format(currentDate);
  localStorageDir=new File(localDirectoryPath);
  if (!localStorageDir.exists()) {
    localStorageDir.mkdirs();
  }
  execDictionary.put(""String_Node_Str"",localDirectoryPath);
  IFileStore localDirectory=EFS.getLocalFileSystem().fromLocalFile(localStorageDir);
  String launchCMDFileName=""String_Node_Str"";
  if (remoteServices.canCreateConnections()) {
    try {
      connection=remoteServices.getConnectionManager().newConnection(execDictionary.get(""String_Node_Str""));
    }
 catch (    RemoteConnectionException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
  }
  while (!formSubmitted.get()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e1) {
      e1.printStackTrace();
      return;
    }
  }
  try {
    launchCMDFileName=writeRemoteCommandFile();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return;
  }
  connection.setAddress(execDictionary.get(""String_Node_Str""));
  DataComponent credentials=(DataComponent)formAtomic.get().getComponent(1);
  connection.setUsername(credentials.retrieveAllEntries().get(0).getValue());
  connection.setPassword(credentials.retrieveAllEntries().get(1).getValue());
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  if (connection.isOpen() && !cancelled.get()) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    IRemoteFileManager fileManager=remoteServices.getFileManager(connection);
    IFileStore fileStore=fileManager.getResource(connection.getWorkingDirectory());
    try {
      IFileStore directory=fileStore.getChild(workingDirectoryBaseName).mkdir(EFS.SHALLOW,null);
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + directory.getName());
      for (      String shortInputName : fileMap.keySet()) {
        if (cancelled.get()) {
          break;
        }
        if (uploadInput || (!uploadInput && shortInputName.equals(""String_Node_Str""))) {
          IFileStore remoteFileStore=directory.getChild(shortInputName);
          File localFile=new File(fileMap.get(shortInputName));
          IFileStore localFileStore=EFS.getLocalFileSystem().fromLocalFile(localFile);
          localFileStore.copy(remoteFileStore,EFS.NONE,null);
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + shortInputName);
        }
      }
    }
 catch (    CoreException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
    String currentWd=connection.getWorkingDirectory();
    connection.setWorkingDirectory(currentWd + remoteSeparator + workingDirectoryBaseName);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + connection.getWorkingDirectory());
    String launchCMD=""String_Node_Str"";
    if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
 else {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
    IRemoteProcessBuilder processBuilder=remoteServices.getProcessBuilder(connection,""String_Node_Str"",launchCMD);
    processBuilder.redirectErrorStream(false);
    try {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ launchCMDFileName);
      remoteJob=processBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
    }
 catch (    IOException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    InputStream stdOutStream=remoteJob.getInputStream();
    InputStream stdErrStream=remoteJob.getErrorStream();
    if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
    monitorJob();
    if (!cancelled.get()) {
      String fixedRemoteWD=currentWd + remoteSeparator + workingDirectoryBaseName;
      String remoteDir=(remoteDownloadDirectory == null) ? fixedRemoteWD : remoteDownloadDirectory;
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + localDirectory.getName() + ""String_Node_Str""+ remoteDir+ ""String_Node_Str"");
      IFileStore downloadFileStore=fileManager.getResource(remoteDir);
      try {
        IFileStore[] remoteStores=downloadFileStore.childStores(EFS.NONE,null);
        for (        IFileStore remoteFile : remoteStores) {
          if (cancelled.get()) {
            break;
          }
          IFileInfo fileInfo=remoteFile.fetchInfo();
          if (fileInfo.getLength() < maxFileSize) {
            String msg=""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getName() + ""String_Node_Str""+ fileInfo.getLength()+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
            IFileStore childStore=localDirectory.getChild(remoteFile.getName());
            remoteFile.copy(childStore,EFS.OVERWRITE,null);
          }
 else {
            long sizeDiff=fileInfo.getLength() - maxFileSize;
            String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getLength() + ""String_Node_Str""+ sizeDiff+ ""String_Node_Str""+ maxFileSize+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
          }
          stdOut.flush();
        }
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  status=FormStatus.Processed;
  connection.close();
  return;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on a remote machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchRemotely(){
  IRemoteServices remoteServices=RemoteServices.getRemoteServices(""String_Node_Str"");
  IRemoteConnection connection=null;
  String remoteDownloadDirectory=execDictionary.get(""String_Node_Str"");
  String separator=System.getProperty(""String_Node_Str"");
  File localStorageDir=null;
  Date currentDate=new Date();
  SimpleDateFormat shortDate=new SimpleDateFormat(""String_Node_Str"");
  String homeDir=System.getProperty(""String_Node_Str"");
  String localDirectoryPath=""String_Node_Str"";
  localDirectoryPath=projectSpaceDir + separator + ""String_Node_Str""+ separator+ ""String_Node_Str""+ shortDate.format(currentDate);
  localStorageDir=new File(localDirectoryPath);
  if (!localStorageDir.exists()) {
    localStorageDir.mkdirs();
  }
  execDictionary.put(""String_Node_Str"",localDirectoryPath);
  IFileStore localDirectory=EFS.getLocalFileSystem().fromLocalFile(localStorageDir);
  String launchCMDFileName=""String_Node_Str"";
  if (remoteServices.canCreateConnections()) {
    try {
      connection=remoteServices.getConnectionManager().newConnection(execDictionary.get(""String_Node_Str""));
    }
 catch (    RemoteConnectionException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
  }
  while (!formSubmitted.get()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e1) {
      e1.printStackTrace();
      return;
    }
  }
  try {
    launchCMDFileName=writeRemoteCommandFile();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return;
  }
  connection.setAddress(execDictionary.get(""String_Node_Str""));
  DataComponent credentials=(DataComponent)formAtomic.get().getComponent(1);
  connection.setUsername(credentials.retrieveAllEntries().get(0).getValue());
  connection.setPassword(credentials.retrieveAllEntries().get(1).getValue());
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  if (connection.isOpen() && !cancelled.get()) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    IRemoteFileManager fileManager=remoteServices.getFileManager(connection);
    IFileStore fileStore=fileManager.getResource(connection.getWorkingDirectory());
    try {
      IFileStore directory=fileStore.getChild(workingDirectoryBaseName).mkdir(EFS.SHALLOW,null);
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + directory.getName());
      for (      String shortInputName : fileMap.keySet()) {
        if (cancelled.get()) {
          break;
        }
        if (uploadInput || (!uploadInput && shortInputName.equals(""String_Node_Str""))) {
          IFileStore remoteFileStore=directory.getChild(shortInputName);
          File localFile=new File(fileMap.get(shortInputName));
          IFileStore localFileStore=EFS.getLocalFileSystem().fromLocalFile(localFile);
          localFileStore.copy(remoteFileStore,EFS.NONE,null);
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + shortInputName);
        }
      }
    }
 catch (    CoreException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
    String currentWd=connection.getWorkingDirectory();
    connection.setWorkingDirectory(currentWd + remoteSeparator + workingDirectoryBaseName);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + connection.getWorkingDirectory());
    String launchCMD=""String_Node_Str"";
    if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
 else {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
    IRemoteProcessBuilder processBuilder=remoteServices.getProcessBuilder(connection,""String_Node_Str"",launchCMD);
    processBuilder.redirectErrorStream(false);
    try {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ launchCMDFileName);
      remoteJob=processBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
    }
 catch (    IOException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    InputStream stdOutStream=remoteJob.getInputStream();
    InputStream stdErrStream=remoteJob.getErrorStream();
    if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
    monitorJob();
    if (!cancelled.get()) {
      String fixedRemoteWD=currentWd + remoteSeparator + workingDirectoryBaseName;
      String remoteDir=(remoteDownloadDirectory == null) ? fixedRemoteWD : remoteDownloadDirectory;
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + localDirectory.getName() + ""String_Node_Str""+ remoteDir+ ""String_Node_Str"");
      IFileStore downloadFileStore=fileManager.getResource(remoteDir);
      try {
        IFileStore[] remoteStores=downloadFileStore.childStores(EFS.NONE,null);
        for (        IFileStore remoteFile : remoteStores) {
          if (cancelled.get()) {
            break;
          }
          IFileInfo fileInfo=remoteFile.fetchInfo();
          if (fileInfo.getLength() < maxFileSize) {
            String msg=""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getName() + ""String_Node_Str""+ fileInfo.getLength()+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
            IFileStore childStore=localDirectory.getChild(remoteFile.getName());
            remoteFile.copy(childStore,EFS.OVERWRITE,null);
          }
 else {
            long sizeDiff=fileInfo.getLength() - maxFileSize;
            String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getLength() + ""String_Node_Str""+ sizeDiff+ ""String_Node_Str""+ maxFileSize+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
          }
          stdOut.flush();
        }
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  status=FormStatus.Processed;
  connection.close();
  return;
}",0.9943468296409472
133728,"/** 
 * <!-- begin-UML-doc --> <p> This operation fills the data dictionary for the JobLaunchAction based on the contents of the Form. </p> <!-- end-UML-doc -->
 * @return <p>The status of the operation. It will only equal FormStatus.ReadyToProcess or FormStatus.InfoError and should cause the calling operation to fail if the latter is returned. </p>
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private FormStatus fillActionDataMap(){
  String filename=null, hostname=null;
  String installDir=""String_Node_Str"";
  IResource fileResource=null;
  String os=""String_Node_Str"", accountCode=""String_Node_Str"";
  DataComponent fileData=null, parallelData=null;
  Entry fileEntry=null, mpiEntry=null;
  int numProcs=1, numTBBThreads=1;
  fileData=(DataComponent)form.getComponent(JobLauncherForm.filesId);
  parallelData=(DataComponent)form.getComponent(JobLauncherForm.parallelId);
  if (fileData == null) {
    return FormStatus.InfoError;
  }
  actionDataMap=new Hashtable<String,String>();
  fileData=(DataComponent)form.getComponent(1);
  for (  String entryName : inputFileNameMap.keySet()) {
    fileEntry=fileData.retrieveEntry(entryName);
    if (fileEntry != null) {
      fileResource=project.findMember(fileEntry.getValue());
      if (fileResource == null || !fileResource.exists()) {
        System.out.println(""String_Node_Str"" + filename);
        System.out.println(""String_Node_Str"" + fileEntry.getAllowedValues());
        return FormStatus.InfoError;
      }
      filename=fileResource.getLocation().toOSString();
      actionDataMap.put(inputFileNameMap.get(entryName).varName,filename);
    }
 else {
      System.out.println(""String_Node_Str"" + entryName);
    }
  }
  ArrayList<Integer> selectedRowIds=hostsTable.getSelectedRows();
  int selectedRowId=1;
  selectedRowId=0;
  if (selectedRowIds != null) {
    selectedRowId=selectedRowIds.get(0);
  }
  ArrayList<Entry> hostEntries=hostsTable.getRow(selectedRowId);
  hostname=hostEntries.get(0).getValue();
  os=hostEntries.get(1).getValue();
  installDir=hostEntries.get(2).getValue();
  if (parallelData != null) {
    mpiEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (mpiEntry != null) {
      numProcs=Math.max(numProcs,Integer.parseInt(mpiEntry.getValue()));
    }
    Entry tbbThreadsEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (tbbThreadsEntry != null) {
      numTBBThreads=Math.max(numTBBThreads,Integer.parseInt(tbbThreadsEntry.getValue()));
    }
    Entry accountEntry=parallelData.retrieveEntry(""String_Node_Str"");
    accountCode=accountEntry.getValue();
  }
  actionDataMap.put(""String_Node_Str"",executableCommandName);
  actionDataMap.put(""String_Node_Str"",String.valueOf(uploadInput));
  if (appendInput && !executableCommandName.contains(""String_Node_Str"")) {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  actionDataMap.put(""String_Node_Str"",installDir);
  actionDataMap.put(""String_Node_Str"",hostname);
  actionDataMap.put(""String_Node_Str"",os);
  actionDataMap.put(""String_Node_Str"",accountCode);
  actionDataMap.put(""String_Node_Str"",String.valueOf(numProcs));
  actionDataMap.put(""String_Node_Str"",String.valueOf(numTBBThreads));
  if (remoteDownloadDir != null) {
    actionDataMap.put(""String_Node_Str"",remoteDownloadDir);
  }
  if (debuggingEnabled) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + actionDataMap);
  }
  return FormStatus.ReadyToProcess;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation fills the data dictionary for the JobLaunchAction based on the contents of the Form. </p> <!-- end-UML-doc -->
 * @return <p>The status of the operation. It will only equal FormStatus.ReadyToProcess or FormStatus.InfoError and should cause the calling operation to fail if the latter is returned. </p>
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private FormStatus fillActionDataMap(){
  String filename=null, hostname=null;
  String installDir=""String_Node_Str"";
  IResource fileResource=null;
  String os=""String_Node_Str"", accountCode=""String_Node_Str"";
  DataComponent fileData=null, parallelData=null;
  Entry fileEntry=null, mpiEntry=null;
  int numProcs=1, numTBBThreads=1;
  String projectSpace=project.getLocation().toOSString();
  fileData=(DataComponent)form.getComponent(JobLauncherForm.filesId);
  parallelData=(DataComponent)form.getComponent(JobLauncherForm.parallelId);
  if (fileData == null) {
    return FormStatus.InfoError;
  }
  actionDataMap=new Hashtable<String,String>();
  fileData=(DataComponent)form.getComponent(1);
  for (  String entryName : inputFileNameMap.keySet()) {
    fileEntry=fileData.retrieveEntry(entryName);
    if (fileEntry != null) {
      fileResource=project.findMember(fileEntry.getValue());
      if (fileResource == null || !fileResource.exists()) {
        System.out.println(""String_Node_Str"" + filename);
        System.out.println(""String_Node_Str"" + fileEntry.getAllowedValues());
        return FormStatus.InfoError;
      }
      filename=fileResource.getLocation().toOSString();
      actionDataMap.put(inputFileNameMap.get(entryName).varName,filename);
    }
 else {
      System.out.println(""String_Node_Str"" + entryName);
    }
  }
  ArrayList<Integer> selectedRowIds=hostsTable.getSelectedRows();
  int selectedRowId=1;
  selectedRowId=0;
  if (selectedRowIds != null) {
    selectedRowId=selectedRowIds.get(0);
  }
  ArrayList<Entry> hostEntries=hostsTable.getRow(selectedRowId);
  hostname=hostEntries.get(0).getValue();
  os=hostEntries.get(1).getValue();
  installDir=hostEntries.get(2).getValue();
  if (parallelData != null) {
    mpiEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (mpiEntry != null) {
      numProcs=Math.max(numProcs,Integer.parseInt(mpiEntry.getValue()));
    }
    Entry tbbThreadsEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (tbbThreadsEntry != null) {
      numTBBThreads=Math.max(numTBBThreads,Integer.parseInt(tbbThreadsEntry.getValue()));
    }
    Entry accountEntry=parallelData.retrieveEntry(""String_Node_Str"");
    accountCode=accountEntry.getValue();
  }
  actionDataMap.put(""String_Node_Str"",executableCommandName);
  actionDataMap.put(""String_Node_Str"",String.valueOf(uploadInput));
  if (appendInput && !executableCommandName.contains(""String_Node_Str"")) {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  actionDataMap.put(""String_Node_Str"",installDir);
  actionDataMap.put(""String_Node_Str"",hostname);
  actionDataMap.put(""String_Node_Str"",os);
  actionDataMap.put(""String_Node_Str"",accountCode);
  actionDataMap.put(""String_Node_Str"",projectSpace);
  actionDataMap.put(""String_Node_Str"",String.valueOf(numProcs));
  actionDataMap.put(""String_Node_Str"",String.valueOf(numTBBThreads));
  if (remoteDownloadDir != null) {
    actionDataMap.put(""String_Node_Str"",remoteDownloadDir);
  }
  if (debuggingEnabled) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + actionDataMap);
  }
  return FormStatus.ReadyToProcess;
}",0.984576907044602
133729,"/** 
 * This operation creates a set of ICEFormPages for ListComponents that are stored in the component map.
 * @return The pages.
 */
private ArrayList<ICEFormPage> createListSectionPages(){
  ArrayList<ICEFormPage> pages=new ArrayList<ICEFormPage>();
  ArrayList<Component> lists=componentMap.get(""String_Node_Str"");
  if (lists.size() > 0) {
    for (int i=0; i < lists.size(); i++) {
      ListComponent list=(ListComponent)lists.get(i);
      if (list != null) {
        ListComponentSectionPage page=new ListComponentSectionPage(this,list.getName(),list.getName());
        page.setList(list);
      }
    }
  }
  return null;
}","/** 
 * This operation creates a set of ICEFormPages for ListComponents that are stored in the component map.
 * @return The pages.
 */
private ArrayList<ICEFormPage> createListSectionPages(){
  ArrayList<ICEFormPage> pages=new ArrayList<ICEFormPage>();
  ArrayList<Component> lists=componentMap.get(""String_Node_Str"");
  if (lists.size() > 0) {
    for (int i=0; i < lists.size(); i++) {
      ListComponent list=(ListComponent)lists.get(i);
      if (list != null) {
        ListComponentSectionPage page=new ListComponentSectionPage(this,list.getName(),list.getName());
        page.setList(list);
        pages.add(page);
      }
    }
  }
  return pages;
}",0.9737654320987654
133730,"protected void createFormContent(IManagedForm managedForm){
  final ScrolledForm scrolledForm=managedForm.getForm();
  final FormToolkit formToolkit=managedFormRef.getToolkit();
  GridLayout layout=new GridLayout(1,false);
  layout.marginWidth=0;
  layout.marginHeight=0;
  scrolledForm.getBody().setLayout(layout);
  managedFormRef=managedForm;
  if (list != null) {
    Composite parent=managedForm.getForm().getBody();
    Section listSection=formToolkit.createSection(parent,Section.TITLE_BAR | Section.DESCRIPTION | Section.TWISTIE| Section.EXPANDED| Section.COMPACT);
    Composite sectionClient=new Composite(parent,SWT.FLAT);
    Table table=formToolkit.createTable(sectionClient,SWT.FLAT);
    DefaultEventTableViewer tableViewer=new DefaultEventTableViewer(list,table,list);
    listSection.setClient(sectionClient);
  }
  return;
}","protected void createFormContent(IManagedForm managedForm){
  final ScrolledForm scrolledForm=managedForm.getForm();
  final FormToolkit formToolkit=managedForm.getToolkit();
  GridLayout layout=new GridLayout(1,true);
  layout.marginWidth=0;
  layout.marginHeight=0;
  scrolledForm.getBody().setLayout(layout);
  if (list != null) {
    Composite parent=managedForm.getForm().getBody();
    Section listSection=formToolkit.createSection(parent,Section.TITLE_BAR | Section.DESCRIPTION | Section.TWISTIE| Section.EXPANDED| Section.COMPACT);
    listSection.setLayout(new GridLayout(1,false));
    listSection.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
    Composite sectionClient=new Composite(listSection,SWT.FLAT);
    sectionClient.setLayout(new GridLayout(2,false));
    sectionClient.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
    Table listTable=formToolkit.createTable(sectionClient,SWT.FLAT);
    DefaultEventTableViewer listTableViewer=new DefaultEventTableViewer(list,listTable,list);
    listTable.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
    Composite listButtonComposite=new Composite(sectionClient,SWT.NONE);
    listButtonComposite.setLayout(new GridLayout(1,false));
    listButtonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.FILL,false,true,1,1));
    Button addMaterialButton=new Button(listButtonComposite,SWT.PUSH);
    addMaterialButton.setText(""String_Node_Str"");
    Button deleteMaterialButton=new Button(listButtonComposite,SWT.PUSH);
    deleteMaterialButton.setText(""String_Node_Str"");
    listSection.setClient(sectionClient);
  }
  return;
}",0.6429725363489499
133731,"/** 
 * <!-- begin-UML-doc --> <p> This operation writes an instance of a particular class type from the input stream into a Java Object. This operation requires both the Object and the specific class type because some classes, such as local classes, do return the appropriate class type from a call to ""this.getClass()."" </p> <!-- end-UML-doc -->
 * @param dataObject <p> An Object that is an instance of the Class that is parsed to create the XML InputStream. </p>
 * @param outputStream <p> An OutputStream to which the XML should be written by JAXB. </p>
 * @throws NullPointerException
 * @throws JAXBException
 * @throws IOException
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
public void write(Object dataObject,OutputStream outputStream) throws NullPointerException, JAXBException, IOException {
  JAXBContext jaxbContext=null;
  if (dataObject == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (outputStream == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (!dataObject.getClass().isAnonymousClass()) {
    jaxbContext=JAXBContext.newInstance(dataObject.getClass());
  }
 else {
    jaxbContext=JAXBContext.newInstance(dataObject.getClass().getSuperclass());
  }
  Marshaller marshaller=jaxbContext.createMarshaller();
  marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,Boolean.TRUE);
  marshaller.marshal(dataObject,outputStream);
}","/** 
 * <!-- begin-UML-doc --> <p> This operation writes an instance of a particular class type from the input stream into a Java Object. This operation requires both the Object and the specific class type because some classes, such as local classes, do return the appropriate class type from a call to ""this.getClass()."" </p> <!-- end-UML-doc -->
 * @param dataObject <p> An Object that is an instance of the Class that is parsed to create the XML InputStream. </p>
 * @param outputStream <p> An OutputStream to which the XML should be written by JAXB. </p>
 * @throws NullPointerException
 * @throws JAXBException
 * @throws IOException
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
public void write(Object dataObject,OutputStream outputStream) throws NullPointerException, JAXBException, IOException {
  JAXBContext jaxbContext=null;
  ArrayList<Class> classList=new ArrayList<Class>();
  Class[] classArray={};
  if (dataObject == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (outputStream == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (dataObject instanceof AbstractListComponent) {
    AbstractListComponent list=(AbstractListComponent)dataObject;
    if (list.size() > 0) {
      classList.add(AbstractListComponent.class);
      classList.add(list.get(0).getClass());
    }
  }
 else   if (!dataObject.getClass().isAnonymousClass()) {
    classList.add(dataObject.getClass());
  }
 else {
    classList.add(dataObject.getClass().getSuperclass());
  }
  if (classList.size() > 0) {
    jaxbContext=JAXBContext.newInstance(classList.toArray(classArray));
    Marshaller marshaller=jaxbContext.createMarshaller();
    marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,Boolean.TRUE);
    marshaller.marshal(dataObject,outputStream);
  }
  return;
}",0.8068695390177765
133732,"/** 
 * <!-- begin-UML-doc --> <p> This operation sets the input on the TreeCompositeViewer to the TreeComposite or set of TreeComposites in ICE. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private void setTreeCompositeViewerInput(){
  if (!(componentMap.get(""String_Node_Str"").isEmpty())) {
    try {
      getSite().getWorkbenchWindow().getActivePage().showView(getTreeCompositeViewerID());
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
    TreeComposite tree=(TreeComposite)componentMap.get(""String_Node_Str"").get(0);
    TreeCompositeViewer treeView=(TreeCompositeViewer)getSite().getWorkbenchWindow().getActivePage().findView(getTreeCompositeViewerID());
    treeView.setInput(tree);
    tree.unregister(this);
    tree.register(this);
  }
}","/** 
 * <!-- begin-UML-doc --> <p> This operation sets the input on the TreeCompositeViewer to the TreeComposite or set of TreeComposites in ICE. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private void setTreeCompositeViewerInput(){
  List<Component> trees=componentMap.get(""String_Node_Str"");
  if (!trees.isEmpty()) {
    try {
      getSite().getWorkbenchWindow().getActivePage().showView(getTreeCompositeViewerID());
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
    int id=getTreeCompositeViewerInputID();
    TreeComposite tree=null;
    if (id != -1) {
      for (      Component formTree : trees) {
        if (id == formTree.getId()) {
          tree=(TreeComposite)formTree;
          break;
        }
      }
    }
    if (tree == null) {
      tree=(TreeComposite)trees.get(0);
    }
    TreeCompositeViewer treeView=(TreeCompositeViewer)getSite().getWorkbenchWindow().getActivePage().findView(getTreeCompositeViewerID());
    treeView.setInput(tree);
    tree.unregister(this);
    tree.register(this);
  }
}",0.7850655903128153
133733,"/** 
 */
@Override public ArrayList<Entry> findAll(URI uri,String regex){
  ArrayList<Entry> retEntries=new ArrayList<Entry>();
  TreeComposite tree=(TreeComposite)read(uri);
  BreadthFirstTreeCompositeIterator iter=new BreadthFirstTreeCompositeIterator(tree);
  while (iter.hasNext()) {
    TreeComposite child=iter.next();
    if (child.getActiveDataNode() != null) {
      DataComponent data=(DataComponent)child.getActiveDataNode();
      for (      Entry e : data.retrieveAllEntries()) {
        if (e.getName().toLowerCase().contains(regex) && !e.getName().toLowerCase().contains(""String_Node_Str"")) {
          e.setName(child.getName());
          retEntries.add((Entry)e.clone());
        }
      }
    }
  }
  return retEntries;
}","/** 
 */
@Override public ArrayList<Entry> findAll(URI uri,String regex){
  ArrayList<Entry> retEntries=new ArrayList<Entry>();
  TreeComposite tree=(TreeComposite)read(uri);
  BreadthFirstTreeCompositeIterator iter=new BreadthFirstTreeCompositeIterator(tree);
  while (iter.hasNext()) {
    TreeComposite child=iter.next();
    if (child.getActiveDataNode() != null) {
      DataComponent data=(DataComponent)child.getActiveDataNode();
      for (      Entry e : data.retrieveAllEntries()) {
        if (!""String_Node_Str"".equals(e.getTag()) && e.getName().toLowerCase().contains(regex) && !e.getName().toLowerCase().contains(""String_Node_Str"")) {
          e.setName(child.getName());
          retEntries.add((Entry)e.clone());
        }
      }
    }
  }
  return retEntries;
}",0.920447074293228
133734,"@Override public void widgetSelected(SelectionEvent e){
  notifyListeners(SWT.Selection,new Event());
  IClient client=ClientHolder.getClient();
  FileDialog fileDialog=new FileDialog(getShell());
  fileDialog.setText(""String_Node_Str"");
  String fileName=fileDialog.open();
  if (fileName != null) {
    File importedFile=new File(fileName);
    client.importFile(importedFile.toURI());
    setEntryValue(fileName);
  }
  return;
}","@Override public void widgetSelected(SelectionEvent e){
  notifyListeners(SWT.Selection,new Event());
  IClient client=ClientHolder.getClient();
  FileDialog fileDialog=new FileDialog(getShell());
  fileDialog.setText(""String_Node_Str"");
  String filePath=fileDialog.open();
  if (filePath != null) {
    File importedFile=new File(filePath);
    client.importFile(importedFile.toURI());
    setEntryValue(importedFile.getName());
  }
  return;
}",0.9476082004555808
133735,"/** 
 * This method creates a browse button on the EntryComposite. Clicking the button opens a file browser, and once a file is selected, the file is imported into the default workspace.
 */
private void createBrowseButton(){
  Button browseButton=new Button(this,SWT.PUSH);
  browseButton.setText(""String_Node_Str"");
  browseButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      notifyListeners(SWT.Selection,new Event());
      IClient client=ClientHolder.getClient();
      FileDialog fileDialog=new FileDialog(getShell());
      fileDialog.setText(""String_Node_Str"");
      String fileName=fileDialog.open();
      if (fileName != null) {
        File importedFile=new File(fileName);
        client.importFile(importedFile.toURI());
        setEntryValue(fileName);
      }
      return;
    }
  }
);
  buttons.add(browseButton);
  return;
}","/** 
 * This method creates a browse button on the EntryComposite. Clicking the button opens a file browser, and once a file is selected, the file is imported into the default workspace.
 */
private void createBrowseButton(){
  Button browseButton=new Button(this,SWT.PUSH);
  browseButton.setText(""String_Node_Str"");
  browseButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      notifyListeners(SWT.Selection,new Event());
      IClient client=ClientHolder.getClient();
      FileDialog fileDialog=new FileDialog(getShell());
      fileDialog.setText(""String_Node_Str"");
      String filePath=fileDialog.open();
      if (filePath != null) {
        File importedFile=new File(filePath);
        client.importFile(importedFile.toURI());
        setEntryValue(importedFile.getName());
      }
      return;
    }
  }
);
  buttons.add(browseButton);
  return;
}",0.975027144408252
133736,"/** 
 * <!-- begin-UML-doc --> <p> This operation creates a drop-down menu on the Composite. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private void createDropdown(){
  dropDown=new Combo(this,SWT.DROP_DOWN | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL| SWT.READ_ONLY);
  dropDown.setBackground(getBackground());
  for (  String i : entry.getAllowedValues()) {
    dropDown.add(i);
  }
  dropDown.select(dropDown.indexOf(entry.getValue()));
  dropDown.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      notifyListeners(SWT.Selection,new Event());
      setEntryValue(dropDown.getItem(dropDown.getSelectionIndex()));
    }
  }
);
  return;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation creates a drop-down menu on the Composite. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private void createDropdown(){
  dropDown=new Combo(this,SWT.DROP_DOWN | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL| SWT.READ_ONLY);
  dropDown.setBackground(getBackground());
  String currentValue=entry.getValue();
  List<String> allowedValues=entry.getAllowedValues();
  for (int i=0; i < allowedValues.size(); i++) {
    String allowedValue=allowedValues.get(i);
    dropDown.add(allowedValue);
    if (allowedValue.equals(currentValue)) {
      dropDown.select(i);
    }
  }
  dropDown.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      notifyListeners(SWT.Selection,new Event());
      setEntryValue(dropDown.getItem(dropDown.getSelectionIndex()));
    }
  }
);
  return;
}",0.7769452449567723
133737,"/** 
 * <!-- begin-UML-doc --> <p> This operation renders the SWT widgets for the Entry. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void render(){
  int numAllowedValues=0, maxValueLength=12, maxShortValues=8;
  boolean shortValues=true;
  AllowedValueType valueType=null;
  for (  String value : entry.getAllowedValues()) {
    lowercaseAllowedValues.add(value.toLowerCase());
  }
  valueType=entry.getValueType();
  numAllowedValues=entry.getAllowedValues().size();
  for (  String i : entry.getAllowedValues()) {
    if (i.length() > maxValueLength) {
      shortValues=false;
      break;
    }
  }
  if (getLayout() == null) {
    FillLayout layout=new FillLayout(SWT.VERTICAL);
    layout.marginHeight=5;
    layout.marginWidth=3;
    layout.spacing=5;
    setLayout(layout);
  }
  FillLayout fillLayout=new FillLayout(SWT.VERTICAL);
  fillLayout.marginHeight=5;
  fillLayout.marginWidth=3;
  fillLayout.spacing=5;
  Layout layout=fillLayout;
  if (valueType == AllowedValueType.Discrete && numAllowedValues > 0) {
    if (numAllowedValues <= maxShortValues && shortValues) {
      if (numAllowedValues == 2 && allowedBinaryValues.containsAll(lowercaseAllowedValues)) {
        createCheckbox();
      }
 else {
        createLabel();
        createButtons();
      }
    }
 else {
      createLabel();
      createDropdown();
    }
  }
 else   if (valueType == AllowedValueType.Discrete) {
    throwMissingValuesError();
  }
 else   if (valueType == AllowedValueType.File) {
    createLabel();
    if (numAllowedValues > 0) {
      createDropdown();
    }
    createBrowseButton();
    final RowLayout rowLayout=new RowLayout();
    rowLayout.wrap=true;
    rowLayout.fill=false;
    rowLayout.center=true;
    layout=rowLayout;
    final RowData rowData=new RowData();
    dropDown.setLayoutData(rowData);
    final int minWidth=50;
    final int unwrappedWidth;
    Button button=buttons.get(0);
    int labelWidth=label.computeSize(SWT.DEFAULT,SWT.DEFAULT).x;
    int buttonWidth=button.computeSize(SWT.DEFAULT,SWT.DEFAULT).x;
    int padding=2 * rowLayout.spacing + rowLayout.marginLeft + rowLayout.marginWidth * 2 + rowLayout.marginRight + 30;
    unwrappedWidth=labelWidth + buttonWidth + padding;
    int availableWidth=getClientArea().width - unwrappedWidth;
    rowData.width=(availableWidth > minWidth ? availableWidth : minWidth);
    if (resizeListener != null) {
      removeControlListener(resizeListener);
    }
    resizeListener=new ControlAdapter(){
      @Override public void controlResized(      ControlEvent e){
        int availableWidth=getClientArea().width - unwrappedWidth;
        rowData.width=(availableWidth > minWidth ? availableWidth : minWidth);
        layout();
      }
    }
;
    addControlListener(resizeListener);
  }
 else {
    createLabel();
    createTextfield();
  }
  setLayout(layout);
  return;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation renders the SWT widgets for the Entry. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void render(){
  int numAllowedValues=0, maxValueLength=12, maxShortValues=8;
  boolean shortValues=true;
  AllowedValueType valueType=null;
  for (  String value : entry.getAllowedValues()) {
    lowercaseAllowedValues.add(value.toLowerCase());
  }
  valueType=entry.getValueType();
  numAllowedValues=entry.getAllowedValues().size();
  for (  String i : entry.getAllowedValues()) {
    if (i.length() > maxValueLength) {
      shortValues=false;
      break;
    }
  }
  FillLayout fillLayout=new FillLayout(SWT.VERTICAL);
  fillLayout.marginHeight=5;
  fillLayout.marginWidth=3;
  fillLayout.spacing=5;
  Layout layout=fillLayout;
  if (valueType == AllowedValueType.Discrete && numAllowedValues > 0) {
    if (numAllowedValues <= maxShortValues && shortValues) {
      if (numAllowedValues == 2 && allowedBinaryValues.containsAll(lowercaseAllowedValues)) {
        createCheckbox();
      }
 else {
        createLabel();
        createButtons();
      }
    }
 else {
      createLabel();
      createDropdown();
    }
  }
 else   if (valueType == AllowedValueType.Discrete) {
    throwMissingValuesError();
  }
 else   if (valueType == AllowedValueType.File) {
    createLabel();
    createDropdown();
    createBrowseButton();
    final RowLayout rowLayout=new RowLayout();
    rowLayout.wrap=true;
    rowLayout.fill=false;
    rowLayout.center=true;
    layout=rowLayout;
    final RowData rowData=new RowData();
    dropDown.setLayoutData(rowData);
    final int minWidth=50;
    final int unwrappedWidth;
    Button button=buttons.get(0);
    int labelWidth=label.computeSize(SWT.DEFAULT,SWT.DEFAULT).x;
    int buttonWidth=button.computeSize(SWT.DEFAULT,SWT.DEFAULT).x;
    int padding=2 * rowLayout.spacing + rowLayout.marginLeft + rowLayout.marginWidth * 2 + rowLayout.marginRight + 30;
    unwrappedWidth=labelWidth + buttonWidth + padding;
    int availableWidth=getClientArea().width - unwrappedWidth;
    rowData.width=(availableWidth > minWidth ? availableWidth : minWidth);
    if (resizeListener != null) {
      removeControlListener(resizeListener);
    }
    resizeListener=new ControlAdapter(){
      @Override public void controlResized(      ControlEvent e){
        int availableWidth=getClientArea().width - unwrappedWidth;
        rowData.width=(availableWidth > minWidth ? availableWidth : minWidth);
        layout();
      }
    }
;
    addControlListener(resizeListener);
  }
 else {
    createLabel();
    createTextfield();
  }
  setLayout(layout);
  return;
}",0.955292454497261
133738,"/** 
 * Sets the orientation of the camera at once, as opposed to incremental orientation.
 * @param direction The new direction in which the camera will point. If null, an exception is thrown.
 * @param up The new up direction. If null or if it is not orthogonal to the camera direction, an exception is thrown.
 * @see #rollCamera(float)
 * @see #pitchCamera(float)
 * @see #yawCamera(float)
 */
public void setOrientation(Vector3f direction,Vector3f up){
  if (direction == null || up == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (FastMath.abs(direction.dot(up)) > 1e-5f || direction.equals(up)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.up.set(up).cross(this.dir.set(direction),this.left);
  camera.setAxes(this.left,this.up,this.dir);
  return;
}","/** 
 * Sets the orientation of the camera at once, as opposed to incremental orientation.
 * @param direction The new direction in which the camera will point. If null, an exception is thrown.
 * @param up The new up direction. If null or if it is not orthogonal to the camera direction, an exception is thrown.
 * @see #rollCamera(float)
 * @see #pitchCamera(float)
 * @see #yawCamera(float)
 */
public void setOrientation(Vector3f direction,Vector3f up){
  if (direction == null || up == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (FastMath.abs(direction.dot(up)) > 1e-5f || direction.equals(up)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.up.set(up).cross(this.dir.set(direction),this.left);
  dragUp.set(up);
  camera.setAxes(this.left,this.up,this.dir);
  return;
}",0.9896551724137932
133739,"/** 
 * Rotates the camera based on the provided angle and axis.   {@link #up},  {@link #left}, and   {@link #dir} are all updated in this method.
 * @param radians The angle to rotate.
 * @param axis The axis to rotate around.
 */
private void rotateCamera(float radians,Vector3f axis){
  Matrix3f matrix=new Matrix3f();
  matrix.fromAngleNormalAxis(radians,axis);
  matrix.mult(up,up);
  matrix.mult(left,left);
  matrix.mult(dir,dir);
  up.normalizeLocal();
  left.normalizeLocal();
  dir.normalizeLocal();
  camera.setAxes(left,up,dir);
}","/** 
 * Rotates the camera based on the provided angle and axis.   {@link #up},  {@link #left}, and   {@link #dir} are all updated in this method.
 * @param radians The angle to rotate.
 * @param axis The axis to rotate around.
 */
private void rotateCamera(float radians,Vector3f axis){
  Matrix3f matrix=new Matrix3f();
  matrix.fromAngleNormalAxis(radians,axis);
  matrix.multLocal(up).normalizeLocal();
  matrix.multLocal(left).normalizeLocal();
  matrix.multLocal(dir).normalizeLocal();
  camera.setAxes(left,up,dir);
}",0.724202626641651
133740,"/** 
 * This method is intended to take a filePath corresponding to a MOOSE YAML or action syntax file, and remove any extraneous header or footer lines that aren't valid syntax. If any lines from the file were removed, it re-writes the file. If no changes were made (no header/footer to remove), it does nothing.
 * @param filePath	The filepath to the YAML or action syntax file.
 * @throws IOException
 * @throws CoreException 
 */
private void createCleanMOOSEFile(String filePath) throws IOException, CoreException {
  String fileExt, execName, fileType=null;
  boolean hasHeader=false, hasFooter=false;
  int headerLine=0, footerLine=0;
  String separator=System.getProperty(""String_Node_Str"");
  ArrayList<String> fileLines;
  IFolder mooseFolder=project.getFolder(""String_Node_Str"");
  if (!mooseFolder.exists()) {
    mooseFolder.create(true,true,null);
  }
  fileExt=filePath.substring(filePath.lastIndexOf(""String_Node_Str""));
  execName=filePath.substring(filePath.lastIndexOf(separator) + 1,filePath.lastIndexOf(fileExt));
  String cleanFilePath=filePath.substring(0,filePath.lastIndexOf(separator)) + separator + ""String_Node_Str""+ separator+ execName+ fileExt;
  if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileExt);
  }
  java.nio.file.Path readPath=Paths.get(filePath);
  fileLines=(ArrayList<String>)Files.readAllLines(readPath,Charset.defaultCharset());
  String header=""String_Node_Str"" + fileType + ""String_Node_Str"";
  String footer=""String_Node_Str"" + fileType + ""String_Node_Str"";
  hasHeader=fileLines.contains(header);
  hasFooter=fileLines.contains(footer);
  if (hasFooter) {
    footerLine=fileLines.indexOf(footer);
    int i=footerLine;
    while (i < fileLines.size()) {
      fileLines.remove(i);
    }
  }
  if (hasHeader) {
    headerLine=fileLines.indexOf(header);
    for (int i=headerLine; i >= 0; i--) {
      fileLines.remove(i);
    }
  }
  if (hasHeader || hasFooter) {
    java.nio.file.Path writePath=Paths.get(cleanFilePath);
    Files.write(writePath,fileLines,Charset.defaultCharset(),StandardOpenOption.CREATE,StandardOpenOption.APPEND);
    File oldFile=new File(filePath);
    oldFile.delete();
  }
  return;
}","/** 
 * This method is intended to take a filePath corresponding to a MOOSE YAML or action syntax file, and remove any extraneous header or footer lines that aren't valid syntax. If any lines from the file were removed, it re-writes the file. If no changes were made (no header/footer to remove), it does nothing.
 * @param filePath	The filepath to the YAML or action syntax file.
 * @throws IOException
 * @throws CoreException 
 */
private void createCleanMOOSEFile(String filePath) throws IOException, CoreException {
  String fileExt, execName, fileType=null;
  boolean hasHeader=false, hasFooter=false;
  int headerLine=0, footerLine=0;
  String separator=System.getProperty(""String_Node_Str"");
  ArrayList<String> fileLines;
  IFolder mooseFolder=project.getFolder(""String_Node_Str"");
  if (!mooseFolder.exists()) {
    mooseFolder.create(true,true,null);
  }
  fileExt=filePath.substring(filePath.lastIndexOf(""String_Node_Str""));
  execName=filePath.substring(filePath.lastIndexOf(separator) + 1,filePath.lastIndexOf(fileExt));
  String cleanFilePath=filePath.substring(0,filePath.lastIndexOf(separator)) + separator + ""String_Node_Str""+ separator+ execName+ fileExt;
  if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(fileExt)) {
    fileType=""String_Node_Str"";
  }
 else {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileExt);
  }
  java.nio.file.Path readPath=Paths.get(filePath);
  fileLines=(ArrayList<String>)Files.readAllLines(readPath,Charset.defaultCharset());
  String header=""String_Node_Str"" + fileType + ""String_Node_Str"";
  String footer=""String_Node_Str"" + fileType + ""String_Node_Str"";
  hasHeader=fileLines.contains(header);
  hasFooter=fileLines.contains(footer);
  if (hasFooter) {
    footerLine=fileLines.indexOf(footer);
    int i=footerLine;
    while (i < fileLines.size()) {
      fileLines.remove(i);
    }
  }
  if (hasHeader) {
    headerLine=fileLines.indexOf(header);
    for (int i=headerLine; i >= 0; i--) {
      fileLines.remove(i);
    }
  }
  if (hasHeader || hasFooter) {
    IFile cleanFile=mooseFolder.getFile(execName + fileExt);
    if (cleanFile.exists()) {
      cleanFile.delete(true,null);
    }
    java.nio.file.Path writePath=Paths.get(cleanFilePath);
    Files.write(writePath,fileLines,Charset.defaultCharset(),StandardOpenOption.CREATE);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + execName + fileExt);
    File oldFile=new File(filePath);
    oldFile.delete();
  }
  return;
}",0.932050757265657
133741,"/** 
 * <!-- begin-UML-doc --> <p> Return a list of IPS files in the Caebat_Model folder of the project space or null if the folder doesn't exist </p> <!-- end-UML-doc -->
 * @return the list of input files
 */
private ArrayList<String> getProjectFiles(IFolder caebatFolder){
  ArrayList<String> files=null;
  if (project != null) {
    try {
      if (caebatFolder.exists()) {
        files=new ArrayList<String>();
        IResource[] resources=caebatFolder.members();
        for (        IResource resource : resources) {
          if (debuggingEnabled) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + resource.getLocationURI() + ""String_Node_Str"");
          }
          if (resource.getType() == IResource.FILE && resource.getProjectRelativePath().lastSegment().contains(""String_Node_Str"")) {
            files.add(resource.getName());
          }
        }
      }
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
  return files;
}","/** 
 * <!-- begin-UML-doc --> <p> Return a list of IPS files in the Caebat_Model folder of the project space or null if the folder doesn't exist </p> <!-- end-UML-doc -->
 * @return the list of input files
 */
private ArrayList<String> getProjectFiles(IFolder caebatFolder){
  ArrayList<String> files=null;
  if (project != null) {
    try {
      project.refreshLocal(IResource.DEPTH_INFINITE,null);
      if (caebatFolder.exists()) {
        files=new ArrayList<String>();
        IResource[] resources=caebatFolder.members();
        for (        IResource resource : resources) {
          if (debuggingEnabled) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + resource.getLocationURI() + ""String_Node_Str"");
          }
          if (resource.getType() == IResource.FILE && resource.getProjectRelativePath().lastSegment().contains(""String_Node_Str"")) {
            files.add(resource.getName());
          }
        }
      }
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
  return files;
}",0.971007371007371
133742,"@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  IWorkbenchWindow window=HandlerUtil.getActiveWorkbenchWindow(event);
  Shell shell=window.getShell();
  MOOSELauncher launcher=new MOOSELauncher(ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str""));
  System.out.println(((DataComponent)launcher.getForm().getComponent(5)).retrieveEntry(""String_Node_Str"").getValue());
  GenerateYAMLWizard wizard=new GenerateYAMLWizard();
  WizardDialog dialog=new WizardDialog(shell,wizard);
  dialog.open();
  ((DataComponent)launcher.getForm().getComponent(5)).retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"");
  ((TableComponent)launcher.getForm().getComponent(4)).getRow(0).get(0).setValue(""String_Node_Str"");
  ((TableComponent)launcher.getForm().getComponent(4)).getRow(0).get(2).setValue(""String_Node_Str"");
  launcher.submitForm(launcher.getForm());
  FormStatus status=launcher.process(""String_Node_Str"");
  if (status.equals(FormStatus.NeedsInfo)) {
    Form actionForm=launcher.getForm();
    launcher.submitForm(actionForm);
  }
  return null;
}","@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  Shell shell=HandlerUtil.getActiveWorkbenchWindow(event).getShell();
  wizard=new GenerateYAMLWizard();
  WizardDialog dialog=new WizardDialog(shell,wizard);
  launcher=new MOOSELauncher(ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str""));
  if (dialog.open() != 0) {
    return null;
  }
  ((DataComponent)launcher.getForm().getComponent(5)).retrieveEntry(""String_Node_Str"").setValue(""String_Node_Str"");
  ((TableComponent)launcher.getForm().getComponent(4)).getRow(0).get(0).setValue(wizard.getHostName());
  ((TableComponent)launcher.getForm().getComponent(4)).getRow(0).get(2).setValue(wizard.getExecPath());
  launcher.submitForm(launcher.getForm());
  Thread thread=new Thread(this);
  thread.start();
  return null;
}",0.4169684428349715
133743,"@Override public boolean performFinish(){
  host_name_password=new ArrayList<String>();
  host_name_password.add(page.getHostName());
  host_name_password.add(page.getUsername());
  host_name_password.add(page.getPassword());
  return true;
}","/** 
 */
@Override public boolean performFinish(){
  launchData=new ArrayList<String>();
  launchData.add(page.getHostName());
  launchData.add(page.getExecPath());
  launchData.add(page.getUsername());
  launchData.add(page.getPassword());
  return true;
}",0.4128256513026052
133744,"/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on the local machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchLocally(){
  FormStatus launchStatus;
  for (int i=0; i < splitCMD.size(); i++) {
    if (cancelled.get()) {
      break;
    }
    launchStatus=launchStageLocally(splitCMD.get(i),stdOut,stdErr);
    monitorJob();
    if (launchStatus.equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
  }
  status=FormStatus.Processed;
  return;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on the local machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchLocally(){
  FormStatus launchStatus;
  String separator=System.getProperty(""String_Node_Str"");
  String userHome=System.getProperty(""String_Node_Str"");
  String localProjectDir=userHome + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
  File workingDirectory=new File(execDictionary.get(""String_Node_Str""));
  for (int i=0; i < splitCMD.size(); i++) {
    if (cancelled.get()) {
      break;
    }
    launchStatus=launchStageLocally(splitCMD.get(i),stdOut,stdErr);
    monitorJob();
    if (launchStatus.equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
  }
  for (  File file : workingDirectory.listFiles()) {
    if (!fileMap.keySet().contains(file.getName())) {
      try {
        Files.copy(Paths.get(file.getAbsolutePath()),Paths.get(localProjectDir + separator + file.getName()));
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  status=FormStatus.Processed;
  return;
}",0.6666666666666666
133745,"protected FormStatus launchStageLocally(String cmd,BufferedWriter stdOut,BufferedWriter stdErr){
  String errMsg=null;
  ProcessBuilder jobBuilder=null;
  InputStream stdOutStream=null, stdErrStream=null;
  int exitValue=-1;
  String os=execDictionary.get(""String_Node_Str"");
  ArrayList<String> cmdList=new ArrayList<String>();
  File directory=new File(execDictionary.get(""String_Node_Str""));
  if (!os.toLowerCase().contains(""String_Node_Str"")) {
    cmdList.add(""String_Node_Str"");
    cmdList.add(""String_Node_Str"");
  }
  cmdList.add(cmd);
  if (!directory.exists()) {
    directory.mkdirs();
  }
  jobBuilder=new ProcessBuilder(cmdList);
  jobBuilder.directory(directory);
  jobBuilder.redirectErrorStream(false);
  try {
    if (!cancelled.get()) {
      job=jobBuilder.start();
    }
  }
 catch (  IOException e) {
    errMsg=e.getMessage();
  }
  if (errMsg != null) {
    try {
      stdErr.write(errMsg);
      stdOut.close();
      stdErr.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    return FormStatus.InfoError;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + cmd + ""String_Node_Str"");
  stdOutStream=job.getInputStream();
  stdErrStream=job.getErrorStream();
  logOutput(stdOutStream,stdErrStream);
  if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
    return FormStatus.InfoError;
  }
  try {
    exitValue=job.exitValue();
  }
 catch (  IllegalThreadStateException e) {
    return FormStatus.Processing;
  }
  if (exitValue == 0) {
    return FormStatus.Processed;
  }
 else {
    return FormStatus.InfoError;
  }
}","protected FormStatus launchStageLocally(String cmd,BufferedWriter stdOut,BufferedWriter stdErr){
  String errMsg=null;
  ProcessBuilder jobBuilder=null;
  InputStream stdOutStream=null, stdErrStream=null;
  int exitValue=-1;
  String os=execDictionary.get(""String_Node_Str"");
  ArrayList<String> cmdList=new ArrayList<String>();
  File directory=new File(execDictionary.get(""String_Node_Str""));
  if (!os.toLowerCase().contains(""String_Node_Str"")) {
    cmdList.add(""String_Node_Str"");
    cmdList.add(""String_Node_Str"");
  }
  cmdList.add(cmd);
  if (!directory.exists()) {
    directory.mkdirs();
  }
  for (  String fileString : fileMap.keySet()) {
    File localFile=new File(fileMap.get(fileString));
    File copyToDirFile=new File(directory.getAbsolutePath() + System.getProperty(""String_Node_Str"") + fileString);
    try {
      Files.copy(Paths.get(localFile.toURI()),Paths.get(copyToDirFile.toURI()));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  jobBuilder=new ProcessBuilder(cmdList);
  jobBuilder.directory(directory);
  jobBuilder.redirectErrorStream(false);
  try {
    if (!cancelled.get()) {
      job=jobBuilder.start();
    }
  }
 catch (  IOException e) {
    errMsg=e.getMessage();
  }
  if (errMsg != null) {
    try {
      stdErr.write(errMsg);
      stdOut.close();
      stdErr.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    return FormStatus.InfoError;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + cmd + ""String_Node_Str"");
  stdOutStream=job.getInputStream();
  stdErrStream=job.getErrorStream();
  logOutput(stdOutStream,stdErrStream);
  if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
    return FormStatus.InfoError;
  }
  try {
    exitValue=job.exitValue();
  }
 catch (  IllegalThreadStateException e) {
    return FormStatus.Processing;
  }
  if (exitValue == 0) {
    return FormStatus.Processed;
  }
 else {
    return FormStatus.InfoError;
  }
}",0.7305685251304587
133746,"/** 
 * (non-Javadoc)
 * @see Runnable#run()
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
public void run(){
  String executable=null, inputFile=null, hostname=null;
  String stdOutFileName=null, stdErrFileName=null;
  String stdOutHeader=null, stdErrHeader=null;
  if (execDictionary != null) {
    executable=execDictionary.get(""String_Node_Str"");
    inputFile=execDictionary.get(""String_Node_Str"");
    stdOutFileName=execDictionary.get(""String_Node_Str"");
    stdErrFileName=execDictionary.get(""String_Node_Str"");
    hostname=execDictionary.get(""String_Node_Str"");
  }
  if (executable == null || inputFile == null || stdOutFileName == null || stdErrFileName == null || hostname == null) {
    status=FormStatus.InfoError;
    return;
  }
  if (execDictionary.get(""String_Node_Str"") != null && (""String_Node_Str"").equals(execDictionary.get((""String_Node_Str"")))) {
    appendInput=false;
  }
  if (execDictionary.get(""String_Node_Str"") != null && (""String_Node_Str"").equals(execDictionary.get((""String_Node_Str"")))) {
    uploadInput=false;
  }
  setWorkingDirectoryName();
  fullCMD=fixExecutableName();
  stdOutFileName=execDictionary.get(""String_Node_Str"");
  stdOut=getBufferedWriter(stdOutFileName);
  stdErrFileName=execDictionary.get(""String_Node_Str"");
  stdErr=getBufferedWriter(stdErrFileName);
  stdOutHeader=createOutputHeader(""String_Node_Str"");
  stdErrHeader=createOutputHeader(""String_Node_Str"");
  try {
    stdOut.write(stdOutHeader);
    stdErr.write(stdErrHeader);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  if (isLocal.get()) {
    launchLocally();
  }
 else {
    launchRemotely();
  }
  try {
    stdOut.close();
    stdErr.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  return;
}","/** 
 * (non-Javadoc)
 * @see Runnable#run()
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
public void run(){
  String executable=null, inputFile=null, hostname=null;
  String stdOutFileName=null, stdErrFileName=null;
  String stdOutHeader=null, stdErrHeader=null;
  if (execDictionary != null) {
    executable=execDictionary.get(""String_Node_Str"");
    inputFile=execDictionary.get(""String_Node_Str"");
    stdOutFileName=execDictionary.get(""String_Node_Str"");
    stdErrFileName=execDictionary.get(""String_Node_Str"");
    hostname=execDictionary.get(""String_Node_Str"");
    uploadInput=Boolean.valueOf(execDictionary.get(""String_Node_Str""));
  }
  if (executable == null || (uploadInput && inputFile == null) || stdOutFileName == null || stdErrFileName == null || hostname == null) {
    status=FormStatus.InfoError;
    return;
  }
  if (execDictionary.get(""String_Node_Str"") != null && (""String_Node_Str"").equals(execDictionary.get((""String_Node_Str"")))) {
    appendInput=false;
  }
  setWorkingDirectoryName();
  fullCMD=fixExecutableName();
  stdOutFileName=execDictionary.get(""String_Node_Str"");
  stdOut=getBufferedWriter(stdOutFileName);
  stdErrFileName=execDictionary.get(""String_Node_Str"");
  stdErr=getBufferedWriter(stdErrFileName);
  stdOutHeader=createOutputHeader(""String_Node_Str"");
  stdErrHeader=createOutputHeader(""String_Node_Str"");
  try {
    stdOut.write(stdOutHeader);
    stdErr.write(stdErrHeader);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  if (isLocal.get()) {
    launchLocally();
  }
 else {
    launchRemotely();
  }
  try {
    stdOut.close();
    stdErr.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  return;
}",0.9323059988992846
133747,"/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on a remote machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchRemotely(){
  IRemoteServices remoteServices=RemoteServices.getRemoteServices(""String_Node_Str"");
  IRemoteConnection connection=null;
  String remoteDownloadDirectory=execDictionary.get(""String_Node_Str"");
  String separator=System.getProperty(""String_Node_Str"");
  String inputFile=execDictionary.get(""String_Node_Str"");
  int lastIndex=inputFile.lastIndexOf(separator);
  String localFilePrefix=inputFile.substring(0,lastIndex);
  File localStorageDir=new File(localFilePrefix);
  IFileStore localDirectory=EFS.getLocalFileSystem().fromLocalFile(localStorageDir);
  String launchCMDFileName=""String_Node_Str"";
  if (remoteServices.canCreateConnections()) {
    try {
      connection=remoteServices.getConnectionManager().newConnection(execDictionary.get(""String_Node_Str""));
    }
 catch (    RemoteConnectionException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
  }
  while (!formSubmitted.get()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e1) {
      e1.printStackTrace();
      return;
    }
  }
  try {
    launchCMDFileName=writeRemoteCommandFile();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return;
  }
  connection.setAddress(execDictionary.get(""String_Node_Str""));
  DataComponent credentials=(DataComponent)formAtomic.get().getComponent(1);
  connection.setUsername(credentials.retrieveAllEntries().get(0).getValue());
  connection.setPassword(credentials.retrieveAllEntries().get(1).getValue());
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  if (connection.isOpen() && !cancelled.get()) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    IRemoteFileManager fileManager=remoteServices.getFileManager(connection);
    IFileStore fileStore=fileManager.getResource(connection.getWorkingDirectory());
    try {
      IFileStore directory=fileStore.getChild(workingDirectoryBaseName).mkdir(EFS.SHALLOW,null);
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + directory.getName());
      for (      String shortInputName : fileMap.keySet()) {
        if (cancelled.get()) {
          break;
        }
        if (uploadInput || (!uploadInput && shortInputName.equals(""String_Node_Str""))) {
          IFileStore remoteFileStore=directory.getChild(shortInputName);
          File localFile=new File(fileMap.get(shortInputName));
          IFileStore localFileStore=EFS.getLocalFileSystem().fromLocalFile(localFile);
          localFileStore.copy(remoteFileStore,EFS.NONE,null);
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + shortInputName);
        }
      }
    }
 catch (    CoreException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
    String currentWd=connection.getWorkingDirectory();
    connection.setWorkingDirectory(currentWd + remoteSeparator + workingDirectoryBaseName);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + connection.getWorkingDirectory());
    String launchCMD=""String_Node_Str"";
    if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
 else {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
    IRemoteProcessBuilder processBuilder=remoteServices.getProcessBuilder(connection,""String_Node_Str"",launchCMD);
    processBuilder.redirectErrorStream(false);
    try {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ launchCMDFileName);
      remoteJob=processBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
    }
 catch (    IOException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    InputStream stdOutStream=remoteJob.getInputStream();
    InputStream stdErrStream=remoteJob.getErrorStream();
    if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
    monitorJob();
    if (!cancelled.get()) {
      String fixedRemoteWD=currentWd + remoteSeparator + workingDirectoryBaseName;
      String remoteDir=(remoteDownloadDirectory == null) ? fixedRemoteWD : remoteDownloadDirectory;
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + localDirectory.getName() + ""String_Node_Str""+ remoteDir+ ""String_Node_Str"");
      IFileStore downloadFileStore=fileManager.getResource(remoteDir);
      try {
        IFileStore[] remoteStores=downloadFileStore.childStores(EFS.NONE,null);
        for (        IFileStore remoteFile : remoteStores) {
          if (cancelled.get()) {
            break;
          }
          IFileInfo fileInfo=remoteFile.fetchInfo();
          if (fileInfo.getLength() < maxFileSize) {
            String msg=""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getName() + ""String_Node_Str""+ fileInfo.getLength()+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
            IFileStore childStore=localDirectory.getChild(remoteFile.getName());
            remoteFile.copy(childStore,EFS.OVERWRITE,null);
          }
 else {
            long sizeDiff=fileInfo.getLength() - maxFileSize;
            String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getLength() + ""String_Node_Str""+ sizeDiff+ ""String_Node_Str""+ maxFileSize+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
          }
          stdOut.flush();
        }
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  status=FormStatus.Processed;
  connection.close();
  return;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation launches the job on a remote machine. </p> <!-- end-UML-doc -->
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
protected void launchRemotely(){
  IRemoteServices remoteServices=RemoteServices.getRemoteServices(""String_Node_Str"");
  IRemoteConnection connection=null;
  String remoteDownloadDirectory=execDictionary.get(""String_Node_Str"");
  String separator=System.getProperty(""String_Node_Str"");
  String inputFile=execDictionary.get(""String_Node_Str"");
  int lastIndex=0;
  String localFilePrefix=""String_Node_Str"";
  File localStorageDir=null;
  if (inputFile != null) {
    lastIndex=inputFile.lastIndexOf(separator);
    localFilePrefix=inputFile.substring(0,lastIndex);
    localStorageDir=new File(localFilePrefix);
  }
 else   if (inputFile == null && !uploadInput) {
    localFilePrefix=System.getProperty(""String_Node_Str"") + separator + ""String_Node_Str""+ separator+ ""String_Node_Str"";
    localStorageDir=new File(localFilePrefix);
  }
 else {
    status=FormStatus.InfoError;
    return;
  }
  IFileStore localDirectory=EFS.getLocalFileSystem().fromLocalFile(localStorageDir);
  String launchCMDFileName=""String_Node_Str"";
  if (remoteServices.canCreateConnections()) {
    try {
      connection=remoteServices.getConnectionManager().newConnection(execDictionary.get(""String_Node_Str""));
    }
 catch (    RemoteConnectionException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
  }
  while (!formSubmitted.get()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e1) {
      e1.printStackTrace();
      return;
    }
  }
  try {
    launchCMDFileName=writeRemoteCommandFile();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return;
  }
  connection.setAddress(execDictionary.get(""String_Node_Str""));
  DataComponent credentials=(DataComponent)formAtomic.get().getComponent(1);
  connection.setUsername(credentials.retrieveAllEntries().get(0).getValue());
  connection.setPassword(credentials.retrieveAllEntries().get(1).getValue());
  try {
    connection.open(null);
  }
 catch (  RemoteConnectionException e) {
    e.printStackTrace();
    status=FormStatus.InfoError;
    return;
  }
  if (connection.isOpen() && !cancelled.get()) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    IRemoteFileManager fileManager=remoteServices.getFileManager(connection);
    IFileStore fileStore=fileManager.getResource(connection.getWorkingDirectory());
    try {
      IFileStore directory=fileStore.getChild(workingDirectoryBaseName).mkdir(EFS.SHALLOW,null);
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + directory.getName());
      for (      String shortInputName : fileMap.keySet()) {
        if (cancelled.get()) {
          break;
        }
        if (uploadInput || (!uploadInput && shortInputName.equals(""String_Node_Str""))) {
          IFileStore remoteFileStore=directory.getChild(shortInputName);
          File localFile=new File(fileMap.get(shortInputName));
          IFileStore localFileStore=EFS.getLocalFileSystem().fromLocalFile(localFile);
          localFileStore.copy(remoteFileStore,EFS.NONE,null);
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + shortInputName);
        }
      }
    }
 catch (    CoreException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    String remoteSeparator=connection.getProperty(IRemoteConnection.FILE_SEPARATOR_PROPERTY);
    String currentWd=connection.getWorkingDirectory();
    connection.setWorkingDirectory(currentWd + remoteSeparator + workingDirectoryBaseName);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + connection.getWorkingDirectory());
    String launchCMD=""String_Node_Str"";
    if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
 else {
      launchCMD=""String_Node_Str"" + launchCMDFileName;
    }
    IRemoteProcessBuilder processBuilder=remoteServices.getProcessBuilder(connection,""String_Node_Str"",launchCMD);
    processBuilder.redirectErrorStream(false);
    try {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ launchCMDFileName);
      remoteJob=processBuilder.start(IRemoteProcessBuilder.FORWARD_X11);
    }
 catch (    IOException e) {
      e.printStackTrace();
      status=FormStatus.InfoError;
      return;
    }
    InputStream stdOutStream=remoteJob.getInputStream();
    InputStream stdErrStream=remoteJob.getErrorStream();
    if (logOutput(stdOutStream,stdErrStream).equals(FormStatus.InfoError)) {
      status=FormStatus.InfoError;
      return;
    }
    monitorJob();
    if (!cancelled.get()) {
      String fixedRemoteWD=currentWd + remoteSeparator + workingDirectoryBaseName;
      String remoteDir=(remoteDownloadDirectory == null) ? fixedRemoteWD : remoteDownloadDirectory;
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + localDirectory.getName() + ""String_Node_Str""+ remoteDir+ ""String_Node_Str"");
      IFileStore downloadFileStore=fileManager.getResource(remoteDir);
      try {
        IFileStore[] remoteStores=downloadFileStore.childStores(EFS.NONE,null);
        for (        IFileStore remoteFile : remoteStores) {
          if (cancelled.get()) {
            break;
          }
          IFileInfo fileInfo=remoteFile.fetchInfo();
          if (fileInfo.getLength() < maxFileSize) {
            String msg=""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getName() + ""String_Node_Str""+ fileInfo.getLength()+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
            IFileStore childStore=localDirectory.getChild(remoteFile.getName());
            remoteFile.copy(childStore,EFS.OVERWRITE,null);
          }
 else {
            long sizeDiff=fileInfo.getLength() - maxFileSize;
            String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + fileInfo.getLength() + ""String_Node_Str""+ sizeDiff+ ""String_Node_Str""+ maxFileSize+ ""String_Node_Str"";
            System.out.println(msg);
            stdOut.write(msg + ""String_Node_Str"");
          }
          stdOut.flush();
        }
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  status=FormStatus.Processed;
  connection.close();
  return;
}",0.9678428917925044
133748,"/** 
 * <!-- begin-UML-doc --> <p> This operation fixes the name of the executable that will be launched. It replaces ${inputFile}, ${installDir} and other keys from the dictionary according to the specification. It also configures the commands to setup the parallel execution environment if indicated by the number of processors or threads. </p> <!-- end-UML-doc -->
 * @return <p>The name of the executable with all variable references and required string replacements fixed. </p>
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private String fixExecutableName(){
  int numProcs=Math.max(1,Integer.parseInt(execDictionary.get(""String_Node_Str"")));
  int numTBBThreads=Math.max(1,Integer.parseInt(execDictionary.get(""String_Node_Str"")));
  String fixedExecutableName=execDictionary.get(""String_Node_Str"");
  String installDir=execDictionary.get(""String_Node_Str"");
  String workingDir=execDictionary.get(""String_Node_Str"");
  String separator=""String_Node_Str"";
  String shortInputName=null;
  System.out.println(""String_Node_Str"" + fixedExecutableName);
  if (appendInput) {
    fixedExecutableName+=""String_Node_Str"";
  }
  fullCMD=fixedExecutableName;
  if (installDir != null && installDir.contains(""String_Node_Str"")) {
    separator=""String_Node_Str"";
  }
  if (installDir != null && !installDir.endsWith(separator)) {
    installDir=installDir + separator;
  }
  Enumeration<String> keys=execDictionary.keys();
  String fixedFileName;
  while (keys.hasMoreElements()) {
    String key=keys.nextElement();
    if (key.toLowerCase().endsWith(""String_Node_Str"")) {
      fixedFileName=execDictionary.get(key);
      if (!isLocal.get()) {
        shortInputName=execDictionary.get(key);
        if (shortInputName.contains(""String_Node_Str"")) {
          shortInputName=shortInputName.substring(shortInputName.lastIndexOf(""String_Node_Str"") + 1);
        }
 else         if (shortInputName.contains(""String_Node_Str"")) {
          shortInputName=shortInputName.substring(shortInputName.lastIndexOf(""String_Node_Str"") + 1);
        }
        fixedFileName=shortInputName;
        fileMap.put(shortInputName,execDictionary.get(key));
      }
      fixedExecutableName=fixedExecutableName.replace(""String_Node_Str"" + key + ""String_Node_Str"",fixedFileName);
    }
  }
  if (fixedExecutableName.contains(""String_Node_Str"") && installDir != null) {
    fixedExecutableName=fixedExecutableName.replace(""String_Node_Str"",installDir);
  }
  if (fixedExecutableName.contains(""String_Node_Str"") && workingDir != null) {
    fixedExecutableName=fixedExecutableName.replace(""String_Node_Str"",workingDir);
  }
  if (numProcs > 1) {
    if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      fixedExecutableName=""String_Node_Str"" + numProcs + ""String_Node_Str""+ fixedExecutableName;
    }
 else {
      fixedExecutableName=""String_Node_Str"" + numProcs + ""String_Node_Str""+ fixedExecutableName;
    }
  }
  if (numTBBThreads > 1) {
    fixedExecutableName=fixedExecutableName + ""String_Node_Str"" + numTBBThreads;
  }
  fixedExecutableName=fixedExecutableName.trim();
  if (!fixedExecutableName.contains(""String_Node_Str"")) {
    splitCMD.add(fixedExecutableName);
  }
 else {
    for (    String stage : fixedExecutableName.split(""String_Node_Str"")) {
      splitCMD.add(stage);
    }
  }
  for (int i=0; i < splitCMD.size(); i++) {
    String cmd=splitCMD.get(i);
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ cmd);
  }
  return fixedExecutableName;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation fixes the name of the executable that will be launched. It replaces ${inputFile}, ${installDir} and other keys from the dictionary according to the specification. It also configures the commands to setup the parallel execution environment if indicated by the number of processors or threads. </p> <!-- end-UML-doc -->
 * @return <p>The name of the executable with all variable references and required string replacements fixed. </p>
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private String fixExecutableName(){
  int numProcs=Math.max(1,Integer.parseInt(execDictionary.get(""String_Node_Str"")));
  int numTBBThreads=Math.max(1,Integer.parseInt(execDictionary.get(""String_Node_Str"")));
  String fixedExecutableName=execDictionary.get(""String_Node_Str"");
  String installDir=execDictionary.get(""String_Node_Str"");
  String workingDir=execDictionary.get(""String_Node_Str"");
  String separator=""String_Node_Str"";
  String shortInputName=null;
  System.out.println(""String_Node_Str"" + fixedExecutableName);
  if (appendInput) {
    fixedExecutableName+=""String_Node_Str"";
  }
  fullCMD=fixedExecutableName;
  if (installDir != null && installDir.contains(""String_Node_Str"")) {
    separator=""String_Node_Str"";
  }
  if (installDir != null && !installDir.endsWith(separator)) {
    installDir=installDir + separator;
  }
  Enumeration<String> keys=execDictionary.keys();
  String fixedFileName;
  while (keys.hasMoreElements()) {
    String key=keys.nextElement();
    if (key.toLowerCase().endsWith(""String_Node_Str"")) {
      fixedFileName=execDictionary.get(key);
      shortInputName=execDictionary.get(key);
      if (shortInputName.contains(""String_Node_Str"")) {
        shortInputName=shortInputName.substring(shortInputName.lastIndexOf(""String_Node_Str"") + 1);
      }
 else       if (shortInputName.contains(""String_Node_Str"")) {
        shortInputName=shortInputName.substring(shortInputName.lastIndexOf(""String_Node_Str"") + 1);
      }
      fixedFileName=shortInputName;
      fileMap.put(shortInputName,execDictionary.get(key));
      fixedExecutableName=fixedExecutableName.replace(""String_Node_Str"" + key + ""String_Node_Str"",fixedFileName);
    }
  }
  if (fixedExecutableName.contains(""String_Node_Str"") && installDir != null) {
    fixedExecutableName=fixedExecutableName.replace(""String_Node_Str"",installDir);
  }
  if (fixedExecutableName.contains(""String_Node_Str"") && workingDir != null) {
    fixedExecutableName=fixedExecutableName.replace(""String_Node_Str"",workingDir);
  }
  if (numProcs > 1) {
    if (!execDictionary.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      fixedExecutableName=""String_Node_Str"" + numProcs + ""String_Node_Str""+ fixedExecutableName;
    }
 else {
      fixedExecutableName=""String_Node_Str"" + numProcs + ""String_Node_Str""+ fixedExecutableName;
    }
  }
  if (numTBBThreads > 1) {
    fixedExecutableName=fixedExecutableName + ""String_Node_Str"" + numTBBThreads;
  }
  fixedExecutableName=fixedExecutableName.trim();
  if (!fixedExecutableName.contains(""String_Node_Str"")) {
    splitCMD.add(fixedExecutableName);
  }
 else {
    for (    String stage : fixedExecutableName.split(""String_Node_Str"")) {
      splitCMD.add(stage);
    }
  }
  for (int i=0; i < splitCMD.size(); i++) {
    String cmd=splitCMD.get(i);
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ cmd);
  }
  return fixedExecutableName;
}",0.8736451796919567
133749,"/** 
 * This operation creates a standard header that contains information about the job being launched. It is used primarily by the run() operation.
 * @param logName The name that should be used to identify the log in its header.
 * @return The header.
 */
private String createOutputHeader(String logName){
  String header=null, localHostname=null;
  try {
    InetAddress addr=InetAddress.getLocalHost();
    localHostname=addr.getHostName();
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
  }
  header=""String_Node_Str"";
  header+=new SimpleDateFormat(""String_Node_Str"").format(Calendar.getInstance().getTime()) + ""String_Node_Str"";
  header+=""String_Node_Str"" + localHostname + ""String_Node_Str"";
  header+=""String_Node_Str"" + execDictionary.get(""String_Node_Str"") + ""String_Node_Str"";
  header+=""String_Node_Str"" + fullCMD + ""String_Node_Str"";
  if (uploadInput) {
    header+=""String_Node_Str"" + execDictionary.get(""String_Node_Str"") + ""String_Node_Str"";
  }
  header+=""String_Node_Str"" + execDictionary.get(""String_Node_Str"") + ""String_Node_Str"";
  header+=""String_Node_Str"";
  return header;
}","/** 
 * This operation creates a standard header that contains information about the job being launched. It is used primarily by the run() operation.
 * @param logName The name that should be used to identify the log in its header.
 * @return The header.
 */
private String createOutputHeader(String logName){
  String header=null, localHostname=null;
  try {
    InetAddress addr=InetAddress.getLocalHost();
    localHostname=addr.getHostName();
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
  }
  header=""String_Node_Str"";
  header+=new SimpleDateFormat(""String_Node_Str"").format(Calendar.getInstance().getTime()) + ""String_Node_Str"";
  header+=""String_Node_Str"" + localHostname + ""String_Node_Str"";
  header+=""String_Node_Str"" + execDictionary.get(""String_Node_Str"") + ""String_Node_Str"";
  header+=""String_Node_Str"" + fullCMD.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
  if (uploadInput) {
    header+=""String_Node_Str"" + execDictionary.get(""String_Node_Str"") + ""String_Node_Str"";
  }
  header+=""String_Node_Str"" + execDictionary.get(""String_Node_Str"") + ""String_Node_Str"";
  header+=""String_Node_Str"";
  return header;
}",0.980323567993004
133750,"/** 
 * <!-- begin-UML-doc --> <p> This operation fills the data dictionary for the JobLaunchAction based on the contents of the Form. </p> <!-- end-UML-doc -->
 * @return <p>The status of the operation. It will only equal FormStatus.ReadyToProcess or FormStatus.InfoError and should cause the calling operation to fail if the latter is returned. </p>
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private FormStatus fillActionDataMap(){
  String filename=null, hostname=null;
  String installDir=""String_Node_Str"";
  IResource fileResource=null;
  String os=""String_Node_Str"", accountCode=""String_Node_Str"";
  DataComponent fileData=null, parallelData=null;
  Entry fileEntry=null, mpiEntry=null;
  int numProcs=1, numTBBThreads=1;
  fileData=(DataComponent)form.getComponent(JobLauncherForm.filesId);
  parallelData=(DataComponent)form.getComponent(JobLauncherForm.parallelId);
  if (fileData == null) {
    return FormStatus.InfoError;
  }
  actionDataMap=new Hashtable<String,String>();
  fileData=(DataComponent)form.getComponent(1);
  for (  String entryName : inputFileNameMap.keySet()) {
    fileEntry=fileData.retrieveEntry(entryName);
    if (fileEntry != null) {
      fileResource=project.findMember(fileEntry.getValue());
      if (fileResource == null || !fileResource.exists()) {
        System.out.println(""String_Node_Str"" + filename);
        System.out.println(""String_Node_Str"" + fileEntry.getAllowedValues());
        return FormStatus.InfoError;
      }
      filename=fileResource.getLocation().toOSString();
      actionDataMap.put(inputFileNameMap.get(entryName).varName,filename);
    }
 else {
      System.out.println(""String_Node_Str"" + entryName);
    }
  }
  ArrayList<Integer> selectedRowIds=hostsTable.getSelectedRows();
  int selectedRowId=1;
  selectedRowId=0;
  if (selectedRowIds != null) {
    selectedRowId=selectedRowIds.get(0);
  }
  ArrayList<Entry> hostEntries=hostsTable.getRow(selectedRowId);
  hostname=hostEntries.get(0).getValue();
  os=hostEntries.get(1).getValue();
  installDir=hostEntries.get(2).getValue();
  if (parallelData != null) {
    mpiEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (mpiEntry != null) {
      numProcs=Math.max(numProcs,Integer.parseInt(mpiEntry.getValue()));
    }
    Entry tbbThreadsEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (tbbThreadsEntry != null) {
      numTBBThreads=Math.max(numTBBThreads,Integer.parseInt(tbbThreadsEntry.getValue()));
    }
    Entry accountEntry=parallelData.retrieveEntry(""String_Node_Str"");
    accountCode=accountEntry.getValue();
  }
  actionDataMap.put(""String_Node_Str"",executableCommandName);
  actionDataMap.put(""String_Node_Str"",(uploadInput) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (appendInput && !executableCommandName.contains(""String_Node_Str"")) {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  actionDataMap.put(""String_Node_Str"",installDir);
  actionDataMap.put(""String_Node_Str"",hostname);
  actionDataMap.put(""String_Node_Str"",os);
  actionDataMap.put(""String_Node_Str"",accountCode);
  actionDataMap.put(""String_Node_Str"",String.valueOf(numProcs));
  actionDataMap.put(""String_Node_Str"",String.valueOf(numTBBThreads));
  if (remoteDownloadDir != null) {
    actionDataMap.put(""String_Node_Str"",remoteDownloadDir);
  }
  if (debuggingEnabled) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + actionDataMap);
  }
  return FormStatus.ReadyToProcess;
}","/** 
 * <!-- begin-UML-doc --> <p> This operation fills the data dictionary for the JobLaunchAction based on the contents of the Form. </p> <!-- end-UML-doc -->
 * @return <p>The status of the operation. It will only equal FormStatus.ReadyToProcess or FormStatus.InfoError and should cause the calling operation to fail if the latter is returned. </p>
 * @generated ""UML to Java (com.ibm.xtools.transform.uml2.java5.internal.UML2JavaTransform)""
 */
private FormStatus fillActionDataMap(){
  String filename=null, hostname=null;
  String installDir=""String_Node_Str"";
  IResource fileResource=null;
  String os=""String_Node_Str"", accountCode=""String_Node_Str"";
  DataComponent fileData=null, parallelData=null;
  Entry fileEntry=null, mpiEntry=null;
  int numProcs=1, numTBBThreads=1;
  fileData=(DataComponent)form.getComponent(JobLauncherForm.filesId);
  parallelData=(DataComponent)form.getComponent(JobLauncherForm.parallelId);
  if (fileData == null) {
    return FormStatus.InfoError;
  }
  actionDataMap=new Hashtable<String,String>();
  fileData=(DataComponent)form.getComponent(1);
  for (  String entryName : inputFileNameMap.keySet()) {
    fileEntry=fileData.retrieveEntry(entryName);
    if (fileEntry != null) {
      fileResource=project.findMember(fileEntry.getValue());
      if (fileResource == null || !fileResource.exists()) {
        System.out.println(""String_Node_Str"" + filename);
        System.out.println(""String_Node_Str"" + fileEntry.getAllowedValues());
        return FormStatus.InfoError;
      }
      filename=fileResource.getLocation().toOSString();
      actionDataMap.put(inputFileNameMap.get(entryName).varName,filename);
    }
 else {
      System.out.println(""String_Node_Str"" + entryName);
    }
  }
  ArrayList<Integer> selectedRowIds=hostsTable.getSelectedRows();
  int selectedRowId=1;
  selectedRowId=0;
  if (selectedRowIds != null) {
    selectedRowId=selectedRowIds.get(0);
  }
  ArrayList<Entry> hostEntries=hostsTable.getRow(selectedRowId);
  hostname=hostEntries.get(0).getValue();
  os=hostEntries.get(1).getValue();
  installDir=hostEntries.get(2).getValue();
  if (parallelData != null) {
    mpiEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (mpiEntry != null) {
      numProcs=Math.max(numProcs,Integer.parseInt(mpiEntry.getValue()));
    }
    Entry tbbThreadsEntry=parallelData.retrieveEntry(""String_Node_Str"");
    if (tbbThreadsEntry != null) {
      numTBBThreads=Math.max(numTBBThreads,Integer.parseInt(tbbThreadsEntry.getValue()));
    }
    Entry accountEntry=parallelData.retrieveEntry(""String_Node_Str"");
    accountCode=accountEntry.getValue();
  }
  actionDataMap.put(""String_Node_Str"",executableCommandName);
  actionDataMap.put(""String_Node_Str"",String.valueOf(uploadInput));
  if (appendInput && !executableCommandName.contains(""String_Node_Str"")) {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    actionDataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  actionDataMap.put(""String_Node_Str"",installDir);
  actionDataMap.put(""String_Node_Str"",hostname);
  actionDataMap.put(""String_Node_Str"",os);
  actionDataMap.put(""String_Node_Str"",accountCode);
  actionDataMap.put(""String_Node_Str"",String.valueOf(numProcs));
  actionDataMap.put(""String_Node_Str"",String.valueOf(numTBBThreads));
  if (remoteDownloadDir != null) {
    actionDataMap.put(""String_Node_Str"",remoteDownloadDir);
  }
  if (debuggingEnabled) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + actionDataMap);
  }
  return FormStatus.ReadyToProcess;
}",0.9924071991001124
133751,"/** 
 * Overriding setupForm to set the executable names and host information.
 */
@Override protected void setupForm(){
  String localInstallDir=""String_Node_Str"";
  String remoteInstallDir=""String_Node_Str"";
  ArrayList<String> executables=new ArrayList<String>();
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(yamlSyntaxGenerator);
  addExecutables(executables);
  super.setupForm();
  DataComponent inputFilesComp=(DataComponent)form.getComponent(1);
  inputFilesComp.deleteEntry(""String_Node_Str"");
  addInputType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addHost(""String_Node_Str"",""String_Node_Str"",localInstallDir);
  addHost(""String_Node_Str"",""String_Node_Str"",remoteInstallDir);
  enableMPI(1,10000,1);
  enableTBB(1,256,1);
  return;
}","/** 
 * Overriding setupForm to set the executable names and host information.
 */
@Override protected void setupForm(){
  String userHome=System.getProperty(""String_Node_Str"");
  String separator=System.getProperty(""String_Node_Str"");
  String localInstallDir=userHome + separator + ""String_Node_Str"";
  String remoteInstallDir=""String_Node_Str"";
  ArrayList<String> executables=new ArrayList<String>();
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(""String_Node_Str"");
  executables.add(yamlSyntaxGenerator);
  addExecutables(executables);
  super.setupForm();
  DataComponent inputFilesComp=(DataComponent)form.getComponent(1);
  inputFilesComp.deleteEntry(""String_Node_Str"");
  addInputType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addHost(""String_Node_Str"",""String_Node_Str"",localInstallDir);
  addHost(""String_Node_Str"",""String_Node_Str"",remoteInstallDir);
  enableMPI(1,10000,1);
  enableTBB(1,256,1);
  return;
}",0.9316831683168316
133752,"/** 
 * Overrides the base class operation to properly account for MOOSE's file structure.
 * @param installDir The installation directory of MOOSE.
 * @param executable The name of the executable selected by a client.
 * @return The complete launch command specific for a given MOOSE product,determined by the executable name selected by the client.
 */
@Override protected String updateExecutablePath(String installDir,String executable){
  HashMap<String,String> executableMap=new HashMap<String,String>();
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(yamlSyntaxGenerator,yamlSyntaxGenerator);
  String launchCommand=null;
  if (""String_Node_Str"".equals(executable)) {
    launchCommand=""String_Node_Str"" + ""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str"";
  }
 else   if (yamlSyntaxGenerator.equals(executable)) {
    setAppendInputFlag(false);
    if (yamlSyntaxGenerator.equals(execName)) {
      setUploadInputFlag(false);
    }
    launchCommand=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(executable)) {
    launchCommand=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str""+ executable+ ""String_Node_Str"";
  }
 else {
    launchCommand=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str""+ executableMap.get(executable)+ ""String_Node_Str"";
  }
  return launchCommand;
}","/** 
 * Overrides the base class operation to properly account for MOOSE's file structure.
 * @param installDir The installation directory of MOOSE.
 * @param executable The name of the executable selected by a client.
 * @return The complete launch command specific for a given MOOSE product,determined by the executable name selected by the client.
 */
@Override protected String updateExecutablePath(String installDir,String executable){
  HashMap<String,String> executableMap=new HashMap<String,String>();
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(""String_Node_Str"",""String_Node_Str"");
  executableMap.put(yamlSyntaxGenerator,yamlSyntaxGenerator);
  String launchCommand=null;
  setUploadInputFlag(true);
  if (""String_Node_Str"".equals(executable)) {
    launchCommand=""String_Node_Str"" + ""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str"";
  }
 else   if (yamlSyntaxGenerator.equals(executable)) {
    setAppendInputFlag(false);
    setUploadInputFlag(false);
    launchCommand=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(executable)) {
    launchCommand=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str""+ executable+ ""String_Node_Str"";
  }
 else {
    launchCommand=""String_Node_Str"" + executableMap.get(executable) + ""String_Node_Str""+ executableMap.get(executable)+ ""String_Node_Str"";
  }
  return launchCommand;
}",0.6430913348946136
133753,"@Override public String getSql(){
  return sql;
}","@Override public String getSql(){
  return sql + ""String_Node_Str"" + getFilterCriteria(sql);
}",0.6853146853146853
133754,"@Override public String prepareSql(Integer first,Integer count,String sortBy,boolean isAscending){
  String sql=getSql();
  StringBuilder sb=new StringBuilder(sql.length() * 2);
  boolean wrapForSkip=containExpand && first != null;
  if (wrapForSkip)   sb.append(""String_Node_Str"");
  sb.append(sql);
  if (!managers.isEmpty()) {
    String filter=applyFilters();
    if (!Strings.isNullOrEmpty(filter)) {
      boolean containsWhere=sql.toUpperCase().contains(""String_Node_Str"");
      if (containsWhere)       sb.append(""String_Node_Str"");
 else       sb.append(""String_Node_Str"");
      sb.append(filter);
      if (containsWhere)       sb.append(""String_Node_Str"");
    }
  }
  if (sortBy != null)   sb.append(""String_Node_Str"" + sortBy + (isAscending ? ""String_Node_Str"" : ""String_Node_Str""));
  if (wrapForSkip)   sb.append(""String_Node_Str"");
  if (first != null)   sb.append(""String_Node_Str"" + first);
  if (count != null && count > 0)   sb.append(""String_Node_Str"" + count);
  return sb.toString();
}","@Override public String prepareSql(Integer first,Integer count,String sortBy,boolean isAscending){
  String sql=getSql();
  StringBuilder sb=new StringBuilder(sql.length() * 2);
  boolean wrapForSkip=containExpand && first != null;
  if (wrapForSkip)   sb.append(""String_Node_Str"");
  sb.append(sql);
  sb.append(getFilterCriteria(sql));
  if (sortBy != null)   sb.append(""String_Node_Str"" + sortBy + (isAscending ? ""String_Node_Str"" : ""String_Node_Str""));
  if (wrapForSkip)   sb.append(""String_Node_Str"");
  if (first != null)   sb.append(""String_Node_Str"" + first);
  if (count != null && count > 0)   sb.append(""String_Node_Str"" + count);
  return sb.toString();
}",0.766388557806913
133755,"@Override public String getCountSql(){
  return countSql;
}","@Override public String getCountSql(){
  return countSql + ""String_Node_Str"" + getFilterCriteria(countSql);
}",0.7023809523809523
133756,"@Override public IRequestHandler onException(RequestCycle cycle,Exception ex){
  Throwable th=null;
  if ((th=Exceptions.findCause(ex,OSecurityException.class)) != null || (th=Exceptions.findCause(ex,OValidationException.class)) != null || (th=Exceptions.findCause(ex,OSchemaException.class)) != null || (th=Exceptions.findCause(ex,IllegalStateException.class)) != null && Exceptions.findCause(ex,WicketRuntimeException.class) == null) {
    Page page=extractCurrentPage();
    if (page == null)     return null;
    OrientDbWebSession.get().error(th.getMessage());
    return new RenderPageRequestHandler(new PageProvider(page),RenderPageRequestHandler.RedirectPolicy.ALWAYS_REDIRECT);
  }
 else   if ((th=Exceptions.findCause(ex,UnauthorizedActionException.class)) != null) {
    final UnauthorizedActionException unauthorizedActionException=(UnauthorizedActionException)th;
    return new IRequestHandler(){
      @Override public void respond(      IRequestCycle requestCycle){
        OrientDbWebApplication.get().onUnauthorizedInstantiation(unauthorizedActionException.getComponent());
      }
      @Override public void detach(      IRequestCycle requestCycle){
      }
    }
;
  }
 else {
    return null;
  }
}","@Override public IRequestHandler onException(RequestCycle cycle,Exception ex){
  Throwable th=null;
  if ((th=Exceptions.findCause(ex,OSecurityException.class)) != null || (th=Exceptions.findCause(ex,OValidationException.class)) != null || (th=Exceptions.findCause(ex,OSchemaException.class)) != null || (th=Exceptions.findCause(ex,IllegalStateException.class)) != null && Exceptions.findCause(ex,WicketRuntimeException.class) == null) {
    Page page=extractCurrentPage(false);
    if (page == null) {
      return th instanceof OSecurityException ? new UnauthorizedInstantiationHandler(extractCurrentPage(true)) : null;
    }
    OrientDbWebSession.get().error(th.getMessage());
    return new RenderPageRequestHandler(new PageProvider(page),RenderPageRequestHandler.RedirectPolicy.ALWAYS_REDIRECT);
  }
 else   if ((th=Exceptions.findCause(ex,UnauthorizedActionException.class)) != null) {
    final UnauthorizedActionException unauthorizedActionException=(UnauthorizedActionException)th;
    return new UnauthorizedInstantiationHandler(unauthorizedActionException.getComponent());
  }
 else {
    return null;
  }
}",0.7729799059427106
133757,"private Page extractCurrentPage(){
  final RequestCycle requestCycle=RequestCycle.get();
  IRequestHandler handler=requestCycle.getActiveRequestHandler();
  if (handler == null) {
    handler=requestCycle.getRequestHandlerScheduledAfterCurrent();
  }
  if (handler instanceof IPageRequestHandler) {
    IPageRequestHandler pageRequestHandler=(IPageRequestHandler)handler;
    return (Page)pageRequestHandler.getPage();
  }
  return null;
}","private Page extractCurrentPage(boolean fullSearch){
  final RequestCycle requestCycle=RequestCycle.get();
  IRequestHandler handler=requestCycle.getActiveRequestHandler();
  if (handler == null) {
    handler=requestCycle.getRequestHandlerScheduledAfterCurrent();
    if (handler == null && fullSearch) {
      handler=OrientDbWebApplication.get().getRootRequestMapper().mapRequest(requestCycle.getRequest());
    }
  }
  if (handler instanceof IPageRequestHandler) {
    IPageRequestHandler pageRequestHandler=(IPageRequestHandler)handler;
    return (Page)pageRequestHandler.getPage();
  }
  return null;
}",0.8377862595419847
133758,"@Override public void respond(IRequestCycle requestCycle){
  OrientDbWebApplication.get().onUnauthorizedInstantiation(unauthorizedActionException.getComponent());
}","@Override public void respond(IRequestCycle requestCycle){
  OrientDbWebApplication.get().onUnauthorizedInstantiation(component);
}",0.888135593220339
133759,"/** 
 * Tranform name to   {@link ORule.ResourceGeneric}
 * @param name name to transform
 * @return {@link ORule.ResourceGeneric} or null
 */
public static ORule.ResourceGeneric getResourceGeneric(String name){
  ORule.ResourceGeneric value=ORule.ResourceGeneric.valueOf(name);
  if (value == null)   value=ORule.mapLegacyResourceToGenericResource(name);
  return value;
}","/** 
 * Transform name to   {@link ORule.ResourceGeneric}
 * @param name name to transform
 * @return {@link ORule.ResourceGeneric} or null
 */
public static ORule.ResourceGeneric getResourceGeneric(String name){
  String shortName=Strings.beforeFirst(name,'.');
  if (Strings.isEmpty(shortName))   shortName=name;
  ORule.ResourceGeneric value=ORule.ResourceGeneric.valueOf(shortName);
  if (value == null)   value=ORule.mapLegacyResourceToGenericResource(name);
  return value;
}",0.8711943793911007
133760,"/** 
 * Check that current user has access to mentioned resource
 * @param resource resource check
 * @param action {@link Action} to check for
 * @param permissions {@link OrientPermission}s to check
 * @return true if access is allowed
 */
public boolean checkResource(String resource,Action action,OrientPermission[] permissions){
  String actionName=action.getName();
  if (resource.indexOf(':') > 0) {
    if (!(resource.endsWith(actionName) && resource.length() > actionName.length() && resource.charAt(resource.length() - actionName.length() - 1) == ':'))     return true;
  }
 else   if (!Component.RENDER.equals(action))   return true;
  OUser user=OrientDbWebSession.get().getUser();
  if (user == null)   return false;
  ORule.ResourceGeneric generic=OSecurityHelper.getResourceGeneric(resource);
  if (generic == null)   generic=ORule.mapLegacyResourceToGenericResource(resource);
  String specific=ORule.mapLegacyResourceToSpecificResource(resource);
  return user != null ? user.checkIfAllowed(generic,specific,OrientPermission.combinedPermission(permissions)) != null : false;
}","/** 
 * Check that current user has access to mentioned resource
 * @param resource resource check
 * @param action {@link Action} to check for
 * @param permissions {@link OrientPermission}s to check
 * @return true if access is allowed
 */
public boolean checkResource(String resource,Action action,OrientPermission[] permissions){
  String actionName=action.getName();
  int actionIndx=resource.indexOf(':');
  if (actionIndx > 0) {
    if (!(resource.endsWith(actionName) && resource.length() > actionName.length() && resource.charAt(resource.length() - actionName.length() - 1) == ':'))     return true;
 else     resource=resource.substring(0,actionIndx);
  }
 else   if (!Component.RENDER.equals(action))   return true;
  OUser user=OrientDbWebSession.get().getUser();
  if (user == null)   return false;
  ORule.ResourceGeneric generic=OSecurityHelper.getResourceGeneric(resource);
  String specific=OSecurityHelper.getResourceSpecific(resource);
  return user != null ? user.checkIfAllowed(generic,specific,OrientPermission.combinedPermission(permissions)) != null : false;
}",0.8764354616444648
133761,"public DynamicPropertyValueModel(IModel<ODocument> docModel,IModel<OProperty> propertyModel){
  Args.notNull(docModel,""String_Node_Str"");
  this.docModel=docModel;
  this.propertyModel=propertyModel;
}","public DynamicPropertyValueModel(IModel<ODocument> docModel,IModel<OProperty> propertyModel,Class<? extends T> valueType){
  Args.notNull(docModel,""String_Node_Str"");
  this.docModel=docModel;
  this.propertyModel=propertyModel;
  this.valueType=valueType;
}",0.8758169934640523
133762,"@SuppressWarnings(""String_Node_Str"") @Override protected T load(){
  ODocument doc=docModel.getObject();
  OProperty prop=propertyModel != null ? propertyModel.getObject() : null;
  if (doc == null)   return null;
  if (prop == null)   return (T)doc;
  return (T)doc.field(prop.getName());
}","@SuppressWarnings(""String_Node_Str"") @Override protected T load(){
  ODocument doc=docModel.getObject();
  OProperty prop=propertyModel != null ? propertyModel.getObject() : null;
  if (doc == null)   return null;
  if (prop == null)   return (T)doc;
  if (valueType == null) {
    return (T)doc.field(prop.getName());
  }
 else {
    Object ret=doc.field(prop.getName(),valueType);
    if (ORecord.class.isAssignableFrom(valueType) && ret instanceof ORID) {
      ret=((ORID)ret).getRecord();
    }
    return (T)ret;
  }
}",0.7141104294478527
133763,"public ODocumentModel(ORID iRID){
  this.orid=iRID;
}","public ODocumentModel(OIdentifiable identifiable){
  super(identifiable != null ? (ODocument)identifiable.getRecord() : null);
  if (identifiable != null)   this.orid=identifiable.getIdentity();
}",0.3694779116465863
133764,"/** 
 * Creation of actual instance from   {@link IPrototype}
 * @param proxy prototype instance to be realized
 * @return realized instance
 */
protected T handleRealize(T proxy){
  T ret=createInstance(proxy);
  PropertyResolverConverter prc=getPropertyResolverConverter();
  for (  Map.Entry<String,Object> entry : values.entrySet()) {
    String propertyName=entry.getKey();
    Object value=entry.getValue();
    int mappedIndicatorIndx=propertyName.indexOf(':');
    if (mappedIndicatorIndx < 0) {
      try {
        PropertyResolver.setValue(propertyName,ret,value,prc);
      }
 catch (      WicketRuntimeException e) {
        e.printStackTrace();
      }
    }
 else {
      String propertyExp=propertyName.substring(0,mappedIndicatorIndx);
      String fieldExp=propertyName.substring(mappedIndicatorIndx + 1);
      Object object=ret;
      int subObject=propertyExp.lastIndexOf('.');
      if (subObject >= 0) {
        object=PropertyResolver.getValue(propertyExp.substring(0,subObject),object);
        propertyExp=propertyExp.substring(subObject + 1);
      }
      if (object != null) {
        String methodName=""String_Node_Str"" + propertyExp.substring(0,1).toUpperCase() + propertyExp.substring(1);
        Method[] methods=object.getClass().getMethods();
        try {
          for (          Method method : methods) {
            if (method.getName().equals(methodName)) {
              Class<?>[] paramTypes=method.getParameterTypes();
              if (paramTypes.length == 2 && paramTypes[0].isAssignableFrom(String.class) && (value == null || paramTypes[1].isInstance(value))) {
                method.invoke(object,fieldExp,value);
                break;
              }
            }
          }
        }
 catch (        Exception e) {
        }
      }
    }
  }
  realized=ret;
  if (listener != null)   listener.onRealizePrototype((IPrototype<T>)proxy);
  return ret;
}","/** 
 * Creation of actual instance from   {@link IPrototype}
 * @param proxy prototype instance to be realized
 * @return realized instance
 */
protected T handleRealize(T proxy){
  T ret=createInstance(proxy);
  PropertyResolverConverter prc=getPropertyResolverConverter();
  for (  Map.Entry<String,Object> entry : values.entrySet()) {
    String propertyName=entry.getKey();
    Object value=entry.getValue();
    int mappedIndicatorIndx=propertyName.indexOf(':');
    if (mappedIndicatorIndx < 0) {
      try {
        PropertyResolver.setValue(propertyName,ret,value,prc);
      }
 catch (      WicketRuntimeException e) {
        LOG.error(""String_Node_Str"" + propertyName,e);
      }
    }
 else {
      String propertyExp=propertyName.substring(0,mappedIndicatorIndx);
      String fieldExp=propertyName.substring(mappedIndicatorIndx + 1);
      Object object=ret;
      int subObject=propertyExp.lastIndexOf('.');
      if (subObject >= 0) {
        object=PropertyResolver.getValue(propertyExp.substring(0,subObject),object);
        propertyExp=propertyExp.substring(subObject + 1);
      }
      if (object != null) {
        String methodName=""String_Node_Str"" + propertyExp.substring(0,1).toUpperCase() + propertyExp.substring(1);
        Method[] methods=object.getClass().getMethods();
        try {
          for (          Method method : methods) {
            if (method.getName().equals(methodName)) {
              Class<?>[] paramTypes=method.getParameterTypes();
              if (paramTypes.length == 2 && paramTypes[0].isAssignableFrom(String.class) && (value == null || paramTypes[1].isInstance(value))) {
                method.invoke(object,fieldExp,value);
                break;
              }
            }
          }
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"" + propertyName,e);
        }
      }
    }
  }
  realized=ret;
  if (listener != null)   listener.onRealizePrototype((IPrototype<T>)proxy);
  return ret;
}",0.9704446157800052
133765,"@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        String segment=i == 1 ? OrientDbWebSession.get().getDatabase().getName() : params.get(i).toString();
        sb.append(UrlEncoder.PATH_INSTANCE.encode(segment,""String_Node_Str"")).append('/');
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString)) {
        if (sb.charAt(sb.length() - 1) != '?')         sb.append('?');
        sb.append(queryString);
      }
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        con.setUseCaches(false);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          con.setDoOutput(true);
          IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null) {
              IOUtils.copy(errorStream,out,""String_Node_Str"");
              String errorBody=sw.toString();
              LOG.error(errorBody);
              attributes.getResponse().write(errorBody);
            }
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
 finally {
        if (con != null)         con.disconnect();
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}","@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        String segment=i == 1 ? OrientDbWebSession.get().getDatabase().getName() : params.get(i).toString();
        sb.append(UrlEncoder.PATH_INSTANCE.encode(segment,""String_Node_Str"")).append('/');
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString)) {
        if (sb.charAt(sb.length() - 1) != '?')         sb.append('?');
        sb.append(queryString);
      }
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        con.setUseCaches(false);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          int contentLength=httpRequest.getContentLength();
          con.setDoOutput(true);
          String initialContentType=httpRequest.getContentType();
          if (initialContentType != null)           con.setRequestProperty(""String_Node_Str"",initialContentType);
          int copied=IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
          if (contentLength > 0 && copied == 0) {
            IOUtils.copy(InterceptContentFilter.getContentAsInputStream(httpRequest),con.getOutputStream());
          }
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null) {
              IOUtils.copy(errorStream,out,""String_Node_Str"");
              String errorBody=sw.toString();
              LOG.error(errorBody);
              attributes.getResponse().write(errorBody);
            }
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
 finally {
        if (con != null)         con.disconnect();
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}",0.9356707317073172
133766,"/** 
 * @param oClassName name of the subject {@link OClass} for security check
 * @param action action to be secured for
 * @param permissions required permissions for access {@link OClass}
 * @return array of {@link RequiredOrientResource} for rights setup emulation
 */
public static RequiredOrientResource[] requireOClass(final String oClassName,final Action action,final OrientPermission... permissions){
  return requireResource(ORule.ResourceGeneric.CLASS,oClassName,action,permissions);
}","/** 
 * @param oClassName name of the subject {@link OClass} for security check
 * @param action action to be secured for
 * @param permissions required permissions for access {@link OClass}
 * @return array of {@link RequiredOrientResource} for rights setup emulation
 */
public static RequiredOrientResource[] requireOClass(final String oClassName,final Action action,final OrientPermission... permissions){
  return oClassName != null ? requireResource(ORule.ResourceGeneric.CLASS,oClassName,action,permissions) : new RequiredOrientResource[0];
}",0.9492822966507176
133767,"@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        String segment=i == 1 ? OrientDbWebSession.get().getDatabase().getName() : params.get(i).toString();
        sb.append(UrlEncoder.PATH_INSTANCE.encode(segment,""String_Node_Str"")).append('/');
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString))       sb.append(queryString);
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        con.setUseCaches(false);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          con.setDoOutput(true);
          IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null) {
              IOUtils.copy(errorStream,out,""String_Node_Str"");
              String errorBody=sw.toString();
              attributes.getResponse().write(errorBody);
            }
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
 finally {
        if (con != null)         con.disconnect();
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}","@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        String segment=i == 1 ? OrientDbWebSession.get().getDatabase().getName() : params.get(i).toString();
        sb.append(UrlEncoder.PATH_INSTANCE.encode(segment,""String_Node_Str"")).append('/');
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString)) {
        if (sb.charAt(sb.length() - 1) != '?')         sb.append('?');
        sb.append(queryString);
      }
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        con.setUseCaches(false);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          con.setDoOutput(true);
          IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null) {
              IOUtils.copy(errorStream,out,""String_Node_Str"");
              String errorBody=sw.toString();
              attributes.getResponse().write(errorBody);
            }
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
 finally {
        if (con != null)         con.disconnect();
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}",0.986127360855758
133768,"@Override public boolean authenticate(String username,String password){
  try {
    ODatabaseDocument currentDB=getDatabase();
    boolean inTransaction=currentDB.getTransaction().isActive();
    IOrientDbSettings settings=OrientDbWebApplication.get().getOrientDbSettings();
    ODatabaseDocument newDB=settings.getDatabasePoolFactory().get(settings.getDBUrl(),username,password).acquire();
    if (newDB != currentDB) {
      currentDB.activateOnCurrentThread();
      currentDB.commit();
      currentDB.close();
      newDB.activateOnCurrentThread();
    }
    setUser(username,password);
    user=newDB.getMetadata().getSecurity().getUser(username);
    newDB.setUser(user);
    if (inTransaction && !newDB.getTransaction().isActive())     newDB.begin();
    return true;
  }
 catch (  OSecurityAccessException e) {
    return false;
  }
}","@Override public boolean authenticate(String username,String password){
  ODatabaseDocument currentDB=getDatabase();
  try {
    boolean inTransaction=currentDB.getTransaction().isActive();
    IOrientDbSettings settings=OrientDbWebApplication.get().getOrientDbSettings();
    ODatabaseDocument newDB=settings.getDatabasePoolFactory().get(settings.getDBUrl(),username,password).acquire();
    if (newDB != currentDB) {
      currentDB.activateOnCurrentThread();
      currentDB.commit();
      currentDB.close();
      newDB.activateOnCurrentThread();
    }
    setUser(username,password);
    user=newDB.getMetadata().getSecurity().getUser(username);
    newDB.setUser(user);
    if (inTransaction && !newDB.getTransaction().isActive())     newDB.begin();
    return true;
  }
 catch (  OSecurityAccessException e) {
    currentDB.activateOnCurrentThread();
    return false;
  }
}",0.9228985507246376
133769,"@Override public IRequestHandler onException(RequestCycle cycle,Exception ex){
  OrientDbWebSession session=OrientDbWebSession.get();
  session.getDatabase().rollback();
  return null;
}","@Override public IRequestHandler onException(RequestCycle cycle,Exception ex){
  ODatabaseDocument db=ODatabaseRecordThreadLocal.INSTANCE.get();
  if (!db.isClosed())   db.rollback();
  return null;
}",0.6528497409326425
133770,"@Override public void onConfigure(Component component){
  Object object=component.getDefaultModelObject();
  component.setEnabled(component.isEnabled() && !(object instanceof IPrototype));
}","@Override public void onConfigure(Component component){
  Object object=component.getDefaultModelObject();
  component.setEnabled(!(object instanceof IPrototype));
}",0.9295774647887324
133771,"public OSchemaHelper linkedClass(String className){
  checkOProperty();
  OClass linkedToClass=schema.getClass(className);
  if (linkedToClass == null)   throw new IllegalArgumentException(""String_Node_Str"" + className + ""String_Node_Str"");
  if (!Objects.equals(linkedToClass,lastProperty.getLinkedClass())) {
    lastProperty.setLinkedClass(linkedToClass);
  }
  return this;
}","public OSchemaHelper linkedClass(String className){
  checkOProperty();
  OClass linkedToClass=schema.getClass(className);
  if (linkedToClass == null)   throw new IllegalArgumentException(""String_Node_Str"" + className + ""String_Node_Str"");
  if (!Objects.equal(linkedToClass,lastProperty.getLinkedClass())) {
    lastProperty.setLinkedClass(linkedToClass);
  }
  return this;
}",0.998678996036988
133772,"@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        String segment=i == 1 ? OrientDbWebSession.get().getDatabase().getName() : params.get(i).toString();
        sb.append(UrlEncoder.PATH_INSTANCE.encode(segment,""String_Node_Str"")).append('/');
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString))       sb.append('?').append(queryString);
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          con.setDoOutput(true);
          IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null)             IOUtils.copy(errorStream,out,""String_Node_Str"");
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}","@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        String segment=i == 1 ? OrientDbWebSession.get().getDatabase().getName() : params.get(i).toString();
        sb.append(UrlEncoder.PATH_INSTANCE.encode(segment,""String_Node_Str"")).append('/');
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString))       sb.append('?').append(queryString);
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        con.setUseCaches(false);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          con.setDoOutput(true);
          IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null)             IOUtils.copy(errorStream,out,""String_Node_Str"");
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}",0.9940098021419496
133773,"public static void mountOrientDbRestApi(OrientDBHttpAPIResource resource,WebApplication app){
  app.getSharedResources().add(ORIENT_DB_KEY,resource);
  app.mountResource(MOUNT_PATH,new SharedResourceReference(ORIENT_DB_KEY));
  Authenticator.setDefault(new Authenticator(){
    @Override protected PasswordAuthentication getPasswordAuthentication(){
      String username;
      String password;
      OrientDbWebSession session=OrientDbWebSession.get();
      if (session.isSignedIn()) {
        username=session.getUsername();
        password=session.getPassword();
      }
 else {
        IOrientDbSettings settings=OrientDbWebApplication.get().getOrientDbSettings();
        username=settings.getDBUserName();
        password=settings.getDBUserPassword();
      }
      return new PasswordAuthentication(username,password.toCharArray());
    }
  }
);
  CookieHandler.setDefault(new PersonalCookieManager());
}","@SuppressWarnings(""String_Node_Str"") public static void mountOrientDbRestApi(OrientDBHttpAPIResource resource,WebApplication app){
  app.getSharedResources().add(ORIENT_DB_KEY,resource);
  app.mountResource(MOUNT_PATH,new SharedResourceReference(ORIENT_DB_KEY));
  Authenticator.setDefault(new Authenticator(){
    @Override protected PasswordAuthentication getPasswordAuthentication(){
      String username;
      String password;
      OrientDbWebSession session=OrientDbWebSession.get();
      if (session.isSignedIn()) {
        username=session.getUsername();
        password=session.getPassword();
      }
 else {
        IOrientDbSettings settings=OrientDbWebApplication.get().getOrientDbSettings();
        username=settings.getDBUserName();
        password=settings.getDBUserPassword();
      }
      return new PasswordAuthentication(username,password.toCharArray());
    }
  }
);
  CookieHandler.setDefault(new PersonalCookieManager());
  sun.net.www.protocol.http.AuthCacheValue.setAuthCache(new MultiUserCache());
}",0.9403905447070916
133774,"@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        if (i == 1) {
          sb.append(OrientDbWebSession.get().getDatabase().getName()).append('/');
        }
 else {
          sb.append(params.get(i).toString()).append('/');
        }
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString))       sb.append('?').append(queryString);
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          con.setDoOutput(true);
          IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null)             IOUtils.copy(errorStream,out,""String_Node_Str"");
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}","@Override protected ResourceResponse newResourceResponse(Attributes attributes){
  final WebRequest request=(WebRequest)attributes.getRequest();
  final HttpServletRequest httpRequest=(HttpServletRequest)request.getContainerRequest();
  final PageParameters params=attributes.getParameters();
  final ResourceResponse response=new ResourceResponse();
  if (response.dataNeedsToBeWritten(attributes)) {
    String orientDbHttpURL=OrientDbWebApplication.get().getOrientDbSettings().getOrientDBRestApiUrl();
    if (orientDbHttpURL != null) {
      StringBuilder sb=new StringBuilder(orientDbHttpURL);
      for (int i=0; i < params.getIndexedCount(); i++) {
        String segment=i == 1 ? OrientDbWebSession.get().getDatabase().getName() : params.get(i).toString();
        sb.append(UrlEncoder.PATH_INSTANCE.encode(segment,""String_Node_Str"")).append('/');
      }
      if (sb.charAt(sb.length() - 1) == '/')       sb.setLength(sb.length() - 1);
      String queryString=request.getUrl().getQueryString();
      if (!Strings.isEmpty(queryString))       sb.append('?').append(queryString);
      final String url=sb.toString();
      final StringWriter sw=new StringWriter();
      final PrintWriter out=new PrintWriter(sw);
      HttpURLConnection con=null;
      try {
        URL orientURL=new URL(url);
        con=(HttpURLConnection)orientURL.openConnection();
        con.setDoInput(true);
        con.setUseCaches(false);
        String method=httpRequest.getMethod();
        con.setRequestMethod(method);
        if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
          con.setDoOutput(true);
          IOUtils.copy(httpRequest.getInputStream(),con.getOutputStream());
        }
        IOUtils.copy(con.getInputStream(),out,""String_Node_Str"");
        response.setStatusCode(con.getResponseCode());
        response.setContentType(con.getContentType());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        if (con != null) {
          try {
            response.setError(con.getResponseCode(),con.getResponseMessage());
            InputStream errorStream=con.getErrorStream();
            if (errorStream != null)             IOUtils.copy(errorStream,out,""String_Node_Str"");
          }
 catch (          IOException e1) {
            LOG.error(""String_Node_Str"",e1);
          }
        }
      }
      response.setWriteCallback(new WriteCallback(){
        @Override public void writeData(        Attributes attributes) throws IOException {
          attributes.getResponse().write(sw.toString());
        }
      }
);
    }
 else {
      response.setError(HttpServletResponse.SC_BAD_GATEWAY,""String_Node_Str"");
    }
  }
  return response;
}",0.9564740307242136
133775,"protected T handleRealize(T proxy){
  T ret=createInstance(proxy);
  PropertyResolverConverter prc=getPropertyResolverConverter();
  for (  Map.Entry<String,Object> entry : values.entrySet()) {
    try {
      PropertyResolver.setValue(entry.getKey(),ret,entry.getValue(),prc);
    }
 catch (    WicketRuntimeException e) {
    }
  }
  realized=ret;
  return ret;
}","protected T handleRealize(T proxy){
  T ret=createInstance(proxy);
  PropertyResolverConverter prc=getPropertyResolverConverter();
  for (  Map.Entry<String,Object> entry : values.entrySet()) {
    String propertyName=entry.getKey();
    Object value=entry.getValue();
    int mappedIndicatorIndx=propertyName.indexOf(':');
    if (mappedIndicatorIndx < 0) {
      try {
        PropertyResolver.setValue(propertyName,ret,value,prc);
      }
 catch (      WicketRuntimeException e) {
        e.printStackTrace();
      }
    }
 else {
      String propertyExp=propertyName.substring(0,mappedIndicatorIndx);
      String fieldExp=propertyName.substring(mappedIndicatorIndx + 1);
      Object object=ret;
      int subObject=propertyExp.lastIndexOf('.');
      if (subObject >= 0) {
        object=PropertyResolver.getValue(propertyExp.substring(0,subObject),object);
        propertyExp=propertyExp.substring(subObject + 1);
      }
      if (object != null) {
        String methodName=""String_Node_Str"" + propertyExp.substring(0,1).toUpperCase() + propertyExp.substring(1);
        Method[] methods=object.getClass().getMethods();
        try {
          for (          Method method : methods) {
            if (method.getName().equals(methodName)) {
              Class<?>[] paramTypes=method.getParameterTypes();
              if (paramTypes.length == 2 && paramTypes[0].isAssignableFrom(String.class) && (value == null || paramTypes[1].isInstance(value))) {
                method.invoke(object,fieldExp,value);
                break;
              }
            }
          }
        }
 catch (        Exception e) {
        }
      }
    }
  }
  realized=ret;
  return ret;
}",0.3077674645823156
133776,"@Override protected void installData(OrientDbWebApplication app,ODatabaseRecord db){
  OSchema schema=db.getMetadata().getSchema();
  OClass classA=schema.createClass(""String_Node_Str"");
  classA.createProperty(""String_Node_Str"",OType.STRING);
  classA.createProperty(""String_Node_Str"",OType.STRING);
  OClass classB=schema.createClass(""String_Node_Str"");
  classB.createProperty(""String_Node_Str"",OType.STRING);
  classB.createProperty(""String_Node_Str"",OType.STRING);
}","@Override protected void installData(OrientDbWebApplication app,ODatabaseRecord db){
  OSchema schema=db.getMetadata().getSchema();
  OClass classA=schema.createClass(""String_Node_Str"");
  classA.createProperty(""String_Node_Str"",OType.STRING);
  classA.createProperty(""String_Node_Str"",OType.STRING);
  OClass classB=schema.createClass(""String_Node_Str"");
  classB.createProperty(""String_Node_Str"",OType.STRING);
  classB.createProperty(""String_Node_Str"",OType.STRING);
  new ODocument(""String_Node_Str"").field(""String_Node_Str"",""String_Node_Str"").save();
  new ODocument(""String_Node_Str"").field(""String_Node_Str"",""String_Node_Str"").save();
  new ODocument(""String_Node_Str"").field(""String_Node_Str"",""String_Node_Str"").save();
}",0.785
133777,"@Override public void setCustom(String param,Object value){
  custom.put(name,value);
}","@Override public void setCustom(String param,Object value){
  customMap.put(param,value);
}",0.9550561797752808
133778,"@Override public Object getCustom(String param){
  return custom.get(param);
}","@Override public Object getCustom(String param){
  return customMap.get(param);
}",0.981132075471698
133779,"@Test public void testMappedPropertiesPrototyper() throws Exception {
  IMyBean bean=MyBeanPrototyper.newPrototype();
  assertTrue(bean instanceof IPrototype<?>);
  assertTrue(bean instanceof Serializable);
  bean.setCustom(""String_Node_Str"",""String_Node_Str"");
  bean.setCustom(""String_Node_Str"",-1);
  assertEquals(""String_Node_Str"",bean.getCustom(""String_Node_Str""));
  assertEquals(Integer.valueOf(-1),bean.getCustom(""String_Node_Str""));
  IPrototype<IMyBean> proto=(IPrototype<IMyBean>)bean;
  assertTrue(proto instanceof IMyBean);
  assertFalse(proto.isPrototypeRealized());
  bean=proto.realizePrototype();
  assertEquals(""String_Node_Str"",bean.getCustom(""String_Node_Str""));
  assertEquals(Integer.valueOf(-1),bean.getCustom(""String_Node_Str""));
  assertEquals(""String_Node_Str"",bean.getSignature());
  assertTrue(proto.isPrototypeRealized());
  assertEquals(""String_Node_Str"",((IMyBean)proto).getSignature());
}","@Test public void testMappedPropertiesPrototyper() throws Exception {
  IMyBean bean=MyBeanPrototyper.newPrototype();
  assertTrue(bean instanceof IPrototype<?>);
  assertTrue(bean instanceof Serializable);
  bean.setCustom(""String_Node_Str"",""String_Node_Str"");
  bean.setCustom(""String_Node_Str"",-1);
  bean.setCustomString(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",bean.getCustom(""String_Node_Str""));
  assertEquals(Integer.valueOf(-1),bean.getCustom(""String_Node_Str""));
  assertEquals(""String_Node_Str"",bean.getCustomString(""String_Node_Str""));
  IPrototype<IMyBean> proto=(IPrototype<IMyBean>)bean;
  assertTrue(proto instanceof IMyBean);
  assertFalse(proto.isPrototypeRealized());
  bean=proto.realizePrototype();
  assertEquals(""String_Node_Str"",bean.getCustom(""String_Node_Str""));
  assertEquals(Integer.valueOf(-1),bean.getCustom(""String_Node_Str""));
  assertEquals(""String_Node_Str"",bean.getCustomString(""String_Node_Str""));
  assertEquals(""String_Node_Str"",bean.getSignature());
  assertTrue(proto.isPrototypeRealized());
  assertEquals(""String_Node_Str"",((IMyBean)proto).getSignature());
}",0.8454412481716236
133780,"@Test public void testOPropertyPrototyper() throws Exception {
  OClass newClass=getSchema().createClass(""String_Node_Str"");
  OProperty newProperty=OPropertyPrototyper.newPrototype(""String_Node_Str"");
  assertNull(newClass.getProperty(""String_Node_Str""));
  newProperty.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",newProperty.getName());
  assertNull(newClass.getProperty(""String_Node_Str""));
  newProperty.setType(OType.STRING);
  assertEquals(OType.STRING,newProperty.getType());
  assertTrue(newProperty instanceof IPrototype);
  OProperty realizedNewProperty=((IPrototype<OProperty>)newProperty).realizePrototype();
  assertEquals(newClass.getProperty(""String_Node_Str""),realizedNewProperty);
  getSchema().dropClass(newClass.getName());
}","@Test public void testOPropertyPrototyper() throws Exception {
  OClass newClass=getSchema().createClass(""String_Node_Str"");
  try {
    OProperty newProperty=OPropertyPrototyper.newPrototype(""String_Node_Str"");
    assertNull(newClass.getProperty(""String_Node_Str""));
    newProperty.setName(""String_Node_Str"");
    assertEquals(""String_Node_Str"",newProperty.getName());
    assertNull(newClass.getProperty(""String_Node_Str""));
    newProperty.setType(OType.STRING);
    assertEquals(OType.STRING,newProperty.getType());
    newProperty.setCustom(""String_Node_Str"",""String_Node_Str"");
    assertEquals(""String_Node_Str"",newProperty.getCustom(""String_Node_Str""));
    assertTrue(newProperty instanceof IPrototype);
    OProperty realizedNewProperty=((IPrototype<OProperty>)newProperty).realizePrototype();
    assertEquals(newClass.getProperty(""String_Node_Str""),realizedNewProperty);
    assertEquals(""String_Node_Str"",realizedNewProperty.getCustom(""String_Node_Str""));
  }
  finally {
    getSchema().dropClass(newClass.getName());
  }
}",0.8455555555555555
133781,"protected void validateType(final IValidatable<T> validatable,final OProperty p,final Object value){
  if (value != null)   if (OType.convert(value,p.getLinkedType().getDefaultJavaType()) == null)   validatable.error(newValidationError(""String_Node_Str""));
}","protected void validateType(final IValidatable<T> validatable,final OProperty p,final Object value){
  if (value != null)   if (OType.convert(value,p.getLinkedType().getDefaultJavaType()) == null)   validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",p.getLinkedType().toString()));
}",0.91651865008881
133782,"protected void validateEmbedded(final IValidatable<T> validatable,final OProperty p,final Object fieldValue){
  if (fieldValue instanceof ORecordId) {
    validatable.error(newValidationError(""String_Node_Str""));
    return;
  }
 else   if (fieldValue instanceof OIdentifiable) {
    if (((OIdentifiable)fieldValue).getIdentity().isValid()) {
      validatable.error(newValidationError(""String_Node_Str""));
      return;
    }
    final OClass embeddedClass=p.getLinkedClass();
    if (embeddedClass != null) {
      final ORecord<?> rec=((OIdentifiable)fieldValue).getRecord();
      if (!(rec instanceof ODocument)) {
        validatable.error(newValidationError(""String_Node_Str""));
        return;
      }
      final ODocument doc=(ODocument)rec;
      if (doc.getSchemaClass() == null || !(doc.getSchemaClass().isSubClassOf(embeddedClass))) {
        validatable.error(newValidationError(""String_Node_Str""));
        return;
      }
    }
  }
 else {
    validatable.error(newValidationError(""String_Node_Str""));
    return;
  }
}","protected void validateEmbedded(final IValidatable<T> validatable,final OProperty p,final Object fieldValue){
  if (fieldValue instanceof ORecordId) {
    validatable.error(newValidationError(""String_Node_Str""));
    return;
  }
 else   if (fieldValue instanceof OIdentifiable) {
    if (((OIdentifiable)fieldValue).getIdentity().isValid()) {
      validatable.error(newValidationError(""String_Node_Str""));
      return;
    }
    final OClass embeddedClass=p.getLinkedClass();
    if (embeddedClass != null) {
      final ORecord<?> rec=((OIdentifiable)fieldValue).getRecord();
      if (!(rec instanceof ODocument)) {
        validatable.error(newValidationError(""String_Node_Str""));
        return;
      }
      final ODocument doc=(ODocument)rec;
      if (doc.getSchemaClass() == null || !(doc.getSchemaClass().isSubClassOf(embeddedClass))) {
        validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",embeddedClass.getName()));
        return;
      }
    }
  }
 else {
    validatable.error(newValidationError(""String_Node_Str""));
    return;
  }
}",0.9801324503311258
133783,"@Override public void validate(IValidatable<T> validatable){
  T fieldValue=validatable.getValue();
  OProperty p=getProperty();
  if (fieldValue == null) {
    if (p.isNotNull()) {
      validatable.error(new ValidationError(this,""String_Node_Str""));
    }
  }
 else {
    OType type=p.getType();
switch (type) {
case LINK:
      validateLink(validatable,p,fieldValue);
    break;
case LINKLIST:
  if (!(fieldValue instanceof List))   validatable.error(newValidationError(""String_Node_Str""));
 else   if (p.getLinkedClass() != null)   for (  Object item : ((List<?>)fieldValue))   validateLink(validatable,p,item);
break;
case LINKSET:
if (!(fieldValue instanceof Set)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) for (Object item : ((Set<?>)fieldValue)) validateLink(validatable,p,item);
break;
case LINKMAP:
if (!(fieldValue instanceof Map)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) for (Entry<?,?> entry : ((Map<?,?>)fieldValue).entrySet()) validateLink(validatable,p,entry.getValue());
break;
case EMBEDDED:
validateEmbedded(validatable,p,fieldValue);
break;
case EMBEDDEDLIST:
if (!(fieldValue instanceof List)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) {
for (Object item : ((List<?>)fieldValue)) validateEmbedded(validatable,p,item);
}
 else if (p.getLinkedType() != null) {
for (Object item : ((List<?>)fieldValue)) validateType(validatable,p,item);
}
break;
case EMBEDDEDSET:
if (!(fieldValue instanceof Set)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) {
for (Object item : ((Set<?>)fieldValue)) validateEmbedded(validatable,p,item);
}
 else if (p.getLinkedType() != null) {
for (Object item : ((Set<?>)fieldValue)) validateType(validatable,p,item);
}
break;
case EMBEDDEDMAP:
if (!(fieldValue instanceof Map)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) {
for (Entry<?,?> entry : ((Map<?,?>)fieldValue).entrySet()) validateEmbedded(validatable,p,entry.getValue());
}
 else if (p.getLinkedType() != null) {
for (Entry<?,?> entry : ((Map<?,?>)fieldValue).entrySet()) validateType(validatable,p,entry.getValue());
}
break;
default :
break;
}
if (p.getMin() != null) {
final String min=p.getMin();
if (p.getType().equals(OType.STRING) && (fieldValue != null && ((String)fieldValue).length() < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.BINARY) && (fieldValue != null && ((byte[])fieldValue).length < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.INTEGER) && (fieldValue != null && type.asInt(fieldValue) < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.LONG) && (fieldValue != null && type.asLong(fieldValue) < Long.parseLong(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.FLOAT) && (fieldValue != null && type.asFloat(fieldValue) < Float.parseFloat(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.DOUBLE) && (fieldValue != null && type.asDouble(fieldValue) < Double.parseDouble(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.DATE)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateFormatInstance().parse(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
}
 catch (ParseException e) {
}
}
 else if (p.getType().equals(OType.DATETIME)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateTimeFormatInstance().parse(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
}
 catch (ParseException e) {
}
}
 else if ((p.getType().equals(OType.EMBEDDEDLIST) || p.getType().equals(OType.EMBEDDEDSET) || p.getType().equals(OType.LINKLIST)|| p.getType().equals(OType.LINKSET)) && (fieldValue != null && ((Collection<?>)fieldValue).size() < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
}
if (p.getMax() != null) {
final String max=p.getMax();
if (p.getType().equals(OType.STRING) && (fieldValue != null && ((String)fieldValue).length() > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.BINARY) && (fieldValue != null && ((byte[])fieldValue).length > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.INTEGER) && (fieldValue != null && type.asInt(fieldValue) > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.LONG) && (fieldValue != null && type.asLong(fieldValue) > Long.parseLong(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.FLOAT) && (fieldValue != null && type.asFloat(fieldValue) > Float.parseFloat(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.DOUBLE) && (fieldValue != null && type.asDouble(fieldValue) > Double.parseDouble(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.DATE)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateFormatInstance().parse(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
}
 catch (ParseException e) {
}
}
 else if (p.getType().equals(OType.DATETIME)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateTimeFormatInstance().parse(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
}
 catch (ParseException e) {
}
}
 else if ((p.getType().equals(OType.EMBEDDEDLIST) || p.getType().equals(OType.EMBEDDEDSET) || p.getType().equals(OType.LINKLIST)|| p.getType().equals(OType.LINKSET)) && (fieldValue != null && ((Collection<?>)fieldValue).size() > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
}
}
}","@Override public void validate(IValidatable<T> validatable){
  T fieldValue=validatable.getValue();
  OProperty p=getProperty();
  if (fieldValue == null) {
    if (p.isNotNull()) {
      validatable.error(newValidationError(""String_Node_Str""));
    }
  }
 else {
    OType type=p.getType();
switch (type) {
case LINK:
      validateLink(validatable,p,fieldValue);
    break;
case LINKLIST:
  if (!(fieldValue instanceof List))   validatable.error(newValidationError(""String_Node_Str""));
 else   if (p.getLinkedClass() != null)   for (  Object item : ((List<?>)fieldValue))   validateLink(validatable,p,item);
break;
case LINKSET:
if (!(fieldValue instanceof Set)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) for (Object item : ((Set<?>)fieldValue)) validateLink(validatable,p,item);
break;
case LINKMAP:
if (!(fieldValue instanceof Map)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) for (Entry<?,?> entry : ((Map<?,?>)fieldValue).entrySet()) validateLink(validatable,p,entry.getValue());
break;
case EMBEDDED:
validateEmbedded(validatable,p,fieldValue);
break;
case EMBEDDEDLIST:
if (!(fieldValue instanceof List)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) {
for (Object item : ((List<?>)fieldValue)) validateEmbedded(validatable,p,item);
}
 else if (p.getLinkedType() != null) {
for (Object item : ((List<?>)fieldValue)) validateType(validatable,p,item);
}
break;
case EMBEDDEDSET:
if (!(fieldValue instanceof Set)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) {
for (Object item : ((Set<?>)fieldValue)) validateEmbedded(validatable,p,item);
}
 else if (p.getLinkedType() != null) {
for (Object item : ((Set<?>)fieldValue)) validateType(validatable,p,item);
}
break;
case EMBEDDEDMAP:
if (!(fieldValue instanceof Map)) validatable.error(newValidationError(""String_Node_Str""));
 else if (p.getLinkedClass() != null) {
for (Entry<?,?> entry : ((Map<?,?>)fieldValue).entrySet()) validateEmbedded(validatable,p,entry.getValue());
}
 else if (p.getLinkedType() != null) {
for (Entry<?,?> entry : ((Map<?,?>)fieldValue).entrySet()) validateType(validatable,p,entry.getValue());
}
break;
default :
break;
}
if (p.getMin() != null) {
final String min=p.getMin();
if (p.getType().equals(OType.STRING) && (fieldValue != null && ((String)fieldValue).length() < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.BINARY) && (fieldValue != null && ((byte[])fieldValue).length < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.INTEGER) && (fieldValue != null && type.asInt(fieldValue) < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.LONG) && (fieldValue != null && type.asLong(fieldValue) < Long.parseLong(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.FLOAT) && (fieldValue != null && type.asFloat(fieldValue) < Float.parseFloat(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.DOUBLE) && (fieldValue != null && type.asDouble(fieldValue) < Double.parseDouble(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
 else if (p.getType().equals(OType.DATE)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateFormatInstance().parse(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
}
 catch (ParseException e) {
}
}
 else if (p.getType().equals(OType.DATETIME)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateTimeFormatInstance().parse(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
}
 catch (ParseException e) {
}
}
 else if ((p.getType().equals(OType.EMBEDDEDLIST) || p.getType().equals(OType.EMBEDDEDSET) || p.getType().equals(OType.LINKLIST)|| p.getType().equals(OType.LINKSET)) && (fieldValue != null && ((Collection<?>)fieldValue).size() < Integer.parseInt(min))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",min));
}
if (p.getMax() != null) {
final String max=p.getMax();
if (p.getType().equals(OType.STRING) && (fieldValue != null && ((String)fieldValue).length() > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.BINARY) && (fieldValue != null && ((byte[])fieldValue).length > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.INTEGER) && (fieldValue != null && type.asInt(fieldValue) > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.LONG) && (fieldValue != null && type.asLong(fieldValue) > Long.parseLong(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.FLOAT) && (fieldValue != null && type.asFloat(fieldValue) > Float.parseFloat(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.DOUBLE) && (fieldValue != null && type.asDouble(fieldValue) > Double.parseDouble(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
 else if (p.getType().equals(OType.DATE)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateFormatInstance().parse(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
}
 catch (ParseException e) {
}
}
 else if (p.getType().equals(OType.DATETIME)) {
try {
if (fieldValue != null && ((Date)fieldValue).before(getDatabase().getStorage().getConfiguration().getDateTimeFormatInstance().parse(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
}
 catch (ParseException e) {
}
}
 else if ((p.getType().equals(OType.EMBEDDEDLIST) || p.getType().equals(OType.EMBEDDEDSET) || p.getType().equals(OType.LINKLIST)|| p.getType().equals(OType.LINKSET)) && (fieldValue != null && ((Collection<?>)fieldValue).size() > Integer.parseInt(max))) validatable.error(newValidationError(""String_Node_Str"",""String_Node_Str"",max));
}
}
}",0.9971658711217184
133784,"/** 
 * @see org.apache.wicket.Application#init()
 */
@Override public void init(){
  super.init();
  getApplicationListeners().add(new EmbeddOrientDbApplicationListener(WicketApplication.class.getResource(""String_Node_Str"")){
    @Override public void onAfterServerStartupAndActivation() throws Exception {
      OServerAdmin serverAdmin=new OServerAdmin(""String_Node_Str"" + DB_NAME).connect(""String_Node_Str"",""String_Node_Str"");
      if (!serverAdmin.existsDatabase())       serverAdmin.createDatabase(DB_NAME,""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  getOrientDbSettings().setDBUrl(""String_Node_Str"" + DB_NAME);
  getOrientDbSettings().setDefaultUserName(""String_Node_Str"");
  getOrientDbSettings().setDefaultUserPassword(""String_Node_Str"");
}","/** 
 * @see org.apache.wicket.Application#init()
 */
@Override public void init(){
  super.init();
  getApplicationListeners().add(new EmbeddOrientDbApplicationListener(WicketApplication.class.getResource(""String_Node_Str"")){
    @Override public void onAfterServerStartupAndActivation() throws Exception {
      OServerAdmin serverAdmin=new OServerAdmin(""String_Node_Str"" + DB_NAME).connect(""String_Node_Str"",""String_Node_Str"");
      if (!serverAdmin.existsDatabase())       serverAdmin.createDatabase(DB_NAME,""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  getOrientDbSettings().setDBUrl(""String_Node_Str"" + DB_NAME);
  getOrientDbSettings().setDBUserName(""String_Node_Str"");
  getOrientDbSettings().setDBUserPassword(""String_Node_Str"");
}",0.9907038512616202
133785,"public byte[] getFileDataBytes(String name){
  System.out.println(""String_Node_Str"" + name);
  try {
    InputStream is=getInputStreamForAsset(name);
    if (is == null) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    ByteArrayOutputStream bout=new ByteArrayOutputStream();
    byte[] buffer=new byte[1024];
    while (true) {
      int len=is.read(buffer);
      if (len < 0) {
        break;
      }
      bout.write(buffer,0,len);
    }
    byte[] retval=bout.toByteArray();
    return retval;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","public byte[] getFileDataBytes(String name){
  System.out.println(""String_Node_Str"" + name);
  try {
    if (name.isEmpty())     return null;
    InputStream is=null;
    if (name.charAt(0) == '/')     is=new FileInputStream(new File(name));
 else     is=getInputStreamForAsset(name);
    if (is == null) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    ByteArrayOutputStream bout=new ByteArrayOutputStream();
    byte[] buffer=new byte[1024];
    while (true) {
      int len=is.read(buffer);
      if (len < 0) {
        break;
      }
      bout.write(buffer,0,len);
    }
    byte[] retval=bout.toByteArray();
    return retval;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.8997772828507795
133786,"protected InputStream getLocalInputStreamForAsset(String name){
  InputStream is=null;
  try {
    try {
      is=apkContext.getAssets().open(name);
    }
 catch (    Exception e) {
      e.printStackTrace();
      is=getAssets().open(name);
    }
    if (is == null) {
      System.out.println(""String_Node_Str"");
      is=getAssets().open(name);
    }
    return is;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","protected InputStream getLocalInputStreamForAsset(String name){
  InputStream is=null;
  try {
    try {
      if (name.charAt(0) == '/')       is=new FileInputStream(new File(name));
 else       is=apkContext.getAssets().open(name);
    }
 catch (    Exception e) {
      e.printStackTrace();
      is=getAssets().open(name);
    }
    if (is == null) {
      System.out.println(""String_Node_Str"");
      is=getAssets().open(name);
    }
    return is;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.9128205128205128
133787,"@Override public void execute(Tuple input){
  Source src=parseComponentId(input.getSourceComponent());
  if (src == Source.GACD) {
    avg=input.getDoubleByField(Field.AVERAGE);
  }
 else {
    CallDetailRecord cdr=(CallDetailRecord)input.getValueByField(Field.RECORD);
    String number=input.getString(0);
    long timestamp=input.getLong(1);
    double rate=input.getDouble(2);
    String key=String.format(""String_Node_Str"",number,timestamp);
    if (map.containsKey(key)) {
      Entry e=map.get(key);
      e.set(src,rate);
      if (e.isFull()) {
        double ratio=(e.get(Source.CT24) / e.get(Source.ECR24)) / avg;
        double score=score(thresholdMin,thresholdMax,ratio);
        LOG.info(String.format(""String_Node_Str"",thresholdMin,thresholdMax,e.get(Source.CT24),e.get(Source.ECR24),avg,ratio,score));
        collector.emit(new Values(number,timestamp,score,cdr));
        map.remove(key);
      }
 else {
        LOG.warn(String.format(""String_Node_Str"",input.getSourceComponent(),e.toString()));
      }
    }
 else {
      Entry e=new Entry(cdr);
      e.set(src,rate);
      map.put(key,e);
    }
  }
}","@Override public void execute(Tuple input){
  Source src=parseComponentId(input.getSourceComponent());
  if (src == Source.GACD) {
    avg=input.getDoubleByField(Field.AVERAGE);
  }
 else {
    CallDetailRecord cdr=(CallDetailRecord)input.getValueByField(Field.RECORD);
    String number=input.getString(0);
    long timestamp=input.getLong(1);
    double rate=input.getDouble(2);
    String key=String.format(""String_Node_Str"",number,timestamp);
    if (map.containsKey(key)) {
      Entry e=map.get(key);
      e.set(src,rate);
      if (e.isFull()) {
        double ratio=(e.get(Source.CT24) / e.get(Source.ECR24)) / avg;
        double score=score(thresholdMin,thresholdMax,ratio);
        LOG.debug(String.format(""String_Node_Str"",thresholdMin,thresholdMax,e.get(Source.CT24),e.get(Source.ECR24),avg,ratio,score));
        collector.emit(new Values(number,timestamp,score,cdr));
        map.remove(key);
      }
 else {
        LOG.warn(String.format(""String_Node_Str"",input.getSourceComponent(),e.toString()));
      }
    }
 else {
      Entry e=new Entry(cdr);
      e.set(src,rate);
      map.put(key,e);
    }
  }
}",0.9959982214317474
133788,"@Override public void execute(Tuple input){
  CallDetailRecord cdr=(CallDetailRecord)input.getValue(3);
  String number=input.getString(0);
  long timestamp=input.getLong(1);
  double rate=input.getDouble(2);
  String key=String.format(""String_Node_Str"",number,timestamp);
  Source src=parseComponentId(input.getSourceComponent());
  if (map.containsKey(key)) {
    Entry e=map.get(key);
    e.set(src,rate);
    if (e.isFull()) {
      double ratio=(e.get(Source.ECR) / e.get(Source.RCR));
      double score=score(thresholdMin,thresholdMax,ratio);
      LOG.info(String.format(""String_Node_Str"",thresholdMin,thresholdMax,e.get(Source.ECR),e.get(Source.RCR),ratio,score));
      collector.emit(new Values(number,timestamp,score,cdr));
      map.remove(key);
    }
 else {
      LOG.warn(String.format(""String_Node_Str"",input.getSourceComponent(),e.toString()));
    }
  }
 else {
    Entry e=new Entry(cdr);
    e.set(src,rate);
    map.put(key,e);
  }
}","@Override public void execute(Tuple input){
  CallDetailRecord cdr=(CallDetailRecord)input.getValue(3);
  String number=input.getString(0);
  long timestamp=input.getLong(1);
  double rate=input.getDouble(2);
  String key=String.format(""String_Node_Str"",number,timestamp);
  Source src=parseComponentId(input.getSourceComponent());
  if (map.containsKey(key)) {
    Entry e=map.get(key);
    e.set(src,rate);
    if (e.isFull()) {
      double ratio=(e.get(Source.ECR) / e.get(Source.RCR));
      double score=score(thresholdMin,thresholdMax,ratio);
      LOG.debug(String.format(""String_Node_Str"",thresholdMin,thresholdMax,e.get(Source.ECR),e.get(Source.RCR),ratio,score));
      collector.emit(new Values(number,timestamp,score,cdr));
      map.remove(key);
    }
 else {
      LOG.warn(String.format(""String_Node_Str"",input.getSourceComponent(),e.toString()));
    }
  }
 else {
    Entry e=new Entry(cdr);
    e.set(src,rate);
    map.put(key,e);
  }
}",0.9952904238618524
133789,"@Override public void execute(Tuple input){
  CallDetailRecord cdr=(CallDetailRecord)input.getValueByField(Field.RECORD);
  Source src=parseComponentId(input.getSourceComponent());
  String caller=cdr.getCallingNumber();
  long timestamp=cdr.getAnswerTime().getMillis() / 1000;
  double score=input.getDouble(2);
  String key=String.format(""String_Node_Str"",caller,timestamp);
  if (map.containsKey(key)) {
    Entry e=map.get(key);
    if (e.isFull()) {
      double mainScore=sum(e.getValues(),weights);
      LOG.info(String.format(""String_Node_Str"",mainScore,Arrays.toString(e.getValues())));
      collector.emit(new Values(caller,timestamp,mainScore,cdr));
    }
 else {
      e.set(src,score);
    }
  }
 else {
    Entry e=new Entry(cdr);
    e.set(src,score);
    map.put(key,e);
  }
}","@Override public void execute(Tuple input){
  CallDetailRecord cdr=(CallDetailRecord)input.getValueByField(Field.RECORD);
  Source src=parseComponentId(input.getSourceComponent());
  String caller=cdr.getCallingNumber();
  long timestamp=cdr.getAnswerTime().getMillis() / 1000;
  double score=input.getDouble(2);
  String key=String.format(""String_Node_Str"",caller,timestamp);
  if (map.containsKey(key)) {
    Entry e=map.get(key);
    if (e.isFull()) {
      double mainScore=sum(e.getValues(),weights);
      LOG.debug(String.format(""String_Node_Str"",mainScore,Arrays.toString(e.getValues())));
      collector.emit(new Values(caller,timestamp,mainScore,cdr));
    }
 else {
      e.set(src,score);
    }
  }
 else {
    Entry e=new Entry(cdr);
    e.set(src,score);
    map.put(key,e);
  }
}",0.9943360604153556
133790,"@Override public void execute(Tuple input){
  CallDetailRecord cdr=(CallDetailRecord)input.getValue(3);
  String number=input.getString(0);
  long timestamp=input.getLong(1);
  double rate=input.getDouble(2);
  String key=String.format(""String_Node_Str"",number,timestamp);
  Source src=parseComponentId(input.getSourceComponent());
  if (map.containsKey(key)) {
    Entry e=map.get(key);
    e.set(src,rate);
    if (e.isFull()) {
      double ratio=(e.get(Source.ENCR) / e.get(Source.ECR));
      double score=score(thresholdMin,thresholdMax,ratio);
      LOG.info(String.format(""String_Node_Str"",thresholdMin,thresholdMax,e.get(Source.ENCR),e.get(Source.ECR),ratio,score));
      collector.emit(new Values(number,timestamp,score,cdr));
      map.remove(key);
    }
 else {
      LOG.warn(String.format(""String_Node_Str"",input.getSourceComponent(),e.toString()));
    }
  }
 else {
    Entry e=new Entry(cdr);
    e.set(src,rate);
    map.put(key,e);
  }
}","@Override public void execute(Tuple input){
  CallDetailRecord cdr=(CallDetailRecord)input.getValue(3);
  String number=input.getString(0);
  long timestamp=input.getLong(1);
  double rate=input.getDouble(2);
  String key=String.format(""String_Node_Str"",number,timestamp);
  Source src=parseComponentId(input.getSourceComponent());
  if (map.containsKey(key)) {
    Entry e=map.get(key);
    e.set(src,rate);
    if (e.isFull()) {
      double ratio=(e.get(Source.ENCR) / e.get(Source.ECR));
      double score=score(thresholdMin,thresholdMax,ratio);
      LOG.debug(String.format(""String_Node_Str"",thresholdMin,thresholdMax,e.get(Source.ENCR),e.get(Source.ECR),ratio,score));
      collector.emit(new Values(number,timestamp,score,cdr));
      map.remove(key);
    }
 else {
      LOG.warn(String.format(""String_Node_Str"",input.getSourceComponent(),e.toString()));
    }
  }
 else {
    Entry e=new Entry(cdr);
    e.set(src,rate);
    map.put(key,e);
  }
}",0.9953002610966056
133791,"@Override public void initialize(){
  varDetectThreads=config.getInt(Conf.VAR_DETECT_THREADS,1);
  ecrThreads=config.getInt(Conf.ECR_THREADS,1);
  rcrThreads=config.getInt(Conf.RCR_THREADS,1);
  encrThreads=config.getInt(Conf.ENCR_THREADS,1);
  ecr24Threads=config.getInt(Conf.ECR24_THREADS,1);
  ct24Threads=config.getInt(Conf.CT24_THREADS,1);
  fofirThreads=config.getInt(Conf.FOFIR_THREADS,1);
  urlThreads=config.getInt(Conf.URL_THREADS,1);
  acdThreads=config.getInt(Conf.ACD_THREADS,1);
  scorerThreads=config.getInt(Conf.SCORER_THREADS,1);
}","@Override public void initialize(){
  super.initialize();
  varDetectThreads=config.getInt(Conf.VAR_DETECT_THREADS,1);
  ecrThreads=config.getInt(Conf.ECR_THREADS,1);
  rcrThreads=config.getInt(Conf.RCR_THREADS,1);
  encrThreads=config.getInt(Conf.ENCR_THREADS,1);
  ecr24Threads=config.getInt(Conf.ECR24_THREADS,1);
  ct24Threads=config.getInt(Conf.CT24_THREADS,1);
  fofirThreads=config.getInt(Conf.FOFIR_THREADS,1);
  urlThreads=config.getInt(Conf.URL_THREADS,1);
  acdThreads=config.getInt(Conf.ACD_THREADS,1);
  scorerThreads=config.getInt(Conf.SCORER_THREADS,1);
}",0.9803220035778176
133792,"@Override public void initialize(){
  String shapeFile=config.getString(Conf.MAP_MATCHER_SHAPEFILE);
  latMin=config.getDouble(Conf.MAP_MATCHER_LAT_MIN);
  latMax=config.getDouble(Conf.MAP_MATCHER_LAT_MAX);
  lonMin=config.getDouble(Conf.MAP_MATCHER_LON_MIN);
  lonMax=config.getDouble(Conf.MAP_MATCHER_LON_MAX);
  try {
    sectors=new RoadGridList(shapeFile);
  }
 catch (  SQLException|IOException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override public void initialize(){
  String shapeFile=config.getString(Conf.MAP_MATCHER_SHAPEFILE);
  latMin=config.getDouble(Conf.MAP_MATCHER_LAT_MIN);
  latMax=config.getDouble(Conf.MAP_MATCHER_LAT_MAX);
  lonMin=config.getDouble(Conf.MAP_MATCHER_LON_MIN);
  lonMax=config.getDouble(Conf.MAP_MATCHER_LON_MAX);
  try {
    sectors=new RoadGridList(config,shapeFile);
  }
 catch (  SQLException|IOException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.99304865938431
133793,"@Override public void execute(Tuple input){
  try {
    int speed=input.getIntegerByField(Field.SPEED);
    int bearing=input.getIntegerByField(Field.BEARING);
    double latitude=input.getDoubleByField(Field.LATITUDE);
    double longitude=input.getDoubleByField(Field.LONGITUDE);
    if (speed <= 0)     return;
    if (longitude > lonMin || longitude < lonMax || latitude > latMin || latitude < latMax)     return;
    GPSRecord record=new GPSRecord(longitude,latitude,speed,bearing);
    int roadID=sectors.fetchRoadID(record);
    if (roadID != -1) {
      List<Object> values=input.getValues();
      values.add(roadID);
      collector.emit(values);
    }
    collector.ack(input);
  }
 catch (  SQLException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}","@Override public void execute(Tuple input){
  try {
    int speed=input.getIntegerByField(Field.SPEED);
    int bearing=input.getIntegerByField(Field.BEARING);
    double latitude=input.getDoubleByField(Field.LATITUDE);
    double longitude=input.getDoubleByField(Field.LONGITUDE);
    if (speed <= 0)     return;
    if (longitude > lonMax || longitude < lonMin || latitude > latMax || latitude < latMin)     return;
    GPSRecord record=new GPSRecord(longitude,latitude,speed,bearing);
    int roadID=sectors.fetchRoadID(record);
    if (roadID != -1) {
      List<Object> values=input.getValues();
      values.add(roadID);
      collector.emit(values);
    }
    collector.ack(input);
  }
 catch (  SQLException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}",0.9895287958115184
133794,"/** 
 * Opens the next file from the index. If there's multiple instances of the spout, it will read only a portion of the files.
 */
protected void openNextFile(){
  while (++curFileIndex % numTasks != taskId) {
  }
  if (curFileIndex < files.length) {
    try {
      File file=files[curFileIndex];
      scanner=new Scanner(file);
      curLineIndex=0;
      LOG.info(""String_Node_Str"",file.getName(),FileUtils.humanReadableByteCount(file.length()));
    }
 catch (    FileNotFoundException ex) {
      LOG.error(String.format(""String_Node_Str"",files[curFileIndex]),ex);
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
}","/** 
 * Opens the next file from the index. If there's multiple instances of the spout, it will read only a portion of the files.
 */
protected void openNextFile(){
  while ((curFileIndex + 1) % numTasks != taskId) {
    curFileIndex++;
  }
  if (curFileIndex < files.length) {
    try {
      File file=files[curFileIndex];
      scanner=new Scanner(file);
      curLineIndex=0;
      LOG.info(""String_Node_Str"",file.getName(),FileUtils.humanReadableByteCount(file.length()));
    }
 catch (    FileNotFoundException ex) {
      LOG.error(String.format(""String_Node_Str"",files[curFileIndex]),ex);
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
}",0.9270516717325228
133795,"@Override public final void execute(Tuple tuple){
  if (TupleUtils.isTickTuple(tuple)) {
    getLogger().debug(""String_Node_Str"");
    emitRankings();
  }
 else {
    updateRankingsWithTuple(tuple);
  }
}","@Override public final void execute(Tuple tuple){
  if (TupleUtils.isTickTuple(tuple)) {
    getLogger().info(""String_Node_Str"");
    emitRankings();
  }
 else {
    updateRankingsWithTuple(tuple);
  }
}",0.977886977886978
133796,"@Override public void execute(Tuple tuple){
  if (TupleUtils.isTickTuple(tuple)) {
    LOG.debug(""String_Node_Str"");
    emitCurrentWindowCounts();
  }
 else {
    countObjAndAck(tuple);
  }
}","@Override public void execute(Tuple tuple){
  if (TupleUtils.isTickTuple(tuple)) {
    LOG.info(""String_Node_Str"");
    emitCurrentWindowCounts();
  }
 else {
    countObjAndAck(tuple);
  }
}",0.9765013054830288
133797,"@Override public void initialize(){
  super.initialize();
  topicExtractorThreads=config.getInt(Conf.TOPIC_EXTRACTOR_THREADS,1);
  counterThreads=config.getInt(Conf.COUNTER_THREADS,1);
  iRankerThreads=config.getInt(Conf.IRANKER_THREADS,1);
  tRankerThreads=config.getInt(Conf.IRANKER_THREADS,1);
}","@Override public void initialize(){
  super.initialize();
  topicExtractorThreads=config.getInt(Conf.TOPIC_EXTRACTOR_THREADS,1);
  counterThreads=config.getInt(Conf.COUNTER_THREADS,1);
  iRankerThreads=config.getInt(Conf.IRANKER_THREADS,1);
  tRankerThreads=config.getInt(Conf.IRANKER_THREADS,1);
  topn=config.getInt(Conf.TOPN,10);
}",0.9430379746835444
133798,"public static void progressAllCleanup(){
  for (  TempBlock block : FROZEN_BLOCKS.keySet()) {
    Player player=FROZEN_BLOCKS.get(block);
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null) {
      return;
    }
 else     if (block.getBlock().getType() != Material.ICE) {
      FROZEN_BLOCKS.remove(block);
      continue;
    }
 else     if (!player.isOnline()) {
      thaw(block);
      continue;
    }
 else     if (block.getBlock().getWorld() != player.getWorld()) {
      thaw(block);
      continue;
    }
 else     if (block.getLocation().distanceSquared(player.getLocation()) > CLEANUP_RANGE * CLEANUP_RANGE || !bPlayer.canBendIgnoreBindsCooldowns(getAbility(""String_Node_Str""))) {
      thaw(block);
    }
  }
}","public static void progressAllCleanup(){
  for (  TempBlock block : FROZEN_BLOCKS.keySet()) {
    Player player=FROZEN_BLOCKS.get(block);
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null) {
      FROZEN_BLOCKS.remove(block);
      continue;
    }
 else     if (block.getBlock().getType() != Material.ICE) {
      FROZEN_BLOCKS.remove(block);
      continue;
    }
 else     if (!player.isOnline()) {
      thaw(block);
      continue;
    }
 else     if (block.getBlock().getWorld() != player.getWorld()) {
      thaw(block);
      continue;
    }
 else     if (block.getLocation().distanceSquared(player.getLocation()) > CLEANUP_RANGE * CLEANUP_RANGE || !bPlayer.canBendIgnoreBindsCooldowns(getAbility(""String_Node_Str""))) {
      thaw(block);
    }
  }
}",0.9698137443802184
133799,"public void revertFrozenBlocks(){
  if (active_types.contains(PhaseChangeType.FREEZE)) {
    for (    TempBlock tb : blocks) {
      tb.revertBlock();
    }
    blocks.clear();
    PLAYER_BY_BLOCK.remove(player);
  }
}","public void revertFrozenBlocks(){
  if (active_types.contains(PhaseChangeType.FREEZE)) {
    for (    TempBlock tb : blocks) {
      PLAYER_BY_BLOCK.remove(tb);
      tb.revertBlock();
    }
    blocks.clear();
  }
}",0.7557603686635944
133800,"public static void sendBrandingMessage(CommandSender sender,String message){
  ChatColor color=ChatColor.valueOf(ConfigManager.languageConfig.get().getString(""String_Node_Str"").toUpperCase());
  color=color == null ? ChatColor.GOLD : color;
  String prefix=ChatColor.translateAlternateColorCodes('&',ConfigManager.languageConfig.get().getString(""String_Node_Str"")) + color + ""String_Node_Str""+ ChatColor.translateAlternateColorCodes('&',ConfigManager.languageConfig.get().getString(""String_Node_Str""));
  if (!(sender instanceof Player)) {
    sender.sendMessage(prefix + message);
  }
 else {
    TextComponent prefixComponent=new TextComponent(prefix);
    TextComponent messageComponent=new TextComponent(message);
    prefixComponent.setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL,""String_Node_Str""));
    prefixComponent.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT,new ComponentBuilder(color + ""String_Node_Str"" + color+ ""String_Node_Str"").create()));
    ((Player)sender).spigot().sendMessage(new TextComponent(prefixComponent,messageComponent));
  }
}","public static void sendBrandingMessage(CommandSender sender,String message){
  ChatColor color=ChatColor.valueOf(ConfigManager.languageConfig.get().getString(""String_Node_Str"").toUpperCase());
  color=color == null ? ChatColor.GOLD : color;
  String prefix=ChatColor.translateAlternateColorCodes('&',ConfigManager.languageConfig.get().getString(""String_Node_Str"")) + color + ""String_Node_Str""+ ChatColor.translateAlternateColorCodes('&',ConfigManager.languageConfig.get().getString(""String_Node_Str""));
  if (!(sender instanceof Player)) {
    sender.sendMessage(prefix + message);
  }
 else {
    TextComponent prefixComponent=new TextComponent(prefix);
    prefixComponent.setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL,""String_Node_Str""));
    prefixComponent.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT,new ComponentBuilder(color + ""String_Node_Str"" + color+ ""String_Node_Str"").create()));
    String lastColor=""String_Node_Str"";
    String newMessage=""String_Node_Str"";
    for (int i=0; i < message.split(""String_Node_Str"").length; i++) {
      String c=message.split(""String_Node_Str"")[i];
      if (c.equalsIgnoreCase(""String_Node_Str"")) {
        lastColor=""String_Node_Str"" + message.split(""String_Node_Str"")[i + 1];
        newMessage=newMessage + c;
      }
 else       if (c.equalsIgnoreCase(""String_Node_Str"")) {
        newMessage=newMessage + ""String_Node_Str"" + lastColor;
      }
 else {
        newMessage=newMessage + c;
      }
    }
    TextComponent messageComponent=new TextComponent(newMessage);
    ((Player)sender).spigot().sendMessage(new TextComponent(prefixComponent,messageComponent));
  }
}",0.7466960352422908
133801,"/** 
 * Removes this ability instance instantly. This method does not cause any block animation, it just removes everything.
 */
@Override public void remove(){
  super.remove();
  for (int i=affectedBlocks.size() - 1; i > -1; i--) {
    final TempBlock tblock=affectedBlocks.get(i);
    tblock.revertBlock();
    if (TEMP_LAVA_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAVA_BLOCKS.remove(TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.get(tblock));
      TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.remove(tblock);
    }
    if (TEMP_LAND_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAND_BLOCKS.remove(tblock);
    }
  }
  for (  BukkitRunnable task : tasks) {
    task.cancel();
  }
}","/** 
 * Removes this ability instance instantly. This method does not cause any block animation, it just removes everything.
 */
@Override public void remove(){
  super.remove();
  for (int i=affectedBlocks.size() - 1; i > -1; i--) {
    final TempBlock tblock=affectedBlocks.get(i);
    tblock.revertBlock();
    if (TEMP_LAVA_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAVA_BLOCKS.remove(TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.get(tblock));
      TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.remove(tblock);
    }
    if (TEMP_LAND_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAND_BLOCKS.remove(TEMP_LAND_BLOCKS_BY_TEMPBLOCK.get(tblock));
      TEMP_LAND_BLOCKS_BY_TEMPBLOCK.remove(tblock);
    }
  }
  for (  BukkitRunnable task : tasks) {
    task.cancel();
  }
}",0.9442664958360024
133802,"/** 
 * Removes this instance of LavaFlow, cleans up any blocks that are remaining in TEMP_LAVA_BLOCKS, and cancels any remaining tasks. This version of remove will create tasks that remove each lava block with an animation.
 */
public void removeSlowly(){
  super.remove();
  for (int i=affectedBlocks.size() - 1; i > -1; i--) {
    final TempBlock tblock=affectedBlocks.get(i);
    final boolean isTempAir=TEMP_AIR_BLOCKS.values().contains(tblock);
    new BukkitRunnable(){
      @SuppressWarnings(""String_Node_Str"") @Override public void run(){
        tblock.revertBlock();
        if (isTempAir && tblock.getState().getType() == Material.DOUBLE_PLANT) {
          tblock.getBlock().getRelative(BlockFace.UP).setType(Material.DOUBLE_PLANT);
          tblock.getBlock().getRelative(BlockFace.UP).setData((byte)(tblock.getState().getRawData() + 8));
        }
      }
    }
.runTaskLater(ProjectKorra.plugin,(long)(i / shiftRemoveSpeed));
    if (TEMP_LAVA_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAVA_BLOCKS.remove(TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.get(tblock));
      TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.remove(tblock);
    }
    if (TEMP_LAND_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAND_BLOCKS.remove(tblock);
    }
    if (TEMP_AIR_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_AIR_BLOCKS.remove(tblock);
    }
  }
  for (  BukkitRunnable task : tasks) {
    task.cancel();
  }
}","/** 
 * Removes this instance of LavaFlow, cleans up any blocks that are remaining in TEMP_LAVA_BLOCKS, and cancels any remaining tasks. This version of remove will create tasks that remove each lava block with an animation.
 */
public void removeSlowly(){
  super.remove();
  for (int i=affectedBlocks.size() - 1; i > -1; i--) {
    final TempBlock tblock=affectedBlocks.get(i);
    final boolean isTempAir=TEMP_AIR_BLOCKS.values().contains(tblock);
    new BukkitRunnable(){
      @SuppressWarnings(""String_Node_Str"") @Override public void run(){
        tblock.revertBlock();
        if (isTempAir && tblock.getState().getType() == Material.DOUBLE_PLANT) {
          tblock.getBlock().getRelative(BlockFace.UP).setType(Material.DOUBLE_PLANT);
          tblock.getBlock().getRelative(BlockFace.UP).setData((byte)(tblock.getState().getRawData() + 8));
        }
      }
    }
.runTaskLater(ProjectKorra.plugin,(long)(i / shiftRemoveSpeed));
    if (TEMP_LAVA_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAVA_BLOCKS.remove(TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.get(tblock));
      TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.remove(tblock);
    }
    if (TEMP_LAND_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_LAND_BLOCKS.remove(TEMP_LAND_BLOCKS_BY_TEMPBLOCK.get(tblock));
      TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.remove(tblock);
    }
    if (TEMP_AIR_BLOCKS.values().contains(tblock)) {
      affectedBlocks.remove(tblock);
      TEMP_AIR_BLOCKS.remove(TEMP_AIR_BLOCKS_BY_TEMPBLOCK.get(tblock));
      TEMP_AIR_BLOCKS_BY_TEMPBLOCK.remove(tblock);
    }
  }
  for (  BukkitRunnable task : tasks) {
    task.cancel();
  }
}",0.94587791063562
133803,"/** 
 * Creates a LavaBlock and appends the TempBlock to our arraylist called TEMP_LAVA_BLOCKS. If ALLOW_NATURAL_FLOW is turned on then this method will remove the block from TempBlock.instances, which will allow the lava to flow naturally.
 * @param block the block that will be turned to lava
 */
public void createLava(Block block){
  if (isEarth(block) || isSand(block) || isMetal(block)) {
    if (isPlant(block.getRelative(BlockFace.UP)) || isSnow(block.getRelative(BlockFace.UP))) {
      Block above=block.getRelative(BlockFace.UP);
      Block above2=above.getRelative(BlockFace.UP);
      if (isPlant(above) || isSnow(above)) {
        TempBlock tb=new TempBlock(above,Material.AIR,(byte)0);
        TEMP_AIR_BLOCKS.put(above,tb);
        affectedBlocks.add(tb);
        if (isPlant(above2) && above2.getType().equals(Material.DOUBLE_PLANT)) {
          TempBlock tb2=new TempBlock(above2,Material.AIR,(byte)0);
          TEMP_AIR_BLOCKS.put(above2,tb2);
          affectedBlocks.add(tb);
        }
      }
 else       return;
    }
    TempBlock tblock=new TempBlock(block,Material.LAVA,(byte)0);
    TEMP_LAVA_BLOCKS.put(block,tblock);
    TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.put(tblock,block);
    affectedBlocks.add(tblock);
    if (allowNaturalFlow) {
      TempBlock.removeBlock(block);
    }
  }
}","/** 
 * Creates a LavaBlock and appends the TempBlock to our arraylist called TEMP_LAVA_BLOCKS. If ALLOW_NATURAL_FLOW is turned on then this method will remove the block from TempBlock.instances, which will allow the lava to flow naturally.
 * @param block the block that will be turned to lava
 */
public void createLava(Block block){
  if (isEarth(block) || isSand(block) || isMetal(block)) {
    if (isPlant(block.getRelative(BlockFace.UP)) || isSnow(block.getRelative(BlockFace.UP))) {
      Block above=block.getRelative(BlockFace.UP);
      Block above2=above.getRelative(BlockFace.UP);
      if (isPlant(above) || isSnow(above)) {
        TempBlock tb=new TempBlock(above,Material.AIR,(byte)0);
        TEMP_AIR_BLOCKS.put(above,tb);
        TEMP_AIR_BLOCKS_BY_TEMPBLOCK.put(tb,above);
        affectedBlocks.add(tb);
        if (isPlant(above2) && above2.getType().equals(Material.DOUBLE_PLANT)) {
          TempBlock tb2=new TempBlock(above2,Material.AIR,(byte)0);
          TEMP_AIR_BLOCKS.put(above2,tb2);
          TEMP_AIR_BLOCKS_BY_TEMPBLOCK.put(tb2,above2);
          affectedBlocks.add(tb);
        }
      }
 else       return;
    }
    TempBlock tblock=new TempBlock(block,Material.LAVA,(byte)0);
    TEMP_LAVA_BLOCKS.put(block,tblock);
    TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.put(tblock,block);
    affectedBlocks.add(tblock);
    if (allowNaturalFlow) {
      TempBlock.removeBlock(block);
    }
  }
}",0.7011747430249633
133804,"/** 
 * Removes a lava block if it is inside of our ArrayList of TempBlocks.
 * @param testBlock the block to attempt to remove
 */
@SuppressWarnings(""String_Node_Str"") public void removeLava(Block testBlock){
  if (TEMP_LAVA_BLOCKS.containsKey(testBlock)) {
    TempBlock tb=TEMP_LAVA_BLOCKS.get(testBlock);
    tb.revertBlock();
    TEMP_LAVA_BLOCKS.remove(testBlock);
    TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.remove(tb);
    affectedBlocks.remove(tb);
    return;
  }
  TempBlock tblock=new TempBlock(testBlock,revertMaterial,testBlock.getData());
  affectedBlocks.add(tblock);
  TEMP_LAND_BLOCKS.put(testBlock,tblock);
}","/** 
 * Removes a lava block if it is inside of our ArrayList of TempBlocks.
 * @param testBlock the block to attempt to remove
 */
@SuppressWarnings(""String_Node_Str"") public void removeLava(Block testBlock){
  if (TEMP_LAVA_BLOCKS.containsKey(testBlock)) {
    TempBlock tb=TEMP_LAVA_BLOCKS.get(testBlock);
    tb.revertBlock();
    TEMP_LAVA_BLOCKS.remove(testBlock);
    TEMP_LAVA_BLOCKS_BY_TEMPBLOCK.remove(tb);
    affectedBlocks.remove(tb);
    return;
  }
  TempBlock tblock=new TempBlock(testBlock,revertMaterial,testBlock.getData());
  affectedBlocks.add(tblock);
  TEMP_LAND_BLOCKS.put(testBlock,tblock);
  TEMP_LAND_BLOCKS_BY_TEMPBLOCK.put(tblock,testBlock);
}",0.9573312645461598
133805,"@Override public void progress(){
  groundBlock=getGround();
  if (groundBlock == null) {
    remove();
    return;
  }
  bPlayer.addCooldown(this);
  dir=dir.clone().normalize().multiply(1.5);
  dir.setY(0);
  double distance=loc.getY() - (double)groundBlock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 1.75) {
    dir.setY(-.50 * dx * dx);
  }
 else   if (distance < 1) {
    dir.setY(.50 * dx * dx);
  }
 else {
    dir.setY(0);
  }
  loc.add(dir);
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,blockByte),1F,0.1F,1F,0.1F,100,loc.add(0,-1,0),500);
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!player.isSneaking()) {
    remove();
    return;
  }
  if (loc.getWorld().equals(startLoc.getWorld()) && loc.distance(startLoc) >= selectRange) {
    remove();
    return;
  }
  for (  Entity e : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
    if (e.getEntityId() != player.getEntityId() && e instanceof LivingEntity) {
      closestEntity=e;
      formDome();
      remove();
      return;
    }
  }
  if (random.nextInt(2) == 0) {
    playEarthbendingSound(loc);
  }
}","@Override public void progress(){
  groundBlock=getGround();
  if (groundBlock == null) {
    remove();
    return;
  }
  bPlayer.addCooldown(this);
  dir=dir.clone().normalize().multiply(1.5);
  dir.setY(0);
  double distance=loc.getY() - (double)groundBlock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 1.75) {
    dir.setY(-.50 * dx * dx);
  }
 else   if (distance < 1) {
    dir.setY(.50 * dx * dx);
  }
 else {
    dir.setY(0);
  }
  loc.add(dir);
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!player.isSneaking()) {
    remove();
    return;
  }
  if (loc.getWorld().equals(startLoc.getWorld()) && loc.distance(startLoc) >= selectRange) {
    remove();
    return;
  }
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,blockByte),1F,0.1F,1F,0.1F,100,loc.add(0,-1,0),500);
  for (  Entity e : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
    if (e.getEntityId() != player.getEntityId() && e instanceof LivingEntity) {
      closestEntity=e;
      formDome();
      remove();
      return;
    }
  }
  if (random.nextInt(2) == 0) {
    playEarthbendingSound(loc);
  }
}",0.6913372582001682
133806,"/** 
 * Adds the ability to bend the given element to the specified Player.
 * @param sender The CommandSender who issued the command
 * @param target The Player to add the element to
 * @param element The element to add to the Player
 */
private void add(CommandSender sender,Player target,Element element){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(target);
  if (bPlayer == null) {
    return;
  }
  if (element instanceof SubElement) {
    SubElement sub=(SubElement)element;
    bPlayer.addSubElement(sub);
    ChatColor color=sub != null ? sub.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      sender.sendMessage(color + chosenOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
 else {
      target.sendMessage(color + chosenCFW.replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,target,sub,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.CHOOSE));
  }
 else {
    bPlayer.addElement(element);
    bPlayer.getSubElements().clear();
    for (    SubElement sub : Element.getAllSubElements()) {
      if (bPlayer.hasElement(sub.getParentElement()) && bPlayer.hasSubElementPermission(sub)) {
        bPlayer.addSubElement(sub);
      }
    }
    ChatColor color=element != null ? element.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      if (element != Element.AIR && element != Element.EARTH)       sender.sendMessage(color + chosenOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
 else       sender.sendMessage(color + chosenOtherAE.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
 else {
      if (element != Element.AIR && element != Element.EARTH)       target.sendMessage(color + chosenCFW.replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
 else       target.sendMessage(color + chosenAE.replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,target,element,Result.CHOOSE));
  }
  GeneralMethods.removeUnusableAbilities(target.getName());
}","/** 
 * Adds the ability to bend the given element to the specified Player.
 * @param sender The CommandSender who issued the command
 * @param target The Player to add the element to
 * @param element The element to add to the Player
 */
private void add(CommandSender sender,Player target,Element element){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(target);
  if (bPlayer == null) {
    return;
  }
  if (element instanceof SubElement) {
    SubElement sub=(SubElement)element;
    bPlayer.addSubElement(sub);
    ChatColor color=sub != null ? sub.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      sender.sendMessage(color + chosenOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
 else {
      target.sendMessage(color + chosenCFW.replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,target,sub,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.CHOOSE));
  }
 else {
    bPlayer.setElement(element);
    bPlayer.getSubElements().clear();
    for (    SubElement sub : Element.getAllSubElements()) {
      if (bPlayer.hasElement(sub.getParentElement()) && bPlayer.hasSubElementPermission(sub)) {
        bPlayer.addSubElement(sub);
      }
    }
    ChatColor color=element != null ? element.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      if (element != Element.AIR && element != Element.EARTH)       sender.sendMessage(color + chosenOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
 else       sender.sendMessage(color + chosenOtherAE.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
 else {
      if (element != Element.AIR && element != Element.EARTH)       target.sendMessage(color + chosenCFW.replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
 else       target.sendMessage(color + chosenAE.replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,target,element,Result.CHOOSE));
  }
  GeneralMethods.removeUnusableAbilities(target.getName());
}",0.9989035087719298
133807,"public static boolean isWeapon(Material mat){
  return mat != null && (mat == Material.WOOD_AXE || mat == Material.WOOD_PICKAXE || mat == Material.WOOD_SPADE || mat == Material.WOOD_SWORD || mat == Material.STONE_AXE || mat == Material.STONE_PICKAXE || mat == Material.STONE_SPADE || mat == Material.STONE_SWORD || mat == Material.IRON_AXE || mat == Material.IRON_PICKAXE || mat == Material.IRON_SWORD || mat == Material.IRON_SPADE || mat == Material.DIAMOND_AXE || mat == Material.DIAMOND_PICKAXE || mat == Material.DIAMOND_SWORD || mat == Material.DIAMOND_SPADE);
}","public static boolean isWeapon(Material mat){
  return mat != null && (mat == Material.WOOD_AXE || mat == Material.WOOD_PICKAXE || mat == Material.WOOD_SPADE || mat == Material.WOOD_SWORD || mat == Material.STONE_AXE || mat == Material.STONE_PICKAXE || mat == Material.STONE_SPADE || mat == Material.STONE_SWORD || mat == Material.IRON_AXE || mat == Material.IRON_PICKAXE || mat == Material.IRON_SWORD || mat == Material.IRON_SPADE || mat == Material.DIAMOND_AXE || mat == Material.DIAMOND_PICKAXE || mat == Material.DIAMOND_SWORD || mat == Material.DIAMOND_SPADE || mat == Material.GOLD_AXE || mat == Material.GOLD_HOE || mat == Material.GOLD_SWORD || mat == Material.GOLD_PICKAXE || mat == Material.GOLD_SPADE);
}",0.8845553822152886
133808,"@EventHandler public void onPlayerDamageByPlayer(EntityDamageByEntityEvent e){
  if (e.isCancelled()) {
    return;
  }
  Entity source=e.getDamager();
  Entity entity=e.getEntity();
  FireBlastCharged fireball=FireBlastCharged.getFireball(source);
  if (fireball != null) {
    e.setCancelled(true);
    fireball.dealDamage(entity);
    return;
  }
  if (Paralyze.isParalyzed(e.getDamager()) || ChiCombo.isParalyzed(e.getDamager())) {
    e.setCancelled(true);
    return;
  }
  if (entity instanceof Player) {
    Suffocate.remove((Player)entity);
  }
  Entity en=e.getEntity();
  if (en instanceof Player) {
    if (e.getDamager() instanceof Player) {
      Player sourcePlayer=(Player)e.getDamager();
      Player targetPlayer=(Player)e.getEntity();
      BendingPlayer sourceBPlayer=BendingPlayer.getBendingPlayer(sourcePlayer);
      if (sourceBPlayer == null) {
        return;
      }
      String boundAbil=sourceBPlayer.getBoundAbilityName();
      if (sourceBPlayer.canBendPassive(Element.CHI)) {
        if (e.getCause() == DamageCause.ENTITY_ATTACK && e.getDamage() == 1) {
          if (sourceBPlayer.getBoundAbility() instanceof ChiAbility) {
            if (GeneralMethods.isWeapon(sourcePlayer.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
              return;
            }
            if (sourceBPlayer.isElementToggled(Element.CHI) == true) {
              if (boundAbil.equalsIgnoreCase(""String_Node_Str"")) {
                new Paralyze(sourcePlayer,targetPlayer);
              }
 else {
                if (ChiPassive.willChiBlock(sourcePlayer,targetPlayer)) {
                  ChiPassive.blockChi(targetPlayer);
                }
              }
            }
          }
        }
      }
      if (sourceBPlayer.canBendPassive(Element.CHI)) {
        if (GeneralMethods.isWeapon(sourcePlayer.getInventory().getItemInMainHand().getType()) && !ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"")) {
          return;
        }
        if (e.getCause() == DamageCause.ENTITY_ATTACK && sourceBPlayer.isElementToggled(Element.CHI) == true) {
          if (boundAbil.equalsIgnoreCase(""String_Node_Str"") && e.getDamage() == 1) {
            if (sourcePlayer.getWorld().equals(targetPlayer.getWorld()) && Math.abs(sourcePlayer.getLocation().distance(targetPlayer.getLocation())) < 3) {
              new Paralyze(sourcePlayer,targetPlayer);
            }
          }
        }
      }
    }
  }
}","@EventHandler public void onPlayerDamageByPlayer(EntityDamageByEntityEvent e){
  if (e.isCancelled()) {
    return;
  }
  Entity source=e.getDamager();
  Entity entity=e.getEntity();
  FireBlastCharged fireball=FireBlastCharged.getFireball(source);
  if (fireball != null) {
    e.setCancelled(true);
    fireball.dealDamage(entity);
    return;
  }
  if (Paralyze.isParalyzed(e.getDamager()) || ChiCombo.isParalyzed(e.getDamager())) {
    e.setCancelled(true);
    return;
  }
  if (entity instanceof Player) {
    Suffocate.remove((Player)entity);
  }
  Entity en=e.getEntity();
  if (en instanceof Player) {
    if (e.getDamager() instanceof Player) {
      Player sourcePlayer=(Player)e.getDamager();
      Player targetPlayer=(Player)e.getEntity();
      BendingPlayer sourceBPlayer=BendingPlayer.getBendingPlayer(sourcePlayer);
      if (sourceBPlayer == null) {
        return;
      }
      String boundAbil=sourceBPlayer.getBoundAbilityName();
      if (sourceBPlayer.canBendPassive(Element.CHI)) {
        if (e.getCause() == DamageCause.ENTITY_ATTACK && e.getDamage() == 1) {
          if (sourceBPlayer.getBoundAbility() instanceof ChiAbility) {
            if (GeneralMethods.isWeapon(sourcePlayer.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
              return;
            }
            if (sourceBPlayer.isElementToggled(Element.CHI) == true) {
              if (boundAbil.equalsIgnoreCase(""String_Node_Str"")) {
                new Paralyze(sourcePlayer,targetPlayer);
              }
 else               if (boundAbil.equalsIgnoreCase(""String_Node_Str"")) {
                new QuickStrike(sourcePlayer,targetPlayer);
              }
 else               if (boundAbil.equalsIgnoreCase(""String_Node_Str"")) {
                new SwiftKick(sourcePlayer,targetPlayer);
              }
 else               if (boundAbil.equalsIgnoreCase(""String_Node_Str"")) {
                new RapidPunch(sourcePlayer,targetPlayer);
              }
 else {
                if (ChiPassive.willChiBlock(sourcePlayer,targetPlayer)) {
                  ChiPassive.blockChi(targetPlayer);
                }
              }
            }
          }
        }
      }
      if (sourceBPlayer.canBendPassive(Element.CHI)) {
        if (GeneralMethods.isWeapon(sourcePlayer.getInventory().getItemInMainHand().getType()) && !ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"")) {
          return;
        }
        if (e.getCause() == DamageCause.ENTITY_ATTACK && sourceBPlayer.isElementToggled(Element.CHI) == true) {
          if (boundAbil.equalsIgnoreCase(""String_Node_Str"") && e.getDamage() == 1) {
            if (sourcePlayer.getWorld().equals(targetPlayer.getWorld()) && Math.abs(sourcePlayer.getLocation().distance(targetPlayer.getLocation())) < 3) {
              new Paralyze(sourcePlayer,targetPlayer);
            }
          }
        }
      }
    }
  }
}",0.9179297597042514
133809,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerSwing(PlayerAnimationEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
 else   if (RIGHT_CLICK_INTERACT.contains(player.getUniqueId())) {
    return;
  }
  Entity target=GeneralMethods.getTargetedEntity(player,3);
  if (target != null && !(target.equals(player)) && target instanceof LivingEntity) {
    ComboManager.addComboAbility(player,ClickType.LEFT_CLICK_ENTITY);
  }
 else {
    ComboManager.addComboAbility(player,ClickType.LEFT_CLICK);
  }
  if (Suffocate.isBreathbent(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (Bloodbending.isBloodbent(player) || Paralyze.isParalyzed(player) || ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (bPlayer.isChiBlocked()) {
    event.setCancelled(true);
    return;
  }
 else   if (GeneralMethods.isInteractable(player.getTargetBlock((Set<Material>)null,5))) {
    event.setCancelled(true);
    return;
  }
 else   if (player.getInventory().getItemInMainHand().getType() == Material.FISHING_ROD) {
    return;
  }
  BlockSource.update(player,ClickType.LEFT_CLICK);
  AirScooter.check(player);
  String abil=bPlayer.getBoundAbilityName();
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  if (coreAbil == null && !MultiAbilityManager.hasMultiAbilityBound(player)) {
    return;
  }
 else   if (bPlayer.canBendIgnoreCooldowns(coreAbil)) {
    if (coreAbil instanceof AddonAbility) {
      return;
    }
    if (coreAbil instanceof AirAbility && bPlayer.isElementToggled(Element.AIR) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSuction(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirBurst.coneBurst(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirScooter(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSpout(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSwipe(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"") || !bPlayer.canUseFlight()) {
          return;
        }
        if (AirFlight.isFlying(event.getPlayer())) {
          if (AirFlight.isHovering(event.getPlayer())) {
            AirFlight.setHovering(event.getPlayer(),false);
          }
 else {
            AirFlight.setHovering(event.getPlayer(),true);
          }
        }
      }
    }
    if (coreAbil instanceof WaterAbility && bPlayer.isElementToggled(Element.WATER) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Bloodbending.launch(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceBlast.activate(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceSpikeBlast.activate(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new OctopusForm(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!CoreAbility.hasAbility(player,PhaseChange.class)) {
          new PhaseChange(player,PhaseChangeType.FREEZE);
        }
 else {
          PhaseChange pc=CoreAbility.getAbility(player,PhaseChange.class);
          pc.startNewType(PhaseChangeType.FREEZE);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new PlantArmor(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterSpout(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        WaterManipulation.moveWater(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SurgeWall(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Torrent(player);
      }
    }
    if (coreAbil instanceof EarthAbility && bPlayer.isElementToggled(Element.EARTH) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Catapult(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        EarthBlast.throwEarth(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RaiseEarth(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Collapse(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Shockwave.coneShockwave(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        EarthArmor armor=CoreAbility.getAbility(player,EarthArmor.class);
        if (armor != null && armor.isFormed()) {
          armor.click();
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthGrab(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Tremorsense(player,true);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        MetalClips clips=CoreAbility.getAbility(player,MetalClips.class);
        if (clips == null) {
          new MetalClips(player,0);
        }
 else         if (clips.getMetalClipsCount() < (player.hasPermission(""String_Node_Str"") ? 4 : 3)) {
          clips.shootMetal();
        }
 else         if (clips.getMetalClipsCount() == 4 && clips.isCanUse4Clips()) {
          clips.crush();
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        LavaSurge surge=CoreAbility.getAbility(player,LavaSurge.class);
        if (surge != null) {
          surge.launch();
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new LavaFlow(player,AbilityType.CLICK);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthSmash(player,ClickType.LEFT_CLICK);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SandSpout(player);
      }
    }
    if (coreAbil instanceof FireAbility && bPlayer.isElementToggled(Element.FIRE) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Blaze(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireJet(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HeatControl(player,HeatControlType.MELT);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (ConfigManager.defaultConfig.get().getBoolean(""String_Node_Str"")) {
          bPlayer.toggleIllumination();
        }
 else {
          new Illumination(player);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        FireBurst.coneBurst(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireShield(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WallOfFire(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Combustion.explode(player);
      }
    }
    if (coreAbil instanceof ChiAbility && bPlayer.isElementToggled(Element.CHI) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HighJump(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RapidPunch(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Smokescreen(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WarriorStance(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AcrobatStance(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new QuickStrike(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SwiftKick(player);
      }
    }
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new AvatarState(player);
    }
  }
  if (MultiAbilityManager.hasMultiAbilityBound(player)) {
    abil=MultiAbilityManager.getBoundMultiAbility(player);
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new WaterArms(player);
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerSwing(PlayerAnimationEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
 else   if (RIGHT_CLICK_INTERACT.contains(player.getUniqueId())) {
    return;
  }
  Entity target=GeneralMethods.getTargetedEntity(player,3);
  if (target != null && !(target.equals(player)) && target instanceof LivingEntity) {
    ComboManager.addComboAbility(player,ClickType.LEFT_CLICK_ENTITY);
  }
 else {
    ComboManager.addComboAbility(player,ClickType.LEFT_CLICK);
  }
  if (Suffocate.isBreathbent(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (Bloodbending.isBloodbent(player) || Paralyze.isParalyzed(player) || ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (bPlayer.isChiBlocked()) {
    event.setCancelled(true);
    return;
  }
 else   if (GeneralMethods.isInteractable(player.getTargetBlock((Set<Material>)null,5))) {
    event.setCancelled(true);
    return;
  }
 else   if (player.getInventory().getItemInMainHand().getType() == Material.FISHING_ROD) {
    return;
  }
  BlockSource.update(player,ClickType.LEFT_CLICK);
  AirScooter.check(player);
  String abil=bPlayer.getBoundAbilityName();
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  if (coreAbil == null && !MultiAbilityManager.hasMultiAbilityBound(player)) {
    return;
  }
 else   if (bPlayer.canBendIgnoreCooldowns(coreAbil)) {
    if (coreAbil instanceof AddonAbility) {
      return;
    }
    if (coreAbil instanceof AirAbility && bPlayer.isElementToggled(Element.AIR) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSuction(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirBurst.coneBurst(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirScooter(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSpout(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSwipe(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"") || !bPlayer.canUseFlight()) {
          return;
        }
        if (AirFlight.isFlying(event.getPlayer())) {
          if (AirFlight.isHovering(event.getPlayer())) {
            AirFlight.setHovering(event.getPlayer(),false);
          }
 else {
            AirFlight.setHovering(event.getPlayer(),true);
          }
        }
      }
    }
    if (coreAbil instanceof WaterAbility && bPlayer.isElementToggled(Element.WATER) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Bloodbending.launch(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceBlast.activate(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceSpikeBlast.activate(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new OctopusForm(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!CoreAbility.hasAbility(player,PhaseChange.class)) {
          new PhaseChange(player,PhaseChangeType.FREEZE);
        }
 else {
          PhaseChange pc=CoreAbility.getAbility(player,PhaseChange.class);
          pc.startNewType(PhaseChangeType.FREEZE);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new PlantArmor(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterSpout(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        WaterManipulation.moveWater(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SurgeWall(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Torrent(player);
      }
    }
    if (coreAbil instanceof EarthAbility && bPlayer.isElementToggled(Element.EARTH) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Catapult(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        EarthBlast.throwEarth(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RaiseEarth(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Collapse(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Shockwave.coneShockwave(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        EarthArmor armor=CoreAbility.getAbility(player,EarthArmor.class);
        if (armor != null && armor.isFormed()) {
          armor.click();
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthGrab(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Tremorsense(player,true);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        MetalClips clips=CoreAbility.getAbility(player,MetalClips.class);
        if (clips == null) {
          new MetalClips(player,0);
        }
 else         if (clips.getMetalClipsCount() < (player.hasPermission(""String_Node_Str"") ? 4 : 3)) {
          clips.shootMetal();
        }
 else         if (clips.getMetalClipsCount() == 4 && clips.isCanUse4Clips()) {
          clips.crush();
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        LavaSurge surge=CoreAbility.getAbility(player,LavaSurge.class);
        if (surge != null) {
          surge.launch();
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new LavaFlow(player,AbilityType.CLICK);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthSmash(player,ClickType.LEFT_CLICK);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SandSpout(player);
      }
    }
    if (coreAbil instanceof FireAbility && bPlayer.isElementToggled(Element.FIRE) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Blaze(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireJet(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HeatControl(player,HeatControlType.MELT);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (ConfigManager.defaultConfig.get().getBoolean(""String_Node_Str"")) {
          bPlayer.toggleIllumination();
        }
 else {
          new Illumination(player);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        FireBurst.coneBurst(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireShield(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WallOfFire(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Combustion.explode(player);
      }
    }
    if (coreAbil instanceof ChiAbility && bPlayer.isElementToggled(Element.CHI) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HighJump(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Smokescreen(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WarriorStance(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AcrobatStance(player);
      }
    }
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new AvatarState(player);
    }
  }
  if (MultiAbilityManager.hasMultiAbilityBound(player)) {
    abil=MultiAbilityManager.getBoundMultiAbility(player);
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new WaterArms(player);
    }
  }
}",0.9836440955184822
133810,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerSneak(PlayerToggleSneakEvent event){
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (event.isCancelled() || bPlayer == null) {
    return;
  }
  if (player.isSneaking()) {
    ComboManager.addComboAbility(player,ClickType.SHIFT_UP);
  }
 else {
    ComboManager.addComboAbility(player,ClickType.SHIFT_DOWN);
  }
  String abilName=bPlayer.getBoundAbilityName();
  if (Suffocate.isBreathbent(player)) {
    if (!abilName.equalsIgnoreCase(""String_Node_Str"") || !abilName.equalsIgnoreCase(""String_Node_Str"") || !abilName.equalsIgnoreCase(""String_Node_Str"")|| !abilName.equalsIgnoreCase(""String_Node_Str"")) {
      if (!player.isSneaking()) {
        event.setCancelled(true);
      }
    }
  }
  if (Paralyze.isParalyzed(player) || ChiCombo.isParalyzed(player) || Bloodbending.isBloodbent(player)) {
    event.setCancelled(true);
    return;
  }
  if (!player.isSneaking()) {
    BlockSource.update(player,ClickType.SHIFT_DOWN);
  }
  AirScooter.check(player);
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  String abil=bPlayer.getBoundAbilityName();
  if (coreAbil == null) {
    return;
  }
  if (bPlayer.isChiBlocked()) {
    event.setCancelled(true);
    return;
  }
  if (!player.isSneaking() && bPlayer.canBendIgnoreCooldowns(coreAbil)) {
    if (coreAbil instanceof AddonAbility) {
      return;
    }
    if (coreAbil instanceof AirAbility && bPlayer.isElementToggled(Element.AIR) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Tornado(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirBlast.setOrigin(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirBurst(player,false);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirSuction.setOrigin(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSwipe(player,true);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirShield(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Suffocate(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (player.isSneaking() || !bPlayer.canUseFlight()) {
          return;
        }
        new AirFlight(player);
      }
    }
    if (coreAbil instanceof WaterAbility && bPlayer.isElementToggled(Element.WATER) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Bloodbending(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new IceBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new IceSpikeBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        OctopusForm.form(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!CoreAbility.hasAbility(player,PhaseChange.class)) {
          new PhaseChange(player,PhaseChangeType.MELT);
        }
 else {
          PhaseChange pc=CoreAbility.getAbility(player,PhaseChange.class);
          pc.startNewType(PhaseChangeType.MELT);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterManipulation(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        SurgeWall.form(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Torrent.create(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterArms(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HealingWaters(player);
      }
    }
    if (coreAbil instanceof EarthAbility && bPlayer.isElementToggled(Element.EARTH) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthArmor(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RaiseEarthWall(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new CollapseWall(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Shockwave(player,false);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthTunnel(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        bPlayer.toggleTremorSense();
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Extraction(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        MetalClips clips=CoreAbility.getAbility(player,MetalClips.class);
        if (clips != null) {
          if (clips.getTargetEntity() == null) {
            clips.setMagnetized(true);
          }
 else {
            clips.setControlling(true);
          }
        }
 else {
          new MetalClips(player,1);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new LavaFlow(player,LavaFlow.AbilityType.SHIFT);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthSmash(player,ClickType.SHIFT_DOWN);
      }
    }
    if (coreAbil instanceof FireAbility && bPlayer.isElementToggled(Element.FIRE) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new BlazeRing(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBlastCharged(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HeatControl(player,HeatControlType.COOK);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBurst(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireShield(player,true);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Lightning(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Combustion(player);
      }
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerSneak(PlayerToggleSneakEvent event){
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (event.isCancelled() || bPlayer == null) {
    return;
  }
  if (CoreAbility.hasAbility(event.getPlayer(),AirScooter.class)) {
    event.setCancelled(true);
    return;
  }
  if (player.isSneaking()) {
    ComboManager.addComboAbility(player,ClickType.SHIFT_UP);
  }
 else {
    ComboManager.addComboAbility(player,ClickType.SHIFT_DOWN);
  }
  String abilName=bPlayer.getBoundAbilityName();
  if (Suffocate.isBreathbent(player)) {
    if (!abilName.equalsIgnoreCase(""String_Node_Str"") || !abilName.equalsIgnoreCase(""String_Node_Str"") || !abilName.equalsIgnoreCase(""String_Node_Str"")|| !abilName.equalsIgnoreCase(""String_Node_Str"")) {
      if (!player.isSneaking()) {
        event.setCancelled(true);
      }
    }
  }
  if (Paralyze.isParalyzed(player) || ChiCombo.isParalyzed(player) || Bloodbending.isBloodbent(player)) {
    event.setCancelled(true);
    return;
  }
  if (!player.isSneaking()) {
    BlockSource.update(player,ClickType.SHIFT_DOWN);
  }
  AirScooter.check(player);
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  String abil=bPlayer.getBoundAbilityName();
  if (coreAbil == null) {
    return;
  }
  if (bPlayer.isChiBlocked()) {
    event.setCancelled(true);
    return;
  }
  if (!player.isSneaking() && bPlayer.canBendIgnoreCooldowns(coreAbil)) {
    if (coreAbil instanceof AddonAbility) {
      return;
    }
    if (coreAbil instanceof AirAbility && bPlayer.isElementToggled(Element.AIR) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Tornado(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirBlast.setOrigin(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirBurst(player,false);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirSuction.setOrigin(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSwipe(player,true);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirShield(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Suffocate(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (player.isSneaking() || !bPlayer.canUseFlight()) {
          return;
        }
        new AirFlight(player);
      }
    }
    if (coreAbil instanceof WaterAbility && bPlayer.isElementToggled(Element.WATER) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Bloodbending(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new IceBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new IceSpikeBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        OctopusForm.form(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!CoreAbility.hasAbility(player,PhaseChange.class)) {
          new PhaseChange(player,PhaseChangeType.MELT);
        }
 else {
          PhaseChange pc=CoreAbility.getAbility(player,PhaseChange.class);
          pc.startNewType(PhaseChangeType.MELT);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterManipulation(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        SurgeWall.form(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Torrent.create(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterArms(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HealingWaters(player);
      }
    }
    if (coreAbil instanceof EarthAbility && bPlayer.isElementToggled(Element.EARTH) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthBlast(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthArmor(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RaiseEarthWall(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new CollapseWall(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Shockwave(player,false);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthTunnel(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        bPlayer.toggleTremorSense();
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Extraction(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        MetalClips clips=CoreAbility.getAbility(player,MetalClips.class);
        if (clips != null) {
          if (clips.getTargetEntity() == null) {
            clips.setMagnetized(true);
          }
 else {
            clips.setControlling(true);
          }
        }
 else {
          new MetalClips(player,1);
        }
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new LavaFlow(player,LavaFlow.AbilityType.SHIFT);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthSmash(player,ClickType.SHIFT_DOWN);
      }
    }
    if (coreAbil instanceof FireAbility && bPlayer.isElementToggled(Element.FIRE) == true) {
      if (GeneralMethods.isWeapon(player.getInventory().getItemInMainHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new BlazeRing(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBlastCharged(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HeatControl(player,HeatControlType.COOK);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBurst(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireShield(player,true);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Lightning(player);
      }
 else       if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Combustion(player);
      }
    }
  }
}",0.9917331399564904
133811,"@SuppressWarnings(""String_Node_Str"") private void advanceSwipe(){
  affectedEntities.clear();
  for (  Vector direction : elements.keySet()) {
    Location location=elements.get(direction);
    if (direction != null && location != null) {
      location=location.clone().add(direction.clone().multiply(speed));
      elements.put(direction,location);
      if (location.distanceSquared(origin) > range * range || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        elements.remove(direction);
      }
 else {
        Block block=location.getBlock();
        if (!EarthAbility.isTransparent(player,block)) {
          remove();
          return;
        }
        for (        Block testblock : GeneralMethods.getBlocksAroundPoint(location,radius)) {
          if (testblock.getType() == Material.FIRE) {
            testblock.setType(Material.AIR);
          }
          if (isBlockBreakable(testblock)) {
            GeneralMethods.breakBlock(testblock);
          }
        }
        if (block.getType() != Material.AIR) {
          if (isBlockBreakable(block)) {
            GeneralMethods.breakBlock(block);
          }
 else {
            elements.remove(direction);
          }
          if (isLava(block)) {
            if (block.getData() == 0x0) {
              block.setType(Material.OBSIDIAN);
            }
 else {
              block.setType(Material.COBBLESTONE);
            }
          }
        }
 else {
          playAirbendingParticles(location,particles,0.2F,0.2F,0);
          if (random.nextInt(4) == 0) {
            playAirbendingSound(location);
          }
          affectPeople(location,direction);
        }
      }
    }
  }
  if (elements.isEmpty()) {
    remove();
  }
}","@SuppressWarnings(""String_Node_Str"") private void advanceSwipe(){
  affectedEntities.clear();
  for (  Vector direction : elements.keySet()) {
    Location location=elements.get(direction);
    if (direction != null && location != null) {
      location=location.clone().add(direction.clone().multiply(speed));
      elements.put(direction,location);
      if (location.distanceSquared(origin) > range * range || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        elements.remove(direction);
      }
 else {
        Block block=location.getBlock();
        if (!EarthAbility.isTransparent(player,block)) {
          remove();
          return;
        }
        for (        Block testblock : GeneralMethods.getBlocksAroundPoint(location,radius)) {
          if (testblock.getType() == Material.FIRE) {
            testblock.setType(Material.AIR);
          }
          if (isBlockBreakable(testblock)) {
            GeneralMethods.breakBlock(testblock);
          }
        }
        if (block.getType() != Material.AIR) {
          if (isBlockBreakable(block)) {
            GeneralMethods.breakBlock(block);
          }
          if (block.getType().equals(Material.SNOW)) {
            continue;
          }
 else {
            elements.remove(direction);
          }
          if (isLava(block)) {
            if (block.getData() == 0x0) {
              block.setType(Material.OBSIDIAN);
            }
 else {
              block.setType(Material.COBBLESTONE);
            }
          }
        }
 else {
          playAirbendingParticles(location,particles,0.2F,0.2F,0);
          if (random.nextInt(4) == 0) {
            playAirbendingSound(location);
          }
          affectPeople(location,direction);
        }
      }
    }
  }
  if (elements.isEmpty()) {
    remove();
  }
}",0.9747660901616104
133812,"@Override public void progress(){
  if (bPlayer.isOnCooldown(this)) {
    remove();
    return;
  }
  jump(player);
  WaterArmsWhip waw=WaterArmsWhip.getGrabbedEntities().get(player);
  if (waw != null) {
    waw.setGrabbed(false);
  }
  bPlayer.addCooldown(this);
}","@Override public void progress(){
  if (bPlayer.isOnCooldown(this)) {
    remove();
    return;
  }
  jump(player);
  WaterArmsWhip waw=WaterArmsWhip.getGrabbedEntities().get(player);
  if (waw != null) {
    waw.setGrabbed(false);
  }
}",0.9423459244532804
133813,"private void jump(Player p){
  if (!GeneralMethods.isSolid(p.getLocation().getBlock().getRelative(BlockFace.DOWN))) {
    return;
  }
  Vector vec=p.getVelocity();
  vec.setY(height);
  p.setVelocity(vec);
  return;
}","private void jump(Player p){
  if (!GeneralMethods.isSolid(p.getLocation().getBlock().getRelative(BlockFace.DOWN))) {
    remove();
    return;
  }
  Vector vec=p.getVelocity();
  vec.setY(height);
  p.setVelocity(vec);
  bPlayer.addCooldown(this);
  return;
}",0.909853249475891
133814,"@Override public long getCooldown(){
  return 0;
}","@Override public long getCooldown(){
  return cooldown;
}",0.9158878504672896
133815,"public QuickStrike(Player player){
  super(player);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.damage=getConfig().getInt(""String_Node_Str"");
  this.blockChance=getConfig().getInt(""String_Node_Str"");
  target=GeneralMethods.getTargetedEntity(player,2);
  if (target == null) {
    return;
  }
  start();
}","public QuickStrike(Player sourceplayer,Entity targetentity){
  super(sourceplayer);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.damage=getConfig().getInt(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.blockChance=getConfig().getInt(""String_Node_Str"");
  target=targetentity;
  if (target == null) {
    return;
  }
  start();
}",0.7942028985507247
133816,"@Override public void progress(){
  if (target == null) {
    remove();
    return;
  }
  DamageHandler.damageEntity(target,damage,this);
  if (target instanceof Player && ChiPassive.willChiBlock(player,(Player)target)) {
    ChiPassive.blockChi((Player)target);
  }
  remove();
}","@Override public void progress(){
  if (bPlayer.isOnCooldown(this)) {
    return;
  }
  if (target == null) {
    remove();
    return;
  }
  DamageHandler.damageEntity(target,damage,this);
  bPlayer.addCooldown(this);
  if (target instanceof Player && ChiPassive.willChiBlock(player,(Player)target)) {
    ChiPassive.blockChi((Player)target);
  }
  remove();
}",0.8736349453978159
133817,"public RapidPunch(Player player){
  super(player);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.damage=getConfig().getInt(""String_Node_Str"");
  this.punches=getConfig().getInt(""String_Node_Str"");
  this.distance=getConfig().getInt(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.target=GeneralMethods.getTargetedEntity(player,distance);
  start();
}","public RapidPunch(Player sourceplayer,Entity targetentity){
  super(sourceplayer);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.damage=getConfig().getInt(""String_Node_Str"");
  this.punches=getConfig().getInt(""String_Node_Str"");
  this.distance=getConfig().getInt(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.target=GeneralMethods.getTargetedEntity(player,distance);
  start();
}",0.946341463414634
133818,"public SwiftKick(Player player){
  super(player);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.damage=getConfig().getInt(""String_Node_Str"");
  this.blockChance=getConfig().getInt(""String_Node_Str"");
  this.cooldown=getConfig().getInt(""String_Node_Str"");
  this.target=GeneralMethods.getTargetedEntity(player,4);
  start();
}","public SwiftKick(Player sourceplayer,Entity targetentity){
  super(sourceplayer);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.damage=getConfig().getInt(""String_Node_Str"");
  this.blockChance=getConfig().getInt(""String_Node_Str"");
  this.cooldown=getConfig().getInt(""String_Node_Str"");
  this.target=targetentity;
  start();
}",0.8716417910447761
133819,"public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    ArrayList<String> helpLines=new ArrayList<String>();
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",helpLines);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",60000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",60000);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",120000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}","public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    ArrayList<String> helpLines=new ArrayList<String>();
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",helpLines);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",60000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",60000);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",120000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}",0.9995286966056536
133820,"@Override public void progress(){
  progressCounter++;
  for (int i=0; i < tasks.size(); i++) {
    BukkitRunnable br=tasks.get(i);
    if (br instanceof FireComboStream) {
      FireComboStream fs=(FireComboStream)br;
      if (fs.isCancelled()) {
        tasks.remove(fs);
      }
    }
  }
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      Vector eyeDir=player.getEyeLocation().getDirection().normalize().multiply(range);
      destination=player.getEyeLocation().add(eyeDir);
      player.getWorld().playSound(player.getLocation(),Sound.ENTITY_HORSE_JUMP,0.5f,0f);
      player.getWorld().playSound(player.getLocation(),Sound.ENTITY_CREEPER_PRIMED,0.5f,1f);
      for (int i=-30; i <= 30; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setSpread(0.2F);
        fs.setDensity(5);
        fs.setUseNewParticles(true);
        if (tasks.size() % 3 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
        player.getWorld().playSound(player.getLocation(),Sound.ITEM_FLINTANDSTEEL_USE,0.5f,1f);
      }
      location=tasks.get(0).getLocation();
    }
 else     if (tasks.size() == 0) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      destination=player.getEyeLocation().add(range,0,range);
      player.getWorld().playSound(player.getLocation(),Sound.ENTITY_CREEPER_PRIMED,0.5f,0.5f);
      for (int i=0; i <= 360; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i - 180);
        vec.setY(0);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation().clone().add(0,1,0),range,speed,""String_Node_Str"");
        fs.setSpread(0.0F);
        fs.setDensity(1);
        fs.setUseNewParticles(true);
        if (tasks.size() % 10 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    if (tasks.size() == 0) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      if (firstTime) {
        if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
          remove();
          return;
        }
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
        firstTime=false;
        float spread=0F;
        ParticleEffect.LARGE_EXPLODE.display(player.getLocation(),spread,spread,spread,0,1);
        player.getWorld().playSound(player.getLocation(),Sound.ENTITY_GENERIC_EXPLODE,15,0F);
      }
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,player.getVelocity().clone().multiply(-1),player.getLocation(),3,0.5,""String_Node_Str"");
      fs.setDensity(1);
      fs.setSpread(0.9F);
      fs.setUseNewParticles(true);
      fs.setCollides(false);
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (firstTime) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      firstTime=false;
    }
 else     if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      direction=player.getVelocity().clone().multiply(-1);
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,direction,player.getLocation(),5,1,""String_Node_Str"");
      fs.setDensity(8);
      fs.setSpread(1.0F);
      fs.setUseNewParticles(true);
      fs.setCollisionRadius(3);
      fs.setParticleEffect(ParticleEffect.LARGE_SMOKE);
      if (progressCounter % 5 != 0) {
        fs.setCollides(false);
      }
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
      if (progressCounter % 4 == 0) {
        player.getWorld().playSound(player.getLocation(),Sound.ENTITY_CREEPER_PRIMED,1,0F);
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (location == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      if (GeneralMethods.getTopBlock(player.getLocation(),3,3) == null) {
        remove();
        return;
      }
      location=player.getLocation();
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
    }
 else     if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(location,2,-4);
    if (topBlock == null || (WaterAbility.isWaterbendable(player,ability,topBlock) && !isPlant(topBlock))) {
      remove();
      return;
    }
 else     if (topBlock.getType() == Material.FIRE || ElementalAbility.isPlant(topBlock)) {
      topBlock=topBlock.getLocation().add(0,-1,0).getBlock();
    }
    location.setY(topBlock.getY() + height);
    FireComboStream fs=new FireComboStream(this,direction,location.clone().add(0,-1,0),5,1,""String_Node_Str"");
    fs.setDensity(0);
    fs.setSinglePoint(true);
    fs.setCollisionRadius(1.5);
    fs.setCollides(true);
    fs.runTaskTimer(ProjectKorra.plugin,0,1L);
    tasks.add(fs);
    for (double i=-180; i <= 180; i+=3) {
      Location tempLoc=location.clone();
      Vector newDir=direction.clone().multiply(radius * Math.cos(Math.toRadians(i)));
      tempLoc.add(newDir);
      tempLoc.setY(tempLoc.getY() + (radius * Math.sin(Math.toRadians(i))));
      ParticleEffect.FLAME.display(tempLoc,0,0,0,0,1);
    }
    location=location.add(direction.clone().multiply(speed));
    location.getWorld().playSound(location,Sound.BLOCK_FIRE_AMBIENT,1,1);
  }
}","@Override public void progress(){
  progressCounter++;
  for (int i=0; i < tasks.size(); i++) {
    BukkitRunnable br=tasks.get(i);
    if (br instanceof FireComboStream) {
      FireComboStream fs=(FireComboStream)br;
      if (fs.isCancelled()) {
        tasks.remove(fs);
      }
    }
  }
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      Vector eyeDir=player.getEyeLocation().getDirection().normalize().multiply(range);
      destination=player.getEyeLocation().add(eyeDir);
      player.getWorld().playSound(player.getLocation(),Sound.ENTITY_HORSE_JUMP,0.5f,0f);
      player.getWorld().playSound(player.getLocation(),Sound.ENTITY_CREEPER_PRIMED,0.5f,1f);
      for (int i=-30; i <= 30; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setSpread(0.2F);
        fs.setDensity(5);
        fs.setUseNewParticles(true);
        if (tasks.size() % 3 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
        player.getWorld().playSound(player.getLocation(),Sound.ITEM_FLINTANDSTEEL_USE,0.5f,1f);
      }
      location=tasks.get(0).getLocation();
    }
 else     if (tasks.size() == 0) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      destination=player.getEyeLocation().add(range,0,range);
      player.getWorld().playSound(player.getLocation(),Sound.ENTITY_CREEPER_PRIMED,0.5f,0.5f);
      for (int i=0; i <= 360; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i - 180);
        vec.setY(0);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation().clone().add(0,1,0),range,speed,""String_Node_Str"");
        fs.setSpread(0.0F);
        fs.setDensity(1);
        fs.setUseNewParticles(true);
        if (tasks.size() % 10 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    if (tasks.size() == 0) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      if (firstTime) {
        if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
          remove();
          return;
        }
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
        firstTime=false;
        float spread=0F;
        ParticleEffect.LARGE_EXPLODE.display(player.getLocation(),spread,spread,spread,0,1);
        player.getWorld().playSound(player.getLocation(),Sound.ENTITY_GENERIC_EXPLODE,15,0F);
      }
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,player.getVelocity().clone().multiply(-1),player.getLocation(),3,0.5,""String_Node_Str"");
      fs.setDensity(1);
      fs.setSpread(0.9F);
      fs.setUseNewParticles(true);
      fs.setCollides(false);
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (firstTime) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      firstTime=false;
    }
 else     if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      direction=player.getVelocity().clone().multiply(-1);
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,direction,player.getLocation(),5,1,""String_Node_Str"");
      fs.setDensity(8);
      fs.setSpread(1.0F);
      fs.setUseNewParticles(true);
      fs.setCollisionRadius(3);
      fs.setParticleEffect(ParticleEffect.LARGE_SMOKE);
      if (progressCounter % 5 != 0) {
        fs.setCollides(false);
      }
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
      if (progressCounter % 4 == 0) {
        player.getWorld().playSound(player.getLocation(),Sound.ENTITY_CREEPER_PRIMED,1,0F);
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (location == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      if (GeneralMethods.getTopBlock(player.getLocation(),3,3) == null) {
        remove();
        return;
      }
      location=player.getLocation();
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
    }
 else     if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(location,2,-4);
    if (topBlock.getType().equals(Material.SNOW)) {
      topBlock=topBlock.getLocation().add(0,-1,0).getBlock();
    }
    if (topBlock == null || (WaterAbility.isWaterbendable(player,ability,topBlock) && !isPlant(topBlock))) {
      remove();
      return;
    }
 else     if (topBlock.getType() == Material.FIRE || ElementalAbility.isPlant(topBlock)) {
      topBlock=topBlock.getLocation().add(0,-1,0).getBlock();
    }
    location.setY(topBlock.getY() + height);
    FireComboStream fs=new FireComboStream(this,direction,location.clone().add(0,-1,0),5,1,""String_Node_Str"");
    fs.setDensity(0);
    fs.setSinglePoint(true);
    fs.setCollisionRadius(1.5);
    fs.setCollides(true);
    fs.runTaskTimer(ProjectKorra.plugin,0,1L);
    tasks.add(fs);
    for (double i=-180; i <= 180; i+=3) {
      Location tempLoc=location.clone();
      Vector newDir=direction.clone().multiply(radius * Math.cos(Math.toRadians(i)));
      tempLoc.add(newDir);
      tempLoc.setY(tempLoc.getY() + (radius * Math.sin(Math.toRadians(i))));
      ParticleEffect.FLAME.display(tempLoc,0,0,0,0,1);
    }
    location=location.add(direction.clone().multiply(speed));
    location.getWorld().playSound(location,Sound.BLOCK_FIRE_AMBIENT,1,1);
  }
}",0.9912980420594634
133821,"/** 
 * Changes the player that owns this ability instance. Used for redirection  and other abilities that change the player object.
 * @param player The player who now controls the ability
 */
public void setPlayer(Player player){
  INSTANCES_BY_PLAYER.get(this.getClass()).get(this.player.getUniqueId()).remove(this.getId());
  INSTANCES_BY_PLAYER.get(this.getClass()).get(player.getUniqueId()).put(this.getId(),this);
  this.player=player;
}","/** 
 * Changes the player that owns this ability instance. Used for redirection  and other abilities that change the player object.
 * @param player The player who now controls the ability
 */
public void setPlayer(Player player){
  Map<UUID,Map<Integer,CoreAbility>> classMap=INSTANCES_BY_PLAYER.get(getClass());
  if (classMap != null) {
    Map<Integer,CoreAbility> playerMap=classMap.get(player.getUniqueId());
    if (playerMap != null) {
      playerMap.remove(this.id);
      if (playerMap.size() == 0) {
        classMap.remove(player.getUniqueId());
      }
    }
    if (classMap.size() == 0) {
      INSTANCES_BY_PLAYER.remove(getClass());
    }
  }
  if (!INSTANCES_BY_PLAYER.containsKey(this.getClass())) {
    INSTANCES_BY_PLAYER.put(this.getClass(),new ConcurrentHashMap<UUID,Map<Integer,CoreAbility>>());
  }
  if (!INSTANCES_BY_PLAYER.get(this.getClass()).containsKey(player.getUniqueId())) {
    INSTANCES_BY_PLAYER.get(this.getClass()).put(player.getUniqueId(),new ConcurrentHashMap<Integer,CoreAbility>());
  }
  INSTANCES_BY_PLAYER.get(this.getClass()).get(player.getUniqueId()).put(this.getId(),this);
  this.player=player;
}",0.4522613065326633
133822,"/** 
 * Displays the enabled moves for the given element to the CommandSender.
 * @param sender The CommandSender to show the moves to
 * @param element The element to show the moves for
 */
private void displayElement(CommandSender sender,Element element){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(element);
  if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.RED + invalidArgument);
    return;
  }
 else   if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.YELLOW + noAbilitiesAvailable.replace(""String_Node_Str"",element.getColor() + element.getName() + ChatColor.YELLOW));
  }
  for (  CoreAbility ability : abilities) {
    if (ability instanceof SubAbility || ability.isHiddenAbility()) {
      continue;
    }
    if (!(sender instanceof Player) || GeneralMethods.canView((Player)sender,ability.getName())) {
      sender.sendMessage(ability.getElement().getColor() + ability.getName());
    }
  }
  if (element.equals(Element.CHI)) {
    sender.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + ChatColor.YELLOW+ ""String_Node_Str"");
  }
 else {
    sender.sendMessage(element.getSubColor() + ""String_Node_Str"" + element.getColor()+ ""String_Node_Str""+ element.getName()+ ""String_Node_Str"");
    for (    SubElement sub : Element.getSubElements(element)) {
      if (sender.hasPermission(""String_Node_Str"" + element.getName().toLowerCase() + ""String_Node_Str""+ sub.getName().toLowerCase())) {
        sender.sendMessage(sub.getColor() + sub.getName() + ""String_Node_Str""+ element.getColor()+ ""String_Node_Str""+ sub.getName());
      }
    }
  }
}","/** 
 * Displays the enabled moves for the given element to the CommandSender.
 * @param sender The CommandSender to show the moves to
 * @param element The element to show the moves for
 */
private void displayElement(CommandSender sender,Element element){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(element);
  if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.RED + invalidArgument);
    return;
  }
 else   if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.YELLOW + noAbilitiesAvailable.replace(""String_Node_Str"",element.getColor() + element.getName() + ChatColor.YELLOW));
  }
  HashSet<String> abilitiesSent=new HashSet<String>();
  for (  CoreAbility ability : abilities) {
    if (ability instanceof SubAbility || ability.isHiddenAbility() || abilitiesSent.contains(ability.getName())) {
      continue;
    }
    if (!(sender instanceof Player) || GeneralMethods.canView((Player)sender,ability.getName())) {
      sender.sendMessage(ability.getElement().getColor() + ability.getName());
      abilitiesSent.add(ability.getName());
    }
  }
  if (element.equals(Element.CHI)) {
    sender.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + ChatColor.YELLOW+ ""String_Node_Str"");
  }
 else {
    sender.sendMessage(element.getSubColor() + ""String_Node_Str"" + element.getColor()+ ""String_Node_Str""+ element.getName()+ ""String_Node_Str"");
    for (    SubElement sub : Element.getSubElements(element)) {
      if (sender.hasPermission(""String_Node_Str"" + element.getName().toLowerCase() + ""String_Node_Str""+ sub.getName().toLowerCase())) {
        sender.sendMessage(sub.getColor() + sub.getName() + ""String_Node_Str""+ element.getColor()+ ""String_Node_Str""+ sub.getName());
      }
    }
  }
}",0.92012012012012
133823,"/** 
 * Displays the enabled moves for the given subelement to the CommandSender.
 * @param sender The CommandSender to show the moves to
 * @param element The subelement to show the moves for
 */
private void displaySubElement(CommandSender sender,Element element){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(element);
  if (abilities.isEmpty() && element != null) {
    sender.sendMessage(ChatColor.YELLOW + noAbilitiesAvailable.replace(""String_Node_Str"",element.getColor() + element.getName() + ChatColor.YELLOW));
    return;
  }
  for (  CoreAbility ability : abilities) {
    if (ability.isHiddenAbility()) {
      continue;
    }
 else     if (!(sender instanceof Player) || GeneralMethods.canView((Player)sender,ability.getName())) {
      sender.sendMessage(element.getColor() + ability.getName());
    }
  }
}","/** 
 * Displays the enabled moves for the given subelement to the CommandSender.
 * @param sender The CommandSender to show the moves to
 * @param element The subelement to show the moves for
 */
private void displaySubElement(CommandSender sender,Element element){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(element);
  if (abilities.isEmpty() && element != null) {
    sender.sendMessage(ChatColor.YELLOW + noAbilitiesAvailable.replace(""String_Node_Str"",element.getColor() + element.getName() + ChatColor.YELLOW));
    return;
  }
  HashSet<String> abilitiesSent=new HashSet<String>();
  for (  CoreAbility ability : abilities) {
    if (ability.isHiddenAbility() || abilitiesSent.contains(ability.getName())) {
      continue;
    }
 else     if (!(sender instanceof Player) || GeneralMethods.canView((Player)sender,ability.getName())) {
      sender.sendMessage(element.getColor() + ability.getName());
      abilitiesSent.add(ability.getName());
    }
  }
}",0.8475877192982456
133824,"private void displayAvatar(CommandSender sender){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(Element.AVATAR);
  if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.YELLOW + noAbilitiesAvailable.replace(""String_Node_Str"",Element.AVATAR.getColor() + ""String_Node_Str"" + ChatColor.YELLOW));
    return;
  }
  for (  CoreAbility ability : abilities) {
    if (ability.isHiddenAbility()) {
      continue;
    }
    if (sender instanceof Player) {
      if (GeneralMethods.canView((Player)sender,ability.getName())) {
        sender.sendMessage(ability.getElement().getColor() + ability.getName());
      }
    }
 else {
      sender.sendMessage(ability.getElement().getColor() + ability.getName());
    }
  }
}","private void displayAvatar(CommandSender sender){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(Element.AVATAR);
  if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.YELLOW + noAbilitiesAvailable.replace(""String_Node_Str"",Element.AVATAR.getColor() + ""String_Node_Str"" + ChatColor.YELLOW));
    return;
  }
  HashSet<String> abilitiesSent=new HashSet<String>();
  for (  CoreAbility ability : abilities) {
    if (ability.isHiddenAbility() || abilitiesSent.contains(ability.getName())) {
      continue;
    }
    if (sender instanceof Player) {
      if (GeneralMethods.canView((Player)sender,ability.getName())) {
        sender.sendMessage(ability.getElement().getColor() + ability.getName());
        abilitiesSent.add(ability.getName());
      }
    }
 else {
      sender.sendMessage(ability.getElement().getColor() + ability.getName());
      abilitiesSent.add(ability.getName());
    }
  }
}",0.8855421686746988
133825,"public boolean prepare(){
  Block block=BlockSource.getWaterSourceBlock(player,selectRange,ClickType.SHIFT_DOWN,true,true,bPlayer.canPlantbend());
  cancelPrevious();
  block(player);
  if (block != null) {
    sourceBlock=block;
    focusBlock();
    return true;
  }
  return false;
}","public boolean prepare(){
  Block block=BlockSource.getWaterSourceBlock(player,selectRange,ClickType.SHIFT_DOWN,true,true,bPlayer.canPlantbend());
  cancelPrevious();
  if (block != null) {
    sourceBlock=block;
    focusBlock();
    return true;
  }
  return false;
}",0.9693693693693692
133826,"/** 
 * Blocks other water manips
 */
private static void block(Player player){
  for (  WaterManipulation manip : getAbilities(WaterManipulation.class)) {
    if (!manip.location.getWorld().equals(player.getWorld())) {
      continue;
    }
 else     if (!manip.progressing) {
      continue;
    }
 else     if (manip.getPlayer().equals(player)) {
      continue;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(manip,manip.location)) {
      continue;
    }
    Location location=player.getEyeLocation();
    Vector vector=location.getDirection();
    Location mloc=manip.location;
    if (mloc.distanceSquared(location) <= manip.selectRange * manip.selectRange && GeneralMethods.getDistanceFromLine(vector,location,manip.location) < manip.deflectRange && mloc.distanceSquared(location.clone().add(vector)) < mloc.distanceSquared(location.clone().add(vector.clone().multiply(-1)))) {
      manip.remove();
    }
  }
}","/** 
 * Blocks other water manips
 */
public static void block(Player player){
  for (  WaterManipulation manip : getAbilities(WaterManipulation.class)) {
    if (!manip.location.getWorld().equals(player.getWorld())) {
      continue;
    }
 else     if (!manip.progressing) {
      continue;
    }
 else     if (manip.getPlayer().equals(player)) {
      continue;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(manip,manip.location)) {
      continue;
    }
    Location location=player.getEyeLocation();
    Vector vector=location.getDirection();
    Location mloc=manip.location;
    if (mloc.distanceSquared(location) <= manip.selectRange * manip.selectRange && GeneralMethods.getDistanceFromLine(vector,location,manip.location) < manip.deflectRange && mloc.distanceSquared(location.clone().add(vector)) < mloc.distanceSquared(location.clone().add(vector.clone().multiply(-1)))) {
      manip.remove();
    }
  }
}",0.9941081949651848
133827,"@SuppressWarnings(""String_Node_Str"") public static void moveWater(Player player){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
  if (bPlayer.isOnCooldown(""String_Node_Str"")) {
    redirectTargettedBlasts(player);
    return;
  }
  boolean handledPrepare=false;
  double range=25;
  for (  WaterManipulation waterManip : getAbilities(player,WaterManipulation.class)) {
    range=waterManip.range;
    if (waterManip.prepared) {
      waterManip.prepared=false;
      handledPrepare=true;
      waterManip.moveWater();
    }
  }
  if (!handledPrepare && WaterReturn.hasWaterBottle(player)) {
    Location eyeLoc=player.getEyeLocation();
    Block block=eyeLoc.add(eyeLoc.getDirection().normalize()).getBlock();
    if (!AFFECTED_BLOCKS.containsKey(block)) {
      AFFECTED_BLOCKS.put(block,block);
    }
    if (isTransparent(player,block) && isTransparent(player,eyeLoc.getBlock())) {
      if (getTargetLocation(player,range).distanceSquared(block.getLocation()) > 1) {
        block.setType(Material.WATER);
        block.setData((byte)0);
        WaterManipulation waterManip=new WaterManipulation(player);
        waterManip.moveWater();
        if (!waterManip.progressing) {
          block.setType(Material.AIR);
        }
 else {
          WaterReturn.emptyWaterBottle(player);
        }
      }
    }
  }
  redirectTargettedBlasts(player);
}","public static void moveWater(Player player){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
  if (bPlayer.isOnCooldown(""String_Node_Str"")) {
    redirectTargettedBlasts(player);
    return;
  }
  boolean handledPrepare=false;
  double range=25;
  for (  WaterManipulation waterManip : getAbilities(player,WaterManipulation.class)) {
    range=waterManip.range;
    if (waterManip.prepared) {
      waterManip.prepared=false;
      handledPrepare=true;
      waterManip.moveWater();
    }
  }
  if (!handledPrepare && WaterReturn.hasWaterBottle(player)) {
    Location eyeLoc=player.getEyeLocation();
    Block block=eyeLoc.add(eyeLoc.getDirection().normalize()).getBlock();
    if (!AFFECTED_BLOCKS.containsKey(block)) {
      AFFECTED_BLOCKS.put(block,block);
    }
    if (isTransparent(player,block) && isTransparent(player,eyeLoc.getBlock())) {
      if (getTargetLocation(player,range).distanceSquared(block.getLocation()) > 1) {
        TempBlock tb=new TempBlock(block,Material.WATER,(byte)0);
        WaterManipulation waterManip=new WaterManipulation(player);
        waterManip.moveWater();
        if (!waterManip.progressing) {
          block.setType(Material.AIR);
          tb.revertBlock();
        }
 else {
          WaterReturn.emptyWaterBottle(player);
          tb.revertBlock();
        }
      }
    }
  }
  redirectTargettedBlasts(player);
}",0.9449152542372882
133828,"@Override public void progress(){
  PotionEffect effect=new PotionEffect(PotionEffectType.SLOW,60,1);
  if (!player.isSneaking()) {
    remove();
    return;
  }
 else   if (holdTime > 0 && System.currentTimeMillis() - this.time > holdTime) {
    remove();
    return;
  }
  if (!canBeUsedOnUndeadMobs) {
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (isUndead(entity)) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
  if (onlyUsableDuringMoon && !isFullMoon(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (canOnlyBeUsedAtNight && !isNight(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (bPlayer.isAvatarState()) {
    ArrayList<Entity> entities=new ArrayList<>();
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation(),range)) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
        continue;
      }
 else       if (!(entity instanceof LivingEntity)) {
        continue;
      }
 else       if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null) {
          if (!targetBPlayer.canBeBloodbent() || entity.getEntityId() == player.getEntityId()) {
            continue;
          }
        }
      }
      entities.add(entity);
      if (!TARGETED_ENTITIES.containsKey(entity) && entity instanceof LivingEntity) {
        DamageHandler.damageEntity(entity,0,this);
        TARGETED_ENTITIES.put(entity,player);
      }
      if (player.getWorld() != entity.getLocation().getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
      if (entity instanceof LivingEntity) {
        entity.setVelocity(new Vector(0,0,0));
        new TempPotionEffect((LivingEntity)entity,effect);
        entity.setFallDistance(0);
        if (entity instanceof Creature) {
          ((Creature)entity).setTarget(null);
        }
        AirAbility.breakBreathbendingHold(entity);
      }
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (!entities.contains(entity) && TARGETED_ENTITIES.get(entity) == player) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
 else {
    if (TARGETED_ENTITIES.get(target) != player) {
      remove();
      return;
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null && !targetBPlayer.canBeBloodbent()) {
          TARGETED_ENTITIES.remove(entity);
          continue;
        }
      }
      Location newLocation=entity.getLocation();
      if (player.getWorld() != newLocation.getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
    }
    Location location=GeneralMethods.getTargetedLocation(player,6,getTransparentMaterial());
    double distance=0;
    if (location.getWorld().equals(target.getWorld())) {
      location.distance(target.getLocation());
    }
    double dx, dy, dz;
    dx=location.getX() - target.getLocation().getX();
    dy=location.getY() - target.getLocation().getY();
    dz=location.getZ() - target.getLocation().getZ();
    Vector vector=new Vector(dx,dy,dz);
    if (distance > .5) {
      target.setVelocity(vector.normalize().multiply(.5));
    }
 else {
      target.setVelocity(new Vector(0,0,0));
    }
    new TempPotionEffect((LivingEntity)target,effect);
    target.setFallDistance(0);
    if (target instanceof Creature) {
      ((Creature)target).setTarget(null);
    }
    AirAbility.breakBreathbendingHold(target);
  }
}","@Override public void progress(){
  PotionEffect effect=new PotionEffect(PotionEffectType.SLOW,60,1);
  if (!player.isSneaking()) {
    remove();
    return;
  }
 else   if (holdTime > 0 && System.currentTimeMillis() - this.time > holdTime) {
    remove();
    return;
  }
  if (!canBeUsedOnUndeadMobs) {
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (isUndead(entity)) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
  if (onlyUsableDuringMoon && !isFullMoon(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (canOnlyBeUsedAtNight && !isNight(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (bPlayer.isAvatarState()) {
    ArrayList<Entity> entities=new ArrayList<>();
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation(),range)) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
        continue;
      }
 else       if (!(entity instanceof LivingEntity)) {
        continue;
      }
 else       if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null) {
          if (!targetBPlayer.canBeBloodbent() || entity.getEntityId() == player.getEntityId()) {
            continue;
          }
        }
      }
      entities.add(entity);
      if (!TARGETED_ENTITIES.containsKey(entity) && entity instanceof LivingEntity) {
        DamageHandler.damageEntity(entity,0,this);
        TARGETED_ENTITIES.put(entity,player);
      }
      if (player.getWorld() != entity.getLocation().getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
      if (entity instanceof LivingEntity) {
        entity.setVelocity(new Vector(0,0,0));
        new TempPotionEffect((LivingEntity)entity,effect);
        entity.setFallDistance(0);
        if (entity instanceof Creature) {
          ((Creature)entity).setTarget(null);
        }
        AirAbility.breakBreathbendingHold(entity);
      }
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (!entities.contains(entity) && TARGETED_ENTITIES.get(entity) == player) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
 else {
    if (TARGETED_ENTITIES.get(target) != player) {
      remove();
      return;
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null && !targetBPlayer.canBeBloodbent()) {
          TARGETED_ENTITIES.remove(entity);
          continue;
        }
      }
      Location newLocation=entity.getLocation();
      if (player.getWorld() != newLocation.getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
    }
    Location location=GeneralMethods.getTargetedLocation(player,6,getTransparentMaterial());
    double distance=0;
    if (location.getWorld().equals(target.getWorld())) {
      distance=location.distance(target.getLocation());
    }
    double dx, dy, dz;
    dx=location.getX() - target.getLocation().getX();
    dy=location.getY() - target.getLocation().getY();
    dz=location.getZ() - target.getLocation().getZ();
    Vector vector=new Vector(dx,dy,dz);
    if (distance > .5) {
      target.setVelocity(vector.normalize().multiply(.5));
    }
 else {
      target.setVelocity(new Vector(0,0,0));
    }
    new TempPotionEffect((LivingEntity)target,effect);
    target.setFallDistance(0);
    if (target instanceof Creature) {
      ((Creature)target).setTarget(null);
    }
    AirAbility.breakBreathbendingHold(target);
  }
}",0.9988230678697528
133829,"@Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (distanceTravelled > spearRange) {
    remove();
    return;
  }
  if (!hitEntity) {
    progressSpear();
  }
 else {
    createIceBall();
    remove();
  }
  if (layer >= spearSphere) {
    remove();
    return;
  }
 else   if (!canPlaceBlock(location.getBlock())) {
    if (canFreeze) {
      createSpear();
    }
    remove();
    return;
  }
}","@Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (distanceTravelled > spearRange) {
    remove();
    return;
  }
  if (!hitEntity) {
    progressSpear();
  }
 else {
    createIceBall();
    remove();
  }
  if (!canPlaceBlock(location.getBlock())) {
    if (canFreeze) {
      createSpear();
    }
    remove();
    return;
  }
}",0.9243119266055044
133830,"private void createIceBall(){
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,spearSphere)) {
    if (isTransparent(player,block) && block.getType() != Material.ICE && !WaterArms.isUnbreakable(block)) {
      playIcebendingSound(block.getLocation());
      new TempBlock(block,Material.ICE,(byte)0);
      getIceBlocks().put(block,System.currentTimeMillis() + spearDuration + (long)(Math.random() * 500));
    }
  }
}","private void createIceBall(){
  if (spearSphere <= 0) {
    if (canFreeze) {
      createSpear();
    }
    return;
  }
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,spearSphere)) {
    if (isTransparent(player,block) && block.getType() != Material.ICE && !WaterArms.isUnbreakable(block)) {
      playIcebendingSound(block.getLocation());
      new TempBlock(block,Material.ICE,(byte)0);
      getIceBlocks().put(block,System.currentTimeMillis() + spearDuration + (long)(Math.random() * 500));
    }
  }
}",0.9066390041493776
133831,"public WaterSpout(Player player){
  super(player);
  WaterSpout oldSpout=getAbility(player,WaterSpout.class);
  if (oldSpout != null) {
    oldSpout.remove();
    return;
  }
  this.canBendOnPackedIce=getConfig().getBoolean(""String_Node_Str"");
  this.useParticles=getConfig().getBoolean(""String_Node_Str"");
  this.useBlockSpiral=getConfig().getBoolean(""String_Node_Str"");
  this.height=getConfig().getDouble(""String_Node_Str"");
  this.interval=getConfig().getLong(""String_Node_Str"");
  hadFly=player.isFlying();
  canFly=player.getAllowFlight();
  maxHeight=getNightFactor(height);
  WaterSpoutWave spoutWave=new WaterSpoutWave(player,WaterSpoutWave.AbilityType.CLICK);
  if (spoutWave.isStarted() && !spoutWave.isRemoved()) {
    return;
  }
  Block topBlock=GeneralMethods.getTopBlock(player.getLocation(),(int)-getNightFactor(height),(int)-getNightFactor(height));
  if (topBlock == null) {
    topBlock=player.getLocation().getBlock();
  }
  if (!isWater(topBlock) && !isIcebendable(topBlock) && !isSnow(topBlock)) {
    return;
  }
 else   if (topBlock.getType() == Material.PACKED_ICE && !canBendOnPackedIce) {
    return;
  }
  double heightRemoveThreshold=2;
  if (!isWithinMaxSpoutHeight(topBlock.getLocation(),heightRemoveThreshold)) {
    return;
  }
  new Flight(player);
  player.setAllowFlight(true);
  start();
}","public WaterSpout(Player player){
  super(player);
  WaterSpout oldSpout=getAbility(player,WaterSpout.class);
  if (oldSpout != null) {
    oldSpout.remove();
    return;
  }
  this.canBendOnPackedIce=getConfig().getBoolean(""String_Node_Str"");
  this.useParticles=getConfig().getBoolean(""String_Node_Str"");
  this.useBlockSpiral=getConfig().getBoolean(""String_Node_Str"");
  this.height=getConfig().getDouble(""String_Node_Str"");
  this.interval=getConfig().getLong(""String_Node_Str"");
  hadFly=player.isFlying();
  canFly=player.getAllowFlight();
  maxHeight=getNightFactor(height);
  WaterSpoutWave spoutWave=new WaterSpoutWave(player,WaterSpoutWave.AbilityType.CLICK);
  if (spoutWave.isStarted() && !spoutWave.isRemoved()) {
    return;
  }
  Block topBlock=GeneralMethods.getTopBlock(player.getLocation(),(int)-getNightFactor(height),(int)-getNightFactor(height));
  if (topBlock == null) {
    topBlock=player.getLocation().getBlock();
  }
  if (!isWater(topBlock) && !isIcebendable(topBlock) && !isSnow(topBlock)) {
    return;
  }
 else   if (topBlock.getType() == Material.PACKED_ICE && !canBendOnPackedIce) {
    return;
  }
  double heightRemoveThreshold=2;
  if (!isWithinMaxSpoutHeight(topBlock.getLocation(),heightRemoveThreshold)) {
    return;
  }
  new Flight(player);
  player.setAllowFlight(true);
  spoutableWaterHeight(player.getLocation());
  start();
}",0.9829629629629628
133832,"private void getGround(){
  for (int i=0; i <= 5; i++) {
    Block block=loc.getBlock().getRelative(BlockFace.DOWN,i);
    if (isEarthbendable(block)) {
      groundBlock=block;
      blockType=block.getType();
      return;
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void getGround(){
  for (int i=0; i <= 5; i++) {
    Block block=loc.getBlock().getRelative(BlockFace.DOWN,i);
    if (isEarthbendable(block)) {
      groundBlock=block;
      blockType=block.getType();
      blockByte=block.getData();
      return;
    }
  }
}",0.8708487084870848
133833,"public EarthGrab(Player player){
  super(player);
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.height=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.origin=player.getEyeLocation();
  this.direction=origin.getDirection();
  this.lowestDistance=selectRange + 1;
  this.closestEntity=null;
  this.startLoc=player.getLocation();
  this.loc=player.getLocation();
  this.dir=player.getLocation().getDirection();
  this.random=new Random();
  if (!bPlayer.canBend(this)) {
    return;
  }
  if (player.isSneaking()) {
    start();
  }
  Location targetLocation=GeneralMethods.getTargetedLocation(player,1);
  Block block=GeneralMethods.getTopBlock(targetLocation,1);
  if (isEarthbendable(block) && block.getLocation().distance(player.getLocation()) <= 2) {
    earthGrabSelf();
    remove();
  }
}","public EarthGrab(Player player){
  super(player);
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.height=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.origin=player.getEyeLocation();
  this.direction=origin.getDirection();
  this.lowestDistance=selectRange + 1;
  this.closestEntity=null;
  this.startLoc=player.getLocation();
  this.loc=player.getLocation();
  this.dir=player.getLocation().getDirection().clone().normalize().multiply(1.5);
  this.random=new Random();
  if (!bPlayer.canBend(this)) {
    return;
  }
  if (player.isSneaking()) {
    start();
  }
 else {
    Location targetLocation=GeneralMethods.getTargetedLocation(player,1);
    Block block=GeneralMethods.getTopBlock(targetLocation,1,1);
    if (isEarthbendable(block) && block.getLocation().distance(player.getLocation()) <= 1.3) {
      earthGrabSelf();
      remove();
    }
  }
}",0.9457364341085271
133834,"@Override public void progress(){
  getGround();
  bPlayer.addCooldown(this);
  if (groundBlock == null) {
    remove();
    return;
  }
  dir=player.getLocation().getDirection().clone().normalize().multiply(1.5);
  dir.setY(0);
  double distance=loc.getY() - (double)groundBlock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 1.75) {
    dir.setY(-.50 * dx * dx);
  }
 else   if (distance < 1) {
    dir.setY(.50 * dx * dx);
  }
 else {
    dir.setY(0);
  }
  loc.add(dir);
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,(byte)0),1F,0.1F,1F,0.1F,100,loc.add(0,-1,0),500);
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!player.isSneaking()) {
    remove();
    return;
  }
  if (loc.distance(startLoc) >= selectRange) {
    remove();
    return;
  }
  for (  Entity e : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
    if (e.getEntityId() != player.getEntityId() && e instanceof LivingEntity) {
      closestEntity=e;
      formDome();
      remove();
      return;
    }
  }
  if (random.nextInt(2) == 0) {
    playEarthbendingSound(loc);
  }
}","@Override public void progress(){
  getGround();
  bPlayer.addCooldown(this);
  if (groundBlock == null) {
    remove();
    return;
  }
  dir=dir.clone().normalize().multiply(1.5);
  dir.setY(0);
  double distance=loc.getY() - (double)groundBlock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 1.75) {
    dir.setY(-.50 * dx * dx);
  }
 else   if (distance < 1) {
    dir.setY(.50 * dx * dx);
  }
 else {
    dir.setY(0);
  }
  loc.add(dir);
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,blockByte),1F,0.1F,1F,0.1F,100,loc.add(0,-1,0),500);
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!player.isSneaking()) {
    remove();
    return;
  }
  if (loc.distance(startLoc) >= selectRange) {
    remove();
    return;
  }
  for (  Entity e : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
    if (e.getEntityId() != player.getEntityId() && e instanceof LivingEntity) {
      closestEntity=e;
      formDome();
      remove();
      return;
    }
  }
  if (random.nextInt(2) == 0) {
    playEarthbendingSound(loc);
  }
}",0.9773123909249564
133835,"public void earthGrabSelf(){
  closestEntity=player;
  getGround();
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,(byte)0),1F,1F,1F,0.1F,100,player.getLocation(),500);
  if (closestEntity != null) {
    ArrayList<Block> blocks=new ArrayList<Block>();
    Location location=closestEntity.getLocation();
    Location loc1=location.clone();
    Location loc2=location.clone();
    Location testLoc, testLoc2;
    double factor=3;
    double factor2=4;
    int height1=3;
    int height2=2;
    for (double angle=0; angle <= 360; angle+=20) {
      testLoc=loc1.clone().add(factor * Math.cos(Math.toRadians(angle)),1,factor * Math.sin(Math.toRadians(angle)));
      testLoc2=loc2.clone().add(factor2 * Math.cos(Math.toRadians(angle)),1,factor2 * Math.sin(Math.toRadians(angle)));
      for (int y=0; y < height - height1; y++) {
        testLoc=testLoc.clone().add(0,-1,0);
        if (isEarthbendable(testLoc.getBlock())) {
          if (!blocks.contains(testLoc.getBlock())) {
            new RaiseEarth(player,testLoc,height1 + y - 1);
          }
          blocks.add(testLoc.getBlock());
          break;
        }
      }
      for (int y=0; y < height - height2; y++) {
        testLoc2=testLoc2.clone().add(0,-1,0);
        if (isEarthbendable(testLoc2.getBlock())) {
          if (!blocks.contains(testLoc2.getBlock())) {
            new RaiseEarth(player,testLoc2,height2 + y - 1);
          }
          blocks.add(testLoc2.getBlock());
          break;
        }
      }
    }
    bPlayer.addCooldown(this);
  }
}","public void earthGrabSelf(){
  closestEntity=player;
  getGround();
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,blockByte),1F,1F,1F,0.1F,100,player.getLocation(),500);
  if (closestEntity != null) {
    ArrayList<Block> blocks=new ArrayList<Block>();
    Location location=closestEntity.getLocation();
    Location loc1=location.clone();
    Location loc2=location.clone();
    Location testLoc, testLoc2;
    double factor=3;
    double factor2=4;
    int height1=3;
    int height2=2;
    for (double angle=0; angle <= 360; angle+=20) {
      testLoc=loc1.clone().add(factor * Math.cos(Math.toRadians(angle)),1,factor * Math.sin(Math.toRadians(angle)));
      testLoc2=loc2.clone().add(factor2 * Math.cos(Math.toRadians(angle)),1,factor2 * Math.sin(Math.toRadians(angle)));
      for (int y=0; y < height - height1; y++) {
        testLoc=testLoc.clone().add(0,-1,0);
        if (isEarthbendable(testLoc.getBlock())) {
          if (!blocks.contains(testLoc.getBlock())) {
            new RaiseEarth(player,testLoc,height1 + y - 1);
          }
          blocks.add(testLoc.getBlock());
          break;
        }
      }
      for (int y=0; y < height - height2; y++) {
        testLoc2=testLoc2.clone().add(0,-1,0);
        if (isEarthbendable(testLoc2.getBlock())) {
          if (!blocks.contains(testLoc2.getBlock())) {
            new RaiseEarth(player,testLoc2,height2 + y - 1);
          }
          blocks.add(testLoc2.getBlock());
          break;
        }
      }
    }
    bPlayer.addCooldown(this);
  }
}",0.9949367088607596
133836,"public static void stopBending(){
  BlazeArc.removeAllCleanup();
  for (  Location loc : TEMP_FIRE.keySet()) {
    revertTempFire(loc);
  }
}","public static void stopBending(){
  BlazeArc.removeAllCleanup();
  HeatControlSolidify.revertAllInstances();
  for (  Location loc : TEMP_FIRE.keySet()) {
    revertTempFire(loc);
  }
}",0.8650306748466258
133837,"@Override public void remove(){
  ProjectKorra.plugin.getServer().getScheduler().scheduleSyncDelayedTask(ProjectKorra.plugin,new Runnable(){
    @Override public void run(){
      revertAll();
      HeatControlSolidify.super.remove();
    }
  }
,revertTime);
}","@Override public void remove(){
  if (Bukkit.getServer().getPluginManager().isPluginEnabled(ProjectKorra.plugin.getName())) {
    revert();
  }
 else {
    HeatControlSolidify.super.remove();
  }
}",0.5426695842450766
133838,"public void progress(){
  if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!charging) {
    if (elements.isEmpty()) {
      remove();
      return;
    }
    advanceSwipe();
  }
 else {
    if (!player.isSneaking()) {
      double factor=1;
      if (System.currentTimeMillis() >= getStartTime() + maxChargeTime) {
        factor=maxChargeFactor;
      }
 else       if (bPlayer.isAvatarState()) {
        factor=AvatarState.getValue(factor);
      }
 else {
        factor=maxChargeFactor * (double)(System.currentTimeMillis() - getStartTime()) / (double)maxChargeTime;
      }
      charging=false;
      launch();
      factor=Math.max(1,factor);
      damage*=factor;
      pushFactor*=factor;
    }
 else     if (System.currentTimeMillis() >= getStartTime() + maxChargeTime) {
      playAirbendingParticles(player.getEyeLocation(),particles);
    }
  }
}","public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!charging) {
    if (elements.isEmpty()) {
      remove();
      return;
    }
    advanceSwipe();
  }
 else {
    if (!player.isSneaking()) {
      double factor=1;
      if (System.currentTimeMillis() >= getStartTime() + maxChargeTime) {
        factor=maxChargeFactor;
      }
 else       if (bPlayer.isAvatarState()) {
        factor=AvatarState.getValue(factor);
      }
 else {
        factor=maxChargeFactor * (double)(System.currentTimeMillis() - getStartTime()) / (double)maxChargeTime;
      }
      charging=false;
      launch();
      factor=Math.max(1,factor);
      damage*=factor;
      pushFactor*=factor;
    }
 else     if (System.currentTimeMillis() >= getStartTime() + maxChargeTime) {
      playAirbendingParticles(player.getEyeLocation(),particles);
    }
  }
}",0.9974240082431736
133839,"public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    ArrayList<String> helpLines=new ArrayList<String>();
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",helpLines);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",120000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}","public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    ArrayList<String> helpLines=new ArrayList<String>();
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    helpLines.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",helpLines);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",120000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}",0.9999033667040316
133840,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreCooldowns(this) || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  if (GeneralMethods.isSolid(block) || block.isLiquid()) {
    if (block.getType() == Material.FURNACE && powerFurnace) {
      Furnace furnace=(Furnace)block.getState();
      furnace.setBurnTime((short)800);
      furnace.setCookTime((short)800);
      furnace.update();
    }
 else     if (BlazeArc.isIgnitable(player,block.getRelative(BlockFace.UP))) {
      if ((isFireBurst && fireBurstIgnite) || !isFireBurst) {
        ignite(location);
      }
    }
    remove();
    return;
  }
  if (location.distanceSquared(origin) > range * range) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
    affect(entity);
    if (entity instanceof LivingEntity) {
      break;
    }
  }
  advanceLocation();
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this) || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  if (GeneralMethods.isSolid(block) || block.isLiquid()) {
    if (block.getType() == Material.FURNACE && powerFurnace) {
      Furnace furnace=(Furnace)block.getState();
      furnace.setBurnTime((short)800);
      furnace.setCookTime((short)800);
      furnace.update();
    }
 else     if (BlazeArc.isIgnitable(player,block.getRelative(BlockFace.UP))) {
      if ((isFireBurst && fireBurstIgnite) || !isFireBurst) {
        ignite(location);
      }
    }
    remove();
    return;
  }
  if (location.distanceSquared(origin) > range * range) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
    affect(entity);
    if (entity instanceof LivingEntity) {
      break;
    }
  }
  advanceLocation();
}",0.9977467327625056
133841,"private void applyHealing(LivingEntity livingEntity){
  if (livingEntity.getHealth() < livingEntity.getMaxHealth()) {
    livingEntity.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION,duration,1));
    AirAbility.breakBreathbendingHold(livingEntity);
    healing=true;
    healingSelf=false;
  }
}","private void applyHealing(LivingEntity livingEntity){
  if (livingEntity.getHealth() < livingEntity.getMaxHealth()) {
    livingEntity.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION,duration,power));
    AirAbility.breakBreathbendingHold(livingEntity);
    healing=true;
    healingSelf=false;
  }
}",0.9904153354632588
133842,"public static boolean isObstructed(Location location1,Location location2){
  Vector loc1=location1.toVector();
  Vector loc2=location2.toVector();
  Vector direction=loc2.subtract(loc1);
  direction.normalize();
  Location loc;
  double max=location1.distance(location2);
  for (double i=0; i <= max; i++) {
    loc=location1.clone().add(direction.clone().multiply(i));
    Material type=loc.getBlock().getType();
    if (type != Material.AIR && !(Arrays.asList(ElementalAbility.getTransparentMaterialSet()).contains(type.getId()) || ElementalAbility.isWater(loc.getBlock()))) {
      return true;
    }
  }
  return false;
}","public static boolean isObstructed(Location location1,Location location2){
  Vector loc1=location1.toVector();
  Vector loc2=location2.toVector();
  Vector direction=loc2.subtract(loc1);
  direction.normalize();
  Location loc;
  double max=0;
  if (location1.getWorld().equals(location2.getWorld()))   max=location1.distance(location2);
  for (double i=0; i <= max; i++) {
    loc=location1.clone().add(direction.clone().multiply(i));
    Material type=loc.getBlock().getType();
    if (type != Material.AIR && !(Arrays.asList(ElementalAbility.getTransparentMaterialSet()).contains(type.getId()) || ElementalAbility.isWater(loc.getBlock()))) {
      return true;
    }
  }
  return false;
}",0.9498480243161094
133843,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerMove(PlayerMoveEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  if (Paralyze.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (CoreAbility.hasAbility(player,WaterSpout.class) || CoreAbility.hasAbility(player,AirSpout.class) || CoreAbility.hasAbility(player,SandSpout.class)) {
    Vector vel=new Vector();
    vel.setX(event.getTo().getX() - event.getFrom().getX());
    vel.setZ(event.getTo().getZ() - event.getFrom().getZ());
    double currspeed=vel.length();
    double maxspeed=.2;
    if (currspeed > maxspeed) {
      vel=vel.normalize().multiply(maxspeed);
      event.getPlayer().setVelocity(vel);
    }
  }
 else   if (Bloodbending.isBloodbent(player)) {
    double distance1, distance2;
    Location loc=Bloodbending.getBloodbendingLocation(player);
    distance1=event.getFrom().distance(loc);
    distance2=event.getTo().distance(loc);
    if (distance2 > distance1) {
      player.setVelocity(new Vector(0,0,0));
    }
  }
 else   if (AirFlight.isFlying(event.getPlayer())) {
    if (AirFlight.isHovering(event.getPlayer())) {
      Location loc=event.getFrom();
      Location toLoc=player.getLocation();
      if (loc.getX() != toLoc.getX() || loc.getY() != toLoc.getY() || loc.getZ() != toLoc.getZ()) {
        event.setCancelled(true);
        return;
      }
    }
  }
 else {
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer != null) {
      if (bPlayer.hasElement(Element.AIR) || bPlayer.hasElement(Element.CHI) || bPlayer.hasElement(Element.EARTH)) {
        PassiveHandler.checkSpeedPassives(player);
      }
      if (bPlayer.hasElement(Element.AIR) || bPlayer.hasElement(Element.CHI)) {
        PassiveHandler.checkJumpPassives(player);
        PassiveHandler.checkExhaustionPassives(player);
      }
    }
  }
  if (event.getTo().getY() > event.getFrom().getY()) {
    if (!(player.getLocation().getBlock().getType() == Material.VINE) && !(player.getLocation().getBlock().getType() == Material.LADDER)) {
      int current=player.getStatistic(Statistic.JUMP);
      int last=JUMPS.get(player);
      if (last != current) {
        JUMPS.put(player,current);
        double yDif=event.getTo().getY() - event.getFrom().getY();
        if ((yDif < 0.035 || yDif > 0.037) && (yDif < 0.116 || yDif > 0.118)) {
          Bukkit.getServer().getPluginManager().callEvent(new PlayerJumpEvent(player,yDif));
        }
      }
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerMove(PlayerMoveEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  if (Paralyze.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (CoreAbility.hasAbility(player,WaterSpout.class) || CoreAbility.hasAbility(player,AirSpout.class) || CoreAbility.hasAbility(player,SandSpout.class)) {
    Vector vel=new Vector();
    vel.setX(event.getTo().getX() - event.getFrom().getX());
    vel.setZ(event.getTo().getZ() - event.getFrom().getZ());
    double currspeed=vel.length();
    double maxspeed=.2;
    if (currspeed > maxspeed) {
      vel=vel.normalize().multiply(maxspeed);
      event.getPlayer().setVelocity(vel);
    }
  }
 else   if (Bloodbending.isBloodbent(player)) {
    double distance1=0;
    double distance2=0;
    Location loc=Bloodbending.getBloodbendingLocation(player);
    if (event.getPlayer().getWorld().equals(loc.getWorld()))     distance1=event.getFrom().distance(loc);
    distance2=event.getTo().distance(loc);
    if (distance2 > distance1) {
      player.setVelocity(new Vector(0,0,0));
    }
  }
 else   if (AirFlight.isFlying(event.getPlayer())) {
    if (AirFlight.isHovering(event.getPlayer())) {
      Location loc=event.getFrom();
      Location toLoc=player.getLocation();
      if (loc.getX() != toLoc.getX() || loc.getY() != toLoc.getY() || loc.getZ() != toLoc.getZ()) {
        event.setCancelled(true);
        return;
      }
    }
  }
 else {
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer != null) {
      if (bPlayer.hasElement(Element.AIR) || bPlayer.hasElement(Element.CHI) || bPlayer.hasElement(Element.EARTH)) {
        PassiveHandler.checkSpeedPassives(player);
      }
      if (bPlayer.hasElement(Element.AIR) || bPlayer.hasElement(Element.CHI)) {
        PassiveHandler.checkJumpPassives(player);
        PassiveHandler.checkExhaustionPassives(player);
      }
    }
  }
  if (event.getTo().getY() > event.getFrom().getY()) {
    if (!(player.getLocation().getBlock().getType() == Material.VINE) && !(player.getLocation().getBlock().getType() == Material.LADDER)) {
      int current=player.getStatistic(Statistic.JUMP);
      int last=JUMPS.get(player);
      if (last != current) {
        JUMPS.put(player,current);
        double yDif=event.getTo().getY() - event.getFrom().getY();
        if ((yDif < 0.035 || yDif > 0.037) && (yDif < 0.116 || yDif > 0.118)) {
          Bukkit.getServer().getPluginManager().callEvent(new PlayerJumpEvent(player,yDif));
        }
      }
    }
  }
}",0.9854368932038836
133844,"private void affect(Entity entity){
  boolean isUser=entity.getUniqueId() == player.getUniqueId();
  if (!isUser || isFromOtherOrigin) {
    pushFactor=pushFactorForOthers;
    Vector velocity=entity.getVelocity();
    double max=speed / speedFactor;
    double factor=pushFactor;
    if (bPlayer.isAvatarState()) {
      max=AvatarState.getValue(max);
      factor=AvatarState.getValue(factor);
    }
    Vector push=direction.clone();
    if (Math.abs(push.getY()) > max && !isUser) {
      if (push.getY() < 0) {
        push.setY(-max);
      }
 else {
        push.setY(max);
      }
    }
    factor*=1 - location.distance(origin) / (2 * range);
    if (isUser && GeneralMethods.isSolid(player.getLocation().add(0,-.5,0).getBlock())) {
      factor*=.5;
    }
    double comp=velocity.dot(push.clone().normalize());
    if (comp > factor) {
      velocity.multiply(.5);
      velocity.add(push.clone().normalize().multiply(velocity.clone().dot(push.clone().normalize())));
    }
 else     if (comp + factor * .5 > factor) {
      velocity.add(push.clone().multiply(factor - comp));
    }
 else {
      velocity.add(push.clone().multiply(factor * .5));
    }
    if (entity instanceof Player) {
      if (Commands.invincible.contains(((Player)entity).getName())) {
        return;
      }
    }
    if (Double.isNaN(velocity.length())) {
      return;
    }
    GeneralMethods.setVelocity(entity,velocity);
    if (source != null) {
      new HorizontalVelocityTracker(entity,player,200l,CoreAbility.getAbility(""String_Node_Str""));
    }
 else {
      new HorizontalVelocityTracker(entity,player,200l,this);
    }
    if (!isUser && entity instanceof Player) {
      new Flight((Player)entity,player);
    }
    if (entity.getFireTicks() > 0) {
      entity.getWorld().playEffect(entity.getLocation(),Effect.EXTINGUISH,0);
    }
    entity.setFireTicks(0);
    breakBreathbendingHold(entity);
    if (source != null && (this.damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,CoreAbility.getAbility(""String_Node_Str""));
      affectedEntities.add(entity);
    }
 else     if (source == null && (damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,this);
      affectedEntities.add(entity);
    }
  }
}","private void affect(Entity entity){
  boolean isUser=entity.getUniqueId() == player.getUniqueId();
  if (!isUser || isFromOtherOrigin) {
    pushFactor=pushFactorForOthers;
    Vector velocity=entity.getVelocity();
    double max=speed / speedFactor;
    double factor=pushFactor;
    if (bPlayer.isAvatarState()) {
      max=AvatarState.getValue(max);
      factor=AvatarState.getValue(factor);
    }
    Vector push=direction.clone();
    if (Math.abs(push.getY()) > max && !isUser) {
      if (push.getY() < 0) {
        push.setY(-max);
      }
 else {
        push.setY(max);
      }
    }
    if (location.getWorld().equals(origin.getWorld())) {
      factor*=1 - location.distance(origin) / (2 * range);
    }
    if (isUser && GeneralMethods.isSolid(player.getLocation().add(0,-.5,0).getBlock())) {
      factor*=.5;
    }
    double comp=velocity.dot(push.clone().normalize());
    if (comp > factor) {
      velocity.multiply(.5);
      velocity.add(push.clone().normalize().multiply(velocity.clone().dot(push.clone().normalize())));
    }
 else     if (comp + factor * .5 > factor) {
      velocity.add(push.clone().multiply(factor - comp));
    }
 else {
      velocity.add(push.clone().multiply(factor * .5));
    }
    if (entity instanceof Player) {
      if (Commands.invincible.contains(((Player)entity).getName())) {
        return;
      }
    }
    if (Double.isNaN(velocity.length())) {
      return;
    }
    GeneralMethods.setVelocity(entity,velocity);
    if (source != null) {
      new HorizontalVelocityTracker(entity,player,200l,CoreAbility.getAbility(""String_Node_Str""));
    }
 else {
      new HorizontalVelocityTracker(entity,player,200l,this);
    }
    if (!isUser && entity instanceof Player) {
      new Flight((Player)entity,player);
    }
    if (entity.getFireTicks() > 0) {
      entity.getWorld().playEffect(entity.getLocation(),Effect.EXTINGUISH,0);
    }
    entity.setFireTicks(0);
    breakBreathbendingHold(entity);
    if (source != null && (this.damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,CoreAbility.getAbility(""String_Node_Str""));
      affectedEntities.add(entity);
    }
 else     if (source == null && (damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,this);
      affectedEntities.add(entity);
    }
  }
}",0.9869136299577208
133845,"@SuppressWarnings(""String_Node_Str"") @Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  for (  Block testblock : GeneralMethods.getBlocksAroundPoint(location,radius)) {
    if (testblock.getType() == Material.FIRE) {
      testblock.setType(Material.AIR);
      testblock.getWorld().playEffect(testblock.getLocation(),Effect.EXTINGUISH,0);
    }
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
      continue;
    }
    Material doorTypes[]={Material.WOODEN_DOOR,Material.SPRUCE_DOOR,Material.BIRCH_DOOR,Material.JUNGLE_DOOR,Material.ACACIA_DOOR,Material.DARK_OAK_DOOR};
    if (Arrays.asList(doorTypes).contains(block.getType()) && canOpenDoors) {
      if (block.getData() >= 8) {
        block=block.getRelative(BlockFace.DOWN);
      }
      if (block.getData() < 4) {
        block.setData((byte)(block.getData() + 4));
        block.getWorld().playSound(block.getLocation(),Sound.BLOCK_WOODEN_DOOR_CLOSE,10,1);
      }
 else {
        block.setData((byte)(block.getData() - 4));
        block.getWorld().playSound(block.getLocation(),Sound.BLOCK_WOODEN_DOOR_OPEN,10,1);
      }
    }
    if ((block.getType() == Material.LEVER) && !affectedLevers.contains(block) && canFlickLevers) {
      Lever lever=new Lever(Material.LEVER,block.getData());
      lever.setPowered(!lever.isPowered());
      block.setData(lever.getData());
      Block supportBlock=block.getRelative(lever.getAttachedFace());
      if (supportBlock != null && supportBlock.getType() != Material.AIR) {
        BlockState initialSupportState=supportBlock.getState();
        BlockState supportState=supportBlock.getState();
        supportState.setType(Material.AIR);
        supportState.update(true,false);
        initialSupportState.update(true);
      }
      affectedLevers.add(block);
    }
 else     if ((block.getType() == Material.STONE_BUTTON) && !affectedLevers.contains(block) && canPressButtons) {
      final Button button=new Button(Material.STONE_BUTTON,block.getData());
      button.setPowered(!button.isPowered());
      block.setData(button.getData());
      Block supportBlock=block.getRelative(button.getAttachedFace());
      if (supportBlock != null && supportBlock.getType() != Material.AIR) {
        BlockState initialSupportState=supportBlock.getState();
        BlockState supportState=supportBlock.getState();
        supportState.setType(Material.AIR);
        supportState.update(true,false);
        initialSupportState.update(true);
      }
      final Block btBlock=block;
      new BukkitRunnable(){
        public void run(){
          button.setPowered(!button.isPowered());
          btBlock.setData(button.getData());
          Block supportBlock=btBlock.getRelative(button.getAttachedFace());
          if (supportBlock != null && supportBlock.getType() != Material.AIR) {
            BlockState initialSupportState=supportBlock.getState();
            BlockState supportState=supportBlock.getState();
            supportState.setType(Material.AIR);
            supportState.update(true,false);
            initialSupportState.update(true);
          }
        }
      }
.runTaskLater(ProjectKorra.plugin,10);
      affectedLevers.add(block);
    }
 else     if ((block.getType() == Material.WOOD_BUTTON) && !affectedLevers.contains(block) && canPressButtons) {
      final Button button=new Button(Material.WOOD_BUTTON,block.getData());
      button.setPowered(!button.isPowered());
      block.setData(button.getData());
      Block supportBlock=block.getRelative(button.getAttachedFace());
      if (supportBlock != null && supportBlock.getType() != Material.AIR) {
        BlockState initialSupportState=supportBlock.getState();
        BlockState supportState=supportBlock.getState();
        supportState.setType(Material.AIR);
        supportState.update(true,false);
        initialSupportState.update(true);
      }
      final Block btBlock=block;
      new BukkitRunnable(){
        public void run(){
          button.setPowered(!button.isPowered());
          btBlock.setData(button.getData());
          Block supportBlock=btBlock.getRelative(button.getAttachedFace());
          if (supportBlock != null && supportBlock.getType() != Material.AIR) {
            BlockState initialSupportState=supportBlock.getState();
            BlockState supportState=supportBlock.getState();
            supportState.setType(Material.AIR);
            supportState.update(true,false);
            initialSupportState.update(true);
          }
        }
      }
.runTaskLater(ProjectKorra.plugin,15);
      affectedLevers.add(block);
    }
  }
  if ((GeneralMethods.isSolid(block) || block.isLiquid()) && !affectedLevers.contains(block) && canCoolLava) {
    if (block.getType() == Material.LAVA || block.getType() == Material.STATIONARY_LAVA) {
      if (block.getData() == 0x0) {
        block.setType(Material.OBSIDIAN);
      }
 else {
        block.setType(Material.COBBLESTONE);
      }
    }
    remove();
    return;
  }
  double dist=location.distance(origin);
  if (Double.isNaN(dist) || dist > range) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,radius)) {
    affect(entity);
  }
  advanceLocation();
  return;
}","@SuppressWarnings(""String_Node_Str"") @Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  for (  Block testblock : GeneralMethods.getBlocksAroundPoint(location,radius)) {
    if (testblock.getType() == Material.FIRE) {
      testblock.setType(Material.AIR);
      testblock.getWorld().playEffect(testblock.getLocation(),Effect.EXTINGUISH,0);
    }
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
      continue;
    }
    Material doorTypes[]={Material.WOODEN_DOOR,Material.SPRUCE_DOOR,Material.BIRCH_DOOR,Material.JUNGLE_DOOR,Material.ACACIA_DOOR,Material.DARK_OAK_DOOR};
    if (Arrays.asList(doorTypes).contains(block.getType()) && canOpenDoors) {
      if (block.getData() >= 8) {
        block=block.getRelative(BlockFace.DOWN);
      }
      if (block.getData() < 4) {
        block.setData((byte)(block.getData() + 4));
        block.getWorld().playSound(block.getLocation(),Sound.BLOCK_WOODEN_DOOR_CLOSE,10,1);
      }
 else {
        block.setData((byte)(block.getData() - 4));
        block.getWorld().playSound(block.getLocation(),Sound.BLOCK_WOODEN_DOOR_OPEN,10,1);
      }
    }
    if ((block.getType() == Material.LEVER) && !affectedLevers.contains(block) && canFlickLevers) {
      Lever lever=new Lever(Material.LEVER,block.getData());
      lever.setPowered(!lever.isPowered());
      block.setData(lever.getData());
      Block supportBlock=block.getRelative(lever.getAttachedFace());
      if (supportBlock != null && supportBlock.getType() != Material.AIR) {
        BlockState initialSupportState=supportBlock.getState();
        BlockState supportState=supportBlock.getState();
        supportState.setType(Material.AIR);
        supportState.update(true,false);
        initialSupportState.update(true);
      }
      affectedLevers.add(block);
    }
 else     if ((block.getType() == Material.STONE_BUTTON) && !affectedLevers.contains(block) && canPressButtons) {
      final Button button=new Button(Material.STONE_BUTTON,block.getData());
      button.setPowered(!button.isPowered());
      block.setData(button.getData());
      Block supportBlock=block.getRelative(button.getAttachedFace());
      if (supportBlock != null && supportBlock.getType() != Material.AIR) {
        BlockState initialSupportState=supportBlock.getState();
        BlockState supportState=supportBlock.getState();
        supportState.setType(Material.AIR);
        supportState.update(true,false);
        initialSupportState.update(true);
      }
      final Block btBlock=block;
      new BukkitRunnable(){
        public void run(){
          button.setPowered(!button.isPowered());
          btBlock.setData(button.getData());
          Block supportBlock=btBlock.getRelative(button.getAttachedFace());
          if (supportBlock != null && supportBlock.getType() != Material.AIR) {
            BlockState initialSupportState=supportBlock.getState();
            BlockState supportState=supportBlock.getState();
            supportState.setType(Material.AIR);
            supportState.update(true,false);
            initialSupportState.update(true);
          }
        }
      }
.runTaskLater(ProjectKorra.plugin,10);
      affectedLevers.add(block);
    }
 else     if ((block.getType() == Material.WOOD_BUTTON) && !affectedLevers.contains(block) && canPressButtons) {
      final Button button=new Button(Material.WOOD_BUTTON,block.getData());
      button.setPowered(!button.isPowered());
      block.setData(button.getData());
      Block supportBlock=block.getRelative(button.getAttachedFace());
      if (supportBlock != null && supportBlock.getType() != Material.AIR) {
        BlockState initialSupportState=supportBlock.getState();
        BlockState supportState=supportBlock.getState();
        supportState.setType(Material.AIR);
        supportState.update(true,false);
        initialSupportState.update(true);
      }
      final Block btBlock=block;
      new BukkitRunnable(){
        public void run(){
          button.setPowered(!button.isPowered());
          btBlock.setData(button.getData());
          Block supportBlock=btBlock.getRelative(button.getAttachedFace());
          if (supportBlock != null && supportBlock.getType() != Material.AIR) {
            BlockState initialSupportState=supportBlock.getState();
            BlockState supportState=supportBlock.getState();
            supportState.setType(Material.AIR);
            supportState.update(true,false);
            initialSupportState.update(true);
          }
        }
      }
.runTaskLater(ProjectKorra.plugin,15);
      affectedLevers.add(block);
    }
  }
  if ((GeneralMethods.isSolid(block) || block.isLiquid()) && !affectedLevers.contains(block) && canCoolLava) {
    if (block.getType() == Material.LAVA || block.getType() == Material.STATIONARY_LAVA) {
      if (block.getData() == 0x0) {
        block.setType(Material.OBSIDIAN);
      }
 else {
        block.setType(Material.COBBLESTONE);
      }
    }
    remove();
    return;
  }
  double dist=0;
  if (location.getWorld().equals(origin.getWorld())) {
    dist=location.distance(origin);
  }
  if (Double.isNaN(dist) || dist > range) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,radius)) {
    affect(entity);
  }
  advanceLocation();
  return;
}",0.9889991950630534
133846,"public static boolean removeAroundPoint(Player player,String ability,Location loc,double radius){
  boolean removed=false;
  for (  AirCombo combo : getAbilities(AirCombo.class)) {
    if (combo.getPlayer().equals(player)) {
      continue;
    }
 else     if (ability.equalsIgnoreCase(""String_Node_Str"") && combo.abilityName.equalsIgnoreCase(""String_Node_Str"")) {
      if (combo.currentLoc != null && Math.abs(combo.currentLoc.distance(loc)) <= radius) {
        combo.remove();
        removed=true;
      }
    }
 else     if (ability.equalsIgnoreCase(""String_Node_Str"") && combo.abilityName.equalsIgnoreCase(""String_Node_Str"")) {
      if (combo.currentLoc != null && Math.abs(combo.currentLoc.distance(loc)) <= radius) {
        combo.remove();
        removed=true;
      }
    }
 else     if (ability.equalsIgnoreCase(""String_Node_Str"") && combo.abilityName.equalsIgnoreCase(""String_Node_Str"")) {
      for (int j=0; j < combo.tasks.size(); j++) {
        FireComboStream fs=(FireComboStream)combo.tasks.get(j);
        if (fs.getLocation() != null && fs.getLocation().getWorld().equals(loc.getWorld()) && Math.abs(fs.getLocation().distance(loc)) <= radius) {
          fs.remove();
          removed=true;
        }
      }
    }
  }
  return removed;
}","public static boolean removeAroundPoint(Player player,String ability,Location loc,double radius){
  boolean removed=false;
  for (  AirCombo combo : getAbilities(AirCombo.class)) {
    if (combo.getPlayer().equals(player)) {
      continue;
    }
 else     if (ability.equalsIgnoreCase(""String_Node_Str"") && combo.abilityName.equalsIgnoreCase(""String_Node_Str"")) {
      if (combo.currentLoc != null && combo.currentLoc.getWorld().equals(loc.getWorld()) && Math.abs(combo.currentLoc.distance(loc)) <= radius) {
        combo.remove();
        removed=true;
      }
    }
 else     if (ability.equalsIgnoreCase(""String_Node_Str"") && combo.abilityName.equalsIgnoreCase(""String_Node_Str"")) {
      if (combo.currentLoc != null && combo.currentLoc.getWorld().equals(loc.getWorld()) && Math.abs(combo.currentLoc.distance(loc)) <= radius) {
        combo.remove();
        removed=true;
      }
    }
 else     if (ability.equalsIgnoreCase(""String_Node_Str"") && combo.abilityName.equalsIgnoreCase(""String_Node_Str"")) {
      for (int j=0; j < combo.tasks.size(); j++) {
        FireComboStream fs=(FireComboStream)combo.tasks.get(j);
        if (fs.getLocation() != null && fs.getLocation().getWorld().equals(loc.getWorld()) && Math.abs(fs.getLocation().distance(loc)) <= radius) {
          fs.remove();
          removed=true;
        }
      }
    }
  }
  return removed;
}",0.958966565349544
133847,"@Override public void progress(){
  progressCounter++;
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (currentLoc != null && GeneralMethods.isRegionProtectedFromBuild(this,currentLoc)) {
    remove();
    return;
  }
  if (abilityName.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      state=AbilityState.TWISTER_MOVING;
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
      origin=player.getLocation().add(direction.clone().multiply(2));
      destination=player.getLocation().add(direction.clone().multiply(range));
      currentLoc=origin.clone();
    }
    if (origin.distanceSquared(currentLoc) < origin.distanceSquared(destination) && state == AbilityState.TWISTER_MOVING) {
      currentLoc.add(direction.clone().multiply(speed));
    }
 else     if (state == AbilityState.TWISTER_MOVING) {
      state=AbilityState.TWISTER_STATIONARY;
      time=System.currentTimeMillis();
    }
 else     if (System.currentTimeMillis() - time >= twisterRemoveDelay) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(this,currentLoc)) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(currentLoc,3,-3);
    if (topBlock == null) {
      remove();
      return;
    }
    currentLoc.setY(topBlock.getLocation().getY());
    double height=twisterHeight;
    double radius=twisterRadius;
    for (double y=0; y < height; y+=twisterHeightParticles) {
      double animRadius=((radius / height) * y);
      for (double i=-180; i <= 180; i+=twisterDegreeParticles) {
        Vector animDir=GeneralMethods.rotateXZ(new Vector(1,0,1),i);
        Location animLoc=currentLoc.clone().add(animDir.multiply(animRadius));
        animLoc.add(0,y,0);
        playAirbendingParticles(animLoc,1,0,0,0);
      }
    }
    playAirbendingSound(currentLoc);
    for (int i=0; i < height; i+=3) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc.clone().add(0,i,0),radius * 0.75)) {
        if (!affectedEntities.contains(entity) && !entity.equals(player)) {
          affectedEntities.add(entity);
        }
      }
    }
    for (    Entity entity : affectedEntities) {
      Vector forceDir=GeneralMethods.getDirection(entity.getLocation(),currentLoc.clone().add(0,height,0));
      if (entity instanceof Player) {
        if (Commands.invincible.contains(((Player)entity).getName())) {
          break;
        }
      }
      entity.setVelocity(forceDir.clone().normalize().multiply(0.3));
    }
  }
 else   if (abilityName.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      origin=player.getEyeLocation();
      currentLoc=origin.clone();
    }
    Entity target=GeneralMethods.getTargetedEntity(player,range);
    if (target instanceof Player) {
      if (Commands.invincible.contains(((Player)target).getName())) {
        return;
      }
    }
    if (target != null && target.getLocation().distanceSquared(currentLoc) > 49) {
      destination=target.getLocation();
    }
 else {
      destination=GeneralMethods.getTargetedLocation(player,range,getTransparentMaterial());
    }
    direction=GeneralMethods.getDirection(currentLoc,destination).normalize();
    currentLoc.add(direction.clone().multiply(speed));
    if (player.getWorld() != currentLoc.getWorld()) {
      remove();
      return;
    }
 else     if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (Math.abs(player.getLocation().distanceSquared(currentLoc)) > range * range) {
      remove();
      return;
    }
 else     if (affectedEntities.size() > 0 && System.currentTimeMillis() - time >= airStreamEntityCarryDuration) {
      remove();
      return;
    }
 else     if (!isTransparent(currentLoc.getBlock())) {
      remove();
      return;
    }
 else     if (currentLoc.getY() - origin.getY() > airStreamMaxEntityHeight) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(this,currentLoc)) {
      remove();
      return;
    }
 else     if (FireAbility.isWithinFireShield(currentLoc)) {
      remove();
      return;
    }
 else     if (isWithinAirShield(currentLoc)) {
      remove();
      return;
    }
 else     if (!isTransparent(currentLoc.getBlock())) {
      currentLoc.subtract(direction.clone().multiply(speed));
    }
    for (int i=0; i < 10; i++) {
      BukkitRunnable br=new BukkitRunnable(){
        final Location loc=currentLoc.clone();
        final Vector dir=direction.clone();
        @Override public void run(){
          for (int angle=-180; angle <= 180; angle+=45) {
            Vector orthog=GeneralMethods.getOrthogonalVector(dir.clone(),angle,0.5);
            playAirbendingParticles(loc.clone().add(orthog),1,0F,0F,0F);
          }
        }
      }
;
      br.runTaskLater(ProjectKorra.plugin,i * 2);
      tasks.add(br);
    }
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc,2.8)) {
      if (affectedEntities.size() == 0) {
        time=System.currentTimeMillis();
      }
      if (!entity.equals(player) && !affectedEntities.contains(entity)) {
        affectedEntities.add(entity);
        if (entity instanceof Player) {
          flights.add(new Flight((Player)entity,player));
        }
      }
    }
    for (    Entity entity : affectedEntities) {
      Vector force=GeneralMethods.getDirection(entity.getLocation(),currentLoc);
      entity.setVelocity(force.clone().normalize().multiply(speed));
      entity.setFallDistance(0F);
    }
  }
 else   if (abilityName.equalsIgnoreCase(""String_Node_Str"")) {
    if (origin == null) {
      direction=player.getEyeLocation().getDirection().normalize();
      origin=player.getLocation().add(direction.clone().multiply(10));
    }
    if (progressCounter < 8) {
      return;
    }
    if (destination == null) {
      destination=player.getLocation().add(player.getEyeLocation().getDirection().normalize().multiply(10));
      Vector origToDest=GeneralMethods.getDirection(origin,destination);
      for (double i=0; i < 30; i++) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),origin.clone().add(origToDest.clone().multiply(i / 30)));
        FireComboStream fs=new FireComboStream(null,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setDensity(1);
        fs.setSpread(0F);
        fs.setUseNewParticles(true);
        fs.setParticleEffect(getAirbendingParticles());
        fs.setCollides(false);
        fs.runTaskTimer(ProjectKorra.plugin,(long)(i / 2.5),1L);
        tasks.add(fs);
      }
    }
    manageAirVectors();
  }
}","@Override public void progress(){
  progressCounter++;
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (currentLoc != null && GeneralMethods.isRegionProtectedFromBuild(this,currentLoc)) {
    remove();
    return;
  }
  if (abilityName.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      state=AbilityState.TWISTER_MOVING;
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
      origin=player.getLocation().add(direction.clone().multiply(2));
      destination=player.getLocation().add(direction.clone().multiply(range));
      currentLoc=origin.clone();
    }
    if (origin.distanceSquared(currentLoc) < origin.distanceSquared(destination) && state == AbilityState.TWISTER_MOVING) {
      currentLoc.add(direction.clone().multiply(speed));
    }
 else     if (state == AbilityState.TWISTER_MOVING) {
      state=AbilityState.TWISTER_STATIONARY;
      time=System.currentTimeMillis();
    }
 else     if (System.currentTimeMillis() - time >= twisterRemoveDelay) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(this,currentLoc)) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(currentLoc,3,-3);
    if (topBlock == null) {
      remove();
      return;
    }
    currentLoc.setY(topBlock.getLocation().getY());
    double height=twisterHeight;
    double radius=twisterRadius;
    for (double y=0; y < height; y+=twisterHeightParticles) {
      double animRadius=((radius / height) * y);
      for (double i=-180; i <= 180; i+=twisterDegreeParticles) {
        Vector animDir=GeneralMethods.rotateXZ(new Vector(1,0,1),i);
        Location animLoc=currentLoc.clone().add(animDir.multiply(animRadius));
        animLoc.add(0,y,0);
        playAirbendingParticles(animLoc,1,0,0,0);
      }
    }
    playAirbendingSound(currentLoc);
    for (int i=0; i < height; i+=3) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc.clone().add(0,i,0),radius * 0.75)) {
        if (!affectedEntities.contains(entity) && !entity.equals(player)) {
          affectedEntities.add(entity);
        }
      }
    }
    for (    Entity entity : affectedEntities) {
      Vector forceDir=GeneralMethods.getDirection(entity.getLocation(),currentLoc.clone().add(0,height,0));
      if (entity instanceof Player) {
        if (Commands.invincible.contains(((Player)entity).getName())) {
          break;
        }
      }
      entity.setVelocity(forceDir.clone().normalize().multiply(0.3));
    }
  }
 else   if (abilityName.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      origin=player.getEyeLocation();
      currentLoc=origin.clone();
    }
    Entity target=GeneralMethods.getTargetedEntity(player,range);
    if (target instanceof Player) {
      if (Commands.invincible.contains(((Player)target).getName())) {
        return;
      }
    }
    if (target != null && target.getLocation().distanceSquared(currentLoc) > 49) {
      destination=target.getLocation();
    }
 else {
      destination=GeneralMethods.getTargetedLocation(player,range,getTransparentMaterial());
    }
    direction=GeneralMethods.getDirection(currentLoc,destination).normalize();
    currentLoc.add(direction.clone().multiply(speed));
    if (player.getWorld() != currentLoc.getWorld()) {
      remove();
      return;
    }
 else     if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (player.getWorld().equals(currentLoc.getWorld()) && Math.abs(player.getLocation().distanceSquared(currentLoc)) > range * range) {
      remove();
      return;
    }
 else     if (affectedEntities.size() > 0 && System.currentTimeMillis() - time >= airStreamEntityCarryDuration) {
      remove();
      return;
    }
 else     if (!isTransparent(currentLoc.getBlock())) {
      remove();
      return;
    }
 else     if (currentLoc.getY() - origin.getY() > airStreamMaxEntityHeight) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(this,currentLoc)) {
      remove();
      return;
    }
 else     if (FireAbility.isWithinFireShield(currentLoc)) {
      remove();
      return;
    }
 else     if (isWithinAirShield(currentLoc)) {
      remove();
      return;
    }
 else     if (!isTransparent(currentLoc.getBlock())) {
      currentLoc.subtract(direction.clone().multiply(speed));
    }
    for (int i=0; i < 10; i++) {
      BukkitRunnable br=new BukkitRunnable(){
        final Location loc=currentLoc.clone();
        final Vector dir=direction.clone();
        @Override public void run(){
          for (int angle=-180; angle <= 180; angle+=45) {
            Vector orthog=GeneralMethods.getOrthogonalVector(dir.clone(),angle,0.5);
            playAirbendingParticles(loc.clone().add(orthog),1,0F,0F,0F);
          }
        }
      }
;
      br.runTaskLater(ProjectKorra.plugin,i * 2);
      tasks.add(br);
    }
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc,2.8)) {
      if (affectedEntities.size() == 0) {
        time=System.currentTimeMillis();
      }
      if (!entity.equals(player) && !affectedEntities.contains(entity)) {
        affectedEntities.add(entity);
        if (entity instanceof Player) {
          flights.add(new Flight((Player)entity,player));
        }
      }
    }
    for (    Entity entity : affectedEntities) {
      Vector force=GeneralMethods.getDirection(entity.getLocation(),currentLoc);
      entity.setVelocity(force.clone().normalize().multiply(speed));
      entity.setFallDistance(0F);
    }
  }
 else   if (abilityName.equalsIgnoreCase(""String_Node_Str"")) {
    if (origin == null) {
      direction=player.getEyeLocation().getDirection().normalize();
      origin=player.getLocation().add(direction.clone().multiply(10));
    }
    if (progressCounter < 8) {
      return;
    }
    if (destination == null) {
      destination=player.getLocation().add(player.getEyeLocation().getDirection().normalize().multiply(10));
      Vector origToDest=GeneralMethods.getDirection(origin,destination);
      for (double i=0; i < 30; i++) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),origin.clone().add(origToDest.clone().multiply(i / 30)));
        FireComboStream fs=new FireComboStream(null,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setDensity(1);
        fs.setSpread(0F);
        fs.setUseNewParticles(true);
        fs.setParticleEffect(getAirbendingParticles());
        fs.setCollides(false);
        fs.runTaskTimer(ProjectKorra.plugin,(long)(i / 2.5),1L);
        tasks.add(fs);
      }
    }
    manageAirVectors();
  }
}",0.9961937458019255
133848,"@Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",location)) {
    remove();
    return;
  }
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
 else   if ((location.distanceSquared(origin) > range * range) || (location.distanceSquared(origin) <= 1)) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,radius)) {
    if (entity.getEntityId() != player.getEntityId() || hasOtherOrigin) {
      Vector velocity=entity.getVelocity();
      double max=speed;
      double factor=pushFactor;
      if (bPlayer.isAvatarState()) {
        max=AvatarState.getValue(max);
        factor=AvatarState.getValue(factor);
      }
      Vector push=direction.clone();
      if (Math.abs(push.getY()) > max && entity.getEntityId() != player.getEntityId()) {
        if (push.getY() < 0) {
          push.setY(-max);
        }
 else {
          push.setY(max);
        }
      }
      factor*=1 - location.distance(origin) / (2 * range);
      double comp=velocity.dot(push.clone().normalize());
      if (comp > factor) {
        velocity.multiply(.5);
        velocity.add(push.clone().normalize().multiply(velocity.clone().dot(push.clone().normalize())));
      }
 else       if (comp + factor * .5 > factor) {
        velocity.add(push.clone().multiply(factor - comp));
      }
 else {
        velocity.add(push.clone().multiply(factor * .5));
      }
      if (entity instanceof Player) {
        if (Commands.invincible.contains(((Player)entity).getName())) {
          continue;
        }
      }
      GeneralMethods.setVelocity(entity,velocity);
      new HorizontalVelocityTracker(entity,player,200l,this);
      entity.setFallDistance(0);
      if (entity.getEntityId() != player.getEntityId() && entity instanceof Player) {
        new Flight((Player)entity,player);
      }
      if (entity.getFireTicks() > 0) {
        entity.getWorld().playEffect(entity.getLocation(),Effect.EXTINGUISH,0);
      }
      entity.setFireTicks(0);
      breakBreathbendingHold(entity);
    }
  }
  advanceLocation();
}","@Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",location)) {
    remove();
    return;
  }
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
 else   if ((location.distanceSquared(origin) > range * range) || (location.distanceSquared(origin) <= 1)) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,radius)) {
    if (entity.getEntityId() != player.getEntityId() || hasOtherOrigin) {
      Vector velocity=entity.getVelocity();
      double max=speed;
      double factor=pushFactor;
      if (bPlayer.isAvatarState()) {
        max=AvatarState.getValue(max);
        factor=AvatarState.getValue(factor);
      }
      Vector push=direction.clone();
      if (Math.abs(push.getY()) > max && entity.getEntityId() != player.getEntityId()) {
        if (push.getY() < 0) {
          push.setY(-max);
        }
 else {
          push.setY(max);
        }
      }
      if (location.getWorld().equals(origin.getWorld())) {
        factor*=1 - location.distance(origin) / (2 * range);
      }
      double comp=velocity.dot(push.clone().normalize());
      if (comp > factor) {
        velocity.multiply(.5);
        velocity.add(push.clone().normalize().multiply(velocity.clone().dot(push.clone().normalize())));
      }
 else       if (comp + factor * .5 > factor) {
        velocity.add(push.clone().multiply(factor - comp));
      }
 else {
        velocity.add(push.clone().multiply(factor * .5));
      }
      if (entity instanceof Player) {
        if (Commands.invincible.contains(((Player)entity).getName())) {
          continue;
        }
      }
      GeneralMethods.setVelocity(entity,velocity);
      new HorizontalVelocityTracker(entity,player,200l,this);
      entity.setFallDistance(0);
      if (entity.getEntityId() != player.getEntityId() && entity instanceof Player) {
        new Flight((Player)entity,player);
      }
      if (entity.getFireTicks() > 0) {
        entity.getWorld().playEffect(entity.getLocation(),Effect.EXTINGUISH,0);
      }
      entity.setFireTicks(0);
      breakBreathbendingHold(entity);
    }
  }
  advanceLocation();
}",0.984608521079634
133849,"@Override public void progress(){
  for (int i=0; i < targets.size(); i++) {
    LivingEntity target=targets.get(i);
    if (target.isDead() || !target.getWorld().equals(player.getWorld()) || target.getLocation().distanceSquared(player.getEyeLocation()) > range * range || GeneralMethods.isRegionProtectedFromBuild(this,target.getLocation())) {
      breakSuffocateLocal(target);
      i--;
    }
 else     if (target instanceof Player) {
      Player targPlayer=(Player)target;
      if (!targPlayer.isOnline()) {
        breakSuffocateLocal(target);
        i--;
      }
    }
  }
  if (targets.size() == 0 || !bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (requireConstantAim) {
    double dist=player.getEyeLocation().distance(targets.get(0).getEyeLocation());
    Location targetLoc=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(dist));
    List<Entity> ents=GeneralMethods.getEntitiesAroundPoint(targetLoc,constantAimRadius);
    for (int i=0; i < targets.size(); i++) {
      LivingEntity target=targets.get(i);
      if (!ents.contains(target)) {
        breakSuffocateLocal(target);
        i--;
      }
    }
    if (targets.size() == 0) {
      remove();
      return;
    }
  }
  if (System.currentTimeMillis() - startTime < chargeTime) {
    return;
  }
 else   if (!started) {
    started=true;
    for (    LivingEntity targ : targets) {
      final LivingEntity target=targ;
      BukkitRunnable br1=new BukkitRunnable(){
        @Override public void run(){
          DamageHandler.damageEntity(target,damage,ability);
        }
      }
;
      BukkitRunnable br2=new BukkitRunnable(){
        @Override public void run(){
          target.addPotionEffect(new PotionEffect(PotionEffectType.SLOW,(int)(slowRepeat * 20),(int)slow));
        }
      }
;
      BukkitRunnable br3=new BukkitRunnable(){
        @Override public void run(){
          target.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS,(int)(blindRepeat * 20),(int)blind));
        }
      }
;
      tasks.add(br1);
      tasks.add(br2);
      tasks.add(br3);
      br1.runTaskTimer(ProjectKorra.plugin,(long)(damageDelay * 20),(long)(damageRepeat * 20));
      br2.runTaskTimer(ProjectKorra.plugin,(long)(slowDelay * 20),(long)(slowRepeat * 20 / 0.25));
      br3.runTaskTimer(ProjectKorra.plugin,(long)(blindDelay * 20),(long)(blindRepeat * 20));
    }
  }
  animate();
  if (!player.isSneaking()) {
    remove();
    return;
  }
}","@Override public void progress(){
  for (int i=0; i < targets.size(); i++) {
    LivingEntity target=targets.get(i);
    if (target.isDead() || !target.getWorld().equals(player.getWorld()) || target.getLocation().distanceSquared(player.getEyeLocation()) > range * range || GeneralMethods.isRegionProtectedFromBuild(this,target.getLocation())) {
      breakSuffocateLocal(target);
      i--;
    }
 else     if (target instanceof Player) {
      Player targPlayer=(Player)target;
      if (!targPlayer.isOnline()) {
        breakSuffocateLocal(target);
        i--;
      }
    }
  }
  if (targets.size() == 0 || !bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (requireConstantAim) {
    double dist=0;
    if (player.getWorld().equals(targets.get(0).getWorld())) {
      dist=player.getEyeLocation().distance(targets.get(0).getEyeLocation());
    }
    Location targetLoc=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(dist));
    List<Entity> ents=GeneralMethods.getEntitiesAroundPoint(targetLoc,constantAimRadius);
    for (int i=0; i < targets.size(); i++) {
      LivingEntity target=targets.get(i);
      if (!ents.contains(target)) {
        breakSuffocateLocal(target);
        i--;
      }
    }
    if (targets.size() == 0) {
      remove();
      return;
    }
  }
  if (System.currentTimeMillis() - startTime < chargeTime) {
    return;
  }
 else   if (!started) {
    started=true;
    for (    LivingEntity targ : targets) {
      final LivingEntity target=targ;
      BukkitRunnable br1=new BukkitRunnable(){
        @Override public void run(){
          DamageHandler.damageEntity(target,damage,ability);
        }
      }
;
      BukkitRunnable br2=new BukkitRunnable(){
        @Override public void run(){
          target.addPotionEffect(new PotionEffect(PotionEffectType.SLOW,(int)(slowRepeat * 20),(int)slow));
        }
      }
;
      BukkitRunnable br3=new BukkitRunnable(){
        @Override public void run(){
          target.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS,(int)(blindRepeat * 20),(int)blind));
        }
      }
;
      tasks.add(br1);
      tasks.add(br2);
      tasks.add(br3);
      br1.runTaskTimer(ProjectKorra.plugin,(long)(damageDelay * 20),(long)(damageRepeat * 20));
      br2.runTaskTimer(ProjectKorra.plugin,(long)(slowDelay * 20),(long)(slowRepeat * 20 / 0.25));
      br3.runTaskTimer(ProjectKorra.plugin,(long)(blindDelay * 20),(long)(blindRepeat * 20));
    }
  }
  animate();
  if (!player.isSneaking()) {
    remove();
    return;
  }
}",0.9837031219320636
133850,"private void rotateTornado(){
  origin=player.getTargetBlock((HashSet<Material>)null,(int)range).getLocation();
  double timefactor=currentHeight / maxHeight;
  currentRadius=timefactor * radius;
  if (origin.getBlock().getType() != Material.AIR && origin.getBlock().getType() != Material.BARRIER) {
    origin.setY(origin.getY() - 1. / 10. * currentHeight);
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(origin,currentHeight)) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
        continue;
      }
      double y=entity.getLocation().getY();
      double factor;
      if (y > origin.getY() && y < origin.getY() + currentHeight) {
        factor=(y - origin.getY()) / currentHeight;
        Location testloc=new Location(origin.getWorld(),origin.getX(),y,origin.getZ());
        if (testloc.distance(entity.getLocation()) < currentRadius * factor) {
          double x, z, vx, vz, mag;
          double angle=100;
          double vy=0.7 * npcPushFactor;
          angle=Math.toRadians(angle);
          x=entity.getLocation().getX() - origin.getX();
          z=entity.getLocation().getZ() - origin.getZ();
          mag=Math.sqrt(x * x + z * z);
          vx=(x * Math.cos(angle) - z * Math.sin(angle)) / mag;
          vz=(x * Math.sin(angle) + z * Math.cos(angle)) / mag;
          if (entity instanceof Player) {
            vy=0.05 * playerPushFactor;
          }
          if (entity.getEntityId() == player.getEntityId()) {
            Vector direction=player.getEyeLocation().getDirection().clone().normalize();
            vx=direction.getX();
            vz=direction.getZ();
            Location playerloc=player.getLocation();
            double py=playerloc.getY();
            double oy=origin.getY();
            double dy=py - oy;
            if (dy >= currentHeight * .95) {
              vy=0;
            }
 else             if (dy >= currentHeight * .85) {
              vy=6.0 * (.95 - dy / currentHeight);
            }
 else {
              vy=.6;
            }
          }
          if (entity instanceof Player) {
            if (Commands.invincible.contains(((Player)entity).getName())) {
              continue;
            }
          }
          Vector velocity=entity.getVelocity();
          velocity.setX(vx);
          velocity.setZ(vz);
          velocity.setY(vy);
          velocity.multiply(timefactor);
          GeneralMethods.setVelocity(entity,velocity);
          entity.setFallDistance(0);
          breakBreathbendingHold(entity);
          if (entity instanceof Player) {
            new Flight((Player)entity);
          }
        }
      }
    }
    for (    int i : angles.keySet()) {
      double x, y, z, factor;
      double angle=(double)angles.get(i);
      angle=Math.toRadians(angle);
      y=origin.getY() + timefactor * (double)i;
      factor=(double)i / currentHeight;
      x=origin.getX() + timefactor * factor * currentRadius* Math.cos(angle);
      z=origin.getZ() + timefactor * factor * currentRadius* Math.sin(angle);
      Location effect=new Location(origin.getWorld(),x,y,z);
      if (!GeneralMethods.isRegionProtectedFromBuild(this,effect)) {
        playAirbendingParticles(effect,particleCount);
        if (random.nextInt(20) == 0) {
          playAirbendingSound(effect);
        }
      }
      angles.put(i,angles.get(i) + 25 * (int)speed);
    }
  }
  currentHeight=currentHeight > maxHeight ? maxHeight : currentHeight + 1;
}","private void rotateTornado(){
  origin=player.getTargetBlock((HashSet<Material>)null,(int)range).getLocation();
  double timefactor=currentHeight / maxHeight;
  currentRadius=timefactor * radius;
  if (origin.getBlock().getType() != Material.AIR && origin.getBlock().getType() != Material.BARRIER) {
    origin.setY(origin.getY() - 1. / 10. * currentHeight);
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(origin,currentHeight)) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
        continue;
      }
      double y=entity.getLocation().getY();
      double factor;
      if (y > origin.getY() && y < origin.getY() + currentHeight) {
        factor=(y - origin.getY()) / currentHeight;
        Location testloc=new Location(origin.getWorld(),origin.getX(),y,origin.getZ());
        if (testloc.getWorld().equals(entity.getWorld()) && testloc.distance(entity.getLocation()) < currentRadius * factor) {
          double x, z, vx, vz, mag;
          double angle=100;
          double vy=0.7 * npcPushFactor;
          angle=Math.toRadians(angle);
          x=entity.getLocation().getX() - origin.getX();
          z=entity.getLocation().getZ() - origin.getZ();
          mag=Math.sqrt(x * x + z * z);
          vx=(x * Math.cos(angle) - z * Math.sin(angle)) / mag;
          vz=(x * Math.sin(angle) + z * Math.cos(angle)) / mag;
          if (entity instanceof Player) {
            vy=0.05 * playerPushFactor;
          }
          if (entity.getEntityId() == player.getEntityId()) {
            Vector direction=player.getEyeLocation().getDirection().clone().normalize();
            vx=direction.getX();
            vz=direction.getZ();
            Location playerloc=player.getLocation();
            double py=playerloc.getY();
            double oy=origin.getY();
            double dy=py - oy;
            if (dy >= currentHeight * .95) {
              vy=0;
            }
 else             if (dy >= currentHeight * .85) {
              vy=6.0 * (.95 - dy / currentHeight);
            }
 else {
              vy=.6;
            }
          }
          if (entity instanceof Player) {
            if (Commands.invincible.contains(((Player)entity).getName())) {
              continue;
            }
          }
          Vector velocity=entity.getVelocity();
          velocity.setX(vx);
          velocity.setZ(vz);
          velocity.setY(vy);
          velocity.multiply(timefactor);
          GeneralMethods.setVelocity(entity,velocity);
          entity.setFallDistance(0);
          breakBreathbendingHold(entity);
          if (entity instanceof Player) {
            new Flight((Player)entity);
          }
        }
      }
    }
    for (    int i : angles.keySet()) {
      double x, y, z, factor;
      double angle=(double)angles.get(i);
      angle=Math.toRadians(angle);
      y=origin.getY() + timefactor * (double)i;
      factor=(double)i / currentHeight;
      x=origin.getX() + timefactor * factor * currentRadius* Math.cos(angle);
      z=origin.getZ() + timefactor * factor * currentRadius* Math.sin(angle);
      Location effect=new Location(origin.getWorld(),x,y,z);
      if (!GeneralMethods.isRegionProtectedFromBuild(this,effect)) {
        playAirbendingParticles(effect,particleCount);
        if (random.nextInt(20) == 0) {
          playAirbendingSound(effect);
        }
      }
      angles.put(i,angles.get(i) + 25 * (int)speed);
    }
  }
  currentHeight=currentHeight > maxHeight ? maxHeight : currentHeight + 1;
}",0.9931232091690544
133851,"private boolean moveEarth(){
  location=location.clone().add(direction);
  if (catapult) {
    if (location.distance(origin) < 0.5) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(origin,2)) {
        if (entity instanceof Player) {
          Player target=(Player)entity;
          new Catapult(target,this);
        }
        entity.setVelocity(direction.clone().multiply(push * distance / length));
      }
      return false;
    }
  }
 else {
    double lengthSquared=(length - distance) * (length - distance);
    if (location.distanceSquared(origin) <= lengthSquared) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(location,2)) {
        entity.setVelocity(direction.clone().multiply(push * distance / length));
      }
      return false;
    }
  }
  moveEarth(location.clone().subtract(direction),direction,distance,false);
  return true;
}","private boolean moveEarth(){
  location=location.clone().add(direction);
  if (catapult) {
    if (location.getWorld().equals(origin.getWorld()) && location.distance(origin) < 0.5) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(origin,2)) {
        if (entity instanceof Player) {
          Player target=(Player)entity;
          new Catapult(target,this);
        }
        entity.setVelocity(direction.clone().multiply(push * distance / length));
      }
      return false;
    }
  }
 else {
    double lengthSquared=(length - distance) * (length - distance);
    if (location.distanceSquared(origin) <= lengthSquared) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(location,2)) {
        entity.setVelocity(direction.clone().multiply(push * distance / length));
      }
      return false;
    }
  }
  moveEarth(location.clone().subtract(direction),direction,distance,false);
  return true;
}",0.973499188750676
133852,"public EarthSmash(Player player,ClickType type){
  super(player);
  this.state=State.START;
  this.requiredBendableBlocks=getConfig().getInt(""String_Node_Str"");
  this.maxBlocksToPassThrough=getConfig().getInt(""String_Node_Str"");
  this.shootAnimationInterval=getConfig().getLong(""String_Node_Str"");
  this.flightAnimationInterval=getConfig().getLong(""String_Node_Str"");
  this.liftAnimationInterval=getConfig().getLong(""String_Node_Str"");
  this.grabDetectionRadius=getConfig().getDouble(""String_Node_Str"");
  this.flightDetectionRadius=getConfig().getDouble(""String_Node_Str"");
  this.allowGrab=getConfig().getBoolean(""String_Node_Str"");
  this.allowFlight=getConfig().getBoolean(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.grabRange=getConfig().getDouble(""String_Node_Str"");
  this.shootRange=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.knockback=getConfig().getDouble(""String_Node_Str"");
  this.knockup=getConfig().getDouble(""String_Node_Str"");
  this.flightSpeed=getConfig().getDouble(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.flightRemoveTimer=getConfig().getLong(""String_Node_Str"");
  this.removeTimer=getConfig().getLong(""String_Node_Str"");
  this.affectedEntities=new ArrayList<>();
  this.currentBlocks=new ArrayList<>();
  this.affectedBlocks=new ArrayList<>();
  if (type == ClickType.SHIFT_DOWN || type == ClickType.SHIFT_UP && !player.isSneaking()) {
    if (bPlayer.isAvatarState()) {
      selectRange=AvatarState.getValue(selectRange);
      grabRange=AvatarState.getValue(grabRange);
      chargeTime=0;
      cooldown=0;
      damage=AvatarState.getValue(damage);
      knockback=AvatarState.getValue(knockback);
      knockup=AvatarState.getValue(knockup);
      flightSpeed=AvatarState.getValue(flightSpeed);
      flightRemoveTimer=Integer.MAX_VALUE;
      shootRange=AvatarState.getValue(shootRange);
    }
    EarthSmash flySmash=flyingInSmashCheck(player);
    if (flySmash != null) {
      flySmash.state=State.FLYING;
      flySmash.player=player;
      flySmash.flightStartTime=System.currentTimeMillis();
      return;
    }
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,State.LIFTED);
    if (grabbedSmash == null) {
      if (bPlayer.isOnCooldown(this)) {
        return;
      }
      grabbedSmash=aimingAtSmashCheck(player,State.SHOT);
    }
    if (grabbedSmash != null) {
      grabbedSmash.state=State.GRABBED;
      grabbedSmash.grabbedDistance=grabbedSmash.location.distance(player.getEyeLocation());
      grabbedSmash.player=player;
      return;
    }
    start();
  }
 else   if (type == ClickType.LEFT_CLICK && player.isSneaking()) {
    for (    EarthSmash smash : getAbilities(EarthSmash.class)) {
      if (smash.state == State.GRABBED && smash.player == player) {
        smash.state=State.SHOT;
        smash.destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(smash.shootRange));
        smash.location.getWorld().playEffect(smash.location,Effect.GHAST_SHOOT,0,10);
      }
    }
    return;
  }
 else   if (type == ClickType.RIGHT_CLICK && player.isSneaking()) {
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,State.GRABBED);
    if (grabbedSmash != null) {
      player.teleport(grabbedSmash.location.clone().add(0,2,0));
      grabbedSmash.state=State.FLYING;
      grabbedSmash.player=player;
      grabbedSmash.flightStartTime=System.currentTimeMillis();
    }
    return;
  }
}","public EarthSmash(Player player,ClickType type){
  super(player);
  this.state=State.START;
  this.requiredBendableBlocks=getConfig().getInt(""String_Node_Str"");
  this.maxBlocksToPassThrough=getConfig().getInt(""String_Node_Str"");
  this.shootAnimationInterval=getConfig().getLong(""String_Node_Str"");
  this.flightAnimationInterval=getConfig().getLong(""String_Node_Str"");
  this.liftAnimationInterval=getConfig().getLong(""String_Node_Str"");
  this.grabDetectionRadius=getConfig().getDouble(""String_Node_Str"");
  this.flightDetectionRadius=getConfig().getDouble(""String_Node_Str"");
  this.allowGrab=getConfig().getBoolean(""String_Node_Str"");
  this.allowFlight=getConfig().getBoolean(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.grabRange=getConfig().getDouble(""String_Node_Str"");
  this.shootRange=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.knockback=getConfig().getDouble(""String_Node_Str"");
  this.knockup=getConfig().getDouble(""String_Node_Str"");
  this.flightSpeed=getConfig().getDouble(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.flightRemoveTimer=getConfig().getLong(""String_Node_Str"");
  this.removeTimer=getConfig().getLong(""String_Node_Str"");
  this.affectedEntities=new ArrayList<>();
  this.currentBlocks=new ArrayList<>();
  this.affectedBlocks=new ArrayList<>();
  if (type == ClickType.SHIFT_DOWN || type == ClickType.SHIFT_UP && !player.isSneaking()) {
    if (bPlayer.isAvatarState()) {
      selectRange=AvatarState.getValue(selectRange);
      grabRange=AvatarState.getValue(grabRange);
      chargeTime=0;
      cooldown=0;
      damage=AvatarState.getValue(damage);
      knockback=AvatarState.getValue(knockback);
      knockup=AvatarState.getValue(knockup);
      flightSpeed=AvatarState.getValue(flightSpeed);
      flightRemoveTimer=Integer.MAX_VALUE;
      shootRange=AvatarState.getValue(shootRange);
    }
    EarthSmash flySmash=flyingInSmashCheck(player);
    if (flySmash != null) {
      flySmash.state=State.FLYING;
      flySmash.player=player;
      flySmash.flightStartTime=System.currentTimeMillis();
      return;
    }
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,State.LIFTED);
    if (grabbedSmash == null) {
      if (bPlayer.isOnCooldown(this)) {
        return;
      }
      grabbedSmash=aimingAtSmashCheck(player,State.SHOT);
    }
    if (grabbedSmash != null) {
      grabbedSmash.state=State.GRABBED;
      grabbedSmash.grabbedDistance=0;
      if (grabbedSmash.location.getWorld().equals(player.getWorld())) {
        grabbedSmash.grabbedDistance=grabbedSmash.location.distance(player.getEyeLocation());
      }
      grabbedSmash.player=player;
      return;
    }
    start();
  }
 else   if (type == ClickType.LEFT_CLICK && player.isSneaking()) {
    for (    EarthSmash smash : getAbilities(EarthSmash.class)) {
      if (smash.state == State.GRABBED && smash.player == player) {
        smash.state=State.SHOT;
        smash.destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(smash.shootRange));
        smash.location.getWorld().playEffect(smash.location,Effect.GHAST_SHOOT,0,10);
      }
    }
    return;
  }
 else   if (type == ClickType.RIGHT_CLICK && player.isSneaking()) {
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,State.GRABBED);
    if (grabbedSmash != null) {
      player.teleport(grabbedSmash.location.clone().add(0,2,0));
      grabbedSmash.state=State.FLYING;
      grabbedSmash.player=player;
      grabbedSmash.flightStartTime=System.currentTimeMillis();
    }
    return;
  }
}",0.983637851104445
133853,"public EarthTunnel(Player player){
  super(player);
  this.maxRadius=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.radius=getConfig().getDouble(""String_Node_Str"");
  this.interval=getConfig().getLong(""String_Node_Str"");
  this.revert=getConfig().getBoolean(""String_Node_Str"");
  this.radiusIncrement=radius;
  this.time=System.currentTimeMillis();
  this.location=player.getEyeLocation().clone();
  this.origin=player.getTargetBlock((HashSet<Material>)null,(int)range).getLocation();
  this.block=origin.getBlock();
  this.direction=location.getDirection().clone().normalize();
  this.depth=Math.max(0,origin.distance(location) - 1);
  this.angle=0;
  if (!bPlayer.canBend(this)) {
    return;
  }
  start();
}","public EarthTunnel(Player player){
  super(player);
  this.maxRadius=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.radius=getConfig().getDouble(""String_Node_Str"");
  this.interval=getConfig().getLong(""String_Node_Str"");
  this.revert=getConfig().getBoolean(""String_Node_Str"");
  this.radiusIncrement=radius;
  this.time=System.currentTimeMillis();
  this.location=player.getEyeLocation().clone();
  this.origin=player.getTargetBlock((HashSet<Material>)null,(int)range).getLocation();
  this.block=origin.getBlock();
  this.direction=location.getDirection().clone().normalize();
  this.depth=0;
  if (origin.getWorld().equals(location.getWorld())) {
    this.depth=Math.max(0,origin.distance(location) - 1);
  }
  this.angle=0;
  if (!bPlayer.canBend(this)) {
    return;
  }
  start();
}",0.9522628642281464
133854,"public static boolean isBlockInWave(Block block){
  for (  LavaSurgeWave lavaWave : getAbilities(LavaSurgeWave.class)) {
    if (block.getLocation().distance(lavaWave.location) <= 2 * lavaWave.radius) {
      return true;
    }
  }
  return false;
}","public static boolean isBlockInWave(Block block){
  for (  LavaSurgeWave lavaWave : getAbilities(LavaSurgeWave.class)) {
    if (block.getWorld().equals(lavaWave.location.getWorld()) && block.getLocation().distance(lavaWave.location) <= 2 * lavaWave.radius) {
      return true;
    }
  }
  return false;
}",0.8972972972972973
133855,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (targetEntity != null) {
    if ((targetEntity instanceof Player && !((Player)targetEntity).isOnline()) || targetEntity.isDead()) {
      remove();
      return;
    }
  }
  if (player.isSneaking()) {
    hasSnuck=true;
  }
  if (!player.isSneaking()) {
    isControlling=false;
    isMagnetized=false;
    if (metalClipsCount < 4 && hasSnuck && abilityType == 0) {
      launch();
    }
  }
  if (isMagnetized) {
    if (GeneralMethods.getEntitiesAroundPoint(player.getLocation(),magnetRange).size() == 0) {
      remove();
      return;
    }
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation(),magnetRange)) {
      Vector vector=GeneralMethods.getDirection(entity.getLocation(),player.getLocation());
      ItemStack itemInHand=player.getInventory().getItemInMainHand();
      if (entity instanceof Player && canLoot && itemInHand.getType() == Material.IRON_INGOT && itemInHand.getItemMeta().getDisplayName().equalsIgnoreCase(""String_Node_Str"")) {
        Player targetPlayer=(Player)entity;
        if (targetPlayer.getEntityId() == player.getEntityId()) {
          continue;
        }
        ItemStack[] inventory=targetPlayer.getInventory().getContents();
        for (        ItemStack is : inventory) {
          if (is == null) {
            continue;
          }
          if (Arrays.asList(METAL_ITEMS).contains(is.getType())) {
            targetPlayer.getWorld().dropItem(targetPlayer.getLocation(),is);
            is.setType(Material.AIR);
            is.setAmount(0);
          }
        }
        targetPlayer.getInventory().setContents(inventory);
        ItemStack[] armor=targetPlayer.getInventory().getArmorContents();
        for (        ItemStack is : armor) {
          if (Arrays.asList(METAL_ITEMS).contains(is.getType())) {
            targetPlayer.getWorld().dropItem(targetPlayer.getLocation(),is);
            is.setType(Material.AIR);
          }
        }
        targetPlayer.getInventory().setArmorContents(armor);
        if (Arrays.asList(METAL_ITEMS).contains(targetPlayer.getInventory().getItemInMainHand().getType())) {
          targetPlayer.getWorld().dropItem(targetPlayer.getLocation(),targetPlayer.getEquipment().getItemInMainHand());
          targetPlayer.getEquipment().setItemInMainHand(new ItemStack(Material.AIR,1));
        }
      }
      if ((entity instanceof Zombie || entity instanceof Skeleton) && canLoot && itemInHand.getType() == Material.IRON_INGOT && itemInHand.getItemMeta().getDisplayName().equalsIgnoreCase(""String_Node_Str"")) {
        LivingEntity livingEntity=(LivingEntity)entity;
        ItemStack[] armor=livingEntity.getEquipment().getArmorContents();
        for (        ItemStack istack : armor) {
          if (Arrays.asList(METAL_ITEMS).contains(istack.getType())) {
            livingEntity.getWorld().dropItem(livingEntity.getLocation(),istack);
            istack.setType(Material.AIR);
          }
        }
        livingEntity.getEquipment().setArmorContents(armor);
        if (Arrays.asList(METAL_ITEMS).contains(livingEntity.getEquipment().getItemInMainHand().getType())) {
          livingEntity.getWorld().dropItem(livingEntity.getLocation(),livingEntity.getEquipment().getItemInMainHand());
          livingEntity.getEquipment().setItemInMainHand(new ItemStack(Material.AIR,1));
        }
      }
      if (entity instanceof Item) {
        Item iron=(Item)entity;
        if (Arrays.asList(METAL_ITEMS).contains(iron.getItemStack().getType())) {
          iron.setVelocity(vector.normalize().multiply(magnetPower));
        }
      }
    }
  }
  if (isBeingWorn && System.currentTimeMillis() > armorStartTime + armorTime) {
    remove();
    return;
  }
  if (isControlling && player.isSneaking()) {
    if (metalClipsCount == 1) {
      Location oldLocation=targetEntity.getLocation();
      Location loc=GeneralMethods.getTargetedLocation(player,(int)player.getLocation().distance(oldLocation));
      double distance=loc.distance(oldLocation);
      Vector vector=GeneralMethods.getDirection(targetEntity.getLocation(),player.getLocation());
      if (distance > 0.5) {
        targetEntity.setVelocity(vector.normalize().multiply(0.2));
      }
    }
    if (metalClipsCount == 2) {
      Location oldLocation=targetEntity.getLocation();
      Location loc=GeneralMethods.getTargetedLocation(player,(int)player.getLocation().distance(oldLocation));
      double distance=loc.distance(oldLocation);
      Vector vector=GeneralMethods.getDirection(targetEntity.getLocation(),GeneralMethods.getTargetedLocation(player,10));
      if (distance > 1.2) {
        targetEntity.setVelocity(vector.normalize().multiply(0.2));
      }
    }
    if (metalClipsCount >= 3) {
      Location oldLocation=targetEntity.getLocation();
      Location loc=GeneralMethods.getTargetedLocation(player,(int)player.getLocation().distance(oldLocation));
      double distance=loc.distance(oldLocation);
      Vector vector=GeneralMethods.getDirection(oldLocation,GeneralMethods.getTargetedLocation(player,10));
      if (distance > 1.2) {
        targetEntity.setVelocity(vector.normalize().multiply(.5));
      }
 else {
        targetEntity.setVelocity(new Vector(0,0,0));
      }
      targetEntity.setFallDistance(0);
    }
  }
  for (int i=0; i < trackedIngots.size(); i++) {
    Item ii=trackedIngots.get(i);
    if (ii.isOnGround()) {
      trackedIngots.remove(i);
      continue;
    }
    if (ii.getItemStack().getType() == Material.IRON_INGOT) {
      if (GeneralMethods.getEntitiesAroundPoint(ii.getLocation(),2).size() == 0) {
        remove();
        return;
      }
      for (      Entity e : GeneralMethods.getEntitiesAroundPoint(ii.getLocation(),2)) {
        if (e instanceof LivingEntity && e.getEntityId() != player.getEntityId()) {
          if ((e instanceof Player || e instanceof Zombie || e instanceof Skeleton)) {
            if (targetEntity == null) {
              targetEntity=(LivingEntity)e;
              TARGET_TO_ABILITY.put(targetEntity,this);
              formArmor();
            }
 else             if (targetEntity == e) {
              formArmor();
            }
 else {
              TARGET_TO_ABILITY.get(targetEntity).remove();
              player.getWorld().dropItemNaturally(e.getLocation(),new ItemStack(Material.IRON_INGOT,1));
            }
          }
 else {
            DamageHandler.damageEntity(e,player,damage,this);
            ii.getWorld().dropItem(ii.getLocation(),ii.getItemStack());
            remove();
          }
          ii.remove();
          break;
        }
      }
    }
  }
  removeDeadIngots();
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (targetEntity != null) {
    if ((targetEntity instanceof Player && !((Player)targetEntity).isOnline()) || targetEntity.isDead()) {
      remove();
      return;
    }
  }
  if (player.isSneaking()) {
    hasSnuck=true;
  }
  if (!player.isSneaking()) {
    isControlling=false;
    isMagnetized=false;
    if (metalClipsCount < 4 && hasSnuck && abilityType == 0) {
      launch();
    }
  }
  if (isMagnetized) {
    if (GeneralMethods.getEntitiesAroundPoint(player.getLocation(),magnetRange).size() == 0) {
      remove();
      return;
    }
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation(),magnetRange)) {
      Vector vector=GeneralMethods.getDirection(entity.getLocation(),player.getLocation());
      ItemStack itemInHand=player.getInventory().getItemInMainHand();
      if (entity instanceof Player && canLoot && itemInHand.getType() == Material.IRON_INGOT && itemInHand.getItemMeta().getDisplayName().equalsIgnoreCase(""String_Node_Str"")) {
        Player targetPlayer=(Player)entity;
        if (targetPlayer.getEntityId() == player.getEntityId()) {
          continue;
        }
        ItemStack[] inventory=targetPlayer.getInventory().getContents();
        for (        ItemStack is : inventory) {
          if (is == null) {
            continue;
          }
          if (Arrays.asList(METAL_ITEMS).contains(is.getType())) {
            targetPlayer.getWorld().dropItem(targetPlayer.getLocation(),is);
            is.setType(Material.AIR);
            is.setAmount(0);
          }
        }
        targetPlayer.getInventory().setContents(inventory);
        ItemStack[] armor=targetPlayer.getInventory().getArmorContents();
        for (        ItemStack is : armor) {
          if (Arrays.asList(METAL_ITEMS).contains(is.getType())) {
            targetPlayer.getWorld().dropItem(targetPlayer.getLocation(),is);
            is.setType(Material.AIR);
          }
        }
        targetPlayer.getInventory().setArmorContents(armor);
        if (Arrays.asList(METAL_ITEMS).contains(targetPlayer.getInventory().getItemInMainHand().getType())) {
          targetPlayer.getWorld().dropItem(targetPlayer.getLocation(),targetPlayer.getEquipment().getItemInMainHand());
          targetPlayer.getEquipment().setItemInMainHand(new ItemStack(Material.AIR,1));
        }
      }
      if ((entity instanceof Zombie || entity instanceof Skeleton) && canLoot && itemInHand.getType() == Material.IRON_INGOT && itemInHand.getItemMeta().getDisplayName().equalsIgnoreCase(""String_Node_Str"")) {
        LivingEntity livingEntity=(LivingEntity)entity;
        ItemStack[] armor=livingEntity.getEquipment().getArmorContents();
        for (        ItemStack istack : armor) {
          if (Arrays.asList(METAL_ITEMS).contains(istack.getType())) {
            livingEntity.getWorld().dropItem(livingEntity.getLocation(),istack);
            istack.setType(Material.AIR);
          }
        }
        livingEntity.getEquipment().setArmorContents(armor);
        if (Arrays.asList(METAL_ITEMS).contains(livingEntity.getEquipment().getItemInMainHand().getType())) {
          livingEntity.getWorld().dropItem(livingEntity.getLocation(),livingEntity.getEquipment().getItemInMainHand());
          livingEntity.getEquipment().setItemInMainHand(new ItemStack(Material.AIR,1));
        }
      }
      if (entity instanceof Item) {
        Item iron=(Item)entity;
        if (Arrays.asList(METAL_ITEMS).contains(iron.getItemStack().getType())) {
          iron.setVelocity(vector.normalize().multiply(magnetPower));
        }
      }
    }
  }
  if (isBeingWorn && System.currentTimeMillis() > armorStartTime + armorTime) {
    remove();
    return;
  }
  if (isControlling && player.isSneaking()) {
    if (metalClipsCount == 1) {
      Location oldLocation=targetEntity.getLocation();
      Location loc=oldLocation;
      if (player.getWorld().equals(oldLocation.getWorld())) {
        loc=GeneralMethods.getTargetedLocation(player,(int)player.getLocation().distance(oldLocation));
      }
      double distance=0;
      if (loc.getWorld().equals(oldLocation.getWorld())) {
        distance=loc.distance(oldLocation);
      }
      Vector vector=GeneralMethods.getDirection(targetEntity.getLocation(),player.getLocation());
      if (distance > 0.5) {
        targetEntity.setVelocity(vector.normalize().multiply(0.2));
      }
    }
    if (metalClipsCount == 2) {
      Location oldLocation=targetEntity.getLocation();
      Location loc=oldLocation;
      if (player.getWorld().equals(oldLocation.getWorld())) {
        loc=GeneralMethods.getTargetedLocation(player,(int)player.getLocation().distance(oldLocation));
      }
      double distance=0;
      if (loc.getWorld().equals(oldLocation.getWorld())) {
        distance=loc.distance(oldLocation);
      }
      Vector vector=GeneralMethods.getDirection(targetEntity.getLocation(),GeneralMethods.getTargetedLocation(player,10));
      if (distance > 1.2) {
        targetEntity.setVelocity(vector.normalize().multiply(0.2));
      }
    }
    if (metalClipsCount >= 3) {
      Location oldLocation=targetEntity.getLocation();
      Location loc=oldLocation;
      if (player.getWorld().equals(oldLocation.getWorld())) {
        loc=GeneralMethods.getTargetedLocation(player,(int)player.getLocation().distance(oldLocation));
      }
      double distance=0;
      if (loc.getWorld().equals(oldLocation.getWorld())) {
        distance=loc.distance(oldLocation);
      }
      Vector vector=GeneralMethods.getDirection(oldLocation,GeneralMethods.getTargetedLocation(player,10));
      if (distance > 1.2) {
        targetEntity.setVelocity(vector.normalize().multiply(.5));
      }
 else {
        targetEntity.setVelocity(new Vector(0,0,0));
      }
      targetEntity.setFallDistance(0);
    }
  }
  for (int i=0; i < trackedIngots.size(); i++) {
    Item ii=trackedIngots.get(i);
    if (ii.isOnGround()) {
      trackedIngots.remove(i);
      continue;
    }
    if (ii.getItemStack().getType() == Material.IRON_INGOT) {
      if (GeneralMethods.getEntitiesAroundPoint(ii.getLocation(),2).size() == 0) {
        remove();
        return;
      }
      for (      Entity e : GeneralMethods.getEntitiesAroundPoint(ii.getLocation(),2)) {
        if (e instanceof LivingEntity && e.getEntityId() != player.getEntityId()) {
          if ((e instanceof Player || e instanceof Zombie || e instanceof Skeleton)) {
            if (targetEntity == null) {
              targetEntity=(LivingEntity)e;
              TARGET_TO_ABILITY.put(targetEntity,this);
              formArmor();
            }
 else             if (targetEntity == e) {
              formArmor();
            }
 else {
              TARGET_TO_ABILITY.get(targetEntity).remove();
              player.getWorld().dropItemNaturally(e.getLocation(),new ItemStack(Material.IRON_INGOT,1));
            }
          }
 else {
            DamageHandler.damageEntity(e,player,damage,this);
            ii.getWorld().dropItem(ii.getLocation(),ii.getItemStack());
            remove();
          }
          ii.remove();
          break;
        }
      }
    }
  }
  removeDeadIngots();
}",0.9548127958685984
133856,"public double getDistanceTraveled(){
  if (start.getWorld() != end.getWorld()) {
    return 0;
  }
  return start.distance(end);
}","public double getDistanceTraveled(){
  if (!start.getWorld().equals(end.getWorld())) {
    return 0;
  }
  return start.distance(end);
}",0.9473684210526316
133857,"public void explode(){
  boolean explode=true;
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,3)) {
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
      explode=false;
      break;
    }
  }
  if (explode) {
    if (canDamageBlocks && explosionRadius > 0 && canFireGrief()) {
      explosion=player.getWorld().spawn(location,TNTPrimed.class);
      explosion.setFuseTicks(0);
      double yield=explosionRadius;
      if (!bPlayer.isAvatarState()) {
        yield=getDayFactor(yield,player.getWorld());
      }
 else {
        yield=AvatarState.getValue(yield);
      }
      explosion.setYield((float)yield);
      EXPLOSIONS.put(explosion,this);
    }
 else {
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location,damageRadius);
      for (      Entity entity : entities) {
        if (entity instanceof LivingEntity) {
          double slope=-(maxDamage * .5) / (damageRadius - innerRadius);
          double damage=slope * (entity.getLocation().distance(location) - innerRadius) + maxDamage;
          DamageHandler.damageEntity(entity,damage,this);
        }
      }
      location.getWorld().playSound(location,Sound.ENTITY_GENERIC_EXPLODE,5,1);
      ParticleEffect.EXPLOSION_HUGE.display(new Vector(0,0,0),0,location,255.0D);
    }
  }
  ignite(location);
  remove();
}","public void explode(){
  boolean explode=true;
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,3)) {
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
      explode=false;
      break;
    }
  }
  if (explode) {
    if (canDamageBlocks && explosionRadius > 0 && canFireGrief()) {
      explosion=player.getWorld().spawn(location,TNTPrimed.class);
      explosion.setFuseTicks(0);
      double yield=explosionRadius;
      if (!bPlayer.isAvatarState()) {
        yield=getDayFactor(yield,player.getWorld());
      }
 else {
        yield=AvatarState.getValue(yield);
      }
      explosion.setYield((float)yield);
      EXPLOSIONS.put(explosion,this);
    }
 else {
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location,damageRadius);
      for (      Entity entity : entities) {
        if (entity instanceof LivingEntity) {
          double slope=-(maxDamage * .5) / (damageRadius - innerRadius);
          double damage=0;
          if (entity.getWorld().equals(location.getWorld())) {
            damage=slope * (entity.getLocation().distance(location) - innerRadius) + maxDamage;
          }
          DamageHandler.damageEntity(entity,damage,this);
        }
      }
      location.getWorld().playSound(location,Sound.ENTITY_GENERIC_EXPLODE,5,1);
      ParticleEffect.EXPLOSION_HUGE.display(new Vector(0,0,0),0,location,255.0D);
    }
  }
  ignite(location);
  remove();
}",0.9653447659878528
133858,"public void dealDamage(Entity entity){
  if (explosion == null) {
    return;
  }
  double distance=entity.getLocation().distance(explosion.getLocation());
  if (distance > damageRadius) {
    return;
  }
 else   if (distance < innerRadius) {
    DamageHandler.damageEntity(entity,maxDamage,this);
    return;
  }
  double slope=-(maxDamage * .5) / (damageRadius - innerRadius);
  double damage=slope * (distance - innerRadius) + maxDamage;
  DamageHandler.damageEntity(entity,damage,this);
  AirAbility.breakBreathbendingHold(entity);
}","public void dealDamage(Entity entity){
  if (explosion == null) {
    return;
  }
  double distance=0;
  if (entity.getWorld().equals(explosion.getWorld())) {
    distance=entity.getLocation().distance(explosion.getLocation());
  }
  if (distance > damageRadius) {
    return;
  }
 else   if (distance < innerRadius) {
    DamageHandler.damageEntity(entity,maxDamage,this);
    return;
  }
  double slope=-(maxDamage * .5) / (damageRadius - innerRadius);
  double damage=slope * (distance - innerRadius) + maxDamage;
  DamageHandler.damageEntity(entity,damage,this);
  AirAbility.breakBreathbendingHold(entity);
}",0.88
133859,"public static boolean isWithinShield(Location loc){
  for (  FireShield fshield : getAbilities(FireShield.class)) {
    Location playerLoc=fshield.player.getLocation();
    if (fshield.shield) {
      if (!playerLoc.getWorld().equals(loc.getWorld())) {
        return false;
      }
 else       if (playerLoc.distanceSquared(loc) <= fshield.radius * fshield.radius) {
        return true;
      }
    }
 else {
      Location tempLoc=playerLoc.clone().add(playerLoc.multiply(fshield.discRadius));
      if (!tempLoc.getWorld().equals(loc.getWorld())) {
        return false;
      }
 else       if (tempLoc.distance(loc) <= fshield.discRadius * fshield.discRadius) {
        return true;
      }
    }
  }
  return false;
}","public static boolean isWithinShield(Location loc){
  for (  FireShield fshield : getAbilities(FireShield.class)) {
    Location playerLoc=fshield.player.getLocation();
    if (fshield.shield) {
      if (!playerLoc.getWorld().equals(loc.getWorld())) {
        return false;
      }
 else       if (playerLoc.distanceSquared(loc) <= fshield.radius * fshield.radius) {
        return true;
      }
    }
 else {
      Location tempLoc=playerLoc.clone().add(playerLoc.multiply(fshield.discRadius));
      if (!tempLoc.getWorld().equals(loc.getWorld())) {
        return false;
      }
 else       if (tempLoc.getWorld().equals(loc.getWorld()) && tempLoc.distance(loc) <= fshield.discRadius * fshield.discRadius) {
        return true;
      }
    }
  }
  return false;
}",0.9698189134808852
133860,"/** 
 * Runs an arc generation algorithm by first creating two points, the starting point and the ending point. Next, it creates a point in the middle that has an offset relative to the beginning and end points. Now that the arc is split into 3 points, we continue this processes by generating middle points in the two halfs of this arc. This process continues the amount of times specified.
 * @param times The amount of times that the arc will be split in half causes O(n^2)complexity
 */
public void generatePoints(int times){
  for (int i=0; i < times; i++) {
    for (int j=0; j < points.size() - 1; j+=2) {
      Location loc1=points.get(j);
      Location loc2=points.get(j + 1);
      double adjac=loc1.distance(loc2) / 2;
      double angle=(Math.random() - 0.5) * maxArcAngle;
      angle+=angle >= 0 ? 10 : -10;
      double radians=Math.toRadians(angle);
      double hypot=adjac / Math.cos(radians);
      Vector dir=GeneralMethods.rotateXZ(direction.clone(),angle);
      Location newLoc=loc1.clone().add(dir.normalize().multiply(hypot));
      newLoc.add(0,(Math.random() - 0.5) / 2.0,0);
      points.add(j + 1,newLoc);
    }
  }
  for (int i=0; i < points.size(); i++) {
    animationLocations.add(new AnimationLocation(points.get(i),animationCounter));
    animationCounter++;
  }
}","/** 
 * Runs an arc generation algorithm by first creating two points, the starting point and the ending point. Next, it creates a point in the middle that has an offset relative to the beginning and end points. Now that the arc is split into 3 points, we continue this processes by generating middle points in the two halfs of this arc. This process continues the amount of times specified.
 * @param times The amount of times that the arc will be split in half causes O(n^2)complexity
 */
public void generatePoints(int times){
  for (int i=0; i < times; i++) {
    for (int j=0; j < points.size() - 1; j+=2) {
      Location loc1=points.get(j);
      Location loc2=points.get(j + 1);
      double adjac=0;
      if (loc1.getWorld().equals(loc2.getWorld())) {
        adjac=loc1.distance(loc2) / 2;
      }
      double angle=(Math.random() - 0.5) * maxArcAngle;
      angle+=angle >= 0 ? 10 : -10;
      double radians=Math.toRadians(angle);
      double hypot=adjac / Math.cos(radians);
      Vector dir=GeneralMethods.rotateXZ(direction.clone(),angle);
      Location newLoc=loc1.clone().add(dir.normalize().multiply(hypot));
      newLoc.add(0,(Math.random() - 0.5) / 2.0,0);
      points.add(j + 1,newLoc);
    }
  }
  for (int i=0; i < points.size(); i++) {
    animationLocations.add(new AnimationLocation(points.get(i),animationCounter));
    animationCounter++;
  }
}",0.9648991784914116
133861,"/** 
 * Attempts to access a Water bendable block that was recently shifted or clicked on by the player.
 * @param player the player that is trying to bend.
 * @param range the maximum range to access the block.
 * @param clickType the action that was performed to access the source,either  {@link ClickType}.SHIFT_DOWN or ClickType.LEFT_CLICK.
 * @param allowWater true if water blocks are allowed.
 * @param allowIce true if ice blocks are allowed.
 * @param allowPlant true if plant blocks are allowed.
 * @param allowWaterBottles true if we should look for a close water block,that may have been created by a WaterBottle.
 * @return a valid Water bendable block, or null if none was found.
 */
public static Block getWaterSourceBlock(Player player,double range,ClickType clickType,boolean allowWater,boolean allowIce,boolean allowPlant,boolean allowSnow,boolean allowWaterBottles){
  Block sourceBlock=null;
  if (allowWaterBottles) {
    sourceBlock=WaterAbility.getWaterSourceBlock(player,range,allowPlant);
    if (sourceBlock == null || sourceBlock.getLocation().distance(player.getEyeLocation()) > 3) {
      sourceBlock=null;
    }
  }
  if (allowWater && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.WATER,clickType);
  }
  if (allowIce && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.ICE,clickType);
  }
  if (allowPlant && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.PLANT,clickType);
  }
  if (allowSnow && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.SNOW,clickType);
  }
  if (sourceBlock != null && TempBlock.isTempBlock(sourceBlock) && !tempblock) {
    return null;
  }
  return sourceBlock;
}","/** 
 * Attempts to access a Water bendable block that was recently shifted or clicked on by the player.
 * @param player the player that is trying to bend.
 * @param range the maximum range to access the block.
 * @param clickType the action that was performed to access the source,either  {@link ClickType}.SHIFT_DOWN or ClickType.LEFT_CLICK.
 * @param allowWater true if water blocks are allowed.
 * @param allowIce true if ice blocks are allowed.
 * @param allowPlant true if plant blocks are allowed.
 * @param allowWaterBottles true if we should look for a close water block,that may have been created by a WaterBottle.
 * @return a valid Water bendable block, or null if none was found.
 */
public static Block getWaterSourceBlock(Player player,double range,ClickType clickType,boolean allowWater,boolean allowIce,boolean allowPlant,boolean allowSnow,boolean allowWaterBottles){
  Block sourceBlock=null;
  if (allowWaterBottles) {
    sourceBlock=WaterAbility.getWaterSourceBlock(player,range,allowPlant);
    if (sourceBlock == null || (sourceBlock.getWorld().equals(player.getWorld()) && sourceBlock.getLocation().distance(player.getEyeLocation()) > 3)) {
      sourceBlock=null;
    }
  }
  if (allowWater && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.WATER,clickType);
  }
  if (allowIce && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.ICE,clickType);
  }
  if (allowPlant && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.PLANT,clickType);
  }
  if (allowSnow && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.SNOW,clickType);
  }
  if (sourceBlock != null && TempBlock.isTempBlock(sourceBlock) && !tempblock) {
    return null;
  }
  return sourceBlock;
}",0.9849330357142856
133862,"private void launch(){
  Location location=player.getLocation();
  for (  Entity entity : TARGETED_ENTITIES.keySet()) {
    Location target=entity.getLocation().clone();
    Vector vector=GeneralMethods.getDirection(location,GeneralMethods.getTargetedLocation(player,location.distance(target)));
    vector.normalize();
    entity.setVelocity(vector.multiply(throwFactor));
    new HorizontalVelocityTracker(entity,player,200,this);
  }
  remove();
  bPlayer.addCooldown(this);
}","private void launch(){
  Location location=player.getLocation();
  for (  Entity entity : TARGETED_ENTITIES.keySet()) {
    Location target=entity.getLocation().clone();
    Vector vector=new Vector(0,0,0);
    if (location.getWorld().equals(target.getWorld())) {
      vector=GeneralMethods.getDirection(location,GeneralMethods.getTargetedLocation(player,location.distance(target)));
    }
    vector.normalize();
    entity.setVelocity(vector.multiply(throwFactor));
    new HorizontalVelocityTracker(entity,player,200,this);
  }
  remove();
  bPlayer.addCooldown(this);
}",0.9097815764482432
133863,"@Override public void progress(){
  PotionEffect effect=new PotionEffect(PotionEffectType.SLOW,60,1);
  if (!player.isSneaking()) {
    remove();
    return;
  }
 else   if (holdTime > 0 && System.currentTimeMillis() - this.time > holdTime) {
    remove();
    return;
  }
  if (!canBeUsedOnUndeadMobs) {
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (isUndead(entity)) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
  if (onlyUsableDuringMoon && !isFullMoon(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (canOnlyBeUsedAtNight && !isNight(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (bPlayer.isAvatarState()) {
    ArrayList<Entity> entities=new ArrayList<>();
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation(),range)) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
        continue;
      }
 else       if (!(entity instanceof LivingEntity)) {
        continue;
      }
 else       if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null) {
          if (!targetBPlayer.canBeBloodbent() || entity.getEntityId() == player.getEntityId()) {
            continue;
          }
        }
      }
      entities.add(entity);
      if (!TARGETED_ENTITIES.containsKey(entity) && entity instanceof LivingEntity) {
        DamageHandler.damageEntity(entity,0,this);
        TARGETED_ENTITIES.put(entity,player);
      }
      if (player.getWorld() != entity.getLocation().getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
      if (entity instanceof LivingEntity) {
        entity.setVelocity(new Vector(0,0,0));
        new TempPotionEffect((LivingEntity)entity,effect);
        entity.setFallDistance(0);
        if (entity instanceof Creature) {
          ((Creature)entity).setTarget(null);
        }
        AirAbility.breakBreathbendingHold(entity);
      }
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (!entities.contains(entity) && TARGETED_ENTITIES.get(entity) == player) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
 else {
    if (TARGETED_ENTITIES.get(target) != player) {
      remove();
      return;
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null && !targetBPlayer.canBeBloodbent()) {
          TARGETED_ENTITIES.remove(entity);
          continue;
        }
      }
      Location newLocation=entity.getLocation();
      if (player.getWorld() != newLocation.getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
    }
    Location location=GeneralMethods.getTargetedLocation(player,6,getTransparentMaterial());
    double distance=location.distance(target.getLocation());
    double dx, dy, dz;
    dx=location.getX() - target.getLocation().getX();
    dy=location.getY() - target.getLocation().getY();
    dz=location.getZ() - target.getLocation().getZ();
    Vector vector=new Vector(dx,dy,dz);
    if (distance > .5) {
      target.setVelocity(vector.normalize().multiply(.5));
    }
 else {
      target.setVelocity(new Vector(0,0,0));
    }
    new TempPotionEffect((LivingEntity)target,effect);
    target.setFallDistance(0);
    if (target instanceof Creature) {
      ((Creature)target).setTarget(null);
    }
    AirAbility.breakBreathbendingHold(target);
  }
}","@Override public void progress(){
  PotionEffect effect=new PotionEffect(PotionEffectType.SLOW,60,1);
  if (!player.isSneaking()) {
    remove();
    return;
  }
 else   if (holdTime > 0 && System.currentTimeMillis() - this.time > holdTime) {
    remove();
    return;
  }
  if (!canBeUsedOnUndeadMobs) {
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (isUndead(entity)) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
  if (onlyUsableDuringMoon && !isFullMoon(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (canOnlyBeUsedAtNight && !isNight(player.getWorld()) && !bPlayer.canBloodbendAtAnytime()) {
    remove();
    return;
  }
 else   if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  if (bPlayer.isAvatarState()) {
    ArrayList<Entity> entities=new ArrayList<>();
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation(),range)) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
        continue;
      }
 else       if (!(entity instanceof LivingEntity)) {
        continue;
      }
 else       if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null) {
          if (!targetBPlayer.canBeBloodbent() || entity.getEntityId() == player.getEntityId()) {
            continue;
          }
        }
      }
      entities.add(entity);
      if (!TARGETED_ENTITIES.containsKey(entity) && entity instanceof LivingEntity) {
        DamageHandler.damageEntity(entity,0,this);
        TARGETED_ENTITIES.put(entity,player);
      }
      if (player.getWorld() != entity.getLocation().getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
      if (entity instanceof LivingEntity) {
        entity.setVelocity(new Vector(0,0,0));
        new TempPotionEffect((LivingEntity)entity,effect);
        entity.setFallDistance(0);
        if (entity instanceof Creature) {
          ((Creature)entity).setTarget(null);
        }
        AirAbility.breakBreathbendingHold(entity);
      }
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (!entities.contains(entity) && TARGETED_ENTITIES.get(entity) == player) {
        TARGETED_ENTITIES.remove(entity);
      }
    }
  }
 else {
    if (TARGETED_ENTITIES.get(target) != player) {
      remove();
      return;
    }
    for (    Entity entity : TARGETED_ENTITIES.keySet()) {
      if (entity instanceof Player) {
        BendingPlayer targetBPlayer=BendingPlayer.getBendingPlayer((Player)entity);
        if (targetBPlayer != null && !targetBPlayer.canBeBloodbent()) {
          TARGETED_ENTITIES.remove(entity);
          continue;
        }
      }
      Location newLocation=entity.getLocation();
      if (player.getWorld() != newLocation.getWorld()) {
        TARGETED_ENTITIES.remove(entity);
        continue;
      }
    }
    Location location=GeneralMethods.getTargetedLocation(player,6,getTransparentMaterial());
    double distance=0;
    if (location.getWorld().equals(target.getWorld())) {
      location.distance(target.getLocation());
    }
    double dx, dy, dz;
    dx=location.getX() - target.getLocation().getX();
    dy=location.getY() - target.getLocation().getY();
    dz=location.getZ() - target.getLocation().getZ();
    Vector vector=new Vector(dx,dy,dz);
    if (distance > .5) {
      target.setVelocity(vector.normalize().multiply(.5));
    }
 else {
      target.setVelocity(new Vector(0,0,0));
    }
    new TempPotionEffect((LivingEntity)target,effect);
    target.setFallDistance(0);
    if (target instanceof Creature) {
      ((Creature)target).setTarget(null);
    }
    AirAbility.breakBreathbendingHold(target);
  }
}",0.9904837430610628
133864,"@SuppressWarnings(""String_Node_Str"") private void getGround(){
  for (int i=0; i <= 5; i++) {
    Block block=loc.getBlock().getRelative(BlockFace.DOWN,i);
    if (isEarthbendable(block)) {
      groundBlock=block;
      blockType=block.getType();
      blockByte=block.getData();
      return;
    }
  }
}","private void getGround(){
  for (int i=0; i <= 5; i++) {
    Block block=loc.getBlock().getRelative(BlockFace.DOWN,i);
    if (isEarthbendable(block)) {
      groundBlock=block;
      blockType=block.getType();
      return;
    }
  }
}",0.8708487084870848
133865,"public EarthGrab(Player player){
  super(player);
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.height=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.origin=player.getEyeLocation();
  this.direction=origin.getDirection();
  this.lowestDistance=selectRange + 1;
  this.closestEntity=null;
  this.startLoc=player.getLocation();
  this.loc=player.getLocation();
  this.dir=player.getLocation().getDirection().clone().normalize().multiply(1.5);
  this.random=new Random();
  if (!bPlayer.canBend(this)) {
    return;
  }
  if (player.isSneaking()) {
    start();
  }
 else {
    Location targetLocation=GeneralMethods.getTargetedLocation(player,1);
    Block block=GeneralMethods.getTopBlock(targetLocation,1,1);
    if (isEarthbendable(block) && block.getLocation().distance(player.getLocation()) <= 1.3) {
      earthGrabSelf();
      remove();
    }
  }
}","public EarthGrab(Player player){
  super(player);
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.height=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.origin=player.getEyeLocation();
  this.direction=origin.getDirection();
  this.lowestDistance=selectRange + 1;
  this.closestEntity=null;
  this.startLoc=player.getLocation();
  this.loc=player.getLocation();
  this.dir=player.getLocation().getDirection();
  this.random=new Random();
  if (!bPlayer.canBend(this)) {
    return;
  }
  if (player.isSneaking()) {
    start();
  }
  Location targetLocation=GeneralMethods.getTargetedLocation(player,1);
  Block block=GeneralMethods.getTopBlock(targetLocation,1);
  if (isEarthbendable(block) && block.getWorld().equals(player.getWorld()) && block.getLocation().distance(player.getLocation()) <= 2) {
    earthGrabSelf();
    remove();
  }
}",0.8304535637149028
133866,"@Override public void progress(){
  getGround();
  bPlayer.addCooldown(this);
  if (groundBlock == null) {
    remove();
    return;
  }
  dir=dir.clone().normalize().multiply(1.5);
  dir.setY(0);
  double distance=loc.getY() - (double)groundBlock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 1.75) {
    dir.setY(-.50 * dx * dx);
  }
 else   if (distance < 1) {
    dir.setY(.50 * dx * dx);
  }
 else {
    dir.setY(0);
  }
  loc.add(dir);
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,blockByte),1F,0.1F,1F,0.1F,100,loc.add(0,-1,0),500);
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!player.isSneaking()) {
    remove();
    return;
  }
  if (loc.distance(startLoc) >= selectRange) {
    remove();
    return;
  }
  for (  Entity e : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
    if (e.getEntityId() != player.getEntityId() && e instanceof LivingEntity) {
      closestEntity=e;
      formDome();
      remove();
      return;
    }
  }
  if (random.nextInt(2) == 0) {
    playEarthbendingSound(loc);
  }
}","@Override public void progress(){
  getGround();
  bPlayer.addCooldown(this);
  if (groundBlock == null) {
    remove();
    return;
  }
  dir=player.getLocation().getDirection().clone().normalize().multiply(1.5);
  dir.setY(0);
  double distance=loc.getY() - (double)groundBlock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 1.75) {
    dir.setY(-.50 * dx * dx);
  }
 else   if (distance < 1) {
    dir.setY(.50 * dx * dx);
  }
 else {
    dir.setY(0);
  }
  loc.add(dir);
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,(byte)0),1F,0.1F,1F,0.1F,100,loc.add(0,-1,0),500);
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (!player.isSneaking()) {
    remove();
    return;
  }
  if (loc.getWorld().equals(startLoc.getWorld()) && loc.distance(startLoc) >= selectRange) {
    remove();
    return;
  }
  for (  Entity e : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
    if (e.getEntityId() != player.getEntityId() && e instanceof LivingEntity) {
      closestEntity=e;
      formDome();
      remove();
      return;
    }
  }
  if (random.nextInt(2) == 0) {
    playEarthbendingSound(loc);
  }
}",0.9580838323353292
133867,"public void earthGrabSelf(){
  closestEntity=player;
  getGround();
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,blockByte),1F,1F,1F,0.1F,100,player.getLocation(),500);
  if (closestEntity != null) {
    ArrayList<Block> blocks=new ArrayList<Block>();
    Location location=closestEntity.getLocation();
    Location loc1=location.clone();
    Location loc2=location.clone();
    Location testLoc, testLoc2;
    double factor=3;
    double factor2=4;
    int height1=3;
    int height2=2;
    for (double angle=0; angle <= 360; angle+=20) {
      testLoc=loc1.clone().add(factor * Math.cos(Math.toRadians(angle)),1,factor * Math.sin(Math.toRadians(angle)));
      testLoc2=loc2.clone().add(factor2 * Math.cos(Math.toRadians(angle)),1,factor2 * Math.sin(Math.toRadians(angle)));
      for (int y=0; y < height - height1; y++) {
        testLoc=testLoc.clone().add(0,-1,0);
        if (isEarthbendable(testLoc.getBlock())) {
          if (!blocks.contains(testLoc.getBlock())) {
            new RaiseEarth(player,testLoc,height1 + y - 1);
          }
          blocks.add(testLoc.getBlock());
          break;
        }
      }
      for (int y=0; y < height - height2; y++) {
        testLoc2=testLoc2.clone().add(0,-1,0);
        if (isEarthbendable(testLoc2.getBlock())) {
          if (!blocks.contains(testLoc2.getBlock())) {
            new RaiseEarth(player,testLoc2,height2 + y - 1);
          }
          blocks.add(testLoc2.getBlock());
          break;
        }
      }
    }
    bPlayer.addCooldown(this);
  }
}","public void earthGrabSelf(){
  closestEntity=player;
  getGround();
  ParticleEffect.BLOCK_CRACK.display((ParticleEffect.ParticleData)new ParticleEffect.BlockData(blockType,(byte)0),1F,1F,1F,0.1F,100,player.getLocation(),500);
  if (closestEntity != null) {
    ArrayList<Block> blocks=new ArrayList<Block>();
    Location location=closestEntity.getLocation();
    Location loc1=location.clone();
    Location loc2=location.clone();
    Location testLoc, testLoc2;
    double factor=3;
    double factor2=4;
    int height1=3;
    int height2=2;
    for (double angle=0; angle <= 360; angle+=20) {
      testLoc=loc1.clone().add(factor * Math.cos(Math.toRadians(angle)),1,factor * Math.sin(Math.toRadians(angle)));
      testLoc2=loc2.clone().add(factor2 * Math.cos(Math.toRadians(angle)),1,factor2 * Math.sin(Math.toRadians(angle)));
      for (int y=0; y < height - height1; y++) {
        testLoc=testLoc.clone().add(0,-1,0);
        if (isEarthbendable(testLoc.getBlock())) {
          if (!blocks.contains(testLoc.getBlock())) {
            new RaiseEarth(player,testLoc,height1 + y - 1);
          }
          blocks.add(testLoc.getBlock());
          break;
        }
      }
      for (int y=0; y < height - height2; y++) {
        testLoc2=testLoc2.clone().add(0,-1,0);
        if (isEarthbendable(testLoc2.getBlock())) {
          if (!blocks.contains(testLoc2.getBlock())) {
            new RaiseEarth(player,testLoc2,height2 + y - 1);
          }
          blocks.add(testLoc2.getBlock());
          break;
        }
      }
    }
    bPlayer.addCooldown(this);
  }
}",0.9949367088607596
133868,"@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),1,2) || !isPlayer(sender)) {
    return;
  }
  CoreAbility coreAbil=CoreAbility.getAbility(args.get(0));
  if (coreAbil == null || coreAbil.isHiddenAbility() || !coreAbil.isEnabled()) {
    sender.sendMessage(ChatColor.RED + abilityDoesntExist.replace(""String_Node_Str"",args.get(0)));
    return;
  }
  if (args.size() == 1) {
    bind(sender,args.get(0),((Player)sender).getInventory().getHeldItemSlot() + 1);
  }
  if (args.size() == 2) {
    bind(sender,args.get(0),Integer.parseInt(args.get(1)));
  }
}","@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),1,2) || !isPlayer(sender)) {
    return;
  }
  CoreAbility coreAbil=CoreAbility.getAbility(args.get(0));
  if (coreAbil == null || coreAbil.isHiddenAbility() || !coreAbil.isEnabled()) {
    sender.sendMessage(ChatColor.RED + abilityDoesntExist.replace(""String_Node_Str"",args.get(0)));
    return;
  }
  if (args.size() == 1) {
    bind(sender,args.get(0),((Player)sender).getInventory().getHeldItemSlot() + 1);
  }
  if (args.size() == 2) {
    try {
      bind(sender,args.get(0),Integer.parseInt(args.get(1)));
    }
 catch (    NumberFormatException ex) {
      sender.sendMessage(ChatColor.RED + wrongNumber);
    }
  }
}",0.9153024911032028
133869,"private void freeze(){
  if (layer == 0) {
    return;
  }
 else   if (!bPlayer.canBendIgnoreBindsCooldowns(getAbility(""String_Node_Str""))) {
    return;
  }
  List<Block> ice=GeneralMethods.getBlocksAroundPoint(location,layer);
  for (  Block block : ice) {
    if (isTransparent(player,block) && block.getType() != Material.ICE) {
      TempBlock tblock=new TempBlock(block,Material.ICE,(byte)0);
      FROZEN_BLOCKS.put(tblock,player);
      FROZEN_BLOCKS_DELAY.put(tblock,System.currentTimeMillis());
      playIcebendingSound(block.getLocation());
    }
  }
}","private void freeze(){
  if (layer == 0) {
    return;
  }
 else   if (!bPlayer.canBendIgnoreBindsCooldowns(getAbility(""String_Node_Str""))) {
    return;
  }
  List<Block> ice=GeneralMethods.getBlocksAroundPoint(location,layer);
  for (  Block block : ice) {
    if (isTransparent(player,block) && block.getType() != Material.ICE) {
      TempBlock tblock=new TempBlock(block,Material.ICE,(byte)0);
      FROZEN_BLOCKS.put(tblock,player);
      FROZEN_BLOCKS_DELAY.put(tblock,System.currentTimeMillis() + (new Random().nextInt((500 + 500) + 1) - 500));
      playIcebendingSound(block.getLocation());
    }
  }
}",0.9591836734693876
133870,"/** 
 * Adds the ability to bend an element to a player.
 * @param sender The CommandSender who issued the add command
 * @param target The player to add the element to
 * @param element The element to add
 */
private void add(CommandSender sender,Player target,String element){
  Element e=Element.fromString(element);
  if (e == null) {
    e=SubElement.fromString(element);
  }
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(target);
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(target.getUniqueId(),target.getName());
    bPlayer=BendingPlayer.getBendingPlayer(target);
  }
  if (bPlayer.isPermaRemoved()) {
    sender.sendMessage(ChatColor.RED + ConfigManager.languageConfig.get().getString(""String_Node_Str""));
    return;
  }
  if (Arrays.asList(Element.getAllElements()).contains(e)) {
    if (bPlayer.hasElement(e)) {
      if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
        sender.sendMessage(ChatColor.RED + alreadyHasElementOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + ChatColor.RED));
      }
 else {
        sender.sendMessage(ChatColor.RED + alreadyHasElement);
      }
      return;
    }
    bPlayer.addElement(e);
    for (    SubElement sub : Element.getAllSubElements()) {
      if (sub.getParentElement() == e && bPlayer.hasSubElementPermission(sub)) {
        bPlayer.addSubElement(sub);
      }
    }
    ChatColor color=e.getColor();
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      sender.sendMessage(color + addedOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
      target.sendMessage(color + added.replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
    }
 else {
      target.sendMessage(color + added.replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
    }
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,target,e,Result.ADD));
    return;
  }
 else   if (Arrays.asList(Element.getAllSubElements()).contains(e)) {
    SubElement sub=(SubElement)e;
    if (bPlayer.hasSubElement(sub)) {
      if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
        sender.sendMessage(ChatColor.RED + alreadyHasSubElementOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + ChatColor.RED));
      }
 else {
        sender.sendMessage(ChatColor.RED + alreadyHasSubElement);
      }
      return;
    }
    bPlayer.addSubElement(sub);
    ChatColor color=e.getColor();
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      sender.sendMessage(color + addedOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
 else {
      target.sendMessage(color + added.replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,target,sub,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.ADD));
    return;
  }
 else {
    sender.sendMessage(ChatColor.RED + invalidElement);
  }
}","/** 
 * Adds the ability to bend an element to a player.
 * @param sender The CommandSender who issued the add command
 * @param target The player to add the element to
 * @param element The element to add
 */
private void add(CommandSender sender,Player target,String element){
  Element e=Element.fromString(element);
  if (e == null) {
    e=SubElement.fromString(element);
  }
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(target);
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(target.getUniqueId(),target.getName());
    bPlayer=BendingPlayer.getBendingPlayer(target);
  }
  if (bPlayer.isPermaRemoved()) {
    sender.sendMessage(ChatColor.RED + ConfigManager.languageConfig.get().getString(""String_Node_Str""));
    return;
  }
  if (Arrays.asList(Element.getAllElements()).contains(e)) {
    if (bPlayer.hasElement(e)) {
      if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
        sender.sendMessage(ChatColor.RED + alreadyHasElementOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + ChatColor.RED));
      }
 else {
        sender.sendMessage(ChatColor.RED + alreadyHasElement);
      }
      return;
    }
    bPlayer.addElement(e);
    for (    SubElement sub : Element.getAllSubElements()) {
      if (sub.getParentElement() == e && bPlayer.hasSubElementPermission(sub)) {
        bPlayer.addSubElement(sub);
      }
    }
    ChatColor color=e.getColor();
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      if (e != Element.AIR && e != Element.EARTH) {
        sender.sendMessage(color + addedOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
        target.sendMessage(color + addedCFW.replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
      }
 else {
        sender.sendMessage(color + addedOtherAE.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
        target.sendMessage(color + addedAE.replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
      }
    }
 else {
      if (e != Element.AIR && e != Element.EARTH)       target.sendMessage(color + addedCFW.replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
 else       target.sendMessage(color + addedAE.replace(""String_Node_Str"",e.getName() + e.getType().getBender()));
    }
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,target,e,Result.ADD));
    return;
  }
 else   if (Arrays.asList(Element.getAllSubElements()).contains(e)) {
    SubElement sub=(SubElement)e;
    if (bPlayer.hasSubElement(sub)) {
      if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
        sender.sendMessage(ChatColor.RED + alreadyHasSubElementOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + ChatColor.RED));
      }
 else {
        sender.sendMessage(ChatColor.RED + alreadyHasSubElement);
      }
      return;
    }
    bPlayer.addSubElement(sub);
    ChatColor color=e.getColor();
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      if (e != Element.AIR && e != Element.EARTH)       sender.sendMessage(color + addedOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
 else       sender.sendMessage(color + addedOtherAE.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
 else {
      if (e != Element.AIR && e != Element.EARTH)       target.sendMessage(color + addedCFW.replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
 else       target.sendMessage(color + addedAE.replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,target,sub,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.ADD));
    return;
  }
 else {
    sender.sendMessage(ChatColor.RED + invalidElement);
  }
}",0.6791918671985587
133871,"public AddCommand(){
  super(""String_Node_Str"",""String_Node_Str"",ConfigManager.languageConfig.get().getString(""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  this.playerNotFound=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.invalidElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.addedOther=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.added=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasElementOther=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasSubElementOther=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasSubElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
}","public AddCommand(){
  super(""String_Node_Str"",""String_Node_Str"",ConfigManager.languageConfig.get().getString(""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  this.playerNotFound=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.invalidElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.addedOtherCFW=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.addedOtherAE=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.addedCFW=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.addedAE=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasElementOther=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasSubElementOther=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.alreadyHasSubElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
}",0.912621359223301
133872,"/** 
 * Adds the ability to bend the given element to the specified Player.
 * @param sender The CommandSender who issued the command
 * @param target The Player to add the element to
 * @param element The element to add to the Player
 */
private void add(CommandSender sender,Player target,Element element){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(target);
  if (bPlayer == null) {
    return;
  }
  if (element instanceof SubElement) {
    SubElement sub=(SubElement)element;
    bPlayer.addSubElement(sub);
    ChatColor color=sub != null ? sub.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      sender.sendMessage(color + chosenOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
 else {
      target.sendMessage(color + chosen.replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,target,sub,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.CHOOSE));
  }
 else {
    bPlayer.setElement(element);
    for (    SubElement sub : Element.getAllSubElements()) {
      if (sub.getParentElement() == element && bPlayer.hasSubElementPermission(sub)) {
        bPlayer.addSubElement(sub);
      }
    }
    ChatColor color=element != null ? element.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      sender.sendMessage(color + chosenOther.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
 else {
      target.sendMessage(color + chosen.replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,target,element,Result.CHOOSE));
  }
  GeneralMethods.removeUnusableAbilities(target.getName());
}","/** 
 * Adds the ability to bend the given element to the specified Player.
 * @param sender The CommandSender who issued the command
 * @param target The Player to add the element to
 * @param element The element to add to the Player
 */
private void add(CommandSender sender,Player target,Element element){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(target);
  if (bPlayer == null) {
    return;
  }
  if (element instanceof SubElement) {
    SubElement sub=(SubElement)element;
    bPlayer.addSubElement(sub);
    ChatColor color=sub != null ? sub.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      sender.sendMessage(color + chosenOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
 else {
      target.sendMessage(color + chosenCFW.replace(""String_Node_Str"",sub.getName() + sub.getType().getBender()));
    }
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,target,sub,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.CHOOSE));
  }
 else {
    bPlayer.setElement(element);
    for (    SubElement sub : Element.getAllSubElements()) {
      if (sub.getParentElement() == element && bPlayer.hasSubElementPermission(sub)) {
        bPlayer.addSubElement(sub);
      }
    }
    ChatColor color=element != null ? element.getColor() : ChatColor.WHITE;
    if (!(sender instanceof Player) || !((Player)sender).equals(target)) {
      if (element != Element.AIR && element != Element.EARTH)       sender.sendMessage(color + chosenOtherCFW.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
 else       sender.sendMessage(color + chosenOtherAE.replace(""String_Node_Str"",ChatColor.DARK_AQUA + target.getName() + color).replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
 else {
      if (element != Element.AIR && element != Element.EARTH)       target.sendMessage(color + chosenCFW.replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
 else       target.sendMessage(color + chosenAE.replace(""String_Node_Str"",element.getName() + element.getType().getBender()));
    }
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,target,element,Result.CHOOSE));
  }
  GeneralMethods.removeUnusableAbilities(target.getName());
}",0.9044611937258096
133873,"public ChooseCommand(){
  super(""String_Node_Str"",""String_Node_Str"",ConfigManager.languageConfig.get().getString(""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  this.playerNotFound=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.invalidElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.chosen=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.chosenOther=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
}","public ChooseCommand(){
  super(""String_Node_Str"",""String_Node_Str"",ConfigManager.languageConfig.get().getString(""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  this.playerNotFound=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.invalidElement=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.chosenCFW=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.chosenAE=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.chosenOtherCFW=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  this.chosenOtherAE=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
}",0.8578471651602301
133874,"public WhoCommand(){
  super(""String_Node_Str"",""String_Node_Str"",ConfigManager.languageConfig.get().getString(""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  databaseOverload=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  noPlayersOnline=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  playerOffline=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.RED + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GOLD + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GOLD + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GOLD + ""String_Node_Str"");
}","public WhoCommand(){
  super(""String_Node_Str"",""String_Node_Str"",ConfigManager.languageConfig.get().getString(""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  databaseOverload=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  noPlayersOnline=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  playerOffline=ConfigManager.languageConfig.get().getString(""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.RED + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GOLD + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.DARK_PURPLE + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GREEN + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GOLD + ""String_Node_Str"");
  staff.put(""String_Node_Str"",ChatColor.GOLD + ""String_Node_Str"");
}",0.9778708133971292
133875,"public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}","public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}",0.9976442411511808
133876,"@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),1,2)) {
    return;
  }
  Player player=Bukkit.getPlayer(args.get(0));
  if (player == null) {
    if (args.size() == 1) {
      Element e=Element.fromString(args.get(0));
      BendingPlayer senderBPlayer=BendingPlayer.getBendingPlayer(sender.getName());
      if (senderBPlayer != null && sender instanceof Player) {
        if (e != null) {
          if (e instanceof SubElement) {
            if (senderBPlayer.hasElement(e)) {
              senderBPlayer.getSubElements().remove(e);
              GeneralMethods.saveSubElements(senderBPlayer);
              GeneralMethods.removeUnusableAbilities(sender.getName());
              sender.sendMessage(e.getColor() + this.succesfullyRemovedElementSelf.replace(""String_Node_Str"",e.getName() + e.getType().getBending()).replace(""String_Node_Str"",ChatColor.DARK_AQUA + sender.getName() + e.getColor()));
              Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,player,(SubElement)e,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.REMOVE));
            }
 else             sender.sendMessage(ChatColor.RED + wrongElementSelf);
            return;
          }
 else           if (e instanceof Element) {
            if (senderBPlayer.hasElement(e)) {
              senderBPlayer.getElements().remove(e);
              GeneralMethods.saveElements(senderBPlayer);
              GeneralMethods.removeUnusableAbilities(sender.getName());
              sender.sendMessage(e.getColor() + succesfullyRemovedElementSelf.replace(""String_Node_Str"",e.getName()));
              Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,(Player)sender,e,Result.REMOVE));
              return;
            }
 else             sender.sendMessage(ChatColor.RED + wrongElementSelf);
{
              return;
            }
          }
        }
 else         sender.sendMessage(ChatColor.RED + invalidElement);
{
          return;
        }
      }
      sender.sendMessage(ChatColor.RED + playerOffline);
      return;
    }
 else {
      help(sender,false);
      return;
    }
  }
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
    bPlayer=BendingPlayer.getBendingPlayer(player);
  }
  if (args.size() == 2) {
    Element e=Element.fromString(args.get(1));
    if (e != null) {
      if (!bPlayer.hasElement(e)) {
        sender.sendMessage(ChatColor.DARK_RED + wrongElementTarget.replace(""String_Node_Str"",player.getName()));
        return;
      }
      if (e instanceof SubElement) {
        bPlayer.getSubElements().remove(e);
        GeneralMethods.saveSubElements(bPlayer);
      }
 else {
        bPlayer.getElements().remove(e);
        GeneralMethods.saveElements(bPlayer);
      }
      GeneralMethods.removeUnusableAbilities(player.getName());
      player.sendMessage(e.getColor() + this.succesfullyRemovedElementTargetConfirm.replace(""String_Node_Str"",e.getName() + e.getType().getBending()).replace(""String_Node_Str"",ChatColor.DARK_AQUA + player.getName() + e.getColor()));
      sender.sendMessage(e.getColor() + this.succesfullyRemovedElementTarget.replace(""String_Node_Str"",e.getName() + e.getType().getBending()).replace(""String_Node_Str"",ChatColor.DARK_AQUA + sender.getName() + e.getColor()));
      Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,e,Result.REMOVE));
      return;
    }
  }
 else   if (args.size() == 1) {
    bPlayer.getElements().clear();
    bPlayer.getSubElements().clear();
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    GeneralMethods.removeUnusableAbilities(player.getName());
    if (GeneralMethods.hasRPG())     RPGMethods.revokeAvatar(bPlayer.getUUID());
    if (!player.getName().equalsIgnoreCase(sender.getName()))     sender.sendMessage(ChatColor.YELLOW + this.succesfullyRemovedAllElementsTargetConfirm.replace(""String_Node_Str"",ChatColor.DARK_AQUA + player.getName() + ChatColor.YELLOW));
    player.sendMessage(ChatColor.YELLOW + this.succesfullyRemovedAllElementsTarget.replace(""String_Node_Str"",ChatColor.DARK_AQUA + sender.getName() + ChatColor.YELLOW));
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,null,Result.REMOVE));
  }
}","@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),1,2)) {
    return;
  }
  Player player=Bukkit.getPlayer(args.get(0));
  if (player == null) {
    if (args.size() == 1) {
      Element e=Element.fromString(args.get(0));
      BendingPlayer senderBPlayer=BendingPlayer.getBendingPlayer(sender.getName());
      if (senderBPlayer != null && sender instanceof Player) {
        if (e != null) {
          if (e instanceof SubElement) {
            if (senderBPlayer.hasElement(e)) {
              senderBPlayer.getSubElements().remove(e);
              GeneralMethods.saveSubElements(senderBPlayer);
              GeneralMethods.removeUnusableAbilities(sender.getName());
              sender.sendMessage(e.getColor() + this.succesfullyRemovedElementSelf.replace(""String_Node_Str"",e.getName() + e.getType().getBending()).replace(""String_Node_Str"",ChatColor.DARK_AQUA + sender.getName() + e.getColor()));
              Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeSubElementEvent(sender,player,(SubElement)e,com.projectkorra.projectkorra.event.PlayerChangeSubElementEvent.Result.REMOVE));
            }
 else             sender.sendMessage(ChatColor.RED + wrongElementSelf);
            return;
          }
 else           if (e instanceof Element) {
            if (senderBPlayer.hasElement(e)) {
              senderBPlayer.getElements().remove(e);
              GeneralMethods.saveElements(senderBPlayer);
              GeneralMethods.removeUnusableAbilities(sender.getName());
              sender.sendMessage(e.getColor() + succesfullyRemovedElementSelf.replace(""String_Node_Str"",e.getName()));
              Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,(Player)sender,e,Result.REMOVE));
              return;
            }
 else             sender.sendMessage(ChatColor.RED + wrongElementSelf);
{
              return;
            }
          }
        }
 else         sender.sendMessage(ChatColor.RED + invalidElement);
{
          return;
        }
      }
      sender.sendMessage(ChatColor.RED + playerOffline);
      return;
    }
 else {
      help(sender,false);
      return;
    }
  }
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
    bPlayer=BendingPlayer.getBendingPlayer(player);
  }
  if (args.size() == 2) {
    Element e=Element.fromString(args.get(1));
    if (e != null) {
      if (!bPlayer.hasElement(e)) {
        sender.sendMessage(ChatColor.DARK_RED + wrongElementTarget.replace(""String_Node_Str"",player.getName()));
        return;
      }
      if (e instanceof SubElement) {
        bPlayer.getSubElements().remove(e);
        GeneralMethods.saveSubElements(bPlayer);
      }
 else {
        bPlayer.getElements().remove(e);
        GeneralMethods.saveElements(bPlayer);
      }
      GeneralMethods.removeUnusableAbilities(player.getName());
      player.sendMessage(e.getColor() + this.succesfullyRemovedElementTarget.replace(""String_Node_Str"",e.getName() + e.getType().getBending()).replace(""String_Node_Str"",ChatColor.DARK_AQUA + sender.getName() + e.getColor()));
      sender.sendMessage(e.getColor() + this.succesfullyRemovedElementTargetConfirm.replace(""String_Node_Str"",e.getName() + e.getType().getBending()).replace(""String_Node_Str"",ChatColor.DARK_AQUA + player.getName() + e.getColor()));
      Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,e,Result.REMOVE));
      return;
    }
  }
 else   if (args.size() == 1) {
    bPlayer.getElements().clear();
    bPlayer.getSubElements().clear();
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.saveSubElements(bPlayer);
    GeneralMethods.removeUnusableAbilities(player.getName());
    if (GeneralMethods.hasRPG())     RPGMethods.revokeAvatar(bPlayer.getUUID());
    if (!player.getName().equalsIgnoreCase(sender.getName()))     sender.sendMessage(ChatColor.YELLOW + this.succesfullyRemovedAllElementsTargetConfirm.replace(""String_Node_Str"",ChatColor.DARK_AQUA + player.getName() + ChatColor.YELLOW));
    player.sendMessage(ChatColor.YELLOW + this.succesfullyRemovedAllElementsTarget.replace(""String_Node_Str"",ChatColor.DARK_AQUA + sender.getName() + ChatColor.YELLOW));
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,null,Result.REMOVE));
  }
}",0.9966696269982238
133877,"public FireJet(Player player){
  super(player);
  FireJet oldJet=getAbility(player,FireJet.class);
  if (oldJet != null) {
    oldJet.remove();
    return;
  }
 else   if (bPlayer.isOnCooldown(this)) {
    return;
  }
  if (hasAbility(player,AirSpout.class)) {
    AirSpout abil=getAbility(player,AirSpout.class);
    abil.remove();
  }
 else   if (hasAbility(player,SandSpout.class)) {
    SandSpout abil=getAbility(player,SandSpout.class);
    abil.remove();
  }
  this.avatarStateToggled=getConfig().getBoolean(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.speed=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.random=new Random();
  this.speed=getDayFactor(speed);
  Block block=player.getLocation().getBlock();
  if (BlazeArc.isIgnitable(player,block) || block.getType() == Material.AIR || bPlayer.isAvatarState()) {
    player.setVelocity(player.getEyeLocation().getDirection().clone().normalize().multiply(speed));
    if (canFireGrief()) {
      createTempFire(block.getLocation());
    }
 else {
      block.setType(Material.FIRE);
    }
    new Flight(player);
    player.setAllowFlight(true);
    time=System.currentTimeMillis();
    start();
    bPlayer.addCooldown(this);
  }
}","public FireJet(Player player){
  super(player);
  FireJet oldJet=getAbility(player,FireJet.class);
  if (oldJet != null) {
    oldJet.remove();
    return;
  }
 else   if (bPlayer.isOnCooldown(this)) {
    return;
  }
  if (hasAbility(player,AirSpout.class)) {
    AirSpout abil=getAbility(player,AirSpout.class);
    abil.remove();
  }
 else   if (hasAbility(player,SandSpout.class)) {
    SandSpout abil=getAbility(player,SandSpout.class);
    abil.remove();
  }
  this.avatarStateToggled=getConfig().getBoolean(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.speed=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.random=new Random();
  this.speed=getDayFactor(speed);
  Block block=player.getLocation().getBlock();
  if (BlazeArc.isIgnitable(player,block) || block.getType() == Material.AIR || block.getType() == Material.STEP || block.getType() == Material.WOOD_STEP || bPlayer.isAvatarState()) {
    player.setVelocity(player.getEyeLocation().getDirection().clone().normalize().multiply(speed));
    if (canFireGrief()) {
      if (block.getType() == Material.AIR) {
        createTempFire(block.getLocation());
      }
    }
 else     if (block.getType() == Material.AIR) {
      block.setType(Material.FIRE);
    }
    new Flight(player);
    player.setAllowFlight(true);
    time=System.currentTimeMillis();
    start();
    bPlayer.addCooldown(this);
  }
}",0.9295877417001096
133878,"private void pushWater(){
  if (bPlayer.hasElement(Element.AIR)) {
    radius=airRadius;
  }
 else {
    radius=waterRadius;
  }
  if (bPlayer.hasElement(Element.WATER) && isNight(player.getWorld())) {
    radius=WaterAbility.getNightFactor(waterRadius,player.getWorld());
  }
  if (airRadius > radius && bPlayer.hasElement(Element.AIR)) {
    radius=airRadius;
  }
  Location location=player.getLocation();
  for (  Block block : waterOrigins.keySet()) {
    if (block.getWorld() != location.getWorld()) {
      if (block.getType() == Material.AIR || isWater(block)) {
        waterOrigins.get(block).update(true);
      }
      waterOrigins.remove(block);
    }
 else     if (block.getLocation().distanceSquared(location) > radius * radius) {
      if (block.getType() == Material.AIR || isWater(block)) {
        waterOrigins.get(block).update(true);
      }
      waterOrigins.remove(block);
    }
  }
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,radius)) {
    if (waterOrigins.containsKey(block)) {
      continue;
    }
 else     if (!isWater(block)) {
      continue;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",block.getLocation())) {
      continue;
    }
 else     if (block.getType() == Material.STATIONARY_WATER || block.getType() == Material.WATER) {
      if (WaterManipulation.canBubbleWater(block)) {
        waterOrigins.put(block,block.getState());
        block.setType(Material.AIR);
      }
    }
  }
}","private void pushWater(){
  if (bPlayer.hasElement(Element.AIR)) {
    radius=airRadius;
  }
 else {
    radius=waterRadius;
  }
  if (bPlayer.hasElement(Element.WATER) && isNight(player.getWorld())) {
    radius=WaterAbility.getNightFactor(waterRadius,player.getWorld());
  }
  if (airRadius > radius && bPlayer.hasElement(Element.AIR)) {
    radius=airRadius;
  }
  Location location=player.getLocation();
  for (  Block block : waterOrigins.keySet()) {
    if (block.getWorld() != location.getWorld()) {
      if (block.getType() == Material.AIR || isWater(block)) {
        waterOrigins.get(block).update(true);
      }
      waterOrigins.remove(block);
    }
 else     if (block.getLocation().distanceSquared(location) > radius * radius) {
      if (block.getType() == Material.AIR || isWater(block)) {
        waterOrigins.get(block).update(true);
      }
      waterOrigins.remove(block);
    }
  }
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,radius)) {
    if (waterOrigins.containsKey(block)) {
      continue;
    }
 else     if (!isWater(block)) {
      continue;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",block.getLocation())) {
      continue;
    }
 else     if (block.getType() == Material.STATIONARY_WATER || block.getType() == Material.WATER) {
      if (WaterManipulation.canBubbleWater(block)) {
        waterOrigins.put(block,block.getState());
        block.setType(Material.AIR);
      }
    }
  }
  WaterAbility.removeWaterSpouts(location,radius,player);
}",0.9809084924292296
133879,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (System.currentTimeMillis() - time >= interval) {
    if (!progressing && !falling && !bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
    if (falling) {
      remove();
      new WaterReturn(player,sourceBlock);
      return;
    }
 else {
      if (!progressing) {
        if (!(isWater(sourceBlock.getType()) || (isIce(sourceBlock) && bPlayer.canIcebend()) || (isSnow(sourceBlock) && bPlayer.canIcebend())|| (isPlant(sourceBlock) && bPlayer.canPlantbend()))) {
          remove();
          return;
        }
        sourceBlock.getWorld().playEffect(location,Effect.SMOKE,4,(int)selectRange);
        return;
      }
      if (sourceBlock.getLocation().distanceSquared(firstDestination) < 0.5 * 0.5) {
        settingUp=false;
      }
      Vector direction;
      if (settingUp) {
        direction=firstDirection;
      }
 else {
        direction=targetDirection;
      }
      Block block=location.getBlock();
      if (displacing) {
        Block targetBlock=player.getTargetBlock((HashSet<Material>)null,dispelRange);
        direction=GeneralMethods.getDirection(location,targetBlock.getLocation()).normalize();
        if (!location.getBlock().equals(targetBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
          if (block.getLocation().equals(sourceBlock.getLocation())) {
            location=location.clone().add(direction);
            block=location.getBlock();
          }
        }
      }
 else {
        WaterAbility.removeWaterSpouts(location,player);
        AirAbility.removeAirSpouts(location,player);
        EarthAbility.removeSandSpouts(location,player);
        if ((new Random()).nextInt(4) == 0) {
          playWaterbendingSound(location);
        }
        double radius=collisionRadius;
        Player source=player;
        if (!(location == null)) {
          if (EarthBlast.annihilateBlasts(location,radius,source) || WaterManipulation.annihilateBlasts(location,radius,source) || FireBlast.annihilateBlasts(location,radius,source)) {
            remove();
            new WaterReturn(player,sourceBlock);
            return;
          }
          Combustion.removeAroundPoint(location,radius);
        }
        location=location.clone().add(direction);
        block=location.getBlock();
        if (block.getLocation().equals(sourceBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
        }
      }
      if (trail2 != null) {
        if (trail2.getBlock().equals(block)) {
          trail2.revertBlock();
          trail2=null;
        }
      }
      if (trail != null) {
        if (trail.getBlock().equals(block)) {
          trail.revertBlock();
          trail=null;
          if (trail2 != null) {
            trail2.revertBlock();
            trail2=null;
          }
        }
      }
      if (isTransparent(player,block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (block.getType() != Material.AIR && !isWater(block)) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      if (!displacing) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
          if (entity instanceof LivingEntity && entity.getEntityId() != player.getEntityId()) {
            Location location=player.getEyeLocation();
            Vector vector=location.getDirection();
            entity.setVelocity(vector.normalize().multiply(pushFactor));
            if (bPlayer.isAvatarState()) {
              damage=AvatarState.getValue(damage);
            }
            damage=getNightFactor(damage);
            DamageHandler.damageEntity(entity,damage,this);
            AirAbility.breakBreathbendingHold(entity);
            progressing=false;
          }
        }
      }
      if (!progressing) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      addWater(block);
      reduceWater(sourceBlock);
      if (trail2 != null) {
        trail2.revertBlock();
        trail2=null;
      }
      if (trail != null) {
        trail2=trail;
        trail2.setType(Material.STATIONARY_WATER,(byte)2);
      }
      trail=new TempBlock(sourceBlock,Material.STATIONARY_WATER,(byte)1);
      sourceBlock=block;
      if (location.distanceSquared(targetDestination) <= 1 || location.distanceSquared(firstDestination) > range * range) {
        falling=true;
        progressing=false;
      }
    }
  }
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (System.currentTimeMillis() - time >= interval) {
    if (!progressing && !falling && !bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
    if (falling) {
      remove();
      new WaterReturn(player,sourceBlock);
      return;
    }
 else {
      if (!progressing) {
        if (!(isWater(sourceBlock.getType()) || (isIce(sourceBlock) && bPlayer.canIcebend()) || (isSnow(sourceBlock) && bPlayer.canIcebend())|| (isPlant(sourceBlock) && bPlayer.canPlantbend()))) {
          remove();
          return;
        }
        sourceBlock.getWorld().playEffect(location,Effect.SMOKE,4,(int)selectRange);
        return;
      }
      if (sourceBlock.getLocation().distanceSquared(firstDestination) < 0.5 * 0.5) {
        settingUp=false;
      }
      Vector direction;
      if (settingUp) {
        direction=firstDirection;
      }
 else {
        direction=targetDirection;
      }
      Block block=location.getBlock();
      if (displacing) {
        Block targetBlock=player.getTargetBlock((HashSet<Material>)null,dispelRange);
        direction=GeneralMethods.getDirection(location,targetBlock.getLocation()).normalize();
        if (!location.getBlock().equals(targetBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
          if (block.getLocation().equals(sourceBlock.getLocation())) {
            location=location.clone().add(direction);
            block=location.getBlock();
          }
        }
      }
 else {
        WaterAbility.removeWaterSpouts(location,player);
        AirAbility.removeAirSpouts(location,player);
        EarthAbility.removeSandSpouts(location,player);
        if ((new Random()).nextInt(4) == 0) {
          playWaterbendingSound(location);
        }
        double radius=collisionRadius;
        Player source=player;
        if (!(location == null)) {
          if (EarthBlast.annihilateBlasts(location,radius,source) || WaterManipulation.annihilateBlasts(location,radius,source) || FireBlast.annihilateBlasts(location,radius,source)) {
            remove();
            new WaterReturn(player,sourceBlock);
            return;
          }
          Combustion.removeAroundPoint(location,radius);
        }
        location=location.clone().add(direction);
        block=location.getBlock();
        if (block.getLocation().equals(sourceBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
        }
      }
      if (trail2 != null) {
        if (!TempBlock.isTempBlock(block) && (trail2.getBlock().equals(block))) {
          trail2.revertBlock();
          trail2=null;
        }
      }
      if (trail != null) {
        if (!TempBlock.isTempBlock(block) && trail.getBlock().equals(block)) {
          trail.revertBlock();
          trail=null;
          if (trail2 != null) {
            trail2.revertBlock();
            trail2=null;
          }
        }
      }
      if (isTransparent(player,block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (block.getType() != Material.AIR && !isWater(block)) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      if (!displacing) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
          if (entity instanceof LivingEntity && entity.getEntityId() != player.getEntityId()) {
            Location location=player.getEyeLocation();
            Vector vector=location.getDirection();
            entity.setVelocity(vector.normalize().multiply(pushFactor));
            if (bPlayer.isAvatarState()) {
              damage=AvatarState.getValue(damage);
            }
            damage=getNightFactor(damage);
            DamageHandler.damageEntity(entity,damage,this);
            AirAbility.breakBreathbendingHold(entity);
            progressing=false;
          }
        }
      }
      if (!progressing) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      addWater(block);
      reduceWater(sourceBlock);
      if (trail2 != null) {
        trail2.revertBlock();
        trail2=null;
      }
      if (trail != null) {
        trail2=trail;
        trail2.setType(Material.STATIONARY_WATER,(byte)2);
      }
      trail=new TempBlock(sourceBlock,Material.STATIONARY_WATER,(byte)1);
      sourceBlock=block;
      if (location.distanceSquared(targetDestination) <= 1 || location.distanceSquared(firstDestination) > range * range) {
        falling=true;
        progressing=false;
      }
    }
  }
}",0.9928118393234672
133880,"private void displayWaterSpiral(Location location){
  if (!useBlockSpiral) {
    return;
  }
  double maxHeight=player.getLocation().getY() - location.getY() - .5;
  double height=0;
  rotation+=.4;
  int i=0;
  while (height < maxHeight) {
    i+=20;
    height+=.4;
    double angle=(i * Math.PI / 180);
    double x=1 * Math.cos(angle + rotation);
    double z=1 * Math.sin(angle + rotation);
    Location loc=location.clone().getBlock().getLocation().add(.5,.5,.5);
    loc.add(x,height,z);
    Block block=loc.getBlock();
    if (block.getType().equals(Material.AIR) || !GeneralMethods.isSolid(block)) {
      blocks.add(new TempBlock(block,Material.STATIONARY_WATER,(byte)1));
      AFFECTED_BLOCKS.put(block,block);
    }
  }
}","private void displayWaterSpiral(Location location){
  if (!useBlockSpiral) {
    return;
  }
  double maxHeight=player.getLocation().getY() - location.getY() - .5;
  double height=0;
  rotation+=.4;
  int i=0;
  while (height < maxHeight) {
    i+=20;
    height+=.4;
    double angle=(i * Math.PI / 180);
    double x=1 * Math.cos(angle + rotation);
    double z=1 * Math.sin(angle + rotation);
    Location loc=location.clone().getBlock().getLocation().add(.5,.5,.5);
    loc.add(x,height,z);
    Block block=loc.getBlock();
    if ((!TempBlock.isTempBlock(block)) && (block.getType().equals(Material.AIR) || !GeneralMethods.isSolid(block))) {
      blocks.add(new TempBlock(block,Material.STATIONARY_WATER,(byte)1));
      AFFECTED_BLOCKS.put(block,block);
    }
  }
}",0.9754152823920266
133881,"public static boolean removeSpouts(Location loc0,double radius,Player sourcePlayer){
  boolean removed=false;
  for (  WaterSpout spout : getAbilities(sourcePlayer,WaterSpout.class)) {
    Location top=spout.getLocation();
    Location base=spout.getBase().getLocation();
    double dist=top.getBlockY() - base.getBlockY();
    for (double d=0; d <= dist; d+=0.25) {
      Location spoutl=base.clone().add(0,d,0);
      if (loc0.distance(spoutl) <= radius) {
        removed=true;
        spout.remove();
      }
    }
  }
  return removed;
}","public static boolean removeSpouts(Location loc0,double radius,Player sourcePlayer){
  boolean removed=false;
  for (  WaterSpout spout : getAbilities(WaterSpout.class)) {
    Location top=spout.getLocation();
    Location base=spout.getBase().getLocation();
    double dist=top.getBlockY() - base.getBlockY();
    for (double d=0; d <= dist; d+=0.5) {
      Location spoutl=base.clone().add(0,d,0);
      if (loc0.distance(spoutl) <= radius) {
        removed=true;
        spout.remove();
      }
    }
  }
  return removed;
}",0.9869158878504672
133882,"private void freeze(){
  clearWave();
  if (!bPlayer.canIcebend()) {
    return;
  }
  double freezeradius=currentRadius;
  if (freezeradius > maxFreezeRadius) {
    freezeradius=maxFreezeRadius;
  }
  for (  Block block : GeneralMethods.getBlocksAroundPoint(frozenLocation,freezeradius)) {
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation()) || GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",block.getLocation())) {
      continue;
    }
 else     if (TempBlock.isTempBlock(block)) {
      continue;
    }
    if (block.getType() == Material.AIR || block.getType() == Material.SNOW) {
      new TempBlock(block,Material.ICE,(byte)0);
      frozenBlocks.put(block,block);
    }
    if (isWater(block)) {
      PhaseChangeFreeze.freeze(player,block);
    }
    if (isPlant(block) && block.getType() != Material.LEAVES) {
      block.breakNaturally();
      new TempBlock(block,Material.ICE,(byte)0);
      frozenBlocks.put(block,block);
    }
    for (    Block sound : frozenBlocks.keySet()) {
      if ((new Random()).nextInt(4) == 0) {
        playWaterbendingSound(sound.getLocation());
      }
    }
  }
}","private void freeze(){
  clearWave();
  if (!bPlayer.canIcebend()) {
    return;
  }
  double freezeradius=currentRadius;
  if (freezeradius > maxFreezeRadius) {
    freezeradius=maxFreezeRadius;
  }
  for (  Block block : GeneralMethods.getBlocksAroundPoint(frozenLocation,freezeradius)) {
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation()) || GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",block.getLocation())) {
      continue;
    }
 else     if (TempBlock.isTempBlock(block)) {
      continue;
    }
    Block oldBlock=block;
    if (block.getType() == Material.AIR || block.getType() == Material.SNOW || isWater(block)) {
      new TempBlock(block,Material.ICE,(byte)0);
      frozenBlocks.put(block,oldBlock.getType());
    }
    if (isPlant(block) && block.getType() != Material.LEAVES) {
      block.breakNaturally();
      new TempBlock(block,Material.ICE,(byte)0);
      frozenBlocks.put(block,oldBlock.getType());
    }
    for (    Block sound : frozenBlocks.keySet()) {
      if ((new Random()).nextInt(4) == 0) {
        playWaterbendingSound(sound.getLocation());
      }
    }
  }
}",0.927763272410792
133883,"public ConcurrentHashMap<Block,Block> getFrozenBlocks(){
  return frozenBlocks;
}","public ConcurrentHashMap<Block,Material> getFrozenBlocks(){
  return frozenBlocks;
}",0.9333333333333332
133884,"public static boolean removeSpouts(Location loc0,double radius,Player sourcePlayer){
  boolean removed=false;
  for (  WaterSpout spout : getAbilities(WaterSpout.class)) {
    Location top=spout.getLocation();
    Location base=spout.getBase().getLocation();
    double dist=top.getBlockY() - base.getBlockY();
    for (double d=0; d <= dist; d+=0.5) {
      Location spoutl=base.clone().add(0,d,0);
      if (loc0.distance(spoutl) <= radius) {
        removed=true;
        spout.remove();
      }
    }
  }
  return removed;
}","public static boolean removeSpouts(Location loc0,double radius,Player sourcePlayer){
  boolean removed=false;
  for (  WaterSpout spout : getAbilities(WaterSpout.class)) {
    if (!spout.player.equals(sourcePlayer)) {
      Location top=spout.getLocation();
      Location base=spout.getBase().getLocation();
      double dist=top.getBlockY() - base.getBlockY();
      for (double d=0; d <= dist; d+=0.5) {
        Location spoutl=base.clone().add(0,d,0);
        if (loc0.distance(spoutl) <= radius) {
          removed=true;
          spout.remove();
        }
      }
    }
  }
  return removed;
}",0.9361702127659576
133885,"public FireBlastCharged(Player player){
  super(player);
  if (!bPlayer.canBend(this) || hasAbility(player,FireBlastCharged.class)) {
    return;
  }
  this.charged=false;
  this.launched=false;
  this.canDamageBlocks=getConfig().getBoolean(""String_Node_Str"");
  this.dissipate=getConfig().getBoolean(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.time=System.currentTimeMillis();
  this.interval=25;
  this.collisionRadius=getConfig().getDouble(""String_Node_Str"");
  this.maxDamage=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.damageRadius=getConfig().getDouble(""String_Node_Str"");
  this.explosionRadius=getConfig().getDouble(""String_Node_Str"");
  this.fireTicks=getConfig().getDouble(""String_Node_Str"");
  this.innerRadius=damageRadius / 2;
  if (isDay(player.getWorld())) {
    this.chargeTime=(long)(chargeTime / getDayFactor());
  }
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.maxDamage=AvatarState.getValue(maxDamage);
  }
  this.range=getDayFactor(range);
  if (!player.getEyeLocation().getBlock().isLiquid()) {
    start();
  }
  if (isDay(player.getWorld())) {
    this.maxDamage=getDayFactor(maxDamage);
  }
}","public FireBlastCharged(Player player){
  super(player);
  if (!bPlayer.canBend(this) || hasAbility(player,FireBlastCharged.class)) {
    return;
  }
  this.charged=false;
  this.launched=false;
  this.canDamageBlocks=getConfig().getBoolean(""String_Node_Str"");
  this.dissipate=getConfig().getBoolean(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.time=System.currentTimeMillis();
  this.interval=25;
  this.collisionRadius=getConfig().getDouble(""String_Node_Str"");
  this.maxDamage=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.damageRadius=getConfig().getDouble(""String_Node_Str"");
  this.explosionRadius=getConfig().getDouble(""String_Node_Str"");
  this.fireTicks=getConfig().getDouble(""String_Node_Str"");
  this.innerRadius=damageRadius / 2;
  if (isDay(player.getWorld())) {
    this.chargeTime=(long)(chargeTime / getDayFactor());
    this.maxDamage=getDayFactor(maxDamage);
    this.range=getDayFactor(range);
  }
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.maxDamage=AvatarState.getValue(maxDamage);
  }
  if (!player.getEyeLocation().getBlock().isLiquid()) {
    start();
  }
}",0.919672131147541
133886,"public void returnWater(){
  if (location != null) {
    new WaterReturn(player,location.getBlock());
  }
}","public void returnWater(){
  if (location != null) {
    if (player.isOnline()) {
      new WaterReturn(player,location.getBlock());
    }
  }
}",0.852589641434263
133887,"public void manageAirVectors(){
  for (int i=0; i < tasks.size(); i++) {
    if (((FireComboStream)tasks.get(i)).isCancelled()) {
      tasks.remove(i);
      i--;
    }
  }
  if (tasks.size() == 0) {
    remove();
    return;
  }
  for (int i=0; i < tasks.size(); i++) {
    FireComboStream fstream=(FireComboStream)tasks.get(i);
    Location loc=fstream.getLocation();
    if (GeneralMethods.isRegionProtectedFromBuild(this,loc)) {
      fstream.remove();
      return;
    }
    if (!isTransparent(loc.getBlock())) {
      if (!isTransparent(loc.clone().add(0,0.2,0).getBlock())) {
        fstream.remove();
        return;
      }
    }
    if (i % 3 == 0) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
        if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
          remove();
          return;
        }
        if (!entity.equals(player) && !affectedEntities.contains(entity)) {
          affectedEntities.add(entity);
          if (knockback != 0) {
            Vector force=fstream.getDirection();
            entity.setVelocity(force.multiply(knockback));
          }
          if (damage != 0) {
            if (entity instanceof LivingEntity) {
              if (fstream.getAbility().equalsIgnoreCase(""String_Node_Str"")) {
                DamageHandler.damageEntity(entity,damage,this);
              }
 else {
                DamageHandler.damageEntity(entity,damage,this);
              }
            }
          }
        }
      }
      if (GeneralMethods.blockAbilities(player,FireCombo.getBlockableAbilities(),loc,1)) {
        fstream.remove();
      }
    }
  }
}","public void manageAirVectors(){
  for (int i=0; i < tasks.size(); i++) {
    if (((FireComboStream)tasks.get(i)).isCancelled()) {
      tasks.remove(i);
      i--;
    }
  }
  if (tasks.size() == 0) {
    remove();
    return;
  }
  for (int i=0; i < tasks.size(); i++) {
    FireComboStream fstream=(FireComboStream)tasks.get(i);
    Location loc=fstream.getLocation();
    if (GeneralMethods.isRegionProtectedFromBuild(this,loc)) {
      fstream.remove();
      return;
    }
    if (!isTransparent(loc.getBlock())) {
      if (!isTransparent(loc.clone().add(0,0.2,0).getBlock())) {
        fstream.remove();
        return;
      }
    }
    if (i % 3 == 0) {
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(loc,2.5)) {
        if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
          remove();
          return;
        }
        if (!entity.equals(player) && !affectedEntities.contains(entity)) {
          affectedEntities.add(entity);
          if (knockback != 0) {
            Vector force=fstream.getDirection();
            entity.setVelocity(force.multiply(knockback));
          }
          if (damage != 0) {
            if (entity instanceof LivingEntity) {
              if (fstream.getAbility().equalsIgnoreCase(""String_Node_Str"")) {
                DamageHandler.damageEntity(entity,damage,this);
              }
 else {
                DamageHandler.damageEntity(entity,damage,this);
              }
            }
          }
        }
      }
      if (GeneralMethods.blockAbilities(player,FireCombo.getBlockableAbilities(),loc,1)) {
        fstream.remove();
      }
 else       AirAbility.removeAirSpouts(loc,player);
      WaterAbility.removeWaterSpouts(loc,player);
      EarthAbility.removeSandSpouts(loc,player);
    }
  }
}",0.9562699102229943
133888,"@SuppressWarnings(""String_Node_Str"") private void advanceSwipe(){
  affectedEntities.clear();
  for (  Vector direction : elements.keySet()) {
    Location location=elements.get(direction);
    if (direction != null && location != null) {
      location=location.clone().add(direction.clone().multiply(speed));
      elements.put(direction,location);
      if (location.distanceSquared(origin) > range * range || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        elements.remove(direction);
      }
 else {
        removeAirSpouts(location,player);
        WaterAbility.removeWaterSpouts(location,player);
        if (EarthBlast.annihilateBlasts(location,radius,player) || WaterManipulation.annihilateBlasts(location,radius,player) || FireBlast.annihilateBlasts(location,radius,player)|| Combustion.removeAroundPoint(location,radius)) {
          elements.remove(direction);
          damage=0;
          remove();
          continue;
        }
        Block block=location.getBlock();
        for (        Block testblock : GeneralMethods.getBlocksAroundPoint(location,radius)) {
          if (testblock.getType() == Material.FIRE) {
            testblock.setType(Material.AIR);
          }
          if (isBlockBreakable(testblock)) {
            GeneralMethods.breakBlock(testblock);
          }
        }
        if (block.getType() != Material.AIR) {
          if (isBlockBreakable(block)) {
            GeneralMethods.breakBlock(block);
          }
 else {
            elements.remove(direction);
          }
          if (isLava(block)) {
            if (block.getData() == 0x0) {
              block.setType(Material.OBSIDIAN);
            }
 else {
              block.setType(Material.COBBLESTONE);
            }
          }
        }
 else {
          playAirbendingParticles(location,particles,0.2F,0.2F,0);
          if (random.nextInt(4) == 0) {
            playAirbendingSound(location);
          }
          affectPeople(location,direction);
        }
      }
    }
  }
  if (elements.isEmpty()) {
    remove();
  }
}","@SuppressWarnings(""String_Node_Str"") private void advanceSwipe(){
  affectedEntities.clear();
  for (  Vector direction : elements.keySet()) {
    Location location=elements.get(direction);
    if (direction != null && location != null) {
      location=location.clone().add(direction.clone().multiply(speed));
      elements.put(direction,location);
      if (location.distanceSquared(origin) > range * range || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        elements.remove(direction);
      }
 else {
        removeAirSpouts(location,player);
        WaterAbility.removeWaterSpouts(location,player);
        EarthAbility.removeSandSpouts(location,player);
        if (EarthBlast.annihilateBlasts(location,radius,player) || WaterManipulation.annihilateBlasts(location,radius,player) || FireBlast.annihilateBlasts(location,radius,player)|| Combustion.removeAroundPoint(location,radius)) {
          elements.remove(direction);
          damage=0;
          remove();
          continue;
        }
        Block block=location.getBlock();
        for (        Block testblock : GeneralMethods.getBlocksAroundPoint(location,radius)) {
          if (testblock.getType() == Material.FIRE) {
            testblock.setType(Material.AIR);
          }
          if (isBlockBreakable(testblock)) {
            GeneralMethods.breakBlock(testblock);
          }
        }
        if (block.getType() != Material.AIR) {
          if (isBlockBreakable(block)) {
            GeneralMethods.breakBlock(block);
          }
 else {
            elements.remove(direction);
          }
          if (isLava(block)) {
            if (block.getData() == 0x0) {
              block.setType(Material.OBSIDIAN);
            }
 else {
              block.setType(Material.COBBLESTONE);
            }
          }
        }
 else {
          playAirbendingParticles(location,particles,0.2F,0.2F,0);
          if (random.nextInt(4) == 0) {
            playAirbendingSound(location);
          }
          affectPeople(location,direction);
        }
      }
    }
  }
  if (elements.isEmpty()) {
    remove();
  }
}",0.9865384615384616
133889,"private void affectPeople(Location location,Vector direction){
  WaterAbility.removeWaterSpouts(location,player);
  removeAirSpouts(location,player);
  final List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location,radius);
  final Vector fDirection=direction;
  for (int i=0; i < entities.size(); i++) {
    final Entity entity=entities.get(i);
    new BukkitRunnable(){
      public void run(){
        if (GeneralMethods.isRegionProtectedFromBuild(AirSwipe.this,entity.getLocation())) {
          return;
        }
        if (entity.getEntityId() != player.getEntityId() && entity instanceof LivingEntity) {
          if (entity instanceof Player) {
            if (Commands.invincible.contains(((Player)entity).getName())) {
              return;
            }
          }
          if (entities.size() < MAX_AFFECTABLE_ENTITIES) {
            if (bPlayer.isAvatarState()) {
              GeneralMethods.setVelocity(entity,fDirection.multiply(AvatarState.getValue(pushFactor)));
            }
 else {
              GeneralMethods.setVelocity(entity,fDirection.multiply(pushFactor));
            }
          }
          if (entity instanceof LivingEntity && !affectedEntities.contains(entity)) {
            if (damage != 0) {
              DamageHandler.damageEntity(entity,damage,ability);
            }
            affectedEntities.add(entity);
          }
          if (entity instanceof Player) {
            new Flight((Player)entity,player);
          }
          breakBreathbendingHold(entity);
          if (elements.containsKey(fDirection)) {
            elements.remove(fDirection);
          }
        }
 else         if (entity.getEntityId() != player.getEntityId() && !(entity instanceof LivingEntity)) {
          if (bPlayer.isAvatarState()) {
            GeneralMethods.setVelocity(entity,fDirection.multiply(AvatarState.getValue(pushFactor)));
          }
 else {
            GeneralMethods.setVelocity(entity,fDirection.multiply(pushFactor));
          }
        }
      }
    }
.runTaskLater(ProjectKorra.plugin,i / MAX_AFFECTABLE_ENTITIES);
  }
}","private void affectPeople(Location location,Vector direction){
  WaterAbility.removeWaterSpouts(location,player);
  removeAirSpouts(location,player);
  removeAirSpouts(location,player);
  final List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location,radius);
  final Vector fDirection=direction;
  for (int i=0; i < entities.size(); i++) {
    final Entity entity=entities.get(i);
    new BukkitRunnable(){
      public void run(){
        if (GeneralMethods.isRegionProtectedFromBuild(AirSwipe.this,entity.getLocation())) {
          return;
        }
        if (entity.getEntityId() != player.getEntityId() && entity instanceof LivingEntity) {
          if (entity instanceof Player) {
            if (Commands.invincible.contains(((Player)entity).getName())) {
              return;
            }
          }
          if (entities.size() < MAX_AFFECTABLE_ENTITIES) {
            if (bPlayer.isAvatarState()) {
              GeneralMethods.setVelocity(entity,fDirection.multiply(AvatarState.getValue(pushFactor)));
            }
 else {
              GeneralMethods.setVelocity(entity,fDirection.multiply(pushFactor));
            }
          }
          if (entity instanceof LivingEntity && !affectedEntities.contains(entity)) {
            if (damage != 0) {
              DamageHandler.damageEntity(entity,damage,ability);
            }
            affectedEntities.add(entity);
          }
          if (entity instanceof Player) {
            new Flight((Player)entity,player);
          }
          breakBreathbendingHold(entity);
          if (elements.containsKey(fDirection)) {
            elements.remove(fDirection);
          }
        }
 else         if (entity.getEntityId() != player.getEntityId() && !(entity instanceof LivingEntity)) {
          if (bPlayer.isAvatarState()) {
            GeneralMethods.setVelocity(entity,fDirection.multiply(AvatarState.getValue(pushFactor)));
          }
 else {
            GeneralMethods.setVelocity(entity,fDirection.multiply(pushFactor));
          }
        }
      }
    }
.runTaskLater(ProjectKorra.plugin,i / MAX_AFFECTABLE_ENTITIES);
  }
}",0.991432651118515
133890,"@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),0,1) || !isPlayer(sender)) {
    return;
  }
 else   if (MultiAbilityManager.hasMultiAbilityBound((Player)sender)) {
    sender.sendMessage(ChatColor.RED + cantEditBinds);
    return;
  }
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(sender.getName());
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(((Player)sender).getUniqueId(),sender.getName());
    bPlayer=BendingPlayer.getBendingPlayer(sender.getName());
  }
  if (args.size() == 0) {
    bPlayer.getAbilities().clear();
    for (int i=1; i <= 9; i++) {
      GeneralMethods.saveAbility(bPlayer,i,null);
    }
    sender.sendMessage(ChatColor.YELLOW + cleared);
  }
 else   if (args.size() == 1) {
    try {
      int slot=Integer.parseInt(args.get(0));
      if (slot < 1 || slot > 9) {
        sender.sendMessage(ChatColor.RED + wrongNumber);
      }
      if (bPlayer.getAbilities().get(slot) != null) {
        bPlayer.getAbilities().remove(slot);
        GeneralMethods.saveAbility(bPlayer,slot,null);
        sender.sendMessage(clearedSlot.replace(""String_Node_Str"",String.valueOf(slot)));
      }
 else {
        sender.sendMessage(ChatColor.YELLOW + alreadyEmpty);
      }
    }
 catch (    NumberFormatException e) {
      sender.sendMessage(ChatColor.RED + wrongNumber);
    }
  }
}","@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),0,1) || !isPlayer(sender)) {
    return;
  }
 else   if (MultiAbilityManager.hasMultiAbilityBound((Player)sender)) {
    sender.sendMessage(ChatColor.RED + cantEditBinds);
    return;
  }
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(sender.getName());
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(((Player)sender).getUniqueId(),sender.getName());
    bPlayer=BendingPlayer.getBendingPlayer(sender.getName());
  }
  if (args.size() == 0) {
    bPlayer.getAbilities().clear();
    for (int i=1; i <= 9; i++) {
      GeneralMethods.saveAbility(bPlayer,i,null);
    }
    sender.sendMessage(ChatColor.YELLOW + cleared);
  }
 else   if (args.size() == 1) {
    try {
      int slot=Integer.parseInt(args.get(0));
      if (slot < 1 || slot > 9) {
        sender.sendMessage(ChatColor.RED + wrongNumber);
      }
      if (bPlayer.getAbilities().get(slot) != null) {
        bPlayer.getAbilities().remove(slot);
        GeneralMethods.saveAbility(bPlayer,slot,null);
        sender.sendMessage(ChatColor.YELLOW + clearedSlot.replace(""String_Node_Str"",String.valueOf(slot)));
      }
 else {
        sender.sendMessage(ChatColor.YELLOW + alreadyEmpty);
      }
    }
 catch (    NumberFormatException e) {
      sender.sendMessage(ChatColor.RED + wrongNumber);
    }
  }
}",0.9194512838550828
133891,"@SuppressWarnings(""String_Node_Str"") @Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (System.currentTimeMillis() - time >= interval) {
    time=System.currentTimeMillis();
    if (isAtDestination) {
      remove();
      return;
    }
 else     if (!isEarthbendable(sourceBlock) && sourceBlock.getType() != Material.COBBLESTONE) {
      remove();
      return;
    }
    if (!isProgressing && !isAtDestination) {
      if (sourceBlock == null || !bPlayer.getBoundAbilityName().equals(getName())) {
        remove();
        return;
      }
 else       if (!player.getWorld().equals(sourceBlock.getWorld())) {
        remove();
        return;
      }
 else       if (sourceBlock.getLocation().distanceSquared(player.getLocation()) > selectRange * selectRange) {
        remove();
        return;
      }
    }
    if (isAtDestination) {
      remove();
      return;
    }
 else {
      if (!isProgressing) {
        return;
      }
      if (sourceBlock.getY() == firstDestination.getBlockY()) {
        isSettingUp=false;
      }
      Vector direction;
      if (isSettingUp) {
        direction=GeneralMethods.getDirection(location,firstDestination).normalize();
      }
 else {
        direction=GeneralMethods.getDirection(location,destination).normalize();
      }
      location=location.clone().add(direction);
      Block block=location.getBlock();
      WaterAbility.removeWaterSpouts(location,player);
      AirAbility.removeAirSpouts(location,player);
      if (block.getLocation().equals(sourceBlock.getLocation())) {
        location=location.clone().add(direction);
        block=location.getBlock();
      }
      if (isTransparent(block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (!isSettingUp) {
        remove();
        return;
      }
 else {
        location=location.clone().subtract(direction);
        direction=GeneralMethods.getDirection(location,destination).normalize();
        location=location.clone().add(direction);
        WaterAbility.removeWaterSpouts(location,player);
        AirAbility.removeAirSpouts(location,player);
        if (EarthBlast.annihilateBlasts(location,collisionRadius,player) || WaterManipulation.annihilateBlasts(location,collisionRadius,player) || FireBlast.annihilateBlasts(location,collisionRadius,player)) {
          remove();
          return;
        }
        Combustion.removeAroundPoint(location,collisionRadius);
        Block block2=location.getBlock();
        if (block2.getLocation().equals(sourceBlock.getLocation())) {
          location=location.clone().add(direction);
          block2=location.getBlock();
        }
        if (isTransparent(block) && !block.isLiquid()) {
          GeneralMethods.breakBlock(block);
        }
 else {
          remove();
          return;
        }
      }
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
        if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
          continue;
        }
        if (entity instanceof LivingEntity && (entity.getEntityId() != player.getEntityId() || canHitSelf)) {
          AirAbility.breakBreathbendingHold(entity);
          Location location=player.getEyeLocation();
          Vector vector=location.getDirection();
          entity.setVelocity(vector.normalize().multiply(pushFactor));
          double damage=this.damage;
          if (isMetal(sourceBlock) && bPlayer.canMetalbend()) {
            damage=getMetalAugment(damage);
          }
          DamageHandler.damageEntity(entity,damage,this);
          isProgressing=false;
        }
      }
      if (!isProgressing) {
        remove();
        return;
      }
      if (isEarthRevertOn()) {
        sourceBlock.setType(sourceType);
        sourceBlock.setData(sourceData);
        if (sourceBlock.getType() == Material.RED_SANDSTONE && sourceType == Material.SAND) {
          sourceBlock.setData((byte)0x1);
        }
        moveEarthBlock(sourceBlock,block);
        if (block.getType() == Material.SAND) {
          block.setType(Material.SANDSTONE);
        }
        if (block.getType() == Material.GRAVEL) {
          block.setType(Material.STONE);
        }
      }
 else {
        block.setType(sourceBlock.getType());
        sourceBlock.setType(Material.AIR);
      }
      sourceBlock=block;
      if (location.distanceSquared(destination) < 1) {
        if (sourceType == Material.SAND || sourceType == Material.GRAVEL) {
          isProgressing=false;
          if (sourceBlock.getType() == Material.RED_SANDSTONE) {
            sourceType=Material.SAND;
            sourceBlock.setType(sourceType);
            sourceBlock.setData((byte)0x1);
          }
 else {
            sourceBlock.setType(sourceType);
          }
        }
        isAtDestination=true;
        isProgressing=false;
      }
      return;
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (System.currentTimeMillis() - time >= interval) {
    time=System.currentTimeMillis();
    if (isAtDestination) {
      remove();
      return;
    }
 else     if (!isEarthbendable(sourceBlock) && sourceBlock.getType() != Material.COBBLESTONE) {
      remove();
      return;
    }
    if (!isProgressing && !isAtDestination) {
      if (sourceBlock == null || !bPlayer.getBoundAbilityName().equals(getName())) {
        remove();
        return;
      }
 else       if (!player.getWorld().equals(sourceBlock.getWorld())) {
        remove();
        return;
      }
 else       if (sourceBlock.getLocation().distanceSquared(player.getLocation()) > selectRange * selectRange) {
        remove();
        return;
      }
    }
    if (isAtDestination) {
      remove();
      return;
    }
 else {
      if (!isProgressing) {
        return;
      }
      if (sourceBlock.getY() == firstDestination.getBlockY()) {
        isSettingUp=false;
      }
      Vector direction;
      if (isSettingUp) {
        direction=GeneralMethods.getDirection(location,firstDestination).normalize();
      }
 else {
        direction=GeneralMethods.getDirection(location,destination).normalize();
      }
      location=location.clone().add(direction);
      Block block=location.getBlock();
      WaterAbility.removeWaterSpouts(location,player);
      AirAbility.removeAirSpouts(location,player);
      EarthAbility.removeSandSpouts(location,player);
      if (block.getLocation().equals(sourceBlock.getLocation())) {
        location=location.clone().add(direction);
        block=location.getBlock();
      }
      if (isTransparent(block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (!isSettingUp) {
        remove();
        return;
      }
 else {
        location=location.clone().subtract(direction);
        direction=GeneralMethods.getDirection(location,destination).normalize();
        location=location.clone().add(direction);
        WaterAbility.removeWaterSpouts(location,player);
        AirAbility.removeAirSpouts(location,player);
        EarthAbility.removeSandSpouts(location,player);
        if (EarthBlast.annihilateBlasts(location,collisionRadius,player) || WaterManipulation.annihilateBlasts(location,collisionRadius,player) || FireBlast.annihilateBlasts(location,collisionRadius,player)) {
          remove();
          return;
        }
        Combustion.removeAroundPoint(location,collisionRadius);
        Block block2=location.getBlock();
        if (block2.getLocation().equals(sourceBlock.getLocation())) {
          location=location.clone().add(direction);
          block2=location.getBlock();
        }
        if (isTransparent(block) && !block.isLiquid()) {
          GeneralMethods.breakBlock(block);
        }
 else {
          remove();
          return;
        }
      }
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
        if (GeneralMethods.isRegionProtectedFromBuild(this,entity.getLocation())) {
          continue;
        }
        if (entity instanceof LivingEntity && (entity.getEntityId() != player.getEntityId() || canHitSelf)) {
          AirAbility.breakBreathbendingHold(entity);
          Location location=player.getEyeLocation();
          Vector vector=location.getDirection();
          entity.setVelocity(vector.normalize().multiply(pushFactor));
          double damage=this.damage;
          if (isMetal(sourceBlock) && bPlayer.canMetalbend()) {
            damage=getMetalAugment(damage);
          }
          DamageHandler.damageEntity(entity,damage,this);
          isProgressing=false;
        }
      }
      if (!isProgressing) {
        remove();
        return;
      }
      if (isEarthRevertOn()) {
        sourceBlock.setType(sourceType);
        sourceBlock.setData(sourceData);
        if (sourceBlock.getType() == Material.RED_SANDSTONE && sourceType == Material.SAND) {
          sourceBlock.setData((byte)0x1);
        }
        moveEarthBlock(sourceBlock,block);
        if (block.getType() == Material.SAND) {
          block.setType(Material.SANDSTONE);
        }
        if (block.getType() == Material.GRAVEL) {
          block.setType(Material.STONE);
        }
      }
 else {
        block.setType(sourceBlock.getType());
        sourceBlock.setType(Material.AIR);
      }
      sourceBlock=block;
      if (location.distanceSquared(destination) < 1) {
        if (sourceType == Material.SAND || sourceType == Material.GRAVEL) {
          isProgressing=false;
          if (sourceBlock.getType() == Material.RED_SANDSTONE) {
            sourceType=Material.SAND;
            sourceBlock.setType(sourceType);
            sourceBlock.setData((byte)0x1);
          }
 else {
            sourceBlock.setType(sourceType);
          }
        }
        isAtDestination=true;
        isProgressing=false;
      }
      return;
    }
  }
}",0.9890131841789852
133892,"@Override public void progress(){
  progressCounter++;
  if (state == State.LIFTED && removeTimer > 0 && System.currentTimeMillis() - startTime > removeTimer) {
    remove();
    return;
  }
  if (state == State.START) {
    if (!bPlayer.canBend(this)) {
      remove();
      return;
    }
  }
 else   if (state == State.START || state == State.FLYING || state == State.GRABBED) {
    if (!bPlayer.canBendIgnoreCooldowns(this)) {
      remove();
      return;
    }
  }
  if (state == State.START && progressCounter > 1) {
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - startTime >= chargeTime) {
        origin=getEarthSourceBlock(selectRange);
        if (origin == null) {
          remove();
          return;
        }
        bPlayer.addCooldown(this);
        location=origin.getLocation();
        state=State.LIFTING;
      }
 else {
        remove();
        return;
      }
    }
 else     if (System.currentTimeMillis() - startTime > chargeTime) {
      Location tempLoc=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(1.2));
      tempLoc.add(0,0.3,0);
      ParticleEffect.SMOKE.display(tempLoc,0.3F,0.1F,0.3F,0,4);
    }
  }
 else   if (state == State.LIFTING) {
    if (System.currentTimeMillis() - delay >= liftAnimationInterval) {
      delay=System.currentTimeMillis();
      animateLift();
    }
  }
 else   if (state == State.GRABBED) {
    if (player.isSneaking()) {
      revert();
      Location oldLoc=location.clone();
      location=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(grabbedDistance));
      for (      Block block : getBlocks()) {
        if (block.getType() != Material.AIR && !isTransparent(block)) {
          location=oldLoc;
          break;
        }
      }
      WaterAbility.removeWaterSpouts(location,2,player);
      AirAbility.removeAirSpouts(location,2,player);
      draw();
      return;
    }
 else {
      state=State.LIFTED;
      return;
    }
  }
 else   if (state == State.SHOT) {
    if (System.currentTimeMillis() - delay >= shootAnimationInterval) {
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        remove();
        return;
      }
      revert();
      location.add(GeneralMethods.getDirection(location,destination).normalize().multiply(1));
      if (location.distanceSquared(destination) < 4) {
        remove();
        return;
      }
      int badBlocksFound=0;
      for (      Block block : getBlocks()) {
        if (block.getType() != Material.AIR && (!isTransparent(block) || block.getType() == Material.WATER || block.getType() == Material.STATIONARY_WATER)) {
          badBlocksFound++;
        }
      }
      if (badBlocksFound > maxBlocksToPassThrough) {
        remove();
        return;
      }
      WaterAbility.removeWaterSpouts(location,2,player);
      AirAbility.removeAirSpouts(location,2,player);
      shootingCollisionDetection();
      draw();
      smashToSmashCollisionDetection();
    }
    return;
  }
 else   if (state == State.FLYING) {
    if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (System.currentTimeMillis() - delay >= flightAnimationInterval) {
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        remove();
        return;
      }
      revert();
      destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(shootRange));
      Vector direction=GeneralMethods.getDirection(location,destination).normalize();
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location.clone().add(0,2,0),flightDetectionRadius);
      if (entities.size() == 0) {
        remove();
        return;
      }
      for (      Entity entity : entities) {
        entity.setVelocity(direction.clone().multiply(flightSpeed));
      }
      if (direction.getY() < -0.35) {
        location=player.getLocation().clone().add(0,-3.2,0);
      }
 else       if (direction.getY() > 0.35) {
        location=player.getLocation().clone().add(0,-1.7,0);
      }
 else {
        location=player.getLocation().clone().add(0,-2.2,0);
      }
      draw();
    }
    if (System.currentTimeMillis() - flightStartTime > flightRemoveTimer) {
      remove();
      return;
    }
  }
}","@Override public void progress(){
  progressCounter++;
  if (state == State.LIFTED && removeTimer > 0 && System.currentTimeMillis() - startTime > removeTimer) {
    remove();
    return;
  }
  if (state == State.START) {
    if (!bPlayer.canBend(this)) {
      remove();
      return;
    }
  }
 else   if (state == State.START || state == State.FLYING || state == State.GRABBED) {
    if (!bPlayer.canBendIgnoreCooldowns(this)) {
      remove();
      return;
    }
  }
  if (state == State.START && progressCounter > 1) {
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - startTime >= chargeTime) {
        origin=getEarthSourceBlock(selectRange);
        if (origin == null) {
          remove();
          return;
        }
        bPlayer.addCooldown(this);
        location=origin.getLocation();
        state=State.LIFTING;
      }
 else {
        remove();
        return;
      }
    }
 else     if (System.currentTimeMillis() - startTime > chargeTime) {
      Location tempLoc=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(1.2));
      tempLoc.add(0,0.3,0);
      ParticleEffect.SMOKE.display(tempLoc,0.3F,0.1F,0.3F,0,4);
    }
  }
 else   if (state == State.LIFTING) {
    if (System.currentTimeMillis() - delay >= liftAnimationInterval) {
      delay=System.currentTimeMillis();
      animateLift();
    }
  }
 else   if (state == State.GRABBED) {
    if (player.isSneaking()) {
      revert();
      Location oldLoc=location.clone();
      location=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(grabbedDistance));
      for (      Block block : getBlocks()) {
        if (block.getType() != Material.AIR && !isTransparent(block)) {
          location=oldLoc;
          break;
        }
      }
      WaterAbility.removeWaterSpouts(location,2,player);
      AirAbility.removeAirSpouts(location,2,player);
      EarthAbility.removeSandSpouts(location,player);
      draw();
      return;
    }
 else {
      state=State.LIFTED;
      return;
    }
  }
 else   if (state == State.SHOT) {
    if (System.currentTimeMillis() - delay >= shootAnimationInterval) {
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        remove();
        return;
      }
      revert();
      location.add(GeneralMethods.getDirection(location,destination).normalize().multiply(1));
      if (location.distanceSquared(destination) < 4) {
        remove();
        return;
      }
      int badBlocksFound=0;
      for (      Block block : getBlocks()) {
        if (block.getType() != Material.AIR && (!isTransparent(block) || block.getType() == Material.WATER || block.getType() == Material.STATIONARY_WATER)) {
          badBlocksFound++;
        }
      }
      if (badBlocksFound > maxBlocksToPassThrough) {
        remove();
        return;
      }
      WaterAbility.removeWaterSpouts(location,2,player);
      AirAbility.removeAirSpouts(location,2,player);
      shootingCollisionDetection();
      draw();
      smashToSmashCollisionDetection();
    }
    return;
  }
 else   if (state == State.FLYING) {
    if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (System.currentTimeMillis() - delay >= flightAnimationInterval) {
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        remove();
        return;
      }
      revert();
      destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(shootRange));
      Vector direction=GeneralMethods.getDirection(location,destination).normalize();
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location.clone().add(0,2,0),flightDetectionRadius);
      if (entities.size() == 0) {
        remove();
        return;
      }
      for (      Entity entity : entities) {
        entity.setVelocity(direction.clone().multiply(flightSpeed));
      }
      if (direction.getY() < -0.35) {
        location=player.getLocation().clone().add(0,-3.2,0);
      }
 else       if (direction.getY() > 0.35) {
        location=player.getLocation().clone().add(0,-1.7,0);
      }
 else {
        location=player.getLocation().clone().add(0,-2.2,0);
      }
      draw();
    }
    if (System.currentTimeMillis() - flightStartTime > flightRemoveTimer) {
      remove();
      return;
    }
  }
}",0.9938900203665988
133893,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreCooldowns(this) || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  if (GeneralMethods.isSolid(block) || block.isLiquid()) {
    if (block.getType() == Material.FURNACE && powerFurnace) {
      Furnace furnace=(Furnace)block.getState();
      furnace.setBurnTime((short)800);
      furnace.setCookTime((short)800);
      furnace.update();
    }
 else     if (BlazeArc.isIgnitable(player,block.getRelative(BlockFace.UP))) {
      ignite(location);
    }
    remove();
    return;
  }
  if (location.distanceSquared(origin) > range * range) {
    remove();
    return;
  }
  WaterAbility.removeWaterSpouts(location,player);
  AirAbility.removeAirSpouts(location,player);
  Player source=player;
  if (EarthBlast.annihilateBlasts(location,collisionRadius,source) || WaterManipulation.annihilateBlasts(location,collisionRadius,source) || FireBlast.annihilateBlasts(location,collisionRadius,source)) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
    affect(entity);
    if (entity instanceof LivingEntity) {
      break;
    }
  }
  advanceLocation();
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreCooldowns(this) || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  if (GeneralMethods.isSolid(block) || block.isLiquid()) {
    if (block.getType() == Material.FURNACE && powerFurnace) {
      Furnace furnace=(Furnace)block.getState();
      furnace.setBurnTime((short)800);
      furnace.setCookTime((short)800);
      furnace.update();
    }
 else     if (BlazeArc.isIgnitable(player,block.getRelative(BlockFace.UP))) {
      ignite(location);
    }
    remove();
    return;
  }
  if (location.distanceSquared(origin) > range * range) {
    remove();
    return;
  }
  WaterAbility.removeWaterSpouts(location,player);
  AirAbility.removeAirSpouts(location,player);
  EarthAbility.removeSandSpouts(location,player);
  Player source=player;
  if (EarthBlast.annihilateBlasts(location,collisionRadius,source) || WaterManipulation.annihilateBlasts(location,collisionRadius,source) || FireBlast.annihilateBlasts(location,collisionRadius,source)) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
    affect(entity);
    if (entity instanceof LivingEntity) {
      break;
    }
  }
  advanceLocation();
}",0.9823446327683616
133894,"@Override public void progress(){
  progressCounter++;
  for (int i=0; i < tasks.size(); i++) {
    BukkitRunnable br=tasks.get(i);
    if (br instanceof FireComboStream) {
      FireComboStream fs=(FireComboStream)br;
      if (fs.isCancelled()) {
        tasks.remove(fs);
      }
    }
  }
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      Vector eyeDir=player.getEyeLocation().getDirection().normalize().multiply(range);
      destination=player.getEyeLocation().add(eyeDir);
      player.getWorld().playSound(player.getLocation(),Sound.HORSE_JUMP,0.5f,0f);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,1f);
      for (int i=-30; i <= 30; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setSpread(0.2F);
        fs.setDensity(5);
        fs.setUseNewParticles(true);
        if (tasks.size() % 3 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
        player.getWorld().playSound(player.getLocation(),Sound.FIRE_IGNITE,0.5f,1f);
      }
      location=tasks.get(0).getLocation();
      for (      FireComboStream stream : tasks) {
        if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,stream.location,2)) {
          stream.remove();
        }
      }
    }
 else     if (tasks.size() == 0) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      destination=player.getEyeLocation().add(range,0,range);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,0.5f);
      for (int i=0; i <= 360; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i - 180);
        vec.setY(0);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation().clone().add(0,1,0),range,speed,""String_Node_Str"");
        fs.setSpread(0.0F);
        fs.setDensity(1);
        fs.setUseNewParticles(true);
        if (tasks.size() % 10 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    if (tasks.size() == 0) {
      remove();
      return;
    }
    for (    FireComboStream stream : tasks) {
      if (isWithinFireShield(stream.getLocation())) {
        stream.remove();
      }
      if (AirAbility.isWithinAirShield(stream.getLocation())) {
        stream.remove();
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      if (firstTime) {
        if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
          remove();
          return;
        }
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
        firstTime=false;
        float spread=0F;
        ParticleEffect.LARGE_EXPLODE.display(player.getLocation(),spread,spread,spread,0,1);
        player.getWorld().playSound(player.getLocation(),Sound.EXPLODE,15,0F);
      }
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,player.getVelocity().clone().multiply(-1),player.getLocation(),3,0.5,""String_Node_Str"");
      fs.setDensity(1);
      fs.setSpread(0.9F);
      fs.setUseNewParticles(true);
      fs.setCollides(false);
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (firstTime) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      firstTime=false;
    }
 else     if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      direction=player.getVelocity().clone().multiply(-1);
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,direction,player.getLocation(),5,1,""String_Node_Str"");
      fs.setDensity(8);
      fs.setSpread(1.0F);
      fs.setUseNewParticles(true);
      fs.setCollisionRadius(3);
      fs.setParticleEffect(ParticleEffect.LARGE_SMOKE);
      if (progressCounter % 5 != 0) {
        fs.setCollides(false);
      }
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
      if (progressCounter % 4 == 0) {
        player.getWorld().playSound(player.getLocation(),Sound.FIZZ,1,0F);
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (location == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      if (GeneralMethods.getTopBlock(player.getLocation(),3,3) == null) {
        remove();
        return;
      }
      location=player.getLocation();
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
    }
 else     if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(location,2,-4);
    if (topBlock == null || (WaterAbility.isWaterbendable(player,ability,topBlock) && !isPlant(topBlock))) {
      remove();
      return;
    }
 else     if (topBlock.getType() == Material.FIRE || ElementalAbility.isPlant(topBlock)) {
      topBlock=topBlock.getLocation().add(0,-1,0).getBlock();
    }
    location.setY(topBlock.getY() + height);
    FireComboStream fs=new FireComboStream(this,direction,location.clone().add(0,-1,0),5,1,""String_Node_Str"");
    fs.setDensity(0);
    fs.setSinglePoint(true);
    fs.setCollisionRadius(1.5);
    fs.setCollides(true);
    fs.runTaskTimer(ProjectKorra.plugin,0,1L);
    tasks.add(fs);
    for (double i=-180; i <= 180; i+=3) {
      Location tempLoc=location.clone();
      Vector newDir=direction.clone().multiply(radius * Math.cos(Math.toRadians(i)));
      tempLoc.add(newDir);
      tempLoc.setY(tempLoc.getY() + (radius * Math.sin(Math.toRadians(i))));
      ParticleEffect.FLAME.display(tempLoc,0,0,0,0,1);
    }
    location=location.add(direction.clone().multiply(speed));
    location.getWorld().playSound(location,Sound.FIRE,1,1);
    if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,location,2)) {
      remove();
      return;
    }
  }
}","@Override public void progress(){
  progressCounter++;
  for (int i=0; i < tasks.size(); i++) {
    BukkitRunnable br=tasks.get(i);
    if (br instanceof FireComboStream) {
      FireComboStream fs=(FireComboStream)br;
      if (fs.isCancelled()) {
        tasks.remove(fs);
      }
    }
  }
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      Vector eyeDir=player.getEyeLocation().getDirection().normalize().multiply(range);
      destination=player.getEyeLocation().add(eyeDir);
      player.getWorld().playSound(player.getLocation(),Sound.HORSE_JUMP,0.5f,0f);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,1f);
      for (int i=-30; i <= 30; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setSpread(0.2F);
        fs.setDensity(5);
        fs.setUseNewParticles(true);
        if (tasks.size() % 3 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
        player.getWorld().playSound(player.getLocation(),Sound.FIRE_IGNITE,0.5f,1f);
      }
      location=tasks.get(0).getLocation();
      for (      FireComboStream stream : tasks) {
        if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,stream.location,2)) {
          stream.remove();
        }
      }
    }
 else     if (tasks.size() == 0) {
      remove();
      return;
    }
    AirAbility.removeAirSpouts(location,player);
    WaterAbility.removeWaterSpouts(location,player);
    EarthAbility.removeSandSpouts(location,player);
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      destination=player.getEyeLocation().add(range,0,range);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,0.5f);
      for (int i=0; i <= 360; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i - 180);
        vec.setY(0);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation().clone().add(0,1,0),range,speed,""String_Node_Str"");
        fs.setSpread(0.0F);
        fs.setDensity(1);
        fs.setUseNewParticles(true);
        if (tasks.size() % 10 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    if (tasks.size() == 0) {
      remove();
      return;
    }
    for (    FireComboStream stream : tasks) {
      if (isWithinFireShield(stream.getLocation())) {
        stream.remove();
      }
      if (AirAbility.isWithinAirShield(stream.getLocation())) {
        stream.remove();
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      if (firstTime) {
        if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
          remove();
          return;
        }
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
        firstTime=false;
        float spread=0F;
        ParticleEffect.LARGE_EXPLODE.display(player.getLocation(),spread,spread,spread,0,1);
        player.getWorld().playSound(player.getLocation(),Sound.EXPLODE,15,0F);
      }
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,player.getVelocity().clone().multiply(-1),player.getLocation(),3,0.5,""String_Node_Str"");
      fs.setDensity(1);
      fs.setSpread(0.9F);
      fs.setUseNewParticles(true);
      fs.setCollides(false);
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (firstTime) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      firstTime=false;
    }
 else     if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      direction=player.getVelocity().clone().multiply(-1);
      FireJet fj=getAbility(player,FireJet.class);
      fj.setSpeed(speed);
      FireComboStream fs=new FireComboStream(this,direction,player.getLocation(),5,1,""String_Node_Str"");
      fs.setDensity(8);
      fs.setSpread(1.0F);
      fs.setUseNewParticles(true);
      fs.setCollisionRadius(3);
      fs.setParticleEffect(ParticleEffect.LARGE_SMOKE);
      if (progressCounter % 5 != 0) {
        fs.setCollides(false);
      }
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
      if (progressCounter % 4 == 0) {
        player.getWorld().playSound(player.getLocation(),Sound.FIZZ,1,0F);
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (location == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      if (GeneralMethods.getTopBlock(player.getLocation(),3,3) == null) {
        remove();
        return;
      }
      location=player.getLocation();
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
    }
 else     if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(location,2,-4);
    if (topBlock == null || (WaterAbility.isWaterbendable(player,ability,topBlock) && !isPlant(topBlock))) {
      remove();
      return;
    }
 else     if (topBlock.getType() == Material.FIRE || ElementalAbility.isPlant(topBlock)) {
      topBlock=topBlock.getLocation().add(0,-1,0).getBlock();
    }
    location.setY(topBlock.getY() + height);
    FireComboStream fs=new FireComboStream(this,direction,location.clone().add(0,-1,0),5,1,""String_Node_Str"");
    fs.setDensity(0);
    fs.setSinglePoint(true);
    fs.setCollisionRadius(1.5);
    fs.setCollides(true);
    fs.runTaskTimer(ProjectKorra.plugin,0,1L);
    tasks.add(fs);
    for (double i=-180; i <= 180; i+=3) {
      Location tempLoc=location.clone();
      Vector newDir=direction.clone().multiply(radius * Math.cos(Math.toRadians(i)));
      tempLoc.add(newDir);
      tempLoc.setY(tempLoc.getY() + (radius * Math.sin(Math.toRadians(i))));
      ParticleEffect.FLAME.display(tempLoc,0,0,0,0,1);
    }
    location=location.add(direction.clone().multiply(speed));
    location.getWorld().playSound(location,Sound.FIRE,1,1);
    if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,location,2)) {
      remove();
      return;
    }
  }
}",0.989529507750884
133895,"private boolean prepare(){
  Block sourceBlock=getWaterSourceBlock(player,sourceGrabRange,canUsePlantSource);
  if (sourceBlock != null) {
    if (isPlant(sourceBlock)) {
      fullSource=false;
    }
    ParticleEffect.LARGE_SMOKE.display(getWaterSourceBlock(player,sourceGrabRange,canUsePlantSource).getLocation().clone().add(0.5,0.5,0.5),0,0,0,0F,4);
    return true;
  }
 else   if (WaterReturn.hasWaterBottle(player)) {
    WaterReturn.emptyWaterBottle(player);
    fullSource=false;
    return true;
  }
  return false;
}","private boolean prepare(){
  Block sourceBlock=getWaterSourceBlock(player,sourceGrabRange,canUsePlantSource);
  if (sourceBlock != null) {
    if (isPlant(sourceBlock)) {
      fullSource=false;
    }
    ParticleEffect.LARGE_SMOKE.display(getWaterSourceBlock(player,sourceGrabRange,canUsePlantSource).getLocation().clone().add(0.5,0.5,0.5),0,0,0,0F,4);
    new PlantRegrowth(player,sourceBlock);
    sourceBlock.setType(Material.AIR);
    return true;
  }
 else   if (WaterReturn.hasWaterBottle(player)) {
    WaterReturn.emptyWaterBottle(player);
    fullSource=false;
    return true;
  }
  return false;
}",0.9278169014084507
133896,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (System.currentTimeMillis() - time >= interval) {
    if (!progressing && !falling && !bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
    if (falling) {
      remove();
      new WaterReturn(player,sourceBlock);
      return;
    }
 else {
      if (!progressing) {
        if (!(isWater(sourceBlock.getType()) || (isIce(sourceBlock) && bPlayer.canIcebend()) || (isSnow(sourceBlock) && bPlayer.canIcebend())|| (isPlant(sourceBlock) && bPlayer.canPlantbend()))) {
          remove();
          return;
        }
        sourceBlock.getWorld().playEffect(location,Effect.SMOKE,4,(int)selectRange);
        return;
      }
      if (sourceBlock.getLocation().distanceSquared(firstDestination) < 0.5 * 0.5) {
        settingUp=false;
      }
      Vector direction;
      if (settingUp) {
        direction=firstDirection;
      }
 else {
        direction=targetDirection;
      }
      Block block=location.getBlock();
      if (displacing) {
        Block targetBlock=player.getTargetBlock((HashSet<Material>)null,dispelRange);
        direction=GeneralMethods.getDirection(location,targetBlock.getLocation()).normalize();
        if (!location.getBlock().equals(targetBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
          if (block.getLocation().equals(sourceBlock.getLocation())) {
            location=location.clone().add(direction);
            block=location.getBlock();
          }
        }
      }
 else {
        WaterAbility.removeWaterSpouts(location,player);
        AirAbility.removeAirSpouts(location,player);
        if ((new Random()).nextInt(4) == 0) {
          playWaterbendingSound(location);
        }
        double radius=collisionRadius;
        Player source=player;
        if (!(location == null)) {
          if (EarthBlast.annihilateBlasts(location,radius,source) || WaterManipulation.annihilateBlasts(location,radius,source) || FireBlast.annihilateBlasts(location,radius,source)) {
            remove();
            new WaterReturn(player,sourceBlock);
            return;
          }
          Combustion.removeAroundPoint(location,radius);
        }
        location=location.clone().add(direction);
        block=location.getBlock();
        if (block.getLocation().equals(sourceBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
        }
      }
      if (trail2 != null) {
        if (trail2.getBlock().equals(block)) {
          trail2.revertBlock();
          trail2=null;
        }
      }
      if (trail != null) {
        if (trail.getBlock().equals(block)) {
          trail.revertBlock();
          trail=null;
          if (trail2 != null) {
            trail2.revertBlock();
            trail2=null;
          }
        }
      }
      if (isTransparent(player,block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (block.getType() != Material.AIR && !isWater(block)) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      if (!displacing) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
          if (entity instanceof LivingEntity && entity.getEntityId() != player.getEntityId()) {
            Location location=player.getEyeLocation();
            Vector vector=location.getDirection();
            entity.setVelocity(vector.normalize().multiply(pushFactor));
            if (bPlayer.isAvatarState()) {
              damage=AvatarState.getValue(damage);
            }
            damage=getNightFactor(damage);
            DamageHandler.damageEntity(entity,damage,this);
            AirAbility.breakBreathbendingHold(entity);
            progressing=false;
          }
        }
      }
      if (!progressing) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      addWater(block);
      reduceWater(sourceBlock);
      if (trail2 != null) {
        trail2.revertBlock();
        trail2=null;
      }
      if (trail != null) {
        trail2=trail;
        trail2.setType(Material.STATIONARY_WATER,(byte)2);
      }
      trail=new TempBlock(sourceBlock,Material.STATIONARY_WATER,(byte)1);
      sourceBlock=block;
      if (location.distanceSquared(targetDestination) <= 1 || location.distanceSquared(firstDestination) > range * range) {
        falling=true;
        progressing=false;
      }
    }
  }
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (System.currentTimeMillis() - time >= interval) {
    if (!progressing && !falling && !bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
    if (falling) {
      remove();
      new WaterReturn(player,sourceBlock);
      return;
    }
 else {
      if (!progressing) {
        if (!(isWater(sourceBlock.getType()) || (isIce(sourceBlock) && bPlayer.canIcebend()) || (isSnow(sourceBlock) && bPlayer.canIcebend())|| (isPlant(sourceBlock) && bPlayer.canPlantbend()))) {
          remove();
          return;
        }
        sourceBlock.getWorld().playEffect(location,Effect.SMOKE,4,(int)selectRange);
        return;
      }
      if (sourceBlock.getLocation().distanceSquared(firstDestination) < 0.5 * 0.5) {
        settingUp=false;
      }
      Vector direction;
      if (settingUp) {
        direction=firstDirection;
      }
 else {
        direction=targetDirection;
      }
      Block block=location.getBlock();
      if (displacing) {
        Block targetBlock=player.getTargetBlock((HashSet<Material>)null,dispelRange);
        direction=GeneralMethods.getDirection(location,targetBlock.getLocation()).normalize();
        if (!location.getBlock().equals(targetBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
          if (block.getLocation().equals(sourceBlock.getLocation())) {
            location=location.clone().add(direction);
            block=location.getBlock();
          }
        }
      }
 else {
        WaterAbility.removeWaterSpouts(location,player);
        AirAbility.removeAirSpouts(location,player);
        EarthAbility.removeSandSpouts(location,player);
        if ((new Random()).nextInt(4) == 0) {
          playWaterbendingSound(location);
        }
        double radius=collisionRadius;
        Player source=player;
        if (!(location == null)) {
          if (EarthBlast.annihilateBlasts(location,radius,source) || WaterManipulation.annihilateBlasts(location,radius,source) || FireBlast.annihilateBlasts(location,radius,source)) {
            remove();
            new WaterReturn(player,sourceBlock);
            return;
          }
          Combustion.removeAroundPoint(location,radius);
        }
        location=location.clone().add(direction);
        block=location.getBlock();
        if (block.getLocation().equals(sourceBlock.getLocation())) {
          location=location.clone().add(direction);
          block=location.getBlock();
        }
      }
      if (trail2 != null) {
        if (trail2.getBlock().equals(block)) {
          trail2.revertBlock();
          trail2=null;
        }
      }
      if (trail != null) {
        if (trail.getBlock().equals(block)) {
          trail.revertBlock();
          trail=null;
          if (trail2 != null) {
            trail2.revertBlock();
            trail2=null;
          }
        }
      }
      if (isTransparent(player,block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (block.getType() != Material.AIR && !isWater(block)) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      if (!displacing) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
          if (entity instanceof LivingEntity && entity.getEntityId() != player.getEntityId()) {
            Location location=player.getEyeLocation();
            Vector vector=location.getDirection();
            entity.setVelocity(vector.normalize().multiply(pushFactor));
            if (bPlayer.isAvatarState()) {
              damage=AvatarState.getValue(damage);
            }
            damage=getNightFactor(damage);
            DamageHandler.damageEntity(entity,damage,this);
            AirAbility.breakBreathbendingHold(entity);
            progressing=false;
          }
        }
      }
      if (!progressing) {
        remove();
        new WaterReturn(player,sourceBlock);
        return;
      }
      addWater(block);
      reduceWater(sourceBlock);
      if (trail2 != null) {
        trail2.revertBlock();
        trail2=null;
      }
      if (trail != null) {
        trail2=trail;
        trail2.setType(Material.STATIONARY_WATER,(byte)2);
      }
      trail=new TempBlock(sourceBlock,Material.STATIONARY_WATER,(byte)1);
      sourceBlock=block;
      if (location.distanceSquared(targetDestination) <= 1 || location.distanceSquared(firstDestination) > range * range) {
        falling=true;
        progressing=false;
      }
    }
  }
}",0.9940017137960584
133897,"@Override public void progress(){
  progressCounter++;
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (type != AbilityType.RELEASE) {
    if (!player.hasPermission(""String_Node_Str"")) {
      remove();
      return;
    }
 else     if (!bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
  }
  if (type == AbilityType.CLICK) {
    if (origin == null) {
      removeOldType(player,AbilityType.CLICK);
      Block block=getWaterSourceBlock(player,selectRange,plant);
      if (block == null) {
        remove();
        return;
      }
      Block blockAbove=block.getRelative(BlockFace.UP);
      if (blockAbove.getType() != Material.AIR && !isWaterbendable(blockAbove)) {
        remove();
        return;
      }
      origin=block.getLocation();
      if (!isWaterbendable(block) || GeneralMethods.isRegionProtectedFromBuild(this,origin)) {
        remove();
        return;
      }
 else       if (iceOnly && !(isIcebendable(block) || isSnow(block))) {
        remove();
        return;
      }
    }
    if (player.getLocation().distanceSquared(origin) > selectRange * selectRange) {
      remove();
      return;
    }
 else     if (player.isSneaking()) {
      setType(AbilityType.SHIFT);
      return;
    }
    playFocusWaterEffect(origin.getBlock());
  }
 else   if (type == AbilityType.SHIFT) {
    if (direction == null) {
      direction=player.getEyeLocation().getDirection();
    }
    if (!charging) {
      if (!containsType(player,AbilityType.SHIFT)) {
        removeOldType(player,AbilityType.CLICK);
        remove();
        return;
      }
      charging=true;
      animation=AnimateState.RISE;
      location=origin.clone();
      if (isPlant(origin.getBlock())) {
        new PlantRegrowth(player,origin.getBlock());
      }
    }
    removeOldType(player,AbilityType.CLICK);
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - time > chargeTime) {
        setType(AbilityType.RELEASE);
        setAnimation(AnimateState.SHRINK);
      }
 else {
        remove();
      }
      return;
    }
    if (animation == AnimateState.RISE && location != null) {
      revertBlocks();
      location.add(0,animationSpeed,0);
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(origin) > 4) {
        animation=AnimateState.TOWARD_PLAYER;
      }
    }
 else     if (animation == AnimateState.TOWARD_PLAYER) {
      revertBlocks();
      Location eyeLoc=player.getTargetBlock((HashSet<Material>)null,2).getLocation();
      eyeLoc.setY(player.getEyeLocation().getY());
      Vector vec=GeneralMethods.getDirection(location,eyeLoc);
      location.add(vec.normalize().multiply(animationSpeed));
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(eyeLoc) < 1.7) {
        animation=AnimateState.CIRCLE;
        Vector tempDir=player.getLocation().getDirection();
        tempDir.setY(0);
        direction=tempDir.normalize();
        revertBlocks();
      }
    }
 else     if (animation == AnimateState.CIRCLE) {
      drawCircle(120,5);
    }
  }
 else   if (type == AbilityType.RELEASE) {
    if (animation == AnimateState.SHRINK) {
      radius-=0.20;
      drawCircle(360,15);
      if (radius < 1) {
        revertBlocks();
        time=System.currentTimeMillis();
        animation=null;
      }
    }
 else {
      moving=true;
      if ((System.currentTimeMillis() - time > flightTime && !bPlayer.isAvatarState()) || player.isSneaking()) {
        remove();
        return;
      }
      player.setFallDistance(0f);
      double currentSpeed=speed - (speed * (System.currentTimeMillis() - time) / flightTime);
      double nightSpeed=getNightFactor(currentSpeed * 0.9);
      currentSpeed=nightSpeed > currentSpeed ? nightSpeed : currentSpeed;
      if (bPlayer.isAvatarState()) {
        currentSpeed=getNightFactor(speed);
      }
      player.setVelocity(player.getEyeLocation().getDirection().normalize().multiply(currentSpeed));
      for (      Block block : GeneralMethods.getBlocksAroundPoint(player.getLocation().add(0,-1,0),waveRadius)) {
        if (block.getType() == Material.AIR && !GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
          if (iceWave) {
            createBlockDelay(block,Material.ICE,(byte)0,2L);
          }
 else {
            createBlock(block,Material.STATIONARY_WATER,(byte)0);
          }
        }
      }
      revertBlocksDelay(20L);
      if (iceWave && progressCounter % 3 == 0) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation().add(0,-1,0),waveRadius * 1.5)) {
          if (entity != this.player && entity instanceof LivingEntity && !affectedEntities.contains(entity)) {
            affectedEntities.add(entity);
            final double augment=getNightFactor(player.getWorld());
            DamageHandler.damageEntity(entity,damage,this);
            final Player fplayer=this.player;
            final Entity fent=entity;
            new BukkitRunnable(){
              @Override public void run(){
                createIceSphere(fplayer,fent,augment * 2.5);
              }
            }
.runTaskLater(ProjectKorra.plugin,6);
          }
        }
        for (        Block block : FROZEN_BLOCKS.keySet()) {
          TempBlock tBlock=FROZEN_BLOCKS.get(block);
          if (tBlock.getLocation().distance(player.getLocation()) >= thawRadius) {
            tBlock.revertBlock();
            FROZEN_BLOCKS.remove(block);
          }
        }
      }
    }
  }
}","@Override public void progress(){
  progressCounter++;
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (type != AbilityType.RELEASE) {
    if (!player.hasPermission(""String_Node_Str"")) {
      remove();
      return;
    }
 else     if (!bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
  }
  if (type == AbilityType.CLICK) {
    if (origin == null) {
      removeOldType(player,AbilityType.CLICK);
      Block block=getWaterSourceBlock(player,selectRange,plant);
      if (block == null) {
        remove();
        return;
      }
      Block blockAbove=block.getRelative(BlockFace.UP);
      if (blockAbove.getType() != Material.AIR && !isWaterbendable(blockAbove)) {
        remove();
        return;
      }
      origin=block.getLocation();
      if (!isWaterbendable(block) || GeneralMethods.isRegionProtectedFromBuild(this,origin)) {
        remove();
        return;
      }
 else       if (iceOnly && !(isIcebendable(block) || isSnow(block))) {
        remove();
        return;
      }
    }
    if (player.getLocation().distanceSquared(origin) > selectRange * selectRange) {
      remove();
      return;
    }
 else     if (player.isSneaking()) {
      setType(AbilityType.SHIFT);
      return;
    }
    playFocusWaterEffect(origin.getBlock());
  }
 else   if (type == AbilityType.SHIFT) {
    if (direction == null) {
      direction=player.getEyeLocation().getDirection();
    }
    if (!charging) {
      if (!containsType(player,AbilityType.SHIFT)) {
        removeOldType(player,AbilityType.CLICK);
        remove();
        return;
      }
      charging=true;
      animation=AnimateState.RISE;
      location=origin.clone();
      if (isPlant(origin.getBlock())) {
        new PlantRegrowth(player,origin.getBlock());
        origin.getBlock().setType(Material.AIR);
      }
    }
    removeOldType(player,AbilityType.CLICK);
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - time > chargeTime) {
        setType(AbilityType.RELEASE);
        setAnimation(AnimateState.SHRINK);
      }
 else {
        remove();
      }
      return;
    }
    if (animation == AnimateState.RISE && location != null) {
      revertBlocks();
      location.add(0,animationSpeed,0);
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(origin) > 4) {
        animation=AnimateState.TOWARD_PLAYER;
      }
    }
 else     if (animation == AnimateState.TOWARD_PLAYER) {
      revertBlocks();
      Location eyeLoc=player.getTargetBlock((HashSet<Material>)null,2).getLocation();
      eyeLoc.setY(player.getEyeLocation().getY());
      Vector vec=GeneralMethods.getDirection(location,eyeLoc);
      location.add(vec.normalize().multiply(animationSpeed));
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(eyeLoc) < 1.7) {
        animation=AnimateState.CIRCLE;
        Vector tempDir=player.getLocation().getDirection();
        tempDir.setY(0);
        direction=tempDir.normalize();
        revertBlocks();
      }
    }
 else     if (animation == AnimateState.CIRCLE) {
      drawCircle(120,5);
    }
  }
 else   if (type == AbilityType.RELEASE) {
    if (animation == AnimateState.SHRINK) {
      radius-=0.20;
      drawCircle(360,15);
      if (radius < 1) {
        revertBlocks();
        time=System.currentTimeMillis();
        animation=null;
      }
    }
 else {
      moving=true;
      if ((System.currentTimeMillis() - time > flightTime && !bPlayer.isAvatarState()) || player.isSneaking()) {
        remove();
        return;
      }
      player.setFallDistance(0f);
      double currentSpeed=speed - (speed * (System.currentTimeMillis() - time) / flightTime);
      double nightSpeed=getNightFactor(currentSpeed * 0.9);
      currentSpeed=nightSpeed > currentSpeed ? nightSpeed : currentSpeed;
      if (bPlayer.isAvatarState()) {
        currentSpeed=getNightFactor(speed);
      }
      player.setVelocity(player.getEyeLocation().getDirection().normalize().multiply(currentSpeed));
      for (      Block block : GeneralMethods.getBlocksAroundPoint(player.getLocation().add(0,-1,0),waveRadius)) {
        if (block.getType() == Material.AIR && !GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
          if (iceWave) {
            createBlockDelay(block,Material.ICE,(byte)0,2L);
          }
 else {
            createBlock(block,Material.STATIONARY_WATER,(byte)0);
          }
        }
      }
      revertBlocksDelay(20L);
      if (iceWave && progressCounter % 3 == 0) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation().add(0,-1,0),waveRadius * 1.5)) {
          if (entity != this.player && entity instanceof LivingEntity && !affectedEntities.contains(entity)) {
            affectedEntities.add(entity);
            final double augment=getNightFactor(player.getWorld());
            DamageHandler.damageEntity(entity,damage,this);
            final Player fplayer=this.player;
            final Entity fent=entity;
            new BukkitRunnable(){
              @Override public void run(){
                createIceSphere(fplayer,fent,augment * 2.5);
              }
            }
.runTaskLater(ProjectKorra.plugin,6);
          }
        }
        for (        Block block : FROZEN_BLOCKS.keySet()) {
          TempBlock tBlock=FROZEN_BLOCKS.get(block);
          if (tBlock.getLocation().distance(player.getLocation()) >= thawRadius) {
            tBlock.revertBlock();
            FROZEN_BLOCKS.remove(block);
          }
        }
      }
    }
  }
}",0.9959560947429232
133898,"@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onEntityDamageByBlock(EntityDamageByBlockEvent event){
  Block block=event.getDamager();
  if (TempBlock.isTempBlock(block)) {
    if (EarthAbility.isEarthbendable(block.getType()) && GeneralMethods.isSolid(block)) {
      event.setCancelled(true);
      return;
    }
  }
}","@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onEntityDamageByBlock(EntityDamageByBlockEvent event){
  Block block=event.getDamager();
  if (block == null)   return;
  if (TempBlock.isTempBlock(block)) {
    if (EarthAbility.isEarthbendable(block.getType()) && GeneralMethods.isSolid(block)) {
      event.setCancelled(true);
      return;
    }
  }
}",0.9578231292517008
133899,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this) || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  if (GeneralMethods.isSolid(block) || block.isLiquid()) {
    if (block.getType() == Material.FURNACE && powerFurnace) {
      Furnace furnace=(Furnace)block.getState();
      furnace.setBurnTime((short)800);
      furnace.setCookTime((short)800);
      furnace.update();
    }
 else     if (BlazeArc.isIgnitable(player,block.getRelative(BlockFace.UP))) {
      ignite(location);
    }
    remove();
    return;
  }
  if (location.distanceSquared(origin) > range * range) {
    remove();
    return;
  }
  WaterAbility.removeWaterSpouts(location,player);
  AirAbility.removeAirSpouts(location,player);
  Player source=player;
  if (EarthBlast.annihilateBlasts(location,collisionRadius,source) || WaterManipulation.annihilateBlasts(location,collisionRadius,source) || FireBlast.annihilateBlasts(location,collisionRadius,source)) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
    affect(entity);
    if (entity instanceof LivingEntity) {
      break;
    }
  }
  advanceLocation();
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this) || GeneralMethods.isRegionProtectedFromBuild(this,location)) {
    remove();
    return;
  }
  if (isFireBurst && !bPlayer.canBend(CoreAbility.getAbility(""String_Node_Str""))) {
    remove();
    return;
  }
 else   if (!isFireBurst && !bPlayer.canBend(CoreAbility.getAbility(""String_Node_Str""))) {
    remove();
    return;
  }
  speedFactor=speed * (ProjectKorra.time_step / 1000.0);
  ticks++;
  if (ticks > MAX_TICKS) {
    remove();
    return;
  }
  Block block=location.getBlock();
  if (GeneralMethods.isSolid(block) || block.isLiquid()) {
    if (block.getType() == Material.FURNACE && powerFurnace) {
      Furnace furnace=(Furnace)block.getState();
      furnace.setBurnTime((short)800);
      furnace.setCookTime((short)800);
      furnace.update();
    }
 else     if (BlazeArc.isIgnitable(player,block.getRelative(BlockFace.UP))) {
      ignite(location);
    }
    remove();
    return;
  }
  if (location.distanceSquared(origin) > range * range) {
    remove();
    return;
  }
  WaterAbility.removeWaterSpouts(location,player);
  AirAbility.removeAirSpouts(location,player);
  Player source=player;
  if (EarthBlast.annihilateBlasts(location,collisionRadius,source) || WaterManipulation.annihilateBlasts(location,collisionRadius,source) || FireBlast.annihilateBlasts(location,collisionRadius,source)) {
    remove();
    return;
  }
  for (  Entity entity : GeneralMethods.getEntitiesAroundPoint(location,collisionRadius)) {
    affect(entity);
    if (entity instanceof LivingEntity) {
      break;
    }
  }
  advanceLocation();
}",0.922365378262306
133900,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this) && !launched) {
    remove();
    return;
  }
 else   if (!player.isSneaking() && !charged) {
    remove();
    return;
  }
  if (System.currentTimeMillis() > startTime + chargeTime) {
    charged=true;
  }
  if (!player.isSneaking() && !launched) {
    launched=true;
    location=player.getEyeLocation();
    origin=location.clone();
    direction=location.getDirection().normalize().multiply(collisionRadius);
  }
  if (System.currentTimeMillis() > time + interval) {
    if (launched) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        remove();
        return;
      }
    }
    time=System.currentTimeMillis();
    if (!launched && !charged) {
      return;
    }
 else     if (!launched) {
      player.getWorld().playEffect(player.getEyeLocation(),Effect.MOBSPAWNER_FLAMES,0,3);
      return;
    }
    location=location.clone().add(direction);
    if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    if (GeneralMethods.isSolid(location.getBlock())) {
      explode();
      return;
    }
 else     if (location.getBlock().isLiquid()) {
      remove();
      return;
    }
    executeFireball();
  }
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this) && !launched) {
    remove();
    return;
  }
 else   if (!bPlayer.canBend(CoreAbility.getAbility(""String_Node_Str"")) && !launched) {
    remove();
    return;
  }
 else   if (!player.isSneaking() && !charged) {
    remove();
    return;
  }
  if (System.currentTimeMillis() > startTime + chargeTime) {
    charged=true;
  }
  if (!player.isSneaking() && !launched) {
    launched=true;
    location=player.getEyeLocation();
    origin=location.clone();
    direction=location.getDirection().normalize().multiply(collisionRadius);
  }
  if (System.currentTimeMillis() > time + interval) {
    if (launched) {
      if (GeneralMethods.isRegionProtectedFromBuild(this,location)) {
        remove();
        return;
      }
    }
    time=System.currentTimeMillis();
    if (!launched && !charged) {
      return;
    }
 else     if (!launched) {
      player.getWorld().playEffect(player.getEyeLocation(),Effect.MOBSPAWNER_FLAMES,0,3);
      return;
    }
    location=location.clone().add(direction);
    if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    if (GeneralMethods.isSolid(location.getBlock())) {
      explode();
      return;
    }
 else     if (location.getBlock().isLiquid()) {
      remove();
      return;
    }
    executeFireball();
  }
}",0.9554380664652568
133901,"@Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (distanceTravelled > spearRange) {
    remove();
    return;
  }
  if (!hitEntity) {
    progressSpear();
  }
 else {
    createIceBall();
  }
  if (layer >= spearSphere) {
    remove();
    return;
  }
 else   if (!canPlaceBlock(location.getBlock())) {
    if (canFreeze) {
      createSpear();
    }
    remove();
    return;
  }
}","@Override public void progress(){
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
 else   if (distanceTravelled > spearRange) {
    remove();
    return;
  }
  if (!hitEntity) {
    progressSpear();
  }
 else {
    createIceBall();
    remove();
  }
  if (layer >= spearSphere) {
    remove();
    return;
  }
 else   if (!canPlaceBlock(location.getBlock())) {
    if (canFreeze) {
      createSpear();
    }
    remove();
    return;
  }
}",0.9848484848484848
133902,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerDamage(EntityDamageEvent event){
  if (event.isCancelled()) {
    return;
  }
  if (event.getEntity() instanceof Player) {
    Player player=(Player)event.getEntity();
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null) {
      return;
    }
    if (bPlayer.hasElement(Element.EARTH) && event.getCause() == DamageCause.FALL) {
      new Shockwave(player,true);
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.AIR) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.AIR)) {
      new AirBurst(player,true);
      event.setDamage(0D);
      event.setCancelled(true);
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.WATER) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.WATER)) {
      if (WaterPassive.applyNoFall(player)) {
        event.setDamage(0D);
        event.setCancelled(true);
      }
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.EARTH) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.EARTH)) {
      if (EarthPassive.softenLanding(player)) {
        event.setDamage(0D);
        event.setCancelled(true);
      }
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.CHI) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.CHI)) {
      if (player.isSprinting()) {
        event.setDamage(0);
        event.setCancelled(true);
      }
 else {
        double initdamage=event.getDamage();
        double newdamage=event.getDamage() * ChiPassive.getFallReductionFactor();
        double finaldamage=initdamage - newdamage;
        event.setDamage(finaldamage);
      }
    }
    if (!event.isCancelled() && event.getCause() == DamageCause.FALL) {
      Player source=Flight.getLaunchedBy(player);
      if (source != null) {
        event.setCancelled(true);
      }
    }
    if (bPlayer.canBendPassive(Element.FIRE) && bPlayer.hasElement(Element.FIRE) && (event.getCause() == DamageCause.FIRE || event.getCause() == DamageCause.FIRE_TICK)) {
      event.setCancelled(!HeatControlExtinguish.canBurn(player));
    }
    if (bPlayer.hasElement(Element.EARTH) && event.getCause() == DamageCause.SUFFOCATION && TempBlock.isTempBlock(player.getEyeLocation().getBlock())) {
      event.setDamage(0D);
      event.setCancelled(true);
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerDamage(EntityDamageEvent event){
  if (event.isCancelled()) {
    return;
  }
  if (event.getEntity() instanceof Player) {
    Player player=(Player)event.getEntity();
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null) {
      return;
    }
    if (bPlayer.hasElement(Element.EARTH) && event.getCause() == DamageCause.FALL) {
      new Shockwave(player,true);
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.AIR) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.AIR)) {
      new AirBurst(player,true);
      event.setDamage(0D);
      event.setCancelled(true);
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.WATER) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.WATER)) {
      if (WaterPassive.applyNoFall(player)) {
        event.setDamage(0D);
        event.setCancelled(true);
      }
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.EARTH) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.EARTH)) {
      if (EarthPassive.softenLanding(player)) {
        event.setDamage(0D);
        event.setCancelled(true);
      }
    }
    if (!event.isCancelled() && bPlayer.hasElement(Element.CHI) && event.getCause() == DamageCause.FALL && bPlayer.canBendPassive(Element.CHI)) {
      double initdamage=event.getDamage();
      double newdamage=event.getDamage() * ChiPassive.getFallReductionFactor();
      double finaldamage=initdamage - newdamage;
      event.setDamage(finaldamage);
    }
    if (!event.isCancelled() && event.getCause() == DamageCause.FALL) {
      Player source=Flight.getLaunchedBy(player);
      if (source != null) {
        event.setCancelled(true);
      }
    }
    if (bPlayer.canBendPassive(Element.FIRE) && bPlayer.hasElement(Element.FIRE) && (event.getCause() == DamageCause.FIRE || event.getCause() == DamageCause.FIRE_TICK)) {
      event.setCancelled(!HeatControlExtinguish.canBurn(player));
    }
    if (bPlayer.hasElement(Element.EARTH) && event.getCause() == DamageCause.SUFFOCATION && TempBlock.isTempBlock(player.getEyeLocation().getBlock())) {
      event.setDamage(0D);
      event.setCancelled(true);
    }
  }
}",0.8988195615514334
133903,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreCooldowns(this)) {
    remove();
    return;
  }
  getFloor();
  if (floorblock == null) {
    remove();
    return;
  }
  Vector velocity=player.getEyeLocation().getDirection().clone();
  velocity.setY(0);
  velocity=velocity.clone().normalize().multiply(speed);
  if (System.currentTimeMillis() > startTime + interval) {
    if (player.getVelocity().length() < speed * .5) {
      remove();
      return;
    }
    spinScooter();
  }
  double distance=player.getLocation().getY() - (double)floorblock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 2.75) {
    velocity.setY(-.25 * dx * dx);
  }
 else   if (distance < 2) {
    velocity.setY(.25 * dx * dx);
  }
 else {
    velocity.setY(0);
  }
  Location loc=player.getLocation();
  if (!WaterAbility.isWater(player.getLocation().add(0,2,0).getBlock())) {
    loc.setY((double)floorblock.getY() + 1.5);
  }
 else {
    return;
  }
  player.setSprinting(false);
  player.removePotionEffect(PotionEffectType.SPEED);
  player.setVelocity(velocity);
  if (random.nextInt(4) == 0) {
    playAirbendingSound(player.getLocation());
  }
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  getFloor();
  if (floorblock == null) {
    remove();
    return;
  }
  Vector velocity=player.getEyeLocation().getDirection().clone();
  velocity.setY(0);
  velocity=velocity.clone().normalize().multiply(speed);
  if (System.currentTimeMillis() > startTime + interval) {
    if (player.getVelocity().length() < speed * .5) {
      remove();
      return;
    }
    spinScooter();
  }
  double distance=player.getLocation().getY() - (double)floorblock.getY();
  double dx=Math.abs(distance - 2.4);
  if (distance > 2.75) {
    velocity.setY(-.25 * dx * dx);
  }
 else   if (distance < 2) {
    velocity.setY(.25 * dx * dx);
  }
 else {
    velocity.setY(0);
  }
  Location loc=player.getLocation();
  if (!WaterAbility.isWater(player.getLocation().add(0,2,0).getBlock())) {
    loc.setY((double)floorblock.getY() + 1.5);
  }
 else {
    return;
  }
  player.setSprinting(false);
  player.removePotionEffect(PotionEffectType.SPEED);
  player.setVelocity(velocity);
  if (random.nextInt(4) == 0) {
    playAirbendingSound(player.getLocation());
  }
}",0.9978513107004728
133904,"public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",9);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}","public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",9);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}",0.9991225621186136
133905,"public Torrent(Player player){
  super(player);
  this.layer=0;
  this.startAngle=0;
  this.maxLayer=getConfig().getInt(""String_Node_Str"");
  this.push=getConfig().getDouble(""String_Node_Str"");
  this.angle=getConfig().getDouble(""String_Node_Str"");
  this.radius=getConfig().getDouble(""String_Node_Str"");
  this.maxUpwardForce=getConfig().getDouble(""String_Node_Str"");
  this.interval=getConfig().getLong(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.deflectDamage=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.blocks=new ArrayList<>();
  this.launchedBlocks=new ArrayList<>();
  this.hurtEntities=new ArrayList<>();
  Torrent oldTorrent=getAbility(player,Torrent.class);
  if (oldTorrent != null) {
    if (!oldTorrent.sourceSelected) {
      oldTorrent.use();
      bPlayer.addCooldown(""String_Node_Str"",oldTorrent.cooldown);
      return;
    }
 else {
      oldTorrent.remove();
    }
  }
  if (bPlayer.isOnCooldown(""String_Node_Str"")) {
    return;
  }
  time=System.currentTimeMillis();
  sourceBlock=BlockSource.getWaterSourceBlock(player,selectRange,ClickType.LEFT_CLICK,true,true,bPlayer.canPlantbend());
  if (sourceBlock != null && !GeneralMethods.isRegionProtectedFromBuild(this,sourceBlock.getLocation())) {
    sourceSelected=true;
    start();
  }
}","public Torrent(Player player){
  super(player);
  this.layer=0;
  this.startAngle=0;
  this.maxLayer=getConfig().getInt(""String_Node_Str"");
  this.push=getConfig().getDouble(""String_Node_Str"");
  this.angle=getConfig().getDouble(""String_Node_Str"");
  this.radius=getConfig().getDouble(""String_Node_Str"");
  this.maxUpwardForce=getConfig().getDouble(""String_Node_Str"");
  this.interval=getConfig().getLong(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.successiveDamage=getConfig().getDouble(""String_Node_Str"");
  this.maxHits=getConfig().getInt(""String_Node_Str"");
  this.deflectDamage=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.blocks=new ArrayList<>();
  this.launchedBlocks=new ArrayList<>();
  this.hurtEntities=new ArrayList<>();
  Torrent oldTorrent=getAbility(player,Torrent.class);
  if (oldTorrent != null) {
    if (!oldTorrent.sourceSelected) {
      oldTorrent.use();
      bPlayer.addCooldown(""String_Node_Str"",oldTorrent.cooldown);
      return;
    }
 else {
      oldTorrent.remove();
    }
  }
  if (bPlayer.isOnCooldown(""String_Node_Str"")) {
    return;
  }
  time=System.currentTimeMillis();
  sourceBlock=BlockSource.getWaterSourceBlock(player,selectRange,ClickType.LEFT_CLICK,true,true,bPlayer.canPlantbend());
  if (sourceBlock != null && !GeneralMethods.isRegionProtectedFromBuild(this,sourceBlock.getLocation())) {
    sourceSelected=true;
    start();
  }
}",0.9609375
133906,"private void affect(Entity entity,Vector direction){
  if (entity.getEntityId() == player.getEntityId()) {
    return;
  }
  if (direction.getY() > maxUpwardForce) {
    direction.setY(maxUpwardForce);
  }
  if (!freeze) {
    entity.setVelocity(direction.multiply(push));
  }
  if (entity instanceof LivingEntity && !hurtEntities.contains(entity)) {
    double damageDealt=getNightFactor(damage);
    DamageHandler.damageEntity(entity,damageDealt,this);
    AirAbility.breakBreathbendingHold(entity);
    hurtEntities.add(entity);
    ((LivingEntity)entity).setNoDamageTicks(0);
  }
}","private void affect(Entity entity,Vector direction){
  if (entity.getEntityId() == player.getEntityId()) {
    return;
  }
  if (direction.getY() > maxUpwardForce) {
    direction.setY(maxUpwardForce);
  }
  if (!freeze) {
    entity.setVelocity(direction.multiply(push));
  }
  if (entity instanceof LivingEntity && !hurtEntities.contains(entity)) {
    double damageDealt=getNightFactor(damage);
    if (hits > 1 && hits <= maxHits) {
      damageDealt=getNightFactor(successiveDamage);
    }
    if (hits == maxHits) {
      hits=maxHits + 1;
    }
 else {
      hits+=1;
    }
    DamageHandler.damageEntity(entity,damageDealt,this);
    AirAbility.breakBreathbendingHold(entity);
    hurtEntities.add(entity);
    ((LivingEntity)entity).setNoDamageTicks(0);
  }
}",0.8647450110864745
133907,"@EventHandler public void onPlayerKick(PlayerKickEvent event){
  if (event.isCancelled()) {
    return;
  }
  AirFlight.remove(event.getPlayer());
}","@EventHandler public void onPlayerKick(PlayerKickEvent event){
  if (event.isCancelled()) {
    return;
  }
  AirFlight.remove(event.getPlayer());
  JUMPS.remove(event.getPlayer());
}",0.8942598187311178
133908,"@EventHandler public void onPlayerQuit(PlayerQuitEvent event){
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer != null) {
    if (TOGGLED_OUT.contains(player.getUniqueId()) && bPlayer.isToggled()) {
      TOGGLED_OUT.remove(player.getUniqueId());
    }
    if (!bPlayer.isToggled()) {
      TOGGLED_OUT.add(player.getUniqueId());
    }
  }
  if (Commands.invincible.contains(player.getName())) {
    Commands.invincible.remove(player.getName());
  }
  Preset.unloadPreset(player);
  EarthArmor earthArmor=CoreAbility.getAbility(player,EarthArmor.class);
  PlantArmor plantArmor=CoreAbility.getAbility(player,PlantArmor.class);
  MetalClips metalClips=CoreAbility.getAbility(player,MetalClips.class);
  if (earthArmor != null) {
    earthArmor.remove();
  }
  if (plantArmor != null) {
    plantArmor.remove();
  }
  if (metalClips != null) {
    metalClips.remove();
  }
  MultiAbilityManager.remove(player);
  AirFlight.remove(event.getPlayer());
}","@EventHandler public void onPlayerQuit(PlayerQuitEvent event){
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer != null) {
    if (TOGGLED_OUT.contains(player.getUniqueId()) && bPlayer.isToggled()) {
      TOGGLED_OUT.remove(player.getUniqueId());
    }
    if (!bPlayer.isToggled()) {
      TOGGLED_OUT.add(player.getUniqueId());
    }
  }
  if (Commands.invincible.contains(player.getName())) {
    Commands.invincible.remove(player.getName());
  }
  Preset.unloadPreset(player);
  EarthArmor earthArmor=CoreAbility.getAbility(player,EarthArmor.class);
  PlantArmor plantArmor=CoreAbility.getAbility(player,PlantArmor.class);
  MetalClips metalClips=CoreAbility.getAbility(player,MetalClips.class);
  if (earthArmor != null) {
    earthArmor.remove();
  }
  if (plantArmor != null) {
    plantArmor.remove();
  }
  if (metalClips != null) {
    metalClips.remove();
  }
  MultiAbilityManager.remove(player);
  AirFlight.remove(player);
  JUMPS.remove(player);
}",0.9769720725134736
133909,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerMove(PlayerMoveEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  if (Paralyze.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (CoreAbility.hasAbility(player,WaterSpout.class) || CoreAbility.hasAbility(player,AirSpout.class) || CoreAbility.hasAbility(player,SandSpout.class)) {
    Vector vel=new Vector();
    vel.setX(event.getTo().getX() - event.getFrom().getX());
    vel.setY(event.getTo().getY() - event.getFrom().getY());
    vel.setZ(event.getTo().getZ() - event.getFrom().getZ());
    double currspeed=vel.length();
    double maxspeed=.15;
    if (currspeed > maxspeed) {
      vel=vel.normalize().multiply(maxspeed);
      event.getPlayer().setVelocity(vel);
    }
  }
 else   if (Bloodbending.isBloodbent(player)) {
    double distance1, distance2;
    Location loc=Bloodbending.getBloodbendingLocation(player);
    distance1=event.getFrom().distance(loc);
    distance2=event.getTo().distance(loc);
    if (distance2 > distance1) {
      player.setVelocity(new Vector(0,0,0));
    }
  }
 else   if (AirFlight.isFlying(event.getPlayer())) {
    if (AirFlight.isHovering(event.getPlayer())) {
      Location loc=event.getFrom();
      Location toLoc=player.getLocation();
      if (loc.getX() != toLoc.getX() || loc.getY() != toLoc.getY() || loc.getZ() != toLoc.getZ()) {
        event.setCancelled(true);
        return;
      }
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerMove(PlayerMoveEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  if (Paralyze.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (CoreAbility.hasAbility(player,WaterSpout.class) || CoreAbility.hasAbility(player,AirSpout.class) || CoreAbility.hasAbility(player,SandSpout.class)) {
    Vector vel=new Vector();
    vel.setX(event.getTo().getX() - event.getFrom().getX());
    vel.setY(event.getTo().getY() - event.getFrom().getY());
    vel.setZ(event.getTo().getZ() - event.getFrom().getZ());
    double currspeed=vel.length();
    double maxspeed=.15;
    if (currspeed > maxspeed) {
      vel=vel.normalize().multiply(maxspeed);
      event.getPlayer().setVelocity(vel);
    }
  }
 else   if (Bloodbending.isBloodbent(player)) {
    double distance1, distance2;
    Location loc=Bloodbending.getBloodbendingLocation(player);
    distance1=event.getFrom().distance(loc);
    distance2=event.getTo().distance(loc);
    if (distance2 > distance1) {
      player.setVelocity(new Vector(0,0,0));
    }
  }
 else   if (AirFlight.isFlying(event.getPlayer())) {
    if (AirFlight.isHovering(event.getPlayer())) {
      Location loc=event.getFrom();
      Location toLoc=player.getLocation();
      if (loc.getX() != toLoc.getX() || loc.getY() != toLoc.getY() || loc.getZ() != toLoc.getZ()) {
        event.setCancelled(true);
        return;
      }
    }
  }
 else {
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    double xDif=event.getTo().getX() - event.getFrom().getX();
    double yDif=event.getTo().getY() - event.getFrom().getY();
    double zDif=event.getTo().getZ() - event.getFrom().getZ();
    if ((xDif > 0.12 || xDif < -0.12) || (yDif > 0.12 || yDif < -0.12) || (zDif > 0.12 || zDif < -0.12)) {
      if (bPlayer.hasElement(Element.AIR) || bPlayer.hasElement(Element.CHI) || bPlayer.hasElement(Element.EARTH)) {
        if (player.hasPotionEffect(PotionEffectType.SPEED)) {
          player.removePotionEffect(PotionEffectType.SPEED);
        }
        PassiveHandler.checkSpeedPassives(player);
      }
      if (bPlayer.hasElement(Element.AIR) || bPlayer.hasElement(Element.CHI)) {
        if (player.hasPotionEffect(PotionEffectType.JUMP)) {
          player.removePotionEffect(PotionEffectType.JUMP);
        }
        PassiveHandler.checkJumpPassives(player);
        PassiveHandler.checkExhaustionPassives(player);
      }
    }
  }
  if (event.getTo().getY() > event.getFrom().getY()) {
    if (!(player.getLocation().getBlock().getType() == Material.VINE) && !(player.getLocation().getBlock().getType() == Material.LADDER)) {
      int current=player.getStatistic(Statistic.JUMP);
      int last=JUMPS.get(player);
      if (last != current) {
        JUMPS.put(player,current);
        double yDif=event.getTo().getY() - event.getFrom().getY();
        if ((yDif < 0.035 || yDif > 0.037) && (yDif < 0.116 || yDif > 0.118)) {
          Bukkit.getServer().getPluginManager().callEvent(new PlayerJumpEvent(player,yDif));
        }
      }
    }
  }
}",0.6632231404958677
133910,"@EventHandler public void onPlayerJoin(PlayerJoinEvent e){
  Player player=e.getPlayer();
  GeneralMethods.createBendingPlayer(e.getPlayer().getUniqueId(),player.getName());
}","@EventHandler public void onPlayerJoin(PlayerJoinEvent e){
  Player player=e.getPlayer();
  JUMPS.put(player,player.getStatistic(Statistic.JUMP));
  GeneralMethods.createBendingPlayer(e.getPlayer().getUniqueId(),player.getName());
}",0.85995085995086
133911,"@Override public void onEnable(){
  plugin=this;
  ProjectKorra.log=this.getLogger();
  try {
    File logFolder=new File(getDataFolder(),""String_Node_Str"");
    if (!logFolder.exists()) {
      logFolder.mkdirs();
    }
    handler=new PKLogHandler(logFolder + File.separator + ""String_Node_Str"");
    log.getParent().addHandler(handler);
  }
 catch (  SecurityException|IOException e) {
    e.printStackTrace();
  }
  new ConfigManager();
  new GeneralMethods(this);
  CoreAbility.registerAbilities();
  updater=new Updater(this,""String_Node_Str"");
  new Commands(this);
  new MultiAbilityManager();
  new ComboManager();
  Preset.loadExternalPresets();
  DBConnection.host=getConfig().getString(""String_Node_Str"");
  DBConnection.port=getConfig().getInt(""String_Node_Str"");
  DBConnection.pass=getConfig().getString(""String_Node_Str"");
  DBConnection.db=getConfig().getString(""String_Node_Str"");
  DBConnection.user=getConfig().getString(""String_Node_Str"");
  DBConnection.init();
  if (DBConnection.isOpen() == false) {
    return;
  }
  getServer().getPluginManager().registerEvents(new PKListener(this),this);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new BendingManager(),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new AirbendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new WaterbendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new EarthbendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new FirebendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new ChiblockingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new PassiveHandler(),0,1);
  getServer().getScheduler().runTaskTimerAsynchronously(this,new RevertChecker(this),0,200);
  for (  Player player : Bukkit.getOnlinePlayers()) {
    GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
  }
  try {
    MetricsLite metrics=new MetricsLite(this);
    metrics.start();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  double cacheTime=ConfigManager.getConfig().getDouble(""String_Node_Str"");
  if (Bukkit.getPluginManager().getPlugin(""String_Node_Str"") != null)   FlagPermissions.addFlag(ConfigManager.defaultConfig.get().getString(""String_Node_Str""));
  GeneralMethods.deserializeFile();
  GeneralMethods.startCacheCleaner(cacheTime);
  updater.checkUpdate();
}","@Override public void onEnable(){
  plugin=this;
  ProjectKorra.log=this.getLogger();
  try {
    File logFolder=new File(getDataFolder(),""String_Node_Str"");
    if (!logFolder.exists()) {
      logFolder.mkdirs();
    }
    handler=new PKLogHandler(logFolder + File.separator + ""String_Node_Str"");
    log.getParent().addHandler(handler);
  }
 catch (  SecurityException|IOException e) {
    e.printStackTrace();
  }
  new ConfigManager();
  new GeneralMethods(this);
  CoreAbility.registerAbilities();
  updater=new Updater(this,""String_Node_Str"");
  new Commands(this);
  new MultiAbilityManager();
  new ComboManager();
  Preset.loadExternalPresets();
  DBConnection.host=getConfig().getString(""String_Node_Str"");
  DBConnection.port=getConfig().getInt(""String_Node_Str"");
  DBConnection.pass=getConfig().getString(""String_Node_Str"");
  DBConnection.db=getConfig().getString(""String_Node_Str"");
  DBConnection.user=getConfig().getString(""String_Node_Str"");
  DBConnection.init();
  if (DBConnection.isOpen() == false) {
    return;
  }
  getServer().getPluginManager().registerEvents(new PKListener(this),this);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new BendingManager(),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new AirbendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new WaterbendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new EarthbendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new FirebendingManager(this),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new ChiblockingManager(this),0,1);
  getServer().getScheduler().runTaskTimerAsynchronously(this,new RevertChecker(this),0,200);
  for (  Player player : Bukkit.getOnlinePlayers()) {
    PKListener.getJumpStatistics().put(player,player.getStatistic(Statistic.JUMP));
    GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
  }
  try {
    MetricsLite metrics=new MetricsLite(this);
    metrics.start();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  double cacheTime=ConfigManager.getConfig().getDouble(""String_Node_Str"");
  if (Bukkit.getPluginManager().getPlugin(""String_Node_Str"") != null)   FlagPermissions.addFlag(ConfigManager.defaultConfig.get().getString(""String_Node_Str""));
  GeneralMethods.deserializeFile();
  GeneralMethods.startCacheCleaner(cacheTime);
  updater.checkUpdate();
}",0.9654615229246616
133912,"public AirCombo(Player player,String ability){
  super(player);
  this.abilityName=ability;
  this.affectedEntities=new ArrayList<>();
  this.tasks=new ArrayList<>();
  this.flights=new ArrayList<>();
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.twisterHeight=getConfig().getDouble(""String_Node_Str"");
    this.twisterRadius=getConfig().getDouble(""String_Node_Str"");
    this.twisterDegreeParticles=getConfig().getDouble(""String_Node_Str"");
    this.twisterHeightParticles=getConfig().getDouble(""String_Node_Str"");
    this.twisterRemoveDelay=getConfig().getLong(""String_Node_Str"");
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.airStreamMaxEntityHeight=getConfig().getDouble(""String_Node_Str"");
    this.airStreamEntityCarryDuration=getConfig().getLong(""String_Node_Str"");
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.knockback=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
  }
  if (bPlayer.isAvatarState()) {
    this.cooldown=0;
    this.damage=AvatarState.getValue(damage);
    this.range=AvatarState.getValue(range);
    this.knockback=knockback * 1.4;
    this.airStreamMaxEntityHeight=AvatarState.getValue(airStreamMaxEntityHeight);
    this.airStreamEntityCarryDuration=AvatarState.getValue(airStreamEntityCarryDuration);
  }
  bPlayer.addCooldown(this);
  start();
}","public AirCombo(Player player,String ability){
  super(player);
  this.abilityName=ability;
  this.affectedEntities=new ArrayList<>();
  this.tasks=new ArrayList<>();
  this.flights=new ArrayList<>();
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    return;
  }
  if (bPlayer.isOnCooldown(ability)) {
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.twisterHeight=getConfig().getDouble(""String_Node_Str"");
    this.twisterRadius=getConfig().getDouble(""String_Node_Str"");
    this.twisterDegreeParticles=getConfig().getDouble(""String_Node_Str"");
    this.twisterHeightParticles=getConfig().getDouble(""String_Node_Str"");
    this.twisterRemoveDelay=getConfig().getLong(""String_Node_Str"");
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.airStreamMaxEntityHeight=getConfig().getDouble(""String_Node_Str"");
    this.airStreamEntityCarryDuration=getConfig().getLong(""String_Node_Str"");
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.knockback=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
  }
  if (bPlayer.isAvatarState()) {
    this.cooldown=0;
    this.damage=AvatarState.getValue(damage);
    this.range=AvatarState.getValue(range);
    this.knockback=knockback * 1.4;
    this.airStreamMaxEntityHeight=AvatarState.getValue(airStreamMaxEntityHeight);
    this.airStreamEntityCarryDuration=AvatarState.getValue(airStreamEntityCarryDuration);
  }
  bPlayer.addCooldown(this);
  start();
}",0.9863286104896845
133913,"public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",9);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}","public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    ArrayList<String> snowBlocks=new ArrayList<>();
    snowBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",snowBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",9);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}",0.9976660807039498
133914,"@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    return;
  }
  if (formed) {
    if (System.currentTimeMillis() > startTime + duration && !complete) {
      complete=true;
      bPlayer.addCooldown(this);
      remove();
      return;
    }
  }
 else   if (System.currentTimeMillis() > time + interval) {
    if (!moveBlocks()) {
      return;
    }
    if (inPosition()) {
      formArmor();
    }
  }
}","@Override public void progress(){
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    return;
  }
  if (formed) {
    PassiveHandler.checkArmorPassives(player);
    if (System.currentTimeMillis() > startTime + duration && !complete) {
      complete=true;
      bPlayer.addCooldown(this);
      remove();
      return;
    }
  }
 else   if (System.currentTimeMillis() > time + interval) {
    if (!moveBlocks()) {
      return;
    }
    if (inPosition()) {
      formArmor();
    }
  }
}",0.9498399146211312
133915,"public FireJet(Player player){
  super(player);
  FireJet oldJet=getAbility(player,FireJet.class);
  if (oldJet != null) {
    oldJet.remove();
    return;
  }
 else   if (bPlayer.isOnCooldown(this)) {
    return;
  }
  this.avatarStateToggled=getConfig().getBoolean(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.speed=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.random=new Random();
  this.speed=getDayFactor(speed);
  Block block=player.getLocation().getBlock();
  if (BlazeArc.isIgnitable(player,block) || block.getType() == Material.AIR || bPlayer.isAvatarState()) {
    player.setVelocity(player.getEyeLocation().getDirection().clone().normalize().multiply(speed));
    if (canFireGrief()) {
      createTempFire(block.getLocation());
    }
 else {
      block.setType(Material.FIRE);
    }
    new Flight(player);
    player.setAllowFlight(true);
    time=System.currentTimeMillis();
    start();
    bPlayer.addCooldown(this);
  }
}","public FireJet(Player player){
  super(player);
  FireJet oldJet=getAbility(player,FireJet.class);
  if (oldJet != null) {
    oldJet.remove();
    return;
  }
 else   if (bPlayer.isOnCooldown(this)) {
    return;
  }
  if (hasAbility(player,AirSpout.class)) {
    AirSpout abil=getAbility(player,AirSpout.class);
    abil.remove();
  }
 else   if (hasAbility(player,SandSpout.class)) {
    SandSpout abil=getAbility(player,SandSpout.class);
    abil.remove();
  }
  this.avatarStateToggled=getConfig().getBoolean(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.speed=getConfig().getDouble(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.random=new Random();
  this.speed=getDayFactor(speed);
  Block block=player.getLocation().getBlock();
  if (BlazeArc.isIgnitable(player,block) || block.getType() == Material.AIR || bPlayer.isAvatarState()) {
    player.setVelocity(player.getEyeLocation().getDirection().clone().normalize().multiply(speed));
    if (canFireGrief()) {
      createTempFire(block.getLocation());
    }
 else {
      block.setType(Material.FIRE);
    }
    new Flight(player);
    player.setAllowFlight(true);
    time=System.currentTimeMillis();
    start();
    bPlayer.addCooldown(this);
  }
}",0.8935803532959931
133916,"/** 
 * Updates all of the player's sources.
 * @param player the player performing the bending.
 * @param clickType either {@link ClickType}.SHIFT_DOWN or ClickType.LEFT_CLICK
 */
public static void update(Player player,ClickType clickType){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  if (coreAbil == null) {
    return;
  }
  if (coreAbil instanceof WaterAbility) {
    Block waterBlock=WaterAbility.getWaterSourceBlock(player,MAX_RANGE,true);
    if (waterBlock != null) {
      putSource(player,waterBlock,BlockSourceType.WATER,clickType);
      if (WaterAbility.isPlant(waterBlock)) {
        putSource(player,waterBlock,BlockSourceType.PLANT,clickType);
      }
      if (WaterAbility.isIce(waterBlock)) {
        putSource(player,waterBlock,BlockSourceType.ICE,clickType);
      }
    }
  }
 else   if (coreAbil instanceof EarthAbility) {
    Block earthBlock=EarthAbility.getEarthSourceBlock(player,null,MAX_RANGE);
    if (earthBlock != null) {
      putSource(player,earthBlock,BlockSourceType.EARTH,clickType);
      if (EarthAbility.isMetal(earthBlock)) {
        putSource(player,earthBlock,BlockSourceType.METAL,clickType);
      }
    }
    Block lavaBlock=EarthAbility.getLavaSourceBlock(player,MAX_RANGE);
    double earthDist=earthBlock != null ? earthBlock.getLocation().distanceSquared(player.getLocation()) : Double.MAX_VALUE;
    double lavaDist=lavaBlock != null ? lavaBlock.getLocation().distanceSquared(player.getLocation()) : Double.MAX_VALUE;
    if (lavaBlock != null && lavaDist <= earthDist) {
      putSource(player,null,BlockSourceType.EARTH,clickType);
      putSource(player,lavaBlock,BlockSourceType.LAVA,clickType);
    }
  }
}","/** 
 * Updates all of the player's sources.
 * @param player the player performing the bending.
 * @param clickType either {@link ClickType}.SHIFT_DOWN or ClickType.LEFT_CLICK
 */
public static void update(Player player,ClickType clickType){
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  if (coreAbil == null) {
    return;
  }
  if (coreAbil instanceof WaterAbility) {
    Block waterBlock=WaterAbility.getWaterSourceBlock(player,MAX_RANGE,true);
    if (waterBlock != null) {
      putSource(player,waterBlock,BlockSourceType.WATER,clickType);
      if (WaterAbility.isPlant(waterBlock)) {
        putSource(player,waterBlock,BlockSourceType.PLANT,clickType);
      }
      if (WaterAbility.isIce(waterBlock)) {
        putSource(player,waterBlock,BlockSourceType.ICE,clickType);
      }
      if (WaterAbility.isSnow(waterBlock)) {
        putSource(player,waterBlock,BlockSourceType.SNOW,clickType);
      }
    }
  }
 else   if (coreAbil instanceof EarthAbility) {
    Block earthBlock=EarthAbility.getEarthSourceBlock(player,null,MAX_RANGE);
    if (earthBlock != null) {
      putSource(player,earthBlock,BlockSourceType.EARTH,clickType);
      if (EarthAbility.isMetal(earthBlock)) {
        putSource(player,earthBlock,BlockSourceType.METAL,clickType);
      }
    }
    Block lavaBlock=EarthAbility.getLavaSourceBlock(player,MAX_RANGE);
    double earthDist=earthBlock != null ? earthBlock.getLocation().distanceSquared(player.getLocation()) : Double.MAX_VALUE;
    double lavaDist=lavaBlock != null ? lavaBlock.getLocation().distanceSquared(player.getLocation()) : Double.MAX_VALUE;
    if (lavaBlock != null && lavaDist <= earthDist) {
      putSource(player,null,BlockSourceType.EARTH,clickType);
      putSource(player,lavaBlock,BlockSourceType.LAVA,clickType);
    }
  }
}",0.9668117519042436
133917,"/** 
 * Attempts to access a Water bendable block that was recently shifted or clicked on by the player.
 * @param player the player that is trying to bend.
 * @param range the maximum range to access the block.
 * @param clickType the action that was performed to access the source,either  {@link ClickType}.SHIFT_DOWN or ClickType.LEFT_CLICK.
 * @param allowWater true if water blocks are allowed.
 * @param allowIce true if ice blocks are allowed.
 * @param allowPlant true if plant blocks are allowed.
 * @param allowWaterBottles true if we should look for a close water block,that may have been created by a WaterBottle.
 * @return a valid Water bendable block, or null if none was found.
 */
public static Block getWaterSourceBlock(Player player,double range,ClickType clickType,boolean allowWater,boolean allowIce,boolean allowPlant,boolean allowWaterBottles){
  Block sourceBlock=null;
  if (allowWaterBottles) {
    sourceBlock=WaterAbility.getWaterSourceBlock(player,range,allowPlant);
    if (sourceBlock == null || sourceBlock.getLocation().distance(player.getEyeLocation()) > 3) {
      sourceBlock=null;
    }
  }
  if (allowWater && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.WATER,clickType);
  }
  if (allowIce && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.ICE,clickType);
  }
  if (allowPlant && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.PLANT,clickType);
  }
  if (sourceBlock != null && TempBlock.isTempBlock(sourceBlock) && !tempblock) {
    return null;
  }
  return sourceBlock;
}","/** 
 * Attempts to access a Water bendable block that was recently shifted or clicked on by the player.
 * @param player the player that is trying to bend.
 * @param range the maximum range to access the block.
 * @param clickType the action that was performed to access the source,either  {@link ClickType}.SHIFT_DOWN or ClickType.LEFT_CLICK.
 * @param allowWater true if water blocks are allowed.
 * @param allowIce true if ice blocks are allowed.
 * @param allowPlant true if plant blocks are allowed.
 * @param allowWaterBottles true if we should look for a close water block,that may have been created by a WaterBottle.
 * @return a valid Water bendable block, or null if none was found.
 */
public static Block getWaterSourceBlock(Player player,double range,ClickType clickType,boolean allowWater,boolean allowIce,boolean allowPlant,boolean allowSnow,boolean allowWaterBottles){
  Block sourceBlock=null;
  if (allowWaterBottles) {
    sourceBlock=WaterAbility.getWaterSourceBlock(player,range,allowPlant);
    if (sourceBlock == null || sourceBlock.getLocation().distance(player.getEyeLocation()) > 3) {
      sourceBlock=null;
    }
  }
  if (allowWater && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.WATER,clickType);
  }
  if (allowIce && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.ICE,clickType);
  }
  if (allowPlant && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.PLANT,clickType);
  }
  if (allowSnow && sourceBlock == null) {
    sourceBlock=getSourceBlock(player,range,BlockSourceType.SNOW,clickType);
  }
  if (sourceBlock != null && TempBlock.isTempBlock(sourceBlock) && !tempblock) {
    return null;
  }
  return sourceBlock;
}",0.9583948067276484
133918,"public static void handleSpeedPassives(){
  int air=AirPassive.getSpeedPower();
  int chi=ChiPassive.getSpeedPower();
  int earth=EarthPassive.getSandRunSpeed();
  for (  Player player : Bukkit.getOnlinePlayers()) {
    if (ConfigManager.defaultConfig.get().getStringList(""String_Node_Str"").contains(player.getWorld().getName())) {
      return;
    }
    boolean sandbender=true;
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null)     continue;
    if (!bPlayer.hasElement(Element.EARTH))     sandbender=false;
    if (!bPlayer.hasSubElement(SubElement.SAND))     sandbender=false;
    if (!bPlayer.hasElement(Element.AIR))     air=0;
    if (!bPlayer.hasElement(Element.CHI))     chi=0;
    int max=0;
    if (sandbender && (player.getLocation().getBlock().getRelative(BlockFace.DOWN).getType() == Material.SAND || player.getLocation().getBlock().getRelative(BlockFace.DOWN).getType() == Material.SANDSTONE || player.getLocation().getBlock().getRelative(BlockFace.DOWN).getType() == Material.RED_SANDSTONE)) {
      if (CoreAbility.hasAbility(player,AcrobatStance.class)) {
        AcrobatStance abil=CoreAbility.getAbility(player,AcrobatStance.class);
        max=Math.max(air,chi);
        max=Math.max(max,abil.getSpeed());
        max=Math.max(max,earth);
      }
 else {
        max=Math.max(air,chi);
        max=Math.max(max,earth);
      }
    }
 else {
      if (CoreAbility.hasAbility(player,AcrobatStance.class)) {
        AcrobatStance abil=CoreAbility.getAbility(player,AcrobatStance.class);
        max=Math.max(air,chi);
        max=Math.max(max,abil.getSpeed());
      }
 else {
        max=Math.max(air,chi);
      }
    }
    if (max == 0)     continue;
    if (player.isSprinting()) {
      player.addPotionEffect(new PotionEffect(PotionEffectType.SPEED,3,max - 1));
    }
  }
}","public static void handleSpeedPassives(){
  int air=AirPassive.getSpeedPower();
  int chi=ChiPassive.getSpeedPower();
  int earth=EarthPassive.getSandRunSpeed();
  for (  Player player : Bukkit.getOnlinePlayers()) {
    if (ConfigManager.defaultConfig.get().getStringList(""String_Node_Str"").contains(player.getWorld().getName())) {
      continue;
    }
    boolean sandbender=true;
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null)     continue;
    if (!bPlayer.hasElement(Element.EARTH))     sandbender=false;
    if (!bPlayer.hasSubElement(SubElement.SAND))     sandbender=false;
    if (!bPlayer.hasElement(Element.AIR))     air=0;
    if (!bPlayer.hasElement(Element.CHI))     chi=0;
    int max=0;
    if (sandbender && (player.getLocation().getBlock().getRelative(BlockFace.DOWN).getType() == Material.SAND || player.getLocation().getBlock().getRelative(BlockFace.DOWN).getType() == Material.SANDSTONE || player.getLocation().getBlock().getRelative(BlockFace.DOWN).getType() == Material.RED_SANDSTONE)) {
      if (CoreAbility.hasAbility(player,AcrobatStance.class)) {
        AcrobatStance abil=CoreAbility.getAbility(player,AcrobatStance.class);
        max=Math.max(air,chi);
        max=Math.max(max,abil.getSpeed());
        max=Math.max(max,earth);
      }
 else {
        max=Math.max(air,chi);
        max=Math.max(max,earth);
      }
    }
 else {
      if (CoreAbility.hasAbility(player,AcrobatStance.class)) {
        AcrobatStance abil=CoreAbility.getAbility(player,AcrobatStance.class);
        max=Math.max(air,chi);
        max=Math.max(max,abil.getSpeed());
      }
 else {
        max=Math.max(air,chi);
      }
    }
    if (max == 0)     continue;
    if (player.isSprinting()) {
      player.addPotionEffect(new PotionEffect(PotionEffectType.SPEED,3,max - 1));
    }
  }
}",0.9967391304347826
133919,"public static void handleJumpPassives(){
  int air=AirPassive.getJumpPower();
  int chi=ChiPassive.getJumpPower();
  for (  Player player : Bukkit.getOnlinePlayers()) {
    if (ConfigManager.defaultConfig.get().getStringList(""String_Node_Str"").contains(player.getWorld().getName())) {
      return;
    }
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null)     continue;
    if (!bPlayer.hasElement(Element.AIR))     air=0;
    if (!bPlayer.hasElement(Element.CHI))     chi=0;
    int max=0;
    if (CoreAbility.hasAbility(player,AcrobatStance.class)) {
      AcrobatStance abil=CoreAbility.getAbility(player,AcrobatStance.class);
      max=Math.max(air,chi);
      max=Math.max(max,abil.getSpeed());
    }
 else {
      max=Math.max(air,chi);
      if (max == 0) {
        continue;
      }
    }
    if (player.isSprinting()) {
      player.addPotionEffect(new PotionEffect(PotionEffectType.JUMP,3,max - 1),false);
    }
  }
}","public static void handleJumpPassives(){
  int air=AirPassive.getJumpPower();
  int chi=ChiPassive.getJumpPower();
  for (  Player player : Bukkit.getOnlinePlayers()) {
    if (ConfigManager.defaultConfig.get().getStringList(""String_Node_Str"").contains(player.getWorld().getName())) {
      continue;
    }
    BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
    if (bPlayer == null)     continue;
    if (!bPlayer.hasElement(Element.AIR))     air=0;
    if (!bPlayer.hasElement(Element.CHI))     chi=0;
    int max=0;
    if (CoreAbility.hasAbility(player,AcrobatStance.class)) {
      AcrobatStance abil=CoreAbility.getAbility(player,AcrobatStance.class);
      max=Math.max(air,chi);
      max=Math.max(max,abil.getSpeed());
    }
 else {
      max=Math.max(air,chi);
      if (max == 0) {
        continue;
      }
    }
    if (player.isSprinting()) {
      player.addPotionEffect(new PotionEffect(PotionEffectType.JUMP,3,max - 1),false);
    }
  }
}",0.993801652892562
133920,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerSwing(PlayerAnimationEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
 else   if (RIGHT_CLICK_INTERACT.contains(player.getUniqueId())) {
    return;
  }
  ComboManager.addComboAbility(player,ClickType.LEFT_CLICK);
  if (Suffocate.isBreathbent(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (Bloodbending.isBloodbent(player) || Paralyze.isParalyzed(player) || ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (bPlayer.isChiBlocked()) {
    event.setCancelled(true);
    return;
  }
 else   if (GeneralMethods.isInteractable(player.getTargetBlock((Set<Material>)null,5))) {
    event.setCancelled(true);
    return;
  }
  BlockSource.update(player,ClickType.LEFT_CLICK);
  AirScooter.check(player);
  String abil=bPlayer.getBoundAbilityName();
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  if (coreAbil == null && !MultiAbilityManager.hasMultiAbilityBound(player)) {
    return;
  }
 else   if (bPlayer.canBendIgnoreCooldowns(coreAbil)) {
    if (coreAbil instanceof AddonAbility) {
      return;
    }
    if (coreAbil instanceof AirAbility && bPlayer.isElementToggled(Element.AIR) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirBlast(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSuction(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirBurst.coneBurst(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirScooter(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSpout(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSwipe(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"") || !bPlayer.canUseFlight()) {
          return;
        }
        if (AirFlight.isFlying(event.getPlayer())) {
          if (AirFlight.isHovering(event.getPlayer())) {
            AirFlight.setHovering(event.getPlayer(),false);
          }
 else {
            AirFlight.setHovering(event.getPlayer(),true);
          }
        }
      }
    }
    if (coreAbil instanceof WaterAbility && bPlayer.isElementToggled(Element.WATER) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Bloodbending.launch(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceBlast.activate(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceSpikeBlast.activate(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new OctopusForm(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new PhaseChangeFreeze(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new PlantArmor(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterSpout(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        WaterManipulation.moveWater(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SurgeWall(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Torrent(player);
      }
    }
    if (coreAbil instanceof EarthAbility && bPlayer.isElementToggled(Element.EARTH) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Catapult(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        EarthBlast.throwEarth(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RaiseEarth(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Collapse(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Shockwave.coneShockwave(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthArmor(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthGrab(player,true);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Tremorsense(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        MetalClips clips=CoreAbility.getAbility(player,MetalClips.class);
        if (clips == null) {
          new MetalClips(player,0);
        }
 else         if (clips.getMetalClipsCount() < (player.hasPermission(""String_Node_Str"") ? 4 : 3)) {
          clips.shootMetal();
        }
 else         if (MetalClips.isControllingEntity(player)) {
          clips.launch();
        }
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        LavaSurge surge=CoreAbility.getAbility(player,LavaSurge.class);
        if (surge != null) {
          surge.launch();
        }
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new LavaFlow(player,AbilityType.CLICK);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthSmash(player,ClickType.LEFT_CLICK);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SandSpout(player);
      }
    }
    if (coreAbil instanceof FireAbility && bPlayer.isElementToggled(Element.FIRE) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Blaze(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBlast(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireJet(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HeatControlExtinguish(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Illumination(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        FireBurst.coneBurst(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireShield(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WallOfFire(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Combustion.explode(player);
      }
    }
    if (coreAbil instanceof ChiAbility && bPlayer.isElementToggled(Element.CHI) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HighJump(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RapidPunch(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Smokescreen(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WarriorStance(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AcrobatStance(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new QuickStrike(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SwiftKick(player);
      }
    }
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new AvatarState(player);
    }
  }
  if (MultiAbilityManager.hasMultiAbilityBound(player)) {
    abil=MultiAbilityManager.getBoundMultiAbility(player);
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new WaterArms(player);
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerSwing(PlayerAnimationEvent event){
  if (event.isCancelled()) {
    return;
  }
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return;
  }
 else   if (RIGHT_CLICK_INTERACT.contains(player.getUniqueId())) {
    return;
  }
  ComboManager.addComboAbility(player,ClickType.LEFT_CLICK);
  if (Suffocate.isBreathbent(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (Bloodbending.isBloodbent(player) || Paralyze.isParalyzed(player) || ChiCombo.isParalyzed(player)) {
    event.setCancelled(true);
    return;
  }
 else   if (bPlayer.isChiBlocked()) {
    event.setCancelled(true);
    return;
  }
 else   if (GeneralMethods.isInteractable(player.getTargetBlock((Set<Material>)null,5))) {
    event.setCancelled(true);
    return;
  }
 else   if (player.getItemInHand().getType() == Material.FISHING_ROD) {
    return;
  }
  BlockSource.update(player,ClickType.LEFT_CLICK);
  AirScooter.check(player);
  String abil=bPlayer.getBoundAbilityName();
  CoreAbility coreAbil=bPlayer.getBoundAbility();
  if (coreAbil == null && !MultiAbilityManager.hasMultiAbilityBound(player)) {
    return;
  }
 else   if (bPlayer.canBendIgnoreCooldowns(coreAbil)) {
    if (coreAbil instanceof AddonAbility) {
      return;
    }
    if (coreAbil instanceof AirAbility && bPlayer.isElementToggled(Element.AIR) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirBlast(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSuction(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        AirBurst.coneBurst(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirScooter(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSpout(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AirSwipe(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        if (!ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"") || !bPlayer.canUseFlight()) {
          return;
        }
        if (AirFlight.isFlying(event.getPlayer())) {
          if (AirFlight.isHovering(event.getPlayer())) {
            AirFlight.setHovering(event.getPlayer(),false);
          }
 else {
            AirFlight.setHovering(event.getPlayer(),true);
          }
        }
      }
    }
    if (coreAbil instanceof WaterAbility && bPlayer.isElementToggled(Element.WATER) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Bloodbending.launch(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceBlast.activate(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        IceSpikeBlast.activate(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new OctopusForm(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new PhaseChangeFreeze(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new PlantArmor(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WaterSpout(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        WaterManipulation.moveWater(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SurgeWall(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Torrent(player);
      }
    }
    if (coreAbil instanceof EarthAbility && bPlayer.isElementToggled(Element.EARTH) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Catapult(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        EarthBlast.throwEarth(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RaiseEarth(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Collapse(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Shockwave.coneShockwave(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthArmor(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthGrab(player,true);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Tremorsense(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        MetalClips clips=CoreAbility.getAbility(player,MetalClips.class);
        if (clips == null) {
          new MetalClips(player,0);
        }
 else         if (clips.getMetalClipsCount() < (player.hasPermission(""String_Node_Str"") ? 4 : 3)) {
          clips.shootMetal();
        }
 else         if (MetalClips.isControllingEntity(player)) {
          clips.launch();
        }
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        LavaSurge surge=CoreAbility.getAbility(player,LavaSurge.class);
        if (surge != null) {
          surge.launch();
        }
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new LavaFlow(player,AbilityType.CLICK);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new EarthSmash(player,ClickType.LEFT_CLICK);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SandSpout(player);
      }
    }
    if (coreAbil instanceof FireAbility && bPlayer.isElementToggled(Element.FIRE) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Blaze(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireBlast(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireJet(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HeatControlExtinguish(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Illumination(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        FireBurst.coneBurst(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new FireShield(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WallOfFire(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        Combustion.explode(player);
      }
    }
    if (coreAbil instanceof ChiAbility && bPlayer.isElementToggled(Element.CHI) == true) {
      if (GeneralMethods.isWeapon(player.getItemInHand().getType()) && !plugin.getConfig().getBoolean(""String_Node_Str"")) {
        return;
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new HighJump(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new RapidPunch(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new Smokescreen(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new WarriorStance(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new AcrobatStance(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new QuickStrike(player);
      }
      if (abil.equalsIgnoreCase(""String_Node_Str"")) {
        new SwiftKick(player);
      }
    }
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new AvatarState(player);
    }
  }
  if (MultiAbilityManager.hasMultiAbilityBound(player)) {
    abil=MultiAbilityManager.getBoundMultiAbility(player);
    if (abil.equalsIgnoreCase(""String_Node_Str"")) {
      new WaterArms(player);
    }
  }
}",0.9945952585677436
133921,"private void affect(Entity entity){
  boolean isUser=entity.getUniqueId() == player.getUniqueId();
  if (!isUser || isFromOtherOrigin) {
    pushFactor=pushFactorForOthers;
    Vector velocity=entity.getVelocity();
    double max=speed / speedFactor;
    double factor=pushFactor;
    if (bPlayer.isAvatarState()) {
      max=AvatarState.getValue(max);
      factor=AvatarState.getValue(factor);
    }
    Vector push=direction.clone();
    if (Math.abs(push.getY()) > max && !isUser) {
      if (push.getY() < 0) {
        push.setY(-max);
      }
 else {
        push.setY(max);
      }
    }
    factor*=1 - location.distance(origin) / (2 * range);
    if (isUser && GeneralMethods.isSolid(player.getLocation().add(0,-.5,0).getBlock())) {
      factor*=.5;
    }
    double comp=velocity.dot(push.clone().normalize());
    if (comp > factor) {
      velocity.multiply(.5);
      velocity.add(push.clone().normalize().multiply(velocity.clone().dot(push.clone().normalize())));
    }
 else     if (comp + factor * .5 > factor) {
      velocity.add(push.clone().multiply(factor - comp));
    }
 else {
      velocity.add(push.clone().multiply(factor * .5));
    }
    if (entity instanceof Player) {
      if (Commands.invincible.contains(((Player)entity).getName())) {
        return;
      }
    }
    if (Double.isNaN(velocity.length())) {
      return;
    }
    GeneralMethods.setVelocity(entity,velocity);
    if (source != null) {
      new HorizontalVelocityTracker(entity,player,200l,this);
    }
 else {
      new HorizontalVelocityTracker(entity,player,200l,this);
    }
    entity.setFallDistance(0);
    if (!isUser && entity instanceof Player) {
      new Flight((Player)entity,player);
    }
    if (entity.getFireTicks() > 0) {
      entity.getWorld().playEffect(entity.getLocation(),Effect.EXTINGUISH,0);
    }
    entity.setFireTicks(0);
    breakBreathbendingHold(entity);
    if (source != null && (this.damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,this);
      affectedEntities.add(entity);
    }
 else     if (source == null && (damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,this);
      affectedEntities.add(entity);
    }
  }
}","private void affect(Entity entity){
  boolean isUser=entity.getUniqueId() == player.getUniqueId();
  if (!isUser || isFromOtherOrigin) {
    pushFactor=pushFactorForOthers;
    Vector velocity=entity.getVelocity();
    double max=speed / speedFactor;
    double factor=pushFactor;
    if (bPlayer.isAvatarState()) {
      max=AvatarState.getValue(max);
      factor=AvatarState.getValue(factor);
    }
    Vector push=direction.clone();
    if (Math.abs(push.getY()) > max && !isUser) {
      if (push.getY() < 0) {
        push.setY(-max);
      }
 else {
        push.setY(max);
      }
    }
    factor*=1 - location.distance(origin) / (2 * range);
    if (isUser && GeneralMethods.isSolid(player.getLocation().add(0,-.5,0).getBlock())) {
      factor*=.5;
    }
    double comp=velocity.dot(push.clone().normalize());
    if (comp > factor) {
      velocity.multiply(.5);
      velocity.add(push.clone().normalize().multiply(velocity.clone().dot(push.clone().normalize())));
    }
 else     if (comp + factor * .5 > factor) {
      velocity.add(push.clone().multiply(factor - comp));
    }
 else {
      velocity.add(push.clone().multiply(factor * .5));
    }
    if (entity instanceof Player) {
      if (Commands.invincible.contains(((Player)entity).getName())) {
        return;
      }
    }
    if (Double.isNaN(velocity.length())) {
      return;
    }
    GeneralMethods.setVelocity(entity,velocity);
    if (source != null) {
      new HorizontalVelocityTracker(entity,player,200l,CoreAbility.getAbility(""String_Node_Str""));
    }
 else {
      new HorizontalVelocityTracker(entity,player,200l,this);
    }
    if (!isUser && entity instanceof Player) {
      new Flight((Player)entity,player);
    }
    if (entity.getFireTicks() > 0) {
      entity.getWorld().playEffect(entity.getLocation(),Effect.EXTINGUISH,0);
    }
    entity.setFireTicks(0);
    breakBreathbendingHold(entity);
    if (source != null && (this.damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,CoreAbility.getAbility(""String_Node_Str""));
      affectedEntities.add(entity);
    }
 else     if (source == null && (damage > 0 && entity instanceof LivingEntity && !entity.equals(player) && !affectedEntities.contains(entity))) {
      DamageHandler.damageEntity((LivingEntity)entity,damage,this);
      affectedEntities.add(entity);
    }
  }
}",0.97509775674007
133922,"public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",9);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}","public static void configCheck(ConfigType type){
  FileConfiguration config;
  if (type == ConfigType.PRESETS) {
    config=presetConfig.get();
    ArrayList<String> abilities=new ArrayList<String>();
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    abilities.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",abilities);
    presetConfig.save();
  }
 else   if (type == ConfigType.LANGUAGE) {
    config=languageConfig.get();
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    ;
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    languageConfig.save();
  }
 else   if (type == ConfigType.DEFAULT) {
    config=defaultConfig.get();
    ArrayList<String> earthBlocks=new ArrayList<String>();
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    earthBlocks.add(""String_Node_Str"");
    ArrayList<String> metalBlocks=new ArrayList<String>();
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    metalBlocks.add(""String_Node_Str"");
    ArrayList<String> sandBlocks=new ArrayList<String>();
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    sandBlocks.add(""String_Node_Str"");
    ArrayList<String> iceBlocks=new ArrayList<String>();
    iceBlocks.add(""String_Node_Str"");
    iceBlocks.add(""String_Node_Str"");
    ArrayList<String> plantBlocks=new ArrayList<String>();
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    plantBlocks.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",62);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",iceBlocks);
    config.addDefault(""String_Node_Str"",plantBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",300000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",earthBlocks);
    config.addDefault(""String_Node_Str"",metalBlocks);
    config.addDefault(""String_Node_Str"",sandBlocks);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",12000L);
    config.addDefault(""String_Node_Str"",true);
    ArrayList<String> disabledWorlds=new ArrayList<String>();
    disabledWorlds.add(""String_Node_Str"");
    disabledWorlds.add(""String_Node_Str"");
    config.addDefault(""String_Node_Str"",disabledWorlds);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7200000);
    config.addDefault(""String_Node_Str"",480000);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1750);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.675);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2.0);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.35);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.4);
    config.addDefault(""String_Node_Str"",14);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",750);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.7);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",70);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.75);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7500);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.2);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",180000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",Double.valueOf(10.0));
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",200);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",13);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",18);
    config.addDefault(""String_Node_Str"",45);
    config.addDefault(""String_Node_Str"",60);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",12000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3.8);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1.3);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",17500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",0.25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",10.0);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",5.0);
    config.addDefault(""String_Node_Str"",0.045);
    config.addDefault(""String_Node_Str"",0.10);
    config.addDefault(""String_Node_Str"",0.01);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",0.11);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",0.15);
    config.addDefault(""String_Node_Str"",0.72);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",30000);
    config.addDefault(""String_Node_Str"",11);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",30);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",3.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",0.6);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",8);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",6);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",40);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",9);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",16);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",1.0);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",25);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1500);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.275);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",3500);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0.8);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",7000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",1.5);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",100);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",20000);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",2500);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",0.20);
    config.addDefault(""String_Node_Str"",30.0);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.00125);
    config.addDefault(""String_Node_Str"",6.0);
    config.addDefault(""String_Node_Str"",0.50);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",false);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",5000);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",11000);
    config.addDefault(""String_Node_Str"",250);
    config.addDefault(""String_Node_Str"",500);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",50);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",7.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",5500);
    config.addDefault(""String_Node_Str"",7);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",3.0);
    config.addDefault(""String_Node_Str"",4500);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",20.0);
    config.addDefault(""String_Node_Str"",4.0);
    config.addDefault(""String_Node_Str"",0.55);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.2);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1.1);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",2.5);
    config.addDefault(""String_Node_Str"",0.3);
    config.addDefault(""String_Node_Str"",0.5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",35);
    config.addDefault(""String_Node_Str"",1000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",15000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",5);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",10000);
    config.addDefault(""String_Node_Str"",2000);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",6000);
    config.addDefault(""String_Node_Str"",3);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",25000);
    config.addDefault(""String_Node_Str"",4);
    config.addDefault(""String_Node_Str"",12);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",0);
    config.addDefault(""String_Node_Str"",-1);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",1);
    config.addDefault(""String_Node_Str"",10);
    config.addDefault(""String_Node_Str"",true);
    config.addDefault(""String_Node_Str"",2);
    config.addDefault(""String_Node_Str"",15);
    config.addDefault(""String_Node_Str"",4000);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",3306);
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",""String_Node_Str"");
    config.addDefault(""String_Node_Str"",false);
    defaultConfig.save();
  }
}",0.9989536517553738
133923,"public static ArrayList<TempBlock> getTempLandBlocks(){
  return TEMP_LAND_BLOCKS;
}","public static ConcurrentHashMap<Block,TempBlock> getTempLandBlocks(){
  return TEMP_LAND_BLOCKS;
}",0.8681318681318682
133924,"/** 
 * Creates a new LavaFlow ability and initializes all of the variables and cooldowns. The ability is not guaranteed to continue, it may be the case that the player doesn't have the correct permissions to bend this ability.
 * @param player the player that bended the ability
 * @param type either shift or sneak
 */
public LavaFlow(Player player,AbilityType type){
  super(player);
  if (!bPlayer.canLavabend()) {
    return;
  }
  this.time=System.currentTimeMillis();
  this.type=type;
  this.shiftCounter=0;
  this.currentRadius=0;
  this.particleOffset=3;
  this.removing=false;
  this.makeLava=true;
  this.clickIsFinished=false;
  this.affectedBlocks=new ArrayList<TempBlock>();
  this.tasks=new ArrayList<BukkitRunnable>();
  this.shiftCooldown=getConfig().getLong(""String_Node_Str"");
  this.shiftPlatformRadius=getConfig().getDouble(""String_Node_Str"");
  this.shiftMaxRadius=getConfig().getDouble(""String_Node_Str"");
  this.shiftFlowSpeed=getConfig().getDouble(""String_Node_Str"");
  this.shiftRemoveSpeed=getConfig().getDouble(""String_Node_Str"");
  this.shiftRemoveDelay=getConfig().getLong(""String_Node_Str"");
  this.particleDensity=getConfig().getDouble(""String_Node_Str"");
  this.clickRange=getConfig().getDouble(""String_Node_Str"");
  this.clickLavaRadius=getConfig().getDouble(""String_Node_Str"");
  this.clickLandRadius=getConfig().getDouble(""String_Node_Str"");
  this.clickLavaDelay=getConfig().getLong(""String_Node_Str"");
  this.clickLandDelay=getConfig().getLong(""String_Node_Str"");
  this.clickLavaCooldown=getConfig().getLong(""String_Node_Str"");
  this.clickLandCooldown=getConfig().getLong(""String_Node_Str"");
  this.clickLavaCleanupDelay=getConfig().getLong(""String_Node_Str"");
  this.clickLandCleanupDelay=getConfig().getLong(""String_Node_Str"");
  this.lavaCreateSpeed=getConfig().getDouble(""String_Node_Str"");
  this.landCreateSpeed=getConfig().getDouble(""String_Node_Str"");
  this.upwardFlow=getConfig().getInt(""String_Node_Str"");
  this.downwardFlow=getConfig().getInt(""String_Node_Str"");
  this.allowNaturalFlow=getConfig().getBoolean(""String_Node_Str"");
  if (bPlayer.isAvatarState()) {
    shiftCooldown=0;
    clickLavaCooldown=0;
    clickLandCooldown=0;
    shiftPlatformRadius=AvatarState.getValue(shiftPlatformRadius);
    shiftMaxRadius=AvatarState.getValue(shiftMaxRadius);
    shiftFlowSpeed=AvatarState.getValue(shiftFlowSpeed);
    shiftRemoveDelay=AvatarState.getValue(shiftRemoveDelay);
    clickRange=AvatarState.getValue(clickRange);
    clickLavaRadius=AvatarState.getValue(clickLavaRadius);
    clickLandRadius=AvatarState.getValue(clickLandRadius);
    clickLavaCleanupDelay=(long)AvatarState.getValue(clickLavaCleanupDelay);
    clickLandCleanupDelay=(long)AvatarState.getValue(clickLandCleanupDelay);
    lavaCreateSpeed=AvatarState.getValue(lavaCreateSpeed);
    landCreateSpeed=AvatarState.getValue(landCreateSpeed);
    upwardFlow=AvatarState.getValue(upwardFlow);
    downwardFlow=AvatarState.getValue(downwardFlow);
  }
  if (type == AbilityType.SHIFT) {
    ArrayList<LavaFlow> shiftFlows=LavaFlow.getLavaFlow(player,LavaFlow.AbilityType.SHIFT);
    if (shiftFlows.size() > 0 && !player.isSneaking()) {
      for (      LavaFlow lavaFlow : shiftFlows) {
        lavaFlow.shiftCounter++;
      }
    }
    if (bPlayer.isOnCooldown(""String_Node_Str"")) {
      remove();
      return;
    }
    start();
  }
 else   if (type == AbilityType.CLICK) {
    Block sourceBlock=BlockSource.getEarthOrLavaSourceBlock(player,clickRange,ClickType.LEFT_CLICK);
    if (sourceBlock == null) {
      remove();
      return;
    }
    long cooldown=makeLava ? clickLavaCooldown : clickLandCooldown;
    origin=sourceBlock.getLocation();
    makeLava=!isLava(sourceBlock);
    if (makeLava) {
      if (bPlayer.isOnCooldown(""String_Node_Str"")) {
        remove();
        return;
      }
 else {
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
      }
    }
    if (!makeLava) {
      if (bPlayer.isOnCooldown(""String_Node_Str"")) {
        remove();
        return;
      }
 else {
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
      }
    }
    start();
  }
}","/** 
 * Creates a new LavaFlow ability and initializes all of the variables and cooldowns. The ability is not guaranteed to continue, it may be the case that the player doesn't have the correct permissions to bend this ability.
 * @param player the player that bended the ability
 * @param type either shift or sneak
 */
public LavaFlow(Player player,AbilityType type){
  super(player);
  if (!bPlayer.canLavabend()) {
    return;
  }
  this.time=System.currentTimeMillis();
  this.type=type;
  this.shiftCounter=0;
  this.currentRadius=0;
  this.particleOffset=3;
  this.removing=false;
  this.makeLava=true;
  this.clickIsFinished=false;
  this.affectedBlocks=new ArrayList<TempBlock>();
  this.tasks=new ArrayList<BukkitRunnable>();
  this.revertMaterial=Material.getMaterial(getConfig().getString(""String_Node_Str""));
  this.shiftCooldown=getConfig().getLong(""String_Node_Str"");
  this.shiftPlatformRadius=getConfig().getDouble(""String_Node_Str"");
  this.shiftMaxRadius=getConfig().getDouble(""String_Node_Str"");
  this.shiftFlowSpeed=getConfig().getDouble(""String_Node_Str"");
  this.shiftRemoveSpeed=getConfig().getDouble(""String_Node_Str"");
  this.shiftRemoveDelay=getConfig().getLong(""String_Node_Str"");
  this.particleDensity=getConfig().getDouble(""String_Node_Str"");
  this.clickRange=getConfig().getDouble(""String_Node_Str"");
  this.clickLavaRadius=getConfig().getDouble(""String_Node_Str"");
  this.clickLandRadius=getConfig().getDouble(""String_Node_Str"");
  this.clickLavaDelay=getConfig().getLong(""String_Node_Str"");
  this.clickLandDelay=getConfig().getLong(""String_Node_Str"");
  this.clickLavaCooldown=getConfig().getLong(""String_Node_Str"");
  this.clickLandCooldown=getConfig().getLong(""String_Node_Str"");
  this.clickLavaCleanupDelay=getConfig().getLong(""String_Node_Str"");
  this.clickLandCleanupDelay=getConfig().getLong(""String_Node_Str"");
  this.lavaCreateSpeed=getConfig().getDouble(""String_Node_Str"");
  this.landCreateSpeed=getConfig().getDouble(""String_Node_Str"");
  this.upwardFlow=getConfig().getInt(""String_Node_Str"");
  this.downwardFlow=getConfig().getInt(""String_Node_Str"");
  this.allowNaturalFlow=getConfig().getBoolean(""String_Node_Str"");
  if (bPlayer.isAvatarState()) {
    shiftCooldown=0;
    clickLavaCooldown=0;
    clickLandCooldown=0;
    shiftPlatformRadius=AvatarState.getValue(shiftPlatformRadius);
    shiftMaxRadius=AvatarState.getValue(shiftMaxRadius);
    shiftFlowSpeed=AvatarState.getValue(shiftFlowSpeed);
    shiftRemoveDelay=AvatarState.getValue(shiftRemoveDelay);
    clickRange=AvatarState.getValue(clickRange);
    clickLavaRadius=AvatarState.getValue(clickLavaRadius);
    clickLandRadius=AvatarState.getValue(clickLandRadius);
    clickLavaCleanupDelay=(long)AvatarState.getValue(clickLavaCleanupDelay);
    clickLandCleanupDelay=(long)AvatarState.getValue(clickLandCleanupDelay);
    lavaCreateSpeed=AvatarState.getValue(lavaCreateSpeed);
    landCreateSpeed=AvatarState.getValue(landCreateSpeed);
    upwardFlow=AvatarState.getValue(upwardFlow);
    downwardFlow=AvatarState.getValue(downwardFlow);
  }
  if (type == AbilityType.SHIFT) {
    ArrayList<LavaFlow> shiftFlows=LavaFlow.getLavaFlow(player,LavaFlow.AbilityType.SHIFT);
    if (shiftFlows.size() > 0 && !player.isSneaking()) {
      for (      LavaFlow lavaFlow : shiftFlows) {
        lavaFlow.shiftCounter++;
      }
    }
    if (bPlayer.isOnCooldown(""String_Node_Str"")) {
      remove();
      return;
    }
    start();
  }
 else   if (type == AbilityType.CLICK) {
    Block sourceBlock=BlockSource.getEarthOrLavaSourceBlock(player,clickRange,ClickType.LEFT_CLICK);
    if (sourceBlock == null) {
      remove();
      return;
    }
    long cooldown=makeLava ? clickLavaCooldown : clickLandCooldown;
    origin=sourceBlock.getLocation();
    makeLava=!isLava(sourceBlock);
    if (bPlayer.isOnCooldown(""String_Node_Str"")) {
      remove();
      return;
    }
 else {
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
    }
    start();
  }
}",0.955865990851774
133925,"public static Material getRevertMaterial(){
  return REVERT_MATERIAL;
}","public static Material getRevertMaterial(){
  Material m=Material.STONE;
  LavaFlow lf=(LavaFlow)CoreAbility.getAbility(""String_Node_Str"");
  m=lf.revertMaterial;
  return m;
}",0.4534412955465587
133926,"/** 
 * Creates a LavaBlock and appends the TempBlock to our arraylist called TEMP_LAVA_BLOCKS. If ALLOW_NATURAL_FLOW is turned on then this method will remove the block from TempBlock.instances, which will allow the lava to flow naturally.
 * @param block the block that will be turned to lava
 */
public void createLava(Block block){
  if (isEarthbendable(block)) {
    TempBlock tblock=new TempBlock(block,Material.STATIONARY_LAVA,(byte)0);
    TEMP_LAVA_BLOCKS.add(tblock);
    affectedBlocks.add(tblock);
    if (allowNaturalFlow) {
      TempBlock.instances.remove(block);
    }
  }
}","/** 
 * Creates a LavaBlock and appends the TempBlock to our arraylist called TEMP_LAVA_BLOCKS. If ALLOW_NATURAL_FLOW is turned on then this method will remove the block from TempBlock.instances, which will allow the lava to flow naturally.
 * @param block the block that will be turned to lava
 */
public void createLava(Block block){
  if (isEarth(block) || isSand(block) || isMetal(block)) {
    TempBlock tblock=new TempBlock(block,Material.STATIONARY_LAVA,(byte)0);
    TEMP_LAVA_BLOCKS.put(block,tblock);
    affectedBlocks.add(tblock);
    if (allowNaturalFlow) {
      TempBlock.instances.remove(block);
    }
  }
}",0.9530090684253916
133927,"public static ArrayList<TempBlock> getTempLavaBlocks(){
  return TEMP_LAVA_BLOCKS;
}","public static ConcurrentHashMap<Block,TempBlock> getTempLavaBlocks(){
  return TEMP_LAVA_BLOCKS;
}",0.8681318681318682
133928,"/** 
 * Removes a lava block if it is inside of our ArrayList of TempBlocks.
 * @param testBlock the block to attempt to remove
 */
@SuppressWarnings(""String_Node_Str"") public void removeLava(Block testBlock){
  for (int i=0; i < TEMP_LAVA_BLOCKS.size(); i++) {
    TempBlock tblock=TEMP_LAVA_BLOCKS.get(i);
    Block block=tblock.getBlock();
    if (block.equals(testBlock)) {
      tblock.revertBlock();
      TEMP_LAVA_BLOCKS.remove(i);
      affectedBlocks.remove(tblock);
      return;
    }
  }
  TempBlock tblock=new TempBlock(testBlock,REVERT_MATERIAL,testBlock.getData());
  affectedBlocks.add(tblock);
  TEMP_LAND_BLOCKS.add(tblock);
}","/** 
 * Removes a lava block if it is inside of our ArrayList of TempBlocks.
 * @param testBlock the block to attempt to remove
 */
@SuppressWarnings(""String_Node_Str"") public void removeLava(Block testBlock){
  if (TEMP_LAVA_BLOCKS.containsKey(testBlock)) {
    TempBlock tb=TEMP_LAVA_BLOCKS.get(testBlock);
    tb.revertBlock();
    TEMP_LAVA_BLOCKS.remove(testBlock);
    affectedBlocks.remove(tb);
    return;
  }
  TempBlock tblock=new TempBlock(testBlock,revertMaterial,testBlock.getData());
  affectedBlocks.add(tblock);
  TEMP_LAND_BLOCKS.put(testBlock,tblock);
}",0.725328947368421
133929,"/** 
 * Progresses LavaFlow by 1 tick. This is the heart of the ability, it determines whether or not the LavaFlow type is Click/Sneaking, and it will remove the ability if any issues arise.
 */
@Override public void progress(){
  if (shiftCounter > 0 && type == AbilityType.SHIFT) {
    remove();
    return;
  }
 else   if (removing) {
    return;
  }
 else   if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  Random random=new Random();
  if (type == AbilityType.SHIFT) {
    if (System.currentTimeMillis() - time > shiftRemoveDelay) {
      remove();
      return;
    }
    if (!player.isSneaking() && !removing) {
      if (affectedBlocks.size() > 0) {
        removeOnDelay();
        removing=true;
        bPlayer.addCooldown(""String_Node_Str"",shiftCooldown);
      }
 else {
        remove();
      }
      return;
    }
    if (!bPlayer.canBendIgnoreCooldowns(this)) {
      remove();
      return;
    }
 else     if (origin == null) {
      origin=player.getLocation().clone().add(0,-1,0);
      if (!isEarthbendable(origin.getBlock()) && origin.getBlock().getType() != Material.GLOWSTONE) {
        remove();
        return;
      }
    }
    for (double x=-currentRadius; x <= currentRadius + particleOffset; x++) {
      for (double z=-currentRadius; z < currentRadius + particleOffset; z++) {
        Location loc=origin.clone().add(x,0,z);
        Block block=GeneralMethods.getTopBlock(loc,upwardFlow,downwardFlow);
        if (block == null) {
          continue;
        }
        double dSquared=distanceSquaredXZ(block.getLocation(),origin);
        if (!isLava(block) && dSquared > Math.pow(shiftPlatformRadius,2)) {
          if (dSquared < Math.pow(currentRadius,2) && !GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
            if (dSquared < shiftPlatformRadius * 4 || getAdjacentLavaBlocks(block.getLocation()).size() > 0) {
              createLava(block);
            }
          }
 else           if (Math.random() < particleDensity && dSquared < Math.pow(currentRadius + particleDensity,2) && currentRadius + particleDensity < shiftMaxRadius && random.nextInt(3) == 0) {
            ParticleEffect.LAVA.display(loc,(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
          }
        }
      }
      if (!shiftIsFinished) {
        if (random.nextInt(10) == 0) {
          ParticleEffect.LAVA.display(player.getLocation(),(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
        }
      }
      currentRadius+=shiftFlowSpeed;
      if (currentRadius > shiftMaxRadius) {
        currentRadius=shiftMaxRadius;
        shiftIsFinished=true;
      }
    }
  }
 else   if (type == AbilityType.CLICK) {
    long curTime=System.currentTimeMillis() - time;
    double delay=makeLava ? clickLavaDelay : clickLandDelay;
    if (makeLava && curTime > clickLavaCleanupDelay) {
      remove();
      return;
    }
 else     if (!makeLava && curTime > clickLandCleanupDelay) {
      remove();
      return;
    }
 else     if (!makeLava && curTime < delay) {
      return;
    }
 else     if (makeLava && curTime < delay) {
      for (double x=-clickLavaRadius; x <= clickLavaRadius; x++) {
        for (double z=-clickLavaRadius; z <= clickLavaRadius; z++) {
          Location loc=origin.clone().add(x,0,z);
          Block tempBlock=GeneralMethods.getTopBlock(loc,upwardFlow,downwardFlow);
          if (tempBlock != null && !isLava(tempBlock) && Math.random() < particleDensity && tempBlock.getLocation().distanceSquared(origin) <= Math.pow(clickLavaRadius,2)) {
            if (random.nextInt(3) == 0) {
              ParticleEffect.LAVA.display(loc,(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
            }
          }
        }
      }
      return;
    }
    if (!clickIsFinished) {
      clickIsFinished=true;
      double radius=makeLava ? clickLavaRadius : clickLandRadius;
      for (double x=-radius; x <= radius; x++) {
        for (double z=-radius; z <= radius; z++) {
          Location loc=origin.clone().add(x,0,z);
          Block tempBlock=GeneralMethods.getTopBlock(loc,upwardFlow,downwardFlow);
          if (tempBlock == null) {
            continue;
          }
          double dSquared=distanceSquaredXZ(tempBlock.getLocation(),origin);
          if (dSquared < Math.pow(radius,2) && !GeneralMethods.isRegionProtectedFromBuild(this,loc)) {
            if (makeLava && !isLava(tempBlock)) {
              clickIsFinished=false;
              if (Math.random() < lavaCreateSpeed) {
                createLava(tempBlock);
              }
 else {
                if (random.nextInt(4) == 0) {
                  ParticleEffect.LAVA.display(loc,(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
                }
              }
            }
 else             if (!makeLava && isLava(tempBlock)) {
              clickIsFinished=false;
              if (Math.random() < landCreateSpeed) {
                removeLava(tempBlock);
              }
            }
          }
        }
      }
      return;
    }
  }
}","/** 
 * Progresses LavaFlow by 1 tick. This is the heart of the ability, it determines whether or not the LavaFlow type is Click/Sneaking, and it will remove the ability if any issues arise.
 */
@Override public void progress(){
  if (shiftCounter > 0 && type == AbilityType.SHIFT) {
    remove();
    return;
  }
 else   if (removing) {
    return;
  }
 else   if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  Random random=new Random();
  if (type == AbilityType.SHIFT) {
    if (System.currentTimeMillis() - time > shiftRemoveDelay) {
      remove();
      return;
    }
    if (!player.isSneaking() && !removing) {
      if (affectedBlocks.size() > 0) {
        removeOnDelay();
        removing=true;
        bPlayer.addCooldown(""String_Node_Str"",shiftCooldown);
      }
 else {
        remove();
      }
      return;
    }
    if (!bPlayer.canBendIgnoreCooldowns(this)) {
      remove();
      return;
    }
 else     if (origin == null) {
      origin=player.getLocation().clone().add(0,-1,0);
      if (!isEarthbendable(origin.getBlock()) && origin.getBlock().getType() != Material.GLOWSTONE) {
        remove();
        return;
      }
    }
    for (double x=-currentRadius; x <= currentRadius + particleOffset; x++) {
      for (double z=-currentRadius; z < currentRadius + particleOffset; z++) {
        Location loc=origin.clone().add(x,0,z);
        Block block=GeneralMethods.getTopBlock(loc,upwardFlow,downwardFlow);
        if (block == null) {
          continue;
        }
        double dSquared=distanceSquaredXZ(block.getLocation(),origin);
        if (dSquared > Math.pow(shiftPlatformRadius,2)) {
          if (dSquared < Math.pow(currentRadius,2) && !GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
            if (dSquared < shiftPlatformRadius * 4 || getAdjacentLavaBlocks(block.getLocation()).size() > 0) {
              if (!isLava(block)) {
                if (isPlant(block)) {
                  Block lower=block.getRelative(BlockFace.DOWN);
                  if (isPlant(lower)) {
                    Block lower2=lower.getRelative(BlockFace.DOWN);
                    if (!isEarth(lower2) && !isSand(lower2) && !isMetal(lower2)) {
                      continue;
                    }
                    block.breakNaturally();
                    lower.breakNaturally();
                    createLava(lower2);
                  }
 else {
                    if (!isEarth(lower) && !isSand(lower) && !isMetal(lower)) {
                      continue;
                    }
                    block.breakNaturally();
                    createLava(lower);
                  }
                }
 else {
                  if (!isEarth(block) && !isSand(block) && !isMetal(block)) {
                    continue;
                  }
                  createLava(block);
                }
              }
            }
          }
 else           if (Math.random() < particleDensity && dSquared < Math.pow(currentRadius + particleDensity,2) && currentRadius + particleDensity < shiftMaxRadius && random.nextInt(3) == 0) {
            ParticleEffect.LAVA.display(loc,(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
          }
        }
      }
      if (!shiftIsFinished) {
        if (random.nextInt(10) == 0) {
          ParticleEffect.LAVA.display(player.getLocation(),(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
        }
      }
      currentRadius+=shiftFlowSpeed;
      if (currentRadius > shiftMaxRadius) {
        currentRadius=shiftMaxRadius;
        shiftIsFinished=true;
      }
    }
  }
 else   if (type == AbilityType.CLICK) {
    long curTime=System.currentTimeMillis() - time;
    double delay=makeLava ? clickLavaDelay : clickLandDelay;
    if (makeLava && curTime > clickLavaCleanupDelay) {
      remove();
      return;
    }
 else     if (!makeLava && curTime > clickLandCleanupDelay) {
      remove();
      return;
    }
 else     if (!makeLava && curTime < delay) {
      return;
    }
 else     if (makeLava && curTime < delay) {
      for (double x=-clickLavaRadius; x <= clickLavaRadius; x++) {
        for (double z=-clickLavaRadius; z <= clickLavaRadius; z++) {
          Location loc=origin.clone().add(x,0,z);
          Block tempBlock=GeneralMethods.getTopBlock(loc,upwardFlow,downwardFlow);
          if (tempBlock != null && !isLava(tempBlock) && Math.random() < particleDensity && tempBlock.getLocation().distanceSquared(origin) <= Math.pow(clickLavaRadius,2)) {
            if (random.nextInt(3) == 0) {
              ParticleEffect.LAVA.display(loc,(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
            }
          }
        }
      }
      return;
    }
    if (!clickIsFinished) {
      clickIsFinished=true;
      double radius=makeLava ? clickLavaRadius : clickLandRadius;
      for (double x=-radius; x <= radius; x++) {
        for (double z=-radius; z <= radius; z++) {
          Location loc=origin.clone().add(x,0,z);
          Block tempBlock=GeneralMethods.getTopBlock(loc,upwardFlow,downwardFlow);
          if (tempBlock == null) {
            continue;
          }
          double dSquared=distanceSquaredXZ(tempBlock.getLocation(),origin);
          if (dSquared < Math.pow(radius,2) && !GeneralMethods.isRegionProtectedFromBuild(this,loc)) {
            if (makeLava && !isLava(tempBlock)) {
              clickIsFinished=false;
              if (Math.random() < lavaCreateSpeed) {
                if (!isLava(tempBlock)) {
                  if (isPlant(tempBlock)) {
                    Block lower=tempBlock.getRelative(BlockFace.DOWN);
                    if (isPlant(lower)) {
                      Block lower2=lower.getRelative(BlockFace.DOWN);
                      if (!isEarth(lower2) && !isSand(lower2) && !isMetal(lower2)) {
                        continue;
                      }
                      tempBlock.breakNaturally();
                      lower.breakNaturally();
                      createLava(lower2);
                    }
 else {
                      if (!isEarth(lower) && !isSand(lower) && !isMetal(lower)) {
                        continue;
                      }
                      tempBlock.breakNaturally();
                      createLava(lower);
                    }
                  }
 else {
                    if (!isEarth(tempBlock) && !isSand(tempBlock) && !isMetal(tempBlock)) {
                      continue;
                    }
                    createLava(tempBlock);
                  }
                }
              }
 else {
                if (random.nextInt(4) == 0) {
                  ParticleEffect.LAVA.display(loc,(float)Math.random(),(float)Math.random(),(float)Math.random(),0,1);
                }
              }
            }
 else             if (!makeLava && isLava(tempBlock)) {
              clickIsFinished=false;
              if (Math.random() < landCreateSpeed) {
                removeLava(tempBlock);
              }
            }
          }
        }
      }
      return;
    }
  }
}",0.7877792378449409
133930,"public WaterSpoutWave(Player player,AbilityType type){
  super(player);
  this.charging=false;
  this.iceWave=false;
  this.iceOnly=false;
  this.plant=getConfig().getBoolean(""String_Node_Str"");
  this.radius=getConfig().getDouble(""String_Node_Str"");
  this.waveRadius=getConfig().getDouble(""String_Node_Str"");
  this.animationSpeed=getConfig().getDouble(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.speed=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.flightTime=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.affectedBlocks=new ConcurrentHashMap<>();
  this.affectedEntities=new ArrayList<>();
  this.tasks=new ArrayList<>();
  this.damage=getNightFactor(this.damage);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.time=System.currentTimeMillis();
  this.type=type;
  start();
  if (type == AbilityType.CLICK) {
    progress();
  }
}","public WaterSpoutWave(Player player,AbilityType type){
  super(player);
  this.charging=false;
  this.iceWave=false;
  this.iceOnly=false;
  this.plant=getConfig().getBoolean(""String_Node_Str"");
  this.radius=getConfig().getDouble(""String_Node_Str"");
  this.waveRadius=getConfig().getDouble(""String_Node_Str"");
  this.thawRadius=getConfig().getDouble(""String_Node_Str"");
  this.animationSpeed=getConfig().getDouble(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  this.speed=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.flightTime=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.affectedBlocks=new ConcurrentHashMap<>();
  this.affectedEntities=new ArrayList<>();
  this.tasks=new ArrayList<>();
  this.damage=getNightFactor(this.damage);
  if (!bPlayer.canBend(this)) {
    return;
  }
  this.time=System.currentTimeMillis();
  this.type=type;
  start();
  if (type == AbilityType.CLICK) {
    progress();
  }
}",0.9724517906336088
133931,"@Override public void progress(){
  progressCounter++;
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (type != AbilityType.RELEASE) {
    if (!player.hasPermission(""String_Node_Str"")) {
      remove();
      return;
    }
 else     if (!bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
  }
  if (type == AbilityType.CLICK) {
    if (origin == null) {
      removeOldType(player,AbilityType.CLICK);
      Block block=getWaterSourceBlock(player,selectRange,plant);
      if (block == null) {
        remove();
        return;
      }
      Block blockAbove=block.getRelative(BlockFace.UP);
      if (blockAbove.getType() != Material.AIR && !isWaterbendable(blockAbove)) {
        remove();
        return;
      }
      origin=block.getLocation();
      if (!isWaterbendable(block) || GeneralMethods.isRegionProtectedFromBuild(this,origin)) {
        remove();
        return;
      }
 else       if (iceOnly && !(isIcebendable(block) || isSnow(block))) {
        remove();
        return;
      }
    }
    if (player.getLocation().distanceSquared(origin) > selectRange * selectRange) {
      remove();
      return;
    }
 else     if (player.isSneaking()) {
      setType(AbilityType.SHIFT);
      return;
    }
    playFocusWaterEffect(origin.getBlock());
  }
 else   if (type == AbilityType.SHIFT) {
    if (direction == null) {
      direction=player.getEyeLocation().getDirection();
    }
    if (!charging) {
      if (!containsType(player,AbilityType.SHIFT)) {
        removeOldType(player,AbilityType.CLICK);
        remove();
        return;
      }
      charging=true;
      animation=AnimateState.RISE;
      location=origin.clone();
      if (isPlant(origin.getBlock())) {
        new PlantRegrowth(player,origin.getBlock());
      }
    }
    removeOldType(player,AbilityType.CLICK);
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - time > chargeTime) {
        setType(AbilityType.RELEASE);
        setAnimation(AnimateState.SHRINK);
      }
 else {
        remove();
      }
      return;
    }
    if (animation == AnimateState.RISE && location != null) {
      revertBlocks();
      location.add(0,animationSpeed,0);
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(origin) > 4) {
        animation=AnimateState.TOWARD_PLAYER;
      }
    }
 else     if (animation == AnimateState.TOWARD_PLAYER) {
      revertBlocks();
      Location eyeLoc=player.getTargetBlock((HashSet<Material>)null,2).getLocation();
      eyeLoc.setY(player.getEyeLocation().getY());
      Vector vec=GeneralMethods.getDirection(location,eyeLoc);
      location.add(vec.normalize().multiply(animationSpeed));
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(eyeLoc) < 1.7) {
        animation=AnimateState.CIRCLE;
        Vector tempDir=player.getLocation().getDirection();
        tempDir.setY(0);
        direction=tempDir.normalize();
        revertBlocks();
      }
    }
 else     if (animation == AnimateState.CIRCLE) {
      drawCircle(120,5);
    }
  }
 else   if (type == AbilityType.RELEASE) {
    if (animation == AnimateState.SHRINK) {
      radius-=0.20;
      drawCircle(360,15);
      if (radius < 1) {
        revertBlocks();
        time=System.currentTimeMillis();
        animation=null;
      }
    }
 else {
      moving=true;
      if ((System.currentTimeMillis() - time > flightTime && !bPlayer.isAvatarState()) || player.isSneaking()) {
        remove();
        return;
      }
      player.setFallDistance(0f);
      double currentSpeed=speed - (speed * (System.currentTimeMillis() - time) / flightTime);
      double nightSpeed=getNightFactor(currentSpeed * 0.9);
      currentSpeed=nightSpeed > currentSpeed ? nightSpeed : currentSpeed;
      if (bPlayer.isAvatarState()) {
        currentSpeed=getNightFactor(speed);
      }
      player.setVelocity(player.getEyeLocation().getDirection().normalize().multiply(currentSpeed));
      for (      Block block : GeneralMethods.getBlocksAroundPoint(player.getLocation().add(0,-1,0),waveRadius)) {
        if (block.getType() == Material.AIR && !GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
          if (iceWave) {
            createBlockDelay(block,Material.ICE,(byte)0,2L);
          }
 else {
            createBlock(block,Material.STATIONARY_WATER,(byte)0);
          }
        }
      }
      revertBlocksDelay(20L);
      if (iceWave && progressCounter % 3 == 0) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation().add(0,-1,0),waveRadius * 1.5)) {
          if (entity != this.player && entity instanceof LivingEntity && !affectedEntities.contains(entity)) {
            affectedEntities.add(entity);
            final double augment=getNightFactor(player.getWorld());
            DamageHandler.damageEntity(entity,damage,this);
            final Player fplayer=this.player;
            final Entity fent=entity;
            new BukkitRunnable(){
              @Override public void run(){
                createIceSphere(fplayer,fent,augment * 2.5);
              }
            }
.runTaskLater(ProjectKorra.plugin,6);
          }
        }
      }
    }
  }
}","@Override public void progress(){
  progressCounter++;
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (type != AbilityType.RELEASE) {
    if (!player.hasPermission(""String_Node_Str"")) {
      remove();
      return;
    }
 else     if (!bPlayer.getBoundAbilityName().equalsIgnoreCase(getName())) {
      remove();
      return;
    }
  }
  if (type == AbilityType.CLICK) {
    if (origin == null) {
      removeOldType(player,AbilityType.CLICK);
      Block block=getWaterSourceBlock(player,selectRange,plant);
      if (block == null) {
        remove();
        return;
      }
      Block blockAbove=block.getRelative(BlockFace.UP);
      if (blockAbove.getType() != Material.AIR && !isWaterbendable(blockAbove)) {
        remove();
        return;
      }
      origin=block.getLocation();
      if (!isWaterbendable(block) || GeneralMethods.isRegionProtectedFromBuild(this,origin)) {
        remove();
        return;
      }
 else       if (iceOnly && !(isIcebendable(block) || isSnow(block))) {
        remove();
        return;
      }
    }
    if (player.getLocation().distanceSquared(origin) > selectRange * selectRange) {
      remove();
      return;
    }
 else     if (player.isSneaking()) {
      setType(AbilityType.SHIFT);
      return;
    }
    playFocusWaterEffect(origin.getBlock());
  }
 else   if (type == AbilityType.SHIFT) {
    if (direction == null) {
      direction=player.getEyeLocation().getDirection();
    }
    if (!charging) {
      if (!containsType(player,AbilityType.SHIFT)) {
        removeOldType(player,AbilityType.CLICK);
        remove();
        return;
      }
      charging=true;
      animation=AnimateState.RISE;
      location=origin.clone();
      if (isPlant(origin.getBlock())) {
        new PlantRegrowth(player,origin.getBlock());
      }
    }
    removeOldType(player,AbilityType.CLICK);
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - time > chargeTime) {
        setType(AbilityType.RELEASE);
        setAnimation(AnimateState.SHRINK);
      }
 else {
        remove();
      }
      return;
    }
    if (animation == AnimateState.RISE && location != null) {
      revertBlocks();
      location.add(0,animationSpeed,0);
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(origin) > 4) {
        animation=AnimateState.TOWARD_PLAYER;
      }
    }
 else     if (animation == AnimateState.TOWARD_PLAYER) {
      revertBlocks();
      Location eyeLoc=player.getTargetBlock((HashSet<Material>)null,2).getLocation();
      eyeLoc.setY(player.getEyeLocation().getY());
      Vector vec=GeneralMethods.getDirection(location,eyeLoc);
      location.add(vec.normalize().multiply(animationSpeed));
      Block block=location.getBlock();
      if (!(isWaterbendable(block) || block.getType() == Material.AIR) || GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
        remove();
        return;
      }
      createBlock(block,Material.STATIONARY_WATER);
      if (location.distanceSquared(eyeLoc) < 1.7) {
        animation=AnimateState.CIRCLE;
        Vector tempDir=player.getLocation().getDirection();
        tempDir.setY(0);
        direction=tempDir.normalize();
        revertBlocks();
      }
    }
 else     if (animation == AnimateState.CIRCLE) {
      drawCircle(120,5);
    }
  }
 else   if (type == AbilityType.RELEASE) {
    if (animation == AnimateState.SHRINK) {
      radius-=0.20;
      drawCircle(360,15);
      if (radius < 1) {
        revertBlocks();
        time=System.currentTimeMillis();
        animation=null;
      }
    }
 else {
      moving=true;
      if ((System.currentTimeMillis() - time > flightTime && !bPlayer.isAvatarState()) || player.isSneaking()) {
        remove();
        return;
      }
      player.setFallDistance(0f);
      double currentSpeed=speed - (speed * (System.currentTimeMillis() - time) / flightTime);
      double nightSpeed=getNightFactor(currentSpeed * 0.9);
      currentSpeed=nightSpeed > currentSpeed ? nightSpeed : currentSpeed;
      if (bPlayer.isAvatarState()) {
        currentSpeed=getNightFactor(speed);
      }
      player.setVelocity(player.getEyeLocation().getDirection().normalize().multiply(currentSpeed));
      for (      Block block : GeneralMethods.getBlocksAroundPoint(player.getLocation().add(0,-1,0),waveRadius)) {
        if (block.getType() == Material.AIR && !GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
          if (iceWave) {
            createBlockDelay(block,Material.ICE,(byte)0,2L);
          }
 else {
            createBlock(block,Material.STATIONARY_WATER,(byte)0);
          }
        }
      }
      revertBlocksDelay(20L);
      if (iceWave && progressCounter % 3 == 0) {
        for (        Entity entity : GeneralMethods.getEntitiesAroundPoint(player.getLocation().add(0,-1,0),waveRadius * 1.5)) {
          if (entity != this.player && entity instanceof LivingEntity && !affectedEntities.contains(entity)) {
            affectedEntities.add(entity);
            final double augment=getNightFactor(player.getWorld());
            DamageHandler.damageEntity(entity,damage,this);
            final Player fplayer=this.player;
            final Entity fent=entity;
            new BukkitRunnable(){
              @Override public void run(){
                createIceSphere(fplayer,fent,augment * 2.5);
              }
            }
.runTaskLater(ProjectKorra.plugin,6);
          }
        }
        for (        Block block : FROZEN_BLOCKS.keySet()) {
          TempBlock tBlock=FROZEN_BLOCKS.get(block);
          if (tBlock.getLocation().distance(player.getLocation()) >= thawRadius) {
            tBlock.revertBlock();
            FROZEN_BLOCKS.remove(block);
          }
        }
      }
    }
  }
}",0.9750297265160524
133932,"@SuppressWarnings(""String_Node_Str"") public EarthArmor(Player player){
  super(player);
  if (hasAbility(player,EarthArmor.class) || !bPlayer.canBend(this)) {
    return;
  }
  this.formed=false;
  this.complete=false;
  this.interval=2000;
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.strength=getConfig().getInt(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  headBlock=getTargetEarthBlock((int)selectRange);
  if (!GeneralMethods.isRegionProtectedFromBuild(this,headBlock.getLocation()) && getEarthbendableBlocksLength(headBlock,new Vector(0,-1,0),2) >= 2) {
    this.legsBlock=headBlock.getRelative(BlockFace.DOWN);
    this.headType=headBlock.getType();
    this.legsType=legsBlock.getType();
    this.headData=headBlock.getData();
    this.legsData=legsBlock.getData();
    this.headBlockLocation=headBlock.getLocation();
    this.legsBlockLocation=legsBlock.getLocation();
    Block oldHeadBlock=headBlock;
    Block oldLegsBlock=legsBlock;
    if (!moveBlocks()) {
      return;
    }
    if (isEarthRevertOn()) {
      addTempAirBlock(oldHeadBlock);
      addTempAirBlock(oldLegsBlock);
    }
 else {
      GeneralMethods.removeBlock(oldHeadBlock);
      GeneralMethods.removeBlock(oldLegsBlock);
    }
    start();
  }
}","@SuppressWarnings(""String_Node_Str"") public EarthArmor(Player player){
  super(player);
  if (hasAbility(player,EarthArmor.class) || !bPlayer.canBend(this)) {
    return;
  }
  if (hasAbility(player,PlantArmor.class)) {
    PlantArmor abil=getAbility(player,PlantArmor.class);
    abil.remove();
    player.sendMessage(""String_Node_Str"");
  }
  this.formed=false;
  this.complete=false;
  this.interval=2000;
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.strength=getConfig().getInt(""String_Node_Str"");
  this.selectRange=getConfig().getDouble(""String_Node_Str"");
  headBlock=getTargetEarthBlock((int)selectRange);
  if (!GeneralMethods.isRegionProtectedFromBuild(this,headBlock.getLocation()) && getEarthbendableBlocksLength(headBlock,new Vector(0,-1,0),2) >= 2) {
    this.legsBlock=headBlock.getRelative(BlockFace.DOWN);
    this.headType=headBlock.getType();
    this.legsType=legsBlock.getType();
    this.headData=headBlock.getData();
    this.legsData=legsBlock.getData();
    this.headBlockLocation=headBlock.getLocation();
    this.legsBlockLocation=legsBlock.getLocation();
    Block oldHeadBlock=headBlock;
    Block oldLegsBlock=legsBlock;
    if (!moveBlocks()) {
      return;
    }
    if (isEarthRevertOn()) {
      addTempAirBlock(oldHeadBlock);
      addTempAirBlock(oldLegsBlock);
    }
 else {
      GeneralMethods.removeBlock(oldHeadBlock);
      GeneralMethods.removeBlock(oldLegsBlock);
    }
    start();
  }
}",0.9409697821503864
133933,"public PlantArmor(Player player){
  super(player);
  this.resistance=getConfig().getInt(""String_Node_Str"");
  this.range=getConfig().getInt(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.range=getNightFactor(range);
  this.duration=(long)getNightFactor(duration);
  if (hasAbility(player,PlantArmor.class)) {
    return;
  }
 else   if (bPlayer.isOnCooldown(this)) {
    return;
  }
  block=getPlantSourceBlock(player,range,true);
  if (block == null) {
    return;
  }
  location=block.getLocation();
  hadEffect=player.hasPotionEffect(PotionEffectType.DAMAGE_RESISTANCE);
  if (!canUse()) {
    return;
  }
  plantbending=new PlantRegrowth(player,block);
  blockType=block.getType();
  block.setType(Material.AIR);
  start();
}","public PlantArmor(Player player){
  super(player);
  this.resistance=getConfig().getInt(""String_Node_Str"");
  this.range=getConfig().getInt(""String_Node_Str"");
  this.duration=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.range=getNightFactor(range);
  this.duration=(long)getNightFactor(duration);
  if (hasAbility(player,PlantArmor.class)) {
    return;
  }
 else   if (!bPlayer.canBend(this)) {
    return;
  }
  if (hasAbility(player,EarthArmor.class)) {
    EarthArmor abil=getAbility(player,EarthArmor.class);
    abil.remove();
    player.sendMessage(""String_Node_Str"");
  }
  block=getPlantSourceBlock(player,range,true);
  if (block == null) {
    return;
  }
  location=block.getLocation();
  hadEffect=player.hasPotionEffect(PotionEffectType.DAMAGE_RESISTANCE);
  if (!canUse()) {
    return;
  }
  plantbending=new PlantRegrowth(player,block);
  blockType=block.getType();
  block.setType(Material.AIR);
  start();
}",0.8959025470653378
133934,"public AirBurst(Player player,boolean isFallBurst){
  super(player);
  if (bPlayer.isOnCooldown(this)) {
    remove();
    return;
  }
  this.isFallBurst=isFallBurst;
  this.isCharged=false;
  this.playerFallDistance=player.getFallDistance();
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.fallThreshold=getConfig().getDouble(""String_Node_Str"");
  this.pushFactor=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.blastAnglePhi=getConfig().getDouble(""String_Node_Str"");
  this.blastAngleTheta=getConfig().getDouble(""String_Node_Str"");
  this.sneakParticles=getConfig().getInt(""String_Node_Str"");
  this.particlePercentage=getConfig().getDouble(""String_Node_Str"");
  this.blasts=new ArrayList<>();
  this.affectedEntities=new ArrayList<>();
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.damage=AvatarState.getValue(this.damage);
  }
  start();
}","public AirBurst(Player player,boolean isFallBurst){
  super(player);
  if (bPlayer.isOnCooldown(this)) {
    remove();
    return;
  }
  if (hasAbility(player,AirBurst.class)) {
    if (!getAbility(player,AirBurst.class).isCharged()) {
      return;
    }
  }
  this.isFallBurst=isFallBurst;
  this.isCharged=false;
  this.playerFallDistance=player.getFallDistance();
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.fallThreshold=getConfig().getDouble(""String_Node_Str"");
  this.pushFactor=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.blastAnglePhi=getConfig().getDouble(""String_Node_Str"");
  this.blastAngleTheta=getConfig().getDouble(""String_Node_Str"");
  this.sneakParticles=getConfig().getInt(""String_Node_Str"");
  this.particlePercentage=getConfig().getDouble(""String_Node_Str"");
  this.blasts=new ArrayList<>();
  this.affectedEntities=new ArrayList<>();
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.damage=AvatarState.getValue(this.damage);
  }
  start();
}",0.9374061091637456
133935,"public Shockwave(Player player,boolean fall){
  super(player);
  this.angle=Math.toRadians(getConfig().getDouble(""String_Node_Str""));
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.threshold=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  if (bPlayer.isAvatarState()) {
    chargeTime=0;
    cooldown=0;
  }
  if (!bPlayer.canBend(this)) {
    return;
  }
  if (fall) {
    fallShockwave();
  }
  start();
}","public Shockwave(Player player,boolean fall){
  super(player);
  this.angle=Math.toRadians(getConfig().getDouble(""String_Node_Str""));
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.threshold=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  if (bPlayer.isAvatarState()) {
    chargeTime=0;
    cooldown=0;
  }
  if (!bPlayer.canBend(this) || hasAbility(player,Shockwave.class)) {
    return;
  }
  if (fall) {
    fallShockwave();
  }
  start();
}",0.8693284936479129
133936,"public FireBlastCharged(Player player){
  super(player);
  this.charged=false;
  this.launched=false;
  this.canDamageBlocks=getConfig().getBoolean(""String_Node_Str"");
  this.dissipate=getConfig().getBoolean(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.time=System.currentTimeMillis();
  this.interval=25;
  this.collisionRadius=getConfig().getDouble(""String_Node_Str"");
  this.maxDamage=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.damageRadius=getConfig().getDouble(""String_Node_Str"");
  this.explosionRadius=getConfig().getDouble(""String_Node_Str"");
  this.fireTicks=getConfig().getDouble(""String_Node_Str"");
  this.innerRadius=damageRadius / 2;
  if (isDay(player.getWorld())) {
    this.chargeTime=(long)(chargeTime / getDayFactor());
  }
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.maxDamage=AvatarState.getValue(maxDamage);
  }
  this.range=getDayFactor(range);
  if (!player.getEyeLocation().getBlock().isLiquid()) {
    start();
  }
}","public FireBlastCharged(Player player){
  super(player);
  if (!bPlayer.canBend(this) || hasAbility(player,FireBlastCharged.class)) {
    return;
  }
  this.charged=false;
  this.launched=false;
  this.canDamageBlocks=getConfig().getBoolean(""String_Node_Str"");
  this.dissipate=getConfig().getBoolean(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.time=System.currentTimeMillis();
  this.interval=25;
  this.collisionRadius=getConfig().getDouble(""String_Node_Str"");
  this.maxDamage=getConfig().getDouble(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.damageRadius=getConfig().getDouble(""String_Node_Str"");
  this.explosionRadius=getConfig().getDouble(""String_Node_Str"");
  this.fireTicks=getConfig().getDouble(""String_Node_Str"");
  this.innerRadius=damageRadius / 2;
  if (isDay(player.getWorld())) {
    this.chargeTime=(long)(chargeTime / getDayFactor());
  }
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.maxDamage=AvatarState.getValue(maxDamage);
  }
  this.range=getDayFactor(range);
  if (!player.getEyeLocation().getBlock().isLiquid()) {
    start();
  }
}",0.9580892293826048
133937,"public Lightning(Player player){
  super(player);
  this.charged=false;
  this.hitWater=false;
  this.hitIce=false;
  this.time=System.currentTimeMillis();
  this.state=State.START;
  this.affectedEntities=new ArrayList<>();
  this.arcs=new ArrayList<>();
  this.tasks=new ArrayList<>();
  this.selfHitWater=getConfig().getBoolean(""String_Node_Str"");
  this.selfHitClose=getConfig().getBoolean(""String_Node_Str"");
  this.arcOnIce=getConfig().getBoolean(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.maxArcAngle=getConfig().getDouble(""String_Node_Str"");
  this.subArcChance=getConfig().getDouble(""String_Node_Str"");
  this.chainRange=getConfig().getDouble(""String_Node_Str"");
  this.chainArcChance=getConfig().getDouble(""String_Node_Str"");
  this.waterArcRange=getConfig().getDouble(""String_Node_Str"");
  this.stunChance=getConfig().getDouble(""String_Node_Str"");
  this.stunDuration=getConfig().getDouble(""String_Node_Str"");
  this.maxChainArcs=getConfig().getInt(""String_Node_Str"");
  this.waterArcs=getConfig().getInt(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.range=getDayFactor(this.range);
  this.subArcChance=getDayFactor(this.subArcChance);
  this.damage=getDayFactor(this.damage);
  this.maxChainArcs=getDayFactor(this.maxChainArcs);
  this.chainArcChance=getDayFactor(this.chainArcChance);
  this.chainRange=getDayFactor(this.chainRange);
  this.waterArcRange=getDayFactor(this.waterArcRange);
  this.stunChance=getDayFactor(this.stunChance);
  this.stunDuration=getDayFactor(this.stunDuration);
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.cooldown=0;
    this.damage=AvatarState.getValue(damage);
    this.maxChainArcs=AvatarState.getValue(maxChainArcs);
    this.chainArcChance=AvatarState.getValue(chainArcChance);
    this.chainRange=AvatarState.getValue(chainRange);
    this.stunChance=AvatarState.getValue(stunChance);
  }
 else   if (isSozinsComet(player.getWorld())) {
    this.chargeTime=0;
    this.cooldown=0;
  }
  start();
}","public Lightning(Player player){
  super(player);
  if (!bPlayer.canBend(this)) {
    return;
  }
  if (hasAbility(player,Lightning.class)) {
    if (!getAbility(player,Lightning.class).isCharged()) {
      return;
    }
  }
  this.charged=false;
  this.hitWater=false;
  this.hitIce=false;
  this.time=System.currentTimeMillis();
  this.state=State.START;
  this.affectedEntities=new ArrayList<>();
  this.arcs=new ArrayList<>();
  this.tasks=new ArrayList<>();
  this.selfHitWater=getConfig().getBoolean(""String_Node_Str"");
  this.selfHitClose=getConfig().getBoolean(""String_Node_Str"");
  this.arcOnIce=getConfig().getBoolean(""String_Node_Str"");
  this.range=getConfig().getDouble(""String_Node_Str"");
  this.damage=getConfig().getDouble(""String_Node_Str"");
  this.maxArcAngle=getConfig().getDouble(""String_Node_Str"");
  this.subArcChance=getConfig().getDouble(""String_Node_Str"");
  this.chainRange=getConfig().getDouble(""String_Node_Str"");
  this.chainArcChance=getConfig().getDouble(""String_Node_Str"");
  this.waterArcRange=getConfig().getDouble(""String_Node_Str"");
  this.stunChance=getConfig().getDouble(""String_Node_Str"");
  this.stunDuration=getConfig().getDouble(""String_Node_Str"");
  this.maxChainArcs=getConfig().getInt(""String_Node_Str"");
  this.waterArcs=getConfig().getInt(""String_Node_Str"");
  this.chargeTime=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.range=getDayFactor(this.range);
  this.subArcChance=getDayFactor(this.subArcChance);
  this.damage=getDayFactor(this.damage);
  this.maxChainArcs=getDayFactor(this.maxChainArcs);
  this.chainArcChance=getDayFactor(this.chainArcChance);
  this.chainRange=getDayFactor(this.chainRange);
  this.waterArcRange=getDayFactor(this.waterArcRange);
  this.stunChance=getDayFactor(this.stunChance);
  this.stunDuration=getDayFactor(this.stunDuration);
  if (bPlayer.isAvatarState()) {
    this.chargeTime=0;
    this.cooldown=0;
    this.damage=AvatarState.getValue(damage);
    this.maxChainArcs=AvatarState.getValue(maxChainArcs);
    this.chainArcChance=AvatarState.getValue(chainArcChance);
    this.chainRange=AvatarState.getValue(chainRange);
    this.stunChance=AvatarState.getValue(stunChance);
  }
 else   if (isSozinsComet(player.getWorld())) {
    this.chargeTime=0;
    this.cooldown=0;
  }
  start();
}",0.9610158164401872
133938,"@SuppressWarnings(""String_Node_Str"") public static boolean softenLanding(Player player){
  Block block=player.getLocation().getBlock().getRelative(BlockFace.DOWN);
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return false;
  }
 else   if (bPlayer.canMetalbend() && ElementalAbility.isMetalBlock(block)) {
    return true;
  }
  if (EarthAbility.isEarthbendable(player,block) || ElementalAbility.isTransparent(player,block)) {
    if (!ElementalAbility.isTransparent(player,block)) {
      MaterialData type=block.getState().getData();
      if (GeneralMethods.isSolid(block.getRelative(BlockFace.DOWN))) {
        if (type.getItemType() == Material.RED_SANDSTONE) {
          byte data=(byte)0x1;
          block.setType(Material.SAND);
          block.setData(data);
        }
 else {
          block.setType(Material.SAND);
        }
        if (!SAND_BLOCKS.containsKey(block)) {
          SAND_ID_ENTITIES.put(block,type);
          SAND_BLOCKS.put(block,System.currentTimeMillis());
        }
      }
    }
    for (    Block affectedBlock : GeneralMethods.getBlocksAroundPoint(block.getLocation(),2)) {
      if (EarthAbility.isEarthbendable(player,affectedBlock)) {
        if (GeneralMethods.isSolid(affectedBlock.getRelative(BlockFace.DOWN))) {
          MaterialData type=affectedBlock.getState().getData();
          if (type.getItemType() == Material.RED_SANDSTONE) {
            byte data=(byte)0x1;
            affectedBlock.setType(Material.SAND);
            affectedBlock.setData(data);
          }
 else {
            affectedBlock.setType(Material.SAND);
          }
          if (!SAND_BLOCKS.containsKey(affectedBlock)) {
            SAND_ID_ENTITIES.putIfAbsent(affectedBlock,type);
            SAND_BLOCKS.put(affectedBlock,System.currentTimeMillis());
          }
        }
      }
    }
    return true;
  }
  return EarthAbility.isEarthbendable(player,block) || EarthAbility.isTransparent(player,block);
}","@SuppressWarnings(""String_Node_Str"") public static boolean softenLanding(Player player){
  Block block=player.getLocation().getBlock().getRelative(BlockFace.DOWN);
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  if (bPlayer == null) {
    return false;
  }
 else   if (bPlayer.canMetalbend() && ElementalAbility.isMetalBlock(block)) {
    return true;
  }
  if (EarthAbility.isEarthbendable(player,block) || ElementalAbility.isTransparent(player,block)) {
    if (!ElementalAbility.isTransparent(player,block)) {
      MaterialData type=block.getState().getData();
      if (GeneralMethods.isSolid(block.getRelative(BlockFace.DOWN))) {
        if (type.getItemType() == Material.RED_SANDSTONE) {
          byte data=(byte)0x1;
          block.setType(Material.SAND);
          block.setData(data);
        }
 else {
          block.setType(Material.SAND);
        }
        if (!SAND_BLOCKS.containsKey(block)) {
          SAND_ID_ENTITIES.put(block,type);
          SAND_BLOCKS.put(block,System.currentTimeMillis());
        }
      }
    }
    for (    Block affectedBlock : GeneralMethods.getBlocksAroundPoint(block.getLocation(),2)) {
      if (EarthAbility.isEarthbendable(player,affectedBlock)) {
        if (GeneralMethods.isSolid(affectedBlock.getRelative(BlockFace.DOWN))) {
          MaterialData type=affectedBlock.getState().getData();
          if (type.getItemType() == Material.RED_SANDSTONE) {
            byte data=(byte)0x1;
            affectedBlock.setType(Material.SAND);
            affectedBlock.setData(data);
          }
 else {
            affectedBlock.setType(Material.SAND);
          }
          if (!SAND_BLOCKS.containsKey(affectedBlock)) {
            SAND_ID_ENTITIES.putIfAbsent(affectedBlock,type);
            SAND_BLOCKS.put(affectedBlock,System.currentTimeMillis());
          }
        }
      }
    }
    return true;
  }
  return (TempBlock.isTempBlock(block) && EarthAbility.isEarthbendable(TempBlock.get(block).getBlock().getType())) || EarthAbility.isEarthbendable(player,block) || EarthAbility.isTransparent(player,block);
}",0.9672977624784854
133939,"/** 
 * Redraws the blocks for this instance of EarthSmash.
 */
public void draw(){
  if (currentBlocks.size() == 0) {
    remove();
    return;
  }
  for (  BlockRepresenter blockRep : currentBlocks) {
    Block block=location.clone().add(blockRep.getX(),blockRep.getY(),blockRep.getZ()).getBlock();
    if (player != null && isTransparent(block)) {
      affectedBlocks.add(new TempBlock(block,blockRep.getType(),blockRep.getData()));
      getPreventEarthbendingBlocks().add(block);
    }
  }
}","/** 
 * Redraws the blocks for this instance of EarthSmash.
 */
public void draw(){
  if (currentBlocks.size() == 0) {
    remove();
    return;
  }
  for (  BlockRepresenter blockRep : currentBlocks) {
    Block block=location.clone().add(blockRep.getX(),blockRep.getY(),blockRep.getZ()).getBlock();
    if (block.getType().equals(Material.SAND) || block.getType().equals(Material.GRAVEL)) {
      addTempAirBlock(block);
    }
    if (player != null && isTransparent(block)) {
      affectedBlocks.add(new TempBlock(block,blockRep.getType(),blockRep.getData()));
      getPreventEarthbendingBlocks().add(block);
    }
  }
}",0.8859180035650623
133940,"@SuppressWarnings(""String_Node_Str"") public SurgeWall(Player player){
  super(player);
  this.interval=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.range=getConfig().getDouble(RANGE_CONFIG);
  this.radius=getConfig().getDouble(""String_Node_Str"");
  SurgeWave wave=getAbility(player,SurgeWave.class);
  if (wave != null && !wave.isProgressing()) {
    wave.moveWater();
    return;
  }
  if (bPlayer.isAvatarState()) {
    radius=AvatarState.getValue(radius);
  }
  SurgeWall wall=getAbility(player,SurgeWall.class);
  if (wall != null) {
    if (wall.progressing) {
      freezeThaw();
    }
 else     if (prepare()) {
      wall.remove();
      start();
      time=System.currentTimeMillis();
    }
  }
 else   if (prepare()) {
    start();
    time=System.currentTimeMillis();
  }
  if (bPlayer.isOnCooldown(""String_Node_Str"")) {
    return;
  }
 else   if (wall == null && WaterReturn.hasWaterBottle(player)) {
    Location eyeLoc=player.getEyeLocation();
    Block block=eyeLoc.add(eyeLoc.getDirection().normalize()).getBlock();
    if (isTransparent(player,block) && isTransparent(player,eyeLoc.getBlock())) {
      block.setType(Material.WATER);
      block.setData(FULL);
      wave=new SurgeWave(player);
      wave.setCanHitSelf(false);
      wave.moveWater();
      if (!wave.isProgressing()) {
        block.setType(Material.AIR);
        wave.remove();
      }
 else {
        WaterReturn.emptyWaterBottle(player);
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public SurgeWall(Player player){
  super(player);
  this.interval=getConfig().getLong(""String_Node_Str"");
  this.cooldown=getConfig().getLong(""String_Node_Str"");
  this.range=getConfig().getDouble(RANGE_CONFIG);
  this.radius=getConfig().getDouble(""String_Node_Str"");
  SurgeWave wave=getAbility(player,SurgeWave.class);
  if (wave != null && !wave.isProgressing()) {
    wave.moveWater();
    return;
  }
  if (bPlayer.isAvatarState()) {
    radius=AvatarState.getValue(radius);
  }
  SurgeWall wall=getAbility(player,SurgeWall.class);
  if (wall != null) {
    if (wall.progressing) {
      wall.freezeThaw();
    }
 else     if (prepare()) {
      wall.remove();
      start();
      time=System.currentTimeMillis();
    }
  }
 else   if (prepare()) {
    start();
    time=System.currentTimeMillis();
  }
  if (bPlayer.isOnCooldown(""String_Node_Str"")) {
    return;
  }
 else   if (wall == null && WaterReturn.hasWaterBottle(player)) {
    Location eyeLoc=player.getEyeLocation();
    Block block=eyeLoc.add(eyeLoc.getDirection().normalize()).getBlock();
    if (isTransparent(player,block) && isTransparent(player,eyeLoc.getBlock())) {
      block.setType(Material.WATER);
      block.setData(FULL);
      wave=new SurgeWave(player);
      wave.setCanHitSelf(false);
      wave.moveWater();
      if (!wave.isProgressing()) {
        block.setType(Material.AIR);
        wave.remove();
      }
 else {
        WaterReturn.emptyWaterBottle(player);
      }
    }
  }
}",0.9983405243942914
133941,"private void getNightAugments(){
  World world=player.getWorld();
  if (isNight(world)) {
    if (GeneralMethods.hasRPG()) {
      if (isLunarEclipse(world)) {
        spearRange=spearRangeFullMoon;
        spearSphere=spearSphereFullMoon;
        spearDuration=spearDurationFullMoon;
      }
 else       if (BendingManager.events.get(world).equalsIgnoreCase(""String_Node_Str"")) {
        spearRange=spearRangeFullMoon;
        spearSphere=spearSphereFullMoon;
        spearDuration=spearDurationFullMoon;
      }
 else {
        spearRange=spearRangeNight;
        spearSphere=spearSphereNight;
        spearDuration=spearDurationNight;
      }
    }
 else {
      if (isFullMoon(world)) {
        spearRange=spearRangeFullMoon;
        spearSphere=spearSphereFullMoon;
        spearDuration=spearDurationFullMoon;
      }
 else {
        spearRange=spearRangeNight;
        spearSphere=spearSphereNight;
        spearDuration=spearDurationNight;
      }
    }
  }
}","private void getNightAugments(){
  World world=player.getWorld();
  if (isNight(world)) {
    if (GeneralMethods.hasRPG()) {
      if (isLunarEclipse(world)) {
        spearRange=spearRangeFullMoon;
        spearSphere=spearSphereFullMoon;
        spearDuration=spearDurationFullMoon;
      }
 else       if (isFullMoon(world)) {
        spearRange=spearRangeFullMoon;
        spearSphere=spearSphereFullMoon;
        spearDuration=spearDurationFullMoon;
      }
 else {
        spearRange=spearRangeNight;
        spearSphere=spearSphereNight;
        spearDuration=spearDurationNight;
      }
    }
 else {
      if (isFullMoon(world)) {
        spearRange=spearRangeFullMoon;
        spearSphere=spearSphereFullMoon;
        spearDuration=spearDurationFullMoon;
      }
 else {
        spearRange=spearRangeNight;
        spearSphere=spearSphereNight;
        spearDuration=spearDurationNight;
      }
    }
  }
}",0.4131704726500265
133942,"private void getAugments(){
  if (ability.equals(Whip.PUNCH)) {
    whipLength=punchLength;
  }
  World world=player.getWorld();
  if (isNight(world)) {
    if (GeneralMethods.hasRPG()) {
      if (isLunarEclipse(world)) {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthFullMoon;
        }
 else {
          whipLength=whipLengthFullMoon;
        }
      }
 else       if (BendingManager.events.get(world).equalsIgnoreCase(""String_Node_Str"")) {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthFullMoon;
        }
 else {
          whipLength=whipLengthFullMoon;
        }
      }
 else {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthNight;
        }
 else {
          whipLength=whipLengthNight;
        }
      }
    }
 else {
      if (isFullMoon(world)) {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthFullMoon;
        }
 else {
          whipLength=whipLengthFullMoon;
        }
      }
 else {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthNight;
        }
 else {
          whipLength=whipLengthNight;
        }
      }
    }
  }
}","private void getAugments(){
  if (ability.equals(Whip.PUNCH)) {
    whipLength=punchLength;
  }
  World world=player.getWorld();
  if (isNight(world)) {
    if (GeneralMethods.hasRPG()) {
      if (isLunarEclipse(world)) {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthFullMoon;
        }
 else {
          whipLength=whipLengthFullMoon;
        }
      }
 else       if (isFullMoon(world)) {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthFullMoon;
        }
 else {
          whipLength=whipLengthFullMoon;
        }
      }
 else {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthNight;
        }
 else {
          whipLength=whipLengthNight;
        }
      }
    }
 else {
      if (isFullMoon(world)) {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthFullMoon;
        }
 else {
          whipLength=whipLengthFullMoon;
        }
      }
 else {
        if (ability.equals(Whip.PUNCH)) {
          whipLength=punchLengthNight;
        }
 else {
          whipLength=whipLengthNight;
        }
      }
    }
  }
}",0.9647979139504564
133943,"public WaterReturn(Player player,Block block){
  super(player);
  if (hasAbility(player,WaterReturn.class)) {
    return;
  }
  this.location=block.getLocation();
  this.range=30;
  this.interval=50;
  this.range=getNightFactor(range);
  if (bPlayer.canBend(this)) {
    if (isTransparent(player,block) && !block.isLiquid() && hasEmptyWaterBottle()) {
      this.block=new TempBlock(block,Material.WATER,(byte)0);
    }
  }
  start();
}","public WaterReturn(Player player,Block block){
  super(player);
  if (hasAbility(player,WaterReturn.class)) {
    return;
  }
  this.location=block.getLocation();
  this.range=30;
  this.interval=50;
  this.range=getNightFactor(range);
  if (bPlayer.canBendIgnoreBindsCooldowns(this)) {
    if (isTransparent(player,block) && ((TempBlock.isTempBlock(block) && block.isLiquid()) || !block.isLiquid()) && hasEmptyWaterBottle()) {
      this.block=new TempBlock(block,Material.WATER,(byte)0);
    }
  }
  start();
}",0.919831223628692
133944,"public boolean canBind(CoreAbility ability){
  if (ability == null || !player.isOnline()) {
    return false;
  }
 else   if (!player.hasPermission(""String_Node_Str"" + ability.getName())) {
    return false;
  }
 else   if (!hasElement(ability.getElement())) {
    return false;
  }
 else   if (ability instanceof SubAbility) {
    SubAbility subAbil=(SubAbility)ability;
    if (!hasElement(subAbil.getParentElement())) {
      return false;
    }
  }
  return true;
}","public boolean canBind(CoreAbility ability){
  if (ability == null || !player.isOnline()) {
    return false;
  }
 else   if (!player.hasPermission(""String_Node_Str"" + ability.getName())) {
    return false;
  }
 else   if (!hasElement(ability.getElement())) {
    return false;
  }
 else   if (ability.getElement() instanceof SubElement) {
    SubElement subElement=(SubElement)ability.getElement();
    if (!hasElement(subElement.getParentElement())) {
      return false;
    }
  }
  return true;
}",0.8824742268041237
133945,"private boolean canBend(CoreAbility ability,boolean ignoreBinds,boolean ignoreCooldowns){
  if (ability == null || ability.getPlayer() == null) {
    return false;
  }
  List<String> disabledWorlds=getConfig().getStringList(""String_Node_Str"");
  Location playerLoc=player.getLocation();
  if (!player.isOnline() || player.isDead()) {
    return false;
  }
 else   if (ability.getLocation() != null && !ability.getLocation().getWorld().equals(player.getWorld())) {
    return false;
  }
 else   if (!ignoreCooldowns && isOnCooldown(ability.getName())) {
    return false;
  }
 else   if (!ignoreBinds && !ability.getName().equals(getBoundAbilityName())) {
    return false;
  }
 else   if (disabledWorlds != null && disabledWorlds.contains(player.getWorld().getName())) {
    return false;
  }
 else   if (Commands.isToggledForAll || !isToggled() || !isElementToggled(ability.getElement())) {
    return false;
  }
 else   if (player.getGameMode() == GameMode.SPECTATOR) {
    return false;
  }
  if (!ignoreCooldowns && cooldowns.containsKey(name)) {
    if (cooldowns.get(name) + getConfig().getLong(""String_Node_Str"") >= System.currentTimeMillis()) {
      return false;
    }
    cooldowns.remove(name);
  }
  if (isChiBlocked() || isParalyzed() || isBloodbended()|| isControlledByMetalClips()) {
    return false;
  }
 else   if (GeneralMethods.isRegionProtectedFromBuild(player,ability.getName(),playerLoc)) {
    return false;
  }
 else   if (ability instanceof FireAbility && BendingManager.events.get(player.getWorld()) != null && BendingManager.events.get(player.getWorld()).equalsIgnoreCase(""String_Node_Str"")) {
    return false;
  }
 else   if (ability instanceof WaterAbility && BendingManager.events.get(player.getWorld()) != null && BendingManager.events.get(player.getWorld()).equalsIgnoreCase(""String_Node_Str"")) {
    return false;
  }
  if (!ignoreBinds && !canBind(ability)) {
    return false;
  }
  return true;
}","private boolean canBend(CoreAbility ability,boolean ignoreBinds,boolean ignoreCooldowns){
  if (ability == null) {
    return false;
  }
  List<String> disabledWorlds=getConfig().getStringList(""String_Node_Str"");
  Location playerLoc=player.getLocation();
  if (!player.isOnline() || player.isDead()) {
    return false;
  }
 else   if (ability.getPlayer() != null && ability.getLocation() != null && !ability.getLocation().getWorld().equals(player.getWorld())) {
    return false;
  }
 else   if (!ignoreCooldowns && isOnCooldown(ability.getName())) {
    return false;
  }
 else   if (!ignoreBinds && !ability.getName().equals(getBoundAbilityName())) {
    return false;
  }
 else   if (disabledWorlds != null && disabledWorlds.contains(player.getWorld().getName())) {
    return false;
  }
 else   if (Commands.isToggledForAll || !isToggled() || !isElementToggled(ability.getElement())) {
    return false;
  }
 else   if (player.getGameMode() == GameMode.SPECTATOR) {
    return false;
  }
  if (!ignoreCooldowns && cooldowns.containsKey(name)) {
    if (cooldowns.get(name) + getConfig().getLong(""String_Node_Str"") >= System.currentTimeMillis()) {
      return false;
    }
    cooldowns.remove(name);
  }
  if (isChiBlocked() || isParalyzed() || isBloodbended()|| isControlledByMetalClips()) {
    return false;
  }
 else   if (GeneralMethods.isRegionProtectedFromBuild(player,ability.getName(),playerLoc)) {
    return false;
  }
 else   if (ability instanceof FireAbility && FireAbility.isSolarEclipse(player.getWorld())) {
    return false;
  }
 else   if (ability instanceof WaterAbility && WaterAbility.isLunarEclipse(player.getWorld())) {
    return false;
  }
  if (!ignoreBinds && !canBind(ability)) {
    return false;
  }
  return true;
}",0.7113038763892654
133946,public boolean isSneakAbility();,"/** 
 * Determines if this ability uses the   {@link PlayerToggleSneakEvent} as a controllingmechanism. Currently  {@link WaterPassive} will not work while the player has a sneak abilitybound.
 * @return true if the ability uses sneak as a controlling mechanism
 */
public boolean isSneakAbility();",0.1939393939393939
133947,"/** 
 * Determines if this ability is considered harmless against other players. A harmless ability cannot manipulate another player. For example: AirPassive, WaterSpout, AirSpout, and FireJet.
 * @return true if the ability is harmless and should be allowed in both PvP and non-PvP zones.
 */
public boolean isHarmlessAbility();","/** 
 * Determines if this ability is considered harmless against other players. A harmless ability cannot manipulate another player. For example: AirPassive, WaterSpout, AirSpout, and FireJet.
 * @return true if the ability is harmless and should be allowed in both PvP and non-PvP zones
 */
public boolean isHarmlessAbility();",0.9984779299847792
133948,public Player getPlayer();,"/** 
 * Returns the player that caused this ability to be initiated. The player can be null in certain circumstances, for example when calling   {@link CoreAbility#getAbility(String)}, or if an ability decided to set player to null.
 * @return the player that this ability belongs to
 */
public Player getPlayer();",0.1529411764705882
133949,public Location getLocation();,"/** 
 * Specifies the Location of the ability, which may be slightly inaccurate depending on the Ability implementation. For example, a   {@link TorrentWave} could not be fully specified by asingle location, while it is possible for an  {@link EarthBlast}. The location is useful for making sure that the player is currently in the same world as the ability.
 * @return the location of the Ability
 * @see BendingPlayer#canBend(CoreAbility)
 */
public Location getLocation();",0.1188118811881188
133950,public boolean isExplosiveAbility();,"/** 
 * Determines if this ability can cause explosions. For example:   {@link FireBlastCharged}
 */
public boolean isExplosiveAbility();",0.4161849710982659
133951,public String getName();,"/** 
 * The name of the ability is used for commands such as <b>/bending display</b> and <b>/bending help</b>. The name is also used for determining the tag for cooldowns  {@link BendingPlayer#addCooldown(Ability)}, therefore if two abilities have the same name they will also share cooldowns. If two classes share the same name (SurgeWall/SurgeWave) but need to have independent cooldowns, then   {@link BendingPlayer#addCooldown(String,long)}should be called explicitly.
 * @return Returns the name of the ability
 */
public String getName();",0.0845070422535211
133952,public boolean isIgniteAbility();,"/** 
 * Determines if this ability can ignite blocks. For example:   {@link Blaze},   {@link FireBlast}, and   {@link FireBurst}.
 */
public boolean isIgniteAbility();",0.33
133953,public long getCooldown();,"/** 
 * @return the cooldown for the ability
 */
public long getCooldown();",0.5148514851485149
133954,public String getDescription();,"/** 
 * The description of an ability is a few sentences used to describe how the player can fully utilize the ability. In most cases the description will be specified in the config.yml file and will be retrieved by accessing the FileConfiguration via   {@link CoreAbility#getConfig}.
 * @return the description for this ability
 * @see HelpCommand
 * @see CoreAbility#getDescription()
 */
public String getDescription();",0.1371681415929203
133955,public void remove();,"/** 
 * Causes the ability to be removed from existence.
 */
public void remove();",0.4077669902912621
133956,public Element getElement();,"/** 
 * Specifies the Element used to represent this type of ability, favoring SubElements over Elements. For example, a LightningAbility would return   {@link Element#LIGHTNING} instead of{@link Element#FIRE}.
 * @return the most accurate Element that this ability belongs to
 * @see SubElement#getParentElement
 */
public Element getElement();",0.1501340482573726
133957,public void progress();,"/** 
 * Causes the ability to be updated.
 */
public void progress();",0.5
133958,public boolean isHiddenAbility();,"/** 
 * A hidden ability is an ability that should not be shown by commands such as <b>/bending display</b> and <b>/bending help</b>. For example: Combos, MultiAbility sub abilities, and helper abilities.
 * @return true if the ability should not be displayed to the players
 */
public boolean isHiddenAbility();",0.1913043478260869
133959,"/** 
 * Accessor Method to get the version of the ability.
 * @return The version of the ability as a String.
 */
public String getVersion();","/** 
 * @return The version of the ability as a String.
 */
public String getVersion();",0.7631578947368421
133960,"/** 
 * Void Method called whenever ProjectKorra stops and the ability is unloaded.
 */
public void stop();","/** 
 * Called whenever ProjectKorra stops and the ability is unloaded. This method is useful for cleaning up leftover objects such as frozen blocks. Any CoreAbility instances do not need to be cleaned up by stop method, as they will be cleaned up by   {@link CoreAbility#removeAll()}.
 */
public void stop();",0.4519230769230769
133961,public String getAuthor();,"/** 
 * @return the name of the author of this AddonAbility
 */
public String getAuthor();",0.4482758620689655
133962,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerChat(AsyncPlayerChatEvent event){
  if (event.isCancelled()) {
    return;
  }
 else   if (!plugin.getConfig().getBoolean(""String_Node_Str"")) {
    return;
  }
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  ChatColor color=ChatColor.WHITE;
  if (bPlayer == null) {
    return;
  }
  if (player.hasPermission(""String_Node_Str"") || bPlayer.getElements().size() > 1) {
    color=ChatColor.valueOf(plugin.getConfig().getString(""String_Node_Str""));
  }
 else {
    for (    Element element : Element.getMainElements()) {
      if (bPlayer.hasElement(element)) {
        color=ChatColor.valueOf(plugin.getConfig().getString(""String_Node_Str"" + element));
        break;
      }
    }
  }
  String format=plugin.getConfig().getString(""String_Node_Str"");
  format=format.replace(""String_Node_Str"",""String_Node_Str"");
  format=format.replace(""String_Node_Str"",color + player.getDisplayName() + ChatColor.RESET);
  event.setFormat(format);
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onPlayerChat(AsyncPlayerChatEvent event){
  if (event.isCancelled()) {
    return;
  }
 else   if (!plugin.getConfig().getBoolean(""String_Node_Str"")) {
    return;
  }
  Player player=event.getPlayer();
  BendingPlayer bPlayer=BendingPlayer.getBendingPlayer(player);
  ChatColor color=ChatColor.WHITE;
  if (bPlayer == null) {
    return;
  }
  if (player.hasPermission(""String_Node_Str"") || bPlayer.getElements().size() > 1) {
    color=ChatColor.valueOf(plugin.getConfig().getString(""String_Node_Str""));
  }
 else {
    for (    Element element : Element.getMainElements()) {
      if (bPlayer.hasElement(element)) {
        color=element.getColor();
        break;
      }
    }
  }
  String format=plugin.getConfig().getString(""String_Node_Str"");
  format=format.replace(""String_Node_Str"",""String_Node_Str"");
  format=format.replace(""String_Node_Str"",color + player.getDisplayName() + ChatColor.RESET);
  event.setFormat(format);
}",0.9558541266794626
133963,"/** 
 * Scans all of the Jar files inside of /ProjectKorra/folder and registers all of the CoreAbility class files that were found.
 * @param folder the name of the folder to scan
 * @see #getAbilities()
 * @see #getAbility(String)
 */
public static void registerAddonAbilities(String folder){
  ProjectKorra plugin=ProjectKorra.plugin;
  File path=new File(plugin.getDataFolder().toString() + folder);
  if (!path.exists()) {
    return;
  }
  AbilityLoader<CoreAbility> abilityLoader=new AbilityLoader<CoreAbility>(plugin,path);
  List<CoreAbility> loadedAbilities=abilityLoader.load(CoreAbility.class,CoreAbility.class);
  for (  CoreAbility coreAbil : loadedAbilities) {
    if (!(coreAbil instanceof AddonAbility)) {
      plugin.getLogger().warning(coreAbil.getName() + ""String_Node_Str"");
      continue;
    }
 else     if (!coreAbil.isEnabled()) {
      plugin.getLogger().info(coreAbil.getName() + ""String_Node_Str"");
      continue;
    }
    AddonAbility addon=(AddonAbility)coreAbil;
    String name=coreAbil.getName();
    try {
      addon.load();
      ABILITIES_BY_NAME.put(name.toLowerCase(),coreAbil);
      if (coreAbil instanceof ComboAbility) {
        ComboAbility combo=(ComboAbility)coreAbil;
        if (combo.getCombination() != null) {
          ComboManager.getComboAbilities().put(name,new ComboManager.ComboAbilityInfo(name,combo.getCombination(),combo));
          ComboManager.getDescriptions().put(name,coreAbil.getDescription());
          ComboManager.getInstructions().put(name,combo.getInstructions());
          ComboManager.getAuthors().put(name,addon.getAuthor());
        }
      }
      if (coreAbil instanceof MultiAbility) {
        MultiAbility multiAbil=(MultiAbility)coreAbil;
        MultiAbilityManager.multiAbilityList.add(new MultiAbilityInfo(name,multiAbil.getMultiAbilities()));
      }
    }
 catch (    Exception|Error e) {
      plugin.getLogger().warning(""String_Node_Str"" + coreAbil.getName() + ""String_Node_Str"");
      e.printStackTrace();
      addon.stop();
      ABILITIES_BY_NAME.remove(coreAbil.getName(),coreAbil);
    }
  }
}","/** 
 * Scans all of the Jar files inside of /ProjectKorra/folder and registers all of the CoreAbility class files that were found.
 * @param folder the name of the folder to scan
 * @see #getAbilities()
 * @see #getAbility(String)
 */
public static void registerAddonAbilities(String folder){
  ProjectKorra plugin=ProjectKorra.plugin;
  File path=new File(plugin.getDataFolder().toString() + folder);
  if (!path.exists()) {
    path.mkdir();
    return;
  }
  AbilityLoader<CoreAbility> abilityLoader=new AbilityLoader<CoreAbility>(plugin,path);
  List<CoreAbility> loadedAbilities=abilityLoader.load(CoreAbility.class,CoreAbility.class);
  for (  CoreAbility coreAbil : loadedAbilities) {
    if (!(coreAbil instanceof AddonAbility)) {
      plugin.getLogger().warning(coreAbil.getName() + ""String_Node_Str"");
      continue;
    }
 else     if (!coreAbil.isEnabled()) {
      plugin.getLogger().info(coreAbil.getName() + ""String_Node_Str"");
      continue;
    }
    AddonAbility addon=(AddonAbility)coreAbil;
    String name=coreAbil.getName();
    try {
      addon.load();
      ABILITIES_BY_NAME.put(name.toLowerCase(),coreAbil);
      if (coreAbil instanceof ComboAbility) {
        ComboAbility combo=(ComboAbility)coreAbil;
        if (combo.getCombination() != null) {
          ComboManager.getComboAbilities().put(name,new ComboManager.ComboAbilityInfo(name,combo.getCombination(),combo));
          ComboManager.getDescriptions().put(name,coreAbil.getDescription());
          ComboManager.getInstructions().put(name,combo.getInstructions());
          ComboManager.getAuthors().put(name,addon.getAuthor());
        }
      }
      if (coreAbil instanceof MultiAbility) {
        MultiAbility multiAbil=(MultiAbility)coreAbil;
        MultiAbilityManager.multiAbilityList.add(new MultiAbilityInfo(name,multiAbil.getMultiAbilities()));
      }
    }
 catch (    Exception|Error e) {
      plugin.getLogger().warning(""String_Node_Str"" + coreAbil.getName() + ""String_Node_Str"");
      e.printStackTrace();
      addon.stop();
      ABILITIES_BY_NAME.remove(coreAbil.getName(),coreAbil);
    }
  }
}",0.9957183634633682
133964,"/** 
 * Removes every CoreAbility instance that has been started but not yet removed.
 */
public static void removeAll(){
  for (  Set<CoreAbility> setAbils : INSTANCES_BY_CLASS.values()) {
    for (    CoreAbility abil : setAbils) {
      abil.remove();
    }
  }
}","/** 
 * Removes every CoreAbility instance that has been started but not yet removed.
 */
public static void removeAll(){
  for (  Set<CoreAbility> setAbils : INSTANCES_BY_CLASS.values()) {
    for (    CoreAbility abil : setAbils) {
      abil.remove();
    }
  }
  for (  CoreAbility coreAbility : ABILITIES_BY_NAME.values()) {
    if (coreAbility instanceof AddonAbility) {
      AddonAbility addon=(AddonAbility)coreAbility;
      addon.stop();
    }
  }
}",0.7327823691460055
133965,"/** 
 * Scans a JavaPlugin and registers CoreAbility class files.
 * @param plugin a JavaPlugin containing CoreAbility class files
 * @param packagePrefix a prefix of the package name, used to increase performance
 * @see #getAbilities()
 * @see #getAbility(String)
 */
public static void registerPluginAbilities(JavaPlugin plugin,String packagePrefix){
  if (plugin == null) {
    return;
  }
  Class<?> pluginClass=plugin.getClass();
  ClassLoader loader=pluginClass.getClassLoader();
  ReflectionFactory rf=ReflectionFactory.getReflectionFactory();
  try {
    for (    final ClassInfo info : ClassPath.from(loader).getAllClasses()) {
      if (!info.getPackageName().startsWith(packagePrefix)) {
        continue;
      }
      Class<?> clazz=null;
      try {
        clazz=info.load();
        if (!CoreAbility.class.isAssignableFrom(clazz) || clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {
          continue;
        }
        Constructor<?> objDef=CoreAbility.class.getDeclaredConstructor();
        Constructor<?> intConstr=rf.newConstructorForSerialization(clazz,objDef);
        ;
        CoreAbility ability=(CoreAbility)clazz.cast(intConstr.newInstance());
        if (ability != null && ability.getName() != null && ability.isEnabled()) {
          ABILITIES_BY_NAME.put(ability.getName().toLowerCase(),ability);
        }
 else         if (!ability.isEnabled()) {
          plugin.getLogger().info(ability.getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
      }
catch (      Error e) {
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Scans a JavaPlugin and registers CoreAbility class files.
 * @param plugin a JavaPlugin containing CoreAbility class files
 * @param packagePrefix a prefix of the package name, used to increase performance
 * @see #getAbilities()
 * @see #getAbility(String)
 */
public static void registerPluginAbilities(JavaPlugin plugin,String packagePrefix){
  if (plugin == null) {
    return;
  }
  Class<?> pluginClass=plugin.getClass();
  ClassLoader loader=pluginClass.getClassLoader();
  ReflectionFactory rf=ReflectionFactory.getReflectionFactory();
  try {
    for (    final ClassInfo info : ClassPath.from(loader).getAllClasses()) {
      if (!info.getPackageName().startsWith(packagePrefix)) {
        continue;
      }
      Class<?> clazz=null;
      try {
        clazz=info.load();
        if (!CoreAbility.class.isAssignableFrom(clazz) || clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {
          continue;
        }
        Constructor<?> objDef=CoreAbility.class.getDeclaredConstructor();
        Constructor<?> intConstr=rf.newConstructorForSerialization(clazz,objDef);
        ;
        CoreAbility ability=(CoreAbility)clazz.cast(intConstr.newInstance());
        if (ability == null || ability.getName() == null) {
          continue;
        }
 else         if (!ability.isEnabled()) {
          plugin.getLogger().info(ability.getName() + ""String_Node_Str"");
          continue;
        }
        String name=ability.getName();
        ABILITIES_BY_NAME.put(ability.getName().toLowerCase(),ability);
        if (ability instanceof ComboAbility) {
          ComboAbility combo=(ComboAbility)ability;
          if (combo.getCombination() != null) {
            ComboManager.getComboAbilities().put(name,new ComboManager.ComboAbilityInfo(name,combo.getCombination(),combo));
            ComboManager.getDescriptions().put(name,ability.getDescription());
            ComboManager.getInstructions().put(name,combo.getInstructions());
            String author=""String_Node_Str"";
            if (ability instanceof AddonAbility) {
              author=((AddonAbility)ability).getAuthor();
            }
            ComboManager.getAuthors().put(name,author);
          }
        }
        if (ability instanceof MultiAbility) {
          MultiAbility multiAbil=(MultiAbility)ability;
          MultiAbilityManager.multiAbilityList.add(new MultiAbilityInfo(name,multiAbil.getMultiAbilities()));
        }
        if (ability instanceof AddonAbility) {
          AddonAbility addon=(AddonAbility)ability;
          addon.load();
        }
      }
 catch (      Exception e) {
      }
catch (      Error e) {
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.6912272622611099
133966,"/** 
 * @param classType
 * @param parentClass a parent of classType that has a visible default constructor
 * @return A list of all of the T objects that were loaded from the jar files within @param directory
 */
@SuppressWarnings(""String_Node_Str"") public List<T> load(Class<?> classType,Class<?> parentClass){
  ArrayList<T> loadables=new ArrayList<>();
  for (  File file : files) {
    JarFile jarFile=null;
    try {
      jarFile=new JarFile(file);
      Enumeration<JarEntry> entries=jarFile.entries();
      while (entries.hasMoreElements()) {
        JarEntry entry=entries.nextElement();
        if (!entry.getName().endsWith(""String_Node_Str"")) {
          continue;
        }
        String className=entry.getName().replace('/','.').substring(0,entry.getName().length() - 6);
        Class<?> clazz=null;
        try {
          clazz=Class.forName(className,true,loader);
        }
 catch (        Exception e) {
          continue;
        }
        if (!classType.isAssignableFrom(clazz) || clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {
          continue;
        }
        ReflectionFactory rf=ReflectionFactory.getReflectionFactory();
        Constructor<?> objDef=parentClass.getDeclaredConstructor();
        Constructor<?> intConstr=rf.newConstructorForSerialization(clazz,objDef);
        T loadable=(T)clazz.cast(intConstr.newInstance());
        loadables.add(loadable);
        AbilityLoadEvent<T> event=new AbilityLoadEvent<T>(plugin,loadable,jarFile);
        plugin.getServer().getPluginManager().callEvent(event);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      plugin.getLogger().log(Level.WARNING,""String_Node_Str"");
      plugin.getLogger().log(Level.WARNING,""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    }
 finally {
      if (jarFile != null) {
        try {
          jarFile.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return loadables;
}","/** 
 * @param classType
 * @param parentClass a parent of classType that has a visible default constructor
 * @return A list of all of the T objects that were loaded from the jar files within @param directory
 */
@SuppressWarnings(""String_Node_Str"") public List<T> load(Class<?> classType,Class<?> parentClass){
  ArrayList<T> loadables=new ArrayList<>();
  for (  File file : files) {
    JarFile jarFile=null;
    try {
      jarFile=new JarFile(file);
      Enumeration<JarEntry> entries=jarFile.entries();
      while (entries.hasMoreElements()) {
        JarEntry entry=entries.nextElement();
        if (!entry.getName().endsWith(""String_Node_Str"")) {
          continue;
        }
        String className=entry.getName().replace('/','.').substring(0,entry.getName().length() - 6);
        Class<?> clazz=null;
        try {
          clazz=Class.forName(className,true,loader);
        }
 catch (        Exception|Error e) {
          continue;
        }
        if (!classType.isAssignableFrom(clazz) || clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {
          continue;
        }
        ReflectionFactory rf=ReflectionFactory.getReflectionFactory();
        Constructor<?> objDef=parentClass.getDeclaredConstructor();
        Constructor<?> intConstr=rf.newConstructorForSerialization(clazz,objDef);
        T loadable=(T)clazz.cast(intConstr.newInstance());
        loadables.add(loadable);
        AbilityLoadEvent<T> event=new AbilityLoadEvent<T>(plugin,loadable,jarFile);
        plugin.getServer().getPluginManager().callEvent(event);
      }
    }
 catch (    Exception|Error e) {
      e.printStackTrace();
      plugin.getLogger().log(Level.WARNING,""String_Node_Str"");
      plugin.getLogger().log(Level.WARNING,""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    }
 finally {
      if (jarFile != null) {
        try {
          jarFile.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return loadables;
}",0.997020854021847
133967,"/** 
 * Gets all of the combos for a given element.
 * @param element The element to get combos for
 * @return An ArrayList of the combos for that element
 */
public static ArrayList<String> getCombosForElement(Element element){
  ArrayList<String> list=new ArrayList<String>();
  for (  String comboab : DESCRIPTIONS.keySet()) {
    CoreAbility coreAbil=CoreAbility.getAbility(COMBO_ABILITIES.get(comboab).getAbilities().get(0).getAbilityName());
    if (coreAbil != null && coreAbil.getElement() == element) {
      list.add(comboab);
    }
  }
  Collections.sort(list);
  return list;
}","/** 
 * Gets all of the combos for a given element.
 * @param element The element to get combos for
 * @return An ArrayList of the combos for that element
 */
public static ArrayList<String> getCombosForElement(Element element){
  ArrayList<String> list=new ArrayList<String>();
  for (  String comboab : COMBO_ABILITIES.keySet()) {
    CoreAbility coreAbil=CoreAbility.getAbility(comboab);
    if (coreAbil == null) {
      continue;
    }
    Element abilElement=coreAbil.getElement();
    if (abilElement instanceof SubElement) {
      abilElement=((SubElement)abilElement).getParentElement();
    }
    if (abilElement == element) {
      list.add(comboab);
    }
  }
  Collections.sort(list);
  return list;
}",0.6799693016116654
133968,"@Override public void progress(){
  boolean isHovering=isHovering(player);
  if (!bPlayer.canBend(this)) {
    remove();
    return;
  }
 else   if (!player.isSneaking() && !isHovering && !firstProgressIteration) {
    remove();
    return;
  }
 else   if (player.getLocation().subtract(0,0.5,0).getBlock().getType() != Material.AIR) {
    remove();
    return;
  }
  player.setAllowFlight(true);
  if (flight == null) {
    flight=new Flight(player);
    player.setFlying(true);
  }
  if (isHovering) {
    Vector vec=player.getVelocity().clone();
    vec.setY(0);
    player.setVelocity(vec);
  }
 else {
    player.setVelocity(player.getEyeLocation().getDirection().normalize().multiply(speed));
  }
}","@Override public void progress(){
  boolean isHovering=isHovering(player);
  if (!bPlayer.canBend(this)) {
    remove();
    return;
  }
 else   if (!player.isSneaking() && !isHovering && !firstProgressIteration) {
    remove();
    return;
  }
 else   if (player.getLocation().subtract(0,0.5,0).getBlock().getType() != Material.AIR) {
    remove();
    return;
  }
  player.setAllowFlight(true);
  if (flight == null) {
    flight=new Flight(player);
    player.setFlying(true);
  }
  if (isHovering) {
    Vector vec=player.getVelocity().clone();
    vec.setY(0);
    player.setVelocity(vec);
  }
 else {
    player.setVelocity(player.getEyeLocation().getDirection().normalize().multiply(speed));
  }
  firstProgressIteration=false;
}",0.9777777777777776
133969,"private void displayAvatar(CommandSender sender){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(Element.AVATAR);
  if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.YELLOW + ""String_Node_Str"" + Element.AVATAR.getColor()+ ""String_Node_Str""+ ChatColor.YELLOW+ ""String_Node_Str"");
    return;
  }
  for (  CoreAbility ability : abilities) {
    if (sender instanceof Player) {
      if (GeneralMethods.canView((Player)sender,ability.getName())) {
        sender.sendMessage(ability.getElement().getColor() + ability.getName());
      }
    }
 else {
      sender.sendMessage(ability.getElement().getColor() + ability.getName());
    }
  }
}","private void displayAvatar(CommandSender sender){
  List<CoreAbility> abilities=CoreAbility.getAbilitiesByElement(Element.AVATAR);
  if (abilities.isEmpty()) {
    sender.sendMessage(ChatColor.YELLOW + ""String_Node_Str"" + Element.AVATAR.getColor()+ ""String_Node_Str""+ ChatColor.YELLOW+ ""String_Node_Str"");
    return;
  }
  for (  CoreAbility ability : abilities) {
    if (ability.isHiddenAbility()) {
      continue;
    }
    if (sender instanceof Player) {
      if (GeneralMethods.canView((Player)sender,ability.getName())) {
        sender.sendMessage(ability.getElement().getColor() + ability.getName());
      }
    }
 else {
      sender.sendMessage(ability.getElement().getColor() + ability.getName());
    }
  }
}",0.9359251259899208
133970,"@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),0,1)) {
    return;
  }
  if (args.size() == 1) {
    String elementName=args.get(0).toLowerCase();
    if (Arrays.asList(Commands.comboaliases).contains(elementName)) {
      elementName=this.getElement(elementName);
      Element element=Element.getElement(elementName);
      ChatColor color=element != null ? element.getColor() : null;
      ArrayList<String> combos=ComboManager.getCombosForElement(element);
      if (combos.isEmpty()) {
        sender.sendMessage(color + ""String_Node_Str"" + elementName+ ""String_Node_Str"");
        return;
      }
      for (      String combomove : combos) {
        if (!sender.hasPermission(""String_Node_Str"" + combomove))         continue;
        sender.sendMessage(color + combomove);
      }
      return;
    }
 else     if (Arrays.asList(Commands.elementaliases).contains(elementName)) {
      elementName=getElement(elementName);
      displayElement(sender,elementName);
    }
 else     if (Arrays.asList(Commands.subelementaliases).contains(elementName)) {
      displaySubElement(sender,elementName);
    }
 else     if (Arrays.asList(Commands.avataraliases).contains(elementName)) {
      displayAvatar(sender);
    }
 else {
      ChatColor w=ChatColor.WHITE;
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.WHITE+ ""String_Node_Str""+ Element.AIR.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.FIRE.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.CHI.getColor()+ ""String_Node_Str"");
      sender.sendMessage(w + ""String_Node_Str"" + w+ ""String_Node_Str""+ Element.AIR.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.FIRE.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.FIRE.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str"");
    }
  }
  if (args.size() == 0) {
    if (!(sender instanceof Player)) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    displayBinds(sender);
  }
}","@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),0,1)) {
    return;
  }
  if (args.size() == 1) {
    String elementName=args.get(0).toLowerCase();
    if (Arrays.asList(Commands.comboaliases).contains(elementName)) {
      elementName=this.getElement(elementName);
      Element element=Element.getElement(elementName);
      ChatColor color=element != null ? element.getColor() : null;
      ArrayList<String> combos=ComboManager.getCombosForElement(element);
      if (combos.isEmpty()) {
        sender.sendMessage(color + ""String_Node_Str"" + elementName+ ""String_Node_Str"");
        return;
      }
      for (      String comboMove : combos) {
        ChatColor comboColor=color;
        if (!sender.hasPermission(""String_Node_Str"" + comboMove)) {
          continue;
        }
        CoreAbility coreAbil=CoreAbility.getAbility(comboMove);
        if (coreAbil != null) {
          comboColor=coreAbil.getElement().getColor();
        }
        sender.sendMessage(comboColor + comboMove);
      }
      return;
    }
 else     if (Arrays.asList(Commands.elementaliases).contains(elementName)) {
      elementName=getElement(elementName);
      displayElement(sender,elementName);
    }
 else     if (Arrays.asList(Commands.subelementaliases).contains(elementName)) {
      displaySubElement(sender,elementName);
    }
 else     if (Arrays.asList(Commands.avataraliases).contains(elementName)) {
      displayAvatar(sender);
    }
 else {
      ChatColor w=ChatColor.WHITE;
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.WHITE+ ""String_Node_Str""+ Element.AIR.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.FIRE.getColor()+ ""String_Node_Str""+ ChatColor.WHITE+ ""String_Node_Str""+ Element.CHI.getColor()+ ""String_Node_Str"");
      sender.sendMessage(w + ""String_Node_Str"" + w+ ""String_Node_Str""+ Element.AIR.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.EARTH.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.FIRE.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.FIRE.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str""+ w+ ""String_Node_Str""+ Element.WATER.getColor()+ ""String_Node_Str"");
    }
  }
  if (args.size() == 0) {
    if (!(sender instanceof Player)) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    displayBinds(sender);
  }
}",0.9529536611248672
133971,"public void explode(){
  boolean explode=true;
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,3)) {
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
      explode=false;
      break;
    }
  }
  if (explode) {
    if (canDamageBlocks && explosionRadius > 0) {
      explosion=player.getWorld().spawn(location,TNTPrimed.class);
      explosion.setFuseTicks(0);
      double yield=explosionRadius;
      if (!bPlayer.isAvatarState()) {
        yield=getDayFactor(yield,player.getWorld());
      }
 else {
        yield=AvatarState.getValue(yield);
      }
      if (!bPlayer.isAvatarState()) {
        if (isDay(player.getWorld())) {
          yield=(float)getDayFactor(yield);
        }
      }
 else {
        yield=AvatarState.getValue(yield);
      }
      explosion.setYield((float)yield);
      EXPLOSIONS.put(explosion,this);
    }
 else {
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location,damageRadius);
      for (      Entity entity : entities) {
        if (entity instanceof LivingEntity) {
          double slope=-(maxDamage * .5) / (damageRadius - innerRadius);
          double damage=slope * (entity.getLocation().distance(location) - innerRadius) + maxDamage;
          GeneralMethods.damageEntity(this,entity,damage);
        }
      }
      location.getWorld().playSound(location,Sound.EXPLODE,5,1);
      ParticleEffect.EXPLOSION_HUGE.display(new Vector(0,0,0),0,location,256);
    }
  }
  ignite(location);
  remove();
}","public void explode(){
  boolean explode=true;
  for (  Block block : GeneralMethods.getBlocksAroundPoint(location,3)) {
    if (GeneralMethods.isRegionProtectedFromBuild(this,block.getLocation())) {
      explode=false;
      break;
    }
  }
  if (explode) {
    if (canDamageBlocks && explosionRadius > 0) {
      explosion=player.getWorld().spawn(location,TNTPrimed.class);
      explosion.setFuseTicks(0);
      double yield=explosionRadius;
      if (!bPlayer.isAvatarState()) {
        yield=getDayFactor(yield,player.getWorld());
      }
 else {
        yield=AvatarState.getValue(yield);
      }
      explosion.setYield((float)yield);
      EXPLOSIONS.put(explosion,this);
    }
 else {
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(location,damageRadius);
      for (      Entity entity : entities) {
        if (entity instanceof LivingEntity) {
          double slope=-(maxDamage * .5) / (damageRadius - innerRadius);
          double damage=slope * (entity.getLocation().distance(location) - innerRadius) + maxDamage;
          GeneralMethods.damageEntity(this,entity,damage);
        }
      }
      location.getWorld().playSound(location,Sound.EXPLODE,5,1);
      ParticleEffect.EXPLOSION_HUGE.display(new Vector(0,0,0),0,location,256);
    }
  }
  ignite(location);
  remove();
}",0.929706817379018
133972,"public FireCombo(Player player,String ability){
  super(player);
  Bukkit.broadcastMessage(""String_Node_Str"");
  this.ability=ability;
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    return;
  }
  this.firstTime=true;
  this.time=System.currentTimeMillis();
  this.affectedEntities=new ArrayList<>();
  this.tasks=new ArrayList<>();
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.speed=1;
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.knockback=getConfig().getDouble(""String_Node_Str"");
    this.speed=0.3;
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.fireTicks=getConfig().getDouble(""String_Node_Str"");
    this.height=2;
    this.radius=1;
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.fireTicks=getConfig().getDouble(""String_Node_Str"");
  }
  if (bPlayer.isAvatarState()) {
    this.cooldown=0;
    this.damage=AvatarState.getValue(damage);
    this.range=AvatarState.getValue(range);
  }
  start();
}","public FireCombo(Player player,String ability){
  super(player);
  this.ability=ability;
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    return;
  }
  this.firstTime=true;
  this.time=System.currentTimeMillis();
  this.affectedEntities=new ArrayList<>();
  this.tasks=new ArrayList<>();
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.speed=1;
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.knockback=getConfig().getDouble(""String_Node_Str"");
    this.speed=0.3;
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.range=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.fireTicks=getConfig().getDouble(""String_Node_Str"");
    this.height=2;
    this.radius=1;
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    this.damage=getConfig().getDouble(""String_Node_Str"");
    this.speed=getConfig().getDouble(""String_Node_Str"");
    this.cooldown=getConfig().getLong(""String_Node_Str"");
    this.fireTicks=getConfig().getDouble(""String_Node_Str"");
  }
  if (bPlayer.isAvatarState()) {
    this.cooldown=0;
    this.damage=AvatarState.getValue(damage);
    this.range=AvatarState.getValue(range);
  }
  start();
}",0.987958115183246
133973,"@Override public void progress(){
  Bukkit.broadcastMessage(""String_Node_Str"");
  progressCounter++;
  for (int i=0; i < tasks.size(); i++) {
    BukkitRunnable br=tasks.get(i);
    if (br instanceof FireComboStream) {
      FireComboStream fs=(FireComboStream)br;
      if (fs.isCancelled()) {
        tasks.remove(fs);
      }
    }
  }
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      Vector eyeDir=player.getEyeLocation().getDirection().normalize().multiply(range);
      destination=player.getEyeLocation().add(eyeDir);
      player.getWorld().playSound(player.getLocation(),Sound.HORSE_JUMP,0.5f,0f);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,1f);
      for (int i=-30; i <= 30; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setSpread(0.2F);
        fs.setDensity(5);
        fs.setUseNewParticles(true);
        if (tasks.size() % 3 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
        player.getWorld().playSound(player.getLocation(),Sound.FIRE_IGNITE,0.5f,1f);
      }
      location=tasks.get(0).getLocation();
      for (      FireComboStream stream : tasks) {
        if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,stream.location,2)) {
          stream.remove();
        }
      }
    }
 else     if (tasks.size() == 0) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      destination=player.getEyeLocation().add(range,0,range);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,0.5f);
      for (int i=0; i <= 360; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i - 180);
        vec.setY(0);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation().clone().add(0,1,0),range,speed,""String_Node_Str"");
        fs.setSpread(0.0F);
        fs.setDensity(1);
        fs.setUseNewParticles(true);
        if (tasks.size() % 10 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    if (tasks.size() == 0) {
      remove();
      return;
    }
    for (    FireComboStream stream : tasks) {
      if (isWithinFireShield(stream.getLocation())) {
        stream.remove();
      }
      if (AirAbility.isWithinAirShield(stream.getLocation())) {
        stream.remove();
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      if (firstTime) {
        if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
          remove();
          return;
        }
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
        firstTime=false;
        float spread=0F;
        ParticleEffect.LARGE_EXPLODE.display(player.getLocation(),spread,spread,spread,0,1);
        player.getWorld().playSound(player.getLocation(),Sound.EXPLODE,15,0F);
      }
      player.setVelocity(player.getVelocity().normalize().multiply(speed));
      FireComboStream fs=new FireComboStream(this,player.getVelocity().clone().multiply(-1),player.getLocation(),3,0.5,""String_Node_Str"");
      fs.setDensity(1);
      fs.setSpread(0.9F);
      fs.setUseNewParticles(true);
      fs.setCollides(false);
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (firstTime) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      firstTime=false;
    }
 else     if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      direction=player.getVelocity().clone().multiply(-1);
      player.setVelocity(player.getVelocity().normalize().multiply(speed));
      FireComboStream fs=new FireComboStream(this,direction,player.getLocation(),5,1,""String_Node_Str"");
      fs.setDensity(8);
      fs.setSpread(1.0F);
      fs.setUseNewParticles(true);
      fs.setCollisionRadius(3);
      fs.setParticleEffect(ParticleEffect.LARGE_SMOKE);
      if (progressCounter % 5 != 0) {
        fs.setCollides(false);
      }
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
      if (progressCounter % 4 == 0) {
        player.getWorld().playSound(player.getLocation(),Sound.FIZZ,1,0F);
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (location == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      if (GeneralMethods.getTopBlock(player.getLocation(),3,3) == null) {
        remove();
        return;
      }
      location=player.getLocation();
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
    }
 else     if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(location,2,-4);
    if (topBlock == null || (WaterAbility.isWaterbendable(topBlock,player) && !isPlant(topBlock))) {
      remove();
      return;
    }
 else     if (topBlock.getType() == Material.FIRE || ElementalAbility.isPlant(topBlock)) {
      topBlock=topBlock.getLocation().add(0,-1,0).getBlock();
    }
    location.setY(topBlock.getY() + height);
    FireComboStream fs=new FireComboStream(this,direction,location.clone().add(0,-1,0),5,1,""String_Node_Str"");
    fs.setDensity(0);
    fs.setSinglePoint(true);
    fs.setCollisionRadius(1.5);
    fs.setCollides(true);
    fs.runTaskTimer(ProjectKorra.plugin,0,1L);
    tasks.add(fs);
    for (double i=-180; i <= 180; i+=3) {
      Location tempLoc=location.clone();
      Vector newDir=direction.clone().multiply(radius * Math.cos(Math.toRadians(i)));
      tempLoc.add(newDir);
      tempLoc.setY(tempLoc.getY() + (radius * Math.sin(Math.toRadians(i))));
      ParticleEffect.FLAME.display(tempLoc,0,0,0,0,1);
    }
    location=location.add(direction.clone().multiply(speed));
    location.getWorld().playSound(location,Sound.FIRE,1,1);
    if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,location,2)) {
      remove();
      return;
    }
  }
}","@Override public void progress(){
  progressCounter++;
  for (int i=0; i < tasks.size(); i++) {
    BukkitRunnable br=tasks.get(i);
    if (br instanceof FireComboStream) {
      FireComboStream fs=(FireComboStream)br;
      if (fs.isCancelled()) {
        tasks.remove(fs);
      }
    }
  }
  if (!bPlayer.canBendIgnoreBindsCooldowns(this)) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      Vector eyeDir=player.getEyeLocation().getDirection().normalize().multiply(range);
      destination=player.getEyeLocation().add(eyeDir);
      player.getWorld().playSound(player.getLocation(),Sound.HORSE_JUMP,0.5f,0f);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,1f);
      for (int i=-30; i <= 30; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setSpread(0.2F);
        fs.setDensity(5);
        fs.setUseNewParticles(true);
        if (tasks.size() % 3 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
        player.getWorld().playSound(player.getLocation(),Sound.FIRE_IGNITE,0.5f,1f);
      }
      location=tasks.get(0).getLocation();
      for (      FireComboStream stream : tasks) {
        if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,stream.location,2)) {
          stream.remove();
        }
      }
    }
 else     if (tasks.size() == 0) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      destination=player.getEyeLocation().add(range,0,range);
      player.getWorld().playSound(player.getLocation(),Sound.FIZZ,0.5f,0.5f);
      for (int i=0; i <= 360; i+=5) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),destination.clone());
        vec=GeneralMethods.rotateXZ(vec,i - 180);
        vec.setY(0);
        FireComboStream fs=new FireComboStream(this,vec,player.getLocation().clone().add(0,1,0),range,speed,""String_Node_Str"");
        fs.setSpread(0.0F);
        fs.setDensity(1);
        fs.setUseNewParticles(true);
        if (tasks.size() % 10 != 0) {
          fs.setCollides(false);
        }
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    if (tasks.size() == 0) {
      remove();
      return;
    }
    for (    FireComboStream stream : tasks) {
      if (isWithinFireShield(stream.getLocation())) {
        stream.remove();
      }
      if (AirAbility.isWithinAirShield(stream.getLocation())) {
        stream.remove();
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      if (firstTime) {
        if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
          remove();
          return;
        }
        bPlayer.addCooldown(""String_Node_Str"",cooldown);
        firstTime=false;
        float spread=0F;
        ParticleEffect.LARGE_EXPLODE.display(player.getLocation(),spread,spread,spread,0,1);
        player.getWorld().playSound(player.getLocation(),Sound.EXPLODE,15,0F);
      }
      player.setVelocity(player.getVelocity().normalize().multiply(speed));
      FireComboStream fs=new FireComboStream(this,player.getVelocity().clone().multiply(-1),player.getLocation(),3,0.5,""String_Node_Str"");
      fs.setDensity(1);
      fs.setSpread(0.9F);
      fs.setUseNewParticles(true);
      fs.setCollides(false);
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (firstTime) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      firstTime=false;
    }
 else     if (System.currentTimeMillis() - time > 5000) {
      remove();
      return;
    }
 else     if (hasAbility(player,FireJet.class)) {
      direction=player.getVelocity().clone().multiply(-1);
      player.setVelocity(player.getVelocity().normalize().multiply(speed));
      FireComboStream fs=new FireComboStream(this,direction,player.getLocation(),5,1,""String_Node_Str"");
      fs.setDensity(8);
      fs.setSpread(1.0F);
      fs.setUseNewParticles(true);
      fs.setCollisionRadius(3);
      fs.setParticleEffect(ParticleEffect.LARGE_SMOKE);
      if (progressCounter % 5 != 0) {
        fs.setCollides(false);
      }
      fs.runTaskTimer(ProjectKorra.plugin,0,1L);
      tasks.add(fs);
      if (progressCounter % 4 == 0) {
        player.getWorld().playSound(player.getLocation(),Sound.FIZZ,1,0F);
      }
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (location == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !bPlayer.isAvatarState()) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      if (GeneralMethods.getTopBlock(player.getLocation(),3,3) == null) {
        remove();
        return;
      }
      location=player.getLocation();
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
    }
 else     if (location.distanceSquared(origin) > range * range) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(location,2,-4);
    if (topBlock == null || (WaterAbility.isWaterbendable(topBlock,player) && !isPlant(topBlock))) {
      remove();
      return;
    }
 else     if (topBlock.getType() == Material.FIRE || ElementalAbility.isPlant(topBlock)) {
      topBlock=topBlock.getLocation().add(0,-1,0).getBlock();
    }
    location.setY(topBlock.getY() + height);
    FireComboStream fs=new FireComboStream(this,direction,location.clone().add(0,-1,0),5,1,""String_Node_Str"");
    fs.setDensity(0);
    fs.setSinglePoint(true);
    fs.setCollisionRadius(1.5);
    fs.setCollides(true);
    fs.runTaskTimer(ProjectKorra.plugin,0,1L);
    tasks.add(fs);
    for (double i=-180; i <= 180; i+=3) {
      Location tempLoc=location.clone();
      Vector newDir=direction.clone().multiply(radius * Math.cos(Math.toRadians(i)));
      tempLoc.add(newDir);
      tempLoc.setY(tempLoc.getY() + (radius * Math.sin(Math.toRadians(i))));
      ParticleEffect.FLAME.display(tempLoc,0,0,0,0,1);
    }
    location=location.add(direction.clone().multiply(speed));
    location.getWorld().playSound(location,Sound.FIRE,1,1);
    if (GeneralMethods.blockAbilities(player,BLOCKABLE_ABILITIES,location,2)) {
      remove();
      return;
    }
  }
}",0.9968449931412896
133974,"public EarthSmash(Player player,ClickType type){
  if (!GeneralMethods.hasPermission(player,""String_Node_Str""))   return;
  this.player=player;
  bplayer=GeneralMethods.getBendingPlayer(player.getName());
  this.time=System.currentTimeMillis();
  if (type == ClickType.SHIFT_DOWN || type == ClickType.SHIFT_UP && !player.isSneaking()) {
    selectRange=SELECT_RANGE;
    chargeTime=CHARGE_TIME;
    cooldown=MAIN_COOLDOWN;
    damage=SHOOTING_DAMAGE;
    knockback=KNOCKBACK_POWER;
    knockup=KNOCKUP_POWER;
    flySpeed=FLYING_PLAYER_SPEED;
    flightRemove=FLYING_REMOVE_TIMER;
    shootRange=TRAVEL_RANGE;
    if (AvatarState.isAvatarState(player)) {
      selectRange=AvatarState.getValue(selectRange);
      chargeTime=0;
      cooldown=0;
      damage=AvatarState.getValue(damage);
      knockback=AvatarState.getValue(knockback);
      knockup=AvatarState.getValue(knockup);
      flySpeed=AvatarState.getValue(flySpeed);
      flightRemove=Integer.MAX_VALUE;
      shootRange=AvatarState.getValue(shootRange);
    }
    EarthSmash flySmash=flyingInSmashCheck(player);
    if (flySmash != null) {
      flySmash.state=State.FLYING;
      flySmash.player=player;
      flySmash.flightStart=System.currentTimeMillis();
      return;
    }
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,null);
    if (grabbedSmash == null) {
      if (bplayer.isOnCooldown(""String_Node_Str"")) {
        return;
      }
      grabbedSmash=aimingAtSmashCheck(player,State.SHOT);
    }
    if (grabbedSmash != null && grabbedSmash.state == State.LIFTED) {
      grabbedSmash.state=State.GRABBED;
      grabbedSmash.grabbedRange=grabbedSmash.loc.distance(player.getEyeLocation());
      grabbedSmash.player=player;
      return;
    }
  }
 else   if (type == ClickType.LEFT_CLICK && player.isSneaking()) {
    for (    EarthSmash smash : instances) {
      if (smash.state == State.GRABBED && smash.player == player) {
        smash.state=State.SHOT;
        smash.destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(smash.shootRange));
        smash.loc.getWorld().playEffect(smash.loc,Effect.GHAST_SHOOT,0,10);
      }
    }
    return;
  }
 else   if (type == ClickType.RIGHT_CLICK && player.isSneaking()) {
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,State.GRABBED);
    if (grabbedSmash != null) {
      player.teleport(grabbedSmash.loc.clone().add(0,2,0));
      grabbedSmash.state=State.FLYING;
      grabbedSmash.player=player;
      grabbedSmash.flightStart=System.currentTimeMillis();
    }
    return;
  }
 else {
    return;
  }
  instances.add(this);
}","public EarthSmash(Player player,ClickType type){
  if (!GeneralMethods.hasPermission(player,""String_Node_Str""))   return;
  this.player=player;
  bplayer=GeneralMethods.getBendingPlayer(player.getName());
  this.time=System.currentTimeMillis();
  if (type == ClickType.SHIFT_DOWN || type == ClickType.SHIFT_UP && !player.isSneaking()) {
    selectRange=SELECT_RANGE;
    chargeTime=CHARGE_TIME;
    cooldown=MAIN_COOLDOWN;
    damage=SHOOTING_DAMAGE;
    knockback=KNOCKBACK_POWER;
    knockup=KNOCKUP_POWER;
    flySpeed=FLYING_PLAYER_SPEED;
    flightRemove=FLYING_REMOVE_TIMER;
    shootRange=TRAVEL_RANGE;
    if (AvatarState.isAvatarState(player)) {
      selectRange=AvatarState.getValue(selectRange);
      chargeTime=0;
      cooldown=0;
      damage=AvatarState.getValue(damage);
      knockback=AvatarState.getValue(knockback);
      knockup=AvatarState.getValue(knockup);
      flySpeed=AvatarState.getValue(flySpeed);
      flightRemove=Integer.MAX_VALUE;
      shootRange=AvatarState.getValue(shootRange);
      GRAB_DETECTION_RADIUS=AvatarState.getValue(shootRange);
    }
    EarthSmash flySmash=flyingInSmashCheck(player);
    if (flySmash != null) {
      flySmash.state=State.FLYING;
      flySmash.player=player;
      flySmash.flightStart=System.currentTimeMillis();
      return;
    }
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,null);
    if (grabbedSmash == null) {
      grabbedSmash=aimingAtSmashCheck(player,State.SHOT);
    }
 else     if (grabbedSmash != null && grabbedSmash.state == State.LIFTED) {
      grabbedSmash.state=State.GRABBED;
      grabbedSmash.grabbedRange=grabbedSmash.loc.distance(player.getEyeLocation());
      grabbedSmash.player=player;
      return;
    }
 else     if (grabbedSmash != null && grabbedSmash.state == State.SHOT && grabbedSmash.player != player && grabbedSmash == aimingAtSmashCheck(player,State.SHOT)) {
      grabbedSmash.state=State.GRABBED;
      grabbedSmash.grabbedRange=grabbedSmash.loc.distance(player.getEyeLocation());
      grabbedSmash.player=player;
      return;
    }
  }
 else   if (type == ClickType.LEFT_CLICK && player.isSneaking()) {
    for (    EarthSmash smash : instances) {
      if (smash.state == State.GRABBED && smash.player == player) {
        smash.state=State.SHOT;
        smash.destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(smash.shootRange));
        smash.loc.getWorld().playEffect(smash.loc,Effect.GHAST_SHOOT,0,10);
      }
    }
    return;
  }
 else   if (type == ClickType.RIGHT_CLICK && player.isSneaking()) {
    EarthSmash grabbedSmash=aimingAtSmashCheck(player,State.GRABBED);
    if (grabbedSmash != null) {
      player.teleport(grabbedSmash.loc.clone().add(0,2,0));
      grabbedSmash.state=State.FLYING;
      grabbedSmash.player=player;
      grabbedSmash.flightStart=System.currentTimeMillis();
    }
    return;
  }
 else {
    return;
  }
  instances.add(this);
}",0.9127083706757484
133975,"private EarthSmash aimingAtSmashCheck(Player player,State reqState){
  if (!ALLOW_GRAB)   return null;
  List<Block> blocks=GeneralMethods.getBlocksAroundPoint(GeneralMethods.getTargetedLocation(player,GRAB_DETECTION_RADIUS,GeneralMethods.nonOpaque),1);
  for (  EarthSmash smash : instances) {
    if (reqState == null || smash.state == reqState)     for (    Block block : blocks)     if (block.getLocation().getWorld() == smash.loc.getWorld() && block.getLocation().distanceSquared(smash.loc) <= Math.pow(GRAB_DETECTION_RADIUS,2))     return smash;
  }
  return null;
}","private EarthSmash aimingAtSmashCheck(Player player,State reqState){
  if (!ALLOW_GRAB)   return null;
  List<Block> blocks=GeneralMethods.getBlocksAroundPoint(GeneralMethods.getTargetedLocation(player,GRAB_DETECTION_RADIUS,GeneralMethods.nonOpaque),1);
  for (  EarthSmash smash : instances) {
    if (reqState == null || smash.state == reqState)     for (    Block block : blocks) {
      if (block.getLocation().getWorld() == smash.loc.getWorld() && block.getLocation().distanceSquared(smash.loc) <= Math.pow(2.5,2))       return smash;
    }
  }
  return null;
}",0.968365553602812
133976,"public void progress(){
  progressCounter++;
  if (state == State.LIFTED && REMOVE_TIMER > 0 && System.currentTimeMillis() - time > REMOVE_TIMER) {
    remove();
    return;
  }
  if (state == State.START || state == State.FLYING || state == State.GRABBED) {
    if (player.isDead() || !player.isOnline()) {
      remove();
      return;
    }
  }
 else   if (state == State.START) {
    String ability=GeneralMethods.getBoundAbility(player);
    if (ability == null || !ability.equalsIgnoreCase(""String_Node_Str"") || bplayer.isOnCooldown(""String_Node_Str"")) {
      remove();
      return;
    }
  }
 else   if (state == State.START || state == State.FLYING || state == State.GRABBED) {
    if (!GeneralMethods.canBend(player.getName(),""String_Node_Str"")) {
      remove();
      return;
    }
  }
  if (state == State.START && progressCounter > 1) {
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - time > chargeTime) {
        origin=EarthMethods.getEarthSourceBlock(player,selectRange,true,EarthMethods.canSandbend(player),EarthMethods.canMetalbend(player));
        if (origin == null) {
          remove();
          return;
        }
        loc=origin.getLocation();
        state=State.LIFTING;
      }
 else {
        remove();
        return;
      }
    }
 else     if (System.currentTimeMillis() - time > chargeTime) {
      Location tempLoc=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(1.2));
      tempLoc.add(0,0.3,0);
      ParticleEffect.SMOKE.display(tempLoc,0.3F,0.1F,0.3F,0,4);
    }
  }
 else   if (state == State.LIFTING) {
    if (System.currentTimeMillis() - delay >= LIFT_ANIMATION_COOLDOWN) {
      delay=System.currentTimeMillis();
      animateLift();
    }
  }
 else   if (state == State.GRABBED) {
    if (player.isSneaking()) {
      revert();
      Location oldLoc=loc.clone();
      loc=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(grabbedRange));
      for (      Block block : getBlocks())       if (block.getType() != Material.AIR && !EarthMethods.isTransparentToEarthbending(player,block)) {
        loc=oldLoc;
        break;
      }
      WaterMethods.removeWaterSpouts(loc,2,player);
      AirMethods.removeAirSpouts(loc,2,player);
      draw();
      return;
    }
 else {
      state=State.LIFTED;
      return;
    }
  }
 else   if (state == State.SHOT) {
    if (System.currentTimeMillis() - delay >= SHOOTING_ANIMATION_COOLDOWN) {
      bplayer.addCooldown(""String_Node_Str"",cooldown);
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",loc)) {
        remove();
        return;
      }
      revert();
      loc.add(GeneralMethods.getDirection(loc,destination).normalize().multiply(1));
      if (loc.distanceSquared(destination) < 4) {
        remove();
        return;
      }
      int badBlocksFound=0;
      for (      Block block : getBlocks())       if (block.getType() != Material.AIR && (!EarthMethods.isTransparentToEarthbending(player,block) || block.getType() == Material.WATER || block.getType() == Material.STATIONARY_WATER))       badBlocksFound++;
      if (badBlocksFound > MAX_BLOCKS_TO_PASS_THROUGH) {
        remove();
        return;
      }
      WaterMethods.removeWaterSpouts(loc,2,player);
      AirMethods.removeAirSpouts(loc,2,player);
      shootingCollisionDetection();
      draw();
      smashToSmashCollisionDetection();
    }
    return;
  }
 else   if (state == State.FLYING) {
    if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (System.currentTimeMillis() - delay >= FLYING_ANIMATION_COOLDOWN) {
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",loc)) {
        remove();
        return;
      }
      revert();
      destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(shootRange));
      Vector direction=GeneralMethods.getDirection(loc,destination).normalize();
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(loc.clone().add(0,2,0),FLIGHT_DETECTION_RADIUS);
      if (entities.size() == 0) {
        remove();
        return;
      }
      for (      Entity entity : entities)       entity.setVelocity(direction.clone().multiply(flySpeed));
      if (direction.getY() < -0.35)       loc=player.getLocation().clone().add(0,-3.2,0);
 else       if (direction.getY() > 0.35)       loc=player.getLocation().clone().add(0,-1.7,0);
 else       loc=player.getLocation().clone().add(0,-2.2,0);
      draw();
    }
    if (System.currentTimeMillis() - flightStart > flightRemove) {
      remove();
      return;
    }
  }
}","public void progress(){
  progressCounter++;
  if (state == State.LIFTED && REMOVE_TIMER > 0 && System.currentTimeMillis() - time > REMOVE_TIMER) {
    remove();
    return;
  }
  if (state == State.START || state == State.FLYING || state == State.GRABBED) {
    if (player.isDead() || !player.isOnline()) {
      remove();
      return;
    }
  }
 else   if (state == State.START) {
    String ability=GeneralMethods.getBoundAbility(player);
    if (ability == null || !ability.equalsIgnoreCase(""String_Node_Str"") || bplayer.isOnCooldown(""String_Node_Str"")) {
      remove();
      return;
    }
  }
 else   if (state == State.START || state == State.FLYING || state == State.GRABBED) {
    if (!GeneralMethods.canBend(player.getName(),""String_Node_Str"")) {
      remove();
      return;
    }
  }
  if (state == State.START && progressCounter > 1) {
    if (!player.isSneaking()) {
      if (System.currentTimeMillis() - time > chargeTime) {
        origin=EarthMethods.getEarthSourceBlock(player,selectRange,true,EarthMethods.canSandbend(player),EarthMethods.canMetalbend(player));
        if (origin == null) {
          remove();
          return;
        }
        loc=origin.getLocation();
        state=State.LIFTING;
      }
 else {
        remove();
        return;
      }
    }
 else     if (System.currentTimeMillis() - time > chargeTime) {
      Location tempLoc=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(1.2));
      tempLoc.add(0,0.3,0);
      ParticleEffect.SMOKE.display(tempLoc,0.3F,0.1F,0.3F,0,4);
    }
    if (bplayer.isOnCooldown(""String_Node_Str"")) {
      return;
    }
  }
 else   if (state == State.LIFTING) {
    if (System.currentTimeMillis() - delay >= LIFT_ANIMATION_COOLDOWN) {
      delay=System.currentTimeMillis();
      animateLift();
      bplayer.addCooldown(""String_Node_Str"",cooldown);
    }
  }
 else   if (state == State.GRABBED) {
    if (player.isSneaking()) {
      revert();
      Location oldLoc=loc.clone();
      loc=player.getEyeLocation().add(player.getEyeLocation().getDirection().normalize().multiply(grabbedRange));
      for (      Block block : getBlocks())       if (block.getType() != Material.AIR && !EarthMethods.isTransparentToEarthbending(player,block)) {
        loc=oldLoc;
        break;
      }
      WaterMethods.removeWaterSpouts(loc,2,player);
      AirMethods.removeAirSpouts(loc,2,player);
      draw();
      return;
    }
 else {
      state=State.LIFTED;
      return;
    }
  }
 else   if (state == State.SHOT) {
    if (System.currentTimeMillis() - delay >= SHOOTING_ANIMATION_COOLDOWN) {
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",loc)) {
        remove();
        return;
      }
      revert();
      loc.add(GeneralMethods.getDirection(loc,destination).normalize().multiply(1));
      if (loc.distanceSquared(destination) < 4) {
        remove();
        return;
      }
      int badBlocksFound=0;
      for (      Block block : getBlocks())       if (block.getType() != Material.AIR && (!EarthMethods.isTransparentToEarthbending(player,block) || block.getType() == Material.WATER || block.getType() == Material.STATIONARY_WATER))       badBlocksFound++;
      if (badBlocksFound > MAX_BLOCKS_TO_PASS_THROUGH) {
        remove();
        return;
      }
      WaterMethods.removeWaterSpouts(loc,2,player);
      AirMethods.removeAirSpouts(loc,2,player);
      shootingCollisionDetection();
      draw();
      smashToSmashCollisionDetection();
    }
    return;
  }
 else   if (state == State.FLYING) {
    if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (System.currentTimeMillis() - delay >= FLYING_ANIMATION_COOLDOWN) {
      delay=System.currentTimeMillis();
      if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",loc)) {
        remove();
        return;
      }
      revert();
      destination=player.getEyeLocation().clone().add(player.getEyeLocation().getDirection().normalize().multiply(shootRange));
      Vector direction=GeneralMethods.getDirection(loc,destination).normalize();
      List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(loc.clone().add(0,2,0),FLIGHT_DETECTION_RADIUS);
      if (entities.size() == 0) {
        remove();
        return;
      }
      for (      Entity entity : entities)       entity.setVelocity(direction.clone().multiply(flySpeed));
      if (direction.getY() < -0.35)       loc=player.getLocation().clone().add(0,-3.2,0);
 else       if (direction.getY() > 0.35)       loc=player.getLocation().clone().add(0,-1.7,0);
 else       loc=player.getLocation().clone().add(0,-2.2,0);
      draw();
    }
    if (System.currentTimeMillis() - flightStart > flightRemove) {
      remove();
      return;
    }
  }
}",0.981068925844577
133977,"/** 
 * Attempts to get a   {@link BendingPlayer} from specified player name. thismethod tries to get a  {@link Player} object and gets the uuid and thencalls  {@link #getBendingPlayer(UUID)}
 * @param playerName The name of the Player
 * @return The BendingPlayer object if {@link BendingPlayer#players}contains the player name
 * @see #getBendingPlayer(UUID)
 */
public static BendingPlayer getBendingPlayer(String player){
  OfflinePlayer oPlayer=Bukkit.getPlayer(player);
  if (player == null) {
    oPlayer=Bukkit.getOfflinePlayer(oPlayer.getUniqueId());
  }
  return BendingPlayer.getPlayers().get(oPlayer.getUniqueId());
}","/** 
 * Attempts to get a   {@link BendingPlayer} from specified player name. thismethod tries to get a  {@link Player} object and gets the uuid and thencalls  {@link #getBendingPlayer(UUID)}
 * @param playerName The name of the Player
 * @return The BendingPlayer object if {@link BendingPlayer#players}contains the player name
 * @see #getBendingPlayer(UUID)
 */
public static BendingPlayer getBendingPlayer(String player){
  OfflinePlayer oPlayer=Bukkit.getOfflinePlayer(player);
  if (player == null) {
    oPlayer=Bukkit.getOfflinePlayer(oPlayer.getUniqueId());
  }
  return BendingPlayer.getPlayers().get(oPlayer.getUniqueId());
}",0.9944664031620554
133978,"public static void login(BendingPlayer pl){
  ProjectKorra plugin=ProjectKorra.plugin;
  Player player=Bukkit.getPlayer(pl.getUUID());
  if (player == null) {
    return;
  }
  if (GeneralMethods.toggledOut.contains(player.getUniqueId())) {
    GeneralMethods.getBendingPlayer(player.getName()).toggleBending();
    player.sendMessage(ChatColor.YELLOW + ""String_Node_Str"");
  }
  Preset.loadPresets(player);
  String append=""String_Node_Str"";
  ChatColor color=null;
  boolean chatEnabled=ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"");
  if ((player.hasPermission(""String_Node_Str"") || GeneralMethods.getBendingPlayer(player.getName()).getElements().size() > 1) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChatColor.valueOf(plugin.getConfig().getString(""String_Node_Str""));
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Air) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=AirMethods.getAirColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Water) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=WaterMethods.getWaterColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Earth) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=EarthMethods.getEarthColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Fire) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=FireMethods.getFireColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Chi) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChiMethods.getChiColor();
  }
  if (chatEnabled) {
    player.setDisplayName(player.getName());
    player.setDisplayName(color + append + ChatColor.RESET+ player.getDisplayName());
  }
  if (player.getGameMode() != GameMode.CREATIVE) {
    HashMap<Integer,String> bound=GeneralMethods.getBendingPlayer(player.getName()).getAbilities();
    for (    String str : bound.values()) {
      if (str.equalsIgnoreCase(""String_Node_Str"") || str.equalsIgnoreCase(""String_Node_Str"") || str.equalsIgnoreCase(""String_Node_Str"")) {
        final Player fplayer=player;
        new BukkitRunnable(){
          public void run(){
            fplayer.setFlying(false);
            fplayer.setAllowFlight(false);
          }
        }
.runTaskLater(ProjectKorra.plugin,2);
        break;
      }
    }
  }
}","public static void login(BendingPlayer pl){
  ProjectKorra plugin=ProjectKorra.plugin;
  Player player=Bukkit.getPlayer(pl.getUUID());
  if (player == null) {
    return;
  }
  if (GeneralMethods.toggledOut.contains(player.getUniqueId())) {
    GeneralMethods.getBendingPlayer(player.getName()).toggleBending();
    player.sendMessage(ChatColor.YELLOW + ""String_Node_Str"");
  }
  Preset.loadPresets(player);
  String append=""String_Node_Str"";
  ChatColor color=null;
  boolean chatEnabled=ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"");
  if (GeneralMethods.getBendingPlayer(player.getName()).getElements().size() > 1 && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChatColor.valueOf(plugin.getConfig().getString(""String_Node_Str""));
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Air) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=AirMethods.getAirColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Water) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=WaterMethods.getWaterColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Earth) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=EarthMethods.getEarthColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Fire) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=FireMethods.getFireColor();
  }
 else   if (GeneralMethods.isBender(player.getName(),Element.Chi) && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChiMethods.getChiColor();
  }
 else {
    append=""String_Node_Str"";
    color=ChatColor.WHITE;
  }
  if (chatEnabled) {
    player.setDisplayName(player.getName());
    player.setDisplayName(color + append + ChatColor.RESET+ player.getDisplayName());
  }
  if (player.getGameMode() != GameMode.CREATIVE) {
    HashMap<Integer,String> bound=GeneralMethods.getBendingPlayer(player.getName()).getAbilities();
    for (    String str : bound.values()) {
      if (str.equalsIgnoreCase(""String_Node_Str"") || str.equalsIgnoreCase(""String_Node_Str"") || str.equalsIgnoreCase(""String_Node_Str"")) {
        final Player fplayer=player;
        new BukkitRunnable(){
          public void run(){
            fplayer.setFlying(false);
            fplayer.setAllowFlight(false);
          }
        }
.runTaskLater(ProjectKorra.plugin,2);
        break;
      }
    }
  }
}",0.9564021995286724
133979,"@EventHandler(priority=EventPriority.NORMAL) public void onElementChange(PlayerChangeElementEvent event){
  Player player=event.getTarget();
  Element e=event.getElement();
  String append=""String_Node_Str"";
  ChatColor color=null;
  boolean chatEnabled=ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"");
  if (GeneralMethods.getBendingPlayer(player.getName()).getElements().size() > 1) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChatColor.valueOf(plugin.getConfig().getString(""String_Node_Str""));
  }
 else   if (e == Element.Air && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=AirMethods.getAirColor();
  }
 else   if (e == Element.Water && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=WaterMethods.getWaterColor();
  }
 else   if (e == Element.Earth && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=EarthMethods.getEarthColor();
  }
 else   if (e == Element.Fire && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=FireMethods.getFireColor();
  }
 else   if (e == Element.Chi && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChiMethods.getChiColor();
  }
  if (chatEnabled) {
    player.setDisplayName(player.getName());
    player.setDisplayName(color + append + ChatColor.RESET+ player.getDisplayName());
  }
}","@EventHandler(priority=EventPriority.NORMAL) public void onElementChange(PlayerChangeElementEvent event){
  Player player=event.getTarget();
  Element e=event.getElement();
  String append=""String_Node_Str"";
  ChatColor color=null;
  boolean chatEnabled=ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"");
  if (GeneralMethods.getBendingPlayer(player.getName()).getElements().size() > 1) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChatColor.valueOf(plugin.getConfig().getString(""String_Node_Str""));
  }
 else   if (e == Element.Air && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=AirMethods.getAirColor();
  }
 else   if (e == Element.Water && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=WaterMethods.getWaterColor();
  }
 else   if (e == Element.Earth && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=EarthMethods.getEarthColor();
  }
 else   if (e == Element.Fire && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=FireMethods.getFireColor();
  }
 else   if (e == Element.Chi && chatEnabled) {
    append=plugin.getConfig().getString(""String_Node_Str"");
    color=ChiMethods.getChiColor();
  }
 else {
    append=""String_Node_Str"";
    color=ChatColor.WHITE;
  }
  if (chatEnabled) {
    player.setDisplayName(player.getName());
    player.setDisplayName(color + append + ChatColor.RESET+ player.getDisplayName());
  }
}",0.9767598518019536
133980,"@SuppressWarnings(""String_Node_Str"") public EarthArmor(Player player){
  if (instances.containsKey(player)) {
    return;
  }
  BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  if (bPlayer.isOnCooldown(""String_Node_Str""))   return;
  this.player=player;
  headblock=BlockSource.getEarthSourceBlock(player,autoSelectRange,selectRange,ClickType.LEFT_CLICK,false,auto,false,true,EarthMethods.canSandbend(player),false);
  if (BlockSource.isAuto(headblock)) {
    isAuto=true;
  }
 else {
    isAuto=false;
  }
  if (EarthMethods.getEarthbendableBlocksLength(player,headblock,new Vector(0,-1,0),2) >= 2) {
    legsblock=headblock.getRelative(BlockFace.DOWN);
    headtype=headblock.getType();
    legstype=legsblock.getType();
    headdata=headblock.getData();
    legsdata=legsblock.getData();
    headblocklocation=headblock.getLocation();
    legsblocklocation=legsblock.getLocation();
    Block oldheadblock, oldlegsblock;
    oldheadblock=headblock;
    oldlegsblock=legsblock;
    if (!moveBlocks())     return;
    if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"")) {
      EarthMethods.addTempAirBlock(oldheadblock);
      EarthMethods.addTempAirBlock(oldlegsblock);
    }
 else {
      GeneralMethods.removeBlock(oldheadblock);
      GeneralMethods.removeBlock(oldlegsblock);
    }
    instances.put(player,this);
  }
}","@SuppressWarnings(""String_Node_Str"") public EarthArmor(Player player){
  if (instances.containsKey(player)) {
    return;
  }
  BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  if (bPlayer.isOnCooldown(""String_Node_Str""))   return;
  this.player=player;
  headblock=BlockSource.getEarthSourceBlock(player,autoSelectRange,selectRange,ClickType.LEFT_CLICK,false,auto,false,true,EarthMethods.canSandbend(player),false);
  if (BlockSource.isAuto(headblock)) {
    bPlayer.addCooldown(""String_Node_Str"",autocooldown);
  }
 else {
    bPlayer.addCooldown(""String_Node_Str"",cooldown);
  }
  if (EarthMethods.getEarthbendableBlocksLength(player,headblock,new Vector(0,-1,0),2) >= 2) {
    legsblock=headblock.getRelative(BlockFace.DOWN);
    headtype=headblock.getType();
    legstype=legsblock.getType();
    headdata=headblock.getData();
    legsdata=legsblock.getData();
    headblocklocation=headblock.getLocation();
    legsblocklocation=legsblock.getLocation();
    Block oldheadblock, oldlegsblock;
    oldheadblock=headblock;
    oldlegsblock=legsblock;
    if (!moveBlocks())     return;
    if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"")) {
      EarthMethods.addTempAirBlock(oldheadblock);
      EarthMethods.addTempAirBlock(oldlegsblock);
    }
 else {
      GeneralMethods.removeBlock(oldheadblock);
      GeneralMethods.removeBlock(oldlegsblock);
    }
    instances.put(player,this);
  }
}",0.9590309939437122
133981,"public static void moveArmor(Player player){
  if (!instances.containsKey(player))   return;
  EarthArmor eartharmor=instances.get(player);
  if (player.isDead() || !player.isOnline()) {
    eartharmor.cancel();
    eartharmor.removeEffect();
    return;
  }
  if (eartharmor.formed) {
    if (System.currentTimeMillis() > eartharmor.starttime + duration && !eartharmor.complete) {
      eartharmor.complete=true;
      eartharmor.removeEffect();
      eartharmor.cancel();
      if (isAuto == true) {
        GeneralMethods.getBendingPlayer(player.getName()).addCooldown(""String_Node_Str"",autocooldown);
      }
 else {
        GeneralMethods.getBendingPlayer(player.getName()).addCooldown(""String_Node_Str"",cooldown);
      }
      return;
    }
  }
 else   if (System.currentTimeMillis() > eartharmor.time + interval) {
    if (!eartharmor.moveBlocks())     return;
    if (eartharmor.inPosition()) {
      eartharmor.formArmor();
    }
  }
}","public static void moveArmor(Player player){
  if (!instances.containsKey(player))   return;
  EarthArmor eartharmor=instances.get(player);
  if (player.isDead() || !player.isOnline()) {
    eartharmor.cancel();
    eartharmor.removeEffect();
    return;
  }
  if (eartharmor.formed) {
    if (System.currentTimeMillis() > eartharmor.starttime + duration && !eartharmor.complete) {
      eartharmor.complete=true;
      eartharmor.removeEffect();
      eartharmor.cancel();
      return;
    }
  }
 else   if (System.currentTimeMillis() > eartharmor.time + interval) {
    if (!eartharmor.moveBlocks())     return;
    if (eartharmor.inPosition()) {
      eartharmor.formArmor();
    }
  }
}",0.6014669926650367
133982,"public boolean prepare(){
  BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  if (bPlayer.isOnCooldown(""String_Node_Str""))   return false;
  cancelPrevious();
  Block block=BlockSource.getEarthSourceBlock(player,autoSelectRange,selectRange,ClickType.SHIFT_DOWN,dynamic,auto,dynamic,true,EarthMethods.canSandbend(player),false);
  block(player);
  if (block != null) {
    if (block.getLocation().distance(player.getLocation()) > selectRange) {
      return false;
    }
    if (BlockSource.isAuto(block)) {
      bPlayer.addCooldown(""String_Node_Str"",autocooldown);
    }
 else {
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
    }
    sourceblock=block;
    focusBlock();
    return true;
  }
  return false;
}","public boolean prepare(){
  cancelPrevious();
  Block block=BlockSource.getEarthSourceBlock(player,autoSelectRange,selectRange,ClickType.SHIFT_DOWN,dynamic,auto,dynamic,true,EarthMethods.canSandbend(player),false);
  block(player);
  if (block != null) {
    if (block.getLocation().distance(player.getLocation()) > selectRange) {
      return false;
    }
    BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
    if (BlockSource.isAuto(block)) {
      bPlayer.addCooldown(""String_Node_Str"",autocooldown);
    }
 else {
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
    }
    sourceblock=block;
    focusBlock();
    return true;
  }
  return false;
}",0.8495451364590623
133983,"public EarthBlast(Player player){
  this.player=player;
  if (prepare()) {
    id=ID++;
    if (ID >= Integer.MAX_VALUE)     ID=Integer.MIN_VALUE;
    instances.put(id,this);
    time=System.currentTimeMillis();
  }
}","public EarthBlast(Player player){
  BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  if (bPlayer.isOnCooldown(""String_Node_Str""))   return;
  this.player=player;
  if (prepare()) {
    id=ID++;
    if (ID >= Integer.MAX_VALUE)     ID=Integer.MIN_VALUE;
    instances.put(id,this);
    time=System.currentTimeMillis();
  }
}",0.7667844522968198
133984,"public static void throwEarth(Player player){
  ArrayList<EarthBlast> ignore=new ArrayList<EarthBlast>();
  BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  if (bPlayer.isOnCooldown(""String_Node_Str""))   return;
  for (  int id : instances.keySet()) {
    EarthBlast blast=instances.get(id);
    if (blast.player == player && !blast.progressing) {
      blast.throwEarth();
      ignore.add(blast);
    }
  }
  redirectTargettedBlasts(player,ignore);
}","public static void throwEarth(Player player){
  ArrayList<EarthBlast> ignore=new ArrayList<EarthBlast>();
  for (  int id : instances.keySet()) {
    EarthBlast blast=instances.get(id);
    if (blast.player == player && !blast.progressing) {
      blast.throwEarth();
      ignore.add(blast);
    }
  }
  redirectTargettedBlasts(player,ignore);
}",0.8398058252427184
133985,"public void progress(){
  progressCounter++;
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      state=AbilityState.TWISTER_MOVING;
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
      origin=player.getLocation().add(direction.clone().multiply(2));
      destination=player.getLocation().add(direction.clone().multiply(range));
      currentLoc=origin.clone();
    }
    if (origin.distance(currentLoc) < origin.distance(destination) && state == AbilityState.TWISTER_MOVING)     currentLoc.add(direction.clone().multiply(speed));
 else     if (state == AbilityState.TWISTER_MOVING) {
      state=AbilityState.TWISTER_STATIONARY;
      time=System.currentTimeMillis();
    }
 else     if (System.currentTimeMillis() - time >= twisterRemoveDelay) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",currentLoc)) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(currentLoc,3,-3);
    if (topBlock == null) {
      remove();
      return;
    }
    currentLoc.setY(topBlock.getLocation().getY());
    double height=twisterHeight;
    double radius=twisterRadius;
    for (double y=0; y < height; y+=twisterHeightPerParticle) {
      double animRadius=((radius / height) * y);
      for (double i=-180; i <= 180; i+=twisterDegreePerParticle) {
        Vector animDir=GeneralMethods.rotateXZ(new Vector(1,0,1),i);
        Location animLoc=currentLoc.clone().add(animDir.multiply(animRadius));
        animLoc.add(0,y,0);
        AirMethods.playAirbendingParticles(animLoc,1,0,0,0);
      }
    }
    AirMethods.playAirbendingSound(currentLoc);
    for (int i=0; i < height; i+=3)     for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc.clone().add(0,i,0),radius * 0.75))     if (!affectedEntities.contains(entity) && !entity.equals(player))     affectedEntities.add(entity);
    for (    Entity entity : affectedEntities) {
      Vector forceDir=GeneralMethods.getDirection(entity.getLocation(),currentLoc.clone().add(0,height,0));
      if (entity instanceof Player) {
        if (Commands.invincible.contains(((Player)entity).getName()))         break;
      }
      entity.setVelocity(forceDir.clone().normalize().multiply(0.3));
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getEyeLocation();
      currentLoc=origin.clone();
    }
    Entity target=GeneralMethods.getTargetedEntity(player,range,new ArrayList<Entity>());
    if (target instanceof Player) {
      if (Commands.invincible.contains(((Player)target).getName()))       return;
    }
    if (target != null && target.getLocation().distance(currentLoc) > 7)     destination=target.getLocation();
 else     destination=GeneralMethods.getTargetedLocation(player,range,EarthMethods.transparentToEarthbending);
    direction=GeneralMethods.getDirection(currentLoc,destination).normalize();
    currentLoc.add(direction.clone().multiply(speed));
    if (!EarthMethods.isTransparentToEarthbending(player,currentLoc.getBlock()))     currentLoc.subtract(direction.clone().multiply(speed));
    if (Math.abs(player.getLocation().distance(currentLoc)) > range) {
      remove();
      return;
    }
 else     if (affectedEntities.size() > 0 && System.currentTimeMillis() - time >= airStreamEntityDuration) {
      remove();
      return;
    }
 else     if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (!EarthMethods.isTransparentToEarthbending(player,currentLoc.getBlock())) {
      remove();
      return;
    }
 else     if (currentLoc.getY() - origin.getY() > airStreamEntityHeight) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",currentLoc)) {
      remove();
      return;
    }
 else     if (FireMethods.isWithinFireShield(currentLoc)) {
      remove();
      return;
    }
 else     if (AirMethods.isWithinAirShield(currentLoc)) {
      remove();
      return;
    }
    for (int i=0; i < 10; i++) {
      BukkitRunnable br=new BukkitRunnable(){
        final Location loc=currentLoc.clone();
        final Vector dir=direction.clone();
        @Override public void run(){
          for (int angle=-180; angle <= 180; angle+=45) {
            Vector orthog=GeneralMethods.getOrthogonalVector(dir.clone(),angle,0.5);
            AirMethods.playAirbendingParticles(loc.clone().add(orthog),1,0F,0F,0F);
          }
        }
      }
;
      br.runTaskLater(ProjectKorra.plugin,i * 2);
      tasks.add(br);
    }
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc,2.8)) {
      if (affectedEntities.size() == 0) {
        time=System.currentTimeMillis();
      }
      if (!entity.equals(player) && !affectedEntities.contains(entity)) {
        affectedEntities.add(entity);
        if (entity instanceof Player) {
          flights.add(new Flight((Player)entity,player));
        }
      }
    }
    for (    Entity entity : affectedEntities) {
      Vector force=GeneralMethods.getDirection(entity.getLocation(),currentLoc);
      entity.setVelocity(force.clone().normalize().multiply(speed));
      entity.setFallDistance(0F);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (origin == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      currentLoc=origin.clone();
      direction=player.getEyeLocation().getDirection();
      for (double i=-5; i < 10; i+=1) {
        FireComboStream fs=new FireComboStream(null,direction.clone().add(new Vector(0,0.03 * i,0)),player.getLocation(),range,speed,""String_Node_Str"");
        fs.setDensity(1);
        fs.setSpread(0F);
        fs.setUseNewParticles(true);
        fs.setParticleEffect(AirMethods.getAirbendingParticles());
        fs.setCollides(false);
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    manageAirVectors();
    for (    Entity entity : affectedEntities)     if (entity instanceof LivingEntity) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (origin == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      direction=player.getEyeLocation().getDirection().normalize();
      origin=player.getLocation().add(direction.clone().multiply(10));
    }
    if (progressCounter < 8)     return;
    if (destination == null) {
      destination=player.getLocation().add(player.getEyeLocation().getDirection().normalize().multiply(10));
      Vector origToDest=GeneralMethods.getDirection(origin,destination);
      for (double i=0; i < 30; i++) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),origin.clone().add(origToDest.clone().multiply(i / 30)));
        FireComboStream fs=new FireComboStream(null,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setDensity(1);
        fs.setSpread(0F);
        fs.setUseNewParticles(true);
        fs.setParticleEffect(AirMethods.getAirbendingParticles());
        fs.setCollides(false);
        fs.runTaskTimer(ProjectKorra.plugin,(long)(i / 2.5),1L);
        tasks.add(fs);
      }
    }
    manageAirVectors();
  }
}","public void progress(){
  progressCounter++;
  if (player.isDead() || !player.isOnline()) {
    remove();
    return;
  }
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      state=AbilityState.TWISTER_MOVING;
      direction=player.getEyeLocation().getDirection().clone().normalize();
      direction.setY(0);
      origin=player.getLocation().add(direction.clone().multiply(2));
      destination=player.getLocation().add(direction.clone().multiply(range));
      currentLoc=origin.clone();
    }
    if (origin.distance(currentLoc) < origin.distance(destination) && state == AbilityState.TWISTER_MOVING)     currentLoc.add(direction.clone().multiply(speed));
 else     if (state == AbilityState.TWISTER_MOVING) {
      state=AbilityState.TWISTER_STATIONARY;
      time=System.currentTimeMillis();
    }
 else     if (System.currentTimeMillis() - time >= twisterRemoveDelay) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",currentLoc)) {
      remove();
      return;
    }
    Block topBlock=GeneralMethods.getTopBlock(currentLoc,3,-3);
    if (topBlock == null) {
      remove();
      return;
    }
    currentLoc.setY(topBlock.getLocation().getY());
    double height=twisterHeight;
    double radius=twisterRadius;
    for (double y=0; y < height; y+=twisterHeightPerParticle) {
      double animRadius=((radius / height) * y);
      for (double i=-180; i <= 180; i+=twisterDegreePerParticle) {
        Vector animDir=GeneralMethods.rotateXZ(new Vector(1,0,1),i);
        Location animLoc=currentLoc.clone().add(animDir.multiply(animRadius));
        animLoc.add(0,y,0);
        AirMethods.playAirbendingParticles(animLoc,1,0,0,0);
      }
    }
    AirMethods.playAirbendingSound(currentLoc);
    for (int i=0; i < height; i+=3)     for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc.clone().add(0,i,0),radius * 0.75))     if (!affectedEntities.contains(entity) && !entity.equals(player))     affectedEntities.add(entity);
    for (    Entity entity : affectedEntities) {
      Vector forceDir=GeneralMethods.getDirection(entity.getLocation(),currentLoc.clone().add(0,height,0));
      if (entity instanceof Player) {
        if (Commands.invincible.contains(((Player)entity).getName()))         break;
      }
      entity.setVelocity(forceDir.clone().normalize().multiply(0.3));
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (destination == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getEyeLocation();
      currentLoc=origin.clone();
    }
    Entity target=GeneralMethods.getTargetedEntity(player,range,new ArrayList<Entity>());
    if (target instanceof Player) {
      if (Commands.invincible.contains(((Player)target).getName()))       return;
    }
    if (target != null && target.getLocation().distance(currentLoc) > 7)     destination=target.getLocation();
 else     destination=GeneralMethods.getTargetedLocation(player,range,EarthMethods.transparentToEarthbending);
    direction=GeneralMethods.getDirection(currentLoc,destination).normalize();
    currentLoc.add(direction.clone().multiply(speed));
    if (!EarthMethods.isTransparentToEarthbending(player,currentLoc.getBlock()))     currentLoc.subtract(direction.clone().multiply(speed));
    if (player.getWorld() != currentLoc.getWorld()) {
      remove();
      return;
    }
    if (Math.abs(player.getLocation().distance(currentLoc)) > range) {
      remove();
      return;
    }
 else     if (affectedEntities.size() > 0 && System.currentTimeMillis() - time >= airStreamEntityDuration) {
      remove();
      return;
    }
 else     if (!player.isSneaking()) {
      remove();
      return;
    }
 else     if (!EarthMethods.isTransparentToEarthbending(player,currentLoc.getBlock())) {
      remove();
      return;
    }
 else     if (currentLoc.getY() - origin.getY() > airStreamEntityHeight) {
      remove();
      return;
    }
 else     if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",currentLoc)) {
      remove();
      return;
    }
 else     if (FireMethods.isWithinFireShield(currentLoc)) {
      remove();
      return;
    }
 else     if (AirMethods.isWithinAirShield(currentLoc)) {
      remove();
      return;
    }
    for (int i=0; i < 10; i++) {
      BukkitRunnable br=new BukkitRunnable(){
        final Location loc=currentLoc.clone();
        final Vector dir=direction.clone();
        @Override public void run(){
          for (int angle=-180; angle <= 180; angle+=45) {
            Vector orthog=GeneralMethods.getOrthogonalVector(dir.clone(),angle,0.5);
            AirMethods.playAirbendingParticles(loc.clone().add(orthog),1,0F,0F,0F);
          }
        }
      }
;
      br.runTaskLater(ProjectKorra.plugin,i * 2);
      tasks.add(br);
    }
    for (    Entity entity : GeneralMethods.getEntitiesAroundPoint(currentLoc,2.8)) {
      if (affectedEntities.size() == 0) {
        time=System.currentTimeMillis();
      }
      if (!entity.equals(player) && !affectedEntities.contains(entity)) {
        affectedEntities.add(entity);
        if (entity instanceof Player) {
          flights.add(new Flight((Player)entity,player));
        }
      }
    }
    for (    Entity entity : affectedEntities) {
      Vector force=GeneralMethods.getDirection(entity.getLocation(),currentLoc);
      entity.setVelocity(force.clone().normalize().multiply(speed));
      entity.setFallDistance(0F);
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (origin == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      origin=player.getLocation();
      currentLoc=origin.clone();
      direction=player.getEyeLocation().getDirection();
      for (double i=-5; i < 10; i+=1) {
        FireComboStream fs=new FireComboStream(null,direction.clone().add(new Vector(0,0.03 * i,0)),player.getLocation(),range,speed,""String_Node_Str"");
        fs.setDensity(1);
        fs.setSpread(0F);
        fs.setUseNewParticles(true);
        fs.setParticleEffect(AirMethods.getAirbendingParticles());
        fs.setCollides(false);
        fs.runTaskTimer(ProjectKorra.plugin,0,1L);
        tasks.add(fs);
      }
    }
    manageAirVectors();
    for (    Entity entity : affectedEntities)     if (entity instanceof LivingEntity) {
      remove();
      return;
    }
  }
 else   if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (origin == null) {
      if (bPlayer.isOnCooldown(""String_Node_Str"") && !AvatarState.isAvatarState(player)) {
        remove();
        return;
      }
      bPlayer.addCooldown(""String_Node_Str"",cooldown);
      direction=player.getEyeLocation().getDirection().normalize();
      origin=player.getLocation().add(direction.clone().multiply(10));
    }
    if (progressCounter < 8)     return;
    if (destination == null) {
      destination=player.getLocation().add(player.getEyeLocation().getDirection().normalize().multiply(10));
      Vector origToDest=GeneralMethods.getDirection(origin,destination);
      for (double i=0; i < 30; i++) {
        Vector vec=GeneralMethods.getDirection(player.getLocation(),origin.clone().add(origToDest.clone().multiply(i / 30)));
        FireComboStream fs=new FireComboStream(null,vec,player.getLocation(),range,speed,""String_Node_Str"");
        fs.setDensity(1);
        fs.setSpread(0F);
        fs.setUseNewParticles(true);
        fs.setParticleEffect(AirMethods.getAirbendingParticles());
        fs.setCollides(false);
        fs.runTaskTimer(ProjectKorra.plugin,(long)(i / 2.5),1L);
        tasks.add(fs);
      }
    }
    manageAirVectors();
  }
}",0.9944382647385984
133986,"public double getDistanceTraveled(){
  return start.distance(end);
}","public double getDistanceTraveled(){
  if (start.getWorld() != end.getWorld()) {
    return 0;
  }
  return start.distance(end);
}",0.6868686868686869
133987,"@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),1,2)) {
    return;
  }
  Player player=Bukkit.getPlayer(args.get(0));
  if (player == null) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
    bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  }
  if (args.size() == 2) {
    if (Element.getType(args.get(1)) != null) {
      bPlayer.getElements().remove(Element.getType(args.get(1)));
      GeneralMethods.removeUnusableAbilities(player.getName());
      if (Element.getType(args.get(1)) == Element.Chi) {
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + args.get(1).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ player.getName());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + args.get(1).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
 else {
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + args.get(1).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ player.getName());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + args.get(1).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
      Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,Element.getType(args.get(1)),Result.REMOVE));
      return;
    }
  }
  bPlayer.getElements().clear();
  GeneralMethods.saveElements(bPlayer);
  GeneralMethods.removeUnusableAbilities(player.getName());
  sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + ChatColor.DARK_AQUA+ player.getName());
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + ChatColor.DARK_AQUA+ sender.getName());
  Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,null,Result.REMOVE));
}","@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),1,2)) {
    return;
  }
  Player player=Bukkit.getPlayer(args.get(0));
  if (player == null) {
    Element e=Element.getType(getElement(args.get(0)));
    if (e != null && sender instanceof Player) {
      if (GeneralMethods.getBendingPlayer(sender.getName()).hasElement(e)) {
        GeneralMethods.getBendingPlayer(sender.getName()).getElements().remove(e);
        GeneralMethods.saveElements(GeneralMethods.getBendingPlayer(sender.getName()));
        GeneralMethods.removeUnusableAbilities(sender.getName());
        if (e == Element.Chi) {
          sender.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"");
          return;
        }
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + e.toString().toLowerCase()+ ""String_Node_Str"");
        return;
      }
 else {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return;
      }
    }
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  if (bPlayer == null) {
    GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
    bPlayer=GeneralMethods.getBendingPlayer(player.getName());
  }
  if (args.size() == 2) {
    Element e=Element.getType(getElement(args.get(1)));
    if (e != null) {
      if (!bPlayer.hasElement(e)) {
        sender.sendMessage(ChatColor.DARK_RED + ""String_Node_Str"");
        return;
      }
      bPlayer.getElements().remove(e);
      GeneralMethods.saveElements(bPlayer);
      GeneralMethods.removeUnusableAbilities(player.getName());
      if (e == Element.Chi) {
        sender.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"" + ChatColor.DARK_AQUA+ player.getName());
        player.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"" + ChatColor.DARK_AQUA+ sender.getName());
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + getElement(args.get(1)).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ player.getName());
        player.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + getElement(args.get(1)).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
      Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,e,Result.REMOVE));
      return;
    }
  }
 else   if (args.size() == 1) {
    bPlayer.getElements().clear();
    GeneralMethods.saveElements(bPlayer);
    GeneralMethods.removeUnusableAbilities(player.getName());
    sender.sendMessage(ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.DARK_AQUA+ player.getName());
    player.sendMessage(ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.DARK_AQUA+ sender.getName());
    Bukkit.getServer().getPluginManager().callEvent(new PlayerChangeElementEvent(sender,player,null,Result.REMOVE));
  }
}",0.6627288836385116
133988,"@Override public void execute(CommandSender sender,List<String> args){
  if (!correctLength(sender,args.size(),0,2)) {
    return;
  }
 else   if (args.size() == 0) {
    if (!hasPermission(sender) || !isPlayer(sender)) {
      return;
    }
    if (Commands.isToggledForAll) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(sender.getName());
    if (bPlayer == null) {
      GeneralMethods.createBendingPlayer(((Player)sender).getUniqueId(),sender.getName());
      bPlayer=GeneralMethods.getBendingPlayer(sender.getName());
    }
    if (bPlayer.isToggled()) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      bPlayer.toggleBending();
    }
 else {
      sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      bPlayer.toggleBending();
    }
  }
 else   if (args.size() == 1 && args.get(0).equalsIgnoreCase(""String_Node_Str"") && hasPermission(sender,""String_Node_Str"")) {
    if (Commands.isToggledForAll) {
      Commands.isToggledForAll=false;
      for (      Player player : Bukkit.getOnlinePlayers()) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
      if (!(sender instanceof Player))       sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    }
 else {
      Commands.isToggledForAll=true;
      for (      Player player : Bukkit.getOnlinePlayers()) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
      if (!(sender instanceof Player))       sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
  }
 else   if (sender instanceof Player && args.size() == 1 && Element.getType(args.get(0)) != null && sender.hasPermission(""String_Node_Str"" + getElement(args.get(0)))) {
    Element e=Element.getType(getElement(args.get(0)));
    BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(sender.getName());
    bPlayer.toggleElement(e);
    if (bPlayer.isElementToggled(e) == false) {
      if (e == Element.Chi) {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str"");
      }
    }
 else {
      if (e == Element.Chi) {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str"");
      }
    }
  }
 else   if (sender instanceof Player && args.size() == 2 && Element.getType(args.get(0)) != null && sender.hasPermission(""String_Node_Str"" + getElement(args.get(0)))) {
    Player target=Bukkit.getPlayer(args.get(1));
    if (!hasAdminPermission(sender))     return;
    if (target == null) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    Element e=Element.getType(getElement(args.get(0)));
    BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(target.getName());
    if (bPlayer.isElementToggled(e) == true) {
      if (e == Element.Chi) {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str""+ args.get(0).toLowerCase()+ ""String_Node_Str"");
        target.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str""+ args.get(0).toLowerCase()+ ""String_Node_Str"");
        target.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
    }
 else {
      if (e == Element.Chi) {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str""+ args.get(0).toLowerCase()+ ""String_Node_Str"");
        target.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str""+ args.get(0).toLowerCase()+ ""String_Node_Str"");
        target.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + args.get(0).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
    }
    bPlayer.toggleElement(e);
  }
 else {
    help(sender,false);
  }
}","@Override public void execute(CommandSender sender,List<String> args){
  if (!correctLength(sender,args.size(),0,2)) {
    return;
  }
 else   if (args.size() == 0) {
    if (!hasPermission(sender) || !isPlayer(sender)) {
      return;
    }
    if (Commands.isToggledForAll) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(sender.getName());
    if (bPlayer == null) {
      GeneralMethods.createBendingPlayer(((Player)sender).getUniqueId(),sender.getName());
      bPlayer=GeneralMethods.getBendingPlayer(sender.getName());
    }
    if (bPlayer.isToggled()) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      bPlayer.toggleBending();
    }
 else {
      sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      bPlayer.toggleBending();
    }
  }
 else   if (args.size() == 1 && args.get(0).equalsIgnoreCase(""String_Node_Str"") && hasPermission(sender,""String_Node_Str"")) {
    if (Commands.isToggledForAll) {
      Commands.isToggledForAll=false;
      for (      Player player : Bukkit.getOnlinePlayers()) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
      if (!(sender instanceof Player))       sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    }
 else {
      Commands.isToggledForAll=true;
      for (      Player player : Bukkit.getOnlinePlayers()) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
      if (!(sender instanceof Player))       sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
  }
 else   if (sender instanceof Player && args.size() == 1 && Element.getType(getElement(args.get(0))) != null && GeneralMethods.getBendingPlayer(sender.getName()).hasElement(Element.getType(getElement(args.get(0))))) {
    Element e=Element.getType(getElement(args.get(0)));
    BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(sender.getName());
    bPlayer.toggleElement(e);
    if (bPlayer.isElementToggled(e) == false) {
      if (e == Element.Chi) {
        sender.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"");
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + getElement(args.get(0)).toLowerCase()+ ""String_Node_Str"");
      }
    }
 else {
      if (e == Element.Chi) {
        sender.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"");
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + getElement(args.get(0)).toLowerCase()+ ""String_Node_Str"");
      }
    }
  }
 else   if (sender instanceof Player && args.size() == 2 && Element.getType(getElement(args.get(0))) != null && GeneralMethods.getBendingPlayer(sender.getName()).hasElement(Element.getType(getElement(args.get(0))))) {
    Player target=Bukkit.getPlayer(args.get(1));
    if (!hasAdminPermission(sender))     return;
    if (target == null) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    Element e=Element.getType(getElement(args.get(0)));
    BendingPlayer bPlayer=GeneralMethods.getBendingPlayer(target.getName());
    if (bPlayer.isElementToggled(e) == true) {
      if (e == Element.Chi) {
        sender.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str"");
        target.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"" + ChatColor.DARK_AQUA+ sender.getName());
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str""+ getElement(args.get(0)).toLowerCase()+ ""String_Node_Str"");
        target.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + getElement(args.get(0)).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
    }
 else {
      if (e == Element.Chi) {
        sender.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str"");
        target.sendMessage(ChiMethods.getChiColor() + ""String_Node_Str"" + ChatColor.DARK_AQUA+ sender.getName());
      }
 else {
        sender.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + ChatColor.DARK_AQUA+ target.getName()+ ""String_Node_Str""+ getElement(args.get(0)).toLowerCase()+ ""String_Node_Str"");
        target.sendMessage(GeneralMethods.getElementColor(e) + ""String_Node_Str"" + getElement(args.get(0)).toLowerCase()+ ""String_Node_Str""+ ChatColor.DARK_AQUA+ sender.getName());
      }
    }
    bPlayer.toggleElement(e);
  }
 else {
    help(sender,false);
  }
}",0.7420996818663839
133989,"public static boolean isEarthbendable(Player player,String ability,Block block){
  Material material=block.getType();
  boolean valid=false;
  for (  String s : config.getStringList(""String_Node_Str""))   if (material == Material.getMaterial(s)) {
    valid=true;
    break;
  }
  if (isMetal(block) && canMetalbend(player)) {
    valid=true;
  }
  if (!valid)   return false;
  if (tempNoEarthbending.contains(block))   return false;
  if (!GeneralMethods.isRegionProtectedFromBuild(player,ability,block.getLocation()))   return true;
  return false;
}","public static boolean isEarthbendable(Player player,String ability,Block block){
  Material material=block.getType();
  boolean valid=false;
  for (  String s : config.getStringList(""String_Node_Str""))   if (material == Material.getMaterial(s)) {
    valid=true;
    break;
  }
  if (isMetal(block) && canMetalbend(player)) {
    valid=true;
  }
  if (tempNoEarthbending.contains(block))   valid=false;
  if (GeneralMethods.isRegionProtectedFromBuild(player,ability,block.getLocation()))   valid=false;
  return valid;
}",0.8973880597014925
133990,"/** 
 * Finds a valid Earth source for a Player. To use dynamic source selection, use BlockSource.getEarthSourceBlock() instead of this method. Dynamic source selection saves the user's previous source for future use.  {@link BlockSource#getEarthSourceBlock(Player,double,com.projectkorra.projectkorra.util.ClickType)}
 * @param player the player that is attempting to Earthbend.
 * @param range the maximum block selection range.
 * @return a valid Earth source block, or null if one could not be found.
 */
@SuppressWarnings(""String_Node_Str"") public static Block getEarthSourceBlock(Player player,double range){
  Block testblock=player.getTargetBlock(getTransparentEarthbending(),(int)range);
  if (isEarthbendable(player,testblock))   return testblock;
  Location location=player.getEyeLocation();
  Vector vector=location.getDirection().clone().normalize();
  for (double i=0; i <= range; i++) {
    Block block=location.clone().add(vector.clone().multiply(i)).getBlock();
    if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",location))     continue;
    if (isEarthbendable(player,block)) {
      return block;
    }
  }
  return null;
}","/** 
 * Finds a valid Earth source for a Player. To use dynamic source selection, use BlockSource.getEarthSourceBlock() instead of this method. Dynamic source selection saves the user's previous source for future use.  {@link BlockSource#getEarthSourceBlock(Player,double,com.projectkorra.projectkorra.util.ClickType)}
 * @param player the player that is attempting to Earthbend.
 * @param range the maximum block selection range.
 * @return a valid Earth source block, or null if one could not be found.
 */
@SuppressWarnings(""String_Node_Str"") public static Block getEarthSourceBlock(Player player,double range){
  Block testblock=player.getTargetBlock(getTransparentEarthbending(),(int)range);
  if (isEarthbendable(player,testblock) || isMetalbendable(player,testblock.getType()))   return testblock;
  Location location=player.getEyeLocation();
  Vector vector=location.getDirection().clone().normalize();
  for (double i=0; i <= range; i++) {
    Block block=location.clone().add(vector.clone().multiply(i)).getBlock();
    if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",location))     continue;
    if (isEarthbendable(player,block)) {
      return block;
    }
  }
  return null;
}",0.980243799915931
133991,"@SuppressWarnings(""String_Node_Str"") public void animateLift(){
  if (animCounter < 4) {
    revert();
    loc.add(0,1,0);
    if (animCounter == 0) {
      int totalBendableBlocks=0;
      for (int x=-1; x <= 1; x++)       for (int y=-2; y <= -1; y++)       for (int z=-1; z <= 1; z++) {
        Block block=loc.clone().add(x,y,z).getBlock();
        if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",block.getLocation())) {
          remove();
          return;
        }
        if (isEarthbendableMaterial(block.getType()))         totalBendableBlocks++;
      }
      if (totalBendableBlocks < REQUIRED_BENDABLE_BLOCKS) {
        remove();
        return;
      }
      for (int y=0; y <= 3; y++) {
        Block tempBlock=loc.clone().add(0,y,0).getBlock();
        if (!EarthMethods.isTransparentToEarthbending(player,tempBlock) && tempBlock.getType() != Material.AIR) {
          remove();
          return;
        }
      }
      Location tempLoc=loc.clone().add(0,-2,0);
      for (int x=-1; x <= 1; x++)       for (int y=-1; y <= 1; y++)       for (int z=-1; z <= 1; z++)       if ((Math.abs(x) + Math.abs(y) + Math.abs(z)) % 2 == 0) {
        Block block=tempLoc.clone().add(x,y,z).getBlock();
        currentBlocks.add(new BlockRepresenter(x,y,z,selectMaterialForRepresenter(block.getType()),block.getData()));
      }
      for (int x=-1; x <= 1; x++)       for (int z=-1; z <= 1; z++) {
        if ((Math.abs(x) + Math.abs(z)) % 2 == 1) {
          Block block=loc.clone().add(x,-2,z).getBlock();
          if (isEarthbendableMaterial(block.getType()))           EarthMethods.addTempAirBlock(block);
        }
        Block block=loc.clone().add(x,-1,z).getBlock();
        if (isEarthbendableMaterial(block.getType()))         EarthMethods.addTempAirBlock(block);
      }
      loc.add(0,-1,0);
    }
    List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(loc,2.5);
    for (    Entity entity : entities) {
      org.bukkit.util.Vector velocity=entity.getVelocity();
      entity.setVelocity(velocity.add(new Vector(0,0.36,0)));
    }
    loc.getWorld().playEffect(loc,Effect.GHAST_SHOOT,0,7);
    draw();
  }
 else {
    state=State.LIFTED;
  }
  animCounter++;
}","@SuppressWarnings(""String_Node_Str"") public void animateLift(){
  if (animCounter < 4) {
    revert();
    loc.add(0,1,0);
    if (animCounter == 0) {
      int totalBendableBlocks=0;
      for (int x=-1; x <= 1; x++)       for (int y=-2; y <= -1; y++)       for (int z=-1; z <= 1; z++) {
        Block block=loc.clone().add(x,y,z).getBlock();
        if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",block.getLocation())) {
          remove();
          return;
        }
        if (EarthMethods.isEarthbendable(player,block))         totalBendableBlocks++;
      }
      if (totalBendableBlocks < REQUIRED_BENDABLE_BLOCKS) {
        remove();
        return;
      }
      for (int y=0; y <= 3; y++) {
        Block tempBlock=loc.clone().add(0,y,0).getBlock();
        if (!EarthMethods.isTransparentToEarthbending(player,tempBlock) && tempBlock.getType() != Material.AIR) {
          remove();
          return;
        }
      }
      Location tempLoc=loc.clone().add(0,-2,0);
      for (int x=-1; x <= 1; x++)       for (int y=-1; y <= 1; y++)       for (int z=-1; z <= 1; z++)       if ((Math.abs(x) + Math.abs(y) + Math.abs(z)) % 2 == 0) {
        Block block=tempLoc.clone().add(x,y,z).getBlock();
        currentBlocks.add(new BlockRepresenter(x,y,z,selectMaterialForRepresenter(block.getType()),block.getData()));
      }
      for (int x=-1; x <= 1; x++)       for (int z=-1; z <= 1; z++) {
        if ((Math.abs(x) + Math.abs(z)) % 2 == 1) {
          Block block=loc.clone().add(x,-2,z).getBlock();
          if (EarthMethods.isEarthbendable(player,block))           EarthMethods.addTempAirBlock(block);
        }
        Block block=loc.clone().add(x,-1,z).getBlock();
        if (EarthMethods.isEarthbendable(player,block))         EarthMethods.addTempAirBlock(block);
      }
      loc.add(0,-1,0);
    }
    List<Entity> entities=GeneralMethods.getEntitiesAroundPoint(loc,2.5);
    for (    Entity entity : entities) {
      org.bukkit.util.Vector velocity=entity.getVelocity();
      entity.setVelocity(velocity.add(new Vector(0,0.36,0)));
    }
    loc.getWorld().playEffect(loc,Effect.GHAST_SHOOT,0,7);
    draw();
  }
 else {
    state=State.LIFTED;
  }
  animCounter++;
}",0.9552643470402168
133992,"/** 
 * Switches the Sand Material and Gravel to SandStone and stone respectively, since gravel and sand cannot be bent due to gravity.
 */
public Material selectMaterialForRepresenter(Material mat){
  Material tempMat=selectMaterial(mat);
  Random rand=new Random();
  if (!isEarthbendableMaterial(tempMat)) {
    if (currentBlocks.size() < 1)     return Material.DIRT;
 else     return currentBlocks.get(rand.nextInt(currentBlocks.size())).getType();
  }
  return tempMat;
}","/** 
 * Switches the Sand Material and Gravel to SandStone and stone respectively, since gravel and sand cannot be bent due to gravity.
 */
public Material selectMaterialForRepresenter(Material mat){
  Material tempMat=selectMaterial(mat);
  Random rand=new Random();
  if (!EarthMethods.isEarthbendable(tempMat) || !EarthMethods.isMetalbendable(player,tempMat)) {
    if (currentBlocks.size() < 1)     return Material.DIRT;
 else     return currentBlocks.get(rand.nextInt(currentBlocks.size())).getType();
  }
  return tempMat;
}",0.9085487077534792
133993,"private void fill(){
  for (  StockAbility a : StockAbility.values()) {
    if (StockAbility.isAirbending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        airbendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.AirScooter)         harmlessabilities.add(a.name());
        if (a == StockAbility.AirSpout)         harmlessabilities.add(a.name());
        if (a == StockAbility.Tornado)         shiftabilities.add(a.name());
        if (a == StockAbility.AirSuction)         shiftabilities.add(a.name());
        if (a == StockAbility.AirSwipe)         shiftabilities.add(a.name());
        if (a == StockAbility.AirBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.AirBurst)         shiftabilities.add(a.name());
        if (a == StockAbility.AirShield)         shiftabilities.add(a.name());
        if (a == StockAbility.Flight)         shiftabilities.add(a.name());
        if (a == StockAbility.Flight)         subabilities.add(a.name());
        if (a == StockAbility.Flight)         flightabilities.add(a.name());
      }
    }
 else     if (StockAbility.isWaterbending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        waterbendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.WaterSpout)         harmlessabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         harmlessabilities.add(a.name());
        if (a == StockAbility.Surge)         shiftabilities.add(a.name());
        if (a == StockAbility.Bloodbending)         shiftabilities.add(a.name());
        if (a == StockAbility.PhaseChange)         shiftabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         shiftabilities.add(a.name());
        if (a == StockAbility.OctopusForm)         shiftabilities.add(a.name());
        if (a == StockAbility.Torrent)         shiftabilities.add(a.name());
        if (a == StockAbility.WaterManipulation)         shiftabilities.add(a.name());
        if (a == StockAbility.IceSpike)         shiftabilities.add(a.name());
        if (a == StockAbility.IceBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.WaterArms)         shiftabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         subabilities.add(a.name());
        if (a == StockAbility.Bloodbending)         subabilities.add(a.name());
        if (a == StockAbility.PhaseChange)         subabilities.add(a.name());
        if (a == StockAbility.IceSpike)         subabilities.add(a.name());
        if (a == StockAbility.IceBlast)         subabilities.add(a.name());
        if (a == StockAbility.PlantArmor)         subabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         healingabilities.add(a.name());
        if (a == StockAbility.Bloodbending)         bloodabilities.add(a.name());
        if (a == StockAbility.PhaseChange)         iceabilities.add(a.name());
        if (a == StockAbility.IceSpike)         iceabilities.add(a.name());
        if (a == StockAbility.IceBlast)         iceabilities.add(a.name());
        if (a == StockAbility.PlantArmor)         plantabilities.add(a.name());
      }
    }
 else     if (StockAbility.isEarthbending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        earthbendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.Tremorsense)         harmlessabilities.add(a.name());
        if (a == StockAbility.RaiseEarth)         shiftabilities.add(a.name());
        if (a == StockAbility.Collapse)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.Shockwave)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthTunnel)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthGrab)         shiftabilities.add(a.name());
        if (a == StockAbility.LavaFlow)         shiftabilities.add(a.name());
        if (a == StockAbility.MetalClips)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthSmash)         shiftabilities.add(a.name());
        if (a == StockAbility.SandSpout)         shiftabilities.add(a.name());
        if (a == StockAbility.MetalClips)         subabilities.add(a.name());
        if (a == StockAbility.Extraction)         subabilities.add(a.name());
        if (a == StockAbility.LavaFlow)         subabilities.add(a.name());
        if (a == StockAbility.SandSpout)         subabilities.add(a.name());
        if (a == StockAbility.MetalClips)         metalabilities.add(a.name());
        if (a == StockAbility.Extraction)         metalabilities.add(a.name());
        if (a == StockAbility.LavaFlow)         lavaabilities.add(a.name());
        if (a == StockAbility.SandSpout)         sandabilities.add(a.name());
      }
    }
 else     if (StockAbility.isFirebending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        firebendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.Illumination)         harmlessabilities.add(a.name());
        if (a == StockAbility.Blaze)         igniteabilities.add(a.name());
        if (a == StockAbility.FireBlast)         explodeabilities.add(a.name());
        if (a == StockAbility.Lightning)         explodeabilities.add(a.name());
        if (a == StockAbility.Combustion)         explodeabilities.add(a.name());
        if (a == StockAbility.HeatControl)         shiftabilities.add(a.name());
        if (a == StockAbility.Lightning)         shiftabilities.add(a.name());
        if (a == StockAbility.FireBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.Blaze)         shiftabilities.add(a.name());
        if (a == StockAbility.FireBurst)         shiftabilities.add(a.name());
        if (a == StockAbility.Lightning)         subabilities.add(a.name());
        if (a == StockAbility.Combustion)         subabilities.add(a.name());
        if (a == StockAbility.Lightning)         lightningabilities.add(a.name());
        if (a == StockAbility.Combustion)         combustionabilities.add(a.name());
      }
    }
 else     if (StockAbility.isChiBlocking(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        chiabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.HighJump)         harmlessabilities.add(a.name());
      }
    }
 else {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
      }
    }
  }
  for (  AbilityModule ab : ability) {
    try {
      boolean succes=true;
      for (      String enabledAbility : abilities) {
        if (enabledAbility.equalsIgnoreCase(ab.getName())) {
          succes=false;
        }
      }
      if (!succes)       continue;
      ab.onThisLoad();
      abilities.add(ab.getName());
      for (      StockAbility a : StockAbility.values()) {
        if (a.name().equalsIgnoreCase(ab.getName())) {
          disabledStockAbilities.add(a.name());
        }
      }
      if (ab.getElement() == Element.Air.toString())       airbendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Water.toString())       waterbendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Earth.toString())       earthbendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Fire.toString())       firebendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Chi.toString())       chiabilities.add(ab.getName());
      if (ab.isShiftAbility())       shiftabilities.add(ab.getName());
      if (ab.isHarmlessAbility())       harmlessabilities.add(ab.getName());
      if (ab.getSubElement() != null) {
        subabilities.add(ab.getName());
switch (ab.getSubElement()) {
case Bloodbending:
          bloodabilities.add(ab.getName());
        break;
case Combustion:
      combustionabilities.add(ab.getName());
    break;
case Flight:
  flightabilities.add(ab.getName());
break;
case Healing:
healingabilities.add(ab.getName());
break;
case Icebending:
iceabilities.add(ab.getName());
break;
case Lavabending:
lavaabilities.add(ab.getName());
break;
case Lightning:
lightningabilities.add(ab.getName());
break;
case Metalbending:
metalabilities.add(ab.getName());
break;
case Plantbending:
plantabilities.add(ab.getName());
break;
case Sandbending:
sandabilities.add(ab.getName());
break;
case SpiritualProjection:
spiritualprojectionabilities.add(ab.getName());
break;
}
}
descriptions.put(ab.getName(),ab.getDescription());
authors.put(ab.getName(),ab.getAuthor());
}
 catch (Exception|Error e) {
ProjectKorra.log.warning(""String_Node_Str"" + ab.getName() + ""String_Node_Str"");
e.printStackTrace();
ab.stop();
abilities.remove(ab.getName());
final AbilityModule skill=ab;
plugin.getServer().getScheduler().scheduleSyncDelayedTask(plugin,new Runnable(){
public void run(){
ability.remove(skill);
}
}
,10);
continue;
}
}
for (Field field : this.getClass().getDeclaredFields()) {
if (List.class.isAssignableFrom(field.getType())) {
try {
Collections.sort((List)field.get(this));
}
 catch (Exception e) {
e.printStackTrace();
}
}
}
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void fill(){
  for (  StockAbility a : StockAbility.values()) {
    if (StockAbility.isAirbending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        airbendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.AirScooter)         harmlessabilities.add(a.name());
        if (a == StockAbility.AirSpout)         harmlessabilities.add(a.name());
        if (a == StockAbility.Tornado)         shiftabilities.add(a.name());
        if (a == StockAbility.AirSuction)         shiftabilities.add(a.name());
        if (a == StockAbility.AirSwipe)         shiftabilities.add(a.name());
        if (a == StockAbility.AirBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.AirBurst)         shiftabilities.add(a.name());
        if (a == StockAbility.AirShield)         shiftabilities.add(a.name());
        if (a == StockAbility.Flight)         shiftabilities.add(a.name());
        if (a == StockAbility.Flight)         subabilities.add(a.name());
        if (a == StockAbility.Flight)         flightabilities.add(a.name());
      }
    }
 else     if (StockAbility.isWaterbending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        waterbendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.WaterSpout)         harmlessabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         harmlessabilities.add(a.name());
        if (a == StockAbility.Surge)         shiftabilities.add(a.name());
        if (a == StockAbility.Bloodbending)         shiftabilities.add(a.name());
        if (a == StockAbility.PhaseChange)         shiftabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         shiftabilities.add(a.name());
        if (a == StockAbility.OctopusForm)         shiftabilities.add(a.name());
        if (a == StockAbility.Torrent)         shiftabilities.add(a.name());
        if (a == StockAbility.WaterManipulation)         shiftabilities.add(a.name());
        if (a == StockAbility.IceSpike)         shiftabilities.add(a.name());
        if (a == StockAbility.IceBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.WaterArms)         shiftabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         subabilities.add(a.name());
        if (a == StockAbility.Bloodbending)         subabilities.add(a.name());
        if (a == StockAbility.PhaseChange)         subabilities.add(a.name());
        if (a == StockAbility.IceSpike)         subabilities.add(a.name());
        if (a == StockAbility.IceBlast)         subabilities.add(a.name());
        if (a == StockAbility.PlantArmor)         subabilities.add(a.name());
        if (a == StockAbility.HealingWaters)         healingabilities.add(a.name());
        if (a == StockAbility.Bloodbending)         bloodabilities.add(a.name());
        if (a == StockAbility.PhaseChange)         iceabilities.add(a.name());
        if (a == StockAbility.IceSpike)         iceabilities.add(a.name());
        if (a == StockAbility.IceBlast)         iceabilities.add(a.name());
        if (a == StockAbility.PlantArmor)         plantabilities.add(a.name());
      }
    }
 else     if (StockAbility.isEarthbending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        earthbendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.Tremorsense)         harmlessabilities.add(a.name());
        if (a == StockAbility.RaiseEarth)         shiftabilities.add(a.name());
        if (a == StockAbility.Collapse)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.Shockwave)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthTunnel)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthGrab)         shiftabilities.add(a.name());
        if (a == StockAbility.LavaFlow)         shiftabilities.add(a.name());
        if (a == StockAbility.MetalClips)         shiftabilities.add(a.name());
        if (a == StockAbility.EarthSmash)         shiftabilities.add(a.name());
        if (a == StockAbility.SandSpout)         shiftabilities.add(a.name());
        if (a == StockAbility.MetalClips)         subabilities.add(a.name());
        if (a == StockAbility.Extraction)         subabilities.add(a.name());
        if (a == StockAbility.LavaFlow)         subabilities.add(a.name());
        if (a == StockAbility.SandSpout)         subabilities.add(a.name());
        if (a == StockAbility.MetalClips)         metalabilities.add(a.name());
        if (a == StockAbility.Extraction)         metalabilities.add(a.name());
        if (a == StockAbility.LavaFlow)         lavaabilities.add(a.name());
        if (a == StockAbility.SandSpout)         sandabilities.add(a.name());
      }
    }
 else     if (StockAbility.isFirebending(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        firebendingabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.Illumination)         harmlessabilities.add(a.name());
        if (a == StockAbility.Blaze)         igniteabilities.add(a.name());
        if (a == StockAbility.FireBlast)         explodeabilities.add(a.name());
        if (a == StockAbility.Lightning)         explodeabilities.add(a.name());
        if (a == StockAbility.Combustion)         explodeabilities.add(a.name());
        if (a == StockAbility.HeatControl)         shiftabilities.add(a.name());
        if (a == StockAbility.Lightning)         shiftabilities.add(a.name());
        if (a == StockAbility.FireBlast)         shiftabilities.add(a.name());
        if (a == StockAbility.Blaze)         shiftabilities.add(a.name());
        if (a == StockAbility.FireBurst)         shiftabilities.add(a.name());
        if (a == StockAbility.Lightning)         subabilities.add(a.name());
        if (a == StockAbility.Combustion)         subabilities.add(a.name());
        if (a == StockAbility.Lightning)         lightningabilities.add(a.name());
        if (a == StockAbility.Combustion)         combustionabilities.add(a.name());
      }
    }
 else     if (StockAbility.isChiBlocking(a)) {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        chiabilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
        if (a == StockAbility.HighJump)         harmlessabilities.add(a.name());
      }
    }
 else {
      if (ProjectKorra.plugin.getConfig().getBoolean(""String_Node_Str"" + a.name() + ""String_Node_Str"")) {
        abilities.add(a.name());
        descriptions.put(a.name(),ProjectKorra.plugin.getConfig().getString(""String_Node_Str"" + a.name() + ""String_Node_Str""));
      }
    }
  }
  for (  AbilityModule ab : ability) {
    try {
      boolean succes=true;
      for (      String enabledAbility : abilities) {
        if (enabledAbility.equalsIgnoreCase(ab.getName())) {
          succes=false;
        }
      }
      if (!succes)       continue;
      ab.onThisLoad();
      abilities.add(ab.getName());
      for (      StockAbility a : StockAbility.values()) {
        if (a.name().equalsIgnoreCase(ab.getName())) {
          disabledStockAbilities.add(a.name());
        }
      }
      if (ab.getElement() == Element.Air.toString())       airbendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Water.toString())       waterbendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Earth.toString())       earthbendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Fire.toString())       firebendingabilities.add(ab.getName());
      if (ab.getElement() == Element.Chi.toString())       chiabilities.add(ab.getName());
      if (ab.isShiftAbility())       shiftabilities.add(ab.getName());
      if (ab.isHarmlessAbility())       harmlessabilities.add(ab.getName());
      if (ab.getSubElement() != null) {
        subabilities.add(ab.getName());
switch (ab.getSubElement()) {
case Bloodbending:
          bloodabilities.add(ab.getName());
        break;
case Combustion:
      combustionabilities.add(ab.getName());
    break;
case Flight:
  flightabilities.add(ab.getName());
break;
case Healing:
healingabilities.add(ab.getName());
break;
case Icebending:
iceabilities.add(ab.getName());
break;
case Lavabending:
lavaabilities.add(ab.getName());
break;
case Lightning:
lightningabilities.add(ab.getName());
break;
case Metalbending:
metalabilities.add(ab.getName());
break;
case Plantbending:
plantabilities.add(ab.getName());
break;
case Sandbending:
sandabilities.add(ab.getName());
break;
case SpiritualProjection:
spiritualprojectionabilities.add(ab.getName());
break;
}
}
descriptions.put(ab.getName(),ab.getDescription());
authors.put(ab.getName(),ab.getAuthor());
}
 catch (Exception|Error e) {
ProjectKorra.log.warning(""String_Node_Str"" + ab.getName() + ""String_Node_Str"");
e.printStackTrace();
ab.stop();
abilities.remove(ab.getName());
final AbilityModule skill=ab;
plugin.getServer().getScheduler().scheduleSyncDelayedTask(plugin,new Runnable(){
public void run(){
ability.remove(skill);
}
}
,10);
continue;
}
}
for (Field field : this.getClass().getDeclaredFields()) {
if (List.class.isAssignableFrom(field.getType())) {
try {
Collections.sort((List)field.get(this));
}
 catch (Exception e) {
e.printStackTrace();
}
}
}
}",0.9972438470093322
133994,"public ChiCombo(Player player,String ability){
  if (!enabled)   return;
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (!GeneralMethods.canBend(player.getName(),""String_Node_Str"") || GeneralMethods.getBendingPlayer(player).isOnCooldown(""String_Node_Str""))     return;
 else {
      this.player=player;
      target=GeneralMethods.getTargetedEntity(player,5,new ArrayList<Entity>());
      paralyze(target,IMMOBILIZE_DURATION);
      instances.add(this);
      GeneralMethods.getBendingPlayer(player).addCooldown(""String_Node_Str"",IMMOBILIZE_COOLDOWN);
    }
  }
}","public ChiCombo(Player player,String ability){
  if (!enabled)   return;
  if (ability.equalsIgnoreCase(""String_Node_Str"")) {
    if (!GeneralMethods.canBend(player.getName(),""String_Node_Str"") || GeneralMethods.getBendingPlayer(player).isOnCooldown(""String_Node_Str""))     return;
 else {
      target=GeneralMethods.getTargetedEntity(player,5,new ArrayList<Entity>());
      paralyze(target,IMMOBILIZE_DURATION);
      instances.add(this);
      GeneralMethods.getBendingPlayer(player).addCooldown(""String_Node_Str"",IMMOBILIZE_COOLDOWN);
    }
  }
}",0.9769503546099292
133995,"@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),0,0)) {
    return;
  }
 else   if (!GeneralMethods.isImportEnabled()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
  File bendingPlayersFile=new File(""String_Node_Str"",""String_Node_Str"");
  FileConfiguration bendingPlayers=YamlConfiguration.loadConfiguration(bendingPlayersFile);
  final LinkedList<BendingPlayer> bPlayers=new LinkedList<BendingPlayer>();
  for (  String string : bendingPlayers.getConfigurationSection(""String_Node_Str"").getKeys(false)) {
    if (string.equalsIgnoreCase(""String_Node_Str""))     continue;
    String playername=string;
    UUID uuid=ProjectKorra.plugin.getServer().getOfflinePlayer(playername).getUniqueId();
    ArrayList<Element> element=new ArrayList<Element>();
    List<Integer> oe=bendingPlayers.getIntegerList(string + ""String_Node_Str"");
    HashMap<Integer,String> abilities=new HashMap<Integer,String>();
    List<Integer> oa=bendingPlayers.getIntegerList(string + ""String_Node_Str"");
    boolean permaremoved=bendingPlayers.getBoolean(string + ""String_Node_Str"");
    int slot=1;
    for (    int i : oa) {
      if (StockAbility.getAbility(i) != null) {
        abilities.put(slot,StockAbility.getAbility(i).toString());
        slot++;
      }
 else {
        abilities.put(slot,null);
        slot++;
      }
    }
    for (    int i : oe) {
      if (Element.getType(i) != null) {
        element.add(Element.getType(i));
      }
    }
    BendingPlayer bPlayer=new BendingPlayer(uuid,playername,element,abilities,permaremoved);
    bPlayers.add(bPlayer);
  }
  final CommandSender s=sender;
  final int total=bPlayers.size();
  sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
  if (debugEnabled) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
  }
  importTask=Bukkit.getServer().getScheduler().runTaskTimerAsynchronously(ProjectKorra.plugin,new Runnable(){
    public void run(){
      int i=0;
      if (i >= 10) {
        s.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + total+ ""String_Node_Str"");
        return;
      }
      while (i < 10) {
        if (bPlayers.isEmpty()) {
          s.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
          Bukkit.getServer().getScheduler().cancelTask(importTask.getTaskId());
          ProjectKorra.plugin.getConfig().set(""String_Node_Str"",false);
          ProjectKorra.plugin.saveConfig();
          for (          Player player : Bukkit.getOnlinePlayers()) {
            GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
          }
          return;
        }
        StringBuilder elements=new StringBuilder();
        BendingPlayer bPlayer=bPlayers.pop();
        if (bPlayer.hasElement(Element.Air))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Water))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Earth))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Fire))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Chi))         elements.append(""String_Node_Str"");
        HashMap<Integer,String> abilities=bPlayer.getAbilities();
        ResultSet rs2=DBConnection.sql.readQuery(""String_Node_Str"" + bPlayer.getUUIDString() + ""String_Node_Str"");
        try {
          if (rs2.next()) {
            DBConnection.sql.modifyQuery(""String_Node_Str"" + bPlayer.getName() + ""String_Node_Str""+ bPlayer.getUUIDString());
            DBConnection.sql.modifyQuery(""String_Node_Str"" + elements + ""String_Node_Str""+ bPlayer.getUUIDString());
            DBConnection.sql.modifyQuery(""String_Node_Str"" + bPlayer.isPermaRemoved() + ""String_Node_Str""+ bPlayer.getUUIDString());
            for (int slot=1; slot < 10; slot++) {
              DBConnection.sql.modifyQuery(""String_Node_Str"" + slot + ""String_Node_Str""+ abilities.get(slot)+ ""String_Node_Str""+ bPlayer.getName()+ ""String_Node_Str"");
            }
          }
 else {
            DBConnection.sql.modifyQuery(""String_Node_Str"" + bPlayer.getUUIDString() + ""String_Node_Str""+ bPlayer.getName()+ ""String_Node_Str""+ elements+ ""String_Node_Str""+ bPlayer.isPermaRemoved()+ ""String_Node_Str"");
            for (int slot=1; slot < 10; slot++) {
              DBConnection.sql.modifyQuery(""String_Node_Str"" + slot + ""String_Node_Str""+ abilities.get(slot)+ ""String_Node_Str""+ bPlayer.getName()+ ""String_Node_Str"");
            }
          }
        }
 catch (        SQLException ex) {
          ex.printStackTrace();
        }
        i++;
        if (debugEnabled) {
          System.out.println(""String_Node_Str"" + bPlayer.getName() + ""String_Node_Str""+ bPlayers.size()+ ""String_Node_Str"");
        }
      }
    }
  }
,0,40);
}","@Override public void execute(CommandSender sender,List<String> args){
  if (!hasPermission(sender) || !correctLength(sender,args.size(),0,0)) {
    return;
  }
 else   if (!GeneralMethods.isImportEnabled()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
  File bendingPlayersFile=new File(""String_Node_Str"",""String_Node_Str"");
  FileConfiguration bendingPlayers=YamlConfiguration.loadConfiguration(bendingPlayersFile);
  final LinkedList<BendingPlayer> bPlayers=new LinkedList<BendingPlayer>();
  for (  String string : bendingPlayers.getConfigurationSection(""String_Node_Str"").getKeys(false)) {
    if (string.equalsIgnoreCase(""String_Node_Str""))     continue;
    String playername=string;
    @SuppressWarnings(""String_Node_Str"") UUID uuid=ProjectKorra.plugin.getServer().getOfflinePlayer(playername).getUniqueId();
    ArrayList<Element> element=new ArrayList<Element>();
    List<Integer> oe=bendingPlayers.getIntegerList(string + ""String_Node_Str"");
    HashMap<Integer,String> abilities=new HashMap<Integer,String>();
    List<Integer> oa=bendingPlayers.getIntegerList(string + ""String_Node_Str"");
    boolean permaremoved=bendingPlayers.getBoolean(string + ""String_Node_Str"");
    int slot=1;
    for (    int i : oa) {
      if (StockAbility.getAbility(i) != null) {
        abilities.put(slot,StockAbility.getAbility(i).toString());
        slot++;
      }
 else {
        abilities.put(slot,null);
        slot++;
      }
    }
    for (    int i : oe) {
      if (Element.getType(i) != null) {
        element.add(Element.getType(i));
      }
    }
    BendingPlayer bPlayer=new BendingPlayer(uuid,playername,element,abilities,permaremoved);
    bPlayers.add(bPlayer);
  }
  final CommandSender s=sender;
  final int total=bPlayers.size();
  sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
  if (debugEnabled) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
  }
  importTask=Bukkit.getServer().getScheduler().runTaskTimerAsynchronously(ProjectKorra.plugin,new Runnable(){
    public void run(){
      int i=0;
      if (i >= 10) {
        s.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + total+ ""String_Node_Str"");
        return;
      }
      while (i < 10) {
        if (bPlayers.isEmpty()) {
          s.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
          Bukkit.getServer().getScheduler().cancelTask(importTask.getTaskId());
          ProjectKorra.plugin.getConfig().set(""String_Node_Str"",false);
          ProjectKorra.plugin.saveConfig();
          for (          Player player : Bukkit.getOnlinePlayers()) {
            GeneralMethods.createBendingPlayer(player.getUniqueId(),player.getName());
          }
          return;
        }
        StringBuilder elements=new StringBuilder();
        BendingPlayer bPlayer=bPlayers.pop();
        if (bPlayer.hasElement(Element.Air))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Water))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Earth))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Fire))         elements.append(""String_Node_Str"");
        if (bPlayer.hasElement(Element.Chi))         elements.append(""String_Node_Str"");
        HashMap<Integer,String> abilities=bPlayer.getAbilities();
        ResultSet rs2=DBConnection.sql.readQuery(""String_Node_Str"" + bPlayer.getUUIDString() + ""String_Node_Str"");
        try {
          if (rs2.next()) {
            DBConnection.sql.modifyQuery(""String_Node_Str"" + bPlayer.getName() + ""String_Node_Str""+ bPlayer.getUUIDString());
            DBConnection.sql.modifyQuery(""String_Node_Str"" + elements + ""String_Node_Str""+ bPlayer.getUUIDString());
            DBConnection.sql.modifyQuery(""String_Node_Str"" + bPlayer.isPermaRemoved() + ""String_Node_Str""+ bPlayer.getUUIDString());
            for (int slot=1; slot < 10; slot++) {
              DBConnection.sql.modifyQuery(""String_Node_Str"" + slot + ""String_Node_Str""+ abilities.get(slot)+ ""String_Node_Str""+ bPlayer.getName()+ ""String_Node_Str"");
            }
          }
 else {
            DBConnection.sql.modifyQuery(""String_Node_Str"" + bPlayer.getUUIDString() + ""String_Node_Str""+ bPlayer.getName()+ ""String_Node_Str""+ elements+ ""String_Node_Str""+ bPlayer.isPermaRemoved()+ ""String_Node_Str"");
            for (int slot=1; slot < 10; slot++) {
              DBConnection.sql.modifyQuery(""String_Node_Str"" + slot + ""String_Node_Str""+ abilities.get(slot)+ ""String_Node_Str""+ bPlayer.getName()+ ""String_Node_Str"");
            }
          }
        }
 catch (        SQLException ex) {
          ex.printStackTrace();
        }
        i++;
        if (debugEnabled) {
          System.out.println(""String_Node_Str"" + bPlayer.getName() + ""String_Node_Str""+ bPlayers.size()+ ""String_Node_Str"");
        }
      }
    }
  }
,0,40);
}",0.9962333299399369
133996,"private void focusBlock(){
  if (EarthPassive.isPassiveSand(sourceblock))   EarthPassive.revertSand(sourceblock);
  if (sourceblock.getType() == Material.SAND) {
    sourcetype=Material.SAND;
    if (sourceblock.getData() == (byte)0x1) {
      sourceblock.setType(Material.RED_SANDSTONE);
    }
 else {
      sourceblock.setType(Material.SANDSTONE);
    }
  }
 else   if (sourceblock.getType() == Material.STONE) {
    sourceblock.setType(Material.COBBLESTONE);
    sourcetype=Material.STONE;
  }
 else {
    sourcetype=sourceblock.getType();
    sourceblock.setType(Material.STONE);
  }
  location=sourceblock.getLocation();
}","@SuppressWarnings(""String_Node_Str"") private void focusBlock(){
  if (EarthPassive.isPassiveSand(sourceblock))   EarthPassive.revertSand(sourceblock);
  if (sourceblock.getType() == Material.SAND) {
    sourcetype=Material.SAND;
    if (sourceblock.getData() == (byte)0x1) {
      sourceblock.setType(Material.RED_SANDSTONE);
    }
 else {
      sourceblock.setType(Material.SANDSTONE);
    }
  }
 else   if (sourceblock.getType() == Material.STONE) {
    sourceblock.setType(Material.COBBLESTONE);
    sourcetype=Material.STONE;
  }
 else {
    sourcetype=sourceblock.getType();
    sourceblock.setType(Material.STONE);
  }
  location=sourceblock.getLocation();
}",0.9713400464756003
133997,"private void unfocusBlock(){
  if (destination != null) {
    breakBlock();
    return;
  }
  if (sourceblock.getType() == Material.SAND) {
    if (sourceblock.getData() == (byte)0x1) {
      sourceblock.setType(sourcetype);
      sourceblock.setData((byte)0x1);
    }
 else {
      sourceblock.setType(sourcetype);
    }
  }
 else {
    sourceblock.setType(sourcetype);
  }
  instances.remove(id);
}","@SuppressWarnings(""String_Node_Str"") private void unfocusBlock(){
  if (destination != null) {
    breakBlock();
    return;
  }
  if (sourceblock.getType() == Material.SAND) {
    if (sourceblock.getData() == (byte)0x1) {
      sourceblock.setType(sourcetype);
      sourceblock.setData((byte)0x1);
    }
 else {
      sourceblock.setType(sourcetype);
    }
  }
 else {
    sourceblock.setType(sourcetype);
  }
  instances.remove(id);
}",0.955794504181601
133998,"private boolean progress(){
  if (player.isDead() || !player.isOnline() || !GeneralMethods.canBend(player.getName(),""String_Node_Str"")) {
    breakBlock();
    return false;
  }
  if (System.currentTimeMillis() - time >= interval) {
    time=System.currentTimeMillis();
    if (falling) {
      breakBlock();
      return false;
    }
    if (!EarthMethods.isEarthbendable(player,sourceblock) && sourceblock.getType() != Material.COBBLESTONE) {
      instances.remove(id);
      return false;
    }
    if (!progressing && !falling) {
      if (GeneralMethods.getBoundAbility(player) == null) {
        unfocusBlock();
        return false;
      }
      if (!GeneralMethods.getBoundAbility(player).equalsIgnoreCase(""String_Node_Str"")) {
        unfocusBlock();
        return false;
      }
      if (sourceblock == null) {
        instances.remove(id);
        return false;
      }
      if (!player.getWorld().equals(sourceblock.getWorld())) {
        unfocusBlock();
        return false;
      }
      if (sourceblock.getLocation().distance(player.getLocation()) > preparerange) {
        unfocusBlock();
        return false;
      }
    }
    if (falling) {
      breakBlock();
    }
 else {
      if (!progressing) {
        return false;
      }
      if (sourceblock.getY() == firstdestination.getBlockY())       settingup=false;
      Vector direction;
      if (settingup) {
        direction=GeneralMethods.getDirection(location,firstdestination).normalize();
      }
 else {
        direction=GeneralMethods.getDirection(location,destination).normalize();
      }
      location=location.clone().add(direction);
      WaterMethods.removeWaterSpouts(location,player);
      AirMethods.removeAirSpouts(location,player);
      Block block=location.getBlock();
      if (block.getLocation().equals(sourceblock.getLocation())) {
        location=location.clone().add(direction);
        block=location.getBlock();
      }
      if (EarthMethods.isTransparentToEarthbending(player,block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (!settingup) {
        breakBlock();
        return false;
      }
 else {
        location=location.clone().subtract(direction);
        direction=GeneralMethods.getDirection(location,destination).normalize();
        location=location.clone().add(direction);
        WaterMethods.removeWaterSpouts(location,player);
        AirMethods.removeAirSpouts(location,player);
        double radius=FireBlast.AFFECTING_RADIUS;
        Player source=player;
        if (EarthBlast.annihilateBlasts(location,radius,source) || WaterManipulation.annihilateBlasts(location,radius,source) || FireBlast.annihilateBlasts(location,radius,source)) {
          breakBlock();
          return false;
        }
        Combustion.removeAroundPoint(location,radius);
        Block block2=location.getBlock();
        if (block2.getLocation().equals(sourceblock.getLocation())) {
          location=location.clone().add(direction);
          block2=location.getBlock();
        }
        if (EarthMethods.isTransparentToEarthbending(player,block) && !block.isLiquid()) {
          GeneralMethods.breakBlock(block);
        }
 else {
          breakBlock();
          return false;
        }
      }
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(location,FireBlast.AFFECTING_RADIUS)) {
        if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",entity.getLocation()))         continue;
        if (entity instanceof LivingEntity && (entity.getEntityId() != player.getEntityId() || hitself)) {
          AirMethods.breakBreathbendingHold(entity);
          Location location=player.getEyeLocation();
          Vector vector=location.getDirection();
          entity.setVelocity(vector.normalize().multiply(pushfactor));
          double damage=this.damage;
          if (EarthMethods.isMetal(sourceblock) && EarthMethods.canMetalbend(player)) {
            damage=EarthMethods.getMetalAugment(this.damage);
          }
          GeneralMethods.damageEntity(player,entity,damage,""String_Node_Str"");
          progressing=false;
        }
      }
      if (!progressing) {
        breakBlock();
        return false;
      }
      if (revert) {
        if (sourceblock.getType() == Material.RED_SANDSTONE) {
          sourceblock.setType(sourcetype);
          if (sourcetype == Material.SAND)           sourceblock.setData((byte)0x1);
        }
 else {
          sourceblock.setType(sourcetype);
        }
        EarthMethods.moveEarthBlock(sourceblock,block);
        if (block.getType() == Material.SAND)         block.setType(Material.SANDSTONE);
        if (block.getType() == Material.GRAVEL)         block.setType(Material.STONE);
      }
 else {
        block.setType(sourceblock.getType());
        sourceblock.setType(Material.AIR);
      }
      sourceblock=block;
      if (location.distance(destination) < 1) {
        if (sourcetype == Material.SAND || sourcetype == Material.GRAVEL) {
          progressing=false;
          if (sourceblock.getType() == Material.RED_SANDSTONE) {
            sourcetype=Material.SAND;
            sourceblock.setType(sourcetype);
            sourceblock.setData((byte)0x1);
          }
 else {
            sourceblock.setType(sourcetype);
          }
        }
        falling=true;
        progressing=false;
      }
      return true;
    }
  }
  return false;
}","@SuppressWarnings(""String_Node_Str"") private boolean progress(){
  if (player.isDead() || !player.isOnline() || !GeneralMethods.canBend(player.getName(),""String_Node_Str"")) {
    breakBlock();
    return false;
  }
  if (System.currentTimeMillis() - time >= interval) {
    time=System.currentTimeMillis();
    if (falling) {
      breakBlock();
      return false;
    }
    if (!EarthMethods.isEarthbendable(player,sourceblock) && sourceblock.getType() != Material.COBBLESTONE) {
      instances.remove(id);
      return false;
    }
    if (!progressing && !falling) {
      if (GeneralMethods.getBoundAbility(player) == null) {
        unfocusBlock();
        return false;
      }
      if (!GeneralMethods.getBoundAbility(player).equalsIgnoreCase(""String_Node_Str"")) {
        unfocusBlock();
        return false;
      }
      if (sourceblock == null) {
        instances.remove(id);
        return false;
      }
      if (!player.getWorld().equals(sourceblock.getWorld())) {
        unfocusBlock();
        return false;
      }
      if (sourceblock.getLocation().distance(player.getLocation()) > preparerange) {
        unfocusBlock();
        return false;
      }
    }
    if (falling) {
      breakBlock();
    }
 else {
      if (!progressing) {
        return false;
      }
      if (sourceblock.getY() == firstdestination.getBlockY())       settingup=false;
      Vector direction;
      if (settingup) {
        direction=GeneralMethods.getDirection(location,firstdestination).normalize();
      }
 else {
        direction=GeneralMethods.getDirection(location,destination).normalize();
      }
      location=location.clone().add(direction);
      WaterMethods.removeWaterSpouts(location,player);
      AirMethods.removeAirSpouts(location,player);
      Block block=location.getBlock();
      if (block.getLocation().equals(sourceblock.getLocation())) {
        location=location.clone().add(direction);
        block=location.getBlock();
      }
      if (EarthMethods.isTransparentToEarthbending(player,block) && !block.isLiquid()) {
        GeneralMethods.breakBlock(block);
      }
 else       if (!settingup) {
        breakBlock();
        return false;
      }
 else {
        location=location.clone().subtract(direction);
        direction=GeneralMethods.getDirection(location,destination).normalize();
        location=location.clone().add(direction);
        WaterMethods.removeWaterSpouts(location,player);
        AirMethods.removeAirSpouts(location,player);
        double radius=FireBlast.AFFECTING_RADIUS;
        Player source=player;
        if (EarthBlast.annihilateBlasts(location,radius,source) || WaterManipulation.annihilateBlasts(location,radius,source) || FireBlast.annihilateBlasts(location,radius,source)) {
          breakBlock();
          return false;
        }
        Combustion.removeAroundPoint(location,radius);
        Block block2=location.getBlock();
        if (block2.getLocation().equals(sourceblock.getLocation())) {
          location=location.clone().add(direction);
          block2=location.getBlock();
        }
        if (EarthMethods.isTransparentToEarthbending(player,block) && !block.isLiquid()) {
          GeneralMethods.breakBlock(block);
        }
 else {
          breakBlock();
          return false;
        }
      }
      for (      Entity entity : GeneralMethods.getEntitiesAroundPoint(location,FireBlast.AFFECTING_RADIUS)) {
        if (GeneralMethods.isRegionProtectedFromBuild(player,""String_Node_Str"",entity.getLocation()))         continue;
        if (entity instanceof LivingEntity && (entity.getEntityId() != player.getEntityId() || hitself)) {
          AirMethods.breakBreathbendingHold(entity);
          Location location=player.getEyeLocation();
          Vector vector=location.getDirection();
          entity.setVelocity(vector.normalize().multiply(pushfactor));
          double damage=this.damage;
          if (EarthMethods.isMetal(sourceblock) && EarthMethods.canMetalbend(player)) {
            damage=EarthMethods.getMetalAugment(this.damage);
          }
          GeneralMethods.damageEntity(player,entity,damage,""String_Node_Str"");
          progressing=false;
        }
      }
      if (!progressing) {
        breakBlock();
        return false;
      }
      if (revert) {
        if (sourceblock.getType() == Material.RED_SANDSTONE) {
          sourceblock.setType(sourcetype);
          if (sourcetype == Material.SAND)           sourceblock.setData((byte)0x1);
        }
 else {
          sourceblock.setType(sourcetype);
        }
        EarthMethods.moveEarthBlock(sourceblock,block);
        if (block.getType() == Material.SAND)         block.setType(Material.SANDSTONE);
        if (block.getType() == Material.GRAVEL)         block.setType(Material.STONE);
      }
 else {
        block.setType(sourceblock.getType());
        sourceblock.setType(Material.AIR);
      }
      sourceblock=block;
      if (location.distance(destination) < 1) {
        if (sourcetype == Material.SAND || sourcetype == Material.GRAVEL) {
          progressing=false;
          if (sourceblock.getType() == Material.RED_SANDSTONE) {
            sourcetype=Material.SAND;
            sourceblock.setType(sourcetype);
            sourceblock.setData((byte)0x1);
          }
 else {
            sourceblock.setType(sourcetype);
          }
        }
        falling=true;
        progressing=false;
      }
      return true;
    }
  }
  return false;
}",0.9965970753241976
133999,"public static boolean softenLanding(Player player){
  Block block=player.getLocation().getBlock().getRelative(BlockFace.DOWN);
  if (EarthMethods.canMetalbend(player) && EarthMethods.isMetalBlock(block)) {
    return true;
  }
  if (EarthMethods.isEarthbendable(player,block) || EarthMethods.isTransparentToEarthbending(player,block)) {
    if (!EarthMethods.isTransparentToEarthbending(player,block)) {
      MaterialData type=block.getState().getData();
      if (GeneralMethods.isSolid(block.getRelative(BlockFace.DOWN))) {
        if (type.getItemType() == Material.RED_SANDSTONE) {
          byte data=(byte)0x1;
          block.setType(Material.SAND);
          block.setData(data);
        }
 else {
          block.setType(Material.SAND);
        }
        if (!sandblocks.containsKey(block)) {
          sandidentities.put(block,type);
          sandblocks.put(block,System.currentTimeMillis());
        }
      }
    }
    for (    Block affectedBlock : GeneralMethods.getBlocksAroundPoint(block.getLocation(),2)) {
      if (EarthMethods.isEarthbendable(player,affectedBlock)) {
        if (GeneralMethods.isSolid(affectedBlock.getRelative(BlockFace.DOWN))) {
          MaterialData type=affectedBlock.getState().getData();
          if (type.getItemType() == Material.RED_SANDSTONE) {
            byte data=(byte)0x1;
            affectedBlock.setType(Material.SAND);
            affectedBlock.setData(data);
          }
 else {
            affectedBlock.setType(Material.SAND);
          }
          if (!sandblocks.containsKey(affectedBlock)) {
            sandidentities.putIfAbsent(affectedBlock,type);
            sandblocks.put(affectedBlock,System.currentTimeMillis());
          }
        }
      }
    }
    return true;
  }
  if (EarthMethods.isEarthbendable(player,block) || EarthMethods.isTransparentToEarthbending(player,block)) {
    return true;
  }
  return false;
}","@SuppressWarnings(""String_Node_Str"") public static boolean softenLanding(Player player){
  Block block=player.getLocation().getBlock().getRelative(BlockFace.DOWN);
  if (EarthMethods.canMetalbend(player) && EarthMethods.isMetalBlock(block)) {
    return true;
  }
  if (EarthMethods.isEarthbendable(player,block) || EarthMethods.isTransparentToEarthbending(player,block)) {
    if (!EarthMethods.isTransparentToEarthbending(player,block)) {
      MaterialData type=block.getState().getData();
      if (GeneralMethods.isSolid(block.getRelative(BlockFace.DOWN))) {
        if (type.getItemType() == Material.RED_SANDSTONE) {
          byte data=(byte)0x1;
          block.setType(Material.SAND);
          block.setData(data);
        }
 else {
          block.setType(Material.SAND);
        }
        if (!sandblocks.containsKey(block)) {
          sandidentities.put(block,type);
          sandblocks.put(block,System.currentTimeMillis());
        }
      }
    }
    for (    Block affectedBlock : GeneralMethods.getBlocksAroundPoint(block.getLocation(),2)) {
      if (EarthMethods.isEarthbendable(player,affectedBlock)) {
        if (GeneralMethods.isSolid(affectedBlock.getRelative(BlockFace.DOWN))) {
          MaterialData type=affectedBlock.getState().getData();
          if (type.getItemType() == Material.RED_SANDSTONE) {
            byte data=(byte)0x1;
            affectedBlock.setType(Material.SAND);
            affectedBlock.setData(data);
          }
 else {
            affectedBlock.setType(Material.SAND);
          }
          if (!sandblocks.containsKey(affectedBlock)) {
            sandidentities.putIfAbsent(affectedBlock,type);
            sandblocks.put(affectedBlock,System.currentTimeMillis());
          }
        }
      }
    }
    return true;
  }
  if (EarthMethods.isEarthbendable(player,block) || EarthMethods.isTransparentToEarthbending(player,block)) {
    return true;
  }
  return false;
}",0.9903267973856208
134000,"public static void revertSand(Block block){
  MaterialData materialdata=sandidentities.get(block);
  sandidentities.remove(block);
  sandblocks.remove(block);
  if (block.getType() == Material.SAND) {
    block.setType(materialdata.getItemType());
    block.setData(materialdata.getData());
  }
}","@SuppressWarnings(""String_Node_Str"") public static void revertSand(Block block){
  MaterialData materialdata=sandidentities.get(block);
  sandidentities.remove(block);
  sandblocks.remove(block);
  if (block.getType() == Material.SAND) {
    block.setType(materialdata.getItemType());
    block.setData(materialdata.getData());
  }
}",0.9411764705882352
